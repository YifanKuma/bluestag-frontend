<html>
<head>
<title>preview1.mjs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
preview1.mjs</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">{ _WebAssembly } from </span><span class="s2">&quot;../webassembly.mjs&quot;</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ resolve } from </span><span class="s2">&quot;./path.mjs&quot;</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ WasiErrno, WasiRights, FileControlFlag, WasiFileControlFlag, WasiFdFlag, WasiFileType, WasiClockid, WasiFstFlag, WasiEventType, WasiSubclockflags } from </span><span class="s2">&quot;./types.mjs&quot;</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ concatBuffer, toFileStat, AsyncTable, SyncTable } from </span><span class="s2">&quot;./fd.mjs&quot;</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ WasiError } from </span><span class="s2">&quot;./error.mjs&quot;</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ isPromiseLike, sleepBreakIf, unsharedSlice } from </span><span class="s2">&quot;./util.mjs&quot;</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ getRights } from </span><span class="s2">&quot;./rights.mjs&quot;</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ extendMemory } from </span><span class="s2">&quot;../memory.mjs&quot;</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ wrapAsyncImport } from </span><span class="s2">&quot;../jspi.mjs&quot;</span><span class="s1">;</span>
<span class="s0">function </span><span class="s1">copyMemory(targets, src) {</span>
    <span class="s0">if </span><span class="s1">(targets.length === </span><span class="s3">0 </span><span class="s1">|| src.length === </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s0">let </span><span class="s1">copied = </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s0">let </span><span class="s1">left = src.length - copied;</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">; i &lt; targets.length; ++i) {</span>
        <span class="s0">const </span><span class="s1">target = targets[i];</span>
        <span class="s0">if </span><span class="s1">(left &lt; target.length) {</span>
            <span class="s1">target.set(src.subarray(copied, copied + left), </span><span class="s3">0</span><span class="s1">);</span>
            <span class="s1">copied += left;</span>
            <span class="s1">left = </span><span class="s3">0</span><span class="s1">;</span>
            <span class="s0">return </span><span class="s1">copied;</span>
        <span class="s1">}</span>
        <span class="s1">target.set(src.subarray(copied, copied + target.length), </span><span class="s3">0</span><span class="s1">);</span>
        <span class="s1">copied += target.length;</span>
        <span class="s1">left -= target.length;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">copied;</span>
<span class="s1">}</span>
<span class="s0">const </span><span class="s1">_memory = </span><span class="s0">new </span><span class="s1">WeakMap();</span>
<span class="s0">const </span><span class="s1">_wasi = </span><span class="s0">new </span><span class="s1">WeakMap();</span>
<span class="s0">const </span><span class="s1">_fs = </span><span class="s0">new </span><span class="s1">WeakMap();</span>
<span class="s0">function </span><span class="s1">getMemory(wasi) {</span>
    <span class="s0">return </span><span class="s1">_memory.get(wasi);</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">getFs(wasi) {</span>
    <span class="s0">const </span><span class="s1">fs = _fs.get(wasi);</span>
    <span class="s0">if </span><span class="s1">(!fs)</span>
        <span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">'filesystem is unavailable'</span><span class="s1">);</span>
    <span class="s0">return </span><span class="s1">fs;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">handleError(err) {</span>
    <span class="s0">if </span><span class="s1">(err </span><span class="s0">instanceof </span><span class="s1">WasiError) {</span>
        <span class="s0">if </span><span class="s1">(process.env.NODE_ENV !== </span><span class="s2">'production'</span><span class="s1">) {</span>
            <span class="s1">console.warn(err);</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">err.errno;</span>
    <span class="s1">}</span>
    <span class="s0">switch </span><span class="s1">(err.code) {</span>
        <span class="s0">case </span><span class="s2">'ENOENT'</span><span class="s1">: </span><span class="s0">return </span><span class="s1">WasiErrno.ENOENT;</span>
        <span class="s0">case </span><span class="s2">'EBADF'</span><span class="s1">: </span><span class="s0">return </span><span class="s1">WasiErrno.EBADF;</span>
        <span class="s0">case </span><span class="s2">'EINVAL'</span><span class="s1">: </span><span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
        <span class="s0">case </span><span class="s2">'EPERM'</span><span class="s1">: </span><span class="s0">return </span><span class="s1">WasiErrno.EPERM;</span>
        <span class="s0">case </span><span class="s2">'EPROTO'</span><span class="s1">: </span><span class="s0">return </span><span class="s1">WasiErrno.EPROTO;</span>
        <span class="s0">case </span><span class="s2">'EEXIST'</span><span class="s1">: </span><span class="s0">return </span><span class="s1">WasiErrno.EEXIST;</span>
        <span class="s0">case </span><span class="s2">'ENOTDIR'</span><span class="s1">: </span><span class="s0">return </span><span class="s1">WasiErrno.ENOTDIR;</span>
        <span class="s0">case </span><span class="s2">'EMFILE'</span><span class="s1">: </span><span class="s0">return </span><span class="s1">WasiErrno.EMFILE;</span>
        <span class="s0">case </span><span class="s2">'EACCES'</span><span class="s1">: </span><span class="s0">return </span><span class="s1">WasiErrno.EACCES;</span>
        <span class="s0">case </span><span class="s2">'EISDIR'</span><span class="s1">: </span><span class="s0">return </span><span class="s1">WasiErrno.EISDIR;</span>
        <span class="s0">case </span><span class="s2">'ENOTEMPTY'</span><span class="s1">: </span><span class="s0">return </span><span class="s1">WasiErrno.ENOTEMPTY;</span>
        <span class="s0">case </span><span class="s2">'ENOSYS'</span><span class="s1">: </span><span class="s0">return </span><span class="s1">WasiErrno.ENOSYS;</span>
    <span class="s1">}</span>
    <span class="s0">throw </span><span class="s1">err;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">defineName(name, f) {</span>
    <span class="s1">Object.defineProperty(f, </span><span class="s2">'name'</span><span class="s1">, { value: name });</span>
    <span class="s0">return </span><span class="s1">f;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">tryCall(f, wasi, args) {</span>
    <span class="s0">let </span><span class="s1">r;</span>
    <span class="s0">try </span><span class="s1">{</span>
        <span class="s1">r = f.apply(wasi, args);</span>
    <span class="s1">}</span>
    <span class="s0">catch </span><span class="s1">(err) {</span>
        <span class="s0">return </span><span class="s1">handleError(err);</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(isPromiseLike(r)) {</span>
        <span class="s0">return </span><span class="s1">r.then(_ =&gt; _, handleError);</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">r;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">syscallWrap(self, name, f) {</span>
    <span class="s0">let </span><span class="s1">debug = </span><span class="s0">false</span><span class="s1">;</span>
    <span class="s0">const </span><span class="s1">NODE_DEBUG_NATIVE = (() =&gt; {</span>
        <span class="s0">try </span><span class="s1">{</span>
            <span class="s0">return </span><span class="s1">process.env.NODE_DEBUG_NATIVE;</span>
        <span class="s1">}</span>
        <span class="s0">catch </span><span class="s1">(_) {</span>
            <span class="s0">return </span><span class="s1">undefined;</span>
        <span class="s1">}</span>
    <span class="s1">})();</span>
    <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">NODE_DEBUG_NATIVE === </span><span class="s2">'string' </span><span class="s1">&amp;&amp; NODE_DEBUG_NATIVE.split(</span><span class="s2">','</span><span class="s1">).includes(</span><span class="s2">'wasi'</span><span class="s1">)) {</span>
        <span class="s1">debug = </span><span class="s0">true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">debug</span>
        <span class="s1">? defineName(name, </span><span class="s0">function </span><span class="s1">() {</span>
            <span class="s0">const </span><span class="s1">args = Array.prototype.slice.call(arguments);</span>
            <span class="s0">let </span><span class="s1">debugArgs = [</span><span class="s2">`</span><span class="s1">${name}</span><span class="s2">(</span><span class="s1">${Array.from({ length: arguments.length }).map(() =&gt; </span><span class="s2">'%d'</span><span class="s1">).join(</span><span class="s2">', '</span><span class="s1">)}</span><span class="s2">)`</span><span class="s1">];</span>
            <span class="s1">debugArgs = debugArgs.concat(args);</span>
            <span class="s1">console.debug.apply(console, debugArgs);</span>
            <span class="s0">return </span><span class="s1">tryCall(f, self, args);</span>
        <span class="s1">})</span>
        <span class="s1">: defineName(name, </span><span class="s0">function </span><span class="s1">() {</span>
            <span class="s0">return </span><span class="s1">tryCall(f, self, arguments);</span>
        <span class="s1">});</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">resolvePathSync(fs, fileDescriptor, path, flags) {</span>
    <span class="s0">let </span><span class="s1">resolvedPath = resolve(fileDescriptor.realPath, path);</span>
    <span class="s0">if </span><span class="s1">((flags &amp; </span><span class="s3">1</span><span class="s1">) === </span><span class="s3">1</span><span class="s1">) {</span>
        <span class="s0">try </span><span class="s1">{</span>
            <span class="s1">resolvedPath = fs.readlinkSync(resolvedPath);</span>
        <span class="s1">}</span>
        <span class="s0">catch </span><span class="s1">(err) {</span>
            <span class="s0">if </span><span class="s1">(err.code !== </span><span class="s2">'EINVAL' </span><span class="s1">&amp;&amp; err.code !== </span><span class="s2">'ENOENT'</span><span class="s1">) {</span>
                <span class="s0">throw </span><span class="s1">err;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">resolvedPath;</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s0">function </span><span class="s1">resolvePathAsync(fs, fileDescriptor, path, flags) {</span>
    <span class="s0">let </span><span class="s1">resolvedPath = resolve(fileDescriptor.realPath, path);</span>
    <span class="s0">if </span><span class="s1">((flags &amp; </span><span class="s3">1</span><span class="s1">) === </span><span class="s3">1</span><span class="s1">) {</span>
        <span class="s0">try </span><span class="s1">{</span>
            <span class="s1">resolvedPath = </span><span class="s0">await </span><span class="s1">fs.promises.readlink(resolvedPath);</span>
        <span class="s1">}</span>
        <span class="s0">catch </span><span class="s1">(err) {</span>
            <span class="s0">if </span><span class="s1">(err.code !== </span><span class="s2">'EINVAL' </span><span class="s1">&amp;&amp; err.code !== </span><span class="s2">'ENOENT'</span><span class="s1">) {</span>
                <span class="s0">throw </span><span class="s1">err;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">resolvedPath;</span>
<span class="s1">}</span>
<span class="s4">// eslint-disable-next-line spaced-comment</span>
<span class="s0">const </span><span class="s1">encoder = </span><span class="s4">/*#__PURE__*/ </span><span class="s0">new </span><span class="s1">TextEncoder();</span>
<span class="s4">// eslint-disable-next-line spaced-comment</span>
<span class="s0">const </span><span class="s1">decoder = </span><span class="s4">/*#__PURE__*/ </span><span class="s0">new </span><span class="s1">TextDecoder();</span>
<span class="s0">const </span><span class="s1">INT64_MAX = (BigInt(</span><span class="s3">1</span><span class="s1">) &lt;&lt; BigInt(</span><span class="s3">63</span><span class="s1">)) - BigInt(</span><span class="s3">1</span><span class="s1">);</span>
<span class="s0">function </span><span class="s1">readStdin() {</span>
    <span class="s0">const </span><span class="s1">value = window.prompt();</span>
    <span class="s0">if </span><span class="s1">(value === </span><span class="s0">null</span><span class="s1">)</span>
        <span class="s0">return new </span><span class="s1">Uint8Array();</span>
    <span class="s0">const </span><span class="s1">buffer = </span><span class="s0">new </span><span class="s1">TextEncoder().encode(value + </span><span class="s2">'</span><span class="s5">\n</span><span class="s2">'</span><span class="s1">);</span>
    <span class="s0">return </span><span class="s1">buffer;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">validateFstFlagsOrReturn(flags) {</span>
    <span class="s0">return </span><span class="s1">(Boolean((flags) &amp; ~(WasiFstFlag.SET_ATIM | WasiFstFlag.SET_ATIM_NOW |</span>
        <span class="s1">WasiFstFlag.SET_MTIM | WasiFstFlag.SET_MTIM_NOW)) ||</span>
        <span class="s1">((flags) &amp; (WasiFstFlag.SET_ATIM | WasiFstFlag.SET_ATIM_NOW)) ===</span>
            <span class="s1">(WasiFstFlag.SET_ATIM | WasiFstFlag.SET_ATIM_NOW) ||</span>
        <span class="s1">((flags) &amp; (WasiFstFlag.SET_MTIM | WasiFstFlag.SET_MTIM_NOW)) ===</span>
            <span class="s1">(WasiFstFlag.SET_MTIM | WasiFstFlag.SET_MTIM_NOW));</span>
<span class="s1">}</span>
<span class="s0">export class </span><span class="s1">WASI {</span>
    <span class="s1">constructor(args, env, fds, asyncFs, fs, asyncify) {</span>
        <span class="s0">this</span><span class="s1">.args_get = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'args_get'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">(argv, argv_buf) {</span>
            <span class="s1">argv = Number(argv);</span>
            <span class="s1">argv_buf = Number(argv_buf);</span>
            <span class="s0">if </span><span class="s1">(argv === </span><span class="s3">0 </span><span class="s1">|| argv_buf === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8, view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">args = wasi.args;</span>
            <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">; i &lt; args.length; ++i) {</span>
                <span class="s0">const </span><span class="s1">arg = args[i];</span>
                <span class="s1">view.setInt32(argv, argv_buf, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s1">argv += </span><span class="s3">4</span><span class="s1">;</span>
                <span class="s0">const </span><span class="s1">data = encoder.encode(arg + </span><span class="s2">'</span><span class="s5">\0</span><span class="s2">'</span><span class="s1">);</span>
                <span class="s1">HEAPU8.set(data, argv_buf);</span>
                <span class="s1">argv_buf += data.length;</span>
            <span class="s1">}</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.args_sizes_get = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'args_sizes_get'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">(argc, argv_buf_size) {</span>
            <span class="s1">argc = Number(argc);</span>
            <span class="s1">argv_buf_size = Number(argv_buf_size);</span>
            <span class="s0">if </span><span class="s1">(argc === </span><span class="s3">0 </span><span class="s1">|| argv_buf_size === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">args = wasi.args;</span>
            <span class="s1">view.setUint32(argc, args.length, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s1">view.setUint32(argv_buf_size, encoder.encode(args.join(</span><span class="s2">'</span><span class="s5">\0</span><span class="s2">'</span><span class="s1">) + </span><span class="s2">'</span><span class="s5">\0</span><span class="s2">'</span><span class="s1">).length, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.environ_get = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'environ_get'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">(environ, environ_buf) {</span>
            <span class="s1">environ = Number(environ);</span>
            <span class="s1">environ_buf = Number(environ_buf);</span>
            <span class="s0">if </span><span class="s1">(environ === </span><span class="s3">0 </span><span class="s1">|| environ_buf === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8, view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">env = wasi.env;</span>
            <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">; i &lt; env.length; ++i) {</span>
                <span class="s0">const </span><span class="s1">pair = env[i];</span>
                <span class="s1">view.setInt32(environ, environ_buf, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s1">environ += </span><span class="s3">4</span><span class="s1">;</span>
                <span class="s0">const </span><span class="s1">data = encoder.encode(pair + </span><span class="s2">'</span><span class="s5">\0</span><span class="s2">'</span><span class="s1">);</span>
                <span class="s1">HEAPU8.set(data, environ_buf);</span>
                <span class="s1">environ_buf += data.length;</span>
            <span class="s1">}</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.environ_sizes_get = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'environ_sizes_get'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">(len, buflen) {</span>
            <span class="s1">len = Number(len);</span>
            <span class="s1">buflen = Number(buflen);</span>
            <span class="s0">if </span><span class="s1">(len === </span><span class="s3">0 </span><span class="s1">|| buflen === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">view.setUint32(len, wasi.env.length, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s1">view.setUint32(buflen, encoder.encode(wasi.env.join(</span><span class="s2">'</span><span class="s5">\0</span><span class="s2">'</span><span class="s1">) + </span><span class="s2">'</span><span class="s5">\0</span><span class="s2">'</span><span class="s1">).length, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.clock_res_get = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'clock_res_get'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">(id, resolution) {</span>
            <span class="s1">resolution = Number(resolution);</span>
            <span class="s0">if </span><span class="s1">(resolution === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">switch </span><span class="s1">(id) {</span>
                <span class="s0">case </span><span class="s1">WasiClockid.REALTIME:</span>
                    <span class="s1">view.setBigUint64(resolution, BigInt(</span><span class="s3">1000000</span><span class="s1">), </span><span class="s0">true</span><span class="s1">);</span>
                    <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
                <span class="s0">case </span><span class="s1">WasiClockid.MONOTONIC:</span>
                <span class="s0">case </span><span class="s1">WasiClockid.PROCESS_CPUTIME_ID:</span>
                <span class="s0">case </span><span class="s1">WasiClockid.THREAD_CPUTIME_ID:</span>
                    <span class="s1">view.setBigUint64(resolution, BigInt(</span><span class="s3">1000</span><span class="s1">), </span><span class="s0">true</span><span class="s1">);</span>
                    <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
                <span class="s0">default</span><span class="s1">: </span><span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.clock_time_get = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'clock_time_get'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">(id, _percision, time) {</span>
            <span class="s1">time = Number(time);</span>
            <span class="s0">if </span><span class="s1">(time === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">switch </span><span class="s1">(id) {</span>
                <span class="s0">case </span><span class="s1">WasiClockid.REALTIME:</span>
                    <span class="s1">view.setBigUint64(time, BigInt(Date.now()) * BigInt(</span><span class="s3">1000000</span><span class="s1">), </span><span class="s0">true</span><span class="s1">);</span>
                    <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
                <span class="s0">case </span><span class="s1">WasiClockid.MONOTONIC:</span>
                <span class="s0">case </span><span class="s1">WasiClockid.PROCESS_CPUTIME_ID:</span>
                <span class="s0">case </span><span class="s1">WasiClockid.THREAD_CPUTIME_ID: {</span>
                    <span class="s0">const </span><span class="s1">t = performance.now() / </span><span class="s3">1000</span><span class="s1">;</span>
                    <span class="s0">const </span><span class="s1">s = Math.trunc(t);</span>
                    <span class="s0">const </span><span class="s1">ms = Math.floor((t - s) * </span><span class="s3">1000</span><span class="s1">);</span>
                    <span class="s0">const </span><span class="s1">result = BigInt(s) * BigInt(</span><span class="s3">1000000000</span><span class="s1">) + BigInt(ms) * BigInt(</span><span class="s3">1000000</span><span class="s1">);</span>
                    <span class="s1">view.setBigUint64(time, result, </span><span class="s0">true</span><span class="s1">);</span>
                    <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
                <span class="s1">}</span>
                <span class="s0">default</span><span class="s1">: </span><span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.fd_advise = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'fd_advise'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">(_fd, _offset, _len, _advice) {</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ENOSYS;</span>
        <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.fd_fdstat_get = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'fd_fdstat_get'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">(fd, fdstat) {</span>
            <span class="s1">fdstat = Number(fdstat);</span>
            <span class="s0">if </span><span class="s1">(fdstat === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, BigInt(</span><span class="s3">0</span><span class="s1">), BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s0">const </span><span class="s1">{ view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">view.setUint16(fdstat, fileDescriptor.type, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s1">view.setUint16(fdstat + </span><span class="s3">2</span><span class="s1">, </span><span class="s3">0</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s1">view.setBigUint64(fdstat + </span><span class="s3">8</span><span class="s1">, fileDescriptor.rightsBase, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s1">view.setBigUint64(fdstat + </span><span class="s3">16</span><span class="s1">, fileDescriptor.rightsInheriting, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.fd_fdstat_set_flags = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'fd_fdstat_set_flags'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">(_fd, _flags) {</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ENOSYS;</span>
        <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.fd_fdstat_set_rights = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'fd_fdstat_set_rights'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">(fd, rightsBase, rightsInheriting) {</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, BigInt(</span><span class="s3">0</span><span class="s1">), BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s0">if </span><span class="s1">((rightsBase | fileDescriptor.rightsBase) &gt; fileDescriptor.rightsBase) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.ENOTCAPABLE;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">((rightsInheriting | fileDescriptor.rightsInheriting) &gt;</span>
                <span class="s1">fileDescriptor.rightsInheriting) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.ENOTCAPABLE;</span>
            <span class="s1">}</span>
            <span class="s1">fileDescriptor.rightsBase = rightsBase;</span>
            <span class="s1">fileDescriptor.rightsInheriting = rightsInheriting;</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.fd_prestat_get = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'fd_prestat_get'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">(fd, prestat) {</span>
            <span class="s1">prestat = Number(prestat);</span>
            <span class="s0">if </span><span class="s1">(prestat === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">let </span><span class="s1">fileDescriptor;</span>
            <span class="s0">try </span><span class="s1">{</span>
                <span class="s1">fileDescriptor = wasi.fds.get(fd, BigInt(</span><span class="s3">0</span><span class="s1">), BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s0">catch </span><span class="s1">(err) {</span>
                <span class="s0">if </span><span class="s1">(err </span><span class="s0">instanceof </span><span class="s1">WasiError)</span>
                    <span class="s0">return </span><span class="s1">err.errno;</span>
                <span class="s0">throw </span><span class="s1">err;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">(fileDescriptor.preopen !== </span><span class="s3">1</span><span class="s1">)</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s0">const </span><span class="s1">{ view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s4">// preopen type is dir(0)</span>
            <span class="s1">view.setUint32(prestat, </span><span class="s3">0</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s1">view.setUint32(prestat + </span><span class="s3">4</span><span class="s1">, encoder.encode(fileDescriptor.path).length, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.fd_prestat_dir_name = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'fd_prestat_dir_name'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">(fd, path, path_len) {</span>
            <span class="s1">path = Number(path);</span>
            <span class="s1">path_len = Number(path_len);</span>
            <span class="s0">if </span><span class="s1">(path === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, BigInt(</span><span class="s3">0</span><span class="s1">), BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s0">if </span><span class="s1">(fileDescriptor.preopen !== </span><span class="s3">1</span><span class="s1">)</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EBADF;</span>
            <span class="s0">const </span><span class="s1">buffer = encoder.encode(fileDescriptor.path);</span>
            <span class="s0">const </span><span class="s1">size = buffer.length;</span>
            <span class="s0">if </span><span class="s1">(size &gt; path_len)</span>
                <span class="s0">return </span><span class="s1">WasiErrno.ENOBUFS;</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8 } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">HEAPU8.set(buffer, path);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.fd_seek = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'fd_seek'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">(fd, offset, whence, newOffset) {</span>
            <span class="s1">newOffset = Number(newOffset);</span>
            <span class="s0">if </span><span class="s1">(newOffset === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">(fd === </span><span class="s3">0 </span><span class="s1">|| fd === </span><span class="s3">1 </span><span class="s1">|| fd === </span><span class="s3">2</span><span class="s1">)</span>
                <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_SEEK, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s0">const </span><span class="s1">r = fileDescriptor.seek(offset, whence);</span>
            <span class="s0">const </span><span class="s1">{ view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">view.setBigUint64(newOffset, r, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.fd_tell = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'fd_tell'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">(fd, offset) {</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_TELL, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s0">const </span><span class="s1">pos = BigInt(fileDescriptor.pos);</span>
            <span class="s0">const </span><span class="s1">{ view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">view.setBigUint64(Number(offset), pos, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.poll_oneoff = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'poll_oneoff'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">(in_ptr, out_ptr, nsubscriptions, nevents) {</span>
            <span class="s1">in_ptr = Number(in_ptr);</span>
            <span class="s1">out_ptr = Number(out_ptr);</span>
            <span class="s1">nevents = Number(nevents);</span>
            <span class="s1">nsubscriptions = Number(nsubscriptions);</span>
            <span class="s1">nsubscriptions = nsubscriptions &gt;&gt;&gt; </span><span class="s3">0</span><span class="s1">;</span>
            <span class="s0">if </span><span class="s1">(in_ptr === </span><span class="s3">0 </span><span class="s1">|| out_ptr === </span><span class="s3">0 </span><span class="s1">|| nsubscriptions === </span><span class="s3">0 </span><span class="s1">|| nevents === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">view.setUint32(nevents, </span><span class="s3">0</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s0">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">;</span>
            <span class="s0">let </span><span class="s1">timer_userdata = BigInt(</span><span class="s3">0</span><span class="s1">);</span>
            <span class="s0">let </span><span class="s1">cur_timeout = BigInt(</span><span class="s3">0</span><span class="s1">);</span>
            <span class="s0">let </span><span class="s1">has_timeout = </span><span class="s3">0</span><span class="s1">;</span>
            <span class="s0">let </span><span class="s1">min_timeout = BigInt(</span><span class="s3">0</span><span class="s1">);</span>
            <span class="s0">let </span><span class="s1">sub;</span>
            <span class="s0">const </span><span class="s1">subscriptions = Array(nsubscriptions);</span>
            <span class="s0">for </span><span class="s1">(i = </span><span class="s3">0</span><span class="s1">; i &lt; nsubscriptions; i++) {</span>
                <span class="s1">sub = in_ptr + i * </span><span class="s3">48</span><span class="s1">;</span>
                <span class="s0">const </span><span class="s1">userdata = view.getBigUint64(sub, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">type = view.getUint8(sub + </span><span class="s3">8</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">clockIdOrFd = view.getUint32(sub + </span><span class="s3">16</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">timeout = view.getBigUint64(sub + </span><span class="s3">24</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">precision = view.getBigUint64(sub + </span><span class="s3">32</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">flags = view.getUint16(sub + </span><span class="s3">40</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s1">subscriptions[i] = {</span>
                    <span class="s1">userdata,</span>
                    <span class="s1">type,</span>
                    <span class="s1">u: {</span>
                        <span class="s1">clock: {</span>
                            <span class="s1">clock_id: clockIdOrFd,</span>
                            <span class="s1">timeout,</span>
                            <span class="s1">precision,</span>
                            <span class="s1">flags</span>
                        <span class="s1">},</span>
                        <span class="s1">fd_readwrite: {</span>
                            <span class="s1">fd: clockIdOrFd</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">fdevents = [];</span>
            <span class="s0">for </span><span class="s1">(i = </span><span class="s3">0</span><span class="s1">; i &lt; nsubscriptions; i++) {</span>
                <span class="s1">sub = subscriptions[i];</span>
                <span class="s0">switch </span><span class="s1">(sub.type) {</span>
                    <span class="s0">case </span><span class="s1">WasiEventType.CLOCK: {</span>
                        <span class="s0">if </span><span class="s1">(sub.u.clock.flags === WasiSubclockflags.ABSTIME) {</span>
                            <span class="s4">/* Convert absolute time to relative delay. */</span>
                            <span class="s0">const </span><span class="s1">now = BigInt(Date.now()) * BigInt(</span><span class="s3">1000000</span><span class="s1">);</span>
                            <span class="s1">cur_timeout = sub.u.clock.timeout - now;</span>
                        <span class="s1">}</span>
                        <span class="s0">else </span><span class="s1">{</span>
                            <span class="s1">cur_timeout = sub.u.clock.timeout;</span>
                        <span class="s1">}</span>
                        <span class="s0">if </span><span class="s1">(has_timeout === </span><span class="s3">0 </span><span class="s1">|| cur_timeout &lt; min_timeout) {</span>
                            <span class="s1">min_timeout = cur_timeout;</span>
                            <span class="s1">timer_userdata = sub.userdata;</span>
                            <span class="s1">has_timeout = </span><span class="s3">1</span><span class="s1">;</span>
                        <span class="s1">}</span>
                        <span class="s0">break</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s0">case </span><span class="s1">WasiEventType.FD_READ:</span>
                    <span class="s0">case </span><span class="s1">WasiEventType.FD_WRITE:</span>
                        <span class="s1">fdevents.push(sub);</span>
                        <span class="s0">break</span><span class="s1">;</span>
                    <span class="s0">default</span><span class="s1">: </span><span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">(fdevents.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s0">for </span><span class="s1">(i = </span><span class="s3">0</span><span class="s1">; i &lt; fdevents.length; i++) {</span>
                    <span class="s0">const </span><span class="s1">fdevent = fdevents[i];</span>
                    <span class="s0">const </span><span class="s1">event = out_ptr + </span><span class="s3">32 </span><span class="s1">* i;</span>
                    <span class="s1">view.setBigUint64(event, fdevent.userdata, </span><span class="s0">true</span><span class="s1">);</span>
                    <span class="s1">view.setUint32(event + </span><span class="s3">8</span><span class="s1">, WasiErrno.ENOSYS, </span><span class="s0">true</span><span class="s1">);</span>
                    <span class="s1">view.setUint32(event + </span><span class="s3">12</span><span class="s1">, fdevent.type, </span><span class="s0">true</span><span class="s1">);</span>
                    <span class="s1">view.setBigUint64(event + </span><span class="s3">16</span><span class="s1">, BigInt(</span><span class="s3">0</span><span class="s1">), </span><span class="s0">true</span><span class="s1">);</span>
                    <span class="s1">view.setUint16(event + </span><span class="s3">24</span><span class="s1">, </span><span class="s3">0</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                    <span class="s1">view.setUint32(nevents, </span><span class="s3">1</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s1">view.setUint32(nevents, fdevents.length, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">(has_timeout) {</span>
                <span class="s0">const </span><span class="s1">delay = Number(min_timeout / BigInt(</span><span class="s3">1000000</span><span class="s1">));</span>
                <span class="s4">// if (isMainThread || typeof SharedArrayBuffer !== 'function') {</span>
                <span class="s1">sleepBreakIf(delay, () =&gt; </span><span class="s0">false</span><span class="s1">);</span>
                <span class="s4">// } else {</span>
                <span class="s4">//   const buf = new SharedArrayBuffer(4)</span>
                <span class="s4">//   const arr = new Int32Array(buf)</span>
                <span class="s4">//   postMsg({</span>
                <span class="s4">//     __tybys_wasm_util_wasi__: {</span>
                <span class="s4">//       type: 'set-timeout',</span>
                <span class="s4">//       payload: {</span>
                <span class="s4">//         buffer: buf,</span>
                <span class="s4">//         delay</span>
                <span class="s4">//       }</span>
                <span class="s4">//     }</span>
                <span class="s4">//   })</span>
                <span class="s4">//   Atomics.wait(arr, 0, 0)</span>
                <span class="s4">// }</span>
                <span class="s0">const </span><span class="s1">event = out_ptr;</span>
                <span class="s1">view.setBigUint64(event, timer_userdata, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s1">view.setUint32(event + </span><span class="s3">8</span><span class="s1">, WasiErrno.ESUCCESS, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s1">view.setUint32(event + </span><span class="s3">12</span><span class="s1">, WasiEventType.CLOCK, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s1">view.setUint32(nevents, </span><span class="s3">1</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.proc_exit = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'proc_exit'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">(rval) {</span>
            <span class="s0">if </span><span class="s1">((</span><span class="s0">typeof </span><span class="s1">process === </span><span class="s2">'object'</span><span class="s1">) &amp;&amp; (process !== </span><span class="s0">null</span><span class="s1">) &amp;&amp; (</span><span class="s0">typeof </span><span class="s1">process.exit === </span><span class="s2">'function'</span><span class="s1">)) {</span>
                <span class="s1">process.exit(rval);</span>
            <span class="s1">}</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.proc_raise = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'proc_raise'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">(_sig) {</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ENOSYS;</span>
        <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.sched_yield = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'sched_yield'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">() {</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.random_get = </span><span class="s0">typeof </span><span class="s1">crypto !== </span><span class="s2">'undefined' </span><span class="s1">&amp;&amp; </span><span class="s0">typeof </span><span class="s1">crypto.getRandomValues === </span><span class="s2">'function'</span>
            <span class="s1">? syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'random_get'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">(buf, buf_len) {</span>
                <span class="s1">buf = Number(buf);</span>
                <span class="s0">if </span><span class="s1">(buf === </span><span class="s3">0</span><span class="s1">) {</span>
                    <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
                <span class="s1">}</span>
                <span class="s1">buf_len = Number(buf_len);</span>
                <span class="s0">const </span><span class="s1">{ HEAPU8, view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
                <span class="s0">if </span><span class="s1">((</span><span class="s0">typeof </span><span class="s1">SharedArrayBuffer === </span><span class="s2">'function' </span><span class="s1">&amp;&amp; HEAPU8.buffer </span><span class="s0">instanceof </span><span class="s1">SharedArrayBuffer) ||</span>
                    <span class="s1">(Object.prototype.toString.call(HEAPU8.buffer) === </span><span class="s2">'[object SharedArrayBuffer]'</span><span class="s1">)) {</span>
                    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = buf; i &lt; buf + buf_len; ++i) {</span>
                        <span class="s1">view.setUint8(i, Math.floor(Math.random() * </span><span class="s3">256</span><span class="s1">));</span>
                    <span class="s1">}</span>
                    <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
                <span class="s1">}</span>
                <span class="s0">let </span><span class="s1">pos;</span>
                <span class="s0">const </span><span class="s1">stride = </span><span class="s3">65536</span><span class="s1">;</span>
                <span class="s0">for </span><span class="s1">(pos = </span><span class="s3">0</span><span class="s1">; pos + stride &lt; buf_len; pos += stride) {</span>
                    <span class="s1">crypto.getRandomValues(HEAPU8.subarray(buf + pos, buf + pos + stride));</span>
                <span class="s1">}</span>
                <span class="s1">crypto.getRandomValues(HEAPU8.subarray(buf + pos, buf + buf_len));</span>
                <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
            <span class="s1">})</span>
            <span class="s1">: syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'random_get'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">(buf, buf_len) {</span>
                <span class="s1">buf = Number(buf);</span>
                <span class="s0">if </span><span class="s1">(buf === </span><span class="s3">0</span><span class="s1">) {</span>
                    <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
                <span class="s1">}</span>
                <span class="s1">buf_len = Number(buf_len);</span>
                <span class="s0">const </span><span class="s1">{ view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
                <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = buf; i &lt; buf + buf_len; ++i) {</span>
                    <span class="s1">view.setUint8(i, Math.floor(Math.random() * </span><span class="s3">256</span><span class="s1">));</span>
                <span class="s1">}</span>
                <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
            <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.sock_recv = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'sock_recv'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">() {</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ENOTSUP;</span>
        <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.sock_send = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'sock_send'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">() {</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ENOTSUP;</span>
        <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.sock_shutdown = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'sock_shutdown'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">() {</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ENOTSUP;</span>
        <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.sock_accept = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'sock_accept'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">() {</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ENOTSUP;</span>
        <span class="s1">});</span>
        <span class="s1">_wasi.set(</span><span class="s0">this</span><span class="s1">, {</span>
            <span class="s1">fds,</span>
            <span class="s1">args,</span>
            <span class="s1">env</span>
        <span class="s1">});</span>
        <span class="s0">if </span><span class="s1">(fs)</span>
            <span class="s1">_fs.set(</span><span class="s0">this</span><span class="s1">, fs);</span>
        <span class="s4">// eslint-disable-next-line @typescript-eslint/no-this-alias</span>
        <span class="s0">const </span><span class="s1">_this = </span><span class="s0">this</span><span class="s1">;</span>
        <span class="s0">function </span><span class="s1">defineImport(name, syncVersion, asyncVersion, parameterType, returnType) {</span>
            <span class="s0">if </span><span class="s1">(asyncFs) {</span>
                <span class="s0">if </span><span class="s1">(asyncify) {</span>
                    <span class="s1">_this[name] = asyncify.wrapImportFunction(syscallWrap(_this, name, asyncVersion));</span>
                <span class="s1">}</span>
                <span class="s0">else </span><span class="s1">{</span>
                    <span class="s1">_this[name] = wrapAsyncImport(syscallWrap(_this, name, asyncVersion), parameterType, returnType);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">_this[name] = syscallWrap(_this, name, syncVersion);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">defineImport(</span><span class="s2">'fd_allocate'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">fd_allocate(fd, offset, len) {</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_ALLOCATE, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s0">const </span><span class="s1">stat = fs.fstatSync(fileDescriptor.fd, { bigint: </span><span class="s0">true </span><span class="s1">});</span>
            <span class="s0">if </span><span class="s1">(stat.size &lt; offset + len) {</span>
                <span class="s1">fs.ftruncateSync(fileDescriptor.fd, Number(offset + len));</span>
            <span class="s1">}</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">fd_allocate(fd, offset, len) {</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_ALLOCATE, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s0">const </span><span class="s1">h = fileDescriptor.fd;</span>
            <span class="s0">const </span><span class="s1">stat = </span><span class="s0">await </span><span class="s1">h.stat({ bigint: </span><span class="s0">true </span><span class="s1">});</span>
            <span class="s0">if </span><span class="s1">(stat.size &lt; offset + len) {</span>
                <span class="s0">await </span><span class="s1">h.truncate(Number(offset + len));</span>
            <span class="s1">}</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i64'</span><span class="s1">, </span><span class="s2">'f64'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s1">defineImport(</span><span class="s2">'fd_close'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">fd_close(fd) {</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, BigInt(</span><span class="s3">0</span><span class="s1">), BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">fs.closeSync(fileDescriptor.fd);</span>
            <span class="s1">wasi.fds.remove(fd);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">fd_close(fd) {</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, BigInt(</span><span class="s3">0</span><span class="s1">), BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s0">await </span><span class="s1">fileDescriptor.fd.close();</span>
            <span class="s1">wasi.fds.remove(fd);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s1">defineImport(</span><span class="s2">'fd_datasync'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">fd_datasync(fd) {</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_DATASYNC, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">fs.fdatasyncSync(fileDescriptor.fd);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">fd_datasync(fd) {</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_DATASYNC, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s0">await </span><span class="s1">fileDescriptor.fd.datasync();</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s1">defineImport(</span><span class="s2">'fd_filestat_get'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">fd_filestat_get(fd, buf) {</span>
            <span class="s1">buf = Number(buf);</span>
            <span class="s0">if </span><span class="s1">(buf === </span><span class="s3">0</span><span class="s1">)</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_FILESTAT_GET, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">stat = fs.fstatSync(fileDescriptor.fd, { bigint: </span><span class="s0">true </span><span class="s1">});</span>
            <span class="s0">const </span><span class="s1">{ view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">toFileStat(view, buf, stat);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">fd_filestat_get(fd, buf) {</span>
            <span class="s1">buf = Number(buf);</span>
            <span class="s0">if </span><span class="s1">(buf === </span><span class="s3">0</span><span class="s1">)</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_FILESTAT_GET, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s0">const </span><span class="s1">h = fileDescriptor.fd;</span>
            <span class="s0">const </span><span class="s1">stat = </span><span class="s0">await </span><span class="s1">h.stat({ bigint: </span><span class="s0">true </span><span class="s1">});</span>
            <span class="s0">const </span><span class="s1">{ view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">toFileStat(view, buf, stat);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s1">defineImport(</span><span class="s2">'fd_filestat_set_size'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">fd_filestat_set_size(fd, size) {</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_FILESTAT_SET_SIZE, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">fs.ftruncateSync(fileDescriptor.fd, Number(size));</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">fd_filestat_set_size(fd, size) {</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_FILESTAT_SET_SIZE, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s0">const </span><span class="s1">h = fileDescriptor.fd;</span>
            <span class="s0">await </span><span class="s1">h.truncate(Number(size));</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i64'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s0">function </span><span class="s1">fdFilestatGetTimes(fd, atim, mtim, flags) {</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_FILESTAT_SET_TIMES, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s0">if </span><span class="s1">((flags &amp; WasiFstFlag.SET_ATIM_NOW) === WasiFstFlag.SET_ATIM_NOW) {</span>
                <span class="s1">atim = BigInt(Date.now() * </span><span class="s3">1000000</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">((flags &amp; WasiFstFlag.SET_MTIM_NOW) === WasiFstFlag.SET_MTIM_NOW) {</span>
                <span class="s1">mtim = BigInt(Date.now() * </span><span class="s3">1000000</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s0">return </span><span class="s1">{ fileDescriptor, atim, mtim };</span>
        <span class="s1">}</span>
        <span class="s1">defineImport(</span><span class="s2">'fd_filestat_set_times'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">fd_filestat_set_times(fd, atim, mtim, flags) {</span>
            <span class="s0">if </span><span class="s1">(validateFstFlagsOrReturn(flags)) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ fileDescriptor, atim: atimRes, mtim: mtimRes } = fdFilestatGetTimes.call(</span><span class="s0">this</span><span class="s1">, fd, atim, mtim, flags);</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">fs.futimesSync(fileDescriptor.fd, Number(atimRes), Number(mtimRes));</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">fd_filestat_set_times(fd, atim, mtim, flags) {</span>
            <span class="s0">if </span><span class="s1">(validateFstFlagsOrReturn(flags)) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ fileDescriptor, atim: atimRes, mtim: mtimRes } = fdFilestatGetTimes.call(</span><span class="s0">this</span><span class="s1">, fd, atim, mtim, flags);</span>
            <span class="s0">const </span><span class="s1">h = fileDescriptor.fd;</span>
            <span class="s0">await </span><span class="s1">h.utimes(Number(atimRes), Number(mtimRes));</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i64'</span><span class="s1">, </span><span class="s2">'i64'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s1">defineImport(</span><span class="s2">'fd_pread'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">fd_pread(fd, iovs, iovslen, offset, size) {</span>
            <span class="s1">iovs = Number(iovs);</span>
            <span class="s1">size = Number(size);</span>
            <span class="s0">if </span><span class="s1">((iovs === </span><span class="s3">0 </span><span class="s1">&amp;&amp; iovslen) || size === </span><span class="s3">0 </span><span class="s1">|| offset &gt; INT64_MAX) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8, view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_READ | WasiRights.FD_SEEK, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s0">if </span><span class="s1">(!iovslen) {</span>
                <span class="s1">view.setUint32(size, </span><span class="s3">0</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
            <span class="s1">}</span>
            <span class="s0">let </span><span class="s1">totalSize = </span><span class="s3">0</span><span class="s1">;</span>
            <span class="s0">const </span><span class="s1">ioVecs = Array.from({ length: Number(iovslen) }, (_, i) =&gt; {</span>
                <span class="s0">const </span><span class="s1">offset = iovs + (i * </span><span class="s3">8</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">buf = view.getInt32(offset, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">bufLen = view.getUint32(offset + </span><span class="s3">4</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s1">totalSize += bufLen;</span>
                <span class="s0">return </span><span class="s1">HEAPU8.subarray(buf, buf + bufLen);</span>
            <span class="s1">});</span>
            <span class="s0">let </span><span class="s1">nread = </span><span class="s3">0</span><span class="s1">;</span>
            <span class="s0">const </span><span class="s1">buffer = (() =&gt; {</span>
                <span class="s0">try </span><span class="s1">{</span>
                    <span class="s0">return new </span><span class="s1">Uint8Array(</span><span class="s0">new </span><span class="s1">SharedArrayBuffer(totalSize));</span>
                <span class="s1">}</span>
                <span class="s0">catch </span><span class="s1">(_) {</span>
                    <span class="s0">return new </span><span class="s1">Uint8Array(totalSize);</span>
                <span class="s1">}</span>
            <span class="s1">})();</span>
            <span class="s1">buffer._isBuffer = </span><span class="s0">true</span><span class="s1">;</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">bytesRead = fs.readSync(fileDescriptor.fd, buffer, </span><span class="s3">0</span><span class="s1">, buffer.length, Number(offset));</span>
            <span class="s1">nread = buffer ? copyMemory(ioVecs, buffer.subarray(</span><span class="s3">0</span><span class="s1">, bytesRead)) : </span><span class="s3">0</span><span class="s1">;</span>
            <span class="s1">view.setUint32(size, nread, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">(fd, iovs, iovslen, offset, size) {</span>
            <span class="s1">iovs = Number(iovs);</span>
            <span class="s1">size = Number(size);</span>
            <span class="s0">if </span><span class="s1">((iovs === </span><span class="s3">0 </span><span class="s1">&amp;&amp; iovslen) || size === </span><span class="s3">0 </span><span class="s1">|| offset &gt; INT64_MAX) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8, view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_READ | WasiRights.FD_SEEK, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s0">if </span><span class="s1">(!iovslen) {</span>
                <span class="s1">view.setUint32(size, </span><span class="s3">0</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
            <span class="s1">}</span>
            <span class="s0">let </span><span class="s1">totalSize = </span><span class="s3">0</span><span class="s1">;</span>
            <span class="s0">const </span><span class="s1">ioVecs = Array.from({ length: Number(iovslen) }, (_, i) =&gt; {</span>
                <span class="s0">const </span><span class="s1">offset = iovs + (i * </span><span class="s3">8</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">buf = view.getInt32(offset, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">bufLen = view.getUint32(offset + </span><span class="s3">4</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s1">totalSize += bufLen;</span>
                <span class="s0">return </span><span class="s1">HEAPU8.subarray(buf, buf + bufLen);</span>
            <span class="s1">});</span>
            <span class="s0">let </span><span class="s1">nread = </span><span class="s3">0</span><span class="s1">;</span>
            <span class="s0">const </span><span class="s1">buffer = </span><span class="s0">new </span><span class="s1">Uint8Array(totalSize);</span>
            <span class="s1">buffer._isBuffer = </span><span class="s0">true</span><span class="s1">;</span>
            <span class="s0">const </span><span class="s1">{ bytesRead } = </span><span class="s0">await </span><span class="s1">fileDescriptor.fd.read(buffer, </span><span class="s3">0</span><span class="s1">, buffer.length, Number(offset));</span>
            <span class="s1">nread = buffer ? copyMemory(ioVecs, buffer.subarray(</span><span class="s3">0</span><span class="s1">, bytesRead)) : </span><span class="s3">0</span><span class="s1">;</span>
            <span class="s1">view.setUint32(size, nread, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i64'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s1">defineImport(</span><span class="s2">'fd_pwrite'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">fd_pwrite(fd, iovs, iovslen, offset, size) {</span>
            <span class="s1">iovs = Number(iovs);</span>
            <span class="s1">size = Number(size);</span>
            <span class="s0">if </span><span class="s1">((iovs === </span><span class="s3">0 </span><span class="s1">&amp;&amp; iovslen) || size === </span><span class="s3">0 </span><span class="s1">|| offset &gt; INT64_MAX) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8, view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_WRITE | WasiRights.FD_SEEK, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s0">if </span><span class="s1">(!iovslen) {</span>
                <span class="s1">view.setUint32(size, </span><span class="s3">0</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">buffer = concatBuffer(Array.from({ length: Number(iovslen) }, (_, i) =&gt; {</span>
                <span class="s0">const </span><span class="s1">offset = iovs + (i * </span><span class="s3">8</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">buf = view.getInt32(offset, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">bufLen = view.getUint32(offset + </span><span class="s3">4</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">return </span><span class="s1">HEAPU8.subarray(buf, buf + bufLen);</span>
            <span class="s1">}));</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">nwritten = fs.writeSync(fileDescriptor.fd, buffer, </span><span class="s3">0</span><span class="s1">, buffer.length, Number(offset));</span>
            <span class="s1">view.setUint32(size, nwritten, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">fd_pwrite(fd, iovs, iovslen, offset, size) {</span>
            <span class="s1">iovs = Number(iovs);</span>
            <span class="s1">size = Number(size);</span>
            <span class="s0">if </span><span class="s1">((iovs === </span><span class="s3">0 </span><span class="s1">&amp;&amp; iovslen) || size === </span><span class="s3">0 </span><span class="s1">|| offset &gt; INT64_MAX) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8, view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_WRITE | WasiRights.FD_SEEK, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s0">if </span><span class="s1">(!iovslen) {</span>
                <span class="s1">view.setUint32(size, </span><span class="s3">0</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">buffer = concatBuffer(Array.from({ length: Number(iovslen) }, (_, i) =&gt; {</span>
                <span class="s0">const </span><span class="s1">offset = iovs + (i * </span><span class="s3">8</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">buf = view.getInt32(offset, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">bufLen = view.getUint32(offset + </span><span class="s3">4</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">return </span><span class="s1">HEAPU8.subarray(buf, buf + bufLen);</span>
            <span class="s1">}));</span>
            <span class="s0">const </span><span class="s1">{ bytesWritten } = </span><span class="s0">await </span><span class="s1">fileDescriptor.fd.write(buffer, </span><span class="s3">0</span><span class="s1">, buffer.length, Number(offset));</span>
            <span class="s1">view.setUint32(size, bytesWritten, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i64'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s1">defineImport(</span><span class="s2">'fd_read'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">fd_read(fd, iovs, iovslen, size) {</span>
            <span class="s1">iovs = Number(iovs);</span>
            <span class="s1">size = Number(size);</span>
            <span class="s0">if </span><span class="s1">((iovs === </span><span class="s3">0 </span><span class="s1">&amp;&amp; iovslen) || size === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8, view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_READ, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s0">if </span><span class="s1">(!iovslen) {</span>
                <span class="s1">view.setUint32(size, </span><span class="s3">0</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
            <span class="s1">}</span>
            <span class="s0">let </span><span class="s1">totalSize = </span><span class="s3">0</span><span class="s1">;</span>
            <span class="s0">const </span><span class="s1">ioVecs = Array.from({ length: Number(iovslen) }, (_, i) =&gt; {</span>
                <span class="s0">const </span><span class="s1">offset = iovs + (i * </span><span class="s3">8</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">buf = view.getInt32(offset, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">bufLen = view.getUint32(offset + </span><span class="s3">4</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s1">totalSize += bufLen;</span>
                <span class="s0">return </span><span class="s1">HEAPU8.subarray(buf, buf + bufLen);</span>
            <span class="s1">});</span>
            <span class="s0">let </span><span class="s1">buffer;</span>
            <span class="s0">let </span><span class="s1">nread = </span><span class="s3">0</span><span class="s1">;</span>
            <span class="s0">if </span><span class="s1">(fd === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">window === </span><span class="s2">'undefined' </span><span class="s1">|| </span><span class="s0">typeof </span><span class="s1">window.prompt !== </span><span class="s2">'function'</span><span class="s1">) {</span>
                    <span class="s0">return </span><span class="s1">WasiErrno.ENOTSUP;</span>
                <span class="s1">}</span>
                <span class="s1">buffer = readStdin();</span>
                <span class="s1">nread = buffer ? copyMemory(ioVecs, buffer) : </span><span class="s3">0</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">buffer = (() =&gt; {</span>
                    <span class="s0">try </span><span class="s1">{</span>
                        <span class="s0">return new </span><span class="s1">Uint8Array(</span><span class="s0">new </span><span class="s1">SharedArrayBuffer(totalSize));</span>
                    <span class="s1">}</span>
                    <span class="s0">catch </span><span class="s1">(_) {</span>
                        <span class="s0">return new </span><span class="s1">Uint8Array(totalSize);</span>
                    <span class="s1">}</span>
                <span class="s1">})();</span>
                <span class="s1">buffer._isBuffer = </span><span class="s0">true</span><span class="s1">;</span>
                <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">bytesRead = fs.readSync(fileDescriptor.fd, buffer, </span><span class="s3">0</span><span class="s1">, buffer.length, Number(fileDescriptor.pos));</span>
                <span class="s1">nread = buffer ? copyMemory(ioVecs, buffer.subarray(</span><span class="s3">0</span><span class="s1">, bytesRead)) : </span><span class="s3">0</span><span class="s1">;</span>
                <span class="s1">fileDescriptor.pos += BigInt(nread);</span>
            <span class="s1">}</span>
            <span class="s1">view.setUint32(size, nread, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">fd_read(fd, iovs, iovslen, size) {</span>
            <span class="s1">iovs = Number(iovs);</span>
            <span class="s1">size = Number(size);</span>
            <span class="s0">if </span><span class="s1">((iovs === </span><span class="s3">0 </span><span class="s1">&amp;&amp; iovslen) || size === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8, view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_READ, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s0">if </span><span class="s1">(!iovslen) {</span>
                <span class="s1">view.setUint32(size, </span><span class="s3">0</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
            <span class="s1">}</span>
            <span class="s0">let </span><span class="s1">totalSize = </span><span class="s3">0</span><span class="s1">;</span>
            <span class="s0">const </span><span class="s1">ioVecs = Array.from({ length: Number(iovslen) }, (_, i) =&gt; {</span>
                <span class="s0">const </span><span class="s1">offset = iovs + (i * </span><span class="s3">8</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">buf = view.getInt32(offset, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">bufLen = view.getUint32(offset + </span><span class="s3">4</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s1">totalSize += bufLen;</span>
                <span class="s0">return </span><span class="s1">HEAPU8.subarray(buf, buf + bufLen);</span>
            <span class="s1">});</span>
            <span class="s0">let </span><span class="s1">buffer;</span>
            <span class="s0">let </span><span class="s1">nread = </span><span class="s3">0</span><span class="s1">;</span>
            <span class="s0">if </span><span class="s1">(fd === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">window === </span><span class="s2">'undefined' </span><span class="s1">|| </span><span class="s0">typeof </span><span class="s1">window.prompt !== </span><span class="s2">'function'</span><span class="s1">) {</span>
                    <span class="s0">return </span><span class="s1">WasiErrno.ENOTSUP;</span>
                <span class="s1">}</span>
                <span class="s1">buffer = readStdin();</span>
                <span class="s1">nread = buffer ? copyMemory(ioVecs, buffer) : </span><span class="s3">0</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">buffer = </span><span class="s0">new </span><span class="s1">Uint8Array(totalSize);</span>
                <span class="s1">buffer._isBuffer = </span><span class="s0">true</span><span class="s1">;</span>
                <span class="s0">const </span><span class="s1">{ bytesRead } = </span><span class="s0">await </span><span class="s1">fileDescriptor.fd.read(buffer, </span><span class="s3">0</span><span class="s1">, buffer.length, Number(fileDescriptor.pos));</span>
                <span class="s1">nread = buffer ? copyMemory(ioVecs, buffer.subarray(</span><span class="s3">0</span><span class="s1">, bytesRead)) : </span><span class="s3">0</span><span class="s1">;</span>
                <span class="s1">fileDescriptor.pos += BigInt(nread);</span>
            <span class="s1">}</span>
            <span class="s1">view.setUint32(size, nread, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s1">defineImport(</span><span class="s2">'fd_readdir'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">fd_readdir(fd, buf, buf_len, cookie, bufused) {</span>
            <span class="s1">buf = Number(buf);</span>
            <span class="s1">buf_len = Number(buf_len);</span>
            <span class="s1">bufused = Number(bufused);</span>
            <span class="s0">if </span><span class="s1">(buf === </span><span class="s3">0 </span><span class="s1">|| bufused === </span><span class="s3">0</span><span class="s1">)</span>
                <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_READDIR, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">entries = fs.readdirSync(fileDescriptor.realPath, { withFileTypes: </span><span class="s0">true </span><span class="s1">});</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8, view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">let </span><span class="s1">bufferUsed = </span><span class="s3">0</span><span class="s1">;</span>
            <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = Number(cookie); i &lt; entries.length; i++) {</span>
                <span class="s0">const </span><span class="s1">nameData = encoder.encode(entries[i].name);</span>
                <span class="s0">const </span><span class="s1">entryInfo = fs.statSync(resolve(fileDescriptor.realPath, entries[i].name), { bigint: </span><span class="s0">true </span><span class="s1">});</span>
                <span class="s0">const </span><span class="s1">entryData = </span><span class="s0">new </span><span class="s1">Uint8Array(</span><span class="s3">24 </span><span class="s1">+ nameData.byteLength);</span>
                <span class="s0">const </span><span class="s1">entryView = </span><span class="s0">new </span><span class="s1">DataView(entryData.buffer);</span>
                <span class="s1">entryView.setBigUint64(</span><span class="s3">0</span><span class="s1">, BigInt(i + </span><span class="s3">1</span><span class="s1">), </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s1">entryView.setBigUint64(</span><span class="s3">8</span><span class="s1">, BigInt(entryInfo.ino ? entryInfo.ino : </span><span class="s3">0</span><span class="s1">), </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s1">entryView.setUint32(</span><span class="s3">16</span><span class="s1">, nameData.byteLength, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">let </span><span class="s1">type;</span>
                <span class="s0">if </span><span class="s1">(entries[i].isFile()) {</span>
                    <span class="s1">type = WasiFileType.REGULAR_FILE;</span>
                <span class="s1">}</span>
                <span class="s0">else if </span><span class="s1">(entries[i].isDirectory()) {</span>
                    <span class="s1">type = WasiFileType.DIRECTORY;</span>
                <span class="s1">}</span>
                <span class="s0">else if </span><span class="s1">(entries[i].isSymbolicLink()) {</span>
                    <span class="s1">type = WasiFileType.SYMBOLIC_LINK;</span>
                <span class="s1">}</span>
                <span class="s0">else if </span><span class="s1">(entries[i].isCharacterDevice()) {</span>
                    <span class="s1">type = WasiFileType.CHARACTER_DEVICE;</span>
                <span class="s1">}</span>
                <span class="s0">else if </span><span class="s1">(entries[i].isBlockDevice()) {</span>
                    <span class="s1">type = WasiFileType.BLOCK_DEVICE;</span>
                <span class="s1">}</span>
                <span class="s0">else if </span><span class="s1">(entries[i].isSocket()) {</span>
                    <span class="s1">type = WasiFileType.SOCKET_STREAM;</span>
                <span class="s1">}</span>
                <span class="s0">else </span><span class="s1">{</span>
                    <span class="s1">type = WasiFileType.UNKNOWN;</span>
                <span class="s1">}</span>
                <span class="s1">entryView.setUint8(</span><span class="s3">20</span><span class="s1">, type);</span>
                <span class="s1">entryData.set(nameData, </span><span class="s3">24</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">data = entryData.slice(</span><span class="s3">0</span><span class="s1">, Math.min(entryData.length, buf_len - bufferUsed));</span>
                <span class="s1">HEAPU8.set(data, buf + bufferUsed);</span>
                <span class="s1">bufferUsed += data.byteLength;</span>
            <span class="s1">}</span>
            <span class="s1">view.setUint32(bufused, bufferUsed, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">fd_readdir(fd, buf, buf_len, cookie, bufused) {</span>
            <span class="s1">buf = Number(buf);</span>
            <span class="s1">buf_len = Number(buf_len);</span>
            <span class="s1">bufused = Number(bufused);</span>
            <span class="s0">if </span><span class="s1">(buf === </span><span class="s3">0 </span><span class="s1">|| bufused === </span><span class="s3">0</span><span class="s1">)</span>
                <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_READDIR, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">entries = </span><span class="s0">await </span><span class="s1">fs.promises.readdir(fileDescriptor.realPath, { withFileTypes: </span><span class="s0">true </span><span class="s1">});</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8, view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">let </span><span class="s1">bufferUsed = </span><span class="s3">0</span><span class="s1">;</span>
            <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = Number(cookie); i &lt; entries.length; i++) {</span>
                <span class="s0">const </span><span class="s1">nameData = encoder.encode(entries[i].name);</span>
                <span class="s0">const </span><span class="s1">entryInfo = </span><span class="s0">await </span><span class="s1">fs.promises.stat(resolve(fileDescriptor.realPath, entries[i].name), { bigint: </span><span class="s0">true </span><span class="s1">});</span>
                <span class="s0">const </span><span class="s1">entryData = </span><span class="s0">new </span><span class="s1">Uint8Array(</span><span class="s3">24 </span><span class="s1">+ nameData.byteLength);</span>
                <span class="s0">const </span><span class="s1">entryView = </span><span class="s0">new </span><span class="s1">DataView(entryData.buffer);</span>
                <span class="s1">entryView.setBigUint64(</span><span class="s3">0</span><span class="s1">, BigInt(i + </span><span class="s3">1</span><span class="s1">), </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s1">entryView.setBigUint64(</span><span class="s3">8</span><span class="s1">, BigInt(entryInfo.ino ? entryInfo.ino : </span><span class="s3">0</span><span class="s1">), </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s1">entryView.setUint32(</span><span class="s3">16</span><span class="s1">, nameData.byteLength, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">let </span><span class="s1">type;</span>
                <span class="s0">if </span><span class="s1">(entries[i].isFile()) {</span>
                    <span class="s1">type = WasiFileType.REGULAR_FILE;</span>
                <span class="s1">}</span>
                <span class="s0">else if </span><span class="s1">(entries[i].isDirectory()) {</span>
                    <span class="s1">type = WasiFileType.DIRECTORY;</span>
                <span class="s1">}</span>
                <span class="s0">else if </span><span class="s1">(entries[i].isSymbolicLink()) {</span>
                    <span class="s1">type = WasiFileType.SYMBOLIC_LINK;</span>
                <span class="s1">}</span>
                <span class="s0">else if </span><span class="s1">(entries[i].isCharacterDevice()) {</span>
                    <span class="s1">type = WasiFileType.CHARACTER_DEVICE;</span>
                <span class="s1">}</span>
                <span class="s0">else if </span><span class="s1">(entries[i].isBlockDevice()) {</span>
                    <span class="s1">type = WasiFileType.BLOCK_DEVICE;</span>
                <span class="s1">}</span>
                <span class="s0">else if </span><span class="s1">(entries[i].isSocket()) {</span>
                    <span class="s1">type = WasiFileType.SOCKET_STREAM;</span>
                <span class="s1">}</span>
                <span class="s0">else </span><span class="s1">{</span>
                    <span class="s1">type = WasiFileType.UNKNOWN;</span>
                <span class="s1">}</span>
                <span class="s1">entryView.setUint8(</span><span class="s3">20</span><span class="s1">, type);</span>
                <span class="s1">entryData.set(nameData, </span><span class="s3">24</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">data = entryData.slice(</span><span class="s3">0</span><span class="s1">, Math.min(entryData.length, buf_len - bufferUsed));</span>
                <span class="s1">HEAPU8.set(data, buf + bufferUsed);</span>
                <span class="s1">bufferUsed += data.byteLength;</span>
            <span class="s1">}</span>
            <span class="s1">view.setUint32(bufused, bufferUsed, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i64'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s1">defineImport(</span><span class="s2">'fd_renumber'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">fd_renumber(from, to) {</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">wasi.fds.renumber(to, from);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">fd_renumber(from, to) {</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">await </span><span class="s1">wasi.fds.renumber(to, from);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s1">defineImport(</span><span class="s2">'fd_sync'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">fd_sync(fd) {</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_SYNC, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">fs.fsyncSync(fileDescriptor.fd);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">fd_sync(fd) {</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_SYNC, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s0">await </span><span class="s1">fileDescriptor.fd.sync();</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s1">defineImport(</span><span class="s2">'fd_write'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">fd_write(fd, iovs, iovslen, size) {</span>
            <span class="s1">iovs = Number(iovs);</span>
            <span class="s1">size = Number(size);</span>
            <span class="s0">if </span><span class="s1">((iovs === </span><span class="s3">0 </span><span class="s1">&amp;&amp; iovslen) || size === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8, view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_WRITE, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s0">if </span><span class="s1">(!iovslen) {</span>
                <span class="s1">view.setUint32(size, </span><span class="s3">0</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">buffer = concatBuffer(Array.from({ length: Number(iovslen) }, (_, i) =&gt; {</span>
                <span class="s0">const </span><span class="s1">offset = iovs + (i * </span><span class="s3">8</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">buf = view.getInt32(offset, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">bufLen = view.getUint32(offset + </span><span class="s3">4</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">return </span><span class="s1">HEAPU8.subarray(buf, buf + bufLen);</span>
            <span class="s1">}));</span>
            <span class="s0">let </span><span class="s1">nwritten;</span>
            <span class="s0">if </span><span class="s1">(fd === </span><span class="s3">1 </span><span class="s1">|| fd === </span><span class="s3">2</span><span class="s1">) {</span>
                <span class="s1">nwritten = fileDescriptor.write(buffer);</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
                <span class="s1">nwritten = fs.writeSync(fileDescriptor.fd, buffer, </span><span class="s3">0</span><span class="s1">, buffer.length, Number(fileDescriptor.pos));</span>
                <span class="s1">fileDescriptor.pos += BigInt(nwritten);</span>
            <span class="s1">}</span>
            <span class="s1">view.setUint32(size, nwritten, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">fd_write(fd, iovs, iovslen, size) {</span>
            <span class="s1">iovs = Number(iovs);</span>
            <span class="s1">size = Number(size);</span>
            <span class="s0">if </span><span class="s1">((iovs === </span><span class="s3">0 </span><span class="s1">&amp;&amp; iovslen) || size === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8, view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_WRITE, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s0">if </span><span class="s1">(!iovslen) {</span>
                <span class="s1">view.setUint32(size, </span><span class="s3">0</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">buffer = concatBuffer(Array.from({ length: Number(iovslen) }, (_, i) =&gt; {</span>
                <span class="s0">const </span><span class="s1">offset = iovs + (i * </span><span class="s3">8</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">buf = view.getInt32(offset, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">bufLen = view.getUint32(offset + </span><span class="s3">4</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">return </span><span class="s1">HEAPU8.subarray(buf, buf + bufLen);</span>
            <span class="s1">}));</span>
            <span class="s0">let </span><span class="s1">nwritten;</span>
            <span class="s0">if </span><span class="s1">(fd === </span><span class="s3">1 </span><span class="s1">|| fd === </span><span class="s3">2</span><span class="s1">) {</span>
                <span class="s1">nwritten = fileDescriptor.write(buffer);</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">nwritten = </span><span class="s0">await </span><span class="s1">(</span><span class="s0">await </span><span class="s1">(fileDescriptor.fd.write(buffer, </span><span class="s3">0</span><span class="s1">, buffer.length, Number(fileDescriptor.pos)))).bytesWritten;</span>
                <span class="s1">fileDescriptor.pos += BigInt(nwritten);</span>
            <span class="s1">}</span>
            <span class="s1">view.setUint32(size, nwritten, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s1">defineImport(</span><span class="s2">'path_create_directory'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">path_create_directory(fd, path, path_len) {</span>
            <span class="s1">path = Number(path);</span>
            <span class="s1">path_len = Number(path_len);</span>
            <span class="s0">if </span><span class="s1">(path === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8 } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.PATH_CREATE_DIRECTORY, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s0">let </span><span class="s1">pathString = decoder.decode(unsharedSlice(HEAPU8, path, path + path_len));</span>
            <span class="s1">pathString = resolve(fileDescriptor.realPath, pathString);</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">fs.mkdirSync(pathString);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">path_create_directory(fd, path, path_len) {</span>
            <span class="s1">path = Number(path);</span>
            <span class="s1">path_len = Number(path_len);</span>
            <span class="s0">if </span><span class="s1">(path === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8 } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.PATH_CREATE_DIRECTORY, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s0">let </span><span class="s1">pathString = decoder.decode(unsharedSlice(HEAPU8, path, path + path_len));</span>
            <span class="s1">pathString = resolve(fileDescriptor.realPath, pathString);</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">await </span><span class="s1">fs.promises.mkdir(pathString);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s1">defineImport(</span><span class="s2">'path_filestat_get'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">path_filestat_get(fd, flags, path, path_len, filestat) {</span>
            <span class="s1">path = Number(path);</span>
            <span class="s1">path_len = Number(path_len);</span>
            <span class="s1">filestat = Number(filestat);</span>
            <span class="s0">if </span><span class="s1">(path === </span><span class="s3">0 </span><span class="s1">|| filestat === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8, view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.PATH_FILESTAT_GET, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s0">let </span><span class="s1">pathString = decoder.decode(unsharedSlice(HEAPU8, path, path + path_len));</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">pathString = resolve(fileDescriptor.realPath, pathString);</span>
            <span class="s0">let </span><span class="s1">stat;</span>
            <span class="s0">if </span><span class="s1">((flags &amp; </span><span class="s3">1</span><span class="s1">) === </span><span class="s3">1</span><span class="s1">) {</span>
                <span class="s1">stat = fs.statSync(pathString, { bigint: </span><span class="s0">true </span><span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">stat = fs.lstatSync(pathString, { bigint: </span><span class="s0">true </span><span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s1">toFileStat(view, filestat, stat);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">path_filestat_get(fd, flags, path, path_len, filestat) {</span>
            <span class="s1">path = Number(path);</span>
            <span class="s1">path_len = Number(path_len);</span>
            <span class="s1">filestat = Number(filestat);</span>
            <span class="s0">if </span><span class="s1">(path === </span><span class="s3">0 </span><span class="s1">|| filestat === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8, view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.PATH_FILESTAT_GET, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s0">let </span><span class="s1">pathString = decoder.decode(unsharedSlice(HEAPU8, path, path + path_len));</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">pathString = resolve(fileDescriptor.realPath, pathString);</span>
            <span class="s0">let </span><span class="s1">stat;</span>
            <span class="s0">if </span><span class="s1">((flags &amp; </span><span class="s3">1</span><span class="s1">) === </span><span class="s3">1</span><span class="s1">) {</span>
                <span class="s1">stat = </span><span class="s0">await </span><span class="s1">fs.promises.stat(pathString, { bigint: </span><span class="s0">true </span><span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">stat = </span><span class="s0">await </span><span class="s1">fs.promises.lstat(pathString, { bigint: </span><span class="s0">true </span><span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s1">toFileStat(view, filestat, stat);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s1">defineImport(</span><span class="s2">'path_filestat_set_times'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">path_filestat_set_times(fd, flags, path, path_len, atim, mtim, fst_flags) {</span>
            <span class="s1">path = Number(path);</span>
            <span class="s1">path_len = Number(path_len);</span>
            <span class="s0">if </span><span class="s1">(path === </span><span class="s3">0</span><span class="s1">)</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8 } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.PATH_FILESTAT_SET_TIMES, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s0">if </span><span class="s1">(validateFstFlagsOrReturn(fst_flags)) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">resolvedPath = resolvePathSync(fs, fileDescriptor, decoder.decode(unsharedSlice(HEAPU8, path, path + path_len)), flags);</span>
            <span class="s0">if </span><span class="s1">((fst_flags &amp; WasiFstFlag.SET_ATIM_NOW) === WasiFstFlag.SET_ATIM_NOW) {</span>
                <span class="s1">atim = BigInt(Date.now() * </span><span class="s3">1000000</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">((fst_flags &amp; WasiFstFlag.SET_MTIM_NOW) === WasiFstFlag.SET_MTIM_NOW) {</span>
                <span class="s1">mtim = BigInt(Date.now() * </span><span class="s3">1000000</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s1">fs.utimesSync(resolvedPath, Number(atim), Number(mtim));</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">path_filestat_set_times(fd, flags, path, path_len, atim, mtim, fst_flags) {</span>
            <span class="s1">path = Number(path);</span>
            <span class="s1">path_len = Number(path_len);</span>
            <span class="s0">if </span><span class="s1">(path === </span><span class="s3">0</span><span class="s1">)</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8 } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.PATH_FILESTAT_SET_TIMES, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s0">if </span><span class="s1">(validateFstFlagsOrReturn(fst_flags)) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">resolvedPath = </span><span class="s0">await </span><span class="s1">resolvePathAsync(fs, fileDescriptor, decoder.decode(unsharedSlice(HEAPU8, path, path + path_len)), flags);</span>
            <span class="s0">if </span><span class="s1">((fst_flags &amp; WasiFstFlag.SET_ATIM_NOW) === WasiFstFlag.SET_ATIM_NOW) {</span>
                <span class="s1">atim = BigInt(Date.now() * </span><span class="s3">1000000</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">((fst_flags &amp; WasiFstFlag.SET_MTIM_NOW) === WasiFstFlag.SET_MTIM_NOW) {</span>
                <span class="s1">mtim = BigInt(Date.now() * </span><span class="s3">1000000</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s0">await </span><span class="s1">fs.promises.utimes(resolvedPath, Number(atim), Number(mtim));</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i64'</span><span class="s1">, </span><span class="s2">'i64'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s1">defineImport(</span><span class="s2">'path_link'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">path_link(old_fd, old_flags, old_path, old_path_len, new_fd, new_path, new_path_len) {</span>
            <span class="s1">old_path = Number(old_path);</span>
            <span class="s1">old_path_len = Number(old_path_len);</span>
            <span class="s1">new_path = Number(new_path);</span>
            <span class="s1">new_path_len = Number(new_path_len);</span>
            <span class="s0">if </span><span class="s1">(old_path === </span><span class="s3">0 </span><span class="s1">|| new_path === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">let </span><span class="s1">oldWrap;</span>
            <span class="s0">let </span><span class="s1">newWrap;</span>
            <span class="s0">if </span><span class="s1">(old_fd === new_fd) {</span>
                <span class="s1">oldWrap = newWrap = wasi.fds.get(old_fd, WasiRights.PATH_LINK_SOURCE | WasiRights.PATH_LINK_TARGET, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">oldWrap = wasi.fds.get(old_fd, WasiRights.PATH_LINK_SOURCE, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
                <span class="s1">newWrap = wasi.fds.get(new_fd, WasiRights.PATH_LINK_TARGET, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8 } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">resolvedOldPath = resolvePathSync(fs, oldWrap, decoder.decode(unsharedSlice(HEAPU8, old_path, old_path + old_path_len)), old_flags);</span>
            <span class="s0">const </span><span class="s1">resolvedNewPath = resolve(newWrap.realPath, decoder.decode(unsharedSlice(HEAPU8, new_path, new_path + new_path_len)));</span>
            <span class="s1">fs.linkSync(resolvedOldPath, resolvedNewPath);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">path_link(old_fd, old_flags, old_path, old_path_len, new_fd, new_path, new_path_len) {</span>
            <span class="s1">old_path = Number(old_path);</span>
            <span class="s1">old_path_len = Number(old_path_len);</span>
            <span class="s1">new_path = Number(new_path);</span>
            <span class="s1">new_path_len = Number(new_path_len);</span>
            <span class="s0">if </span><span class="s1">(old_path === </span><span class="s3">0 </span><span class="s1">|| new_path === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">let </span><span class="s1">oldWrap;</span>
            <span class="s0">let </span><span class="s1">newWrap;</span>
            <span class="s0">if </span><span class="s1">(old_fd === new_fd) {</span>
                <span class="s1">oldWrap = newWrap = wasi.fds.get(old_fd, WasiRights.PATH_LINK_SOURCE | WasiRights.PATH_LINK_TARGET, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">oldWrap = wasi.fds.get(old_fd, WasiRights.PATH_LINK_SOURCE, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
                <span class="s1">newWrap = wasi.fds.get(new_fd, WasiRights.PATH_LINK_TARGET, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8 } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">resolvedOldPath = </span><span class="s0">await </span><span class="s1">resolvePathAsync(fs, oldWrap, decoder.decode(unsharedSlice(HEAPU8, old_path, old_path + old_path_len)), old_flags);</span>
            <span class="s0">const </span><span class="s1">resolvedNewPath = resolve(newWrap.realPath, decoder.decode(unsharedSlice(HEAPU8, new_path, new_path + new_path_len)));</span>
            <span class="s0">await </span><span class="s1">fs.promises.link(resolvedOldPath, resolvedNewPath);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s0">function </span><span class="s1">pathOpen(o_flags, fs_rights_base, fs_rights_inheriting, fs_flags) {</span>
            <span class="s0">const </span><span class="s1">read = (fs_rights_base &amp; (WasiRights.FD_READ |</span>
                <span class="s1">WasiRights.FD_READDIR)) !== BigInt(</span><span class="s3">0</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">write = (fs_rights_base &amp; (WasiRights.FD_DATASYNC |</span>
                <span class="s1">WasiRights.FD_WRITE |</span>
                <span class="s1">WasiRights.FD_ALLOCATE |</span>
                <span class="s1">WasiRights.FD_FILESTAT_SET_SIZE)) !== BigInt(</span><span class="s3">0</span><span class="s1">);</span>
            <span class="s0">let </span><span class="s1">flags = write ? read ? FileControlFlag.O_RDWR : FileControlFlag.O_WRONLY : FileControlFlag.O_RDONLY;</span>
            <span class="s0">let </span><span class="s1">needed_base = WasiRights.PATH_OPEN;</span>
            <span class="s0">let </span><span class="s1">needed_inheriting = fs_rights_base | fs_rights_inheriting;</span>
            <span class="s0">if </span><span class="s1">((o_flags &amp; WasiFileControlFlag.O_CREAT) !== </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s1">flags |= FileControlFlag.O_CREAT;</span>
                <span class="s1">needed_base |= WasiRights.PATH_CREATE_FILE;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">((o_flags &amp; WasiFileControlFlag.O_DIRECTORY) !== </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s1">flags |= FileControlFlag.O_DIRECTORY;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">((o_flags &amp; WasiFileControlFlag.O_EXCL) !== </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s1">flags |= FileControlFlag.O_EXCL;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">((o_flags &amp; WasiFileControlFlag.O_TRUNC) !== </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s1">flags |= FileControlFlag.O_TRUNC;</span>
                <span class="s1">needed_base |= WasiRights.PATH_FILESTAT_SET_SIZE;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">((fs_flags &amp; WasiFdFlag.APPEND) !== </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s1">flags |= FileControlFlag.O_APPEND;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">((fs_flags &amp; WasiFdFlag.DSYNC) !== </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s4">// flags |= FileControlFlag.O_DSYNC;</span>
                <span class="s1">needed_inheriting |= WasiRights.FD_DATASYNC;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">((fs_flags &amp; WasiFdFlag.NONBLOCK) !== </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s1">flags |= FileControlFlag.O_NONBLOCK;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">((fs_flags &amp; WasiFdFlag.RSYNC) !== </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s1">flags |= FileControlFlag.O_SYNC;</span>
                <span class="s1">needed_inheriting |= WasiRights.FD_SYNC;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">((fs_flags &amp; WasiFdFlag.SYNC) !== </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s1">flags |= FileControlFlag.O_SYNC;</span>
                <span class="s1">needed_inheriting |= WasiRights.FD_SYNC;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">(write &amp;&amp; (flags &amp; (FileControlFlag.O_APPEND | FileControlFlag.O_TRUNC)) === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s1">needed_inheriting |= WasiRights.FD_SEEK;</span>
            <span class="s1">}</span>
            <span class="s0">return </span><span class="s1">{ flags, needed_base, needed_inheriting };</span>
        <span class="s1">}</span>
        <span class="s1">defineImport(</span><span class="s2">'path_open'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">path_open(dirfd, dirflags, path, path_len, o_flags, fs_rights_base, fs_rights_inheriting, fs_flags, fd) {</span>
            <span class="s1">path = Number(path);</span>
            <span class="s1">fd = Number(fd);</span>
            <span class="s0">if </span><span class="s1">(path === </span><span class="s3">0 </span><span class="s1">|| fd === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
            <span class="s1">path_len = Number(path_len);</span>
            <span class="s1">fs_rights_base = BigInt(fs_rights_base);</span>
            <span class="s1">fs_rights_inheriting = BigInt(fs_rights_inheriting);</span>
            <span class="s0">const </span><span class="s1">{ flags: flagsRes, needed_base: neededBase, needed_inheriting: neededInheriting } = pathOpen(o_flags, fs_rights_base, fs_rights_inheriting, fs_flags);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(dirfd, neededBase, neededInheriting);</span>
            <span class="s0">const </span><span class="s1">memory = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">HEAPU8 = memory.HEAPU8;</span>
            <span class="s0">const </span><span class="s1">pathString = decoder.decode(unsharedSlice(HEAPU8, path, path + path_len));</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">resolved_path = resolvePathSync(fs, fileDescriptor, pathString, dirflags);</span>
            <span class="s0">const </span><span class="s1">r = fs.openSync(resolved_path, flagsRes, </span><span class="s3">0o666</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">filetype = wasi.fds.getFileTypeByFd(r);</span>
            <span class="s0">if </span><span class="s1">((filetype !== WasiFileType.DIRECTORY) &amp;&amp;</span>
                <span class="s1">((o_flags &amp; WasiFileControlFlag.O_DIRECTORY) !== </span><span class="s3">0 </span><span class="s1">||</span>
                    <span class="s1">(resolved_path.endsWith(</span><span class="s2">'/'</span><span class="s1">)))) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.ENOTDIR;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ base: max_base, inheriting: max_inheriting } = getRights(wasi.fds.stdio, r, flagsRes, filetype);</span>
            <span class="s0">const </span><span class="s1">wrap = wasi.fds.insert(r, resolved_path, resolved_path, filetype, fs_rights_base &amp; max_base, fs_rights_inheriting &amp; max_inheriting, </span><span class="s3">0</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">stat = fs.fstatSync(r, { bigint: </span><span class="s0">true </span><span class="s1">});</span>
            <span class="s0">if </span><span class="s1">(stat.isFile()) {</span>
                <span class="s1">wrap.size = stat.size;</span>
                <span class="s0">if </span><span class="s1">((flagsRes &amp; FileControlFlag.O_APPEND) !== </span><span class="s3">0</span><span class="s1">) {</span>
                    <span class="s1">wrap.pos = stat.size;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">view = memory.view;</span>
            <span class="s1">view.setInt32(fd, wrap.id, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">path_open(dirfd, dirflags, path, path_len, o_flags, fs_rights_base, fs_rights_inheriting, fs_flags, fd) {</span>
            <span class="s1">path = Number(path);</span>
            <span class="s1">fd = Number(fd);</span>
            <span class="s0">if </span><span class="s1">(path === </span><span class="s3">0 </span><span class="s1">|| fd === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
            <span class="s1">path_len = Number(path_len);</span>
            <span class="s1">fs_rights_base = BigInt(fs_rights_base);</span>
            <span class="s1">fs_rights_inheriting = BigInt(fs_rights_inheriting);</span>
            <span class="s0">const </span><span class="s1">{ flags: flagsRes, needed_base: neededBase, needed_inheriting: neededInheriting } = pathOpen(o_flags, fs_rights_base, fs_rights_inheriting, fs_flags);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(dirfd, neededBase, neededInheriting);</span>
            <span class="s0">const </span><span class="s1">memory = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">HEAPU8 = memory.HEAPU8;</span>
            <span class="s0">const </span><span class="s1">pathString = decoder.decode(unsharedSlice(HEAPU8, path, path + path_len));</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">resolved_path = </span><span class="s0">await </span><span class="s1">resolvePathAsync(fs, fileDescriptor, pathString, dirflags);</span>
            <span class="s0">const </span><span class="s1">r = </span><span class="s0">await </span><span class="s1">fs.promises.open(resolved_path, flagsRes, </span><span class="s3">0o666</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">filetype = </span><span class="s0">await </span><span class="s1">wasi.fds.getFileTypeByFd(r);</span>
            <span class="s0">if </span><span class="s1">((o_flags &amp; WasiFileControlFlag.O_DIRECTORY) !== </span><span class="s3">0 </span><span class="s1">&amp;&amp; filetype !== WasiFileType.DIRECTORY) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.ENOTDIR;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ base: max_base, inheriting: max_inheriting } = getRights(wasi.fds.stdio, r.fd, flagsRes, filetype);</span>
            <span class="s0">const </span><span class="s1">wrap = wasi.fds.insert(r, resolved_path, resolved_path, filetype, fs_rights_base &amp; max_base, fs_rights_inheriting &amp; max_inheriting, </span><span class="s3">0</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">stat = </span><span class="s0">await </span><span class="s1">r.stat({ bigint: </span><span class="s0">true </span><span class="s1">});</span>
            <span class="s0">if </span><span class="s1">(stat.isFile()) {</span>
                <span class="s1">wrap.size = stat.size;</span>
                <span class="s0">if </span><span class="s1">((flagsRes &amp; FileControlFlag.O_APPEND) !== </span><span class="s3">0</span><span class="s1">) {</span>
                    <span class="s1">wrap.pos = stat.size;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">view = memory.view;</span>
            <span class="s1">view.setInt32(fd, wrap.id, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i64'</span><span class="s1">, </span><span class="s2">'i64'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s1">defineImport(</span><span class="s2">'path_readlink'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">path_readlink(fd, path, path_len, buf, buf_len, bufused) {</span>
            <span class="s1">path = Number(path);</span>
            <span class="s1">path_len = Number(path_len);</span>
            <span class="s1">buf = Number(buf);</span>
            <span class="s1">buf_len = Number(buf_len);</span>
            <span class="s1">bufused = Number(bufused);</span>
            <span class="s0">if </span><span class="s1">(path === </span><span class="s3">0 </span><span class="s1">|| buf === </span><span class="s3">0 </span><span class="s1">|| bufused === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8, view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.PATH_READLINK, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s0">let </span><span class="s1">pathString = decoder.decode(unsharedSlice(HEAPU8, path, path + path_len));</span>
            <span class="s1">pathString = resolve(fileDescriptor.realPath, pathString);</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">link = fs.readlinkSync(pathString);</span>
            <span class="s0">const </span><span class="s1">linkData = encoder.encode(link);</span>
            <span class="s0">const </span><span class="s1">len = Math.min(linkData.length, buf_len);</span>
            <span class="s0">if </span><span class="s1">(len &gt;= buf_len)</span>
                <span class="s0">return </span><span class="s1">WasiErrno.ENOBUFS;</span>
            <span class="s1">HEAPU8.set(linkData.subarray(</span><span class="s3">0</span><span class="s1">, len), buf);</span>
            <span class="s1">HEAPU8[buf + len] = </span><span class="s3">0</span><span class="s1">;</span>
            <span class="s1">view.setUint32(bufused, len, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">path_readlink(fd, path, path_len, buf, buf_len, bufused) {</span>
            <span class="s1">path = Number(path);</span>
            <span class="s1">path_len = Number(path_len);</span>
            <span class="s1">buf = Number(buf);</span>
            <span class="s1">buf_len = Number(buf_len);</span>
            <span class="s1">bufused = Number(bufused);</span>
            <span class="s0">if </span><span class="s1">(path === </span><span class="s3">0 </span><span class="s1">|| buf === </span><span class="s3">0 </span><span class="s1">|| bufused === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8, view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.PATH_READLINK, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s0">let </span><span class="s1">pathString = decoder.decode(unsharedSlice(HEAPU8, path, path + path_len));</span>
            <span class="s1">pathString = resolve(fileDescriptor.realPath, pathString);</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">link = </span><span class="s0">await </span><span class="s1">fs.promises.readlink(pathString);</span>
            <span class="s0">const </span><span class="s1">linkData = encoder.encode(link);</span>
            <span class="s0">const </span><span class="s1">len = Math.min(linkData.length, buf_len);</span>
            <span class="s0">if </span><span class="s1">(len &gt;= buf_len)</span>
                <span class="s0">return </span><span class="s1">WasiErrno.ENOBUFS;</span>
            <span class="s1">HEAPU8.set(linkData.subarray(</span><span class="s3">0</span><span class="s1">, len), buf);</span>
            <span class="s1">HEAPU8[buf + len] = </span><span class="s3">0</span><span class="s1">;</span>
            <span class="s1">view.setUint32(bufused, len, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s1">defineImport(</span><span class="s2">'path_remove_directory'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">path_remove_directory(fd, path, path_len) {</span>
            <span class="s1">path = Number(path);</span>
            <span class="s1">path_len = Number(path_len);</span>
            <span class="s0">if </span><span class="s1">(path === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8 } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.PATH_REMOVE_DIRECTORY, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s0">let </span><span class="s1">pathString = decoder.decode(unsharedSlice(HEAPU8, path, path + path_len));</span>
            <span class="s1">pathString = resolve(fileDescriptor.realPath, pathString);</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">fs.rmdirSync(pathString);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">path_remove_directory(fd, path, path_len) {</span>
            <span class="s1">path = Number(path);</span>
            <span class="s1">path_len = Number(path_len);</span>
            <span class="s0">if </span><span class="s1">(path === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8 } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.PATH_REMOVE_DIRECTORY, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s0">let </span><span class="s1">pathString = decoder.decode(unsharedSlice(HEAPU8, path, path + path_len));</span>
            <span class="s1">pathString = resolve(fileDescriptor.realPath, pathString);</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">await </span><span class="s1">fs.promises.rmdir(pathString);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s1">defineImport(</span><span class="s2">'path_rename'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">path_rename(old_fd, old_path, old_path_len, new_fd, new_path, new_path_len) {</span>
            <span class="s1">old_path = Number(old_path);</span>
            <span class="s1">old_path_len = Number(old_path_len);</span>
            <span class="s1">new_path = Number(new_path);</span>
            <span class="s1">new_path_len = Number(new_path_len);</span>
            <span class="s0">if </span><span class="s1">(old_path === </span><span class="s3">0 </span><span class="s1">|| new_path === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">let </span><span class="s1">oldWrap;</span>
            <span class="s0">let </span><span class="s1">newWrap;</span>
            <span class="s0">if </span><span class="s1">(old_fd === new_fd) {</span>
                <span class="s1">oldWrap = newWrap = wasi.fds.get(old_fd, WasiRights.PATH_RENAME_SOURCE | WasiRights.PATH_RENAME_TARGET, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">oldWrap = wasi.fds.get(old_fd, WasiRights.PATH_RENAME_SOURCE, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
                <span class="s1">newWrap = wasi.fds.get(new_fd, WasiRights.PATH_RENAME_TARGET, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8 } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">resolvedOldPath = resolve(oldWrap.realPath, decoder.decode(unsharedSlice(HEAPU8, old_path, old_path + old_path_len)));</span>
            <span class="s0">const </span><span class="s1">resolvedNewPath = resolve(newWrap.realPath, decoder.decode(unsharedSlice(HEAPU8, new_path, new_path + new_path_len)));</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">fs.renameSync(resolvedOldPath, resolvedNewPath);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">path_rename(old_fd, old_path, old_path_len, new_fd, new_path, new_path_len) {</span>
            <span class="s1">old_path = Number(old_path);</span>
            <span class="s1">old_path_len = Number(old_path_len);</span>
            <span class="s1">new_path = Number(new_path);</span>
            <span class="s1">new_path_len = Number(new_path_len);</span>
            <span class="s0">if </span><span class="s1">(old_path === </span><span class="s3">0 </span><span class="s1">|| new_path === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">let </span><span class="s1">oldWrap;</span>
            <span class="s0">let </span><span class="s1">newWrap;</span>
            <span class="s0">if </span><span class="s1">(old_fd === new_fd) {</span>
                <span class="s1">oldWrap = newWrap = wasi.fds.get(old_fd, WasiRights.PATH_RENAME_SOURCE | WasiRights.PATH_RENAME_TARGET, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">oldWrap = wasi.fds.get(old_fd, WasiRights.PATH_RENAME_SOURCE, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
                <span class="s1">newWrap = wasi.fds.get(new_fd, WasiRights.PATH_RENAME_TARGET, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8 } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">resolvedOldPath = resolve(oldWrap.realPath, decoder.decode(unsharedSlice(HEAPU8, old_path, old_path + old_path_len)));</span>
            <span class="s0">const </span><span class="s1">resolvedNewPath = resolve(newWrap.realPath, decoder.decode(unsharedSlice(HEAPU8, new_path, new_path + new_path_len)));</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">await </span><span class="s1">fs.promises.rename(resolvedOldPath, resolvedNewPath);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s1">defineImport(</span><span class="s2">'path_symlink'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">path_symlink(old_path, old_path_len, fd, new_path, new_path_len) {</span>
            <span class="s1">old_path = Number(old_path);</span>
            <span class="s1">old_path_len = Number(old_path_len);</span>
            <span class="s1">new_path = Number(new_path);</span>
            <span class="s1">new_path_len = Number(new_path_len);</span>
            <span class="s0">if </span><span class="s1">(old_path === </span><span class="s3">0 </span><span class="s1">|| new_path === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8 } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.PATH_SYMLINK, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s0">const </span><span class="s1">oldPath = decoder.decode(unsharedSlice(HEAPU8, old_path, old_path + old_path_len));</span>
            <span class="s0">if </span><span class="s1">(oldPath.length &gt; </span><span class="s3">0 </span><span class="s1">&amp;&amp; oldPath[</span><span class="s3">0</span><span class="s1">] === </span><span class="s2">'/'</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EPERM;</span>
            <span class="s1">}</span>
            <span class="s0">let </span><span class="s1">newPath = decoder.decode(unsharedSlice(HEAPU8, new_path, new_path + new_path_len));</span>
            <span class="s1">newPath = resolve(fileDescriptor.realPath, newPath);</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">fs.symlinkSync(oldPath, newPath);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">path_symlink(old_path, old_path_len, fd, new_path, new_path_len) {</span>
            <span class="s1">old_path = Number(old_path);</span>
            <span class="s1">old_path_len = Number(old_path_len);</span>
            <span class="s1">new_path = Number(new_path);</span>
            <span class="s1">new_path_len = Number(new_path_len);</span>
            <span class="s0">if </span><span class="s1">(old_path === </span><span class="s3">0 </span><span class="s1">|| new_path === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8 } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.PATH_SYMLINK, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s0">const </span><span class="s1">oldPath = decoder.decode(unsharedSlice(HEAPU8, old_path, old_path + old_path_len));</span>
            <span class="s0">let </span><span class="s1">newPath = decoder.decode(unsharedSlice(HEAPU8, new_path, new_path + new_path_len));</span>
            <span class="s1">newPath = resolve(fileDescriptor.realPath, newPath);</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">await </span><span class="s1">fs.promises.symlink(oldPath, newPath);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s1">defineImport(</span><span class="s2">'path_unlink_file'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">path_unlink_file(fd, path, path_len) {</span>
            <span class="s1">path = Number(path);</span>
            <span class="s1">path_len = Number(path_len);</span>
            <span class="s0">if </span><span class="s1">(path === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8 } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.PATH_UNLINK_FILE, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s0">let </span><span class="s1">pathString = decoder.decode(unsharedSlice(HEAPU8, path, path + path_len));</span>
            <span class="s1">pathString = resolve(fileDescriptor.realPath, pathString);</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">fs.unlinkSync(pathString);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">path_unlink_file(fd, path, path_len) {</span>
            <span class="s1">path = Number(path);</span>
            <span class="s1">path_len = Number(path_len);</span>
            <span class="s0">if </span><span class="s1">(path === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s1">WasiErrno.EINVAL;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8 } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.PATH_UNLINK_FILE, BigInt(</span><span class="s3">0</span><span class="s1">));</span>
            <span class="s0">let </span><span class="s1">pathString = decoder.decode(unsharedSlice(HEAPU8, path, path + path_len));</span>
            <span class="s1">pathString = resolve(fileDescriptor.realPath, pathString);</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">await </span><span class="s1">fs.promises.unlink(pathString);</span>
            <span class="s0">return </span><span class="s1">WasiErrno.ESUCCESS;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s0">this</span><span class="s1">._setMemory = </span><span class="s0">function </span><span class="s1">setMemory(m) {</span>
            <span class="s0">if </span><span class="s1">(!(m </span><span class="s0">instanceof </span><span class="s1">_WebAssembly.Memory)) {</span>
                <span class="s0">throw new </span><span class="s1">TypeError(</span><span class="s2">'&quot;instance.exports.memory&quot; property must be a WebAssembly.Memory'</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s1">_memory.set(_this, extendMemory(m));</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s0">static </span><span class="s1">createSync(args, env, preopens, stdio, fs, print, printErr) {</span>
        <span class="s0">const </span><span class="s1">fds = </span><span class="s0">new </span><span class="s1">SyncTable({</span>
            <span class="s1">size: </span><span class="s3">3</span><span class="s1">,</span>
            <span class="s0">in</span><span class="s1">: stdio[</span><span class="s3">0</span><span class="s1">],</span>
            <span class="s1">out: stdio[</span><span class="s3">1</span><span class="s1">],</span>
            <span class="s1">err: stdio[</span><span class="s3">2</span><span class="s1">],</span>
            <span class="s1">fs,</span>
            <span class="s1">print,</span>
            <span class="s1">printErr</span>
        <span class="s1">});</span>
        <span class="s0">const </span><span class="s1">_this = </span><span class="s0">new </span><span class="s1">WASI(args, env, fds, </span><span class="s0">false</span><span class="s1">, fs);</span>
        <span class="s0">if </span><span class="s1">(preopens.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">; i &lt; preopens.length; ++i) {</span>
                <span class="s0">const </span><span class="s1">realPath = fs.realpathSync(preopens[i].realPath, </span><span class="s2">'utf8'</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">fd = fs.openSync(realPath, </span><span class="s2">'r'</span><span class="s1">, </span><span class="s3">0o666</span><span class="s1">);</span>
                <span class="s1">fds.insertPreopen(fd, preopens[i].mappedPath, realPath);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">_this;</span>
    <span class="s1">}</span>
    <span class="s0">static </span><span class="s1">async createAsync(args, env, preopens, stdio, fs, print, printErr, asyncify) {</span>
        <span class="s0">const </span><span class="s1">fds = </span><span class="s0">new </span><span class="s1">AsyncTable({</span>
            <span class="s1">size: </span><span class="s3">3</span><span class="s1">,</span>
            <span class="s0">in</span><span class="s1">: stdio[</span><span class="s3">0</span><span class="s1">],</span>
            <span class="s1">out: stdio[</span><span class="s3">1</span><span class="s1">],</span>
            <span class="s1">err: stdio[</span><span class="s3">2</span><span class="s1">],</span>
            <span class="s1">print,</span>
            <span class="s1">printErr</span>
        <span class="s1">});</span>
        <span class="s0">const </span><span class="s1">_this = </span><span class="s0">new </span><span class="s1">WASI(args, env, fds, </span><span class="s0">true</span><span class="s1">, fs, asyncify);</span>
        <span class="s0">if </span><span class="s1">(preopens.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">; i &lt; preopens.length; ++i) {</span>
                <span class="s0">const </span><span class="s1">entry = preopens[i];</span>
                <span class="s0">const </span><span class="s1">realPath = </span><span class="s0">await </span><span class="s1">fs.promises.realpath(entry.realPath);</span>
                <span class="s0">const </span><span class="s1">fd = </span><span class="s0">await </span><span class="s1">fs.promises.open(realPath, </span><span class="s2">'r'</span><span class="s1">, </span><span class="s3">0o666</span><span class="s1">);</span>
                <span class="s0">await </span><span class="s1">fds.insertPreopen(fd, entry.mappedPath, realPath);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">_this;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
</pre>
</body>
</html>