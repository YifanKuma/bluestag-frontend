<html>
<head>
<title>magic-string.cjs.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #8c8c8c; font-style: italic;}
.s3 { color: #067d17;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
magic-string.cjs.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">export interface </span><span class="s1">BundleOptions {</span>
	<span class="s1">intro?: string;</span>
	<span class="s1">separator?: string;</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">SourceMapOptions {</span>
	<span class="s2">/**</span>
	 <span class="s2">* Whether the mapping should be high-resolution.</span>
	 <span class="s2">* Hi-res mappings map every single character, meaning (for example) your devtools will always</span>
	 <span class="s2">* be able to pinpoint the exact location of function calls and so on.</span>
	 <span class="s2">* With lo-res mappings, devtools may only be able to identify the correct</span>
	 <span class="s2">* line - but they're quicker to generate and less bulky.</span>
	 <span class="s2">* You can also set `&quot;boundary&quot;` to generate a semi-hi-res mappings segmented per word boundary</span>
	 <span class="s2">* instead of per character, suitable for string semantics that are separated by words.</span>
	 <span class="s2">* If sourcemap locations have been specified with s.addSourceMapLocation(), they will be used here.</span>
	 <span class="s2">*/</span>
	<span class="s1">hires?: boolean | </span><span class="s3">'boundary'</span><span class="s1">;</span>
	<span class="s2">/**</span>
	 <span class="s2">* The filename where you plan to write the sourcemap.</span>
	 <span class="s2">*/</span>
	<span class="s1">file?: string;</span>
	<span class="s2">/**</span>
	 <span class="s2">* The filename of the file containing the original source.</span>
	 <span class="s2">*/</span>
	<span class="s1">source?: string;</span>
	<span class="s2">/**</span>
	 <span class="s2">* Whether to include the original content in the map's sourcesContent array.</span>
	 <span class="s2">*/</span>
	<span class="s1">includeContent?: boolean;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">type SourceMapSegment =</span>
	<span class="s1">| [number]</span>
	<span class="s1">| [number, number, number, number]</span>
	<span class="s1">| [number, number, number, number, number];</span>

<span class="s0">export interface </span><span class="s1">DecodedSourceMap {</span>
	<span class="s1">file: string;</span>
	<span class="s1">sources: string[];</span>
	<span class="s1">sourcesContent?: string[];</span>
	<span class="s1">names: string[];</span>
	<span class="s1">mappings: SourceMapSegment[][];</span>
	<span class="s1">x_google_ignoreList?: number[];</span>
<span class="s1">}</span>

<span class="s0">export class </span><span class="s1">SourceMap {</span>
	<span class="s1">constructor(properties: DecodedSourceMap);</span>

	<span class="s1">version: number;</span>
	<span class="s1">file: string;</span>
	<span class="s1">sources: string[];</span>
	<span class="s1">sourcesContent?: string[];</span>
	<span class="s1">names: string[];</span>
	<span class="s1">mappings: string;</span>
	<span class="s1">x_google_ignoreList?: number[];</span>
	<span class="s1">debugId?: string;</span>

	<span class="s2">/**</span>
	 <span class="s2">* Returns the equivalent of `JSON.stringify(map)`</span>
	 <span class="s2">*/</span>
	<span class="s1">toString(): string;</span>
	<span class="s2">/**</span>
	 <span class="s2">* Returns a DataURI containing the sourcemap. Useful for doing this sort of thing:</span>
	 <span class="s2">* `generateMap(options?: SourceMapOptions): SourceMap;`</span>
	 <span class="s2">*/</span>
	<span class="s1">toUrl(): string;</span>
<span class="s1">}</span>

<span class="s0">export class </span><span class="s1">Bundle {</span>
	<span class="s1">constructor(options?: BundleOptions);</span>
	<span class="s2">/**</span>
	 <span class="s2">* Adds the specified source to the bundle, which can either be a `MagicString` object directly,</span>
	 <span class="s2">* or an options object that holds a magic string `content` property and optionally provides</span>
	 <span class="s2">* a `filename` for the source within the bundle, as well as an optional `ignoreList` hint</span>
	 <span class="s2">* (which defaults to `false`). The `filename` is used when constructing the source map for the</span>
	 <span class="s2">* bundle, to identify this `source` in the source map's `sources` field. The `ignoreList` hint</span>
	 <span class="s2">* is used to populate the `x_google_ignoreList` extension field in the source map, which is a</span>
	 <span class="s2">* mechanism for tools to signal to debuggers that certain sources should be ignored by default</span>
	 <span class="s2">* (depending on user preferences).</span>
	 <span class="s2">*/</span>
	<span class="s1">addSource(</span>
		<span class="s1">source: MagicString | { filename?: string; content: MagicString; ignoreList?: boolean },</span>
	<span class="s1">): </span><span class="s0">this</span><span class="s1">;</span>
	<span class="s1">append(str: string, options?: BundleOptions): </span><span class="s0">this</span><span class="s1">;</span>
	<span class="s1">clone(): </span><span class="s0">this</span><span class="s1">;</span>
	<span class="s1">generateMap(</span>
		<span class="s1">options?: SourceMapOptions,</span>
	<span class="s1">): Omit&lt;SourceMap, </span><span class="s3">'sourcesContent'</span><span class="s1">&gt; &amp; { sourcesContent: Array&lt;string | </span><span class="s0">null</span><span class="s1">&gt; };</span>
	<span class="s1">generateDecodedMap(</span>
		<span class="s1">options?: SourceMapOptions,</span>
	<span class="s1">): Omit&lt;DecodedSourceMap, </span><span class="s3">'sourcesContent'</span><span class="s1">&gt; &amp; { sourcesContent: Array&lt;string | </span><span class="s0">null</span><span class="s1">&gt; };</span>
	<span class="s1">getIndentString(): string;</span>
	<span class="s1">indent(indentStr?: string): </span><span class="s0">this</span><span class="s1">;</span>
	<span class="s1">indentExclusionRanges: ExclusionRange | Array&lt;ExclusionRange&gt;;</span>
	<span class="s1">prepend(str: string): </span><span class="s0">this</span><span class="s1">;</span>
	<span class="s1">toString(): string;</span>
	<span class="s1">trimLines(): </span><span class="s0">this</span><span class="s1">;</span>
	<span class="s1">trim(charType?: string): </span><span class="s0">this</span><span class="s1">;</span>
	<span class="s1">trimStart(charType?: string): </span><span class="s0">this</span><span class="s1">;</span>
	<span class="s1">trimEnd(charType?: string): </span><span class="s0">this</span><span class="s1">;</span>
	<span class="s1">isEmpty(): boolean;</span>
	<span class="s1">length(): number;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">type ExclusionRange = [number, number];</span>

<span class="s0">export interface </span><span class="s1">MagicStringOptions {</span>
	<span class="s1">filename?: string;</span>
	<span class="s1">indentExclusionRanges?: ExclusionRange | Array&lt;ExclusionRange&gt;;</span>
	<span class="s1">offset?: number;</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">IndentOptions {</span>
	<span class="s1">exclude?: ExclusionRange | Array&lt;ExclusionRange&gt;;</span>
	<span class="s1">indentStart?: boolean;</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">OverwriteOptions {</span>
	<span class="s1">storeName?: boolean;</span>
	<span class="s1">contentOnly?: boolean;</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">UpdateOptions {</span>
	<span class="s1">storeName?: boolean;</span>
	<span class="s1">overwrite?: boolean;</span>
<span class="s1">}</span>

<span class="s0">export default class </span><span class="s1">MagicString {</span>
	<span class="s1">constructor(str: string, options?: MagicStringOptions);</span>
	<span class="s2">/**</span>
	 <span class="s2">* Adds the specified character index (with respect to the original string) to sourcemap mappings, if `hires` is false.</span>
	 <span class="s2">*/</span>
	<span class="s1">addSourcemapLocation(char: number): </span><span class="s0">void</span><span class="s1">;</span>
	<span class="s2">/**</span>
	 <span class="s2">* Appends the specified content to the end of the string.</span>
	 <span class="s2">*/</span>
	<span class="s1">append(content: string): </span><span class="s0">this</span><span class="s1">;</span>
	<span class="s2">/**</span>
	 <span class="s2">* Appends the specified content at the index in the original string.</span>
	 <span class="s2">* If a range *ending* with index is subsequently moved, the insert will be moved with it.</span>
	 <span class="s2">* See also `s.prependLeft(...)`.</span>
	 <span class="s2">*/</span>
	<span class="s1">appendLeft(index: number, content: string): </span><span class="s0">this</span><span class="s1">;</span>
	<span class="s2">/**</span>
	 <span class="s2">* Appends the specified content at the index in the original string.</span>
	 <span class="s2">* If a range *starting* with index is subsequently moved, the insert will be moved with it.</span>
	 <span class="s2">* See also `s.prependRight(...)`.</span>
	 <span class="s2">*/</span>
	<span class="s1">appendRight(index: number, content: string): </span><span class="s0">this</span><span class="s1">;</span>
	<span class="s2">/**</span>
	 <span class="s2">* Does what you'd expect.</span>
	 <span class="s2">*/</span>
	<span class="s1">clone(): </span><span class="s0">this</span><span class="s1">;</span>
	<span class="s2">/**</span>
	 <span class="s2">* Generates a version 3 sourcemap.</span>
	 <span class="s2">*/</span>
	<span class="s1">generateMap(options?: SourceMapOptions): SourceMap;</span>
	<span class="s2">/**</span>
	 <span class="s2">* Generates a sourcemap object with raw mappings in array form, rather than encoded as a string.</span>
	 <span class="s2">* Useful if you need to manipulate the sourcemap further, but most of the time you will use `generateMap` instead.</span>
	 <span class="s2">*/</span>
	<span class="s1">generateDecodedMap(options?: SourceMapOptions): DecodedSourceMap;</span>
	<span class="s1">getIndentString(): string;</span>

	<span class="s2">/**</span>
	 <span class="s2">* Prefixes each line of the string with prefix.</span>
	 <span class="s2">* If prefix is not supplied, the indentation will be guessed from the original content, falling back to a single tab character.</span>
	 <span class="s2">*/</span>
	<span class="s1">indent(options?: IndentOptions): </span><span class="s0">this</span><span class="s1">;</span>
	<span class="s2">/**</span>
	 <span class="s2">* Prefixes each line of the string with prefix.</span>
	 <span class="s2">* If prefix is not supplied, the indentation will be guessed from the original content, falling back to a single tab character.</span>
	 <span class="s2">*</span>
	 <span class="s2">* The options argument can have an exclude property, which is an array of [start, end] character ranges.</span>
	 <span class="s2">* These ranges will be excluded from the indentation - useful for (e.g.) multiline strings.</span>
	 <span class="s2">*/</span>
	<span class="s1">indent(indentStr?: string, options?: IndentOptions): </span><span class="s0">this</span><span class="s1">;</span>
	<span class="s1">indentExclusionRanges: ExclusionRange | Array&lt;ExclusionRange&gt;;</span>

	<span class="s2">/**</span>
	 <span class="s2">* Moves the characters from `start` and `end` to `index`.</span>
	 <span class="s2">*/</span>
	<span class="s1">move(start: number, end: number, index: number): </span><span class="s0">this</span><span class="s1">;</span>
	<span class="s2">/**</span>
	 <span class="s2">* Replaces the characters from `start` to `end` with `content`, along with the appended/prepended content in</span>
	 <span class="s2">* that range. The same restrictions as `s.remove()` apply.</span>
	 <span class="s2">*</span>
	 <span class="s2">* The fourth argument is optional. It can have a storeName property — if true, the original name will be stored</span>
	 <span class="s2">* for later inclusion in a sourcemap's names array — and a contentOnly property which determines whether only</span>
	 <span class="s2">* the content is overwritten, or anything that was appended/prepended to the range as well.</span>
	 <span class="s2">*</span>
	 <span class="s2">* It may be preferred to use `s.update(...)` instead if you wish to avoid overwriting the appended/prepended content.</span>
	 <span class="s2">*/</span>
	<span class="s1">overwrite(</span>
		<span class="s1">start: number,</span>
		<span class="s1">end: number,</span>
		<span class="s1">content: string,</span>
		<span class="s1">options?: boolean | OverwriteOptions,</span>
	<span class="s1">): </span><span class="s0">this</span><span class="s1">;</span>
	<span class="s2">/**</span>
	 <span class="s2">* Replaces the characters from `start` to `end` with `content`. The same restrictions as `s.remove()` apply.</span>
	 <span class="s2">*</span>
	 <span class="s2">* The fourth argument is optional. It can have a storeName property — if true, the original name will be stored</span>
	 <span class="s2">* for later inclusion in a sourcemap's names array — and an overwrite property which determines whether only</span>
	 <span class="s2">* the content is overwritten, or anything that was appended/prepended to the range as well.</span>
	 <span class="s2">*/</span>
	<span class="s1">update(start: number, end: number, content: string, options?: boolean | UpdateOptions): </span><span class="s0">this</span><span class="s1">;</span>
	<span class="s2">/**</span>
	 <span class="s2">* Prepends the string with the specified content.</span>
	 <span class="s2">*/</span>
	<span class="s1">prepend(content: string): </span><span class="s0">this</span><span class="s1">;</span>
	<span class="s2">/**</span>
	 <span class="s2">* Same as `s.appendLeft(...)`, except that the inserted content will go *before* any previous appends or prepends at index</span>
	 <span class="s2">*/</span>
	<span class="s1">prependLeft(index: number, content: string): </span><span class="s0">this</span><span class="s1">;</span>
	<span class="s2">/**</span>
	 <span class="s2">* Same as `s.appendRight(...)`, except that the inserted content will go *before* any previous appends or prepends at `index`</span>
	 <span class="s2">*/</span>
	<span class="s1">prependRight(index: number, content: string): </span><span class="s0">this</span><span class="s1">;</span>
	<span class="s2">/**</span>
	 <span class="s2">* Removes the characters from `start` to `end` (of the original string, **not** the generated string).</span>
	 <span class="s2">* Removing the same content twice, or making removals that partially overlap, will cause an error.</span>
	 <span class="s2">*/</span>
	<span class="s1">remove(start: number, end: number): </span><span class="s0">this</span><span class="s1">;</span>
	<span class="s2">/**</span>
	 <span class="s2">* Reset the modified characters from `start` to `end` (of the original string, **not** the generated string).</span>
	 <span class="s2">*/</span>
	<span class="s1">reset(start: number, end: number): </span><span class="s0">this</span><span class="s1">;</span>
	<span class="s2">/**</span>
	 <span class="s2">* Returns the content of the generated string that corresponds to the slice between `start` and `end` of the original string.</span>
	 <span class="s2">* Throws error if the indices are for characters that were already removed.</span>
	 <span class="s2">*/</span>
	<span class="s1">slice(start: number, end: number): string;</span>
	<span class="s2">/**</span>
	 <span class="s2">* Returns a clone of `s`, with all content before the `start` and `end` characters of the original string removed.</span>
	 <span class="s2">*/</span>
	<span class="s1">snip(start: number, end: number): </span><span class="s0">this</span><span class="s1">;</span>
	<span class="s2">/**</span>
	 <span class="s2">* Trims content matching `charType` (defaults to `\s`, i.e. whitespace) from the start and end.</span>
	 <span class="s2">*/</span>
	<span class="s1">trim(charType?: string): </span><span class="s0">this</span><span class="s1">;</span>
	<span class="s2">/**</span>
	 <span class="s2">* Trims content matching `charType` (defaults to `\s`, i.e. whitespace) from the start.</span>
	 <span class="s2">*/</span>
	<span class="s1">trimStart(charType?: string): </span><span class="s0">this</span><span class="s1">;</span>
	<span class="s2">/**</span>
	 <span class="s2">* Trims content matching `charType` (defaults to `\s`, i.e. whitespace) from the end.</span>
	 <span class="s2">*/</span>
	<span class="s1">trimEnd(charType?: string): </span><span class="s0">this</span><span class="s1">;</span>
	<span class="s2">/**</span>
	 <span class="s2">* Removes empty lines from the start and end.</span>
	 <span class="s2">*/</span>
	<span class="s1">trimLines(): </span><span class="s0">this</span><span class="s1">;</span>
	<span class="s2">/**</span>
	 <span class="s2">* String replacement with RegExp or string.</span>
	 <span class="s2">*/</span>
	<span class="s1">replace(</span>
		<span class="s1">regex: RegExp | string,</span>
		<span class="s1">replacement: string | ((substring: string, ...args: any[]) =&gt; string),</span>
	<span class="s1">): </span><span class="s0">this</span><span class="s1">;</span>
	<span class="s2">/**</span>
	 <span class="s2">* Same as `s.replace`, but replace all matched strings instead of just one.</span>
	 <span class="s2">*/</span>
	<span class="s1">replaceAll(</span>
		<span class="s1">regex: RegExp | string,</span>
		<span class="s1">replacement: string | ((substring: string, ...args: any[]) =&gt; string),</span>
	<span class="s1">): </span><span class="s0">this</span><span class="s1">;</span>

	<span class="s1">lastChar(): string;</span>
	<span class="s1">lastLine(): string;</span>
	<span class="s2">/**</span>
	 <span class="s2">* Returns true if the resulting source is empty (disregarding white space).</span>
	 <span class="s2">*/</span>
	<span class="s1">isEmpty(): boolean;</span>
	<span class="s1">length(): number;</span>

	<span class="s2">/**</span>
	 <span class="s2">* Indicates if the string has been changed.</span>
	 <span class="s2">*/</span>
	<span class="s1">hasChanged(): boolean;</span>

	<span class="s1">original: string;</span>
	<span class="s2">/**</span>
	 <span class="s2">* Returns the generated string.</span>
	 <span class="s2">*/</span>
	<span class="s1">toString(): string;</span>

	<span class="s1">offset: number;</span>
<span class="s1">}</span>
</pre>
</body>
</html>