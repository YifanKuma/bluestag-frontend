<html>
<head>
<title>emnapi.cjs.min.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #1750eb;}
.s4 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
emnapi.cjs.min.js</font>
</center></td></tr></table>
<pre><span class="s0">const </span><span class="s1">e=</span><span class="s0">new </span><span class="s1">WeakMap;</span><span class="s0">function </span><span class="s1">t(t){</span><span class="s0">return </span><span class="s1">e.has(t)}</span><span class="s0">const </span><span class="s1">i=(()=&gt;{</span><span class="s0">function </span><span class="s1">t(t){Object.setPrototypeOf(</span><span class="s0">this</span><span class="s1">,</span><span class="s0">null</span><span class="s1">),e.set(</span><span class="s0">this</span><span class="s1">,t)}</span><span class="s0">return </span><span class="s1">t.prototype=</span><span class="s0">null</span><span class="s1">,t})();</span><span class="s0">function </span><span class="s1">s(i){</span><span class="s0">if</span><span class="s1">(!t(i))</span><span class="s0">throw new </span><span class="s1">TypeError(</span><span class="s2">&quot;not external&quot;</span><span class="s1">);</span><span class="s0">return </span><span class="s1">e.get(i)}</span><span class="s0">const </span><span class="s1">n=</span><span class="s0">function</span><span class="s1">(){</span><span class="s0">let </span><span class="s1">e;</span><span class="s0">try</span><span class="s1">{e=</span><span class="s0">new </span><span class="s1">Function}</span><span class="s0">catch</span><span class="s1">(e){</span><span class="s0">return</span><span class="s1">!</span><span class="s3">1</span><span class="s1">}</span><span class="s0">return</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">e}(),r=</span><span class="s0">function</span><span class="s1">(){</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;undefined&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">globalThis)</span><span class="s0">return </span><span class="s1">globalThis;</span><span class="s0">let </span><span class="s1">e=</span><span class="s0">function</span><span class="s1">(){</span><span class="s0">return this</span><span class="s1">}();</span><span class="s0">if</span><span class="s1">(!e&amp;&amp;n)</span><span class="s0">try</span><span class="s1">{e=</span><span class="s0">new </span><span class="s1">Function(</span><span class="s2">&quot;return this&quot;</span><span class="s1">)()}</span><span class="s0">catch</span><span class="s1">(e){}</span><span class="s0">if</span><span class="s1">(!e){</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;undefined&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">__webpack_public_path__&amp;&amp;</span><span class="s2">&quot;undefined&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">global)</span><span class="s0">return </span><span class="s1">global;</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;undefined&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">window)</span><span class="s0">return </span><span class="s1">window;</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;undefined&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">self)</span><span class="s0">return </span><span class="s1">self}</span><span class="s0">return </span><span class="s1">e}();</span><span class="s0">class </span><span class="s1">o{constructor(){</span><span class="s0">this</span><span class="s1">._exception=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">._caught=!</span><span class="s3">1</span><span class="s1">}isEmpty(){</span><span class="s0">return</span><span class="s1">!</span><span class="s0">this</span><span class="s1">._caught}hasCaught(){</span><span class="s0">return this</span><span class="s1">._caught}exception(){</span><span class="s0">return this</span><span class="s1">._exception}setError(e){</span><span class="s0">this</span><span class="s1">._caught=!</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">._exception=e}reset(){</span><span class="s0">this</span><span class="s1">._caught=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">._exception=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">}extractException(){</span><span class="s0">const </span><span class="s1">e=</span><span class="s0">this</span><span class="s1">._exception;</span><span class="s0">return this</span><span class="s1">.reset(),e}}</span><span class="s0">const </span><span class="s1">a=</span><span class="s0">function</span><span class="s1">(){</span><span class="s0">var </span><span class="s1">e;</span><span class="s0">try</span><span class="s1">{</span><span class="s0">return </span><span class="s1">Boolean(</span><span class="s0">null</span><span class="s1">===(e=Object.getOwnPropertyDescriptor(Function.prototype,</span><span class="s2">&quot;name&quot;</span><span class="s1">))||</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===e?</span><span class="s0">void </span><span class="s3">0</span><span class="s1">:e.configurable)}</span><span class="s0">catch</span><span class="s1">(e){</span><span class="s0">return</span><span class="s1">!</span><span class="s3">1</span><span class="s1">}}(),l=</span><span class="s2">&quot;object&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">Reflect,c=</span><span class="s2">&quot;undefined&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">FinalizationRegistry&amp;&amp;</span><span class="s2">&quot;undefined&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">WeakRef,h=</span><span class="s0">function</span><span class="s1">(){</span><span class="s0">try</span><span class="s1">{</span><span class="s0">const </span><span class="s1">e=Symbol();</span><span class="s0">new </span><span class="s1">WeakRef(e),(</span><span class="s0">new </span><span class="s1">WeakMap).set(e,</span><span class="s0">void </span><span class="s3">0</span><span class="s1">)}</span><span class="s0">catch</span><span class="s1">(e){</span><span class="s0">return</span><span class="s1">!</span><span class="s3">1</span><span class="s1">}</span><span class="s0">return</span><span class="s1">!</span><span class="s3">0</span><span class="s1">}(),u=</span><span class="s2">&quot;undefined&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">BigInt;</span><span class="s0">const </span><span class="s1">p=</span><span class="s0">function</span><span class="s1">(){</span><span class="s0">let </span><span class="s1">e;</span><span class="s0">return </span><span class="s1">e=</span><span class="s2">&quot;undefined&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">__webpack_public_path__||</span><span class="s2">&quot;undefined&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">__webpack_public_path__?</span><span class="s2">&quot;undefined&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">__non_webpack_require__?__non_webpack_require__:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">:</span><span class="s2">&quot;undefined&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">require?require:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,e}(),f=</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">MessageChannel?MessageChannel:</span><span class="s0">function</span><span class="s1">(){</span><span class="s0">try</span><span class="s1">{</span><span class="s0">return </span><span class="s1">p(</span><span class="s2">&quot;worker_threads&quot;</span><span class="s1">).MessageChannel}</span><span class="s0">catch</span><span class="s1">(e){}}(),d=</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">setImmediate?setImmediate:</span><span class="s0">function</span><span class="s1">(e){</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;function&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">e)</span><span class="s0">throw new </span><span class="s1">TypeError(</span><span class="s2">'The &quot;callback&quot; argument must be of type function'</span><span class="s1">);</span><span class="s0">if</span><span class="s1">(f){</span><span class="s0">let </span><span class="s1">t=</span><span class="s0">new </span><span class="s1">f;t.port1.onmessage=</span><span class="s0">function</span><span class="s1">(){t.port1.onmessage=</span><span class="s0">null</span><span class="s1">,t=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,e()},t.port2.postMessage(</span><span class="s0">null</span><span class="s1">)}</span><span class="s0">else </span><span class="s1">setTimeout(e,</span><span class="s3">0</span><span class="s1">)},_=</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">Buffer?Buffer:</span><span class="s0">function</span><span class="s1">(){</span><span class="s0">try</span><span class="s1">{</span><span class="s0">return </span><span class="s1">p(</span><span class="s2">&quot;buffer&quot;</span><span class="s1">).Buffer}</span><span class="s0">catch</span><span class="s1">(e){}}(),v=</span><span class="s2">&quot;1.5.0&quot;</span><span class="s1">,g=</span><span class="s3">2147483647</span><span class="s1">;</span><span class="s0">class </span><span class="s1">y{constructor(e,t){</span><span class="s0">this</span><span class="s1">.id=e,</span><span class="s0">this</span><span class="s1">.value=t}data(){</span><span class="s0">return </span><span class="s1">s(</span><span class="s0">this</span><span class="s1">.value)}isNumber(){</span><span class="s0">return</span><span class="s2">&quot;number&quot;</span><span class="s1">==</span><span class="s0">typeof this</span><span class="s1">.value}isBigInt(){</span><span class="s0">return</span><span class="s2">&quot;bigint&quot;</span><span class="s1">==</span><span class="s0">typeof this</span><span class="s1">.value}isString(){</span><span class="s0">return</span><span class="s2">&quot;string&quot;</span><span class="s1">==</span><span class="s0">typeof this</span><span class="s1">.value}isFunction(){</span><span class="s0">return</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof this</span><span class="s1">.value}isExternal(){</span><span class="s0">return </span><span class="s1">t(</span><span class="s0">this</span><span class="s1">.value)}isObject(){</span><span class="s0">return</span><span class="s2">&quot;object&quot;</span><span class="s1">==</span><span class="s0">typeof this</span><span class="s1">.value&amp;&amp;</span><span class="s0">null</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">.value}isArray(){</span><span class="s0">return </span><span class="s1">Array.isArray(</span><span class="s0">this</span><span class="s1">.value)}isArrayBuffer(){</span><span class="s0">return this</span><span class="s1">.value </span><span class="s0">instanceof </span><span class="s1">ArrayBuffer}isTypedArray(){</span><span class="s0">return </span><span class="s1">ArrayBuffer.isView(</span><span class="s0">this</span><span class="s1">.value)&amp;&amp;!(</span><span class="s0">this</span><span class="s1">.value </span><span class="s0">instanceof </span><span class="s1">DataView)}isBuffer(e){</span><span class="s0">return</span><span class="s1">!!ArrayBuffer.isView(</span><span class="s0">this</span><span class="s1">.value)||(</span><span class="s0">null</span><span class="s1">!=e||(e=_),</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">e&amp;&amp;e.isBuffer(</span><span class="s0">this</span><span class="s1">.value))}isDataView(){</span><span class="s0">return this</span><span class="s1">.value </span><span class="s0">instanceof </span><span class="s1">DataView}isDate(){</span><span class="s0">return this</span><span class="s1">.value </span><span class="s0">instanceof </span><span class="s1">Date}isPromise(){</span><span class="s0">return this</span><span class="s1">.value </span><span class="s0">instanceof </span><span class="s1">Promise}isBoolean(){</span><span class="s0">return</span><span class="s2">&quot;boolean&quot;</span><span class="s1">==</span><span class="s0">typeof this</span><span class="s1">.value}isUndefined(){</span><span class="s0">return void </span><span class="s3">0</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.value}isSymbol(){</span><span class="s0">return</span><span class="s2">&quot;symbol&quot;</span><span class="s1">==</span><span class="s0">typeof this</span><span class="s1">.value}isNull(){</span><span class="s0">return null</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.value}dispose(){</span><span class="s0">this</span><span class="s1">.value=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">}}</span><span class="s0">class </span><span class="s1">x </span><span class="s0">extends </span><span class="s1">y{constructor(e,t){</span><span class="s0">super</span><span class="s1">(e,t)}dispose(){}}</span><span class="s0">class </span><span class="s1">z{constructor(){</span><span class="s0">this</span><span class="s1">._values=[</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,z.UNDEFINED,z.NULL,z.FALSE,z.TRUE,z.GLOBAL],</span><span class="s0">this</span><span class="s1">._next=z.MIN_ID}push(e){</span><span class="s0">let </span><span class="s1">t;</span><span class="s0">const </span><span class="s1">i=</span><span class="s0">this</span><span class="s1">._next,s=</span><span class="s0">this</span><span class="s1">._values;</span><span class="s0">return </span><span class="s1">i&lt;s.length?(t=s[i],t.value=e):(t=</span><span class="s0">new </span><span class="s1">y(i,e),s[i]=t),</span><span class="s0">this</span><span class="s1">._next++,t}erase(e,t){</span><span class="s0">this</span><span class="s1">._next=e;</span><span class="s0">const </span><span class="s1">i=</span><span class="s0">this</span><span class="s1">._values;</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">s=e;s&lt;t;++s)i[s].dispose()}get(e){</span><span class="s0">return this</span><span class="s1">._values[e]}swap(e,t){</span><span class="s0">const </span><span class="s1">i=</span><span class="s0">this</span><span class="s1">._values,s=i[e];i[e]=i[t],i[e].id=Number(e),i[t]=s,s.id=Number(t)}dispose(){</span><span class="s0">this</span><span class="s1">._values.length=z.MIN_ID,</span><span class="s0">this</span><span class="s1">._next=z.MIN_ID}}z.UNDEFINED=</span><span class="s0">new </span><span class="s1">x(</span><span class="s3">1</span><span class="s1">,</span><span class="s0">void </span><span class="s3">0</span><span class="s1">),z.NULL=</span><span class="s0">new </span><span class="s1">x(</span><span class="s3">2</span><span class="s1">,</span><span class="s0">null</span><span class="s1">),z.FALSE=</span><span class="s0">new </span><span class="s1">x(</span><span class="s3">3</span><span class="s1">,!</span><span class="s3">1</span><span class="s1">),z.TRUE=</span><span class="s0">new </span><span class="s1">x(</span><span class="s3">4</span><span class="s1">,!</span><span class="s3">0</span><span class="s1">),z.GLOBAL=</span><span class="s0">new </span><span class="s1">x(</span><span class="s3">5</span><span class="s1">,r),z.MIN_ID=</span><span class="s3">6</span><span class="s1">;</span><span class="s0">class </span><span class="s1">k{constructor(e,t,i,s,n=s){</span><span class="s0">this</span><span class="s1">.handleStore=e,</span><span class="s0">this</span><span class="s1">.id=t,</span><span class="s0">this</span><span class="s1">.parent=i,</span><span class="s0">this</span><span class="s1">.child=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">null</span><span class="s1">!==i&amp;&amp;(i.child=</span><span class="s0">this</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.start=s,</span><span class="s0">this</span><span class="s1">.end=n,</span><span class="s0">this</span><span class="s1">._escapeCalled=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.callbackInfo={thiz:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,data:</span><span class="s3">0</span><span class="s1">,args:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,fn:</span><span class="s0">void </span><span class="s3">0</span><span class="s1">}}add(e){</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">this</span><span class="s1">.handleStore.push(e);</span><span class="s0">return this</span><span class="s1">.end++,t}addExternal(e){</span><span class="s0">return this</span><span class="s1">.add(</span><span class="s0">new </span><span class="s1">i(e))}dispose(){</span><span class="s0">this</span><span class="s1">._escapeCalled&amp;&amp;(</span><span class="s0">this</span><span class="s1">._escapeCalled=!</span><span class="s3">1</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.start!==</span><span class="s0">this</span><span class="s1">.end&amp;&amp;</span><span class="s0">this</span><span class="s1">.handleStore.erase(</span><span class="s0">this</span><span class="s1">.start,</span><span class="s0">this</span><span class="s1">.end)}escape(e){</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">._escapeCalled)</span><span class="s0">return null</span><span class="s1">;</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">._escapeCalled=!</span><span class="s3">0</span><span class="s1">,e&lt;</span><span class="s0">this</span><span class="s1">.start||e&gt;=</span><span class="s0">this</span><span class="s1">.end)</span><span class="s0">return null</span><span class="s1">;</span><span class="s0">this</span><span class="s1">.handleStore.swap(e,</span><span class="s0">this</span><span class="s1">.start);</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">this</span><span class="s1">.handleStore.get(</span><span class="s0">this</span><span class="s1">.start);</span><span class="s0">return this</span><span class="s1">.start++,</span><span class="s0">this</span><span class="s1">.parent.end++,t}escapeCalled(){</span><span class="s0">return this</span><span class="s1">._escapeCalled}}</span><span class="s0">class </span><span class="s1">b{constructor(){</span><span class="s0">this</span><span class="s1">._rootScope=</span><span class="s0">new </span><span class="s1">k(</span><span class="s0">null</span><span class="s1">,</span><span class="s3">0</span><span class="s1">,</span><span class="s0">null</span><span class="s1">,</span><span class="s3">1</span><span class="s1">,z.MIN_ID),</span><span class="s0">this</span><span class="s1">.currentScope=</span><span class="s0">this</span><span class="s1">._rootScope,</span><span class="s0">this</span><span class="s1">._values=[</span><span class="s0">void </span><span class="s3">0</span><span class="s1">]}get(e){</span><span class="s0">return this</span><span class="s1">._values[e]}openScope(e){</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">this</span><span class="s1">.currentScope;</span><span class="s0">let </span><span class="s1">i=t.child;</span><span class="s0">if</span><span class="s1">(</span><span class="s0">null</span><span class="s1">!==i)i.start=i.end=t.end;</span><span class="s0">else</span><span class="s1">{</span><span class="s0">const </span><span class="s1">s=t.id+</span><span class="s3">1</span><span class="s1">;i=</span><span class="s0">new </span><span class="s1">k(e,s,t,t.end),</span><span class="s0">this</span><span class="s1">._values[s]=i}</span><span class="s0">return this</span><span class="s1">.currentScope=i,i}closeScope(){</span><span class="s0">const </span><span class="s1">e=</span><span class="s0">this</span><span class="s1">.currentScope;</span><span class="s0">this</span><span class="s1">.currentScope=e.parent,e.dispose()}dispose(){</span><span class="s0">this</span><span class="s1">.currentScope=</span><span class="s0">this</span><span class="s1">._rootScope,</span><span class="s0">this</span><span class="s1">._values.length=</span><span class="s3">1</span><span class="s1">}}</span><span class="s0">class </span><span class="s1">w{constructor(){</span><span class="s0">this</span><span class="s1">._next=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">this</span><span class="s1">._prev=</span><span class="s0">null</span><span class="s1">}dispose(){}finalize(){}link(e){</span><span class="s0">this</span><span class="s1">._prev=e,</span><span class="s0">this</span><span class="s1">._next=e._next,</span><span class="s0">null</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">._next&amp;&amp;(</span><span class="s0">this</span><span class="s1">._next._prev=</span><span class="s0">this</span><span class="s1">),e._next=</span><span class="s0">this</span><span class="s1">}unlink(){</span><span class="s0">null</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">._prev&amp;&amp;(</span><span class="s0">this</span><span class="s1">._prev._next=</span><span class="s0">this</span><span class="s1">._next),</span><span class="s0">null</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">._next&amp;&amp;(</span><span class="s0">this</span><span class="s1">._next._prev=</span><span class="s0">this</span><span class="s1">._prev),</span><span class="s0">this</span><span class="s1">._prev=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">this</span><span class="s1">._next=</span><span class="s0">null</span><span class="s1">}</span><span class="s0">static </span><span class="s1">finalizeAll(e){</span><span class="s0">for</span><span class="s1">(;</span><span class="s0">null</span><span class="s1">!==e._next;)e._next.finalize()}}</span><span class="s0">class </span><span class="s1">S{constructor(e,t=</span><span class="s3">0</span><span class="s1">,i=</span><span class="s3">0</span><span class="s1">,s=</span><span class="s3">0</span><span class="s1">){</span><span class="s0">this</span><span class="s1">.envObject=e,</span><span class="s0">this</span><span class="s1">._finalizeCallback=t,</span><span class="s0">this</span><span class="s1">._finalizeData=i,</span><span class="s0">this</span><span class="s1">._finalizeHint=s,</span><span class="s0">this</span><span class="s1">._makeDynCall_vppp=e.makeDynCall_vppp}callback(){</span><span class="s0">return this</span><span class="s1">._finalizeCallback}data(){</span><span class="s0">return this</span><span class="s1">._finalizeData}hint(){</span><span class="s0">return this</span><span class="s1">._finalizeHint}resetEnv(){</span><span class="s0">this</span><span class="s1">.envObject=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">}resetFinalizer(){</span><span class="s0">this</span><span class="s1">._finalizeCallback=</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">._finalizeData=</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">._finalizeHint=</span><span class="s3">0</span><span class="s1">}callFinalizer(){</span><span class="s0">const </span><span class="s1">e=</span><span class="s0">this</span><span class="s1">._finalizeCallback,t=</span><span class="s0">this</span><span class="s1">._finalizeData,i=</span><span class="s0">this</span><span class="s1">._finalizeHint;</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.resetFinalizer(),!e)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const </span><span class="s1">s=Number(e);</span><span class="s0">this</span><span class="s1">.envObject?</span><span class="s0">this</span><span class="s1">.envObject.callFinalizer(s,t,i):</span><span class="s0">this</span><span class="s1">._makeDynCall_vppp(s)(</span><span class="s3">0</span><span class="s1">,t,i)}dispose(){</span><span class="s0">this</span><span class="s1">.envObject=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">._makeDynCall_vppp=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">}}</span><span class="s0">class </span><span class="s1">E </span><span class="s0">extends </span><span class="s1">w{</span><span class="s0">static </span><span class="s1">create(e,t,i,s){</span><span class="s0">const </span><span class="s1">n=</span><span class="s0">new </span><span class="s1">E(e,t,i,s);</span><span class="s0">return </span><span class="s1">n.link(e.finalizing_reflist),n}constructor(e,t,i,s){</span><span class="s0">super</span><span class="s1">(),</span><span class="s0">this</span><span class="s1">._finalizer=</span><span class="s0">new </span><span class="s1">S(e,t,i,s)}data(){</span><span class="s0">return this</span><span class="s1">._finalizer.data()}dispose(){</span><span class="s0">this</span><span class="s1">._finalizer&amp;&amp;(</span><span class="s0">this</span><span class="s1">.unlink(),</span><span class="s0">this</span><span class="s1">._finalizer.envObject.dequeueFinalizer(</span><span class="s0">this</span><span class="s1">),</span><span class="s0">this</span><span class="s1">._finalizer.dispose(),</span><span class="s0">this</span><span class="s1">._finalizer=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,</span><span class="s0">super</span><span class="s1">.dispose())}finalize(){</span><span class="s0">let </span><span class="s1">e;</span><span class="s0">this</span><span class="s1">.unlink();</span><span class="s0">let </span><span class="s1">t=!</span><span class="s3">1</span><span class="s1">;</span><span class="s0">try</span><span class="s1">{</span><span class="s0">this</span><span class="s1">._finalizer.callFinalizer()}</span><span class="s0">catch</span><span class="s1">(i){t=!</span><span class="s3">0</span><span class="s1">,e=i}</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.dispose(),t)</span><span class="s0">throw </span><span class="s1">e}}</span><span class="s0">function </span><span class="s1">m(e,t){</span><span class="s0">if</span><span class="s1">(!e.terminatedOrTerminating())</span><span class="s0">throw </span><span class="s1">t}</span><span class="s0">class </span><span class="s1">C{constructor(e,t,i,s,n){</span><span class="s0">this</span><span class="s1">.ctx=e,</span><span class="s0">this</span><span class="s1">.moduleApiVersion=t,</span><span class="s0">this</span><span class="s1">.makeDynCall_vppp=i,</span><span class="s0">this</span><span class="s1">.makeDynCall_vp=s,</span><span class="s0">this</span><span class="s1">.abort=n,</span><span class="s0">this</span><span class="s1">.openHandleScopes=</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.instanceData=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.tryCatch=</span><span class="s0">new </span><span class="s1">o,</span><span class="s0">this</span><span class="s1">.refs=</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.reflist=</span><span class="s0">new </span><span class="s1">w,</span><span class="s0">this</span><span class="s1">.finalizing_reflist=</span><span class="s0">new </span><span class="s1">w,</span><span class="s0">this</span><span class="s1">.pendingFinalizers=[],</span><span class="s0">this</span><span class="s1">.lastError={errorCode:</span><span class="s3">0</span><span class="s1">,engineErrorCode:</span><span class="s3">0</span><span class="s1">,engineReserved:</span><span class="s3">0</span><span class="s1">},</span><span class="s0">this</span><span class="s1">.inGcFinalizer=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">._bindingMap=</span><span class="s0">new </span><span class="s1">WeakMap,</span><span class="s0">this</span><span class="s1">.id=</span><span class="s3">0</span><span class="s1">}canCallIntoJs(){</span><span class="s0">return</span><span class="s1">!</span><span class="s3">0</span><span class="s1">}terminatedOrTerminating(){</span><span class="s0">return</span><span class="s1">!</span><span class="s0">this</span><span class="s1">.canCallIntoJs()}ref(){</span><span class="s0">this</span><span class="s1">.refs++}unref(){</span><span class="s0">this</span><span class="s1">.refs--,</span><span class="s3">0</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.refs&amp;&amp;</span><span class="s0">this</span><span class="s1">.dispose()}ensureHandle(e){</span><span class="s0">return this</span><span class="s1">.ctx.ensureHandle(e)}ensureHandleId(e){</span><span class="s0">return this</span><span class="s1">.ensureHandle(e).id}clearLastError(){</span><span class="s0">const </span><span class="s1">e=</span><span class="s0">this</span><span class="s1">.lastError;</span><span class="s0">return </span><span class="s3">0</span><span class="s1">!==e.errorCode&amp;&amp;(e.errorCode=</span><span class="s3">0</span><span class="s1">),</span><span class="s3">0</span><span class="s1">!==e.engineErrorCode&amp;&amp;(e.engineErrorCode=</span><span class="s3">0</span><span class="s1">),</span><span class="s3">0</span><span class="s1">!==e.engineReserved&amp;&amp;(e.engineReserved=</span><span class="s3">0</span><span class="s1">),</span><span class="s3">0</span><span class="s1">}setLastError(e,t=</span><span class="s3">0</span><span class="s1">,i=</span><span class="s3">0</span><span class="s1">){</span><span class="s0">const </span><span class="s1">s=</span><span class="s0">this</span><span class="s1">.lastError;</span><span class="s0">return </span><span class="s1">s.errorCode!==e&amp;&amp;(s.errorCode=e),s.engineErrorCode!==t&amp;&amp;(s.engineErrorCode=t),s.engineReserved!==i&amp;&amp;(s.engineReserved=i),e}getReturnStatus(){</span><span class="s0">return this</span><span class="s1">.tryCatch.hasCaught()?</span><span class="s0">this</span><span class="s1">.setLastError(</span><span class="s3">10</span><span class="s1">):</span><span class="s3">0</span><span class="s1">}callIntoModule(e,t=m){</span><span class="s0">const </span><span class="s1">i=</span><span class="s0">this</span><span class="s1">.openHandleScopes;</span><span class="s0">this</span><span class="s1">.clearLastError();</span><span class="s0">const </span><span class="s1">s=e(</span><span class="s0">this</span><span class="s1">);</span><span class="s0">if</span><span class="s1">(i!==</span><span class="s0">this</span><span class="s1">.openHandleScopes&amp;&amp;</span><span class="s0">this</span><span class="s1">.abort(</span><span class="s2">&quot;open_handle_scopes != open_handle_scopes_before&quot;</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.tryCatch.hasCaught()){t(</span><span class="s0">this</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.tryCatch.extractException())}</span><span class="s0">return </span><span class="s1">s}invokeFinalizerFromGC(e){</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.moduleApiVersion!==g)</span><span class="s0">this</span><span class="s1">.enqueueFinalizer(e);</span><span class="s0">else</span><span class="s1">{</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">this</span><span class="s1">.inGcFinalizer;</span><span class="s0">this</span><span class="s1">.inGcFinalizer=!</span><span class="s3">0</span><span class="s1">;</span><span class="s0">try</span><span class="s1">{e.finalize()}</span><span class="s0">finally</span><span class="s1">{</span><span class="s0">this</span><span class="s1">.inGcFinalizer=t}}}checkGCAccess(){</span><span class="s0">this</span><span class="s1">.moduleApiVersion===g&amp;&amp;</span><span class="s0">this</span><span class="s1">.inGcFinalizer&amp;&amp;</span><span class="s0">this</span><span class="s1">.abort(</span><span class="s2">&quot;Finalizer is calling a function that may affect GC state.</span><span class="s4">\n</span><span class="s2">The finalizers are run directly from GC and must not affect GC state.</span><span class="s4">\n</span><span class="s2">Use `node_api_post_finalizer` from inside of the finalizer to work around this issue.</span><span class="s4">\n</span><span class="s2">It schedules the call as a new task in the event loop.&quot;</span><span class="s1">)}enqueueFinalizer(e){-</span><span class="s3">1</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.pendingFinalizers.indexOf(e)&amp;&amp;</span><span class="s0">this</span><span class="s1">.pendingFinalizers.push(e)}dequeueFinalizer(e){</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">this</span><span class="s1">.pendingFinalizers.indexOf(e);-</span><span class="s3">1</span><span class="s1">!==t&amp;&amp;</span><span class="s0">this</span><span class="s1">.pendingFinalizers.splice(t,</span><span class="s3">1</span><span class="s1">)}deleteMe(){w.finalizeAll(</span><span class="s0">this</span><span class="s1">.finalizing_reflist),w.finalizeAll(</span><span class="s0">this</span><span class="s1">.reflist),</span><span class="s0">this</span><span class="s1">.tryCatch.extractException(),</span><span class="s0">this</span><span class="s1">.ctx.envStore.remove(</span><span class="s0">this</span><span class="s1">.id)}dispose(){</span><span class="s3">0</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">.id&amp;&amp;(</span><span class="s0">this</span><span class="s1">.deleteMe(),</span><span class="s0">this</span><span class="s1">.finalizing_reflist.dispose(),</span><span class="s0">this</span><span class="s1">.reflist.dispose(),</span><span class="s0">this</span><span class="s1">.id=</span><span class="s3">0</span><span class="s1">)}initObjectBinding(e){</span><span class="s0">const </span><span class="s1">t={wrapped:</span><span class="s3">0</span><span class="s1">,tag:</span><span class="s0">null</span><span class="s1">};</span><span class="s0">return this</span><span class="s1">._bindingMap.set(e,t),t}getObjectBinding(e){</span><span class="s0">return this</span><span class="s1">._bindingMap.has(e)?</span><span class="s0">this</span><span class="s1">._bindingMap.get(e):</span><span class="s0">this</span><span class="s1">.initObjectBinding(e)}setInstanceData(e,t,i){</span><span class="s0">this</span><span class="s1">.instanceData&amp;&amp;</span><span class="s0">this</span><span class="s1">.instanceData.dispose(),</span><span class="s0">this</span><span class="s1">.instanceData=E.create(</span><span class="s0">this</span><span class="s1">,t,e,i)}getInstanceData(){</span><span class="s0">return this</span><span class="s1">.instanceData?</span><span class="s0">this</span><span class="s1">.instanceData.data():</span><span class="s3">0</span><span class="s1">}}</span><span class="s0">class </span><span class="s1">F </span><span class="s0">extends </span><span class="s1">C{constructor(e,t,i,s,n,r,o){</span><span class="s0">super</span><span class="s1">(e,i,s,n,r),</span><span class="s0">this</span><span class="s1">.filename=t,</span><span class="s0">this</span><span class="s1">.nodeBinding=o,</span><span class="s0">this</span><span class="s1">.destructing=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.finalizationScheduled=!</span><span class="s3">1</span><span class="s1">}deleteMe(){</span><span class="s0">this</span><span class="s1">.destructing=!</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.drainFinalizerQueue(),</span><span class="s0">super</span><span class="s1">.deleteMe()}canCallIntoJs(){</span><span class="s0">return super</span><span class="s1">.canCallIntoJs()&amp;&amp;</span><span class="s0">this</span><span class="s1">.ctx.canCallIntoJs()}triggerFatalException(e){</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.nodeBinding)</span><span class="s0">this</span><span class="s1">.nodeBinding.napi.fatalException(e);</span><span class="s0">else</span><span class="s1">{</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;object&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">process||</span><span class="s0">null</span><span class="s1">===process||</span><span class="s2">&quot;function&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">process._fatalException)</span><span class="s0">throw </span><span class="s1">e;process._fatalException(e)||(console.error(e),process.exit(</span><span class="s3">1</span><span class="s1">))}}callbackIntoModule(e,t){</span><span class="s0">return this</span><span class="s1">.callIntoModule(t,(t,i)=&gt;{</span><span class="s0">if</span><span class="s1">(t.terminatedOrTerminating())</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const </span><span class="s1">s=</span><span class="s2">&quot;object&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">process&amp;&amp;</span><span class="s0">null</span><span class="s1">!==process,n=!!s&amp;&amp;Boolean(process.execArgv&amp;&amp;-</span><span class="s3">1</span><span class="s1">!==process.execArgv.indexOf(</span><span class="s2">&quot;--force-node-api-uncaught-exceptions-policy&quot;</span><span class="s1">));</span><span class="s0">if</span><span class="s1">(t.moduleApiVersion&lt;</span><span class="s3">10</span><span class="s1">&amp;&amp;!n&amp;&amp;!e){</span><span class="s0">return void</span><span class="s1">(s&amp;&amp;</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">process.emitWarning?process.emitWarning:</span><span class="s0">function</span><span class="s1">(e,t,i){</span><span class="s0">if</span><span class="s1">(e </span><span class="s0">instanceof </span><span class="s1">Error)console.warn(e.toString());</span><span class="s0">else</span><span class="s1">{</span><span class="s0">const </span><span class="s1">s=i?</span><span class="s2">`[</span><span class="s1">${i}</span><span class="s2">] `</span><span class="s1">:</span><span class="s2">&quot;&quot;</span><span class="s1">;console.warn(</span><span class="s2">`</span><span class="s1">${s}${t||</span><span class="s2">&quot;Warning&quot;</span><span class="s1">}</span><span class="s2">: </span><span class="s1">${e}</span><span class="s2">`</span><span class="s1">)}})(</span><span class="s2">&quot;Uncaught N-API callback exception detected, please run node with option --force-node-api-uncaught-exceptions-policy=true to handle those exceptions properly.&quot;</span><span class="s1">,</span><span class="s2">&quot;DeprecationWarning&quot;</span><span class="s1">,</span><span class="s2">&quot;DEP0168&quot;</span><span class="s1">)}t.triggerFatalException(i)})}callFinalizer(e,t,i){</span><span class="s0">this</span><span class="s1">.callFinalizerInternal(</span><span class="s3">1</span><span class="s1">,e,t,i)}callFinalizerInternal(e,t,i,s){</span><span class="s0">const </span><span class="s1">n=</span><span class="s0">this</span><span class="s1">.makeDynCall_vppp(t),r=</span><span class="s0">this</span><span class="s1">.id,o=</span><span class="s0">this</span><span class="s1">.ctx.openScope(</span><span class="s0">this</span><span class="s1">);</span><span class="s0">try</span><span class="s1">{</span><span class="s0">this</span><span class="s1">.callbackIntoModule(Boolean(e),()=&gt;{n(r,i,s)})}</span><span class="s0">finally</span><span class="s1">{</span><span class="s0">this</span><span class="s1">.ctx.closeScope(</span><span class="s0">this</span><span class="s1">,o)}}enqueueFinalizer(e){</span><span class="s0">super</span><span class="s1">.enqueueFinalizer(e),</span><span class="s0">this</span><span class="s1">.finalizationScheduled||</span><span class="s0">this</span><span class="s1">.destructing||(</span><span class="s0">this</span><span class="s1">.finalizationScheduled=!</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.ref(),d(()=&gt;{</span><span class="s0">this</span><span class="s1">.finalizationScheduled=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.unref(),</span><span class="s0">this</span><span class="s1">.drainFinalizerQueue()}))}drainFinalizerQueue(){</span><span class="s0">for</span><span class="s1">(;</span><span class="s0">this</span><span class="s1">.pendingFinalizers.length&gt;</span><span class="s3">0</span><span class="s1">;){</span><span class="s0">this</span><span class="s1">.pendingFinalizers.shift().finalize()}}}</span><span class="s0">function </span><span class="s1">I(e,t,i,s,n,r,o){(i=</span><span class="s2">&quot;number&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">i?</span><span class="s3">8</span><span class="s1">:i)&lt;</span><span class="s3">8</span><span class="s1">?i=</span><span class="s3">8</span><span class="s1">:i&gt;</span><span class="s3">10</span><span class="s1">&amp;&amp;i!==g&amp;&amp;</span><span class="s0">function</span><span class="s1">(e,t){</span><span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">`</span><span class="s1">${e} </span><span class="s2">requires Node-API version </span><span class="s1">${t}</span><span class="s2">, but this version of Node.js only supports version 10 add-ons.`</span><span class="s1">)}(t,i);</span><span class="s0">const </span><span class="s1">a=</span><span class="s0">new </span><span class="s1">F(e,t,i,s,n,r,o);</span><span class="s0">return </span><span class="s1">e.envStore.add(a),e.addCleanupHook(a,()=&gt;{a.unref()},</span><span class="s3">0</span><span class="s1">),a}</span><span class="s0">class </span><span class="s1">O </span><span class="s0">extends </span><span class="s1">Error{constructor(e){</span><span class="s0">super</span><span class="s1">(e);</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">new</span><span class="s1">.target,i=t.prototype;</span><span class="s0">if</span><span class="s1">(!(</span><span class="s0">this instanceof </span><span class="s1">O)){</span><span class="s0">const </span><span class="s1">e=Object.setPrototypeOf;</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">e?e.call(Object,</span><span class="s0">this</span><span class="s1">,i):</span><span class="s0">this</span><span class="s1">.__proto__=i,</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">Error.captureStackTrace&amp;&amp;Error.captureStackTrace(</span><span class="s0">this</span><span class="s1">,t)}}}Object.defineProperty(O.prototype,</span><span class="s2">&quot;name&quot;</span><span class="s1">,{configurable:!</span><span class="s3">0</span><span class="s1">,writable:!</span><span class="s3">0</span><span class="s1">,value:</span><span class="s2">&quot;EmnapiError&quot;</span><span class="s1">});</span><span class="s0">class </span><span class="s1">D </span><span class="s0">extends </span><span class="s1">O{constructor(e,t){</span><span class="s0">super</span><span class="s1">(</span><span class="s2">`</span><span class="s1">${e}</span><span class="s2">: The current runtime does not support &quot;FinalizationRegistry&quot; and &quot;WeakRef&quot;.</span><span class="s1">${t?</span><span class="s2">` </span><span class="s1">${t}</span><span class="s2">`</span><span class="s1">:</span><span class="s2">&quot;&quot;</span><span class="s1">}</span><span class="s2">`</span><span class="s1">)}}Object.defineProperty(D.prototype,</span><span class="s2">&quot;name&quot;</span><span class="s1">,{configurable:!</span><span class="s3">0</span><span class="s1">,writable:!</span><span class="s3">0</span><span class="s1">,value:</span><span class="s2">&quot;NotSupportWeakRefError&quot;</span><span class="s1">});</span><span class="s0">class </span><span class="s1">R </span><span class="s0">extends </span><span class="s1">O{constructor(e,t){</span><span class="s0">super</span><span class="s1">(</span><span class="s2">`</span><span class="s1">${e}</span><span class="s2">: The current runtime does not support &quot;Buffer&quot;. Consider using buffer polyfill to make sure </span><span class="s4">\`</span><span class="s2">globalThis.Buffer</span><span class="s4">\` </span><span class="s2">is defined.</span><span class="s1">${t?</span><span class="s2">` </span><span class="s1">${t}</span><span class="s2">`</span><span class="s1">:</span><span class="s2">&quot;&quot;</span><span class="s1">}</span><span class="s2">`</span><span class="s1">)}}Object.defineProperty(R.prototype,</span><span class="s2">&quot;name&quot;</span><span class="s1">,{configurable:!</span><span class="s3">0</span><span class="s1">,writable:!</span><span class="s3">0</span><span class="s1">,value:</span><span class="s2">&quot;NotSupportBufferError&quot;</span><span class="s1">});</span><span class="s0">class </span><span class="s1">N{constructor(e){</span><span class="s0">this</span><span class="s1">._value=e}deref(){</span><span class="s0">return this</span><span class="s1">._value}dispose(){</span><span class="s0">this</span><span class="s1">._value=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">}}</span><span class="s0">class </span><span class="s1">H{constructor(e){</span><span class="s0">this</span><span class="s1">._ref=</span><span class="s0">new </span><span class="s1">N(e)}setWeak(e,t){</span><span class="s0">if</span><span class="s1">(!c||</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===</span><span class="s0">this</span><span class="s1">._ref||</span><span class="s0">this</span><span class="s1">._ref </span><span class="s0">instanceof </span><span class="s1">WeakRef)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const </span><span class="s1">i=</span><span class="s0">this</span><span class="s1">._ref.deref();</span><span class="s0">try</span><span class="s1">{H._registry.register(i,</span><span class="s0">this</span><span class="s1">,</span><span class="s0">this</span><span class="s1">);</span><span class="s0">const </span><span class="s1">s=</span><span class="s0">new </span><span class="s1">WeakRef(i);</span><span class="s0">this</span><span class="s1">._ref.dispose(),</span><span class="s0">this</span><span class="s1">._ref=s,</span><span class="s0">this</span><span class="s1">._param=e,</span><span class="s0">this</span><span class="s1">._callback=t}</span><span class="s0">catch</span><span class="s1">(e){</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;symbol&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">i)</span><span class="s0">throw </span><span class="s1">e}}clearWeak(){</span><span class="s0">if</span><span class="s1">(c&amp;&amp;</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">._ref&amp;&amp;</span><span class="s0">this</span><span class="s1">._ref </span><span class="s0">instanceof </span><span class="s1">WeakRef){</span><span class="s0">try</span><span class="s1">{H._registry.unregister(</span><span class="s0">this</span><span class="s1">)}</span><span class="s0">catch</span><span class="s1">(e){}</span><span class="s0">this</span><span class="s1">._param=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">._callback=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">;</span><span class="s0">const </span><span class="s1">e=</span><span class="s0">this</span><span class="s1">._ref.deref();</span><span class="s0">this</span><span class="s1">._ref=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===e?e:</span><span class="s0">new </span><span class="s1">N(e)}}reset(){</span><span class="s0">if</span><span class="s1">(c)</span><span class="s0">try</span><span class="s1">{H._registry.unregister(</span><span class="s0">this</span><span class="s1">)}</span><span class="s0">catch</span><span class="s1">(e){}</span><span class="s0">this</span><span class="s1">._param=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">._callback=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">._ref </span><span class="s0">instanceof </span><span class="s1">N&amp;&amp;</span><span class="s0">this</span><span class="s1">._ref.dispose(),</span><span class="s0">this</span><span class="s1">._ref=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">}isEmpty(){</span><span class="s0">return void </span><span class="s3">0</span><span class="s1">===</span><span class="s0">this</span><span class="s1">._ref}deref(){</span><span class="s0">if</span><span class="s1">(</span><span class="s0">void </span><span class="s3">0</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">._ref)</span><span class="s0">return this</span><span class="s1">._ref.deref()}}</span><span class="s0">var </span><span class="s1">A;H._registry=c?</span><span class="s0">new </span><span class="s1">FinalizationRegistry(e=&gt;{e._ref=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">;</span><span class="s0">const </span><span class="s1">t=e._callback,i=e._param;e._callback=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,e._param=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">t&amp;&amp;t(i)}):</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,exports.ReferenceOwnership=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,(A=exports.ReferenceOwnership||(exports.ReferenceOwnership={}))[A.kRuntime=</span><span class="s3">0</span><span class="s1">]=</span><span class="s2">&quot;kRuntime&quot;</span><span class="s1">,A[A.kUserland=</span><span class="s3">1</span><span class="s1">]=</span><span class="s2">&quot;kUserland&quot;</span><span class="s1">;</span><span class="s0">class </span><span class="s1">j </span><span class="s0">extends </span><span class="s1">w{</span><span class="s0">static </span><span class="s1">weakCallback(e){e.persistent.reset(),e.invokeFinalizerFromGC()}</span><span class="s0">static </span><span class="s1">create(e,t,i,s,n,r,o){</span><span class="s0">const </span><span class="s1">a=</span><span class="s0">new </span><span class="s1">j(e,t,i,s);</span><span class="s0">return </span><span class="s1">e.ctx.refStore.add(a),a.link(e.reflist),a}constructor(e,t,i,s){</span><span class="s0">super</span><span class="s1">(),</span><span class="s0">this</span><span class="s1">.envObject=e,</span><span class="s0">this</span><span class="s1">._refcount=i,</span><span class="s0">this</span><span class="s1">._ownership=s;</span><span class="s0">const </span><span class="s1">n=e.ctx.handleStore.get(t);</span><span class="s0">var </span><span class="s1">r;</span><span class="s0">this</span><span class="s1">.canBeWeak=(r=n).isObject()||r.isFunction()||r.isSymbol(),</span><span class="s0">this</span><span class="s1">.persistent=</span><span class="s0">new </span><span class="s1">H(n.value),</span><span class="s0">this</span><span class="s1">.id=</span><span class="s3">0</span><span class="s1">,</span><span class="s3">0</span><span class="s1">===i&amp;&amp;</span><span class="s0">this</span><span class="s1">._setWeak()}ref(){</span><span class="s0">return this</span><span class="s1">.persistent.isEmpty()?</span><span class="s3">0</span><span class="s1">:(</span><span class="s3">1</span><span class="s1">===++</span><span class="s0">this</span><span class="s1">._refcount&amp;&amp;</span><span class="s0">this</span><span class="s1">.canBeWeak&amp;&amp;</span><span class="s0">this</span><span class="s1">.persistent.clearWeak(),</span><span class="s0">this</span><span class="s1">._refcount)}unref(){</span><span class="s0">return this</span><span class="s1">.persistent.isEmpty()||</span><span class="s3">0</span><span class="s1">===</span><span class="s0">this</span><span class="s1">._refcount?</span><span class="s3">0</span><span class="s1">:(</span><span class="s3">0</span><span class="s1">===--</span><span class="s0">this</span><span class="s1">._refcount&amp;&amp;</span><span class="s0">this</span><span class="s1">._setWeak(),</span><span class="s0">this</span><span class="s1">._refcount)}get(e=</span><span class="s0">this</span><span class="s1">.envObject){</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.persistent.isEmpty())</span><span class="s0">return </span><span class="s3">0</span><span class="s1">;</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">this</span><span class="s1">.persistent.deref();</span><span class="s0">return </span><span class="s1">e.ensureHandle(t).id}resetFinalizer(){}data(){</span><span class="s0">return </span><span class="s3">0</span><span class="s1">}refcount(){</span><span class="s0">return this</span><span class="s1">._refcount}ownership(){</span><span class="s0">return this</span><span class="s1">._ownership}callUserFinalizer(){}invokeFinalizerFromGC(){</span><span class="s0">this</span><span class="s1">.finalize()}_setWeak(){</span><span class="s0">this</span><span class="s1">.canBeWeak?</span><span class="s0">this</span><span class="s1">.persistent.setWeak(</span><span class="s0">this</span><span class="s1">,j.weakCallback):</span><span class="s0">this</span><span class="s1">.persistent.reset()}finalize(){</span><span class="s0">this</span><span class="s1">.persistent.reset();</span><span class="s0">const </span><span class="s1">e=</span><span class="s0">this</span><span class="s1">._ownership===exports.ReferenceOwnership.kRuntime;</span><span class="s0">this</span><span class="s1">.unlink(),</span><span class="s0">this</span><span class="s1">.callUserFinalizer(),e&amp;&amp;</span><span class="s0">this</span><span class="s1">.dispose()}dispose(){</span><span class="s3">0</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">.id&amp;&amp;(</span><span class="s0">this</span><span class="s1">.unlink(),</span><span class="s0">this</span><span class="s1">.persistent.reset(),</span><span class="s0">this</span><span class="s1">.envObject.ctx.refStore.remove(</span><span class="s0">this</span><span class="s1">.id),</span><span class="s0">super</span><span class="s1">.dispose(),</span><span class="s0">this</span><span class="s1">.envObject=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.id=</span><span class="s3">0</span><span class="s1">)}}</span><span class="s0">class </span><span class="s1">B </span><span class="s0">extends </span><span class="s1">j{</span><span class="s0">static </span><span class="s1">create(e,t,i,s,n){</span><span class="s0">const </span><span class="s1">r=</span><span class="s0">new </span><span class="s1">B(e,t,i,s,n);</span><span class="s0">return </span><span class="s1">e.ctx.refStore.add(r),r.link(e.reflist),r}constructor(e,t,i,s,n){</span><span class="s0">super</span><span class="s1">(e,t,i,s),</span><span class="s0">this</span><span class="s1">._data=n}data(){</span><span class="s0">return this</span><span class="s1">._data}}</span><span class="s0">class </span><span class="s1">T </span><span class="s0">extends </span><span class="s1">j{</span><span class="s0">static </span><span class="s1">create(e,t,i,s,n,r,o){</span><span class="s0">const </span><span class="s1">a=</span><span class="s0">new </span><span class="s1">T(e,t,i,s,n,r,o);</span><span class="s0">return </span><span class="s1">e.ctx.refStore.add(a),a.link(e.finalizing_reflist),a}constructor(e,t,i,s,n,r,o){</span><span class="s0">super</span><span class="s1">(e,t,i,s),</span><span class="s0">this</span><span class="s1">._finalizer=</span><span class="s0">new </span><span class="s1">S(e,n,r,o)}resetFinalizer(){</span><span class="s0">this</span><span class="s1">._finalizer.resetFinalizer()}data(){</span><span class="s0">return this</span><span class="s1">._finalizer.data()}callUserFinalizer(){</span><span class="s0">this</span><span class="s1">._finalizer.callFinalizer()}invokeFinalizerFromGC(){</span><span class="s0">this</span><span class="s1">._finalizer.envObject.invokeFinalizerFromGC(</span><span class="s0">this</span><span class="s1">)}dispose(){</span><span class="s0">this</span><span class="s1">._finalizer&amp;&amp;(</span><span class="s0">this</span><span class="s1">._finalizer.envObject.dequeueFinalizer(</span><span class="s0">this</span><span class="s1">),</span><span class="s0">this</span><span class="s1">._finalizer.dispose(),</span><span class="s0">super</span><span class="s1">.dispose(),</span><span class="s0">this</span><span class="s1">._finalizer=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">)}}</span><span class="s0">class </span><span class="s1">W{</span><span class="s0">static </span><span class="s1">create(e,t){</span><span class="s0">const </span><span class="s1">i=</span><span class="s0">new </span><span class="s1">W(e,t);</span><span class="s0">return </span><span class="s1">e.deferredStore.add(i),i}constructor(e,t){</span><span class="s0">this</span><span class="s1">.id=</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.ctx=e,</span><span class="s0">this</span><span class="s1">.value=t}resolve(e){</span><span class="s0">this</span><span class="s1">.value.resolve(e),</span><span class="s0">this</span><span class="s1">.dispose()}reject(e){</span><span class="s0">this</span><span class="s1">.value.reject(e),</span><span class="s0">this</span><span class="s1">.dispose()}dispose(){</span><span class="s0">this</span><span class="s1">.ctx.deferredStore.remove(</span><span class="s0">this</span><span class="s1">.id),</span><span class="s0">this</span><span class="s1">.id=</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.value=</span><span class="s0">null</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.ctx=</span><span class="s0">null</span><span class="s1">}}</span><span class="s0">class </span><span class="s1">M{constructor(){</span><span class="s0">this</span><span class="s1">._values=[</span><span class="s0">void </span><span class="s3">0</span><span class="s1">],</span><span class="s0">this</span><span class="s1">._values.length=</span><span class="s3">4</span><span class="s1">,</span><span class="s0">this</span><span class="s1">._size=</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">._freeList=[]}add(e){</span><span class="s0">let </span><span class="s1">t;</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">._freeList.length)t=</span><span class="s0">this</span><span class="s1">._freeList.shift();</span><span class="s0">else</span><span class="s1">{t=</span><span class="s0">this</span><span class="s1">._size,</span><span class="s0">this</span><span class="s1">._size++;</span><span class="s0">const </span><span class="s1">e=</span><span class="s0">this</span><span class="s1">._values.length;t&gt;=e&amp;&amp;(</span><span class="s0">this</span><span class="s1">._values.length=e+(e&gt;&gt;</span><span class="s3">1</span><span class="s1">)+</span><span class="s3">16</span><span class="s1">)}e.id=t,</span><span class="s0">this</span><span class="s1">._values[t]=e}get(e){</span><span class="s0">return this</span><span class="s1">._values[e]}has(e){</span><span class="s0">return void </span><span class="s3">0</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">._values[e]}remove(e){</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">this</span><span class="s1">._values[e];t&amp;&amp;(t.id=</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">._values[e]=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">._freeList.push(Number(e)))}dispose(){</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">e=</span><span class="s3">1</span><span class="s1">;e&lt;</span><span class="s0">this</span><span class="s1">._size;++e){</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">this</span><span class="s1">._values[e];</span><span class="s0">null</span><span class="s1">==t||t.dispose()}</span><span class="s0">this</span><span class="s1">._values=[</span><span class="s0">void </span><span class="s3">0</span><span class="s1">],</span><span class="s0">this</span><span class="s1">._size=</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">._freeList=[]}}</span><span class="s0">class </span><span class="s1">L{constructor(e,t,i,s){</span><span class="s0">this</span><span class="s1">.envObject=e,</span><span class="s0">this</span><span class="s1">.fn=t,</span><span class="s0">this</span><span class="s1">.arg=i,</span><span class="s0">this</span><span class="s1">.order=s}}</span><span class="s0">class </span><span class="s1">P{constructor(){</span><span class="s0">this</span><span class="s1">._cleanupHooks=[],</span><span class="s0">this</span><span class="s1">._cleanupHookCounter=</span><span class="s3">0</span><span class="s1">}empty(){</span><span class="s0">return </span><span class="s3">0</span><span class="s1">===</span><span class="s0">this</span><span class="s1">._cleanupHooks.length}add(e,t,i){</span><span class="s0">if</span><span class="s1">(</span><span class="s0">this</span><span class="s1">._cleanupHooks.filter(s=&gt;s.envObject===e&amp;&amp;s.fn===t&amp;&amp;s.arg===i).length&gt;</span><span class="s3">0</span><span class="s1">)</span><span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Can not add same fn and arg twice&quot;</span><span class="s1">);</span><span class="s0">this</span><span class="s1">._cleanupHooks.push(</span><span class="s0">new </span><span class="s1">L(e,t,i,</span><span class="s0">this</span><span class="s1">._cleanupHookCounter++))}remove(e,t,i){</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">s=</span><span class="s3">0</span><span class="s1">;s&lt;</span><span class="s0">this</span><span class="s1">._cleanupHooks.length;++s){</span><span class="s0">const </span><span class="s1">n=</span><span class="s0">this</span><span class="s1">._cleanupHooks[s];</span><span class="s0">if</span><span class="s1">(n.envObject===e&amp;&amp;n.fn===t&amp;&amp;n.arg===i)</span><span class="s0">return void this</span><span class="s1">._cleanupHooks.splice(s,</span><span class="s3">1</span><span class="s1">)}}drain(){</span><span class="s0">const </span><span class="s1">e=</span><span class="s0">this</span><span class="s1">._cleanupHooks.slice();e.sort((e,t)=&gt;t.order-e.order);</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">t=</span><span class="s3">0</span><span class="s1">;t&lt;e.length;++t){</span><span class="s0">const </span><span class="s1">i=e[t];</span><span class="s2">&quot;number&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">i.fn?i.envObject.makeDynCall_vp(i.fn)(i.arg):i.fn(i.arg),</span><span class="s0">this</span><span class="s1">._cleanupHooks.splice(</span><span class="s0">this</span><span class="s1">._cleanupHooks.indexOf(i),</span><span class="s3">1</span><span class="s1">)}}dispose(){</span><span class="s0">this</span><span class="s1">._cleanupHooks.length=</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">._cleanupHookCounter=</span><span class="s3">0</span><span class="s1">}}</span><span class="s0">class </span><span class="s1">U{constructor(){</span><span class="s0">this</span><span class="s1">.refHandle=(</span><span class="s0">new </span><span class="s1">f).port1,</span><span class="s0">this</span><span class="s1">.count=</span><span class="s3">0</span><span class="s1">}increase(){</span><span class="s3">0</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.count&amp;&amp;</span><span class="s0">this</span><span class="s1">.refHandle.ref&amp;&amp;</span><span class="s0">this</span><span class="s1">.refHandle.ref(),</span><span class="s0">this</span><span class="s1">.count++}decrease(){</span><span class="s3">0</span><span class="s1">!==</span><span class="s0">this</span><span class="s1">.count&amp;&amp;(</span><span class="s3">1</span><span class="s1">===</span><span class="s0">this</span><span class="s1">.count&amp;&amp;</span><span class="s0">this</span><span class="s1">.refHandle.unref&amp;&amp;</span><span class="s0">this</span><span class="s1">.refHandle.unref(),</span><span class="s0">this</span><span class="s1">.count--)}}</span><span class="s0">class </span><span class="s1">V{constructor(){</span><span class="s0">this</span><span class="s1">._isStopping=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">._canCallIntoJs=!</span><span class="s3">0</span><span class="s1">,</span><span class="s0">this</span><span class="s1">._suppressDestroy=!</span><span class="s3">1</span><span class="s1">,</span><span class="s0">this</span><span class="s1">.envStore=</span><span class="s0">new </span><span class="s1">M,</span><span class="s0">this</span><span class="s1">.scopeStore=</span><span class="s0">new </span><span class="s1">b,</span><span class="s0">this</span><span class="s1">.refStore=</span><span class="s0">new </span><span class="s1">M,</span><span class="s0">this</span><span class="s1">.deferredStore=</span><span class="s0">new </span><span class="s1">M,</span><span class="s0">this</span><span class="s1">.handleStore=</span><span class="s0">new </span><span class="s1">z,</span><span class="s0">this</span><span class="s1">.feature={supportReflect:l,supportFinalizer:c,supportWeakSymbol:h,supportBigInt:u,supportNewFunction:n,canSetFunctionName:a,setImmediate:d,Buffer:_,MessageChannel:f},</span><span class="s0">this</span><span class="s1">.cleanupQueue=</span><span class="s0">new </span><span class="s1">P,</span><span class="s2">&quot;object&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">process&amp;&amp;</span><span class="s0">null</span><span class="s1">!==process&amp;&amp;</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">process.once&amp;&amp;(</span><span class="s0">this</span><span class="s1">.refCounter=</span><span class="s0">new </span><span class="s1">U,process.once(</span><span class="s2">&quot;beforeExit&quot;</span><span class="s1">,()=&gt;{</span><span class="s0">this</span><span class="s1">._suppressDestroy||</span><span class="s0">this</span><span class="s1">.destroy()}))}suppressDestroy(){</span><span class="s0">this</span><span class="s1">._suppressDestroy=!</span><span class="s3">0</span><span class="s1">}getRuntimeVersions(){</span><span class="s0">return</span><span class="s1">{version:v,NODE_API_SUPPORTED_VERSION_MAX:</span><span class="s3">10</span><span class="s1">,NAPI_VERSION_EXPERIMENTAL:g,NODE_API_DEFAULT_MODULE_API_VERSION:</span><span class="s3">8</span><span class="s1">}}createNotSupportWeakRefError(e,t){</span><span class="s0">return new </span><span class="s1">D(e,t)}createNotSupportBufferError(e,t){</span><span class="s0">return new </span><span class="s1">R(e,t)}createReference(e,t,i,s){</span><span class="s0">return </span><span class="s1">j.create(e,t,i,s)}createReferenceWithData(e,t,i,s,n){</span><span class="s0">return </span><span class="s1">B.create(e,t,i,s,n)}createReferenceWithFinalizer(e,t,i,s,n=</span><span class="s3">0</span><span class="s1">,r=</span><span class="s3">0</span><span class="s1">,o=</span><span class="s3">0</span><span class="s1">){</span><span class="s0">return </span><span class="s1">T.create(e,t,i,s,n,r,o)}createDeferred(e){</span><span class="s0">return </span><span class="s1">W.create(</span><span class="s0">this</span><span class="s1">,e)}createEnv(e,t,i,s,n,r){</span><span class="s0">return </span><span class="s1">I(</span><span class="s0">this</span><span class="s1">,e,t,i,s,n,r)}createTrackedFinalizer(e,t,i,s){</span><span class="s0">return </span><span class="s1">E.create(e,t,i,s)}getCurrentScope(){</span><span class="s0">return this</span><span class="s1">.scopeStore.currentScope}addToCurrentScope(e){</span><span class="s0">return this</span><span class="s1">.scopeStore.currentScope.add(e)}openScope(e){</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">this</span><span class="s1">.scopeStore.openScope(</span><span class="s0">this</span><span class="s1">.handleStore);</span><span class="s0">return </span><span class="s1">e&amp;&amp;e.openHandleScopes++,t}closeScope(e,t){e&amp;&amp;</span><span class="s3">0</span><span class="s1">===e.openHandleScopes||(</span><span class="s0">this</span><span class="s1">.scopeStore.closeScope(),e&amp;&amp;e.openHandleScopes--)}ensureHandle(e){</span><span class="s0">switch</span><span class="s1">(e){</span><span class="s0">case void </span><span class="s3">0</span><span class="s1">:</span><span class="s0">return </span><span class="s1">z.UNDEFINED;</span><span class="s0">case null</span><span class="s1">:</span><span class="s0">return </span><span class="s1">z.NULL;</span><span class="s0">case</span><span class="s1">!</span><span class="s3">0</span><span class="s1">:</span><span class="s0">return </span><span class="s1">z.TRUE;</span><span class="s0">case</span><span class="s1">!</span><span class="s3">1</span><span class="s1">:</span><span class="s0">return </span><span class="s1">z.FALSE;</span><span class="s0">case </span><span class="s1">r:</span><span class="s0">return </span><span class="s1">z.GLOBAL}</span><span class="s0">return this</span><span class="s1">.addToCurrentScope(e)}addCleanupHook(e,t,i){</span><span class="s0">this</span><span class="s1">.cleanupQueue.add(e,t,i)}removeCleanupHook(e,t,i){</span><span class="s0">this</span><span class="s1">.cleanupQueue.remove(e,t,i)}runCleanup(){</span><span class="s0">for</span><span class="s1">(;!</span><span class="s0">this</span><span class="s1">.cleanupQueue.empty();)</span><span class="s0">this</span><span class="s1">.cleanupQueue.drain()}increaseWaitingRequestCounter(){</span><span class="s0">var </span><span class="s1">e;</span><span class="s0">null</span><span class="s1">===(e=</span><span class="s0">this</span><span class="s1">.refCounter)||</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===e||e.increase()}decreaseWaitingRequestCounter(){</span><span class="s0">var </span><span class="s1">e;</span><span class="s0">null</span><span class="s1">===(e=</span><span class="s0">this</span><span class="s1">.refCounter)||</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===e||e.decrease()}setCanCallIntoJs(e){</span><span class="s0">this</span><span class="s1">._canCallIntoJs=e}setStopping(e){</span><span class="s0">this</span><span class="s1">._isStopping=e}canCallIntoJs(){</span><span class="s0">return this</span><span class="s1">._canCallIntoJs&amp;&amp;!</span><span class="s0">this</span><span class="s1">._isStopping}destroy(){</span><span class="s0">this</span><span class="s1">.setStopping(!</span><span class="s3">0</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.setCanCallIntoJs(!</span><span class="s3">1</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.runCleanup()}}</span><span class="s0">let </span><span class="s1">G;</span><span class="s0">function </span><span class="s1">q(){</span><span class="s0">return new </span><span class="s1">V}exports.ConstHandle=x,exports.Context=V,exports.Deferred=W,exports.EmnapiError=O,exports.Env=C,exports.External=i,exports.Finalizer=S,exports.Handle=y,exports.HandleScope=k,exports.HandleStore=z,exports.NAPI_VERSION_EXPERIMENTAL=g,exports.NODE_API_DEFAULT_MODULE_API_VERSION=</span><span class="s3">8</span><span class="s1">,exports.NODE_API_SUPPORTED_VERSION_MAX=</span><span class="s3">10</span><span class="s1">,exports.NODE_API_SUPPORTED_VERSION_MIN=</span><span class="s3">1</span><span class="s1">,exports.NodeEnv=F,exports.NotSupportBufferError=R,exports.NotSupportWeakRefError=D,exports.Persistent=H,exports.RefTracker=w,exports.Reference=j,exports.ReferenceWithData=B,exports.ReferenceWithFinalizer=T,exports.ScopeStore=b,exports.Store=M,exports.TrackedFinalizer=E,exports.TryCatch=o,exports.createContext=q,exports.getDefaultContext=</span><span class="s0">function</span><span class="s1">(){</span><span class="s0">return </span><span class="s1">G||(G=q()),G},exports.getExternalValue=s,exports.isExternal=t,exports.isReferenceType=</span><span class="s0">function</span><span class="s1">(e){</span><span class="s0">return</span><span class="s2">&quot;object&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">e&amp;&amp;</span><span class="s0">null</span><span class="s1">!==e||</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">e},exports.version=v;</span>
</pre>
</body>
</html>