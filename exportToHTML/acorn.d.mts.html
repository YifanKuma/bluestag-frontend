<html>
<head>
<title>acorn.d.mts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #8c8c8c; font-style: italic;}
.s3 { color: #067d17;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
acorn.d.mts</font>
</center></td></tr></table>
<pre><span class="s0">export interface </span><span class="s1">Node {</span>
  <span class="s1">start: number</span>
  <span class="s1">end: number</span>
  <span class="s1">type: string</span>
  <span class="s1">range?: [number, number]</span>
  <span class="s1">loc?: SourceLocation | </span><span class="s0">null</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">SourceLocation {</span>
  <span class="s1">source?: string | </span><span class="s0">null</span>
  <span class="s1">start: Position</span>
  <span class="s1">end: Position</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">Position {</span>
  <span class="s2">/** 1-based */</span>
  <span class="s1">line: number</span>
  <span class="s2">/** 0-based */</span>
  <span class="s1">column: number</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">Identifier </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;Identifier&quot;</span>
  <span class="s1">name: string</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">Literal </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;Literal&quot;</span>
  <span class="s1">value?: string | boolean | </span><span class="s0">null </span><span class="s1">| number | RegExp | bigint</span>
  <span class="s1">raw?: string</span>
  <span class="s1">regex?: {</span>
    <span class="s1">pattern: string</span>
    <span class="s1">flags: string</span>
  <span class="s1">}</span>
  <span class="s1">bigint?: string</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">Program </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;Program&quot;</span>
  <span class="s1">body: Array&lt;Statement | ModuleDeclaration&gt;</span>
  <span class="s1">sourceType: </span><span class="s3">&quot;script&quot; </span><span class="s1">| </span><span class="s3">&quot;module&quot;</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">Function </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">id?: Identifier | </span><span class="s0">null</span>
  <span class="s1">params: Array&lt;Pattern&gt;</span>
  <span class="s1">body: BlockStatement | Expression</span>
  <span class="s1">generator: boolean</span>
  <span class="s1">expression: boolean</span>
  <span class="s1">async: boolean</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">ExpressionStatement </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;ExpressionStatement&quot;</span>
  <span class="s1">expression: Expression | Literal</span>
  <span class="s1">directive?: string</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">BlockStatement </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;BlockStatement&quot;</span>
  <span class="s1">body: Array&lt;Statement&gt;</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">EmptyStatement </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;EmptyStatement&quot;</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">DebuggerStatement </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;DebuggerStatement&quot;</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">WithStatement </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;WithStatement&quot;</span>
  <span class="s1">object: Expression</span>
  <span class="s1">body: Statement</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">ReturnStatement </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;ReturnStatement&quot;</span>
  <span class="s1">argument?: Expression | </span><span class="s0">null</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">LabeledStatement </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;LabeledStatement&quot;</span>
  <span class="s1">label: Identifier</span>
  <span class="s1">body: Statement</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">BreakStatement </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;BreakStatement&quot;</span>
  <span class="s1">label?: Identifier | </span><span class="s0">null</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">ContinueStatement </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;ContinueStatement&quot;</span>
  <span class="s1">label?: Identifier | </span><span class="s0">null</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">IfStatement </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;IfStatement&quot;</span>
  <span class="s1">test: Expression</span>
  <span class="s1">consequent: Statement</span>
  <span class="s1">alternate?: Statement | </span><span class="s0">null</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">SwitchStatement </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;SwitchStatement&quot;</span>
  <span class="s1">discriminant: Expression</span>
  <span class="s1">cases: Array&lt;SwitchCase&gt;</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">SwitchCase </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;SwitchCase&quot;</span>
  <span class="s1">test?: Expression | </span><span class="s0">null</span>
  <span class="s1">consequent: Array&lt;Statement&gt;</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">ThrowStatement </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;ThrowStatement&quot;</span>
  <span class="s1">argument: Expression</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">TryStatement </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;TryStatement&quot;</span>
  <span class="s1">block: BlockStatement</span>
  <span class="s1">handler?: CatchClause | </span><span class="s0">null</span>
  <span class="s1">finalizer?: BlockStatement | </span><span class="s0">null</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">CatchClause </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;CatchClause&quot;</span>
  <span class="s1">param?: Pattern | </span><span class="s0">null</span>
  <span class="s1">body: BlockStatement</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">WhileStatement </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;WhileStatement&quot;</span>
  <span class="s1">test: Expression</span>
  <span class="s1">body: Statement</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">DoWhileStatement </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;DoWhileStatement&quot;</span>
  <span class="s1">body: Statement</span>
  <span class="s1">test: Expression</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">ForStatement </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;ForStatement&quot;</span>
  <span class="s1">init?: VariableDeclaration | Expression | </span><span class="s0">null</span>
  <span class="s1">test?: Expression | </span><span class="s0">null</span>
  <span class="s1">update?: Expression | </span><span class="s0">null</span>
  <span class="s1">body: Statement</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">ForInStatement </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;ForInStatement&quot;</span>
  <span class="s1">left: VariableDeclaration | Pattern</span>
  <span class="s1">right: Expression</span>
  <span class="s1">body: Statement</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">FunctionDeclaration </span><span class="s0">extends </span><span class="s1">Function {</span>
  <span class="s1">type: </span><span class="s3">&quot;FunctionDeclaration&quot;</span>
  <span class="s1">id: Identifier</span>
  <span class="s1">body: BlockStatement</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">VariableDeclaration </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;VariableDeclaration&quot;</span>
  <span class="s1">declarations: Array&lt;VariableDeclarator&gt;</span>
  <span class="s1">kind: </span><span class="s3">&quot;var&quot; </span><span class="s1">| </span><span class="s3">&quot;let&quot; </span><span class="s1">| </span><span class="s3">&quot;const&quot; </span><span class="s1">| </span><span class="s3">&quot;using&quot; </span><span class="s1">| </span><span class="s3">&quot;await using&quot;</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">VariableDeclarator </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;VariableDeclarator&quot;</span>
  <span class="s1">id: Pattern</span>
  <span class="s1">init?: Expression | </span><span class="s0">null</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">ThisExpression </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;ThisExpression&quot;</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">ArrayExpression </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;ArrayExpression&quot;</span>
  <span class="s1">elements: Array&lt;Expression | SpreadElement | </span><span class="s0">null</span><span class="s1">&gt;</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">ObjectExpression </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;ObjectExpression&quot;</span>
  <span class="s1">properties: Array&lt;Property | SpreadElement&gt;</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">Property </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;Property&quot;</span>
  <span class="s1">key: Expression</span>
  <span class="s1">value: Expression</span>
  <span class="s1">kind: </span><span class="s3">&quot;init&quot; </span><span class="s1">| </span><span class="s3">&quot;get&quot; </span><span class="s1">| </span><span class="s3">&quot;set&quot;</span>
  <span class="s1">method: boolean</span>
  <span class="s1">shorthand: boolean</span>
  <span class="s1">computed: boolean</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">FunctionExpression </span><span class="s0">extends </span><span class="s1">Function {</span>
  <span class="s1">type: </span><span class="s3">&quot;FunctionExpression&quot;</span>
  <span class="s1">body: BlockStatement</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">UnaryExpression </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;UnaryExpression&quot;</span>
  <span class="s1">operator: UnaryOperator</span>
  <span class="s1">prefix: boolean</span>
  <span class="s1">argument: Expression</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">type UnaryOperator = </span><span class="s3">&quot;-&quot; </span><span class="s1">| </span><span class="s3">&quot;+&quot; </span><span class="s1">| </span><span class="s3">&quot;!&quot; </span><span class="s1">| </span><span class="s3">&quot;~&quot; </span><span class="s1">| </span><span class="s3">&quot;typeof&quot; </span><span class="s1">| </span><span class="s3">&quot;void&quot; </span><span class="s1">| </span><span class="s3">&quot;delete&quot;</span>

<span class="s0">export interface </span><span class="s1">UpdateExpression </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;UpdateExpression&quot;</span>
  <span class="s1">operator: UpdateOperator</span>
  <span class="s1">argument: Expression</span>
  <span class="s1">prefix: boolean</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">type UpdateOperator = </span><span class="s3">&quot;++&quot; </span><span class="s1">| </span><span class="s3">&quot;--&quot;</span>

<span class="s0">export interface </span><span class="s1">BinaryExpression </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;BinaryExpression&quot;</span>
  <span class="s1">operator: BinaryOperator</span>
  <span class="s1">left: Expression | PrivateIdentifier</span>
  <span class="s1">right: Expression</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">type BinaryOperator = </span><span class="s3">&quot;==&quot; </span><span class="s1">| </span><span class="s3">&quot;!=&quot; </span><span class="s1">| </span><span class="s3">&quot;===&quot; </span><span class="s1">| </span><span class="s3">&quot;!==&quot; </span><span class="s1">| </span><span class="s3">&quot;&lt;&quot; </span><span class="s1">| </span><span class="s3">&quot;&lt;=&quot; </span><span class="s1">| </span><span class="s3">&quot;&gt;&quot; </span><span class="s1">| </span><span class="s3">&quot;&gt;=&quot; </span><span class="s1">| </span><span class="s3">&quot;&lt;&lt;&quot; </span><span class="s1">| </span><span class="s3">&quot;&gt;&gt;&quot; </span><span class="s1">| </span><span class="s3">&quot;&gt;&gt;&gt;&quot; </span><span class="s1">| </span><span class="s3">&quot;+&quot; </span><span class="s1">| </span><span class="s3">&quot;-&quot; </span><span class="s1">| </span><span class="s3">&quot;*&quot; </span><span class="s1">| </span><span class="s3">&quot;/&quot; </span><span class="s1">| </span><span class="s3">&quot;%&quot; </span><span class="s1">| </span><span class="s3">&quot;|&quot; </span><span class="s1">| </span><span class="s3">&quot;^&quot; </span><span class="s1">| </span><span class="s3">&quot;&amp;&quot; </span><span class="s1">| </span><span class="s3">&quot;in&quot; </span><span class="s1">| </span><span class="s3">&quot;instanceof&quot; </span><span class="s1">| </span><span class="s3">&quot;**&quot;</span>

<span class="s0">export interface </span><span class="s1">AssignmentExpression </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;AssignmentExpression&quot;</span>
  <span class="s1">operator: AssignmentOperator</span>
  <span class="s1">left: Pattern</span>
  <span class="s1">right: Expression</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">type AssignmentOperator = </span><span class="s3">&quot;=&quot; </span><span class="s1">| </span><span class="s3">&quot;+=&quot; </span><span class="s1">| </span><span class="s3">&quot;-=&quot; </span><span class="s1">| </span><span class="s3">&quot;*=&quot; </span><span class="s1">| </span><span class="s3">&quot;/=&quot; </span><span class="s1">| </span><span class="s3">&quot;%=&quot; </span><span class="s1">| </span><span class="s3">&quot;&lt;&lt;=&quot; </span><span class="s1">| </span><span class="s3">&quot;&gt;&gt;=&quot; </span><span class="s1">| </span><span class="s3">&quot;&gt;&gt;&gt;=&quot; </span><span class="s1">| </span><span class="s3">&quot;|=&quot; </span><span class="s1">| </span><span class="s3">&quot;^=&quot; </span><span class="s1">| </span><span class="s3">&quot;&amp;=&quot; </span><span class="s1">| </span><span class="s3">&quot;**=&quot; </span><span class="s1">| </span><span class="s3">&quot;||=&quot; </span><span class="s1">| </span><span class="s3">&quot;&amp;&amp;=&quot; </span><span class="s1">| </span><span class="s3">&quot;??=&quot;</span>

<span class="s0">export interface </span><span class="s1">LogicalExpression </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;LogicalExpression&quot;</span>
  <span class="s1">operator: LogicalOperator</span>
  <span class="s1">left: Expression</span>
  <span class="s1">right: Expression</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">type LogicalOperator = </span><span class="s3">&quot;||&quot; </span><span class="s1">| </span><span class="s3">&quot;&amp;&amp;&quot; </span><span class="s1">| </span><span class="s3">&quot;??&quot;</span>

<span class="s0">export interface </span><span class="s1">MemberExpression </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;MemberExpression&quot;</span>
  <span class="s1">object: Expression | Super</span>
  <span class="s1">property: Expression | PrivateIdentifier</span>
  <span class="s1">computed: boolean</span>
  <span class="s1">optional: boolean</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">ConditionalExpression </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;ConditionalExpression&quot;</span>
  <span class="s1">test: Expression</span>
  <span class="s1">alternate: Expression</span>
  <span class="s1">consequent: Expression</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">CallExpression </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;CallExpression&quot;</span>
  <span class="s1">callee: Expression | Super</span>
  <span class="s1">arguments: Array&lt;Expression | SpreadElement&gt;</span>
  <span class="s1">optional: boolean</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">NewExpression </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;NewExpression&quot;</span>
  <span class="s1">callee: Expression</span>
  <span class="s1">arguments: Array&lt;Expression | SpreadElement&gt;</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">SequenceExpression </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;SequenceExpression&quot;</span>
  <span class="s1">expressions: Array&lt;Expression&gt;</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">ForOfStatement </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;ForOfStatement&quot;</span>
  <span class="s1">left: VariableDeclaration | Pattern</span>
  <span class="s1">right: Expression</span>
  <span class="s1">body: Statement</span>
  <span class="s0">await</span><span class="s1">: boolean</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">Super </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;Super&quot;</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">SpreadElement </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;SpreadElement&quot;</span>
  <span class="s1">argument: Expression</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">ArrowFunctionExpression </span><span class="s0">extends </span><span class="s1">Function {</span>
  <span class="s1">type: </span><span class="s3">&quot;ArrowFunctionExpression&quot;</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">YieldExpression </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;YieldExpression&quot;</span>
  <span class="s1">argument?: Expression | </span><span class="s0">null</span>
  <span class="s1">delegate: boolean</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">TemplateLiteral </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;TemplateLiteral&quot;</span>
  <span class="s1">quasis: Array&lt;TemplateElement&gt;</span>
  <span class="s1">expressions: Array&lt;Expression&gt;</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">TaggedTemplateExpression </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;TaggedTemplateExpression&quot;</span>
  <span class="s1">tag: Expression</span>
  <span class="s1">quasi: TemplateLiteral</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">TemplateElement </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;TemplateElement&quot;</span>
  <span class="s1">tail: boolean</span>
  <span class="s1">value: {</span>
    <span class="s1">cooked?: string | </span><span class="s0">null</span>
    <span class="s1">raw: string</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">AssignmentProperty </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;Property&quot;</span>
  <span class="s1">key: Expression</span>
  <span class="s1">value: Pattern</span>
  <span class="s1">kind: </span><span class="s3">&quot;init&quot;</span>
  <span class="s1">method: </span><span class="s0">false</span>
  <span class="s1">shorthand: boolean</span>
  <span class="s1">computed: boolean</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">ObjectPattern </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;ObjectPattern&quot;</span>
  <span class="s1">properties: Array&lt;AssignmentProperty | RestElement&gt;</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">ArrayPattern </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;ArrayPattern&quot;</span>
  <span class="s1">elements: Array&lt;Pattern | </span><span class="s0">null</span><span class="s1">&gt;</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">RestElement </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;RestElement&quot;</span>
  <span class="s1">argument: Pattern</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">AssignmentPattern </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;AssignmentPattern&quot;</span>
  <span class="s1">left: Pattern</span>
  <span class="s1">right: Expression</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">Class </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">id?: Identifier | </span><span class="s0">null</span>
  <span class="s1">superClass?: Expression | </span><span class="s0">null</span>
  <span class="s1">body: ClassBody</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">ClassBody </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;ClassBody&quot;</span>
  <span class="s1">body: Array&lt;MethodDefinition | PropertyDefinition | StaticBlock&gt;</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">MethodDefinition </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;MethodDefinition&quot;</span>
  <span class="s1">key: Expression | PrivateIdentifier</span>
  <span class="s1">value: FunctionExpression</span>
  <span class="s1">kind: </span><span class="s3">&quot;constructor&quot; </span><span class="s1">| </span><span class="s3">&quot;method&quot; </span><span class="s1">| </span><span class="s3">&quot;get&quot; </span><span class="s1">| </span><span class="s3">&quot;set&quot;</span>
  <span class="s1">computed: boolean</span>
  <span class="s0">static</span><span class="s1">: boolean</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">ClassDeclaration </span><span class="s0">extends </span><span class="s1">Class {</span>
  <span class="s1">type: </span><span class="s3">&quot;ClassDeclaration&quot;</span>
  <span class="s1">id: Identifier</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">ClassExpression </span><span class="s0">extends </span><span class="s1">Class {</span>
  <span class="s1">type: </span><span class="s3">&quot;ClassExpression&quot;</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">MetaProperty </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;MetaProperty&quot;</span>
  <span class="s1">meta: Identifier</span>
  <span class="s1">property: Identifier</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">ImportDeclaration </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;ImportDeclaration&quot;</span>
  <span class="s1">specifiers: Array&lt;ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier&gt;</span>
  <span class="s1">source: Literal</span>
  <span class="s1">attributes: Array&lt;ImportAttribute&gt;</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">ImportSpecifier </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;ImportSpecifier&quot;</span>
  <span class="s1">imported: Identifier | Literal</span>
  <span class="s1">local: Identifier</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">ImportDefaultSpecifier </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;ImportDefaultSpecifier&quot;</span>
  <span class="s1">local: Identifier</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">ImportNamespaceSpecifier </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;ImportNamespaceSpecifier&quot;</span>
  <span class="s1">local: Identifier</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">ImportAttribute </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;ImportAttribute&quot;</span>
  <span class="s1">key: Identifier | Literal</span>
  <span class="s1">value: Literal</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">ExportNamedDeclaration </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;ExportNamedDeclaration&quot;</span>
  <span class="s1">declaration?: Declaration | </span><span class="s0">null</span>
  <span class="s1">specifiers: Array&lt;ExportSpecifier&gt;</span>
  <span class="s1">source?: Literal | </span><span class="s0">null</span>
  <span class="s1">attributes: Array&lt;ImportAttribute&gt;</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">ExportSpecifier </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;ExportSpecifier&quot;</span>
  <span class="s1">exported: Identifier | Literal</span>
  <span class="s1">local: Identifier | Literal</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">AnonymousFunctionDeclaration </span><span class="s0">extends </span><span class="s1">Function {</span>
  <span class="s1">type: </span><span class="s3">&quot;FunctionDeclaration&quot;</span>
  <span class="s1">id: </span><span class="s0">null</span>
  <span class="s1">body: BlockStatement</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">AnonymousClassDeclaration </span><span class="s0">extends </span><span class="s1">Class {</span>
  <span class="s1">type: </span><span class="s3">&quot;ClassDeclaration&quot;</span>
  <span class="s1">id: </span><span class="s0">null</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">ExportDefaultDeclaration </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;ExportDefaultDeclaration&quot;</span>
  <span class="s1">declaration: AnonymousFunctionDeclaration | FunctionDeclaration | AnonymousClassDeclaration | ClassDeclaration | Expression</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">ExportAllDeclaration </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;ExportAllDeclaration&quot;</span>
  <span class="s1">source: Literal</span>
  <span class="s1">exported?: Identifier | Literal | </span><span class="s0">null</span>
  <span class="s1">attributes: Array&lt;ImportAttribute&gt;</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">AwaitExpression </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;AwaitExpression&quot;</span>
  <span class="s1">argument: Expression</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">ChainExpression </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;ChainExpression&quot;</span>
  <span class="s1">expression: MemberExpression | CallExpression</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">ImportExpression </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;ImportExpression&quot;</span>
  <span class="s1">source: Expression</span>
  <span class="s1">options: Expression | </span><span class="s0">null</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">ParenthesizedExpression </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;ParenthesizedExpression&quot;</span>
  <span class="s1">expression: Expression</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">PropertyDefinition </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;PropertyDefinition&quot;</span>
  <span class="s1">key: Expression | PrivateIdentifier</span>
  <span class="s1">value?: Expression | </span><span class="s0">null</span>
  <span class="s1">computed: boolean</span>
  <span class="s0">static</span><span class="s1">: boolean</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">PrivateIdentifier </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;PrivateIdentifier&quot;</span>
  <span class="s1">name: string</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">StaticBlock </span><span class="s0">extends </span><span class="s1">Node {</span>
  <span class="s1">type: </span><span class="s3">&quot;StaticBlock&quot;</span>
  <span class="s1">body: Array&lt;Statement&gt;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">type Statement = </span>
<span class="s1">| ExpressionStatement</span>
<span class="s1">| BlockStatement</span>
<span class="s1">| EmptyStatement</span>
<span class="s1">| DebuggerStatement</span>
<span class="s1">| WithStatement</span>
<span class="s1">| ReturnStatement</span>
<span class="s1">| LabeledStatement</span>
<span class="s1">| BreakStatement</span>
<span class="s1">| ContinueStatement</span>
<span class="s1">| IfStatement</span>
<span class="s1">| SwitchStatement</span>
<span class="s1">| ThrowStatement</span>
<span class="s1">| TryStatement</span>
<span class="s1">| WhileStatement</span>
<span class="s1">| DoWhileStatement</span>
<span class="s1">| ForStatement</span>
<span class="s1">| ForInStatement</span>
<span class="s1">| ForOfStatement</span>
<span class="s1">| Declaration</span>

<span class="s0">export </span><span class="s1">type Declaration = </span>
<span class="s1">| FunctionDeclaration</span>
<span class="s1">| VariableDeclaration</span>
<span class="s1">| ClassDeclaration</span>

<span class="s0">export </span><span class="s1">type Expression = </span>
<span class="s1">| Identifier</span>
<span class="s1">| Literal</span>
<span class="s1">| ThisExpression</span>
<span class="s1">| ArrayExpression</span>
<span class="s1">| ObjectExpression</span>
<span class="s1">| FunctionExpression</span>
<span class="s1">| UnaryExpression</span>
<span class="s1">| UpdateExpression</span>
<span class="s1">| BinaryExpression</span>
<span class="s1">| AssignmentExpression</span>
<span class="s1">| LogicalExpression</span>
<span class="s1">| MemberExpression</span>
<span class="s1">| ConditionalExpression</span>
<span class="s1">| CallExpression</span>
<span class="s1">| NewExpression</span>
<span class="s1">| SequenceExpression</span>
<span class="s1">| ArrowFunctionExpression</span>
<span class="s1">| YieldExpression</span>
<span class="s1">| TemplateLiteral</span>
<span class="s1">| TaggedTemplateExpression</span>
<span class="s1">| ClassExpression</span>
<span class="s1">| MetaProperty</span>
<span class="s1">| AwaitExpression</span>
<span class="s1">| ChainExpression</span>
<span class="s1">| ImportExpression</span>
<span class="s1">| ParenthesizedExpression</span>

<span class="s0">export </span><span class="s1">type Pattern = </span>
<span class="s1">| Identifier</span>
<span class="s1">| MemberExpression</span>
<span class="s1">| ObjectPattern</span>
<span class="s1">| ArrayPattern</span>
<span class="s1">| RestElement</span>
<span class="s1">| AssignmentPattern</span>

<span class="s0">export </span><span class="s1">type ModuleDeclaration = </span>
<span class="s1">| ImportDeclaration</span>
<span class="s1">| ExportNamedDeclaration</span>
<span class="s1">| ExportDefaultDeclaration</span>
<span class="s1">| ExportAllDeclaration</span>

<span class="s2">/**</span>
  <span class="s2">* This interface is only used for defining {</span><span class="s4">@link </span><span class="s2">AnyNode}.</span>
  <span class="s2">* It exists so that it can be extended by plugins:</span>
  <span class="s2">*</span>
  <span class="s2">* </span><span class="s4">@example</span>
  <span class="s2">* ```typescript</span>
  <span class="s2">* declare module 'acorn' {</span>
  <span class="s2">*   interface NodeTypes {</span>
  <span class="s2">*     pluginName: FirstNode | SecondNode | ThirdNode | ... | LastNode</span>
  <span class="s2">*   }</span>
  <span class="s2">* }</span>
  <span class="s2">* ```</span>
  <span class="s2">*/</span>
<span class="s0">interface </span><span class="s1">NodeTypes {</span>
  <span class="s1">core: Statement | Expression | Declaration | ModuleDeclaration | Literal | Program | SwitchCase | CatchClause | Property | Super | SpreadElement | TemplateElement | AssignmentProperty | ObjectPattern | ArrayPattern | RestElement | AssignmentPattern | ClassBody | MethodDefinition | MetaProperty | ImportAttribute | ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier | ExportSpecifier | AnonymousFunctionDeclaration | AnonymousClassDeclaration | PropertyDefinition | PrivateIdentifier | StaticBlock | VariableDeclarator</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">type AnyNode = NodeTypes[keyof NodeTypes]</span>

<span class="s0">export function </span><span class="s1">parse(input: string, options: Options): Program</span>

<span class="s0">export function </span><span class="s1">parseExpressionAt(input: string, pos: number, options: Options): Expression</span>

<span class="s0">export function </span><span class="s1">tokenizer(input: string, options: Options): {</span>
  <span class="s1">getToken(): Token</span>
  <span class="s1">[Symbol.iterator](): Iterator&lt;Token&gt;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">type ecmaVersion = </span><span class="s5">3 </span><span class="s1">| </span><span class="s5">5 </span><span class="s1">| </span><span class="s5">6 </span><span class="s1">| </span><span class="s5">7 </span><span class="s1">| </span><span class="s5">8 </span><span class="s1">| </span><span class="s5">9 </span><span class="s1">| </span><span class="s5">10 </span><span class="s1">| </span><span class="s5">11 </span><span class="s1">| </span><span class="s5">12 </span><span class="s1">| </span><span class="s5">13 </span><span class="s1">| </span><span class="s5">14 </span><span class="s1">| </span><span class="s5">15 </span><span class="s1">| </span><span class="s5">16 </span><span class="s1">| </span><span class="s5">17 </span><span class="s1">| </span><span class="s5">2015 </span><span class="s1">| </span><span class="s5">2016 </span><span class="s1">| </span><span class="s5">2017 </span><span class="s1">| </span><span class="s5">2018 </span><span class="s1">| </span><span class="s5">2019 </span><span class="s1">| </span><span class="s5">2020 </span><span class="s1">| </span><span class="s5">2021 </span><span class="s1">| </span><span class="s5">2022 </span><span class="s1">| </span><span class="s5">2023 </span><span class="s1">| </span><span class="s5">2024 </span><span class="s1">| </span><span class="s5">2025 </span><span class="s1">| </span><span class="s5">2026 </span><span class="s1">| </span><span class="s3">&quot;latest&quot;</span>

<span class="s0">export interface </span><span class="s1">Options {</span>
  <span class="s2">/**</span>
   <span class="s2">* `ecmaVersion` indicates the ECMAScript version to parse. Can be a</span>
   <span class="s2">* number, either in year (`2022`) or plain version number (`6`) form,</span>
   <span class="s2">* or `&quot;latest&quot;` (the latest the library supports). This influences</span>
   <span class="s2">* support for strict mode, the set of reserved words, and support for</span>
   <span class="s2">* new syntax features.</span>
   <span class="s2">*/</span>
  <span class="s1">ecmaVersion: ecmaVersion</span>

  <span class="s2">/**</span>
   <span class="s2">* `sourceType` indicates the mode the code should be parsed in.</span>
   <span class="s2">* Can be either `&quot;script&quot;` or `&quot;module&quot;`. This influences global</span>
   <span class="s2">* strict mode and parsing of `import` and `export` declarations.</span>
   <span class="s2">*/</span>
  <span class="s1">sourceType?: </span><span class="s3">&quot;script&quot; </span><span class="s1">| </span><span class="s3">&quot;module&quot;</span>

  <span class="s2">/**</span>
   <span class="s2">* a callback that will be called when a semicolon is automatically inserted.</span>
   <span class="s2">* </span><span class="s4">@param </span><span class="s2">lastTokEnd the position of the comma as an offset</span>
   <span class="s2">* </span><span class="s4">@param </span><span class="s2">lastTokEndLoc location if {</span><span class="s4">@link </span><span class="s2">locations} is enabled</span>
   <span class="s2">*/</span>
  <span class="s1">onInsertedSemicolon?: (lastTokEnd: number, lastTokEndLoc?: Position) =&gt; </span><span class="s0">void</span>

  <span class="s2">/**</span>
   <span class="s2">* similar to `onInsertedSemicolon`, but for trailing commas</span>
   <span class="s2">* </span><span class="s4">@param </span><span class="s2">lastTokEnd the position of the comma as an offset</span>
   <span class="s2">* </span><span class="s4">@param </span><span class="s2">lastTokEndLoc location if `locations` is enabled</span>
   <span class="s2">*/</span>
  <span class="s1">onTrailingComma?: (lastTokEnd: number, lastTokEndLoc?: Position) =&gt; </span><span class="s0">void</span>

  <span class="s2">/**</span>
   <span class="s2">* By default, reserved words are only enforced if ecmaVersion &gt;= 5.</span>
   <span class="s2">* Set `allowReserved` to a boolean value to explicitly turn this on</span>
   <span class="s2">* an off. When this option has the value &quot;never&quot;, reserved words</span>
   <span class="s2">* and keywords can also not be used as property names.</span>
   <span class="s2">*/</span>
  <span class="s1">allowReserved?: boolean | </span><span class="s3">&quot;never&quot;</span>

  <span class="s2">/** </span>
   <span class="s2">* When enabled, a return at the top level is not considered an error.</span>
   <span class="s2">*/</span>
  <span class="s1">allowReturnOutsideFunction?: boolean</span>

  <span class="s2">/**</span>
   <span class="s2">* When enabled, import/export statements are not constrained to</span>
   <span class="s2">* appearing at the top of the program, and an import.meta expression</span>
   <span class="s2">* in a script isn't considered an error.</span>
   <span class="s2">*/</span>
  <span class="s1">allowImportExportEverywhere?: boolean</span>

  <span class="s2">/**</span>
   <span class="s2">* By default, `await` identifiers are allowed to appear at the top-level scope only if {</span><span class="s4">@link </span><span class="s2">ecmaVersion} &gt;= 2022.</span>
   <span class="s2">* When enabled, await identifiers are allowed to appear at the top-level scope,</span>
   <span class="s2">* but they are still not allowed in non-async functions.</span>
   <span class="s2">*/</span>
  <span class="s1">allowAwaitOutsideFunction?: boolean</span>

  <span class="s2">/**</span>
   <span class="s2">* When enabled, super identifiers are not constrained to</span>
   <span class="s2">* appearing in methods and do not raise an error when they appear elsewhere.</span>
   <span class="s2">*/</span>
  <span class="s1">allowSuperOutsideMethod?: boolean</span>

  <span class="s2">/**</span>
   <span class="s2">* When enabled, hashbang directive in the beginning of file is</span>
   <span class="s2">* allowed and treated as a line comment. Enabled by default when</span>
   <span class="s2">* {</span><span class="s4">@link </span><span class="s2">ecmaVersion} &gt;= 2023.</span>
   <span class="s2">*/</span>
  <span class="s1">allowHashBang?: boolean</span>

  <span class="s2">/**</span>
   <span class="s2">* By default, the parser will verify that private properties are</span>
   <span class="s2">* only used in places where they are valid and have been declared.</span>
   <span class="s2">* Set this to false to turn such checks off.</span>
   <span class="s2">*/</span>
  <span class="s1">checkPrivateFields?: boolean</span>

  <span class="s2">/**</span>
   <span class="s2">* When `locations` is on, `loc` properties holding objects with</span>
   <span class="s2">* `start` and `end` properties as {</span><span class="s4">@link </span><span class="s2">Position} objects will be attached to the</span>
   <span class="s2">* nodes.</span>
   <span class="s2">*/</span>
  <span class="s1">locations?: boolean</span>

  <span class="s2">/**</span>
   <span class="s2">* a callback that will cause Acorn to call that export function with object in the same</span>
   <span class="s2">* format as tokens returned from `tokenizer().getToken()`. Note</span>
   <span class="s2">* that you are not allowed to call the parser from the</span>
   <span class="s2">* callback—that will corrupt its internal state.</span>
   <span class="s2">*/</span>
  <span class="s1">onToken?: ((token: Token) =&gt; </span><span class="s0">void</span><span class="s1">) | Token[]</span>


  <span class="s2">/**</span>
   <span class="s2">* This takes a export function or an array.</span>
   <span class="s2">* </span>
   <span class="s2">* When a export function is passed, Acorn will call that export function with `(block, text, start,</span>
   <span class="s2">* end)` parameters whenever a comment is skipped. `block` is a</span>
   <span class="s2">* boolean indicating whether this is a block (`/* *\/`) comment,</span>
   <span class="s2">* `text` is the content of the comment, and `start` and `end` are</span>
   <span class="s2">* character offsets that denote the start and end of the comment.</span>
   <span class="s2">* When the {</span><span class="s4">@link </span><span class="s2">locations} option is on, two more parameters are</span>
   <span class="s2">* passed, the full locations of {</span><span class="s4">@link </span><span class="s2">Position} export type of the start and</span>
   <span class="s2">* end of the comments.</span>
   <span class="s2">* </span>
   <span class="s2">* When a array is passed, each found comment of {</span><span class="s4">@link </span><span class="s2">Comment} export type is pushed to the array.</span>
   <span class="s2">* </span>
   <span class="s2">* Note that you are not allowed to call the</span>
   <span class="s2">* parser from the callback—that will corrupt its internal state.</span>
   <span class="s2">*/</span>
  <span class="s1">onComment?: ((</span>
    <span class="s1">isBlock: boolean, text: string, start: number, end: number, startLoc?: Position,</span>
    <span class="s1">endLoc?: Position</span>
  <span class="s1">) =&gt; </span><span class="s0">void</span><span class="s1">) | Comment[]</span>

  <span class="s2">/**</span>
   <span class="s2">* Nodes have their start and end characters offsets recorded in</span>
   <span class="s2">* `start` and `end` properties (directly on the node, rather than</span>
   <span class="s2">* the `loc` object, which holds line/column data. To also add a</span>
   <span class="s2">* [semi-standardized][range] `range` property holding a `[start,</span>
   <span class="s2">* end]` array with the same numbers, set the `ranges` option to</span>
   <span class="s2">* `true`.</span>
   <span class="s2">*/</span>
  <span class="s1">ranges?: boolean</span>

  <span class="s2">/**</span>
   <span class="s2">* It is possible to parse multiple files into a single AST by</span>
   <span class="s2">* passing the tree produced by parsing the first file as</span>
   <span class="s2">* `program` option in subsequent parses. This will add the</span>
   <span class="s2">* toplevel forms of the parsed file to the `Program` (top) node</span>
   <span class="s2">* of an existing parse tree.</span>
   <span class="s2">*/</span>
  <span class="s1">program?: Node</span>

  <span class="s2">/**</span>
   <span class="s2">* When {</span><span class="s4">@link </span><span class="s2">locations} is on, you can pass this to record the source</span>
   <span class="s2">* file in every node's `loc` object.</span>
   <span class="s2">*/</span>
  <span class="s1">sourceFile?: string</span>

  <span class="s2">/**</span>
   <span class="s2">* This value, if given, is stored in every node, whether {</span><span class="s4">@link </span><span class="s2">locations} is on or off.</span>
   <span class="s2">*/</span>
  <span class="s1">directSourceFile?: string</span>

  <span class="s2">/**</span>
   <span class="s2">* When enabled, parenthesized expressions are represented by</span>
   <span class="s2">* (non-standard) ParenthesizedExpression nodes</span>
   <span class="s2">*/</span>
  <span class="s1">preserveParens?: boolean</span>
<span class="s1">}</span>
  
<span class="s0">export class </span><span class="s1">Parser {</span>
  <span class="s1">options: Options</span>
  <span class="s1">input: string</span>
  
  <span class="s0">protected </span><span class="s1">constructor(options: Options, input: string, startPos?: number)</span>
  <span class="s1">parse(): Program</span>
  
  <span class="s0">static </span><span class="s1">parse(input: string, options: Options): Program</span>
  <span class="s0">static </span><span class="s1">parseExpressionAt(input: string, pos: number, options: Options): Expression</span>
  <span class="s0">static </span><span class="s1">tokenizer(input: string, options: Options): {</span>
    <span class="s1">getToken(): Token</span>
    <span class="s1">[Symbol.iterator](): Iterator&lt;Token&gt;</span>
  <span class="s1">}</span>
  <span class="s0">static </span><span class="s1">extend(...plugins: ((BaseParser: </span><span class="s0">typeof </span><span class="s1">Parser) =&gt; </span><span class="s0">typeof </span><span class="s1">Parser)[]): </span><span class="s0">typeof </span><span class="s1">Parser</span>
<span class="s1">}</span>

<span class="s0">export const </span><span class="s1">defaultOptions: Options</span>

<span class="s0">export function </span><span class="s1">getLineInfo(input: string, offset: number): Position</span>

<span class="s0">export class </span><span class="s1">TokenType {</span>
  <span class="s1">label: string</span>
  <span class="s1">keyword: string | undefined</span>
<span class="s1">}</span>

<span class="s0">export const </span><span class="s1">tokTypes: {</span>
  <span class="s1">num: TokenType</span>
  <span class="s1">regexp: TokenType</span>
  <span class="s1">string: TokenType</span>
  <span class="s1">name: TokenType</span>
  <span class="s1">privateId: TokenType</span>
  <span class="s1">eof: TokenType</span>

  <span class="s1">bracketL: TokenType</span>
  <span class="s1">bracketR: TokenType</span>
  <span class="s1">braceL: TokenType</span>
  <span class="s1">braceR: TokenType</span>
  <span class="s1">parenL: TokenType</span>
  <span class="s1">parenR: TokenType</span>
  <span class="s1">comma: TokenType</span>
  <span class="s1">semi: TokenType</span>
  <span class="s1">colon: TokenType</span>
  <span class="s1">dot: TokenType</span>
  <span class="s1">question: TokenType</span>
  <span class="s1">questionDot: TokenType</span>
  <span class="s1">arrow: TokenType</span>
  <span class="s1">template: TokenType</span>
  <span class="s1">invalidTemplate: TokenType</span>
  <span class="s1">ellipsis: TokenType</span>
  <span class="s1">backQuote: TokenType</span>
  <span class="s1">dollarBraceL: TokenType</span>

  <span class="s1">eq: TokenType</span>
  <span class="s1">assign: TokenType</span>
  <span class="s1">incDec: TokenType</span>
  <span class="s1">prefix: TokenType</span>
  <span class="s1">logicalOR: TokenType</span>
  <span class="s1">logicalAND: TokenType</span>
  <span class="s1">bitwiseOR: TokenType</span>
  <span class="s1">bitwiseXOR: TokenType</span>
  <span class="s1">bitwiseAND: TokenType</span>
  <span class="s1">equality: TokenType</span>
  <span class="s1">relational: TokenType</span>
  <span class="s1">bitShift: TokenType</span>
  <span class="s1">plusMin: TokenType</span>
  <span class="s1">modulo: TokenType</span>
  <span class="s1">star: TokenType</span>
  <span class="s1">slash: TokenType</span>
  <span class="s1">starstar: TokenType</span>
  <span class="s1">coalesce: TokenType</span>

  <span class="s1">_break: TokenType</span>
  <span class="s1">_case: TokenType</span>
  <span class="s1">_catch: TokenType</span>
  <span class="s1">_continue: TokenType</span>
  <span class="s1">_debugger: TokenType</span>
  <span class="s1">_default: TokenType</span>
  <span class="s1">_do: TokenType</span>
  <span class="s1">_else: TokenType</span>
  <span class="s1">_finally: TokenType</span>
  <span class="s1">_for: TokenType</span>
  <span class="s1">_function: TokenType</span>
  <span class="s1">_if: TokenType</span>
  <span class="s1">_return: TokenType</span>
  <span class="s1">_switch: TokenType</span>
  <span class="s1">_throw: TokenType</span>
  <span class="s1">_try: TokenType</span>
  <span class="s1">_var: TokenType</span>
  <span class="s1">_const: TokenType</span>
  <span class="s1">_while: TokenType</span>
  <span class="s1">_with: TokenType</span>
  <span class="s1">_new: TokenType</span>
  <span class="s1">_this: TokenType</span>
  <span class="s1">_super: TokenType</span>
  <span class="s1">_class: TokenType</span>
  <span class="s1">_extends: TokenType</span>
  <span class="s1">_export: TokenType</span>
  <span class="s1">_import: TokenType</span>
  <span class="s1">_null: TokenType</span>
  <span class="s1">_true: TokenType</span>
  <span class="s1">_false: TokenType</span>
  <span class="s1">_in: TokenType</span>
  <span class="s1">_instanceof: TokenType</span>
  <span class="s1">_typeof: TokenType</span>
  <span class="s1">_void: TokenType</span>
  <span class="s1">_delete: TokenType</span>
<span class="s1">}</span>

<span class="s0">export interface </span><span class="s1">Comment {</span>
  <span class="s1">type: </span><span class="s3">&quot;Line&quot; </span><span class="s1">| </span><span class="s3">&quot;Block&quot;</span>
  <span class="s1">value: string</span>
  <span class="s1">start: number</span>
  <span class="s1">end: number</span>
  <span class="s1">loc?: SourceLocation</span>
  <span class="s1">range?: [number, number]</span>
<span class="s1">}</span>

<span class="s0">export class </span><span class="s1">Token {</span>
  <span class="s1">type: TokenType</span>
  <span class="s1">start: number</span>
  <span class="s1">end: number</span>
  <span class="s1">loc?: SourceLocation</span>
  <span class="s1">range?: [number, number]</span>
<span class="s1">}</span>

<span class="s0">export const </span><span class="s1">version: string</span>
</pre>
</body>
</html>