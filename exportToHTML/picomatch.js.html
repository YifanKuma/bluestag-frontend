<html>
<head>
<title>picomatch.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #1750eb;}
.s6 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
picomatch.js</font>
</center></td></tr></table>
<pre><span class="s0">'use strict'</span><span class="s1">;</span>

<span class="s2">const </span><span class="s1">scan = require(</span><span class="s0">'./scan'</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">parse = require(</span><span class="s0">'./parse'</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">utils = require(</span><span class="s0">'./utils'</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">constants = require(</span><span class="s0">'./constants'</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">isObject = val =&gt; val &amp;&amp; </span><span class="s2">typeof </span><span class="s1">val === </span><span class="s0">'object' </span><span class="s1">&amp;&amp; !Array.isArray(val);</span>

<span class="s3">/**</span>
 <span class="s3">* Creates a matcher function from one or more glob patterns. The</span>
 <span class="s3">* returned function takes a string to match as its first argument,</span>
 <span class="s3">* and returns true if the string is a match. The returned matcher</span>
 <span class="s3">* function also takes a boolean as the second argument that, when true,</span>
 <span class="s3">* returns an object with additional information.</span>
 <span class="s3">*</span>
 <span class="s3">* ```js</span>
 <span class="s3">* const picomatch = require('picomatch');</span>
 <span class="s3">* // picomatch(glob[, options]);</span>
 <span class="s3">*</span>
 <span class="s3">* const isMatch = picomatch('*.!(*a)');</span>
 <span class="s3">* console.log(isMatch('a.a')); //=&gt; false</span>
 <span class="s3">* console.log(isMatch('a.b')); //=&gt; true</span>
 <span class="s3">* ```</span>
 <span class="s3">* </span><span class="s4">@name </span><span class="s3">picomatch</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{String|Array} `globs` One or more glob patterns.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object=} `options`</span>
 <span class="s3">* </span><span class="s4">@return </span><span class="s3">{Function=} Returns a matcher function.</span>
 <span class="s3">* </span><span class="s4">@api </span><span class="s3">public</span>
 <span class="s3">*/</span>

<span class="s2">const </span><span class="s1">picomatch = (glob, options, returnState = </span><span class="s2">false</span><span class="s1">) =&gt; {</span>
  <span class="s2">if </span><span class="s1">(Array.isArray(glob)) {</span>
    <span class="s2">const </span><span class="s1">fns = glob.map(input =&gt; picomatch(input, options, returnState));</span>
    <span class="s2">const </span><span class="s1">arrayMatcher = str =&gt; {</span>
      <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">isMatch of fns) {</span>
        <span class="s2">const </span><span class="s1">state = isMatch(str);</span>
        <span class="s2">if </span><span class="s1">(state) </span><span class="s2">return </span><span class="s1">state;</span>
      <span class="s1">}</span>
      <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s2">return </span><span class="s1">arrayMatcher;</span>
  <span class="s1">}</span>

  <span class="s2">const </span><span class="s1">isState = isObject(glob) &amp;&amp; glob.tokens &amp;&amp; glob.input;</span>

  <span class="s2">if </span><span class="s1">(glob === </span><span class="s0">'' </span><span class="s1">|| (</span><span class="s2">typeof </span><span class="s1">glob !== </span><span class="s0">'string' </span><span class="s1">&amp;&amp; !isState)) {</span>
    <span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">'Expected pattern to be a non-empty string'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s2">const </span><span class="s1">opts = options || {};</span>
  <span class="s2">const </span><span class="s1">posix = opts.windows;</span>
  <span class="s2">const </span><span class="s1">regex = isState</span>
    <span class="s1">? picomatch.compileRe(glob, options)</span>
    <span class="s1">: picomatch.makeRe(glob, options, </span><span class="s2">false</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>

  <span class="s2">const </span><span class="s1">state = regex.state;</span>
  <span class="s2">delete </span><span class="s1">regex.state;</span>

  <span class="s2">let </span><span class="s1">isIgnored = () =&gt; </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">if </span><span class="s1">(opts.ignore) {</span>
    <span class="s2">const </span><span class="s1">ignoreOpts = { ...options, ignore: </span><span class="s2">null</span><span class="s1">, onMatch: </span><span class="s2">null</span><span class="s1">, onResult: </span><span class="s2">null </span><span class="s1">};</span>
    <span class="s1">isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);</span>
  <span class="s1">}</span>

  <span class="s2">const </span><span class="s1">matcher = (input, returnObject = </span><span class="s2">false</span><span class="s1">) =&gt; {</span>
    <span class="s2">const </span><span class="s1">{ isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });</span>
    <span class="s2">const </span><span class="s1">result = { glob, state, regex, posix, input, output, match, isMatch };</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">opts.onResult === </span><span class="s0">'function'</span><span class="s1">) {</span>
      <span class="s1">opts.onResult(result);</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(isMatch === </span><span class="s2">false</span><span class="s1">) {</span>
      <span class="s1">result.isMatch = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s2">return </span><span class="s1">returnObject ? result : </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(isIgnored(input)) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">opts.onIgnore === </span><span class="s0">'function'</span><span class="s1">) {</span>
        <span class="s1">opts.onIgnore(result);</span>
      <span class="s1">}</span>
      <span class="s1">result.isMatch = </span><span class="s2">false</span><span class="s1">;</span>
      <span class="s2">return </span><span class="s1">returnObject ? result : </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">opts.onMatch === </span><span class="s0">'function'</span><span class="s1">) {</span>
      <span class="s1">opts.onMatch(result);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">returnObject ? result : </span><span class="s2">true</span><span class="s1">;</span>
  <span class="s1">};</span>

  <span class="s2">if </span><span class="s1">(returnState) {</span>
    <span class="s1">matcher.state = state;</span>
  <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">matcher;</span>
<span class="s1">};</span>

<span class="s3">/**</span>
 <span class="s3">* Test `input` with the given `regex`. This is used by the main</span>
 <span class="s3">* `picomatch()` function to test the input string.</span>
 <span class="s3">*</span>
 <span class="s3">* ```js</span>
 <span class="s3">* const picomatch = require('picomatch');</span>
 <span class="s3">* // picomatch.test(input, regex[, options]);</span>
 <span class="s3">*</span>
 <span class="s3">* console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));</span>
 <span class="s3">* // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }</span>
 <span class="s3">* ```</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{String} `input` String to test.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{RegExp} `regex`</span>
 <span class="s3">* </span><span class="s4">@return </span><span class="s3">{Object} Returns an object with matching info.</span>
 <span class="s3">* </span><span class="s4">@api </span><span class="s3">public</span>
 <span class="s3">*/</span>

<span class="s1">picomatch.test = (input, regex, options, { glob, posix } = {}) =&gt; {</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">input !== </span><span class="s0">'string'</span><span class="s1">) {</span>
    <span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">'Expected input to be a string'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(input === </span><span class="s0">''</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s1">{ isMatch: </span><span class="s2">false</span><span class="s1">, output: </span><span class="s0">'' </span><span class="s1">};</span>
  <span class="s1">}</span>

  <span class="s2">const </span><span class="s1">opts = options || {};</span>
  <span class="s2">const </span><span class="s1">format = opts.format || (posix ? utils.toPosixSlashes : </span><span class="s2">null</span><span class="s1">);</span>
  <span class="s2">let </span><span class="s1">match = input === glob;</span>
  <span class="s2">let </span><span class="s1">output = (match &amp;&amp; format) ? format(input) : input;</span>

  <span class="s2">if </span><span class="s1">(match === </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s1">output = format ? format(input) : input;</span>
    <span class="s1">match = output === glob;</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(match === </span><span class="s2">false </span><span class="s1">|| opts.capture === </span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(opts.matchBase === </span><span class="s2">true </span><span class="s1">|| opts.basename === </span><span class="s2">true</span><span class="s1">) {</span>
      <span class="s1">match = picomatch.matchBase(input, regex, options, posix);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">match = regex.exec(output);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">{ isMatch: Boolean(match), match, output };</span>
<span class="s1">};</span>

<span class="s3">/**</span>
 <span class="s3">* Match the basename of a filepath.</span>
 <span class="s3">*</span>
 <span class="s3">* ```js</span>
 <span class="s3">* const picomatch = require('picomatch');</span>
 <span class="s3">* // picomatch.matchBase(input, glob[, options]);</span>
 <span class="s3">* console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true</span>
 <span class="s3">* ```</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{String} `input` String to test.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).</span>
 <span class="s3">* </span><span class="s4">@return </span><span class="s3">{Boolean}</span>
 <span class="s3">* </span><span class="s4">@api </span><span class="s3">public</span>
 <span class="s3">*/</span>

<span class="s1">picomatch.matchBase = (input, glob, options) =&gt; {</span>
  <span class="s2">const </span><span class="s1">regex = glob </span><span class="s2">instanceof </span><span class="s1">RegExp ? glob : picomatch.makeRe(glob, options);</span>
  <span class="s2">return </span><span class="s1">regex.test(utils.basename(input));</span>
<span class="s1">};</span>

<span class="s3">/**</span>
 <span class="s3">* Returns true if **any** of the given glob `patterns` match the specified `string`.</span>
 <span class="s3">*</span>
 <span class="s3">* ```js</span>
 <span class="s3">* const picomatch = require('picomatch');</span>
 <span class="s3">* // picomatch.isMatch(string, patterns[, options]);</span>
 <span class="s3">*</span>
 <span class="s3">* console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=&gt; true</span>
 <span class="s3">* console.log(picomatch.isMatch('a.a', 'b.*')); //=&gt; false</span>
 <span class="s3">* ```</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{String|Array} str The string to test.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{String|Array} patterns One or more glob patterns to use for matching.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} [options] See available [options](#options).</span>
 <span class="s3">* </span><span class="s4">@return </span><span class="s3">{Boolean} Returns true if any patterns match `str`</span>
 <span class="s3">* </span><span class="s4">@api </span><span class="s3">public</span>
 <span class="s3">*/</span>

<span class="s1">picomatch.isMatch = (str, patterns, options) =&gt; picomatch(patterns, options)(str);</span>

<span class="s3">/**</span>
 <span class="s3">* Parse a glob pattern to create the source string for a regular</span>
 <span class="s3">* expression.</span>
 <span class="s3">*</span>
 <span class="s3">* ```js</span>
 <span class="s3">* const picomatch = require('picomatch');</span>
 <span class="s3">* const result = picomatch.parse(pattern[, options]);</span>
 <span class="s3">* ```</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{String} `pattern`</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} `options`</span>
 <span class="s3">* </span><span class="s4">@return </span><span class="s3">{Object} Returns an object with useful properties and output to be used as a regex source string.</span>
 <span class="s3">* </span><span class="s4">@api </span><span class="s3">public</span>
 <span class="s3">*/</span>

<span class="s1">picomatch.parse = (pattern, options) =&gt; {</span>
  <span class="s2">if </span><span class="s1">(Array.isArray(pattern)) </span><span class="s2">return </span><span class="s1">pattern.map(p =&gt; picomatch.parse(p, options));</span>
  <span class="s2">return </span><span class="s1">parse(pattern, { ...options, fastpaths: </span><span class="s2">false </span><span class="s1">});</span>
<span class="s1">};</span>

<span class="s3">/**</span>
 <span class="s3">* Scan a glob pattern to separate the pattern into segments.</span>
 <span class="s3">*</span>
 <span class="s3">* ```js</span>
 <span class="s3">* const picomatch = require('picomatch');</span>
 <span class="s3">* // picomatch.scan(input[, options]);</span>
 <span class="s3">*</span>
 <span class="s3">* const result = picomatch.scan('!./foo/*.js');</span>
 <span class="s3">* console.log(result);</span>
 <span class="s3">* { prefix: '!./',</span>
 <span class="s3">*   input: '!./foo/*.js',</span>
 <span class="s3">*   start: 3,</span>
 <span class="s3">*   base: 'foo',</span>
 <span class="s3">*   glob: '*.js',</span>
 <span class="s3">*   isBrace: false,</span>
 <span class="s3">*   isBracket: false,</span>
 <span class="s3">*   isGlob: true,</span>
 <span class="s3">*   isExtglob: false,</span>
 <span class="s3">*   isGlobstar: false,</span>
 <span class="s3">*   negated: true }</span>
 <span class="s3">* ```</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{String} `input` Glob pattern to scan.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} `options`</span>
 <span class="s3">* </span><span class="s4">@return </span><span class="s3">{Object} Returns an object with</span>
 <span class="s3">* </span><span class="s4">@api </span><span class="s3">public</span>
 <span class="s3">*/</span>

<span class="s1">picomatch.scan = (input, options) =&gt; scan(input, options);</span>

<span class="s3">/**</span>
 <span class="s3">* Compile a regular expression from the `state` object returned by the</span>
 <span class="s3">* [parse()](#parse) method.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} `state`</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} `options`</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Boolean} `returnOutput` Intended for implementors, this argument allows you to return the raw output from the parser.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Boolean} `returnState` Adds the state to a `state` property on the returned regex. Useful for implementors and debugging.</span>
 <span class="s3">* </span><span class="s4">@return </span><span class="s3">{RegExp}</span>
 <span class="s3">* </span><span class="s4">@api </span><span class="s3">public</span>
 <span class="s3">*/</span>

<span class="s1">picomatch.compileRe = (state, options, returnOutput = </span><span class="s2">false</span><span class="s1">, returnState = </span><span class="s2">false</span><span class="s1">) =&gt; {</span>
  <span class="s2">if </span><span class="s1">(returnOutput === </span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s1">state.output;</span>
  <span class="s1">}</span>

  <span class="s2">const </span><span class="s1">opts = options || {};</span>
  <span class="s2">const </span><span class="s1">prepend = opts.contains ? </span><span class="s0">'' </span><span class="s1">: </span><span class="s0">'^'</span><span class="s1">;</span>
  <span class="s2">const </span><span class="s1">append = opts.contains ? </span><span class="s0">'' </span><span class="s1">: </span><span class="s0">'$'</span><span class="s1">;</span>

  <span class="s2">let </span><span class="s1">source = </span><span class="s0">`</span><span class="s1">${prepend}</span><span class="s0">(?:</span><span class="s1">${state.output}</span><span class="s0">)</span><span class="s1">${append}</span><span class="s0">`</span><span class="s1">;</span>
  <span class="s2">if </span><span class="s1">(state &amp;&amp; state.negated === </span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">source = </span><span class="s0">`^(?!</span><span class="s1">${source}</span><span class="s0">).*$`</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s2">const </span><span class="s1">regex = picomatch.toRegex(source, options);</span>
  <span class="s2">if </span><span class="s1">(returnState === </span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s1">regex.state = state;</span>
  <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">regex;</span>
<span class="s1">};</span>

<span class="s3">/**</span>
 <span class="s3">* Create a regular expression from a parsed glob pattern.</span>
 <span class="s3">*</span>
 <span class="s3">* ```js</span>
 <span class="s3">* const picomatch = require('picomatch');</span>
 <span class="s3">* const state = picomatch.parse('*.js');</span>
 <span class="s3">* // picomatch.compileRe(state[, options]);</span>
 <span class="s3">*</span>
 <span class="s3">* console.log(picomatch.compileRe(state));</span>
 <span class="s3">* //=&gt; /^(?:(?!\.)(?=.)[^/]*?\.js)$/</span>
 <span class="s3">* ```</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{String} `state` The object returned from the `.parse` method.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} `options`</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Boolean} `returnOutput` Implementors may use this argument to return the compiled output, instead of a regular expression. This is not exposed on the options to prevent end-users from mutating the result.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Boolean} `returnState` Implementors may use this argument to return the state from the parsed glob with the returned regular expression.</span>
 <span class="s3">* </span><span class="s4">@return </span><span class="s3">{RegExp} Returns a regex created from the given pattern.</span>
 <span class="s3">* </span><span class="s4">@api </span><span class="s3">public</span>
 <span class="s3">*/</span>

<span class="s1">picomatch.makeRe = (input, options = {}, returnOutput = </span><span class="s2">false</span><span class="s1">, returnState = </span><span class="s2">false</span><span class="s1">) =&gt; {</span>
  <span class="s2">if </span><span class="s1">(!input || </span><span class="s2">typeof </span><span class="s1">input !== </span><span class="s0">'string'</span><span class="s1">) {</span>
    <span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">'Expected a non-empty string'</span><span class="s1">);</span>
  <span class="s1">}</span>

  <span class="s2">let </span><span class="s1">parsed = { negated: </span><span class="s2">false</span><span class="s1">, fastpaths: </span><span class="s2">true </span><span class="s1">};</span>

  <span class="s2">if </span><span class="s1">(options.fastpaths !== </span><span class="s2">false </span><span class="s1">&amp;&amp; (input[</span><span class="s5">0</span><span class="s1">] === </span><span class="s0">'.' </span><span class="s1">|| input[</span><span class="s5">0</span><span class="s1">] === </span><span class="s0">'*'</span><span class="s1">)) {</span>
    <span class="s1">parsed.output = parse.fastpaths(input, options);</span>
  <span class="s1">}</span>

  <span class="s2">if </span><span class="s1">(!parsed.output) {</span>
    <span class="s1">parsed = parse(input, options);</span>
  <span class="s1">}</span>

  <span class="s2">return </span><span class="s1">picomatch.compileRe(parsed, options, returnOutput, returnState);</span>
<span class="s1">};</span>

<span class="s3">/**</span>
 <span class="s3">* Create a regular expression from the given regex source string.</span>
 <span class="s3">*</span>
 <span class="s3">* ```js</span>
 <span class="s3">* const picomatch = require('picomatch');</span>
 <span class="s3">* // picomatch.toRegex(source[, options]);</span>
 <span class="s3">*</span>
 <span class="s3">* const { output } = picomatch.parse('*.js');</span>
 <span class="s3">* console.log(picomatch.toRegex(output));</span>
 <span class="s3">* //=&gt; /^(?:(?!\.)(?=.)[^/]*?\.js)$/</span>
 <span class="s3">* ```</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{String} `source` Regular expression source string.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} `options`</span>
 <span class="s3">* </span><span class="s4">@return </span><span class="s3">{RegExp}</span>
 <span class="s3">* </span><span class="s4">@api </span><span class="s3">public</span>
 <span class="s3">*/</span>

<span class="s1">picomatch.toRegex = (source, options) =&gt; {</span>
  <span class="s2">try </span><span class="s1">{</span>
    <span class="s2">const </span><span class="s1">opts = options || {};</span>
    <span class="s2">return new </span><span class="s1">RegExp(source, opts.flags || (opts.nocase ? </span><span class="s0">'i' </span><span class="s1">: </span><span class="s0">''</span><span class="s1">));</span>
  <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
    <span class="s2">if </span><span class="s1">(options &amp;&amp; options.debug === </span><span class="s2">true</span><span class="s1">) </span><span class="s2">throw </span><span class="s1">err;</span>
    <span class="s2">return </span><span class="s6">/$^/</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">};</span>

<span class="s3">/**</span>
 <span class="s3">* Picomatch constants.</span>
 <span class="s3">* </span><span class="s4">@return </span><span class="s3">{Object}</span>
 <span class="s3">*/</span>

<span class="s1">picomatch.constants = constants;</span>

<span class="s3">/**</span>
 <span class="s3">* Expose &quot;picomatch&quot;</span>
 <span class="s3">*/</span>

<span class="s1">module.exports = picomatch;</span>
</pre>
</body>
</html>