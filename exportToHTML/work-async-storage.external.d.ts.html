<html>
<head>
<title>work-async-storage.external.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
work-async-storage.external.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">type { AsyncLocalStorage } from </span><span class="s2">'async_hooks'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { IncrementalCache } from </span><span class="s2">'../lib/incremental-cache'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { FetchMetrics } from </span><span class="s2">'../base-http'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { DeepReadonly } from </span><span class="s2">'../../shared/lib/deep-readonly'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { AppSegmentConfig } from </span><span class="s2">'../../build/segment-config/app/app-segment-config'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { AfterContext } from </span><span class="s2">'../after/after-context'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { CacheLife } from </span><span class="s2">'../use-cache/cache-life'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ workAsyncStorageInstance } from </span><span class="s2">'./work-async-storage-instance'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { LazyResult } from </span><span class="s2">'../lib/lazy-result'</span><span class="s1">;</span>
<span class="s0">export interface </span><span class="s1">WorkStore {</span>
    <span class="s1">readonly isStaticGeneration: boolean;</span>
    <span class="s3">/**</span>
     <span class="s3">* The page that is being rendered. This relates to the path to the page file.</span>
     <span class="s3">*/</span>
    <span class="s1">readonly page: string;</span>
    <span class="s3">/**</span>
     <span class="s3">* The route that is being rendered. This is the page property without the</span>
     <span class="s3">* trailing `/page` or `/route` suffix.</span>
     <span class="s3">*/</span>
    <span class="s1">readonly route: string;</span>
    <span class="s1">readonly incrementalCache?: IncrementalCache;</span>
    <span class="s1">readonly cacheLifeProfiles?: {</span>
        <span class="s1">[profile: string]: CacheLife;</span>
    <span class="s1">};</span>
    <span class="s1">readonly isOnDemandRevalidate?: boolean;</span>
    <span class="s1">readonly isBuildTimePrerendering?: boolean;</span>
    <span class="s3">/**</span>
     <span class="s3">* This is true when:</span>
     <span class="s3">* - source maps are generated</span>
     <span class="s3">* - source maps are applied</span>
     <span class="s3">* - minification is disabled</span>
     <span class="s3">*/</span>
    <span class="s1">readonly hasReadableErrorStacks?: boolean;</span>
    <span class="s1">readonly isRevalidate?: boolean;</span>
    <span class="s1">forceDynamic?: boolean;</span>
    <span class="s1">fetchCache?: AppSegmentConfig[</span><span class="s2">'fetchCache'</span><span class="s1">];</span>
    <span class="s1">forceStatic?: boolean;</span>
    <span class="s1">dynamicShouldError?: boolean;</span>
    <span class="s1">pendingRevalidates?: Record&lt;string, Promise&lt;any&gt;&gt;;</span>
    <span class="s1">pendingRevalidateWrites?: Array&lt;Promise&lt;</span><span class="s0">void</span><span class="s1">&gt;&gt;;</span>
    <span class="s1">readonly afterContext: AfterContext;</span>
    <span class="s1">dynamicUsageDescription?: string;</span>
    <span class="s1">dynamicUsageStack?: string;</span>
    <span class="s3">/**</span>
     <span class="s3">* Invalid dynamic usage errors might be caught in userland. We attach them to</span>
     <span class="s3">* the work store to ensure we can still fail the build, or show en error in</span>
     <span class="s3">* dev mode.</span>
     <span class="s3">*/</span>
    <span class="s1">invalidDynamicUsageError?: Error;</span>
    <span class="s1">nextFetchId?: number;</span>
    <span class="s1">pathWasRevalidated?: boolean;</span>
    <span class="s3">/**</span>
     <span class="s3">* Tags that were revalidated during the current request. They need to be sent</span>
     <span class="s3">* to cache handlers to propagate their revalidation.</span>
     <span class="s3">*/</span>
    <span class="s1">pendingRevalidatedTags?: string[];</span>
    <span class="s3">/**</span>
     <span class="s3">* Tags that were previously revalidated (e.g. by a redirecting server action)</span>
     <span class="s3">* and have already been sent to cache handlers. Retrieved cache entries that</span>
     <span class="s3">* include any of these tags must be discarded.</span>
     <span class="s3">*/</span>
    <span class="s1">readonly previouslyRevalidatedTags: readonly string[];</span>
    <span class="s3">/**</span>
     <span class="s3">* This map contains lazy results so that we can evaluate them when the first</span>
     <span class="s3">* cache entry is read. It allows us to skip refreshing tags if no caches are</span>
     <span class="s3">* read at all.</span>
     <span class="s3">*/</span>
    <span class="s1">readonly refreshTagsByCacheKind: Map&lt;string, LazyResult&lt;</span><span class="s0">void</span><span class="s1">&gt;&gt;;</span>
    <span class="s1">fetchMetrics?: FetchMetrics;</span>
    <span class="s1">shouldTrackFetchMetrics: boolean;</span>
    <span class="s1">isDraftMode?: boolean;</span>
    <span class="s1">isUnstableNoStore?: boolean;</span>
    <span class="s1">isPrefetchRequest?: boolean;</span>
    <span class="s1">buildId: string;</span>
    <span class="s1">readonly reactLoadableManifest?: DeepReadonly&lt;Record&lt;string, {</span>
        <span class="s1">files: string[];</span>
    <span class="s1">}&gt;&gt;;</span>
    <span class="s1">readonly assetPrefix?: string;</span>
    <span class="s1">cacheComponentsEnabled: boolean;</span>
    <span class="s1">dev: boolean;</span>
    <span class="s3">/**</span>
     <span class="s3">* Run the given function inside a clean AsyncLocalStorage snapshot. This is</span>
     <span class="s3">* useful when generating cache entries, to ensure that the cache generation</span>
     <span class="s3">* cannot read anything from the context we're currently executing in, which</span>
     <span class="s3">* might include request-specific things like `cookies()` inside a</span>
     <span class="s3">* `React.cache()`.</span>
     <span class="s3">*/</span>
    <span class="s1">runInCleanSnapshot: &lt;R, TArgs </span><span class="s0">extends </span><span class="s1">any[]&gt;(fn: (...args: TArgs) =&gt; R, ...args: TArgs) =&gt; R;</span>
<span class="s1">}</span>
<span class="s0">export </span><span class="s1">type WorkAsyncStorage = AsyncLocalStorage&lt;WorkStore&gt;;</span>
<span class="s0">export </span><span class="s1">{ workAsyncStorageInstance as workAsyncStorage };</span>
</pre>
</body>
</html>