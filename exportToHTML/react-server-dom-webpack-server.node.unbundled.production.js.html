<html>
<head>
<title>react-server-dom-webpack-server.node.unbundled.production.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #8c8c8c; font-style: italic;}
.s2 { color: #080808;}
.s3 { color: #067d17;}
.s4 { color: #0033b3;}
.s5 { color: #1750eb;}
.s6 { color: #0037a6;}
.s7 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
react-server-dom-webpack-server.node.unbundled.production.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@license </span><span class="s0">React</span>
 <span class="s0">* react-server-dom-webpack-server.node.unbundled.production.js</span>
 <span class="s0">*</span>
 <span class="s0">* Copyright (c) Meta Platforms, Inc. and affiliates.</span>
 <span class="s0">*</span>
 <span class="s0">* This source code is licensed under the MIT license found in the</span>
 <span class="s0">* LICENSE file in the root directory of this source tree.</span>
 <span class="s0">*/</span>

<span class="s3">&quot;use strict&quot;</span><span class="s2">;</span>
<span class="s4">var </span><span class="s2">stream = require(</span><span class="s3">&quot;stream&quot;</span><span class="s2">),</span>
  <span class="s2">util = require(</span><span class="s3">&quot;util&quot;</span><span class="s2">);</span>
<span class="s2">require(</span><span class="s3">&quot;crypto&quot;</span><span class="s2">);</span>
<span class="s4">var </span><span class="s2">async_hooks = require(</span><span class="s3">&quot;async_hooks&quot;</span><span class="s2">),</span>
  <span class="s2">ReactDOM = require(</span><span class="s3">&quot;react-dom&quot;</span><span class="s2">),</span>
  <span class="s2">React = require(</span><span class="s3">&quot;react&quot;</span><span class="s2">),</span>
  <span class="s2">REACT_LEGACY_ELEMENT_TYPE = Symbol.for(</span><span class="s3">&quot;react.element&quot;</span><span class="s2">),</span>
  <span class="s2">REACT_ELEMENT_TYPE = Symbol.for(</span><span class="s3">&quot;react.transitional.element&quot;</span><span class="s2">),</span>
  <span class="s2">REACT_FRAGMENT_TYPE = Symbol.for(</span><span class="s3">&quot;react.fragment&quot;</span><span class="s2">),</span>
  <span class="s2">REACT_CONTEXT_TYPE = Symbol.for(</span><span class="s3">&quot;react.context&quot;</span><span class="s2">),</span>
  <span class="s2">REACT_FORWARD_REF_TYPE = Symbol.for(</span><span class="s3">&quot;react.forward_ref&quot;</span><span class="s2">),</span>
  <span class="s2">REACT_SUSPENSE_TYPE = Symbol.for(</span><span class="s3">&quot;react.suspense&quot;</span><span class="s2">),</span>
  <span class="s2">REACT_SUSPENSE_LIST_TYPE = Symbol.for(</span><span class="s3">&quot;react.suspense_list&quot;</span><span class="s2">),</span>
  <span class="s2">REACT_MEMO_TYPE = Symbol.for(</span><span class="s3">&quot;react.memo&quot;</span><span class="s2">),</span>
  <span class="s2">REACT_LAZY_TYPE = Symbol.for(</span><span class="s3">&quot;react.lazy&quot;</span><span class="s2">),</span>
  <span class="s2">REACT_MEMO_CACHE_SENTINEL = Symbol.for(</span><span class="s3">&quot;react.memo_cache_sentinel&quot;</span><span class="s2">),</span>
  <span class="s2">REACT_POSTPONE_TYPE = Symbol.for(</span><span class="s3">&quot;react.postpone&quot;</span><span class="s2">),</span>
  <span class="s2">REACT_VIEW_TRANSITION_TYPE = Symbol.for(</span><span class="s3">&quot;react.view_transition&quot;</span><span class="s2">),</span>
  <span class="s2">MAYBE_ITERATOR_SYMBOL = Symbol.iterator;</span>
<span class="s4">function </span><span class="s2">getIteratorFn(maybeIterable) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== maybeIterable || </span><span class="s3">&quot;object&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">maybeIterable) </span><span class="s4">return null</span><span class="s2">;</span>
  <span class="s2">maybeIterable =</span>
    <span class="s2">(MAYBE_ITERATOR_SYMBOL &amp;&amp; maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||</span>
    <span class="s2">maybeIterable[</span><span class="s3">&quot;@@iterator&quot;</span><span class="s2">];</span>
  <span class="s4">return </span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">maybeIterable ? maybeIterable : </span><span class="s4">null</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">ASYNC_ITERATOR = Symbol.asyncIterator,</span>
  <span class="s2">scheduleMicrotask = queueMicrotask,</span>
  <span class="s2">currentView = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">writtenBytes = </span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">destinationHasCapacity = !</span><span class="s5">0</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">writeToDestination(destination, view) {</span>
  <span class="s2">destination = destination.write(view);</span>
  <span class="s2">destinationHasCapacity = destinationHasCapacity &amp;&amp; destination;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">writeChunkAndReturn(destination, chunk) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">chunk) {</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">!== chunk.length)</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s5">2048 </span><span class="s2">&lt; </span><span class="s5">3 </span><span class="s2">* chunk.length)</span>
        <span class="s5">0 </span><span class="s2">&lt; writtenBytes &amp;&amp;</span>
          <span class="s2">(writeToDestination(</span>
            <span class="s2">destination,</span>
            <span class="s2">currentView.subarray(</span><span class="s5">0</span><span class="s2">, writtenBytes)</span>
          <span class="s2">),</span>
          <span class="s2">(currentView = </span><span class="s4">new </span><span class="s2">Uint8Array(</span><span class="s5">2048</span><span class="s2">)),</span>
          <span class="s2">(writtenBytes = </span><span class="s5">0</span><span class="s2">)),</span>
          <span class="s2">writeToDestination(destination, chunk);</span>
      <span class="s4">else </span><span class="s2">{</span>
        <span class="s4">var </span><span class="s2">target = currentView;</span>
        <span class="s5">0 </span><span class="s2">&lt; writtenBytes &amp;&amp; (target = currentView.subarray(writtenBytes));</span>
        <span class="s2">target = textEncoder.encodeInto(chunk, target);</span>
        <span class="s4">var </span><span class="s2">read = target.read;</span>
        <span class="s2">writtenBytes += target.written;</span>
        <span class="s2">read &lt; chunk.length &amp;&amp;</span>
          <span class="s2">(writeToDestination(</span>
            <span class="s2">destination,</span>
            <span class="s2">currentView.subarray(</span><span class="s5">0</span><span class="s2">, writtenBytes)</span>
          <span class="s2">),</span>
          <span class="s2">(currentView = </span><span class="s4">new </span><span class="s2">Uint8Array(</span><span class="s5">2048</span><span class="s2">)),</span>
          <span class="s2">(writtenBytes = textEncoder.encodeInto(</span>
            <span class="s2">chunk.slice(read),</span>
            <span class="s2">currentView</span>
          <span class="s2">).written));</span>
        <span class="s5">2048 </span><span class="s2">=== writtenBytes &amp;&amp;</span>
          <span class="s2">(writeToDestination(destination, currentView),</span>
          <span class="s2">(currentView = </span><span class="s4">new </span><span class="s2">Uint8Array(</span><span class="s5">2048</span><span class="s2">)),</span>
          <span class="s2">(writtenBytes = </span><span class="s5">0</span><span class="s2">));</span>
      <span class="s2">}</span>
  <span class="s2">} </span><span class="s4">else</span>
    <span class="s5">0 </span><span class="s2">!== chunk.byteLength &amp;&amp;</span>
      <span class="s2">(</span><span class="s5">2048 </span><span class="s2">&lt; chunk.byteLength</span>
        <span class="s2">? (</span><span class="s5">0 </span><span class="s2">&lt; writtenBytes &amp;&amp;</span>
            <span class="s2">(writeToDestination(</span>
              <span class="s2">destination,</span>
              <span class="s2">currentView.subarray(</span><span class="s5">0</span><span class="s2">, writtenBytes)</span>
            <span class="s2">),</span>
            <span class="s2">(currentView = </span><span class="s4">new </span><span class="s2">Uint8Array(</span><span class="s5">2048</span><span class="s2">)),</span>
            <span class="s2">(writtenBytes = </span><span class="s5">0</span><span class="s2">)),</span>
          <span class="s2">writeToDestination(destination, chunk))</span>
        <span class="s2">: ((target = currentView.length - writtenBytes),</span>
          <span class="s2">target &lt; chunk.byteLength &amp;&amp;</span>
            <span class="s2">(</span><span class="s5">0 </span><span class="s2">=== target</span>
              <span class="s2">? writeToDestination(destination, currentView)</span>
              <span class="s2">: (currentView.set(chunk.subarray(</span><span class="s5">0</span><span class="s2">, target), writtenBytes),</span>
                <span class="s2">(writtenBytes += target),</span>
                <span class="s2">writeToDestination(destination, currentView),</span>
                <span class="s2">(chunk = chunk.subarray(target))),</span>
            <span class="s2">(currentView = </span><span class="s4">new </span><span class="s2">Uint8Array(</span><span class="s5">2048</span><span class="s2">)),</span>
            <span class="s2">(writtenBytes = </span><span class="s5">0</span><span class="s2">)),</span>
          <span class="s2">currentView.set(chunk, writtenBytes),</span>
          <span class="s2">(writtenBytes += chunk.byteLength),</span>
          <span class="s5">2048 </span><span class="s2">=== writtenBytes &amp;&amp;</span>
            <span class="s2">(writeToDestination(destination, currentView),</span>
            <span class="s2">(currentView = </span><span class="s4">new </span><span class="s2">Uint8Array(</span><span class="s5">2048</span><span class="s2">)),</span>
            <span class="s2">(writtenBytes = </span><span class="s5">0</span><span class="s2">))));</span>
  <span class="s4">return </span><span class="s2">destinationHasCapacity;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">textEncoder = </span><span class="s4">new </span><span class="s2">util.TextEncoder();</span>
<span class="s4">function </span><span class="s2">byteLengthOfChunk(chunk) {</span>
  <span class="s4">return </span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">chunk</span>
    <span class="s2">? Buffer.byteLength(chunk, </span><span class="s3">&quot;utf8&quot;</span><span class="s2">)</span>
    <span class="s2">: chunk.byteLength;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">CLIENT_REFERENCE_TAG$1 = Symbol.for(</span><span class="s3">&quot;react.client.reference&quot;</span><span class="s2">),</span>
  <span class="s2">SERVER_REFERENCE_TAG = Symbol.for(</span><span class="s3">&quot;react.server.reference&quot;</span><span class="s2">);</span>
<span class="s4">function </span><span class="s2">registerClientReferenceImpl(proxyImplementation, id, async) {</span>
  <span class="s4">return </span><span class="s2">Object.defineProperties(proxyImplementation, {</span>
    <span class="s2">$$typeof: { value: CLIENT_REFERENCE_TAG$1 },</span>
    <span class="s2">$$id: { value: id },</span>
    <span class="s2">$$async: { value: async }</span>
  <span class="s2">});</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">FunctionBind = Function.prototype.bind,</span>
  <span class="s2">ArraySlice = Array.prototype.slice;</span>
<span class="s4">function </span><span class="s2">bind() {</span>
  <span class="s4">var </span><span class="s2">newFn = FunctionBind.apply(</span><span class="s4">this</span><span class="s2">, arguments);</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">this</span><span class="s2">.$$typeof === SERVER_REFERENCE_TAG) {</span>
    <span class="s4">var </span><span class="s2">args = ArraySlice.call(arguments, </span><span class="s5">1</span><span class="s2">),</span>
      <span class="s2">$$typeof = { value: SERVER_REFERENCE_TAG },</span>
      <span class="s2">$$id = { value: </span><span class="s4">this</span><span class="s2">.$$id };</span>
    <span class="s2">args = { value: </span><span class="s4">this</span><span class="s2">.$$bound ? </span><span class="s4">this</span><span class="s2">.$$bound.concat(args) : args };</span>
    <span class="s4">return </span><span class="s2">Object.defineProperties(newFn, {</span>
      <span class="s2">$$typeof: $$typeof,</span>
      <span class="s2">$$id: $$id,</span>
      <span class="s2">$$bound: args,</span>
      <span class="s2">bind: { value: bind, configurable: !</span><span class="s5">0 </span><span class="s2">}</span>
    <span class="s2">});</span>
  <span class="s2">}</span>
  <span class="s4">return </span><span class="s2">newFn;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">PROMISE_PROTOTYPE = Promise.prototype,</span>
  <span class="s2">deepProxyHandlers = {</span>
    <span class="s2">get: </span><span class="s4">function </span><span class="s2">(target, name) {</span>
      <span class="s4">switch </span><span class="s2">(name) {</span>
        <span class="s4">case </span><span class="s3">&quot;$$typeof&quot;</span><span class="s2">:</span>
          <span class="s4">return </span><span class="s2">target.$$typeof;</span>
        <span class="s4">case </span><span class="s3">&quot;$$id&quot;</span><span class="s2">:</span>
          <span class="s4">return </span><span class="s2">target.$$id;</span>
        <span class="s4">case </span><span class="s3">&quot;$$async&quot;</span><span class="s2">:</span>
          <span class="s4">return </span><span class="s2">target.$$async;</span>
        <span class="s4">case </span><span class="s3">&quot;name&quot;</span><span class="s2">:</span>
          <span class="s4">return </span><span class="s2">target.name;</span>
        <span class="s4">case </span><span class="s3">&quot;displayName&quot;</span><span class="s2">:</span>
          <span class="s4">return</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s3">&quot;defaultProps&quot;</span><span class="s2">:</span>
          <span class="s4">return</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s3">&quot;_debugInfo&quot;</span><span class="s2">:</span>
          <span class="s4">return</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s3">&quot;toJSON&quot;</span><span class="s2">:</span>
          <span class="s4">return</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s2">Symbol.toPrimitive:</span>
          <span class="s4">return </span><span class="s2">Object.prototype[Symbol.toPrimitive];</span>
        <span class="s4">case </span><span class="s2">Symbol.toStringTag:</span>
          <span class="s4">return </span><span class="s2">Object.prototype[Symbol.toStringTag];</span>
        <span class="s4">case </span><span class="s3">&quot;Provider&quot;</span><span class="s2">:</span>
          <span class="s4">throw </span><span class="s2">Error(</span>
            <span class="s3">&quot;Cannot render a Client Context Provider on the Server. Instead, you can export a Client Component wrapper that itself renders a Client Context Provider.&quot;</span>
          <span class="s2">);</span>
        <span class="s4">case </span><span class="s3">&quot;then&quot;</span><span class="s2">:</span>
          <span class="s4">throw </span><span class="s2">Error(</span>
            <span class="s3">&quot;Cannot await or return from a thenable. You cannot await a client module from a server component.&quot;</span>
          <span class="s2">);</span>
      <span class="s2">}</span>
      <span class="s4">throw </span><span class="s2">Error(</span>
        <span class="s3">&quot;Cannot access &quot; </span><span class="s2">+</span>
          <span class="s2">(String(target.name) + </span><span class="s3">&quot;.&quot; </span><span class="s2">+ String(name)) +</span>
          <span class="s3">&quot; on the server. You cannot dot into a client module from a server component. You can only pass the imported name through.&quot;</span>
      <span class="s2">);</span>
    <span class="s2">},</span>
    <span class="s2">set: </span><span class="s4">function </span><span class="s2">() {</span>
      <span class="s4">throw </span><span class="s2">Error(</span><span class="s3">&quot;Cannot assign to a client module from a server module.&quot;</span><span class="s2">);</span>
    <span class="s2">}</span>
  <span class="s2">};</span>
<span class="s4">function </span><span class="s2">getReference(target, name) {</span>
  <span class="s4">switch </span><span class="s2">(name) {</span>
    <span class="s4">case </span><span class="s3">&quot;$$typeof&quot;</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">target.$$typeof;</span>
    <span class="s4">case </span><span class="s3">&quot;$$id&quot;</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">target.$$id;</span>
    <span class="s4">case </span><span class="s3">&quot;$$async&quot;</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">target.$$async;</span>
    <span class="s4">case </span><span class="s3">&quot;name&quot;</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">target.name;</span>
    <span class="s4">case </span><span class="s3">&quot;defaultProps&quot;</span><span class="s2">:</span>
      <span class="s4">return</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;_debugInfo&quot;</span><span class="s2">:</span>
      <span class="s4">return</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;toJSON&quot;</span><span class="s2">:</span>
      <span class="s4">return</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s2">Symbol.toPrimitive:</span>
      <span class="s4">return </span><span class="s2">Object.prototype[Symbol.toPrimitive];</span>
    <span class="s4">case </span><span class="s2">Symbol.toStringTag:</span>
      <span class="s4">return </span><span class="s2">Object.prototype[Symbol.toStringTag];</span>
    <span class="s4">case </span><span class="s3">&quot;__esModule&quot;</span><span class="s2">:</span>
      <span class="s4">var </span><span class="s2">moduleId = target.$$id;</span>
      <span class="s2">target.default = registerClientReferenceImpl(</span>
        <span class="s4">function </span><span class="s2">() {</span>
          <span class="s4">throw </span><span class="s2">Error(</span>
            <span class="s3">&quot;Attempted to call the default export of &quot; </span><span class="s2">+</span>
              <span class="s2">moduleId +</span>
              <span class="s3">&quot; from the server but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.&quot;</span>
          <span class="s2">);</span>
        <span class="s2">},</span>
        <span class="s2">target.$$id + </span><span class="s3">&quot;#&quot;</span><span class="s2">,</span>
        <span class="s2">target.$$async</span>
      <span class="s2">);</span>
      <span class="s4">return </span><span class="s2">!</span><span class="s5">0</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;then&quot;</span><span class="s2">:</span>
      <span class="s4">if </span><span class="s2">(target.then) </span><span class="s4">return </span><span class="s2">target.then;</span>
      <span class="s4">if </span><span class="s2">(target.$$async) </span><span class="s4">return</span><span class="s2">;</span>
      <span class="s4">var </span><span class="s2">clientReference = registerClientReferenceImpl({}, target.$$id, !</span><span class="s5">0</span><span class="s2">),</span>
        <span class="s2">proxy = </span><span class="s4">new </span><span class="s2">Proxy(clientReference, proxyHandlers$1);</span>
      <span class="s2">target.status = </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">;</span>
      <span class="s2">target.value = proxy;</span>
      <span class="s4">return </span><span class="s2">(target.then = registerClientReferenceImpl(</span>
        <span class="s4">function </span><span class="s2">(resolve) {</span>
          <span class="s4">return </span><span class="s2">Promise.resolve(resolve(proxy));</span>
        <span class="s2">},</span>
        <span class="s2">target.$$id + </span><span class="s3">&quot;#then&quot;</span><span class="s2">,</span>
        <span class="s2">!</span><span class="s5">1</span>
      <span class="s2">));</span>
  <span class="s2">}</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;symbol&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">name)</span>
    <span class="s4">throw </span><span class="s2">Error(</span>
      <span class="s3">&quot;Cannot read Symbol exports. Only named exports are supported on a client module imported on the server.&quot;</span>
    <span class="s2">);</span>
  <span class="s2">clientReference = target[name];</span>
  <span class="s2">clientReference ||</span>
    <span class="s2">((clientReference = registerClientReferenceImpl(</span>
      <span class="s4">function </span><span class="s2">() {</span>
        <span class="s4">throw </span><span class="s2">Error(</span>
          <span class="s3">&quot;Attempted to call &quot; </span><span class="s2">+</span>
            <span class="s2">String(name) +</span>
            <span class="s3">&quot;() from the server but &quot; </span><span class="s2">+</span>
            <span class="s2">String(name) +</span>
            <span class="s3">&quot; is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.&quot;</span>
        <span class="s2">);</span>
      <span class="s2">},</span>
      <span class="s2">target.$$id + </span><span class="s3">&quot;#&quot; </span><span class="s2">+ name,</span>
      <span class="s2">target.$$async</span>
    <span class="s2">)),</span>
    <span class="s2">Object.defineProperty(clientReference, </span><span class="s3">&quot;name&quot;</span><span class="s2">, { value: name }),</span>
    <span class="s2">(clientReference = target[name] =</span>
      <span class="s4">new </span><span class="s2">Proxy(clientReference, deepProxyHandlers)));</span>
  <span class="s4">return </span><span class="s2">clientReference;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">proxyHandlers$1 = {</span>
    <span class="s2">get: </span><span class="s4">function </span><span class="s2">(target, name) {</span>
      <span class="s4">return </span><span class="s2">getReference(target, name);</span>
    <span class="s2">},</span>
    <span class="s2">getOwnPropertyDescriptor: </span><span class="s4">function </span><span class="s2">(target, name) {</span>
      <span class="s4">var </span><span class="s2">descriptor = Object.getOwnPropertyDescriptor(target, name);</span>
      <span class="s2">descriptor ||</span>
        <span class="s2">((descriptor = {</span>
          <span class="s2">value: getReference(target, name),</span>
          <span class="s2">writable: !</span><span class="s5">1</span><span class="s2">,</span>
          <span class="s2">configurable: !</span><span class="s5">1</span><span class="s2">,</span>
          <span class="s2">enumerable: !</span><span class="s5">1</span>
        <span class="s2">}),</span>
        <span class="s2">Object.defineProperty(target, name, descriptor));</span>
      <span class="s4">return </span><span class="s2">descriptor;</span>
    <span class="s2">},</span>
    <span class="s2">getPrototypeOf: </span><span class="s4">function </span><span class="s2">() {</span>
      <span class="s4">return </span><span class="s2">PROMISE_PROTOTYPE;</span>
    <span class="s2">},</span>
    <span class="s2">set: </span><span class="s4">function </span><span class="s2">() {</span>
      <span class="s4">throw </span><span class="s2">Error(</span><span class="s3">&quot;Cannot assign to a client module from a server module.&quot;</span><span class="s2">);</span>
    <span class="s2">}</span>
  <span class="s2">},</span>
  <span class="s2">ReactDOMSharedInternals =</span>
    <span class="s2">ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,</span>
  <span class="s2">previousDispatcher = ReactDOMSharedInternals.d;</span>
<span class="s2">ReactDOMSharedInternals.d = {</span>
  <span class="s2">f: previousDispatcher.f,</span>
  <span class="s2">r: previousDispatcher.r,</span>
  <span class="s2">D: prefetchDNS,</span>
  <span class="s2">C: preconnect,</span>
  <span class="s2">L: preload,</span>
  <span class="s2">m: preloadModule$1,</span>
  <span class="s2">X: preinitScript,</span>
  <span class="s2">S: preinitStyle,</span>
  <span class="s2">M: preinitModuleScript</span>
<span class="s2">};</span>
<span class="s4">function </span><span class="s2">prefetchDNS(href) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">href &amp;&amp; href) {</span>
    <span class="s4">var </span><span class="s2">request = resolveRequest();</span>
    <span class="s4">if </span><span class="s2">(request) {</span>
      <span class="s4">var </span><span class="s2">hints = request.hints,</span>
        <span class="s2">key = </span><span class="s3">&quot;D|&quot; </span><span class="s2">+ href;</span>
      <span class="s2">hints.has(key) || (hints.add(key), emitHint(request, </span><span class="s3">&quot;D&quot;</span><span class="s2">, href));</span>
    <span class="s2">} </span><span class="s4">else </span><span class="s2">previousDispatcher.D(href);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">preconnect(href, crossOrigin) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">href) {</span>
    <span class="s4">var </span><span class="s2">request = resolveRequest();</span>
    <span class="s4">if </span><span class="s2">(request) {</span>
      <span class="s4">var </span><span class="s2">hints = request.hints,</span>
        <span class="s2">key = </span><span class="s3">&quot;C|&quot; </span><span class="s2">+ (</span><span class="s4">null </span><span class="s2">== crossOrigin ? </span><span class="s3">&quot;null&quot; </span><span class="s2">: crossOrigin) + </span><span class="s3">&quot;|&quot; </span><span class="s2">+ href;</span>
      <span class="s2">hints.has(key) ||</span>
        <span class="s2">(hints.add(key),</span>
        <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">crossOrigin</span>
          <span class="s2">? emitHint(request, </span><span class="s3">&quot;C&quot;</span><span class="s2">, [href, crossOrigin])</span>
          <span class="s2">: emitHint(request, </span><span class="s3">&quot;C&quot;</span><span class="s2">, href));</span>
    <span class="s2">} </span><span class="s4">else </span><span class="s2">previousDispatcher.C(href, crossOrigin);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">preload(href, as, options) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">href) {</span>
    <span class="s4">var </span><span class="s2">request = resolveRequest();</span>
    <span class="s4">if </span><span class="s2">(request) {</span>
      <span class="s4">var </span><span class="s2">hints = request.hints,</span>
        <span class="s2">key = </span><span class="s3">&quot;L&quot;</span><span class="s2">;</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;image&quot; </span><span class="s2">=== as &amp;&amp; options) {</span>
        <span class="s4">var </span><span class="s2">imageSrcSet = options.imageSrcSet,</span>
          <span class="s2">imageSizes = options.imageSizes,</span>
          <span class="s2">uniquePart = </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
        <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">imageSrcSet &amp;&amp; </span><span class="s3">&quot;&quot; </span><span class="s2">!== imageSrcSet</span>
          <span class="s2">? ((uniquePart += </span><span class="s3">&quot;[&quot; </span><span class="s2">+ imageSrcSet + </span><span class="s3">&quot;]&quot;</span><span class="s2">),</span>
            <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">imageSizes &amp;&amp;</span>
              <span class="s2">(uniquePart += </span><span class="s3">&quot;[&quot; </span><span class="s2">+ imageSizes + </span><span class="s3">&quot;]&quot;</span><span class="s2">))</span>
          <span class="s2">: (uniquePart += </span><span class="s3">&quot;[][]&quot; </span><span class="s2">+ href);</span>
        <span class="s2">key += </span><span class="s3">&quot;[image]&quot; </span><span class="s2">+ uniquePart;</span>
      <span class="s2">} </span><span class="s4">else </span><span class="s2">key += </span><span class="s3">&quot;[&quot; </span><span class="s2">+ as + </span><span class="s3">&quot;]&quot; </span><span class="s2">+ href;</span>
      <span class="s2">hints.has(key) ||</span>
        <span class="s2">(hints.add(key),</span>
        <span class="s2">(options = trimOptions(options))</span>
          <span class="s2">? emitHint(request, </span><span class="s3">&quot;L&quot;</span><span class="s2">, [href, as, options])</span>
          <span class="s2">: emitHint(request, </span><span class="s3">&quot;L&quot;</span><span class="s2">, [href, as]));</span>
    <span class="s2">} </span><span class="s4">else </span><span class="s2">previousDispatcher.L(href, as, options);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">preloadModule$1(href, options) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">href) {</span>
    <span class="s4">var </span><span class="s2">request = resolveRequest();</span>
    <span class="s4">if </span><span class="s2">(request) {</span>
      <span class="s4">var </span><span class="s2">hints = request.hints,</span>
        <span class="s2">key = </span><span class="s3">&quot;m|&quot; </span><span class="s2">+ href;</span>
      <span class="s4">if </span><span class="s2">(hints.has(key)) </span><span class="s4">return</span><span class="s2">;</span>
      <span class="s2">hints.add(key);</span>
      <span class="s4">return </span><span class="s2">(options = trimOptions(options))</span>
        <span class="s2">? emitHint(request, </span><span class="s3">&quot;m&quot;</span><span class="s2">, [href, options])</span>
        <span class="s2">: emitHint(request, </span><span class="s3">&quot;m&quot;</span><span class="s2">, href);</span>
    <span class="s2">}</span>
    <span class="s2">previousDispatcher.m(href, options);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">preinitStyle(href, precedence, options) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">href) {</span>
    <span class="s4">var </span><span class="s2">request = resolveRequest();</span>
    <span class="s4">if </span><span class="s2">(request) {</span>
      <span class="s4">var </span><span class="s2">hints = request.hints,</span>
        <span class="s2">key = </span><span class="s3">&quot;S|&quot; </span><span class="s2">+ href;</span>
      <span class="s4">if </span><span class="s2">(hints.has(key)) </span><span class="s4">return</span><span class="s2">;</span>
      <span class="s2">hints.add(key);</span>
      <span class="s4">return </span><span class="s2">(options = trimOptions(options))</span>
        <span class="s2">? emitHint(request, </span><span class="s3">&quot;S&quot;</span><span class="s2">, [</span>
            <span class="s2">href,</span>
            <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">precedence ? precedence : </span><span class="s5">0</span><span class="s2">,</span>
            <span class="s2">options</span>
          <span class="s2">])</span>
        <span class="s2">: </span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">precedence</span>
          <span class="s2">? emitHint(request, </span><span class="s3">&quot;S&quot;</span><span class="s2">, [href, precedence])</span>
          <span class="s2">: emitHint(request, </span><span class="s3">&quot;S&quot;</span><span class="s2">, href);</span>
    <span class="s2">}</span>
    <span class="s2">previousDispatcher.S(href, precedence, options);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">preinitScript(src, options) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">src) {</span>
    <span class="s4">var </span><span class="s2">request = resolveRequest();</span>
    <span class="s4">if </span><span class="s2">(request) {</span>
      <span class="s4">var </span><span class="s2">hints = request.hints,</span>
        <span class="s2">key = </span><span class="s3">&quot;X|&quot; </span><span class="s2">+ src;</span>
      <span class="s4">if </span><span class="s2">(hints.has(key)) </span><span class="s4">return</span><span class="s2">;</span>
      <span class="s2">hints.add(key);</span>
      <span class="s4">return </span><span class="s2">(options = trimOptions(options))</span>
        <span class="s2">? emitHint(request, </span><span class="s3">&quot;X&quot;</span><span class="s2">, [src, options])</span>
        <span class="s2">: emitHint(request, </span><span class="s3">&quot;X&quot;</span><span class="s2">, src);</span>
    <span class="s2">}</span>
    <span class="s2">previousDispatcher.X(src, options);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">preinitModuleScript(src, options) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">src) {</span>
    <span class="s4">var </span><span class="s2">request = resolveRequest();</span>
    <span class="s4">if </span><span class="s2">(request) {</span>
      <span class="s4">var </span><span class="s2">hints = request.hints,</span>
        <span class="s2">key = </span><span class="s3">&quot;M|&quot; </span><span class="s2">+ src;</span>
      <span class="s4">if </span><span class="s2">(hints.has(key)) </span><span class="s4">return</span><span class="s2">;</span>
      <span class="s2">hints.add(key);</span>
      <span class="s4">return </span><span class="s2">(options = trimOptions(options))</span>
        <span class="s2">? emitHint(request, </span><span class="s3">&quot;M&quot;</span><span class="s2">, [src, options])</span>
        <span class="s2">: emitHint(request, </span><span class="s3">&quot;M&quot;</span><span class="s2">, src);</span>
    <span class="s2">}</span>
    <span class="s2">previousDispatcher.M(src, options);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">trimOptions(options) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">== options) </span><span class="s4">return null</span><span class="s2">;</span>
  <span class="s4">var </span><span class="s2">hasProperties = !</span><span class="s5">1</span><span class="s2">,</span>
    <span class="s2">trimmed = {},</span>
    <span class="s2">key;</span>
  <span class="s4">for </span><span class="s2">(key </span><span class="s4">in </span><span class="s2">options)</span>
    <span class="s4">null </span><span class="s2">!= options[key] &amp;&amp;</span>
      <span class="s2">((hasProperties = !</span><span class="s5">0</span><span class="s2">), (trimmed[key] = options[key]));</span>
  <span class="s4">return </span><span class="s2">hasProperties ? trimmed : </span><span class="s4">null</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">requestStorage = </span><span class="s4">new </span><span class="s2">async_hooks.AsyncLocalStorage(),</span>
  <span class="s2">TEMPORARY_REFERENCE_TAG = Symbol.for(</span><span class="s3">&quot;react.temporary.reference&quot;</span><span class="s2">),</span>
  <span class="s2">proxyHandlers = {</span>
    <span class="s2">get: </span><span class="s4">function </span><span class="s2">(target, name) {</span>
      <span class="s4">switch </span><span class="s2">(name) {</span>
        <span class="s4">case </span><span class="s3">&quot;$$typeof&quot;</span><span class="s2">:</span>
          <span class="s4">return </span><span class="s2">target.$$typeof;</span>
        <span class="s4">case </span><span class="s3">&quot;name&quot;</span><span class="s2">:</span>
          <span class="s4">return</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s3">&quot;displayName&quot;</span><span class="s2">:</span>
          <span class="s4">return</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s3">&quot;defaultProps&quot;</span><span class="s2">:</span>
          <span class="s4">return</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s3">&quot;_debugInfo&quot;</span><span class="s2">:</span>
          <span class="s4">return</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s3">&quot;toJSON&quot;</span><span class="s2">:</span>
          <span class="s4">return</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s2">Symbol.toPrimitive:</span>
          <span class="s4">return </span><span class="s2">Object.prototype[Symbol.toPrimitive];</span>
        <span class="s4">case </span><span class="s2">Symbol.toStringTag:</span>
          <span class="s4">return </span><span class="s2">Object.prototype[Symbol.toStringTag];</span>
        <span class="s4">case </span><span class="s3">&quot;Provider&quot;</span><span class="s2">:</span>
          <span class="s4">throw </span><span class="s2">Error(</span>
            <span class="s3">&quot;Cannot render a Client Context Provider on the Server. Instead, you can export a Client Component wrapper that itself renders a Client Context Provider.&quot;</span>
          <span class="s2">);</span>
        <span class="s4">case </span><span class="s3">&quot;then&quot;</span><span class="s2">:</span>
          <span class="s4">return</span><span class="s2">;</span>
      <span class="s2">}</span>
      <span class="s4">throw </span><span class="s2">Error(</span>
        <span class="s3">&quot;Cannot access &quot; </span><span class="s2">+</span>
          <span class="s2">String(name) +</span>
          <span class="s3">&quot; on the server. You cannot dot into a temporary client reference from a server component. You can only pass the value through to the client.&quot;</span>
      <span class="s2">);</span>
    <span class="s2">},</span>
    <span class="s2">set: </span><span class="s4">function </span><span class="s2">() {</span>
      <span class="s4">throw </span><span class="s2">Error(</span>
        <span class="s3">&quot;Cannot assign to a temporary client reference from a server module.&quot;</span>
      <span class="s2">);</span>
    <span class="s2">}</span>
  <span class="s2">};</span>
<span class="s4">function </span><span class="s2">createTemporaryReference(temporaryReferences, id) {</span>
  <span class="s4">var </span><span class="s2">reference = Object.defineProperties(</span>
    <span class="s4">function </span><span class="s2">() {</span>
      <span class="s4">throw </span><span class="s2">Error(</span>
        <span class="s3">&quot;Attempted to call a temporary Client Reference from the server but it is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.&quot;</span>
      <span class="s2">);</span>
    <span class="s2">},</span>
    <span class="s2">{ $$typeof: { value: TEMPORARY_REFERENCE_TAG } }</span>
  <span class="s2">);</span>
  <span class="s2">reference = </span><span class="s4">new </span><span class="s2">Proxy(reference, proxyHandlers);</span>
  <span class="s2">temporaryReferences.set(reference, id);</span>
  <span class="s4">return </span><span class="s2">reference;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">noop() {}</span>
<span class="s4">var </span><span class="s2">SuspenseException = Error(</span>
  <span class="s3">&quot;Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.</span><span class="s6">\n\n</span><span class="s3">To handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`.&quot;</span>
<span class="s2">);</span>
<span class="s4">function </span><span class="s2">trackUsedThenable(thenableState, thenable, index) {</span>
  <span class="s2">index = thenableState[index];</span>
  <span class="s4">void </span><span class="s5">0 </span><span class="s2">=== index</span>
    <span class="s2">? thenableState.push(thenable)</span>
    <span class="s2">: index !== thenable &amp;&amp; (thenable.then(noop, noop), (thenable = index));</span>
  <span class="s4">switch </span><span class="s2">(thenable.status) {</span>
    <span class="s4">case </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">thenable.value;</span>
    <span class="s4">case </span><span class="s3">&quot;rejected&quot;</span><span class="s2">:</span>
      <span class="s4">throw </span><span class="s2">thenable.reason;</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">thenable.status</span>
        <span class="s2">? thenable.then(noop, noop)</span>
        <span class="s2">: ((thenableState = thenable),</span>
          <span class="s2">(thenableState.status = </span><span class="s3">&quot;pending&quot;</span><span class="s2">),</span>
          <span class="s2">thenableState.then(</span>
            <span class="s4">function </span><span class="s2">(fulfilledValue) {</span>
              <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;pending&quot; </span><span class="s2">=== thenable.status) {</span>
                <span class="s4">var </span><span class="s2">fulfilledThenable = thenable;</span>
                <span class="s2">fulfilledThenable.status = </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">;</span>
                <span class="s2">fulfilledThenable.value = fulfilledValue;</span>
              <span class="s2">}</span>
            <span class="s2">},</span>
            <span class="s4">function </span><span class="s2">(error) {</span>
              <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;pending&quot; </span><span class="s2">=== thenable.status) {</span>
                <span class="s4">var </span><span class="s2">rejectedThenable = thenable;</span>
                <span class="s2">rejectedThenable.status = </span><span class="s3">&quot;rejected&quot;</span><span class="s2">;</span>
                <span class="s2">rejectedThenable.reason = error;</span>
              <span class="s2">}</span>
            <span class="s2">}</span>
          <span class="s2">));</span>
      <span class="s4">switch </span><span class="s2">(thenable.status) {</span>
        <span class="s4">case </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">:</span>
          <span class="s4">return </span><span class="s2">thenable.value;</span>
        <span class="s4">case </span><span class="s3">&quot;rejected&quot;</span><span class="s2">:</span>
          <span class="s4">throw </span><span class="s2">thenable.reason;</span>
      <span class="s2">}</span>
      <span class="s2">suspendedThenable = thenable;</span>
      <span class="s4">throw </span><span class="s2">SuspenseException;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">suspendedThenable = </span><span class="s4">null</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">getSuspendedThenable() {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== suspendedThenable)</span>
    <span class="s4">throw </span><span class="s2">Error(</span>
      <span class="s3">&quot;Expected a suspended thenable. This is a bug in React. Please file an issue.&quot;</span>
    <span class="s2">);</span>
  <span class="s4">var </span><span class="s2">thenable = suspendedThenable;</span>
  <span class="s2">suspendedThenable = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">return </span><span class="s2">thenable;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">currentRequest$1 = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">thenableIndexCounter = </span><span class="s5">0</span><span class="s2">,</span>
  <span class="s2">thenableState = </span><span class="s4">null</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">getThenableStateAfterSuspending() {</span>
  <span class="s4">var </span><span class="s2">state = thenableState || [];</span>
  <span class="s2">thenableState = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">return </span><span class="s2">state;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">HooksDispatcher = {</span>
  <span class="s2">readContext: unsupportedContext,</span>
  <span class="s2">use: use,</span>
  <span class="s2">useCallback: </span><span class="s4">function </span><span class="s2">(callback) {</span>
    <span class="s4">return </span><span class="s2">callback;</span>
  <span class="s2">},</span>
  <span class="s2">useContext: unsupportedContext,</span>
  <span class="s2">useEffect: unsupportedHook,</span>
  <span class="s2">useImperativeHandle: unsupportedHook,</span>
  <span class="s2">useLayoutEffect: unsupportedHook,</span>
  <span class="s2">useInsertionEffect: unsupportedHook,</span>
  <span class="s2">useMemo: </span><span class="s4">function </span><span class="s2">(nextCreate) {</span>
    <span class="s4">return </span><span class="s2">nextCreate();</span>
  <span class="s2">},</span>
  <span class="s2">useReducer: unsupportedHook,</span>
  <span class="s2">useRef: unsupportedHook,</span>
  <span class="s2">useState: unsupportedHook,</span>
  <span class="s2">useDebugValue: </span><span class="s4">function </span><span class="s2">() {},</span>
  <span class="s2">useDeferredValue: unsupportedHook,</span>
  <span class="s2">useTransition: unsupportedHook,</span>
  <span class="s2">useSyncExternalStore: unsupportedHook,</span>
  <span class="s2">useId: useId,</span>
  <span class="s2">useHostTransitionStatus: unsupportedHook,</span>
  <span class="s2">useFormState: unsupportedHook,</span>
  <span class="s2">useActionState: unsupportedHook,</span>
  <span class="s2">useOptimistic: unsupportedHook,</span>
  <span class="s2">useMemoCache: </span><span class="s4">function </span><span class="s2">(size) {</span>
    <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">data = Array(size), i = </span><span class="s5">0</span><span class="s2">; i &lt; size; i++)</span>
      <span class="s2">data[i] = REACT_MEMO_CACHE_SENTINEL;</span>
    <span class="s4">return </span><span class="s2">data;</span>
  <span class="s2">},</span>
  <span class="s2">useCacheRefresh: </span><span class="s4">function </span><span class="s2">() {</span>
    <span class="s4">return </span><span class="s2">unsupportedRefresh;</span>
  <span class="s2">}</span>
<span class="s2">};</span>
<span class="s2">HooksDispatcher.useEffectEvent = unsupportedHook;</span>
<span class="s4">function </span><span class="s2">unsupportedHook() {</span>
  <span class="s4">throw </span><span class="s2">Error(</span><span class="s3">&quot;This Hook is not supported in Server Components.&quot;</span><span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">unsupportedRefresh() {</span>
  <span class="s4">throw </span><span class="s2">Error(</span><span class="s3">&quot;Refreshing the cache is not supported in Server Components.&quot;</span><span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">unsupportedContext() {</span>
  <span class="s4">throw </span><span class="s2">Error(</span><span class="s3">&quot;Cannot read a Client Context from a Server Component.&quot;</span><span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">useId() {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== currentRequest$1)</span>
    <span class="s4">throw </span><span class="s2">Error(</span><span class="s3">&quot;useId can only be used while React is rendering&quot;</span><span class="s2">);</span>
  <span class="s4">var </span><span class="s2">id = currentRequest$1.identifierCount++;</span>
  <span class="s4">return </span><span class="s3">&quot;_&quot; </span><span class="s2">+ currentRequest$1.identifierPrefix + </span><span class="s3">&quot;S_&quot; </span><span class="s2">+ id.toString(</span><span class="s5">32</span><span class="s2">) + </span><span class="s3">&quot;_&quot;</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">use(usable) {</span>
  <span class="s4">if </span><span class="s2">(</span>
    <span class="s2">(</span><span class="s4">null </span><span class="s2">!== usable &amp;&amp; </span><span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">usable) ||</span>
    <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">usable</span>
  <span class="s2">) {</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">usable.then) {</span>
      <span class="s4">var </span><span class="s2">index = thenableIndexCounter;</span>
      <span class="s2">thenableIndexCounter += </span><span class="s5">1</span><span class="s2">;</span>
      <span class="s4">null </span><span class="s2">=== thenableState &amp;&amp; (thenableState = []);</span>
      <span class="s4">return </span><span class="s2">trackUsedThenable(thenableState, usable, index);</span>
    <span class="s2">}</span>
    <span class="s2">usable.$$typeof === REACT_CONTEXT_TYPE &amp;&amp; unsupportedContext();</span>
  <span class="s2">}</span>
  <span class="s4">if </span><span class="s2">(usable.$$typeof === CLIENT_REFERENCE_TAG$1) {</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!= usable.value &amp;&amp; usable.value.$$typeof === REACT_CONTEXT_TYPE)</span>
      <span class="s4">throw </span><span class="s2">Error(</span><span class="s3">&quot;Cannot read a Client Context from a Server Component.&quot;</span><span class="s2">);</span>
    <span class="s4">throw </span><span class="s2">Error(</span><span class="s3">&quot;Cannot use() an already resolved Client Reference.&quot;</span><span class="s2">);</span>
  <span class="s2">}</span>
  <span class="s4">throw </span><span class="s2">Error(</span><span class="s3">&quot;An unsupported type was passed to use(): &quot; </span><span class="s2">+ String(usable));</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">DefaultAsyncDispatcher = {</span>
    <span class="s2">getCacheForType: </span><span class="s4">function </span><span class="s2">(resourceType) {</span>
      <span class="s4">var </span><span class="s2">JSCompiler_inline_result = (JSCompiler_inline_result =</span>
        <span class="s2">resolveRequest())</span>
        <span class="s2">? JSCompiler_inline_result.cache</span>
        <span class="s2">: </span><span class="s4">new </span><span class="s2">Map();</span>
      <span class="s4">var </span><span class="s2">entry = JSCompiler_inline_result.get(resourceType);</span>
      <span class="s4">void </span><span class="s5">0 </span><span class="s2">=== entry &amp;&amp;</span>
        <span class="s2">((entry = resourceType()),</span>
        <span class="s2">JSCompiler_inline_result.set(resourceType, entry));</span>
      <span class="s4">return </span><span class="s2">entry;</span>
    <span class="s2">},</span>
    <span class="s2">cacheSignal: </span><span class="s4">function </span><span class="s2">() {</span>
      <span class="s4">var </span><span class="s2">request = resolveRequest();</span>
      <span class="s4">return </span><span class="s2">request ? request.cacheController.signal : </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s2">}</span>
  <span class="s2">},</span>
  <span class="s2">ReactSharedInternalsServer =</span>
    <span class="s2">React.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;</span>
<span class="s4">if </span><span class="s2">(!ReactSharedInternalsServer)</span>
  <span class="s4">throw </span><span class="s2">Error(</span>
    <span class="s3">'The &quot;react&quot; package in this environment is not configured correctly. The &quot;react-server&quot; condition must be enabled in any environment that runs React Server Components.'</span>
  <span class="s2">);</span>
<span class="s4">var </span><span class="s2">isArrayImpl = Array.isArray,</span>
  <span class="s2">getPrototypeOf = Object.getPrototypeOf;</span>
<span class="s4">function </span><span class="s2">objectName(object) {</span>
  <span class="s2">object = Object.prototype.toString.call(object);</span>
  <span class="s4">return </span><span class="s2">object.slice(</span><span class="s5">8</span><span class="s2">, object.length - </span><span class="s5">1</span><span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">describeValueForErrorMessage(value) {</span>
  <span class="s4">switch </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">value) {</span>
    <span class="s4">case </span><span class="s3">&quot;string&quot;</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">JSON.stringify(</span>
        <span class="s5">10 </span><span class="s2">&gt;= value.length ? value : value.slice(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">10</span><span class="s2">) + </span><span class="s3">&quot;...&quot;</span>
      <span class="s2">);</span>
    <span class="s4">case </span><span class="s3">&quot;object&quot;</span><span class="s2">:</span>
      <span class="s4">if </span><span class="s2">(isArrayImpl(value)) </span><span class="s4">return </span><span class="s3">&quot;[...]&quot;</span><span class="s2">;</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== value &amp;&amp; value.$$typeof === CLIENT_REFERENCE_TAG)</span>
        <span class="s4">return </span><span class="s3">&quot;client&quot;</span><span class="s2">;</span>
      <span class="s2">value = objectName(value);</span>
      <span class="s4">return </span><span class="s3">&quot;Object&quot; </span><span class="s2">=== value ? </span><span class="s3">&quot;{...}&quot; </span><span class="s2">: value;</span>
    <span class="s4">case </span><span class="s3">&quot;function&quot;</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">value.$$typeof === CLIENT_REFERENCE_TAG</span>
        <span class="s2">? </span><span class="s3">&quot;client&quot;</span>
        <span class="s2">: (value = value.displayName || value.name)</span>
          <span class="s2">? </span><span class="s3">&quot;function &quot; </span><span class="s2">+ value</span>
          <span class="s2">: </span><span class="s3">&quot;function&quot;</span><span class="s2">;</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">String(value);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">describeElementType(type) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">type) </span><span class="s4">return </span><span class="s2">type;</span>
  <span class="s4">switch </span><span class="s2">(type) {</span>
    <span class="s4">case </span><span class="s2">REACT_SUSPENSE_TYPE:</span>
      <span class="s4">return </span><span class="s3">&quot;Suspense&quot;</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s2">REACT_SUSPENSE_LIST_TYPE:</span>
      <span class="s4">return </span><span class="s3">&quot;SuspenseList&quot;</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s2">REACT_VIEW_TRANSITION_TYPE:</span>
      <span class="s4">return </span><span class="s3">&quot;ViewTransition&quot;</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">type)</span>
    <span class="s4">switch </span><span class="s2">(type.$$typeof) {</span>
      <span class="s4">case </span><span class="s2">REACT_FORWARD_REF_TYPE:</span>
        <span class="s4">return </span><span class="s2">describeElementType(type.render);</span>
      <span class="s4">case </span><span class="s2">REACT_MEMO_TYPE:</span>
        <span class="s4">return </span><span class="s2">describeElementType(type.type);</span>
      <span class="s4">case </span><span class="s2">REACT_LAZY_TYPE:</span>
        <span class="s4">var </span><span class="s2">payload = type._payload;</span>
        <span class="s2">type = type._init;</span>
        <span class="s4">try </span><span class="s2">{</span>
          <span class="s4">return </span><span class="s2">describeElementType(type(payload));</span>
        <span class="s2">} </span><span class="s4">catch </span><span class="s2">(x) {}</span>
    <span class="s2">}</span>
  <span class="s4">return </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">CLIENT_REFERENCE_TAG = Symbol.for(</span><span class="s3">&quot;react.client.reference&quot;</span><span class="s2">);</span>
<span class="s4">function </span><span class="s2">describeObjectForErrorMessage(objectOrArray, expandedName) {</span>
  <span class="s4">var </span><span class="s2">objKind = objectName(objectOrArray);</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;Object&quot; </span><span class="s2">!== objKind &amp;&amp; </span><span class="s3">&quot;Array&quot; </span><span class="s2">!== objKind) </span><span class="s4">return </span><span class="s2">objKind;</span>
  <span class="s2">objKind = -</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s4">var </span><span class="s2">length = </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s4">if </span><span class="s2">(isArrayImpl(objectOrArray)) {</span>
    <span class="s4">var </span><span class="s2">str = </span><span class="s3">&quot;[&quot;</span><span class="s2">;</span>
    <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; objectOrArray.length; i++) {</span>
      <span class="s5">0 </span><span class="s2">&lt; i &amp;&amp; (str += </span><span class="s3">&quot;, &quot;</span><span class="s2">);</span>
      <span class="s4">var </span><span class="s2">value = objectOrArray[i];</span>
      <span class="s2">value =</span>
        <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value &amp;&amp; </span><span class="s4">null </span><span class="s2">!== value</span>
          <span class="s2">? describeObjectForErrorMessage(value)</span>
          <span class="s2">: describeValueForErrorMessage(value);</span>
      <span class="s3">&quot;&quot; </span><span class="s2">+ i === expandedName</span>
        <span class="s2">? ((objKind = str.length), (length = value.length), (str += value))</span>
        <span class="s2">: (str =</span>
            <span class="s5">10 </span><span class="s2">&gt; value.length &amp;&amp; </span><span class="s5">40 </span><span class="s2">&gt; str.length + value.length</span>
              <span class="s2">? str + value</span>
              <span class="s2">: str + </span><span class="s3">&quot;...&quot;</span><span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s2">str += </span><span class="s3">&quot;]&quot;</span><span class="s2">;</span>
  <span class="s2">} </span><span class="s4">else if </span><span class="s2">(objectOrArray.$$typeof === REACT_ELEMENT_TYPE)</span>
    <span class="s2">str = </span><span class="s3">&quot;&lt;&quot; </span><span class="s2">+ describeElementType(objectOrArray.type) + </span><span class="s3">&quot;/&gt;&quot;</span><span class="s2">;</span>
  <span class="s4">else </span><span class="s2">{</span>
    <span class="s4">if </span><span class="s2">(objectOrArray.$$typeof === CLIENT_REFERENCE_TAG) </span><span class="s4">return </span><span class="s3">&quot;client&quot;</span><span class="s2">;</span>
    <span class="s2">str = </span><span class="s3">&quot;{&quot;</span><span class="s2">;</span>
    <span class="s2">i = Object.keys(objectOrArray);</span>
    <span class="s4">for </span><span class="s2">(value = </span><span class="s5">0</span><span class="s2">; value &lt; i.length; value++) {</span>
      <span class="s5">0 </span><span class="s2">&lt; value &amp;&amp; (str += </span><span class="s3">&quot;, &quot;</span><span class="s2">);</span>
      <span class="s4">var </span><span class="s2">name = i[value],</span>
        <span class="s2">encodedKey = JSON.stringify(name);</span>
      <span class="s2">str += (</span><span class="s3">'&quot;' </span><span class="s2">+ name + </span><span class="s3">'&quot;' </span><span class="s2">=== encodedKey ? name : encodedKey) + </span><span class="s3">&quot;: &quot;</span><span class="s2">;</span>
      <span class="s2">encodedKey = objectOrArray[name];</span>
      <span class="s2">encodedKey =</span>
        <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">encodedKey &amp;&amp; </span><span class="s4">null </span><span class="s2">!== encodedKey</span>
          <span class="s2">? describeObjectForErrorMessage(encodedKey)</span>
          <span class="s2">: describeValueForErrorMessage(encodedKey);</span>
      <span class="s2">name === expandedName</span>
        <span class="s2">? ((objKind = str.length),</span>
          <span class="s2">(length = encodedKey.length),</span>
          <span class="s2">(str += encodedKey))</span>
        <span class="s2">: (str =</span>
            <span class="s5">10 </span><span class="s2">&gt; encodedKey.length &amp;&amp; </span><span class="s5">40 </span><span class="s2">&gt; str.length + encodedKey.length</span>
              <span class="s2">? str + encodedKey</span>
              <span class="s2">: str + </span><span class="s3">&quot;...&quot;</span><span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s2">str += </span><span class="s3">&quot;}&quot;</span><span class="s2">;</span>
  <span class="s2">}</span>
  <span class="s4">return void </span><span class="s5">0 </span><span class="s2">=== expandedName</span>
    <span class="s2">? str</span>
    <span class="s2">: -</span><span class="s5">1 </span><span class="s2">&lt; objKind &amp;&amp; </span><span class="s5">0 </span><span class="s2">&lt; length</span>
      <span class="s2">? ((objectOrArray = </span><span class="s3">&quot; &quot;</span><span class="s2">.repeat(objKind) + </span><span class="s3">&quot;^&quot;</span><span class="s2">.repeat(length)),</span>
        <span class="s3">&quot;</span><span class="s6">\n  </span><span class="s3">&quot; </span><span class="s2">+ str + </span><span class="s3">&quot;</span><span class="s6">\n  </span><span class="s3">&quot; </span><span class="s2">+ objectOrArray)</span>
      <span class="s2">: </span><span class="s3">&quot;</span><span class="s6">\n  </span><span class="s3">&quot; </span><span class="s2">+ str;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">hasOwnProperty = Object.prototype.hasOwnProperty,</span>
  <span class="s2">ObjectPrototype = Object.prototype,</span>
  <span class="s2">stringify = JSON.stringify,</span>
  <span class="s2">TaintRegistryObjects = ReactSharedInternalsServer.TaintRegistryObjects,</span>
  <span class="s2">TaintRegistryValues = ReactSharedInternalsServer.TaintRegistryValues,</span>
  <span class="s2">TaintRegistryByteLengths =</span>
    <span class="s2">ReactSharedInternalsServer.TaintRegistryByteLengths,</span>
  <span class="s2">TaintRegistryPendingRequests =</span>
    <span class="s2">ReactSharedInternalsServer.TaintRegistryPendingRequests;</span>
<span class="s4">function </span><span class="s2">throwTaintViolation(message) {</span>
  <span class="s4">throw </span><span class="s2">Error(message);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">cleanupTaintQueue(request) {</span>
  <span class="s2">request = request.taintCleanupQueue;</span>
  <span class="s2">TaintRegistryPendingRequests.delete(request);</span>
  <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; request.length; i++) {</span>
    <span class="s4">var </span><span class="s2">entryValue = request[i],</span>
      <span class="s2">entry = TaintRegistryValues.get(entryValue);</span>
    <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== entry &amp;&amp;</span>
      <span class="s2">(</span><span class="s5">1 </span><span class="s2">=== entry.count</span>
        <span class="s2">? TaintRegistryValues.delete(entryValue)</span>
        <span class="s2">: entry.count--);</span>
  <span class="s2">}</span>
  <span class="s2">request.length = </span><span class="s5">0</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">defaultErrorHandler(error) {</span>
  <span class="s2">console.error(error);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">RequestInstance(</span>
  <span class="s2">type,</span>
  <span class="s2">model,</span>
  <span class="s2">bundlerConfig,</span>
  <span class="s2">onError,</span>
  <span class="s2">onPostpone,</span>
  <span class="s2">onAllReady,</span>
  <span class="s2">onFatalError,</span>
  <span class="s2">identifierPrefix,</span>
  <span class="s2">temporaryReferences</span>
<span class="s2">) {</span>
  <span class="s4">if </span><span class="s2">(</span>
    <span class="s4">null </span><span class="s2">!== ReactSharedInternalsServer.A &amp;&amp;</span>
    <span class="s2">ReactSharedInternalsServer.A !== DefaultAsyncDispatcher</span>
  <span class="s2">)</span>
    <span class="s4">throw </span><span class="s2">Error(</span><span class="s3">&quot;Currently React only supports one RSC renderer at a time.&quot;</span><span class="s2">);</span>
  <span class="s2">ReactSharedInternalsServer.A = DefaultAsyncDispatcher;</span>
  <span class="s4">var </span><span class="s2">abortSet = </span><span class="s4">new </span><span class="s2">Set(),</span>
    <span class="s2">pingedTasks = [],</span>
    <span class="s2">cleanupQueue = [];</span>
  <span class="s2">TaintRegistryPendingRequests.add(cleanupQueue);</span>
  <span class="s4">var </span><span class="s2">hints = </span><span class="s4">new </span><span class="s2">Set();</span>
  <span class="s4">this</span><span class="s2">.type = type;</span>
  <span class="s4">this</span><span class="s2">.status = </span><span class="s5">10</span><span class="s2">;</span>
  <span class="s4">this</span><span class="s2">.flushScheduled = !</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s4">this</span><span class="s2">.destination = </span><span class="s4">this</span><span class="s2">.fatalError = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">this</span><span class="s2">.bundlerConfig = bundlerConfig;</span>
  <span class="s4">this</span><span class="s2">.cache = </span><span class="s4">new </span><span class="s2">Map();</span>
  <span class="s4">this</span><span class="s2">.cacheController = </span><span class="s4">new </span><span class="s2">AbortController();</span>
  <span class="s4">this</span><span class="s2">.pendingChunks = </span><span class="s4">this</span><span class="s2">.nextChunkId = </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s4">this</span><span class="s2">.hints = hints;</span>
  <span class="s4">this</span><span class="s2">.abortableTasks = abortSet;</span>
  <span class="s4">this</span><span class="s2">.pingedTasks = pingedTasks;</span>
  <span class="s4">this</span><span class="s2">.completedImportChunks = [];</span>
  <span class="s4">this</span><span class="s2">.completedHintChunks = [];</span>
  <span class="s4">this</span><span class="s2">.completedRegularChunks = [];</span>
  <span class="s4">this</span><span class="s2">.completedErrorChunks = [];</span>
  <span class="s4">this</span><span class="s2">.writtenSymbols = </span><span class="s4">new </span><span class="s2">Map();</span>
  <span class="s4">this</span><span class="s2">.writtenClientReferences = </span><span class="s4">new </span><span class="s2">Map();</span>
  <span class="s4">this</span><span class="s2">.writtenServerReferences = </span><span class="s4">new </span><span class="s2">Map();</span>
  <span class="s4">this</span><span class="s2">.writtenObjects = </span><span class="s4">new </span><span class="s2">WeakMap();</span>
  <span class="s4">this</span><span class="s2">.temporaryReferences = temporaryReferences;</span>
  <span class="s4">this</span><span class="s2">.identifierPrefix = identifierPrefix || </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
  <span class="s4">this</span><span class="s2">.identifierCount = </span><span class="s5">1</span><span class="s2">;</span>
  <span class="s4">this</span><span class="s2">.taintCleanupQueue = cleanupQueue;</span>
  <span class="s4">this</span><span class="s2">.onError = </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">=== onError ? defaultErrorHandler : onError;</span>
  <span class="s4">this</span><span class="s2">.onPostpone = </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">=== onPostpone ? noop : onPostpone;</span>
  <span class="s4">this</span><span class="s2">.onAllReady = onAllReady;</span>
  <span class="s4">this</span><span class="s2">.onFatalError = onFatalError;</span>
  <span class="s2">type = createTask(</span><span class="s4">this</span><span class="s2">, model, </span><span class="s4">null</span><span class="s2">, !</span><span class="s5">1</span><span class="s2">, abortSet);</span>
  <span class="s2">pingedTasks.push(type);</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">currentRequest = </span><span class="s4">null</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">resolveRequest() {</span>
  <span class="s4">if </span><span class="s2">(currentRequest) </span><span class="s4">return </span><span class="s2">currentRequest;</span>
  <span class="s4">var </span><span class="s2">store = requestStorage.getStore();</span>
  <span class="s4">return </span><span class="s2">store ? store : </span><span class="s4">null</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">serializeThenable(request, task, thenable) {</span>
  <span class="s4">var </span><span class="s2">newTask = createTask(</span>
    <span class="s2">request,</span>
    <span class="s2">thenable,</span>
    <span class="s2">task.keyPath,</span>
    <span class="s2">task.implicitSlot,</span>
    <span class="s2">request.abortableTasks</span>
  <span class="s2">);</span>
  <span class="s4">switch </span><span class="s2">(thenable.status) {</span>
    <span class="s4">case </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">(newTask.model = thenable.value), pingTask(request, newTask), newTask.id</span>
      <span class="s2">);</span>
    <span class="s4">case </span><span class="s3">&quot;rejected&quot;</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">erroredTask(request, newTask, thenable.reason), newTask.id;</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s5">12 </span><span class="s2">=== request.status)</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">request.abortableTasks.delete(newTask),</span>
          <span class="s5">21 </span><span class="s2">=== request.type</span>
            <span class="s2">? (haltTask(newTask), finishHaltedTask(newTask, request))</span>
            <span class="s2">: ((task = request.fatalError),</span>
              <span class="s2">abortTask(newTask),</span>
              <span class="s2">finishAbortedTask(newTask, request, task)),</span>
          <span class="s2">newTask.id</span>
        <span class="s2">);</span>
      <span class="s3">&quot;string&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">thenable.status &amp;&amp;</span>
        <span class="s2">((thenable.status = </span><span class="s3">&quot;pending&quot;</span><span class="s2">),</span>
        <span class="s2">thenable.then(</span>
          <span class="s4">function </span><span class="s2">(fulfilledValue) {</span>
            <span class="s3">&quot;pending&quot; </span><span class="s2">=== thenable.status &amp;&amp;</span>
              <span class="s2">((thenable.status = </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">),</span>
              <span class="s2">(thenable.value = fulfilledValue));</span>
          <span class="s2">},</span>
          <span class="s4">function </span><span class="s2">(error) {</span>
            <span class="s3">&quot;pending&quot; </span><span class="s2">=== thenable.status &amp;&amp;</span>
              <span class="s2">((thenable.status = </span><span class="s3">&quot;rejected&quot;</span><span class="s2">), (thenable.reason = error));</span>
          <span class="s2">}</span>
        <span class="s2">));</span>
  <span class="s2">}</span>
  <span class="s2">thenable.then(</span>
    <span class="s4">function </span><span class="s2">(value) {</span>
      <span class="s2">newTask.model = value;</span>
      <span class="s2">pingTask(request, newTask);</span>
    <span class="s2">},</span>
    <span class="s4">function </span><span class="s2">(reason) {</span>
      <span class="s5">0 </span><span class="s2">=== newTask.status &amp;&amp;</span>
        <span class="s2">(erroredTask(request, newTask, reason), enqueueFlush(request));</span>
    <span class="s2">}</span>
  <span class="s2">);</span>
  <span class="s4">return </span><span class="s2">newTask.id;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">serializeReadableStream(request, task, stream) {</span>
  <span class="s4">function </span><span class="s2">progress(entry) {</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">=== streamTask.status)</span>
      <span class="s4">if </span><span class="s2">(entry.done)</span>
        <span class="s2">(streamTask.status = </span><span class="s5">1</span><span class="s2">),</span>
          <span class="s2">(entry = streamTask.id.toString(</span><span class="s5">16</span><span class="s2">) + </span><span class="s3">&quot;:C</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">),</span>
          <span class="s2">request.completedRegularChunks.push(entry),</span>
          <span class="s2">request.abortableTasks.delete(streamTask),</span>
          <span class="s2">request.cacheController.signal.removeEventListener(</span>
            <span class="s3">&quot;abort&quot;</span><span class="s2">,</span>
            <span class="s2">abortStream</span>
          <span class="s2">),</span>
          <span class="s2">enqueueFlush(request),</span>
          <span class="s2">callOnAllReadyIfReady(request);</span>
      <span class="s4">else</span>
        <span class="s4">try </span><span class="s2">{</span>
          <span class="s2">(streamTask.model = entry.value),</span>
            <span class="s2">request.pendingChunks++,</span>
            <span class="s2">tryStreamTask(request, streamTask),</span>
            <span class="s2">enqueueFlush(request),</span>
            <span class="s2">reader.read().then(progress, error);</span>
        <span class="s2">} </span><span class="s4">catch </span><span class="s2">(x$8) {</span>
          <span class="s2">error(x$8);</span>
        <span class="s2">}</span>
  <span class="s2">}</span>
  <span class="s4">function </span><span class="s2">error(reason) {</span>
    <span class="s5">0 </span><span class="s2">=== streamTask.status &amp;&amp;</span>
      <span class="s2">(request.cacheController.signal.removeEventListener(</span><span class="s3">&quot;abort&quot;</span><span class="s2">, abortStream),</span>
      <span class="s2">erroredTask(request, streamTask, reason),</span>
      <span class="s2">enqueueFlush(request),</span>
      <span class="s2">reader.cancel(reason).then(error, error));</span>
  <span class="s2">}</span>
  <span class="s4">function </span><span class="s2">abortStream() {</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">=== streamTask.status) {</span>
      <span class="s4">var </span><span class="s2">signal = request.cacheController.signal;</span>
      <span class="s2">signal.removeEventListener(</span><span class="s3">&quot;abort&quot;</span><span class="s2">, abortStream);</span>
      <span class="s2">signal = signal.reason;</span>
      <span class="s5">21 </span><span class="s2">=== request.type</span>
        <span class="s2">? (request.abortableTasks.delete(streamTask),</span>
          <span class="s2">haltTask(streamTask),</span>
          <span class="s2">finishHaltedTask(streamTask, request))</span>
        <span class="s2">: (erroredTask(request, streamTask, signal), enqueueFlush(request));</span>
      <span class="s2">reader.cancel(signal).then(error, error);</span>
    <span class="s2">}</span>
  <span class="s2">}</span>
  <span class="s4">var </span><span class="s2">supportsBYOB = stream.supportsBYOB;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">=== supportsBYOB)</span>
    <span class="s4">try </span><span class="s2">{</span>
      <span class="s2">stream.getReader({ mode: </span><span class="s3">&quot;byob&quot; </span><span class="s2">}).releaseLock(), (supportsBYOB = !</span><span class="s5">0</span><span class="s2">);</span>
    <span class="s2">} </span><span class="s4">catch </span><span class="s2">(x) {</span>
      <span class="s2">supportsBYOB = !</span><span class="s5">1</span><span class="s2">;</span>
    <span class="s2">}</span>
  <span class="s4">var </span><span class="s2">reader = stream.getReader(),</span>
    <span class="s2">streamTask = createTask(</span>
      <span class="s2">request,</span>
      <span class="s2">task.model,</span>
      <span class="s2">task.keyPath,</span>
      <span class="s2">task.implicitSlot,</span>
      <span class="s2">request.abortableTasks</span>
    <span class="s2">);</span>
  <span class="s2">request.pendingChunks++;</span>
  <span class="s2">task = streamTask.id.toString(</span><span class="s5">16</span><span class="s2">) + </span><span class="s3">&quot;:&quot; </span><span class="s2">+ (supportsBYOB ? </span><span class="s3">&quot;r&quot; </span><span class="s2">: </span><span class="s3">&quot;R&quot;</span><span class="s2">) + </span><span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">;</span>
  <span class="s2">request.completedRegularChunks.push(task);</span>
  <span class="s2">request.cacheController.signal.addEventListener(</span><span class="s3">&quot;abort&quot;</span><span class="s2">, abortStream);</span>
  <span class="s2">reader.read().then(progress, error);</span>
  <span class="s4">return </span><span class="s2">serializeByValueID(streamTask.id);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">serializeAsyncIterable(request, task, iterable, iterator) {</span>
  <span class="s4">function </span><span class="s2">progress(entry) {</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">=== streamTask.status)</span>
      <span class="s4">if </span><span class="s2">(entry.done) {</span>
        <span class="s2">streamTask.status = </span><span class="s5">1</span><span class="s2">;</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">=== entry.value)</span>
          <span class="s4">var </span><span class="s2">endStreamRow = streamTask.id.toString(</span><span class="s5">16</span><span class="s2">) + </span><span class="s3">&quot;:C</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">;</span>
        <span class="s4">else</span>
          <span class="s4">try </span><span class="s2">{</span>
            <span class="s4">var </span><span class="s2">chunkId = outlineModel(request, entry.value);</span>
            <span class="s2">endStreamRow =</span>
              <span class="s2">streamTask.id.toString(</span><span class="s5">16</span><span class="s2">) +</span>
              <span class="s3">&quot;:C&quot; </span><span class="s2">+</span>
              <span class="s2">stringify(serializeByValueID(chunkId)) +</span>
              <span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">;</span>
          <span class="s2">} </span><span class="s4">catch </span><span class="s2">(x) {</span>
            <span class="s2">error(x);</span>
            <span class="s4">return</span><span class="s2">;</span>
          <span class="s2">}</span>
        <span class="s2">request.completedRegularChunks.push(endStreamRow);</span>
        <span class="s2">request.abortableTasks.delete(streamTask);</span>
        <span class="s2">request.cacheController.signal.removeEventListener(</span>
          <span class="s3">&quot;abort&quot;</span><span class="s2">,</span>
          <span class="s2">abortIterable</span>
        <span class="s2">);</span>
        <span class="s2">enqueueFlush(request);</span>
        <span class="s2">callOnAllReadyIfReady(request);</span>
      <span class="s2">} </span><span class="s4">else</span>
        <span class="s4">try </span><span class="s2">{</span>
          <span class="s2">(streamTask.model = entry.value),</span>
            <span class="s2">request.pendingChunks++,</span>
            <span class="s2">tryStreamTask(request, streamTask),</span>
            <span class="s2">enqueueFlush(request),</span>
            <span class="s2">iterator.next().then(progress, error);</span>
        <span class="s2">} </span><span class="s4">catch </span><span class="s2">(x$9) {</span>
          <span class="s2">error(x$9);</span>
        <span class="s2">}</span>
  <span class="s2">}</span>
  <span class="s4">function </span><span class="s2">error(reason) {</span>
    <span class="s5">0 </span><span class="s2">=== streamTask.status &amp;&amp;</span>
      <span class="s2">(request.cacheController.signal.removeEventListener(</span>
        <span class="s3">&quot;abort&quot;</span><span class="s2">,</span>
        <span class="s2">abortIterable</span>
      <span class="s2">),</span>
      <span class="s2">erroredTask(request, streamTask, reason),</span>
      <span class="s2">enqueueFlush(request),</span>
      <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">iterator.throw &amp;&amp;</span>
        <span class="s2">iterator.throw(reason).then(error, error));</span>
  <span class="s2">}</span>
  <span class="s4">function </span><span class="s2">abortIterable() {</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">=== streamTask.status) {</span>
      <span class="s4">var </span><span class="s2">signal = request.cacheController.signal;</span>
      <span class="s2">signal.removeEventListener(</span><span class="s3">&quot;abort&quot;</span><span class="s2">, abortIterable);</span>
      <span class="s4">var </span><span class="s2">reason = signal.reason;</span>
      <span class="s5">21 </span><span class="s2">=== request.type</span>
        <span class="s2">? (request.abortableTasks.delete(streamTask),</span>
          <span class="s2">haltTask(streamTask),</span>
          <span class="s2">finishHaltedTask(streamTask, request))</span>
        <span class="s2">: (erroredTask(request, streamTask, signal.reason),</span>
          <span class="s2">enqueueFlush(request));</span>
      <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">iterator.throw &amp;&amp;</span>
        <span class="s2">iterator.throw(reason).then(error, error);</span>
    <span class="s2">}</span>
  <span class="s2">}</span>
  <span class="s2">iterable = iterable === iterator;</span>
  <span class="s4">var </span><span class="s2">streamTask = createTask(</span>
    <span class="s2">request,</span>
    <span class="s2">task.model,</span>
    <span class="s2">task.keyPath,</span>
    <span class="s2">task.implicitSlot,</span>
    <span class="s2">request.abortableTasks</span>
  <span class="s2">);</span>
  <span class="s2">request.pendingChunks++;</span>
  <span class="s2">task = streamTask.id.toString(</span><span class="s5">16</span><span class="s2">) + </span><span class="s3">&quot;:&quot; </span><span class="s2">+ (iterable ? </span><span class="s3">&quot;x&quot; </span><span class="s2">: </span><span class="s3">&quot;X&quot;</span><span class="s2">) + </span><span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">;</span>
  <span class="s2">request.completedRegularChunks.push(task);</span>
  <span class="s2">request.cacheController.signal.addEventListener(</span><span class="s3">&quot;abort&quot;</span><span class="s2">, abortIterable);</span>
  <span class="s2">iterator.next().then(progress, error);</span>
  <span class="s4">return </span><span class="s2">serializeByValueID(streamTask.id);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">emitHint(request, code, model) {</span>
  <span class="s2">model = stringify(model);</span>
  <span class="s2">request.completedHintChunks.push(</span><span class="s3">&quot;:H&quot; </span><span class="s2">+ code + model + </span><span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">);</span>
  <span class="s2">enqueueFlush(request);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">readThenable(thenable) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;fulfilled&quot; </span><span class="s2">=== thenable.status) </span><span class="s4">return </span><span class="s2">thenable.value;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;rejected&quot; </span><span class="s2">=== thenable.status) </span><span class="s4">throw </span><span class="s2">thenable.reason;</span>
  <span class="s4">throw </span><span class="s2">thenable;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createLazyWrapperAroundWakeable(request, task, wakeable) {</span>
  <span class="s4">switch </span><span class="s2">(wakeable.status) {</span>
    <span class="s4">case </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">:</span>
      <span class="s4">return </span><span class="s2">wakeable.value;</span>
    <span class="s4">case </span><span class="s3">&quot;rejected&quot;</span><span class="s2">:</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s3">&quot;string&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">wakeable.status &amp;&amp;</span>
        <span class="s2">((wakeable.status = </span><span class="s3">&quot;pending&quot;</span><span class="s2">),</span>
        <span class="s2">wakeable.then(</span>
          <span class="s4">function </span><span class="s2">(fulfilledValue) {</span>
            <span class="s3">&quot;pending&quot; </span><span class="s2">=== wakeable.status &amp;&amp;</span>
              <span class="s2">((wakeable.status = </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">),</span>
              <span class="s2">(wakeable.value = fulfilledValue));</span>
          <span class="s2">},</span>
          <span class="s4">function </span><span class="s2">(error) {</span>
            <span class="s3">&quot;pending&quot; </span><span class="s2">=== wakeable.status &amp;&amp;</span>
              <span class="s2">((wakeable.status = </span><span class="s3">&quot;rejected&quot;</span><span class="s2">), (wakeable.reason = error));</span>
          <span class="s2">}</span>
        <span class="s2">));</span>
  <span class="s2">}</span>
  <span class="s4">return </span><span class="s2">{ $$typeof: REACT_LAZY_TYPE, _payload: wakeable, _init: readThenable };</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">voidHandler() {}</span>
<span class="s4">function </span><span class="s2">processServerComponentReturnValue(request, task, Component, result) {</span>
  <span class="s4">if </span><span class="s2">(</span>
    <span class="s3">&quot;object&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">result ||</span>
    <span class="s4">null </span><span class="s2">=== result ||</span>
    <span class="s2">result.$$typeof === CLIENT_REFERENCE_TAG$1</span>
  <span class="s2">)</span>
    <span class="s4">return </span><span class="s2">result;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">result.then)</span>
    <span class="s4">return </span><span class="s2">createLazyWrapperAroundWakeable(request, task, result);</span>
  <span class="s4">var </span><span class="s2">iteratorFn = getIteratorFn(result);</span>
  <span class="s4">return </span><span class="s2">iteratorFn</span>
    <span class="s2">? ((request = {}),</span>
      <span class="s2">(request[Symbol.iterator] = </span><span class="s4">function </span><span class="s2">() {</span>
        <span class="s4">return </span><span class="s2">iteratorFn.call(result);</span>
      <span class="s2">}),</span>
      <span class="s2">request)</span>
    <span class="s2">: </span><span class="s3">&quot;function&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">result[ASYNC_ITERATOR] ||</span>
        <span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">ReadableStream &amp;&amp;</span>
          <span class="s2">result </span><span class="s4">instanceof </span><span class="s2">ReadableStream)</span>
      <span class="s2">? result</span>
      <span class="s2">: ((request = {}),</span>
        <span class="s2">(request[ASYNC_ITERATOR] = </span><span class="s4">function </span><span class="s2">() {</span>
          <span class="s4">return </span><span class="s2">result[ASYNC_ITERATOR]();</span>
        <span class="s2">}),</span>
        <span class="s2">request);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">renderFunctionComponent(request, task, key, Component, props) {</span>
  <span class="s4">var </span><span class="s2">prevThenableState = task.thenableState;</span>
  <span class="s2">task.thenableState = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">thenableIndexCounter = </span><span class="s5">0</span><span class="s2">;</span>
  <span class="s2">thenableState = prevThenableState;</span>
  <span class="s2">props = Component(props, </span><span class="s4">void </span><span class="s5">0</span><span class="s2">);</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">12 </span><span class="s2">=== request.status)</span>
    <span class="s4">throw </span><span class="s2">(</span>
      <span class="s2">(</span><span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">props &amp;&amp;</span>
        <span class="s4">null </span><span class="s2">!== props &amp;&amp;</span>
        <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">props.then &amp;&amp;</span>
        <span class="s2">props.$$typeof !== CLIENT_REFERENCE_TAG$1 &amp;&amp;</span>
        <span class="s2">props.then(voidHandler, voidHandler),</span>
      <span class="s4">null</span><span class="s2">)</span>
    <span class="s2">);</span>
  <span class="s2">props = processServerComponentReturnValue(request, task, Component, props);</span>
  <span class="s2">Component = task.keyPath;</span>
  <span class="s2">prevThenableState = task.implicitSlot;</span>
  <span class="s4">null </span><span class="s2">!== key</span>
    <span class="s2">? (task.keyPath = </span><span class="s4">null </span><span class="s2">=== Component ? key : Component + </span><span class="s3">&quot;,&quot; </span><span class="s2">+ key)</span>
    <span class="s2">: </span><span class="s4">null </span><span class="s2">=== Component &amp;&amp; (task.implicitSlot = !</span><span class="s5">0</span><span class="s2">);</span>
  <span class="s2">request = renderModelDestructive(request, task, emptyRoot, </span><span class="s3">&quot;&quot;</span><span class="s2">, props);</span>
  <span class="s2">task.keyPath = Component;</span>
  <span class="s2">task.implicitSlot = prevThenableState;</span>
  <span class="s4">return </span><span class="s2">request;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">renderFragment(request, task, children) {</span>
  <span class="s4">return null </span><span class="s2">!== task.keyPath</span>
    <span class="s2">? ((request = [</span>
        <span class="s2">REACT_ELEMENT_TYPE,</span>
        <span class="s2">REACT_FRAGMENT_TYPE,</span>
        <span class="s2">task.keyPath,</span>
        <span class="s2">{ children: children }</span>
      <span class="s2">]),</span>
      <span class="s2">task.implicitSlot ? [request] : request)</span>
    <span class="s2">: children;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">serializedSize = </span><span class="s5">0</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">deferTask(request, task) {</span>
  <span class="s2">task = createTask(</span>
    <span class="s2">request,</span>
    <span class="s2">task.model,</span>
    <span class="s2">task.keyPath,</span>
    <span class="s2">task.implicitSlot,</span>
    <span class="s2">request.abortableTasks</span>
  <span class="s2">);</span>
  <span class="s2">pingTask(request, task);</span>
  <span class="s4">return </span><span class="s2">serializeLazyID(task.id);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">renderElement(request, task, type, key, ref, props) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== ref &amp;&amp; </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== ref)</span>
    <span class="s4">throw </span><span class="s2">Error(</span>
      <span class="s3">&quot;Refs cannot be used in Server Components, nor passed to Client Components.&quot;</span>
    <span class="s2">);</span>
  <span class="s4">if </span><span class="s2">(</span>
    <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">type &amp;&amp;</span>
    <span class="s2">type.$$typeof !== CLIENT_REFERENCE_TAG$1 &amp;&amp;</span>
    <span class="s2">type.$$typeof !== TEMPORARY_REFERENCE_TAG</span>
  <span class="s2">)</span>
    <span class="s4">return </span><span class="s2">renderFunctionComponent(request, task, key, type, props);</span>
  <span class="s4">if </span><span class="s2">(type === REACT_FRAGMENT_TYPE &amp;&amp; </span><span class="s4">null </span><span class="s2">=== key)</span>
    <span class="s4">return </span><span class="s2">(</span>
      <span class="s2">(type = task.implicitSlot),</span>
      <span class="s4">null </span><span class="s2">=== task.keyPath &amp;&amp; (task.implicitSlot = !</span><span class="s5">0</span><span class="s2">),</span>
      <span class="s2">(props = renderModelDestructive(</span>
        <span class="s2">request,</span>
        <span class="s2">task,</span>
        <span class="s2">emptyRoot,</span>
        <span class="s3">&quot;&quot;</span><span class="s2">,</span>
        <span class="s2">props.children</span>
      <span class="s2">)),</span>
      <span class="s2">(task.implicitSlot = type),</span>
      <span class="s2">props</span>
    <span class="s2">);</span>
  <span class="s4">if </span><span class="s2">(</span>
    <span class="s4">null </span><span class="s2">!= type &amp;&amp;</span>
    <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">type &amp;&amp;</span>
    <span class="s2">type.$$typeof !== CLIENT_REFERENCE_TAG$1</span>
  <span class="s2">)</span>
    <span class="s4">switch </span><span class="s2">(type.$$typeof) {</span>
      <span class="s4">case </span><span class="s2">REACT_LAZY_TYPE:</span>
        <span class="s4">var </span><span class="s2">init = type._init;</span>
        <span class="s2">type = init(type._payload);</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s5">12 </span><span class="s2">=== request.status) </span><span class="s4">throw null</span><span class="s2">;</span>
        <span class="s4">return </span><span class="s2">renderElement(request, task, type, key, ref, props);</span>
      <span class="s4">case </span><span class="s2">REACT_FORWARD_REF_TYPE:</span>
        <span class="s4">return </span><span class="s2">renderFunctionComponent(request, task, key, type.render, props);</span>
      <span class="s4">case </span><span class="s2">REACT_MEMO_TYPE:</span>
        <span class="s4">return </span><span class="s2">renderElement(request, task, type.type, key, ref, props);</span>
    <span class="s2">}</span>
  <span class="s2">request = key;</span>
  <span class="s2">key = task.keyPath;</span>
  <span class="s4">null </span><span class="s2">=== request</span>
    <span class="s2">? (request = key)</span>
    <span class="s2">: </span><span class="s4">null </span><span class="s2">!== key &amp;&amp; (request = key + </span><span class="s3">&quot;,&quot; </span><span class="s2">+ request);</span>
  <span class="s2">props = [REACT_ELEMENT_TYPE, type, request, props];</span>
  <span class="s2">task = task.implicitSlot &amp;&amp; </span><span class="s4">null </span><span class="s2">!== request ? [props] : props;</span>
  <span class="s4">return </span><span class="s2">task;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">pingTask(request, task) {</span>
  <span class="s4">var </span><span class="s2">pingedTasks = request.pingedTasks;</span>
  <span class="s2">pingedTasks.push(task);</span>
  <span class="s5">1 </span><span class="s2">=== pingedTasks.length &amp;&amp;</span>
    <span class="s2">((request.flushScheduled = </span><span class="s4">null </span><span class="s2">!== request.destination),</span>
    <span class="s5">21 </span><span class="s2">=== request.type || </span><span class="s5">10 </span><span class="s2">=== request.status</span>
      <span class="s2">? scheduleMicrotask(</span><span class="s4">function </span><span class="s2">() {</span>
          <span class="s4">return </span><span class="s2">performWork(request);</span>
        <span class="s2">})</span>
      <span class="s2">: setImmediate(</span><span class="s4">function </span><span class="s2">() {</span>
          <span class="s4">return </span><span class="s2">performWork(request);</span>
        <span class="s2">}));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createTask(request, model, keyPath, implicitSlot, abortSet) {</span>
  <span class="s2">request.pendingChunks++;</span>
  <span class="s4">var </span><span class="s2">id = request.nextChunkId++;</span>
  <span class="s3">&quot;object&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">model ||</span>
    <span class="s4">null </span><span class="s2">=== model ||</span>
    <span class="s4">null </span><span class="s2">!== keyPath ||</span>
    <span class="s2">implicitSlot ||</span>
    <span class="s2">request.writtenObjects.set(model, serializeByValueID(id));</span>
  <span class="s4">var </span><span class="s2">task = {</span>
    <span class="s2">id: id,</span>
    <span class="s2">status: </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">model: model,</span>
    <span class="s2">keyPath: keyPath,</span>
    <span class="s2">implicitSlot: implicitSlot,</span>
    <span class="s2">ping: </span><span class="s4">function </span><span class="s2">() {</span>
      <span class="s4">return </span><span class="s2">pingTask(request, task);</span>
    <span class="s2">},</span>
    <span class="s2">toJSON: </span><span class="s4">function </span><span class="s2">(parentPropertyName, value) {</span>
      <span class="s2">serializedSize += parentPropertyName.length;</span>
      <span class="s4">var </span><span class="s2">prevKeyPath = task.keyPath,</span>
        <span class="s2">prevImplicitSlot = task.implicitSlot;</span>
      <span class="s4">try </span><span class="s2">{</span>
        <span class="s4">var </span><span class="s2">JSCompiler_inline_result = renderModelDestructive(</span>
          <span class="s2">request,</span>
          <span class="s2">task,</span>
          <span class="s4">this</span><span class="s2">,</span>
          <span class="s2">parentPropertyName,</span>
          <span class="s2">value</span>
        <span class="s2">);</span>
      <span class="s2">} </span><span class="s4">catch </span><span class="s2">(thrownValue) {</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s2">((parentPropertyName = task.model),</span>
          <span class="s2">(parentPropertyName =</span>
            <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">parentPropertyName &amp;&amp;</span>
            <span class="s4">null </span><span class="s2">!== parentPropertyName &amp;&amp;</span>
            <span class="s2">(parentPropertyName.$$typeof === REACT_ELEMENT_TYPE ||</span>
              <span class="s2">parentPropertyName.$$typeof === REACT_LAZY_TYPE)),</span>
          <span class="s5">12 </span><span class="s2">=== request.status)</span>
        <span class="s2">)</span>
          <span class="s2">(task.status = </span><span class="s5">3</span><span class="s2">),</span>
            <span class="s5">21 </span><span class="s2">=== request.type</span>
              <span class="s2">? ((prevKeyPath = request.nextChunkId++),</span>
                <span class="s2">(prevKeyPath = parentPropertyName</span>
                  <span class="s2">? serializeLazyID(prevKeyPath)</span>
                  <span class="s2">: serializeByValueID(prevKeyPath)),</span>
                <span class="s2">(JSCompiler_inline_result = prevKeyPath))</span>
              <span class="s2">: ((prevKeyPath = request.fatalError),</span>
                <span class="s2">(JSCompiler_inline_result = parentPropertyName</span>
                  <span class="s2">? serializeLazyID(prevKeyPath)</span>
                  <span class="s2">: serializeByValueID(prevKeyPath)));</span>
        <span class="s4">else if </span><span class="s2">(</span>
          <span class="s2">((value =</span>
            <span class="s2">thrownValue === SuspenseException</span>
              <span class="s2">? getSuspendedThenable()</span>
              <span class="s2">: thrownValue),</span>
          <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value &amp;&amp;</span>
            <span class="s4">null </span><span class="s2">!== value &amp;&amp;</span>
            <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value.then)</span>
        <span class="s2">) {</span>
          <span class="s2">JSCompiler_inline_result = createTask(</span>
            <span class="s2">request,</span>
            <span class="s2">task.model,</span>
            <span class="s2">task.keyPath,</span>
            <span class="s2">task.implicitSlot,</span>
            <span class="s2">request.abortableTasks</span>
          <span class="s2">);</span>
          <span class="s4">var </span><span class="s2">ping = JSCompiler_inline_result.ping;</span>
          <span class="s2">value.then(ping, ping);</span>
          <span class="s2">JSCompiler_inline_result.thenableState =</span>
            <span class="s2">getThenableStateAfterSuspending();</span>
          <span class="s2">task.keyPath = prevKeyPath;</span>
          <span class="s2">task.implicitSlot = prevImplicitSlot;</span>
          <span class="s2">JSCompiler_inline_result = parentPropertyName</span>
            <span class="s2">? serializeLazyID(JSCompiler_inline_result.id)</span>
            <span class="s2">: serializeByValueID(JSCompiler_inline_result.id);</span>
        <span class="s2">} </span><span class="s4">else</span>
          <span class="s2">(task.keyPath = prevKeyPath),</span>
            <span class="s2">(task.implicitSlot = prevImplicitSlot),</span>
            <span class="s2">request.pendingChunks++,</span>
            <span class="s2">(prevKeyPath = request.nextChunkId++),</span>
            <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value &amp;&amp;</span>
            <span class="s4">null </span><span class="s2">!== value &amp;&amp;</span>
            <span class="s2">value.$$typeof === REACT_POSTPONE_TYPE</span>
              <span class="s2">? (logPostpone(request, value.message, task),</span>
                <span class="s2">emitPostponeChunk(request, prevKeyPath))</span>
              <span class="s2">: ((prevImplicitSlot = logRecoverableError(request, value, task)),</span>
                <span class="s2">emitErrorChunk(request, prevKeyPath, prevImplicitSlot)),</span>
            <span class="s2">(JSCompiler_inline_result = parentPropertyName</span>
              <span class="s2">? serializeLazyID(prevKeyPath)</span>
              <span class="s2">: serializeByValueID(prevKeyPath));</span>
      <span class="s2">}</span>
      <span class="s4">return </span><span class="s2">JSCompiler_inline_result;</span>
    <span class="s2">},</span>
    <span class="s2">thenableState: </span><span class="s4">null</span>
  <span class="s2">};</span>
  <span class="s2">abortSet.add(task);</span>
  <span class="s4">return </span><span class="s2">task;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">serializeByValueID(id) {</span>
  <span class="s4">return </span><span class="s3">&quot;$&quot; </span><span class="s2">+ id.toString(</span><span class="s5">16</span><span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">serializeLazyID(id) {</span>
  <span class="s4">return </span><span class="s3">&quot;$L&quot; </span><span class="s2">+ id.toString(</span><span class="s5">16</span><span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">encodeReferenceChunk(request, id, reference) {</span>
  <span class="s2">request = stringify(reference);</span>
  <span class="s4">return </span><span class="s2">id.toString(</span><span class="s5">16</span><span class="s2">) + </span><span class="s3">&quot;:&quot; </span><span class="s2">+ request + </span><span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">serializeClientReference(</span>
  <span class="s2">request,</span>
  <span class="s2">parent,</span>
  <span class="s2">parentPropertyName,</span>
  <span class="s2">clientReference</span>
<span class="s2">) {</span>
  <span class="s4">var </span><span class="s2">clientReferenceKey = clientReference.$$async</span>
      <span class="s2">? clientReference.$$id + </span><span class="s3">&quot;#async&quot;</span>
      <span class="s2">: clientReference.$$id,</span>
    <span class="s2">writtenClientReferences = request.writtenClientReferences,</span>
    <span class="s2">existingId = writtenClientReferences.get(clientReferenceKey);</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== existingId)</span>
    <span class="s4">return </span><span class="s2">parent[</span><span class="s5">0</span><span class="s2">] === REACT_ELEMENT_TYPE &amp;&amp; </span><span class="s3">&quot;1&quot; </span><span class="s2">=== parentPropertyName</span>
      <span class="s2">? serializeLazyID(existingId)</span>
      <span class="s2">: serializeByValueID(existingId);</span>
  <span class="s4">try </span><span class="s2">{</span>
    <span class="s4">var </span><span class="s2">config = request.bundlerConfig,</span>
      <span class="s2">modulePath = clientReference.$$id;</span>
    <span class="s2">existingId = </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
    <span class="s4">var </span><span class="s2">resolvedModuleData = config[modulePath];</span>
    <span class="s4">if </span><span class="s2">(resolvedModuleData) existingId = resolvedModuleData.name;</span>
    <span class="s4">else </span><span class="s2">{</span>
      <span class="s4">var </span><span class="s2">idx = modulePath.lastIndexOf(</span><span class="s3">&quot;#&quot;</span><span class="s2">);</span>
      <span class="s2">-</span><span class="s5">1 </span><span class="s2">!== idx &amp;&amp;</span>
        <span class="s2">((existingId = modulePath.slice(idx + </span><span class="s5">1</span><span class="s2">)),</span>
        <span class="s2">(resolvedModuleData = config[modulePath.slice(</span><span class="s5">0</span><span class="s2">, idx)]));</span>
      <span class="s4">if </span><span class="s2">(!resolvedModuleData)</span>
        <span class="s4">throw </span><span class="s2">Error(</span>
          <span class="s3">'Could not find the module &quot;' </span><span class="s2">+</span>
            <span class="s2">modulePath +</span>
            <span class="s3">'&quot; in the React Client Manifest. This is probably a bug in the React Server Components bundler.'</span>
        <span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s4">if </span><span class="s2">(!</span><span class="s5">0 </span><span class="s2">=== resolvedModuleData.async &amp;&amp; !</span><span class="s5">0 </span><span class="s2">=== clientReference.$$async)</span>
      <span class="s4">throw </span><span class="s2">Error(</span>
        <span class="s3">'The module &quot;' </span><span class="s2">+</span>
          <span class="s2">modulePath +</span>
          <span class="s3">'&quot; is marked as an async ESM module but was loaded as a CJS proxy. This is probably a bug in the React Server Components bundler.'</span>
      <span class="s2">);</span>
    <span class="s4">var </span><span class="s2">JSCompiler_inline_result =</span>
      <span class="s2">!</span><span class="s5">0 </span><span class="s2">=== resolvedModuleData.async || !</span><span class="s5">0 </span><span class="s2">=== clientReference.$$async</span>
        <span class="s2">? [resolvedModuleData.id, resolvedModuleData.chunks, existingId, </span><span class="s5">1</span><span class="s2">]</span>
        <span class="s2">: [resolvedModuleData.id, resolvedModuleData.chunks, existingId];</span>
    <span class="s2">request.pendingChunks++;</span>
    <span class="s4">var </span><span class="s2">importId = request.nextChunkId++,</span>
      <span class="s2">json = stringify(JSCompiler_inline_result),</span>
      <span class="s2">processedChunk = importId.toString(</span><span class="s5">16</span><span class="s2">) + </span><span class="s3">&quot;:I&quot; </span><span class="s2">+ json + </span><span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">;</span>
    <span class="s2">request.completedImportChunks.push(processedChunk);</span>
    <span class="s2">writtenClientReferences.set(clientReferenceKey, importId);</span>
    <span class="s4">return </span><span class="s2">parent[</span><span class="s5">0</span><span class="s2">] === REACT_ELEMENT_TYPE &amp;&amp; </span><span class="s3">&quot;1&quot; </span><span class="s2">=== parentPropertyName</span>
      <span class="s2">? serializeLazyID(importId)</span>
      <span class="s2">: serializeByValueID(importId);</span>
  <span class="s2">} </span><span class="s4">catch </span><span class="s2">(x) {</span>
    <span class="s4">return </span><span class="s2">(</span>
      <span class="s2">request.pendingChunks++,</span>
      <span class="s2">(parent = request.nextChunkId++),</span>
      <span class="s2">(parentPropertyName = logRecoverableError(request, x, </span><span class="s4">null</span><span class="s2">)),</span>
      <span class="s2">emitErrorChunk(request, parent, parentPropertyName),</span>
      <span class="s2">serializeByValueID(parent)</span>
    <span class="s2">);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">outlineModel(request, value) {</span>
  <span class="s2">value = createTask(request, value, </span><span class="s4">null</span><span class="s2">, !</span><span class="s5">1</span><span class="s2">, request.abortableTasks);</span>
  <span class="s2">retryTask(request, value);</span>
  <span class="s4">return </span><span class="s2">value.id;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">serializeTypedArray(request, tag, typedArray) {</span>
  <span class="s2">request.pendingChunks++;</span>
  <span class="s4">var </span><span class="s2">bufferId = request.nextChunkId++;</span>
  <span class="s2">emitTypedArrayChunk(request, bufferId, tag, typedArray, !</span><span class="s5">1</span><span class="s2">);</span>
  <span class="s4">return </span><span class="s2">serializeByValueID(bufferId);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">serializeBlob(request, blob) {</span>
  <span class="s4">function </span><span class="s2">progress(entry) {</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">=== newTask.status)</span>
      <span class="s4">if </span><span class="s2">(entry.done)</span>
        <span class="s2">request.cacheController.signal.removeEventListener(</span><span class="s3">&quot;abort&quot;</span><span class="s2">, abortBlob),</span>
          <span class="s2">pingTask(request, newTask);</span>
      <span class="s4">else</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">model.push(entry.value), reader.read().then(progress).catch(error)</span>
        <span class="s2">);</span>
  <span class="s2">}</span>
  <span class="s4">function </span><span class="s2">error(reason) {</span>
    <span class="s5">0 </span><span class="s2">=== newTask.status &amp;&amp;</span>
      <span class="s2">(request.cacheController.signal.removeEventListener(</span><span class="s3">&quot;abort&quot;</span><span class="s2">, abortBlob),</span>
      <span class="s2">erroredTask(request, newTask, reason),</span>
      <span class="s2">enqueueFlush(request),</span>
      <span class="s2">reader.cancel(reason).then(error, error));</span>
  <span class="s2">}</span>
  <span class="s4">function </span><span class="s2">abortBlob() {</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">=== newTask.status) {</span>
      <span class="s4">var </span><span class="s2">signal = request.cacheController.signal;</span>
      <span class="s2">signal.removeEventListener(</span><span class="s3">&quot;abort&quot;</span><span class="s2">, abortBlob);</span>
      <span class="s2">signal = signal.reason;</span>
      <span class="s5">21 </span><span class="s2">=== request.type</span>
        <span class="s2">? (request.abortableTasks.delete(newTask),</span>
          <span class="s2">haltTask(newTask),</span>
          <span class="s2">finishHaltedTask(newTask, request))</span>
        <span class="s2">: (erroredTask(request, newTask, signal), enqueueFlush(request));</span>
      <span class="s2">reader.cancel(signal).then(error, error);</span>
    <span class="s2">}</span>
  <span class="s2">}</span>
  <span class="s4">var </span><span class="s2">model = [blob.type],</span>
    <span class="s2">newTask = createTask(request, model, </span><span class="s4">null</span><span class="s2">, !</span><span class="s5">1</span><span class="s2">, request.abortableTasks),</span>
    <span class="s2">reader = blob.stream().getReader();</span>
  <span class="s2">request.cacheController.signal.addEventListener(</span><span class="s3">&quot;abort&quot;</span><span class="s2">, abortBlob);</span>
  <span class="s2">reader.read().then(progress).catch(error);</span>
  <span class="s4">return </span><span class="s3">&quot;$B&quot; </span><span class="s2">+ newTask.id.toString(</span><span class="s5">16</span><span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">modelRoot = !</span><span class="s5">1</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">renderModelDestructive(</span>
  <span class="s2">request,</span>
  <span class="s2">task,</span>
  <span class="s2">parent,</span>
  <span class="s2">parentPropertyName,</span>
  <span class="s2">value</span>
<span class="s2">) {</span>
  <span class="s2">task.model = value;</span>
  <span class="s4">if </span><span class="s2">(value === REACT_ELEMENT_TYPE) </span><span class="s4">return </span><span class="s3">&quot;$&quot;</span><span class="s2">;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== value) </span><span class="s4">return null</span><span class="s2">;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value) {</span>
    <span class="s4">switch </span><span class="s2">(value.$$typeof) {</span>
      <span class="s4">case </span><span class="s2">REACT_ELEMENT_TYPE:</span>
        <span class="s4">var </span><span class="s2">elementReference = </span><span class="s4">null</span><span class="s2">,</span>
          <span class="s2">writtenObjects = request.writtenObjects;</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== task.keyPath &amp;&amp; !task.implicitSlot) {</span>
          <span class="s4">var </span><span class="s2">existingReference = writtenObjects.get(value);</span>
          <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== existingReference)</span>
            <span class="s4">if </span><span class="s2">(modelRoot === value) modelRoot = </span><span class="s4">null</span><span class="s2">;</span>
            <span class="s4">else return </span><span class="s2">existingReference;</span>
          <span class="s4">else</span>
            <span class="s2">-</span><span class="s5">1 </span><span class="s2">=== parentPropertyName.indexOf(</span><span class="s3">&quot;:&quot;</span><span class="s2">) &amp;&amp;</span>
              <span class="s2">((parent = writtenObjects.get(parent)),</span>
              <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== parent &amp;&amp;</span>
                <span class="s2">((elementReference = parent + </span><span class="s3">&quot;:&quot; </span><span class="s2">+ parentPropertyName),</span>
                <span class="s2">writtenObjects.set(value, elementReference)));</span>
        <span class="s2">}</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s5">3200 </span><span class="s2">&lt; serializedSize) </span><span class="s4">return </span><span class="s2">deferTask(request, task);</span>
        <span class="s2">parentPropertyName = value.props;</span>
        <span class="s2">parent = parentPropertyName.ref;</span>
        <span class="s2">value = renderElement(</span>
          <span class="s2">request,</span>
          <span class="s2">task,</span>
          <span class="s2">value.type,</span>
          <span class="s2">value.key,</span>
          <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== parent ? parent : </span><span class="s4">null</span><span class="s2">,</span>
          <span class="s2">parentPropertyName</span>
        <span class="s2">);</span>
        <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value &amp;&amp;</span>
          <span class="s4">null </span><span class="s2">!== value &amp;&amp;</span>
          <span class="s4">null </span><span class="s2">!== elementReference &amp;&amp;</span>
          <span class="s2">(writtenObjects.has(value) ||</span>
            <span class="s2">writtenObjects.set(value, elementReference));</span>
        <span class="s4">return </span><span class="s2">value;</span>
      <span class="s4">case </span><span class="s2">REACT_LAZY_TYPE:</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s5">3200 </span><span class="s2">&lt; serializedSize) </span><span class="s4">return </span><span class="s2">deferTask(request, task);</span>
        <span class="s2">task.thenableState = </span><span class="s4">null</span><span class="s2">;</span>
        <span class="s2">parentPropertyName = value._init;</span>
        <span class="s2">value = parentPropertyName(value._payload);</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s5">12 </span><span class="s2">=== request.status) </span><span class="s4">throw null</span><span class="s2">;</span>
        <span class="s4">return </span><span class="s2">renderModelDestructive(request, task, emptyRoot, </span><span class="s3">&quot;&quot;</span><span class="s2">, value);</span>
      <span class="s4">case </span><span class="s2">REACT_LEGACY_ELEMENT_TYPE:</span>
        <span class="s4">throw </span><span class="s2">Error(</span>
          <span class="s3">'A React Element from an older version of React was rendered. This is not supported. It can happen if:</span><span class="s6">\n</span><span class="s3">- Multiple copies of the &quot;react&quot; package is used.</span><span class="s6">\n</span><span class="s3">- A library pre-bundled an old copy of &quot;react&quot; or &quot;react/jsx-runtime&quot;.</span><span class="s6">\n</span><span class="s3">- A compiler tries to &quot;inline&quot; JSX instead of using the runtime.'</span>
        <span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s4">if </span><span class="s2">(value.$$typeof === CLIENT_REFERENCE_TAG$1)</span>
      <span class="s4">return </span><span class="s2">serializeClientReference(</span>
        <span class="s2">request,</span>
        <span class="s2">parent,</span>
        <span class="s2">parentPropertyName,</span>
        <span class="s2">value</span>
      <span class="s2">);</span>
    <span class="s4">if </span><span class="s2">(</span>
      <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== request.temporaryReferences &amp;&amp;</span>
      <span class="s2">((elementReference = request.temporaryReferences.get(value)),</span>
      <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== elementReference)</span>
    <span class="s2">)</span>
      <span class="s4">return </span><span class="s3">&quot;$T&quot; </span><span class="s2">+ elementReference;</span>
    <span class="s2">elementReference = TaintRegistryObjects.get(value);</span>
    <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== elementReference &amp;&amp; throwTaintViolation(elementReference);</span>
    <span class="s2">elementReference = request.writtenObjects;</span>
    <span class="s2">writtenObjects = elementReference.get(value);</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value.then) {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== writtenObjects) {</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== task.keyPath || task.implicitSlot)</span>
          <span class="s4">return </span><span class="s3">&quot;$@&quot; </span><span class="s2">+ serializeThenable(request, task, value).toString(</span><span class="s5">16</span><span class="s2">);</span>
        <span class="s4">if </span><span class="s2">(modelRoot === value) modelRoot = </span><span class="s4">null</span><span class="s2">;</span>
        <span class="s4">else return </span><span class="s2">writtenObjects;</span>
      <span class="s2">}</span>
      <span class="s2">request = </span><span class="s3">&quot;$@&quot; </span><span class="s2">+ serializeThenable(request, task, value).toString(</span><span class="s5">16</span><span class="s2">);</span>
      <span class="s2">elementReference.set(value, request);</span>
      <span class="s4">return </span><span class="s2">request;</span>
    <span class="s2">}</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== writtenObjects)</span>
      <span class="s4">if </span><span class="s2">(modelRoot === value) {</span>
        <span class="s4">if </span><span class="s2">(writtenObjects !== serializeByValueID(task.id))</span>
          <span class="s4">return </span><span class="s2">writtenObjects;</span>
        <span class="s2">modelRoot = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s2">} </span><span class="s4">else return </span><span class="s2">writtenObjects;</span>
    <span class="s4">else if </span><span class="s2">(</span>
      <span class="s2">-</span><span class="s5">1 </span><span class="s2">=== parentPropertyName.indexOf(</span><span class="s3">&quot;:&quot;</span><span class="s2">) &amp;&amp;</span>
      <span class="s2">((writtenObjects = elementReference.get(parent)),</span>
      <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== writtenObjects)</span>
    <span class="s2">) {</span>
      <span class="s2">existingReference = parentPropertyName;</span>
      <span class="s4">if </span><span class="s2">(isArrayImpl(parent) &amp;&amp; parent[</span><span class="s5">0</span><span class="s2">] === REACT_ELEMENT_TYPE)</span>
        <span class="s4">switch </span><span class="s2">(parentPropertyName) {</span>
          <span class="s4">case </span><span class="s3">&quot;1&quot;</span><span class="s2">:</span>
            <span class="s2">existingReference = </span><span class="s3">&quot;type&quot;</span><span class="s2">;</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s4">case </span><span class="s3">&quot;2&quot;</span><span class="s2">:</span>
            <span class="s2">existingReference = </span><span class="s3">&quot;key&quot;</span><span class="s2">;</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s4">case </span><span class="s3">&quot;3&quot;</span><span class="s2">:</span>
            <span class="s2">existingReference = </span><span class="s3">&quot;props&quot;</span><span class="s2">;</span>
            <span class="s4">break</span><span class="s2">;</span>
          <span class="s4">case </span><span class="s3">&quot;4&quot;</span><span class="s2">:</span>
            <span class="s2">existingReference = </span><span class="s3">&quot;_owner&quot;</span><span class="s2">;</span>
        <span class="s2">}</span>
      <span class="s2">elementReference.set(value, writtenObjects + </span><span class="s3">&quot;:&quot; </span><span class="s2">+ existingReference);</span>
    <span class="s2">}</span>
    <span class="s4">if </span><span class="s2">(isArrayImpl(value)) </span><span class="s4">return </span><span class="s2">renderFragment(request, task, value);</span>
    <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Map)</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">(value = Array.from(value)),</span>
        <span class="s3">&quot;$Q&quot; </span><span class="s2">+ outlineModel(request, value).toString(</span><span class="s5">16</span><span class="s2">)</span>
      <span class="s2">);</span>
    <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Set)</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">(value = Array.from(value)),</span>
        <span class="s3">&quot;$W&quot; </span><span class="s2">+ outlineModel(request, value).toString(</span><span class="s5">16</span><span class="s2">)</span>
      <span class="s2">);</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">FormData &amp;&amp; value </span><span class="s4">instanceof </span><span class="s2">FormData)</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">(value = Array.from(value.entries())),</span>
        <span class="s3">&quot;$K&quot; </span><span class="s2">+ outlineModel(request, value).toString(</span><span class="s5">16</span><span class="s2">)</span>
      <span class="s2">);</span>
    <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Error) </span><span class="s4">return </span><span class="s3">&quot;$Z&quot;</span><span class="s2">;</span>
    <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">ArrayBuffer)</span>
      <span class="s4">return </span><span class="s2">serializeTypedArray(request, </span><span class="s3">&quot;A&quot;</span><span class="s2">, </span><span class="s4">new </span><span class="s2">Uint8Array(value));</span>
    <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Int8Array)</span>
      <span class="s4">return </span><span class="s2">serializeTypedArray(request, </span><span class="s3">&quot;O&quot;</span><span class="s2">, value);</span>
    <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Uint8Array)</span>
      <span class="s4">return </span><span class="s2">serializeTypedArray(request, </span><span class="s3">&quot;o&quot;</span><span class="s2">, value);</span>
    <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Uint8ClampedArray)</span>
      <span class="s4">return </span><span class="s2">serializeTypedArray(request, </span><span class="s3">&quot;U&quot;</span><span class="s2">, value);</span>
    <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Int16Array)</span>
      <span class="s4">return </span><span class="s2">serializeTypedArray(request, </span><span class="s3">&quot;S&quot;</span><span class="s2">, value);</span>
    <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Uint16Array)</span>
      <span class="s4">return </span><span class="s2">serializeTypedArray(request, </span><span class="s3">&quot;s&quot;</span><span class="s2">, value);</span>
    <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Int32Array)</span>
      <span class="s4">return </span><span class="s2">serializeTypedArray(request, </span><span class="s3">&quot;L&quot;</span><span class="s2">, value);</span>
    <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Uint32Array)</span>
      <span class="s4">return </span><span class="s2">serializeTypedArray(request, </span><span class="s3">&quot;l&quot;</span><span class="s2">, value);</span>
    <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Float32Array)</span>
      <span class="s4">return </span><span class="s2">serializeTypedArray(request, </span><span class="s3">&quot;G&quot;</span><span class="s2">, value);</span>
    <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Float64Array)</span>
      <span class="s4">return </span><span class="s2">serializeTypedArray(request, </span><span class="s3">&quot;g&quot;</span><span class="s2">, value);</span>
    <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">BigInt64Array)</span>
      <span class="s4">return </span><span class="s2">serializeTypedArray(request, </span><span class="s3">&quot;M&quot;</span><span class="s2">, value);</span>
    <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">BigUint64Array)</span>
      <span class="s4">return </span><span class="s2">serializeTypedArray(request, </span><span class="s3">&quot;m&quot;</span><span class="s2">, value);</span>
    <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">DataView)</span>
      <span class="s4">return </span><span class="s2">serializeTypedArray(request, </span><span class="s3">&quot;V&quot;</span><span class="s2">, value);</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">Blob &amp;&amp; value </span><span class="s4">instanceof </span><span class="s2">Blob)</span>
      <span class="s4">return </span><span class="s2">serializeBlob(request, value);</span>
    <span class="s4">if </span><span class="s2">((elementReference = getIteratorFn(value)))</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">(parentPropertyName = elementReference.call(value)),</span>
        <span class="s2">parentPropertyName === value</span>
          <span class="s2">? </span><span class="s3">&quot;$i&quot; </span><span class="s2">+</span>
            <span class="s2">outlineModel(request, Array.from(parentPropertyName)).toString(</span><span class="s5">16</span><span class="s2">)</span>
          <span class="s2">: renderFragment(request, task, Array.from(parentPropertyName))</span>
      <span class="s2">);</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">ReadableStream &amp;&amp; value </span><span class="s4">instanceof </span><span class="s2">ReadableStream)</span>
      <span class="s4">return </span><span class="s2">serializeReadableStream(request, task, value);</span>
    <span class="s2">elementReference = value[ASYNC_ITERATOR];</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">elementReference)</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s4">null </span><span class="s2">!== task.keyPath</span>
          <span class="s2">? ((value = [</span>
              <span class="s2">REACT_ELEMENT_TYPE,</span>
              <span class="s2">REACT_FRAGMENT_TYPE,</span>
              <span class="s2">task.keyPath,</span>
              <span class="s2">{ children: value }</span>
            <span class="s2">]),</span>
            <span class="s2">(value = task.implicitSlot ? [value] : value))</span>
          <span class="s2">: ((parentPropertyName = elementReference.call(value)),</span>
            <span class="s2">(value = serializeAsyncIterable(</span>
              <span class="s2">request,</span>
              <span class="s2">task,</span>
              <span class="s2">value,</span>
              <span class="s2">parentPropertyName</span>
            <span class="s2">))),</span>
        <span class="s2">value</span>
      <span class="s2">);</span>
    <span class="s4">if </span><span class="s2">(value </span><span class="s4">instanceof </span><span class="s2">Date) </span><span class="s4">return </span><span class="s3">&quot;$D&quot; </span><span class="s2">+ value.toJSON();</span>
    <span class="s2">request = getPrototypeOf(value);</span>
    <span class="s4">if </span><span class="s2">(</span>
      <span class="s2">request !== ObjectPrototype &amp;&amp;</span>
      <span class="s2">(</span><span class="s4">null </span><span class="s2">=== request || </span><span class="s4">null </span><span class="s2">!== getPrototypeOf(request))</span>
    <span class="s2">)</span>
      <span class="s4">throw </span><span class="s2">Error(</span>
        <span class="s3">&quot;Only plain objects, and a few built-ins, can be passed to Client Components from Server Components. Classes or null prototypes are not supported.&quot; </span><span class="s2">+</span>
          <span class="s2">describeObjectForErrorMessage(parent, parentPropertyName)</span>
      <span class="s2">);</span>
    <span class="s4">return </span><span class="s2">value;</span>
  <span class="s2">}</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value) {</span>
    <span class="s2">task = TaintRegistryValues.get(value);</span>
    <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== task &amp;&amp; throwTaintViolation(task.message);</span>
    <span class="s2">serializedSize += value.length;</span>
    <span class="s4">if </span><span class="s2">(</span>
      <span class="s3">&quot;Z&quot; </span><span class="s2">=== value[value.length - </span><span class="s5">1</span><span class="s2">] &amp;&amp;</span>
      <span class="s2">parent[parentPropertyName] </span><span class="s4">instanceof </span><span class="s2">Date</span>
    <span class="s2">)</span>
      <span class="s4">return </span><span class="s3">&quot;$D&quot; </span><span class="s2">+ value;</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s5">1024 </span><span class="s2">&lt;= value.length &amp;&amp; </span><span class="s4">null </span><span class="s2">!== byteLengthOfChunk)</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">request.pendingChunks++,</span>
        <span class="s2">(task = request.nextChunkId++),</span>
        <span class="s2">emitTextChunk(request, task, value, !</span><span class="s5">1</span><span class="s2">),</span>
        <span class="s2">serializeByValueID(task)</span>
      <span class="s2">);</span>
    <span class="s2">value = </span><span class="s3">&quot;$&quot; </span><span class="s2">=== value[</span><span class="s5">0</span><span class="s2">] ? </span><span class="s3">&quot;$&quot; </span><span class="s2">+ value : value;</span>
    <span class="s4">return </span><span class="s2">value;</span>
  <span class="s2">}</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;boolean&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value) </span><span class="s4">return </span><span class="s2">value;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;number&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value)</span>
    <span class="s4">return </span><span class="s2">Number.isFinite(value)</span>
      <span class="s2">? </span><span class="s5">0 </span><span class="s2">=== value &amp;&amp; -Infinity === </span><span class="s5">1 </span><span class="s2">/ value</span>
        <span class="s2">? </span><span class="s3">&quot;$-0&quot;</span>
        <span class="s2">: value</span>
      <span class="s2">: Infinity === value</span>
        <span class="s2">? </span><span class="s3">&quot;$Infinity&quot;</span>
        <span class="s2">: -Infinity === value</span>
          <span class="s2">? </span><span class="s3">&quot;$-Infinity&quot;</span>
          <span class="s2">: </span><span class="s3">&quot;$NaN&quot;</span><span class="s2">;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;undefined&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value) </span><span class="s4">return </span><span class="s3">&quot;$undefined&quot;</span><span class="s2">;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value) {</span>
    <span class="s4">if </span><span class="s2">(value.$$typeof === CLIENT_REFERENCE_TAG$1)</span>
      <span class="s4">return </span><span class="s2">serializeClientReference(</span>
        <span class="s2">request,</span>
        <span class="s2">parent,</span>
        <span class="s2">parentPropertyName,</span>
        <span class="s2">value</span>
      <span class="s2">);</span>
    <span class="s4">if </span><span class="s2">(value.$$typeof === SERVER_REFERENCE_TAG)</span>
      <span class="s4">return </span><span class="s2">(</span>
        <span class="s2">(task = request.writtenServerReferences),</span>
        <span class="s2">(parentPropertyName = task.get(value)),</span>
        <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== parentPropertyName</span>
          <span class="s2">? (value = </span><span class="s3">&quot;$F&quot; </span><span class="s2">+ parentPropertyName.toString(</span><span class="s5">16</span><span class="s2">))</span>
          <span class="s2">: ((parentPropertyName = value.$$bound),</span>
            <span class="s2">(parentPropertyName =</span>
              <span class="s4">null </span><span class="s2">=== parentPropertyName</span>
                <span class="s2">? </span><span class="s4">null</span>
                <span class="s2">: Promise.resolve(parentPropertyName)),</span>
            <span class="s2">(request = outlineModel(request, {</span>
              <span class="s2">id: value.$$id,</span>
              <span class="s2">bound: parentPropertyName</span>
            <span class="s2">})),</span>
            <span class="s2">task.set(value, request),</span>
            <span class="s2">(value = </span><span class="s3">&quot;$F&quot; </span><span class="s2">+ request.toString(</span><span class="s5">16</span><span class="s2">))),</span>
        <span class="s2">value</span>
      <span class="s2">);</span>
    <span class="s4">if </span><span class="s2">(</span>
      <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== request.temporaryReferences &amp;&amp;</span>
      <span class="s2">((request = request.temporaryReferences.get(value)), </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== request)</span>
    <span class="s2">)</span>
      <span class="s4">return </span><span class="s3">&quot;$T&quot; </span><span class="s2">+ request;</span>
    <span class="s2">request = TaintRegistryObjects.get(value);</span>
    <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== request &amp;&amp; throwTaintViolation(request);</span>
    <span class="s4">if </span><span class="s2">(value.$$typeof === TEMPORARY_REFERENCE_TAG)</span>
      <span class="s4">throw </span><span class="s2">Error(</span>
        <span class="s3">&quot;Could not reference an opaque temporary reference. This is likely due to misconfiguring the temporaryReferences options on the server.&quot;</span>
      <span class="s2">);</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s7">/^on[A-Z]/</span><span class="s2">.test(parentPropertyName))</span>
      <span class="s4">throw </span><span class="s2">Error(</span>
        <span class="s3">&quot;Event handlers cannot be passed to Client Component props.&quot; </span><span class="s2">+</span>
          <span class="s2">describeObjectForErrorMessage(parent, parentPropertyName) +</span>
          <span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">If you need interactivity, consider converting part of this to a Client Component.&quot;</span>
      <span class="s2">);</span>
    <span class="s4">throw </span><span class="s2">Error(</span>
      <span class="s3">'Functions cannot be passed directly to Client Components unless you explicitly expose it by marking it with &quot;use server&quot;. Or maybe you meant to call this function rather than return it.' </span><span class="s2">+</span>
        <span class="s2">describeObjectForErrorMessage(parent, parentPropertyName)</span>
    <span class="s2">);</span>
  <span class="s2">}</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;symbol&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value) {</span>
    <span class="s2">task = request.writtenSymbols;</span>
    <span class="s2">elementReference = task.get(value);</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== elementReference)</span>
      <span class="s4">return </span><span class="s2">serializeByValueID(elementReference);</span>
    <span class="s2">elementReference = value.description;</span>
    <span class="s4">if </span><span class="s2">(Symbol.for(elementReference) !== value)</span>
      <span class="s4">throw </span><span class="s2">Error(</span>
        <span class="s3">&quot;Only global symbols received from Symbol.for(...) can be passed to Client Components. The symbol Symbol.for(&quot; </span><span class="s2">+</span>
          <span class="s2">(value.description + </span><span class="s3">&quot;) cannot be found among global symbols.&quot;</span><span class="s2">) +</span>
          <span class="s2">describeObjectForErrorMessage(parent, parentPropertyName)</span>
      <span class="s2">);</span>
    <span class="s2">request.pendingChunks++;</span>
    <span class="s2">parentPropertyName = request.nextChunkId++;</span>
    <span class="s2">parent = encodeReferenceChunk(</span>
      <span class="s2">request,</span>
      <span class="s2">parentPropertyName,</span>
      <span class="s3">&quot;$S&quot; </span><span class="s2">+ elementReference</span>
    <span class="s2">);</span>
    <span class="s2">request.completedImportChunks.push(parent);</span>
    <span class="s2">task.set(value, parentPropertyName);</span>
    <span class="s4">return </span><span class="s2">serializeByValueID(parentPropertyName);</span>
  <span class="s2">}</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;bigint&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value)</span>
    <span class="s4">return </span><span class="s2">(</span>
      <span class="s2">(request = TaintRegistryValues.get(value)),</span>
      <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== request &amp;&amp; throwTaintViolation(request.message),</span>
      <span class="s3">&quot;$n&quot; </span><span class="s2">+ value.toString(</span><span class="s5">10</span><span class="s2">)</span>
    <span class="s2">);</span>
  <span class="s4">throw </span><span class="s2">Error(</span>
    <span class="s3">&quot;Type &quot; </span><span class="s2">+</span>
      <span class="s4">typeof </span><span class="s2">value +</span>
      <span class="s3">&quot; is not supported in Client Component props.&quot; </span><span class="s2">+</span>
      <span class="s2">describeObjectForErrorMessage(parent, parentPropertyName)</span>
  <span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">logPostpone(request, reason) {</span>
  <span class="s4">var </span><span class="s2">prevRequest = currentRequest;</span>
  <span class="s2">currentRequest = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">try </span><span class="s2">{</span>
    <span class="s2">requestStorage.run(</span><span class="s4">void </span><span class="s5">0</span><span class="s2">, request.onPostpone, reason);</span>
  <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
    <span class="s2">currentRequest = prevRequest;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">logRecoverableError(request, error) {</span>
  <span class="s4">var </span><span class="s2">prevRequest = currentRequest;</span>
  <span class="s2">currentRequest = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">try </span><span class="s2">{</span>
    <span class="s4">var </span><span class="s2">errorDigest = requestStorage.run(</span><span class="s4">void </span><span class="s5">0</span><span class="s2">, request.onError, error);</span>
  <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
    <span class="s2">currentRequest = prevRequest;</span>
  <span class="s2">}</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!= errorDigest &amp;&amp; </span><span class="s3">&quot;string&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">errorDigest)</span>
    <span class="s4">throw </span><span class="s2">Error(</span>
      <span class="s3">'onError returned something with a type other than &quot;string&quot;. onError should return a string and may return null or undefined but must not return anything else. It received something of type &quot;' </span><span class="s2">+</span>
        <span class="s4">typeof </span><span class="s2">errorDigest +</span>
        <span class="s3">'&quot; instead'</span>
    <span class="s2">);</span>
  <span class="s4">return </span><span class="s2">errorDigest || </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">fatalError(request, error) {</span>
  <span class="s4">var </span><span class="s2">onFatalError = request.onFatalError;</span>
  <span class="s2">onFatalError(error);</span>
  <span class="s2">cleanupTaintQueue(request);</span>
  <span class="s4">null </span><span class="s2">!== request.destination</span>
    <span class="s2">? ((request.status = </span><span class="s5">14</span><span class="s2">), request.destination.destroy(error))</span>
    <span class="s2">: ((request.status = </span><span class="s5">13</span><span class="s2">), (request.fatalError = error));</span>
  <span class="s2">request.cacheController.abort(</span>
    <span class="s2">Error(</span><span class="s3">&quot;The render was aborted due to a fatal error.&quot;</span><span class="s2">, { cause: error })</span>
  <span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">emitPostponeChunk(request, id) {</span>
  <span class="s2">id = id.toString(</span><span class="s5">16</span><span class="s2">) + </span><span class="s3">&quot;:P</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">;</span>
  <span class="s2">request.completedErrorChunks.push(id);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">emitErrorChunk(request, id, digest) {</span>
  <span class="s2">digest = { digest: digest };</span>
  <span class="s2">id = id.toString(</span><span class="s5">16</span><span class="s2">) + </span><span class="s3">&quot;:E&quot; </span><span class="s2">+ stringify(digest) + </span><span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">;</span>
  <span class="s2">request.completedErrorChunks.push(id);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">emitTypedArrayChunk(request, id, tag, typedArray, debug) {</span>
  <span class="s4">if </span><span class="s2">(TaintRegistryByteLengths.has(typedArray.byteLength)) {</span>
    <span class="s4">var </span><span class="s2">tainted = TaintRegistryValues.get(</span>
      <span class="s2">String.fromCharCode.apply(</span>
        <span class="s2">String,</span>
        <span class="s4">new </span><span class="s2">Uint8Array(</span>
          <span class="s2">typedArray.buffer,</span>
          <span class="s2">typedArray.byteOffset,</span>
          <span class="s2">typedArray.byteLength</span>
        <span class="s2">)</span>
      <span class="s2">)</span>
    <span class="s2">);</span>
    <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== tainted &amp;&amp; throwTaintViolation(tainted.message);</span>
  <span class="s2">}</span>
  <span class="s2">debug ? request.pendingDebugChunks++ : request.pendingChunks++;</span>
  <span class="s2">typedArray = </span><span class="s4">new </span><span class="s2">Uint8Array(</span>
    <span class="s2">typedArray.buffer,</span>
    <span class="s2">typedArray.byteOffset,</span>
    <span class="s2">typedArray.byteLength</span>
  <span class="s2">);</span>
  <span class="s2">debug = typedArray.byteLength;</span>
  <span class="s2">id = id.toString(</span><span class="s5">16</span><span class="s2">) + </span><span class="s3">&quot;:&quot; </span><span class="s2">+ tag + debug.toString(</span><span class="s5">16</span><span class="s2">) + </span><span class="s3">&quot;,&quot;</span><span class="s2">;</span>
  <span class="s2">request.completedRegularChunks.push(id, typedArray);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">emitTextChunk(request, id, text, debug) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== byteLengthOfChunk)</span>
    <span class="s4">throw </span><span class="s2">Error(</span>
      <span class="s3">&quot;Existence of byteLengthOfChunk should have already been checked. This is a bug in React.&quot;</span>
    <span class="s2">);</span>
  <span class="s2">debug ? request.pendingDebugChunks++ : request.pendingChunks++;</span>
  <span class="s2">debug = byteLengthOfChunk(text);</span>
  <span class="s2">id = id.toString(</span><span class="s5">16</span><span class="s2">) + </span><span class="s3">&quot;:T&quot; </span><span class="s2">+ debug.toString(</span><span class="s5">16</span><span class="s2">) + </span><span class="s3">&quot;,&quot;</span><span class="s2">;</span>
  <span class="s2">request.completedRegularChunks.push(id, text);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">emitChunk(request, task, value) {</span>
  <span class="s4">var </span><span class="s2">id = task.id;</span>
  <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value &amp;&amp; </span><span class="s4">null </span><span class="s2">!== byteLengthOfChunk</span>
    <span class="s2">? ((task = TaintRegistryValues.get(value)),</span>
      <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== task &amp;&amp; throwTaintViolation(task.message),</span>
      <span class="s2">emitTextChunk(request, id, value, !</span><span class="s5">1</span><span class="s2">))</span>
    <span class="s2">: value </span><span class="s4">instanceof </span><span class="s2">ArrayBuffer</span>
      <span class="s2">? emitTypedArrayChunk(request, id, </span><span class="s3">&quot;A&quot;</span><span class="s2">, </span><span class="s4">new </span><span class="s2">Uint8Array(value), !</span><span class="s5">1</span><span class="s2">)</span>
      <span class="s2">: value </span><span class="s4">instanceof </span><span class="s2">Int8Array</span>
        <span class="s2">? emitTypedArrayChunk(request, id, </span><span class="s3">&quot;O&quot;</span><span class="s2">, value, !</span><span class="s5">1</span><span class="s2">)</span>
        <span class="s2">: value </span><span class="s4">instanceof </span><span class="s2">Uint8Array</span>
          <span class="s2">? emitTypedArrayChunk(request, id, </span><span class="s3">&quot;o&quot;</span><span class="s2">, value, !</span><span class="s5">1</span><span class="s2">)</span>
          <span class="s2">: value </span><span class="s4">instanceof </span><span class="s2">Uint8ClampedArray</span>
            <span class="s2">? emitTypedArrayChunk(request, id, </span><span class="s3">&quot;U&quot;</span><span class="s2">, value, !</span><span class="s5">1</span><span class="s2">)</span>
            <span class="s2">: value </span><span class="s4">instanceof </span><span class="s2">Int16Array</span>
              <span class="s2">? emitTypedArrayChunk(request, id, </span><span class="s3">&quot;S&quot;</span><span class="s2">, value, !</span><span class="s5">1</span><span class="s2">)</span>
              <span class="s2">: value </span><span class="s4">instanceof </span><span class="s2">Uint16Array</span>
                <span class="s2">? emitTypedArrayChunk(request, id, </span><span class="s3">&quot;s&quot;</span><span class="s2">, value, !</span><span class="s5">1</span><span class="s2">)</span>
                <span class="s2">: value </span><span class="s4">instanceof </span><span class="s2">Int32Array</span>
                  <span class="s2">? emitTypedArrayChunk(request, id, </span><span class="s3">&quot;L&quot;</span><span class="s2">, value, !</span><span class="s5">1</span><span class="s2">)</span>
                  <span class="s2">: value </span><span class="s4">instanceof </span><span class="s2">Uint32Array</span>
                    <span class="s2">? emitTypedArrayChunk(request, id, </span><span class="s3">&quot;l&quot;</span><span class="s2">, value, !</span><span class="s5">1</span><span class="s2">)</span>
                    <span class="s2">: value </span><span class="s4">instanceof </span><span class="s2">Float32Array</span>
                      <span class="s2">? emitTypedArrayChunk(request, id, </span><span class="s3">&quot;G&quot;</span><span class="s2">, value, !</span><span class="s5">1</span><span class="s2">)</span>
                      <span class="s2">: value </span><span class="s4">instanceof </span><span class="s2">Float64Array</span>
                        <span class="s2">? emitTypedArrayChunk(request, id, </span><span class="s3">&quot;g&quot;</span><span class="s2">, value, !</span><span class="s5">1</span><span class="s2">)</span>
                        <span class="s2">: value </span><span class="s4">instanceof </span><span class="s2">BigInt64Array</span>
                          <span class="s2">? emitTypedArrayChunk(request, id, </span><span class="s3">&quot;M&quot;</span><span class="s2">, value, !</span><span class="s5">1</span><span class="s2">)</span>
                          <span class="s2">: value </span><span class="s4">instanceof </span><span class="s2">BigUint64Array</span>
                            <span class="s2">? emitTypedArrayChunk(request, id, </span><span class="s3">&quot;m&quot;</span><span class="s2">, value, !</span><span class="s5">1</span><span class="s2">)</span>
                            <span class="s2">: value </span><span class="s4">instanceof </span><span class="s2">DataView</span>
                              <span class="s2">? emitTypedArrayChunk(request, id, </span><span class="s3">&quot;V&quot;</span><span class="s2">, value, !</span><span class="s5">1</span><span class="s2">)</span>
                              <span class="s2">: ((value = stringify(value, task.toJSON)),</span>
                                <span class="s2">(task =</span>
                                  <span class="s2">task.id.toString(</span><span class="s5">16</span><span class="s2">) + </span><span class="s3">&quot;:&quot; </span><span class="s2">+ value + </span><span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">),</span>
                                <span class="s2">request.completedRegularChunks.push(task));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">erroredTask(request, task, error) {</span>
  <span class="s2">task.status = </span><span class="s5">4</span><span class="s2">;</span>
  <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">error &amp;&amp;</span>
  <span class="s4">null </span><span class="s2">!== error &amp;&amp;</span>
  <span class="s2">error.$$typeof === REACT_POSTPONE_TYPE</span>
    <span class="s2">? (logPostpone(request, error.message, task),</span>
      <span class="s2">emitPostponeChunk(request, task.id))</span>
    <span class="s2">: ((error = logRecoverableError(request, error, task)),</span>
      <span class="s2">emitErrorChunk(request, task.id, error));</span>
  <span class="s2">request.abortableTasks.delete(task);</span>
  <span class="s2">callOnAllReadyIfReady(request);</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">emptyRoot = {};</span>
<span class="s4">function </span><span class="s2">retryTask(request, task) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">=== task.status) {</span>
    <span class="s2">task.status = </span><span class="s5">5</span><span class="s2">;</span>
    <span class="s4">var </span><span class="s2">parentSerializedSize = serializedSize;</span>
    <span class="s4">try </span><span class="s2">{</span>
      <span class="s2">modelRoot = task.model;</span>
      <span class="s4">var </span><span class="s2">resolvedModel = renderModelDestructive(</span>
        <span class="s2">request,</span>
        <span class="s2">task,</span>
        <span class="s2">emptyRoot,</span>
        <span class="s3">&quot;&quot;</span><span class="s2">,</span>
        <span class="s2">task.model</span>
      <span class="s2">);</span>
      <span class="s2">modelRoot = resolvedModel;</span>
      <span class="s2">task.keyPath = </span><span class="s4">null</span><span class="s2">;</span>
      <span class="s2">task.implicitSlot = !</span><span class="s5">1</span><span class="s2">;</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">resolvedModel &amp;&amp; </span><span class="s4">null </span><span class="s2">!== resolvedModel)</span>
        <span class="s2">request.writtenObjects.set(resolvedModel, serializeByValueID(task.id)),</span>
          <span class="s2">emitChunk(request, task, resolvedModel);</span>
      <span class="s4">else </span><span class="s2">{</span>
        <span class="s4">var </span><span class="s2">json = stringify(resolvedModel),</span>
          <span class="s2">processedChunk = task.id.toString(</span><span class="s5">16</span><span class="s2">) + </span><span class="s3">&quot;:&quot; </span><span class="s2">+ json + </span><span class="s3">&quot;</span><span class="s6">\n</span><span class="s3">&quot;</span><span class="s2">;</span>
        <span class="s2">request.completedRegularChunks.push(processedChunk);</span>
      <span class="s2">}</span>
      <span class="s2">task.status = </span><span class="s5">1</span><span class="s2">;</span>
      <span class="s2">request.abortableTasks.delete(task);</span>
      <span class="s2">callOnAllReadyIfReady(request);</span>
    <span class="s2">} </span><span class="s4">catch </span><span class="s2">(thrownValue) {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s5">12 </span><span class="s2">=== request.status)</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s2">(request.abortableTasks.delete(task),</span>
          <span class="s2">(task.status = </span><span class="s5">0</span><span class="s2">),</span>
          <span class="s5">21 </span><span class="s2">=== request.type)</span>
        <span class="s2">)</span>
          <span class="s2">haltTask(task), finishHaltedTask(task, request);</span>
        <span class="s4">else </span><span class="s2">{</span>
          <span class="s4">var </span><span class="s2">errorId = request.fatalError;</span>
          <span class="s2">abortTask(task);</span>
          <span class="s2">finishAbortedTask(task, request, errorId);</span>
        <span class="s2">}</span>
      <span class="s4">else </span><span class="s2">{</span>
        <span class="s4">var </span><span class="s2">x =</span>
          <span class="s2">thrownValue === SuspenseException</span>
            <span class="s2">? getSuspendedThenable()</span>
            <span class="s2">: thrownValue;</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">x &amp;&amp;</span>
          <span class="s4">null </span><span class="s2">!== x &amp;&amp;</span>
          <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">x.then</span>
        <span class="s2">) {</span>
          <span class="s2">task.status = </span><span class="s5">0</span><span class="s2">;</span>
          <span class="s2">task.thenableState = getThenableStateAfterSuspending();</span>
          <span class="s4">var </span><span class="s2">ping = task.ping;</span>
          <span class="s2">x.then(ping, ping);</span>
        <span class="s2">} </span><span class="s4">else </span><span class="s2">erroredTask(request, task, x);</span>
      <span class="s2">}</span>
    <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
      <span class="s2">serializedSize = parentSerializedSize;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">tryStreamTask(request, task) {</span>
  <span class="s4">var </span><span class="s2">parentSerializedSize = serializedSize;</span>
  <span class="s4">try </span><span class="s2">{</span>
    <span class="s2">emitChunk(request, task, task.model);</span>
  <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
    <span class="s2">serializedSize = parentSerializedSize;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">performWork(request) {</span>
  <span class="s4">var </span><span class="s2">prevDispatcher = ReactSharedInternalsServer.H;</span>
  <span class="s2">ReactSharedInternalsServer.H = HooksDispatcher;</span>
  <span class="s4">var </span><span class="s2">prevRequest = currentRequest;</span>
  <span class="s2">currentRequest$1 = currentRequest = request;</span>
  <span class="s4">try </span><span class="s2">{</span>
    <span class="s4">var </span><span class="s2">pingedTasks = request.pingedTasks;</span>
    <span class="s2">request.pingedTasks = [];</span>
    <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; pingedTasks.length; i++)</span>
      <span class="s2">retryTask(request, pingedTasks[i]);</span>
    <span class="s2">flushCompletedChunks(request);</span>
  <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
    <span class="s2">logRecoverableError(request, error, </span><span class="s4">null</span><span class="s2">), fatalError(request, error);</span>
  <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
    <span class="s2">(ReactSharedInternalsServer.H = prevDispatcher),</span>
      <span class="s2">(currentRequest$1 = </span><span class="s4">null</span><span class="s2">),</span>
      <span class="s2">(currentRequest = prevRequest);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">abortTask(task) {</span>
  <span class="s5">0 </span><span class="s2">=== task.status &amp;&amp; (task.status = </span><span class="s5">3</span><span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">finishAbortedTask(task, request, errorId) {</span>
  <span class="s5">3 </span><span class="s2">=== task.status &amp;&amp;</span>
    <span class="s2">((errorId = serializeByValueID(errorId)),</span>
    <span class="s2">(task = encodeReferenceChunk(request, task.id, errorId)),</span>
    <span class="s2">request.completedErrorChunks.push(task));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">haltTask(task) {</span>
  <span class="s5">0 </span><span class="s2">=== task.status &amp;&amp; (task.status = </span><span class="s5">3</span><span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">finishHaltedTask(task, request) {</span>
  <span class="s5">3 </span><span class="s2">=== task.status &amp;&amp; request.pendingChunks--;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">flushCompletedChunks(request) {</span>
  <span class="s4">var </span><span class="s2">destination = request.destination;</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== destination) {</span>
    <span class="s2">currentView = </span><span class="s4">new </span><span class="s2">Uint8Array(</span><span class="s5">2048</span><span class="s2">);</span>
    <span class="s2">writtenBytes = </span><span class="s5">0</span><span class="s2">;</span>
    <span class="s2">destinationHasCapacity = !</span><span class="s5">0</span><span class="s2">;</span>
    <span class="s4">try </span><span class="s2">{</span>
      <span class="s4">for </span><span class="s2">(</span>
        <span class="s4">var </span><span class="s2">importsChunks = request.completedImportChunks, i = </span><span class="s5">0</span><span class="s2">;</span>
        <span class="s2">i &lt; importsChunks.length;</span>
        <span class="s2">i++</span>
      <span class="s2">)</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s2">(request.pendingChunks--,</span>
          <span class="s2">!writeChunkAndReturn(destination, importsChunks[i]))</span>
        <span class="s2">) {</span>
          <span class="s2">request.destination = </span><span class="s4">null</span><span class="s2">;</span>
          <span class="s2">i++;</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s2">}</span>
      <span class="s2">importsChunks.splice(</span><span class="s5">0</span><span class="s2">, i);</span>
      <span class="s4">var </span><span class="s2">hintChunks = request.completedHintChunks;</span>
      <span class="s4">for </span><span class="s2">(i = </span><span class="s5">0</span><span class="s2">; i &lt; hintChunks.length; i++)</span>
        <span class="s4">if </span><span class="s2">(!writeChunkAndReturn(destination, hintChunks[i])) {</span>
          <span class="s2">request.destination = </span><span class="s4">null</span><span class="s2">;</span>
          <span class="s2">i++;</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s2">}</span>
      <span class="s2">hintChunks.splice(</span><span class="s5">0</span><span class="s2">, i);</span>
      <span class="s4">var </span><span class="s2">regularChunks = request.completedRegularChunks;</span>
      <span class="s4">for </span><span class="s2">(i = </span><span class="s5">0</span><span class="s2">; i &lt; regularChunks.length; i++)</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s2">(request.pendingChunks--,</span>
          <span class="s2">!writeChunkAndReturn(destination, regularChunks[i]))</span>
        <span class="s2">) {</span>
          <span class="s2">request.destination = </span><span class="s4">null</span><span class="s2">;</span>
          <span class="s2">i++;</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s2">}</span>
      <span class="s2">regularChunks.splice(</span><span class="s5">0</span><span class="s2">, i);</span>
      <span class="s4">var </span><span class="s2">errorChunks = request.completedErrorChunks;</span>
      <span class="s4">for </span><span class="s2">(i = </span><span class="s5">0</span><span class="s2">; i &lt; errorChunks.length; i++)</span>
        <span class="s4">if </span><span class="s2">(</span>
          <span class="s2">(request.pendingChunks--,</span>
          <span class="s2">!writeChunkAndReturn(destination, errorChunks[i]))</span>
        <span class="s2">) {</span>
          <span class="s2">request.destination = </span><span class="s4">null</span><span class="s2">;</span>
          <span class="s2">i++;</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s2">}</span>
      <span class="s2">errorChunks.splice(</span><span class="s5">0</span><span class="s2">, i);</span>
    <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
      <span class="s2">(request.flushScheduled = !</span><span class="s5">1</span><span class="s2">),</span>
        <span class="s2">currentView &amp;&amp;</span>
          <span class="s5">0 </span><span class="s2">&lt; writtenBytes &amp;&amp;</span>
          <span class="s2">destination.write(currentView.subarray(</span><span class="s5">0</span><span class="s2">, writtenBytes)),</span>
        <span class="s2">(currentView = </span><span class="s4">null</span><span class="s2">),</span>
        <span class="s2">(writtenBytes = </span><span class="s5">0</span><span class="s2">),</span>
        <span class="s2">(destinationHasCapacity = !</span><span class="s5">0</span><span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">destination.flush &amp;&amp; destination.flush();</span>
  <span class="s2">}</span>
  <span class="s5">0 </span><span class="s2">=== request.pendingChunks &amp;&amp;</span>
    <span class="s2">(cleanupTaintQueue(request),</span>
    <span class="s5">12 </span><span class="s2">&gt; request.status &amp;&amp;</span>
      <span class="s2">request.cacheController.abort(</span>
        <span class="s2">Error(</span>
          <span class="s3">&quot;This render completed successfully. All cacheSignals are now aborted to allow clean up of any unused resources.&quot;</span>
        <span class="s2">)</span>
      <span class="s2">),</span>
    <span class="s4">null </span><span class="s2">!== request.destination &amp;&amp;</span>
      <span class="s2">((request.status = </span><span class="s5">14</span><span class="s2">),</span>
      <span class="s2">request.destination.end(),</span>
      <span class="s2">(request.destination = </span><span class="s4">null</span><span class="s2">)));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">startWork(request) {</span>
  <span class="s2">request.flushScheduled = </span><span class="s4">null </span><span class="s2">!== request.destination;</span>
  <span class="s2">scheduleMicrotask(</span><span class="s4">function </span><span class="s2">() {</span>
    <span class="s2">requestStorage.run(request, performWork, request);</span>
  <span class="s2">});</span>
  <span class="s2">setImmediate(</span><span class="s4">function </span><span class="s2">() {</span>
    <span class="s5">10 </span><span class="s2">=== request.status &amp;&amp; (request.status = </span><span class="s5">11</span><span class="s2">);</span>
  <span class="s2">});</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">enqueueFlush(request) {</span>
  <span class="s2">!</span><span class="s5">1 </span><span class="s2">=== request.flushScheduled &amp;&amp;</span>
    <span class="s5">0 </span><span class="s2">=== request.pingedTasks.length &amp;&amp;</span>
    <span class="s4">null </span><span class="s2">!== request.destination &amp;&amp;</span>
    <span class="s2">((request.flushScheduled = !</span><span class="s5">0</span><span class="s2">),</span>
    <span class="s2">setImmediate(</span><span class="s4">function </span><span class="s2">() {</span>
      <span class="s2">request.flushScheduled = !</span><span class="s5">1</span><span class="s2">;</span>
      <span class="s2">flushCompletedChunks(request);</span>
    <span class="s2">}));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">callOnAllReadyIfReady(request) {</span>
  <span class="s5">0 </span><span class="s2">=== request.abortableTasks.size &amp;&amp;</span>
    <span class="s2">((request = request.onAllReady), request());</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">startFlowing(request, destination) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s5">13 </span><span class="s2">=== request.status)</span>
    <span class="s2">(request.status = </span><span class="s5">14</span><span class="s2">), destination.destroy(request.fatalError);</span>
  <span class="s4">else if </span><span class="s2">(</span><span class="s5">14 </span><span class="s2">!== request.status &amp;&amp; </span><span class="s4">null </span><span class="s2">=== request.destination) {</span>
    <span class="s2">request.destination = destination;</span>
    <span class="s4">try </span><span class="s2">{</span>
      <span class="s2">flushCompletedChunks(request);</span>
    <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
      <span class="s2">logRecoverableError(request, error, </span><span class="s4">null</span><span class="s2">), fatalError(request, error);</span>
    <span class="s2">}</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">finishHalt(request, abortedTasks) {</span>
  <span class="s4">try </span><span class="s2">{</span>
    <span class="s2">abortedTasks.forEach(</span><span class="s4">function </span><span class="s2">(task) {</span>
      <span class="s4">return </span><span class="s2">finishHaltedTask(task, request);</span>
    <span class="s2">});</span>
    <span class="s4">var </span><span class="s2">onAllReady = request.onAllReady;</span>
    <span class="s2">onAllReady();</span>
    <span class="s2">flushCompletedChunks(request);</span>
  <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
    <span class="s2">logRecoverableError(request, error, </span><span class="s4">null</span><span class="s2">), fatalError(request, error);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">finishAbort(request, abortedTasks, errorId) {</span>
  <span class="s4">try </span><span class="s2">{</span>
    <span class="s2">abortedTasks.forEach(</span><span class="s4">function </span><span class="s2">(task) {</span>
      <span class="s4">return </span><span class="s2">finishAbortedTask(task, request, errorId);</span>
    <span class="s2">});</span>
    <span class="s4">var </span><span class="s2">onAllReady = request.onAllReady;</span>
    <span class="s2">onAllReady();</span>
    <span class="s2">flushCompletedChunks(request);</span>
  <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
    <span class="s2">logRecoverableError(request, error, </span><span class="s4">null</span><span class="s2">), fatalError(request, error);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">abort(request, reason) {</span>
  <span class="s4">if </span><span class="s2">(!(</span><span class="s5">11 </span><span class="s2">&lt; request.status))</span>
    <span class="s4">try </span><span class="s2">{</span>
      <span class="s2">request.status = </span><span class="s5">12</span><span class="s2">;</span>
      <span class="s2">request.cacheController.abort(reason);</span>
      <span class="s4">var </span><span class="s2">abortableTasks = request.abortableTasks;</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">&lt; abortableTasks.size)</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s5">21 </span><span class="s2">=== request.type)</span>
          <span class="s2">abortableTasks.forEach(</span><span class="s4">function </span><span class="s2">(task) {</span>
            <span class="s4">return </span><span class="s2">haltTask(task, request);</span>
          <span class="s2">}),</span>
            <span class="s2">setImmediate(</span><span class="s4">function </span><span class="s2">() {</span>
              <span class="s4">return </span><span class="s2">finishHalt(request, abortableTasks);</span>
            <span class="s2">});</span>
        <span class="s4">else if </span><span class="s2">(</span>
          <span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">reason &amp;&amp;</span>
          <span class="s4">null </span><span class="s2">!== reason &amp;&amp;</span>
          <span class="s2">reason.$$typeof === REACT_POSTPONE_TYPE</span>
        <span class="s2">) {</span>
          <span class="s2">logPostpone(request, reason.message, </span><span class="s4">null</span><span class="s2">);</span>
          <span class="s4">var </span><span class="s2">errorId = request.nextChunkId++;</span>
          <span class="s2">request.fatalError = errorId;</span>
          <span class="s2">request.pendingChunks++;</span>
          <span class="s2">emitPostponeChunk(request, errorId, reason);</span>
          <span class="s2">abortableTasks.forEach(</span><span class="s4">function </span><span class="s2">(task) {</span>
            <span class="s4">return </span><span class="s2">abortTask(task, request, errorId);</span>
          <span class="s2">});</span>
          <span class="s2">setImmediate(</span><span class="s4">function </span><span class="s2">() {</span>
            <span class="s4">return </span><span class="s2">finishAbort(request, abortableTasks, errorId);</span>
          <span class="s2">});</span>
        <span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
          <span class="s4">var </span><span class="s2">error =</span>
              <span class="s4">void </span><span class="s5">0 </span><span class="s2">=== reason</span>
                <span class="s2">? Error(</span>
                    <span class="s3">&quot;The render was aborted by the server without a reason.&quot;</span>
                  <span class="s2">)</span>
                <span class="s2">: </span><span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">reason &amp;&amp;</span>
                    <span class="s4">null </span><span class="s2">!== reason &amp;&amp;</span>
                    <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">reason.then</span>
                  <span class="s2">? Error(</span>
                      <span class="s3">&quot;The render was aborted by the server with a promise.&quot;</span>
                    <span class="s2">)</span>
                  <span class="s2">: reason,</span>
            <span class="s2">digest = logRecoverableError(request, error, </span><span class="s4">null</span><span class="s2">),</span>
            <span class="s2">errorId$26 = request.nextChunkId++;</span>
          <span class="s2">request.fatalError = errorId$26;</span>
          <span class="s2">request.pendingChunks++;</span>
          <span class="s2">emitErrorChunk(request, errorId$26, digest, error, !</span><span class="s5">1</span><span class="s2">);</span>
          <span class="s2">abortableTasks.forEach(</span><span class="s4">function </span><span class="s2">(task) {</span>
            <span class="s4">return </span><span class="s2">abortTask(task, request, errorId$26);</span>
          <span class="s2">});</span>
          <span class="s2">setImmediate(</span><span class="s4">function </span><span class="s2">() {</span>
            <span class="s4">return </span><span class="s2">finishAbort(request, abortableTasks, errorId$26);</span>
          <span class="s2">});</span>
        <span class="s2">}</span>
      <span class="s4">else </span><span class="s2">{</span>
        <span class="s4">var </span><span class="s2">onAllReady = request.onAllReady;</span>
        <span class="s2">onAllReady();</span>
        <span class="s2">flushCompletedChunks(request);</span>
      <span class="s2">}</span>
    <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error$27) {</span>
      <span class="s2">logRecoverableError(request, error$27, </span><span class="s4">null</span><span class="s2">),</span>
        <span class="s2">fatalError(request, error$27);</span>
    <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">resolveServerReference(bundlerConfig, id) {</span>
  <span class="s4">var </span><span class="s2">idx = id.lastIndexOf(</span><span class="s3">&quot;#&quot;</span><span class="s2">);</span>
  <span class="s2">bundlerConfig = id.slice(</span><span class="s5">0</span><span class="s2">, idx);</span>
  <span class="s2">id = id.slice(idx + </span><span class="s5">1</span><span class="s2">);</span>
  <span class="s4">return </span><span class="s2">{ specifier: bundlerConfig, name: id };</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">asyncModuleCache = </span><span class="s4">new </span><span class="s2">Map();</span>
<span class="s4">function </span><span class="s2">preloadModule(metadata) {</span>
  <span class="s4">var </span><span class="s2">existingPromise = asyncModuleCache.get(metadata.specifier);</span>
  <span class="s4">if </span><span class="s2">(existingPromise)</span>
    <span class="s4">return </span><span class="s3">&quot;fulfilled&quot; </span><span class="s2">=== existingPromise.status ? </span><span class="s4">null </span><span class="s2">: existingPromise;</span>
  <span class="s4">var </span><span class="s2">modulePromise = </span><span class="s4">import</span><span class="s2">(metadata.specifier);</span>
  <span class="s2">metadata.async &amp;&amp;</span>
    <span class="s2">(modulePromise = modulePromise.then(</span><span class="s4">function </span><span class="s2">(value) {</span>
      <span class="s4">return </span><span class="s2">value.default;</span>
    <span class="s2">}));</span>
  <span class="s2">modulePromise.then(</span>
    <span class="s4">function </span><span class="s2">(value) {</span>
      <span class="s4">var </span><span class="s2">fulfilledThenable = modulePromise;</span>
      <span class="s2">fulfilledThenable.status = </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">;</span>
      <span class="s2">fulfilledThenable.value = value;</span>
    <span class="s2">},</span>
    <span class="s4">function </span><span class="s2">(reason) {</span>
      <span class="s4">var </span><span class="s2">rejectedThenable = modulePromise;</span>
      <span class="s2">rejectedThenable.status = </span><span class="s3">&quot;rejected&quot;</span><span class="s2">;</span>
      <span class="s2">rejectedThenable.reason = reason;</span>
    <span class="s2">}</span>
  <span class="s2">);</span>
  <span class="s2">asyncModuleCache.set(metadata.specifier, modulePromise);</span>
  <span class="s4">return </span><span class="s2">modulePromise;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">requireModule(metadata) {</span>
  <span class="s4">var </span><span class="s2">moduleExports = asyncModuleCache.get(metadata.specifier);</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;fulfilled&quot; </span><span class="s2">=== moduleExports.status) moduleExports = moduleExports.value;</span>
  <span class="s4">else throw </span><span class="s2">moduleExports.reason;</span>
  <span class="s4">return </span><span class="s3">&quot;*&quot; </span><span class="s2">=== metadata.name</span>
    <span class="s2">? moduleExports</span>
    <span class="s2">: </span><span class="s3">&quot;&quot; </span><span class="s2">=== metadata.name</span>
      <span class="s2">? moduleExports.default</span>
      <span class="s2">: moduleExports[metadata.name];</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">Chunk(status, value, reason, response) {</span>
  <span class="s4">this</span><span class="s2">.status = status;</span>
  <span class="s4">this</span><span class="s2">.value = value;</span>
  <span class="s4">this</span><span class="s2">.reason = reason;</span>
  <span class="s4">this</span><span class="s2">._response = response;</span>
<span class="s2">}</span>
<span class="s2">Chunk.prototype = Object.create(Promise.prototype);</span>
<span class="s2">Chunk.prototype.then = </span><span class="s4">function </span><span class="s2">(resolve, reject) {</span>
  <span class="s4">switch </span><span class="s2">(</span><span class="s4">this</span><span class="s2">.status) {</span>
    <span class="s4">case </span><span class="s3">&quot;resolved_model&quot;</span><span class="s2">:</span>
      <span class="s2">initializeModelChunk(</span><span class="s4">this</span><span class="s2">);</span>
  <span class="s2">}</span>
  <span class="s4">switch </span><span class="s2">(</span><span class="s4">this</span><span class="s2">.status) {</span>
    <span class="s4">case </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">:</span>
      <span class="s2">resolve(</span><span class="s4">this</span><span class="s2">.value);</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">case </span><span class="s3">&quot;pending&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;blocked&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;cyclic&quot;</span><span class="s2">:</span>
      <span class="s2">resolve &amp;&amp;</span>
        <span class="s2">(</span><span class="s4">null </span><span class="s2">=== </span><span class="s4">this</span><span class="s2">.value &amp;&amp; (</span><span class="s4">this</span><span class="s2">.value = []), </span><span class="s4">this</span><span class="s2">.value.push(resolve));</span>
      <span class="s2">reject &amp;&amp;</span>
        <span class="s2">(</span><span class="s4">null </span><span class="s2">=== </span><span class="s4">this</span><span class="s2">.reason &amp;&amp; (</span><span class="s4">this</span><span class="s2">.reason = []), </span><span class="s4">this</span><span class="s2">.reason.push(reject));</span>
      <span class="s4">break</span><span class="s2">;</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s2">reject(</span><span class="s4">this</span><span class="s2">.reason);</span>
  <span class="s2">}</span>
<span class="s2">};</span>
<span class="s4">function </span><span class="s2">createPendingChunk(response) {</span>
  <span class="s4">return new </span><span class="s2">Chunk(</span><span class="s3">&quot;pending&quot;</span><span class="s2">, </span><span class="s4">null</span><span class="s2">, </span><span class="s4">null</span><span class="s2">, response);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">wakeChunk(listeners, value) {</span>
  <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; listeners.length; i++) (</span><span class="s5">0</span><span class="s2">, listeners[i])(value);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">triggerErrorOnChunk(chunk, error) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;pending&quot; </span><span class="s2">!== chunk.status &amp;&amp; </span><span class="s3">&quot;blocked&quot; </span><span class="s2">!== chunk.status)</span>
    <span class="s2">chunk.reason.error(error);</span>
  <span class="s4">else </span><span class="s2">{</span>
    <span class="s4">var </span><span class="s2">listeners = chunk.reason;</span>
    <span class="s2">chunk.status = </span><span class="s3">&quot;rejected&quot;</span><span class="s2">;</span>
    <span class="s2">chunk.reason = error;</span>
    <span class="s4">null </span><span class="s2">!== listeners &amp;&amp; wakeChunk(listeners, error);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">resolveModelChunk(chunk, value, id) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;pending&quot; </span><span class="s2">!== chunk.status)</span>
    <span class="s2">(chunk = chunk.reason),</span>
      <span class="s3">&quot;C&quot; </span><span class="s2">=== value[</span><span class="s5">0</span><span class="s2">]</span>
        <span class="s2">? chunk.close(</span><span class="s3">&quot;C&quot; </span><span class="s2">=== value ? </span><span class="s3">'&quot;$undefined&quot;' </span><span class="s2">: value.slice(</span><span class="s5">1</span><span class="s2">))</span>
        <span class="s2">: chunk.enqueueModel(value);</span>
  <span class="s4">else </span><span class="s2">{</span>
    <span class="s4">var </span><span class="s2">resolveListeners = chunk.value,</span>
      <span class="s2">rejectListeners = chunk.reason;</span>
    <span class="s2">chunk.status = </span><span class="s3">&quot;resolved_model&quot;</span><span class="s2">;</span>
    <span class="s2">chunk.value = value;</span>
    <span class="s2">chunk.reason = id;</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">!== resolveListeners)</span>
      <span class="s4">switch </span><span class="s2">((initializeModelChunk(chunk), chunk.status)) {</span>
        <span class="s4">case </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">:</span>
          <span class="s2">wakeChunk(resolveListeners, chunk.value);</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s3">&quot;pending&quot;</span><span class="s2">:</span>
        <span class="s4">case </span><span class="s3">&quot;blocked&quot;</span><span class="s2">:</span>
        <span class="s4">case </span><span class="s3">&quot;cyclic&quot;</span><span class="s2">:</span>
          <span class="s4">if </span><span class="s2">(chunk.value)</span>
            <span class="s4">for </span><span class="s2">(value = </span><span class="s5">0</span><span class="s2">; value &lt; resolveListeners.length; value++)</span>
              <span class="s2">chunk.value.push(resolveListeners[value]);</span>
          <span class="s4">else </span><span class="s2">chunk.value = resolveListeners;</span>
          <span class="s4">if </span><span class="s2">(chunk.reason) {</span>
            <span class="s4">if </span><span class="s2">(rejectListeners)</span>
              <span class="s4">for </span><span class="s2">(value = </span><span class="s5">0</span><span class="s2">; value &lt; rejectListeners.length; value++)</span>
                <span class="s2">chunk.reason.push(rejectListeners[value]);</span>
          <span class="s2">} </span><span class="s4">else </span><span class="s2">chunk.reason = rejectListeners;</span>
          <span class="s4">break</span><span class="s2">;</span>
        <span class="s4">case </span><span class="s3">&quot;rejected&quot;</span><span class="s2">:</span>
          <span class="s2">rejectListeners &amp;&amp; wakeChunk(rejectListeners, chunk.reason);</span>
      <span class="s2">}</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createResolvedIteratorResultChunk(response, value, done) {</span>
  <span class="s4">return new </span><span class="s2">Chunk(</span>
    <span class="s3">&quot;resolved_model&quot;</span><span class="s2">,</span>
    <span class="s2">(done ? </span><span class="s3">'{&quot;done&quot;:true,&quot;value&quot;:' </span><span class="s2">: </span><span class="s3">'{&quot;done&quot;:false,&quot;value&quot;:'</span><span class="s2">) + value + </span><span class="s3">&quot;}&quot;</span><span class="s2">,</span>
    <span class="s2">-</span><span class="s5">1</span><span class="s2">,</span>
    <span class="s2">response</span>
  <span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">resolveIteratorResultChunk(chunk, value, done) {</span>
  <span class="s2">resolveModelChunk(</span>
    <span class="s2">chunk,</span>
    <span class="s2">(done ? </span><span class="s3">'{&quot;done&quot;:true,&quot;value&quot;:' </span><span class="s2">: </span><span class="s3">'{&quot;done&quot;:false,&quot;value&quot;:'</span><span class="s2">) + value + </span><span class="s3">&quot;}&quot;</span><span class="s2">,</span>
    <span class="s2">-</span><span class="s5">1</span>
  <span class="s2">);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">loadServerReference$1(</span>
  <span class="s2">response,</span>
  <span class="s2">id,</span>
  <span class="s2">bound,</span>
  <span class="s2">parentChunk,</span>
  <span class="s2">parentObject,</span>
  <span class="s2">key</span>
<span class="s2">) {</span>
  <span class="s4">var </span><span class="s2">serverReference = resolveServerReference(response._bundlerConfig, id);</span>
  <span class="s2">id = preloadModule(serverReference);</span>
  <span class="s4">if </span><span class="s2">(bound)</span>
    <span class="s2">bound = Promise.all([bound, id]).then(</span><span class="s4">function </span><span class="s2">(_ref) {</span>
      <span class="s2">_ref = _ref[</span><span class="s5">0</span><span class="s2">];</span>
      <span class="s4">var </span><span class="s2">fn = requireModule(serverReference);</span>
      <span class="s4">return </span><span class="s2">fn.bind.apply(fn, [</span><span class="s4">null</span><span class="s2">].concat(_ref));</span>
    <span class="s2">});</span>
  <span class="s4">else if </span><span class="s2">(id)</span>
    <span class="s2">bound = Promise.resolve(id).then(</span><span class="s4">function </span><span class="s2">() {</span>
      <span class="s4">return </span><span class="s2">requireModule(serverReference);</span>
    <span class="s2">});</span>
  <span class="s4">else return </span><span class="s2">requireModule(serverReference);</span>
  <span class="s2">bound.then(</span>
    <span class="s2">createModelResolver(</span>
      <span class="s2">parentChunk,</span>
      <span class="s2">parentObject,</span>
      <span class="s2">key,</span>
      <span class="s2">!</span><span class="s5">1</span><span class="s2">,</span>
      <span class="s2">response,</span>
      <span class="s2">createModel,</span>
      <span class="s2">[]</span>
    <span class="s2">),</span>
    <span class="s2">createModelReject(parentChunk)</span>
  <span class="s2">);</span>
  <span class="s4">return null</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">reviveModel(response, parentObj, parentKey, value, reference) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value)</span>
    <span class="s4">return </span><span class="s2">parseModelString(response, parentObj, parentKey, value, reference);</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;object&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">value &amp;&amp; </span><span class="s4">null </span><span class="s2">!== value)</span>
    <span class="s4">if </span><span class="s2">(</span>
      <span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== reference &amp;&amp;</span>
        <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== response._temporaryReferences &amp;&amp;</span>
        <span class="s2">response._temporaryReferences.set(value, reference),</span>
      <span class="s2">Array.isArray(value))</span>
    <span class="s2">)</span>
      <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; value.length; i++)</span>
        <span class="s2">value[i] = reviveModel(</span>
          <span class="s2">response,</span>
          <span class="s2">value,</span>
          <span class="s3">&quot;&quot; </span><span class="s2">+ i,</span>
          <span class="s2">value[i],</span>
          <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== reference ? reference + </span><span class="s3">&quot;:&quot; </span><span class="s2">+ i : </span><span class="s4">void </span><span class="s5">0</span>
        <span class="s2">);</span>
    <span class="s4">else</span>
      <span class="s4">for </span><span class="s2">(i </span><span class="s4">in </span><span class="s2">value)</span>
        <span class="s2">hasOwnProperty.call(value, i) &amp;&amp;</span>
          <span class="s2">((parentObj =</span>
            <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== reference &amp;&amp; -</span><span class="s5">1 </span><span class="s2">=== i.indexOf(</span><span class="s3">&quot;:&quot;</span><span class="s2">)</span>
              <span class="s2">? reference + </span><span class="s3">&quot;:&quot; </span><span class="s2">+ i</span>
              <span class="s2">: </span><span class="s4">void </span><span class="s5">0</span><span class="s2">),</span>
          <span class="s2">(parentObj = reviveModel(response, value, i, value[i], parentObj)),</span>
          <span class="s4">void </span><span class="s5">0 </span><span class="s2">!== parentObj ? (value[i] = parentObj) : </span><span class="s4">delete </span><span class="s2">value[i]);</span>
  <span class="s4">return </span><span class="s2">value;</span>
<span class="s2">}</span>
<span class="s4">var </span><span class="s2">initializingChunk = </span><span class="s4">null</span><span class="s2">,</span>
  <span class="s2">initializingChunkBlockedModel = </span><span class="s4">null</span><span class="s2">;</span>
<span class="s4">function </span><span class="s2">initializeModelChunk(chunk) {</span>
  <span class="s4">var </span><span class="s2">prevChunk = initializingChunk,</span>
    <span class="s2">prevBlocked = initializingChunkBlockedModel;</span>
  <span class="s2">initializingChunk = chunk;</span>
  <span class="s2">initializingChunkBlockedModel = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">var </span><span class="s2">rootReference = -</span><span class="s5">1 </span><span class="s2">=== chunk.reason ? </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">: chunk.reason.toString(</span><span class="s5">16</span><span class="s2">),</span>
    <span class="s2">resolvedModel = chunk.value;</span>
  <span class="s2">chunk.status = </span><span class="s3">&quot;cyclic&quot;</span><span class="s2">;</span>
  <span class="s2">chunk.value = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">chunk.reason = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s4">try </span><span class="s2">{</span>
    <span class="s4">var </span><span class="s2">rawModel = JSON.parse(resolvedModel),</span>
      <span class="s2">value = reviveModel(</span>
        <span class="s2">chunk._response,</span>
        <span class="s2">{ </span><span class="s3">&quot;&quot;</span><span class="s2">: rawModel },</span>
        <span class="s3">&quot;&quot;</span><span class="s2">,</span>
        <span class="s2">rawModel,</span>
        <span class="s2">rootReference</span>
      <span class="s2">);</span>
    <span class="s4">if </span><span class="s2">(</span>
      <span class="s4">null </span><span class="s2">!== initializingChunkBlockedModel &amp;&amp;</span>
      <span class="s5">0 </span><span class="s2">&lt; initializingChunkBlockedModel.deps</span>
    <span class="s2">)</span>
      <span class="s2">(initializingChunkBlockedModel.value = value), (chunk.status = </span><span class="s3">&quot;blocked&quot;</span><span class="s2">);</span>
    <span class="s4">else </span><span class="s2">{</span>
      <span class="s4">var </span><span class="s2">resolveListeners = chunk.value;</span>
      <span class="s2">chunk.status = </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">;</span>
      <span class="s2">chunk.value = value;</span>
      <span class="s4">null </span><span class="s2">!== resolveListeners &amp;&amp; wakeChunk(resolveListeners, value);</span>
    <span class="s2">}</span>
  <span class="s2">} </span><span class="s4">catch </span><span class="s2">(error) {</span>
    <span class="s2">(chunk.status = </span><span class="s3">&quot;rejected&quot;</span><span class="s2">), (chunk.reason = error);</span>
  <span class="s2">} </span><span class="s4">finally </span><span class="s2">{</span>
    <span class="s2">(initializingChunk = prevChunk),</span>
      <span class="s2">(initializingChunkBlockedModel = prevBlocked);</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">reportGlobalError(response, error) {</span>
  <span class="s2">response._closed = !</span><span class="s5">0</span><span class="s2">;</span>
  <span class="s2">response._closedReason = error;</span>
  <span class="s2">response._chunks.forEach(</span><span class="s4">function </span><span class="s2">(chunk) {</span>
    <span class="s3">&quot;pending&quot; </span><span class="s2">=== chunk.status &amp;&amp; triggerErrorOnChunk(chunk, error);</span>
  <span class="s2">});</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getChunk(response, id) {</span>
  <span class="s4">var </span><span class="s2">chunks = response._chunks,</span>
    <span class="s2">chunk = chunks.get(id);</span>
  <span class="s2">chunk ||</span>
    <span class="s2">((chunk = response._formData.get(response._prefix + id)),</span>
    <span class="s2">(chunk =</span>
      <span class="s4">null </span><span class="s2">!= chunk</span>
        <span class="s2">? </span><span class="s4">new </span><span class="s2">Chunk(</span><span class="s3">&quot;resolved_model&quot;</span><span class="s2">, chunk, id, response)</span>
        <span class="s2">: response._closed</span>
          <span class="s2">? </span><span class="s4">new </span><span class="s2">Chunk(</span><span class="s3">&quot;rejected&quot;</span><span class="s2">, </span><span class="s4">null</span><span class="s2">, response._closedReason, response)</span>
          <span class="s2">: createPendingChunk(response)),</span>
    <span class="s2">chunks.set(id, chunk));</span>
  <span class="s4">return </span><span class="s2">chunk;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createModelResolver(</span>
  <span class="s2">chunk,</span>
  <span class="s2">parentObject,</span>
  <span class="s2">key,</span>
  <span class="s2">cyclic,</span>
  <span class="s2">response,</span>
  <span class="s2">map,</span>
  <span class="s2">path</span>
<span class="s2">) {</span>
  <span class="s4">if </span><span class="s2">(initializingChunkBlockedModel) {</span>
    <span class="s4">var </span><span class="s2">blocked = initializingChunkBlockedModel;</span>
    <span class="s2">cyclic || blocked.deps++;</span>
  <span class="s2">} </span><span class="s4">else</span>
    <span class="s2">blocked = initializingChunkBlockedModel = {</span>
      <span class="s2">deps: cyclic ? </span><span class="s5">0 </span><span class="s2">: </span><span class="s5">1</span><span class="s2">,</span>
      <span class="s2">value: </span><span class="s4">null</span>
    <span class="s2">};</span>
  <span class="s4">return function </span><span class="s2">(value) {</span>
    <span class="s4">for </span><span class="s2">(</span><span class="s4">var </span><span class="s2">i = </span><span class="s5">1</span><span class="s2">; i &lt; path.length; i++) value = value[path[i]];</span>
    <span class="s2">parentObject[key] = map(response, value);</span>
    <span class="s3">&quot;&quot; </span><span class="s2">=== key &amp;&amp; </span><span class="s4">null </span><span class="s2">=== blocked.value &amp;&amp; (blocked.value = parentObject[key]);</span>
    <span class="s2">blocked.deps--;</span>
    <span class="s5">0 </span><span class="s2">=== blocked.deps &amp;&amp;</span>
      <span class="s3">&quot;blocked&quot; </span><span class="s2">=== chunk.status &amp;&amp;</span>
      <span class="s2">((value = chunk.value),</span>
      <span class="s2">(chunk.status = </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">),</span>
      <span class="s2">(chunk.value = blocked.value),</span>
      <span class="s4">null </span><span class="s2">!== value &amp;&amp; wakeChunk(value, blocked.value));</span>
  <span class="s2">};</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createModelReject(chunk) {</span>
  <span class="s4">return function </span><span class="s2">(error) {</span>
    <span class="s4">return </span><span class="s2">triggerErrorOnChunk(chunk, error);</span>
  <span class="s2">};</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">getOutlinedModel(response, reference, parentObject, key, map) {</span>
  <span class="s2">reference = reference.split(</span><span class="s3">&quot;:&quot;</span><span class="s2">);</span>
  <span class="s4">var </span><span class="s2">id = parseInt(reference[</span><span class="s5">0</span><span class="s2">], </span><span class="s5">16</span><span class="s2">);</span>
  <span class="s2">id = getChunk(response, id);</span>
  <span class="s4">switch </span><span class="s2">(id.status) {</span>
    <span class="s4">case </span><span class="s3">&quot;resolved_model&quot;</span><span class="s2">:</span>
      <span class="s2">initializeModelChunk(id);</span>
  <span class="s2">}</span>
  <span class="s4">switch </span><span class="s2">(id.status) {</span>
    <span class="s4">case </span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">:</span>
      <span class="s2">parentObject = id.value;</span>
      <span class="s4">for </span><span class="s2">(key = </span><span class="s5">1</span><span class="s2">; key &lt; reference.length; key++)</span>
        <span class="s2">parentObject = parentObject[reference[key]];</span>
      <span class="s4">return </span><span class="s2">map(response, parentObject);</span>
    <span class="s4">case </span><span class="s3">&quot;pending&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;blocked&quot;</span><span class="s2">:</span>
    <span class="s4">case </span><span class="s3">&quot;cyclic&quot;</span><span class="s2">:</span>
      <span class="s4">var </span><span class="s2">parentChunk = initializingChunk;</span>
      <span class="s2">id.then(</span>
        <span class="s2">createModelResolver(</span>
          <span class="s2">parentChunk,</span>
          <span class="s2">parentObject,</span>
          <span class="s2">key,</span>
          <span class="s3">&quot;cyclic&quot; </span><span class="s2">=== id.status,</span>
          <span class="s2">response,</span>
          <span class="s2">map,</span>
          <span class="s2">reference</span>
        <span class="s2">),</span>
        <span class="s2">createModelReject(parentChunk)</span>
      <span class="s2">);</span>
      <span class="s4">return null</span><span class="s2">;</span>
    <span class="s4">default</span><span class="s2">:</span>
      <span class="s4">throw </span><span class="s2">id.reason;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createMap(response, model) {</span>
  <span class="s4">return new </span><span class="s2">Map(model);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createSet(response, model) {</span>
  <span class="s4">return new </span><span class="s2">Set(model);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">extractIterator(response, model) {</span>
  <span class="s4">return </span><span class="s2">model[Symbol.iterator]();</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createModel(response, model) {</span>
  <span class="s4">return </span><span class="s2">model;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">parseTypedArray(</span>
  <span class="s2">response,</span>
  <span class="s2">reference,</span>
  <span class="s2">constructor,</span>
  <span class="s2">bytesPerElement,</span>
  <span class="s2">parentObject,</span>
  <span class="s2">parentKey</span>
<span class="s2">) {</span>
  <span class="s2">reference = parseInt(reference.slice(</span><span class="s5">2</span><span class="s2">), </span><span class="s5">16</span><span class="s2">);</span>
  <span class="s2">reference = response._formData.get(response._prefix + reference);</span>
  <span class="s2">reference =</span>
    <span class="s2">constructor === ArrayBuffer</span>
      <span class="s2">? reference.arrayBuffer()</span>
      <span class="s2">: reference.arrayBuffer().then(</span><span class="s4">function </span><span class="s2">(buffer) {</span>
          <span class="s4">return new </span><span class="s2">constructor(buffer);</span>
        <span class="s2">});</span>
  <span class="s2">bytesPerElement = initializingChunk;</span>
  <span class="s2">reference.then(</span>
    <span class="s2">createModelResolver(</span>
      <span class="s2">bytesPerElement,</span>
      <span class="s2">parentObject,</span>
      <span class="s2">parentKey,</span>
      <span class="s2">!</span><span class="s5">1</span><span class="s2">,</span>
      <span class="s2">response,</span>
      <span class="s2">createModel,</span>
      <span class="s2">[]</span>
    <span class="s2">),</span>
    <span class="s2">createModelReject(bytesPerElement)</span>
  <span class="s2">);</span>
  <span class="s4">return null</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">resolveStream(response, id, stream, controller) {</span>
  <span class="s4">var </span><span class="s2">chunks = response._chunks;</span>
  <span class="s2">stream = </span><span class="s4">new </span><span class="s2">Chunk(</span><span class="s3">&quot;fulfilled&quot;</span><span class="s2">, stream, controller, response);</span>
  <span class="s2">chunks.set(id, stream);</span>
  <span class="s2">response = response._formData.getAll(response._prefix + id);</span>
  <span class="s4">for </span><span class="s2">(id = </span><span class="s5">0</span><span class="s2">; id &lt; response.length; id++)</span>
    <span class="s2">(chunks = response[id]),</span>
      <span class="s3">&quot;C&quot; </span><span class="s2">=== chunks[</span><span class="s5">0</span><span class="s2">]</span>
        <span class="s2">? controller.close(</span><span class="s3">&quot;C&quot; </span><span class="s2">=== chunks ? </span><span class="s3">'&quot;$undefined&quot;' </span><span class="s2">: chunks.slice(</span><span class="s5">1</span><span class="s2">))</span>
        <span class="s2">: controller.enqueueModel(chunks);</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">parseReadableStream(response, reference, type) {</span>
  <span class="s2">reference = parseInt(reference.slice(</span><span class="s5">2</span><span class="s2">), </span><span class="s5">16</span><span class="s2">);</span>
  <span class="s4">var </span><span class="s2">controller = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">type = </span><span class="s4">new </span><span class="s2">ReadableStream({</span>
    <span class="s2">type: type,</span>
    <span class="s2">start: </span><span class="s4">function </span><span class="s2">(c) {</span>
      <span class="s2">controller = c;</span>
    <span class="s2">}</span>
  <span class="s2">});</span>
  <span class="s4">var </span><span class="s2">previousBlockedChunk = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">resolveStream(response, reference, type, {</span>
    <span class="s2">enqueueModel: </span><span class="s4">function </span><span class="s2">(json) {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== previousBlockedChunk) {</span>
        <span class="s4">var </span><span class="s2">chunk = </span><span class="s4">new </span><span class="s2">Chunk(</span><span class="s3">&quot;resolved_model&quot;</span><span class="s2">, json, -</span><span class="s5">1</span><span class="s2">, response);</span>
        <span class="s2">initializeModelChunk(chunk);</span>
        <span class="s3">&quot;fulfilled&quot; </span><span class="s2">=== chunk.status</span>
          <span class="s2">? controller.enqueue(chunk.value)</span>
          <span class="s2">: (chunk.then(</span>
              <span class="s4">function </span><span class="s2">(v) {</span>
                <span class="s4">return </span><span class="s2">controller.enqueue(v);</span>
              <span class="s2">},</span>
              <span class="s4">function </span><span class="s2">(e) {</span>
                <span class="s4">return </span><span class="s2">controller.error(e);</span>
              <span class="s2">}</span>
            <span class="s2">),</span>
            <span class="s2">(previousBlockedChunk = chunk));</span>
      <span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
        <span class="s2">chunk = previousBlockedChunk;</span>
        <span class="s4">var </span><span class="s2">chunk$30 = createPendingChunk(response);</span>
        <span class="s2">chunk$30.then(</span>
          <span class="s4">function </span><span class="s2">(v) {</span>
            <span class="s4">return </span><span class="s2">controller.enqueue(v);</span>
          <span class="s2">},</span>
          <span class="s4">function </span><span class="s2">(e) {</span>
            <span class="s4">return </span><span class="s2">controller.error(e);</span>
          <span class="s2">}</span>
        <span class="s2">);</span>
        <span class="s2">previousBlockedChunk = chunk$30;</span>
        <span class="s2">chunk.then(</span><span class="s4">function </span><span class="s2">() {</span>
          <span class="s2">previousBlockedChunk === chunk$30 &amp;&amp; (previousBlockedChunk = </span><span class="s4">null</span><span class="s2">);</span>
          <span class="s2">resolveModelChunk(chunk$30, json, -</span><span class="s5">1</span><span class="s2">);</span>
        <span class="s2">});</span>
      <span class="s2">}</span>
    <span class="s2">},</span>
    <span class="s2">close: </span><span class="s4">function </span><span class="s2">() {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== previousBlockedChunk) controller.close();</span>
      <span class="s4">else </span><span class="s2">{</span>
        <span class="s4">var </span><span class="s2">blockedChunk = previousBlockedChunk;</span>
        <span class="s2">previousBlockedChunk = </span><span class="s4">null</span><span class="s2">;</span>
        <span class="s2">blockedChunk.then(</span><span class="s4">function </span><span class="s2">() {</span>
          <span class="s4">return </span><span class="s2">controller.close();</span>
        <span class="s2">});</span>
      <span class="s2">}</span>
    <span class="s2">},</span>
    <span class="s2">error: </span><span class="s4">function </span><span class="s2">(error) {</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== previousBlockedChunk) controller.error(error);</span>
      <span class="s4">else </span><span class="s2">{</span>
        <span class="s4">var </span><span class="s2">blockedChunk = previousBlockedChunk;</span>
        <span class="s2">previousBlockedChunk = </span><span class="s4">null</span><span class="s2">;</span>
        <span class="s2">blockedChunk.then(</span><span class="s4">function </span><span class="s2">() {</span>
          <span class="s4">return </span><span class="s2">controller.error(error);</span>
        <span class="s2">});</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
  <span class="s2">});</span>
  <span class="s4">return </span><span class="s2">type;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">asyncIterator() {</span>
  <span class="s4">return this</span><span class="s2">;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createIterator(next) {</span>
  <span class="s2">next = { next: next };</span>
  <span class="s2">next[ASYNC_ITERATOR] = asyncIterator;</span>
  <span class="s4">return </span><span class="s2">next;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">parseAsyncIterable(response, reference, iterator) {</span>
  <span class="s2">reference = parseInt(reference.slice(</span><span class="s5">2</span><span class="s2">), </span><span class="s5">16</span><span class="s2">);</span>
  <span class="s4">var </span><span class="s2">buffer = [],</span>
    <span class="s2">closed = !</span><span class="s5">1</span><span class="s2">,</span>
    <span class="s2">nextWriteIndex = </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">$jscomp$compprop2 = {};</span>
  <span class="s2">$jscomp$compprop2 =</span>
    <span class="s2">(($jscomp$compprop2[ASYNC_ITERATOR] = </span><span class="s4">function </span><span class="s2">() {</span>
      <span class="s4">var </span><span class="s2">nextReadIndex = </span><span class="s5">0</span><span class="s2">;</span>
      <span class="s4">return </span><span class="s2">createIterator(</span><span class="s4">function </span><span class="s2">(arg) {</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== arg)</span>
          <span class="s4">throw </span><span class="s2">Error(</span>
            <span class="s3">&quot;Values cannot be passed to next() of AsyncIterables passed to Client Components.&quot;</span>
          <span class="s2">);</span>
        <span class="s4">if </span><span class="s2">(nextReadIndex === buffer.length) {</span>
          <span class="s4">if </span><span class="s2">(closed)</span>
            <span class="s4">return new </span><span class="s2">Chunk(</span>
              <span class="s3">&quot;fulfilled&quot;</span><span class="s2">,</span>
              <span class="s2">{ done: !</span><span class="s5">0</span><span class="s2">, value: </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">},</span>
              <span class="s4">null</span><span class="s2">,</span>
              <span class="s2">response</span>
            <span class="s2">);</span>
          <span class="s2">buffer[nextReadIndex] = createPendingChunk(response);</span>
        <span class="s2">}</span>
        <span class="s4">return </span><span class="s2">buffer[nextReadIndex++];</span>
      <span class="s2">});</span>
    <span class="s2">}),</span>
    <span class="s2">$jscomp$compprop2);</span>
  <span class="s2">iterator = iterator ? $jscomp$compprop2[ASYNC_ITERATOR]() : $jscomp$compprop2;</span>
  <span class="s2">resolveStream(response, reference, iterator, {</span>
    <span class="s2">enqueueModel: </span><span class="s4">function </span><span class="s2">(value) {</span>
      <span class="s2">nextWriteIndex === buffer.length</span>
        <span class="s2">? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(</span>
            <span class="s2">response,</span>
            <span class="s2">value,</span>
            <span class="s2">!</span><span class="s5">1</span>
          <span class="s2">))</span>
        <span class="s2">: resolveIteratorResultChunk(buffer[nextWriteIndex], value, !</span><span class="s5">1</span><span class="s2">);</span>
      <span class="s2">nextWriteIndex++;</span>
    <span class="s2">},</span>
    <span class="s2">close: </span><span class="s4">function </span><span class="s2">(value) {</span>
      <span class="s2">closed = !</span><span class="s5">0</span><span class="s2">;</span>
      <span class="s2">nextWriteIndex === buffer.length</span>
        <span class="s2">? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(</span>
            <span class="s2">response,</span>
            <span class="s2">value,</span>
            <span class="s2">!</span><span class="s5">0</span>
          <span class="s2">))</span>
        <span class="s2">: resolveIteratorResultChunk(buffer[nextWriteIndex], value, !</span><span class="s5">0</span><span class="s2">);</span>
      <span class="s4">for </span><span class="s2">(nextWriteIndex++; nextWriteIndex &lt; buffer.length; )</span>
        <span class="s2">resolveIteratorResultChunk(</span>
          <span class="s2">buffer[nextWriteIndex++],</span>
          <span class="s3">'&quot;$undefined&quot;'</span><span class="s2">,</span>
          <span class="s2">!</span><span class="s5">0</span>
        <span class="s2">);</span>
    <span class="s2">},</span>
    <span class="s2">error: </span><span class="s4">function </span><span class="s2">(error) {</span>
      <span class="s2">closed = !</span><span class="s5">0</span><span class="s2">;</span>
      <span class="s4">for </span><span class="s2">(</span>
        <span class="s2">nextWriteIndex === buffer.length &amp;&amp;</span>
        <span class="s2">(buffer[nextWriteIndex] = createPendingChunk(response));</span>
        <span class="s2">nextWriteIndex &lt; buffer.length;</span>

      <span class="s2">)</span>
        <span class="s2">triggerErrorOnChunk(buffer[nextWriteIndex++], error);</span>
    <span class="s2">}</span>
  <span class="s2">});</span>
  <span class="s4">return </span><span class="s2">iterator;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">parseModelString(response, obj, key, value, reference) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;$&quot; </span><span class="s2">=== value[</span><span class="s5">0</span><span class="s2">]) {</span>
    <span class="s4">switch </span><span class="s2">(value[</span><span class="s5">1</span><span class="s2">]) {</span>
      <span class="s4">case </span><span class="s3">&quot;$&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">value.slice(</span><span class="s5">1</span><span class="s2">);</span>
      <span class="s4">case </span><span class="s3">&quot;@&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">(obj = parseInt(value.slice(</span><span class="s5">2</span><span class="s2">), </span><span class="s5">16</span><span class="s2">)), getChunk(response, obj);</span>
      <span class="s4">case </span><span class="s3">&quot;F&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">(value = value.slice(</span><span class="s5">2</span><span class="s2">)),</span>
          <span class="s2">(value = getOutlinedModel(response, value, obj, key, createModel)),</span>
          <span class="s2">loadServerReference$1(</span>
            <span class="s2">response,</span>
            <span class="s2">value.id,</span>
            <span class="s2">value.bound,</span>
            <span class="s2">initializingChunk,</span>
            <span class="s2">obj,</span>
            <span class="s2">key</span>
          <span class="s2">)</span>
        <span class="s2">);</span>
      <span class="s4">case </span><span class="s3">&quot;T&quot;</span><span class="s2">:</span>
        <span class="s4">if </span><span class="s2">(</span><span class="s4">void </span><span class="s5">0 </span><span class="s2">=== reference || </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">=== response._temporaryReferences)</span>
          <span class="s4">throw </span><span class="s2">Error(</span>
            <span class="s3">&quot;Could not reference an opaque temporary reference. This is likely due to misconfiguring the temporaryReferences options on the server.&quot;</span>
          <span class="s2">);</span>
        <span class="s4">return </span><span class="s2">createTemporaryReference(</span>
          <span class="s2">response._temporaryReferences,</span>
          <span class="s2">reference</span>
        <span class="s2">);</span>
      <span class="s4">case </span><span class="s3">&quot;Q&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">(value = value.slice(</span><span class="s5">2</span><span class="s2">)),</span>
          <span class="s2">getOutlinedModel(response, value, obj, key, createMap)</span>
        <span class="s2">);</span>
      <span class="s4">case </span><span class="s3">&quot;W&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">(value = value.slice(</span><span class="s5">2</span><span class="s2">)),</span>
          <span class="s2">getOutlinedModel(response, value, obj, key, createSet)</span>
        <span class="s2">);</span>
      <span class="s4">case </span><span class="s3">&quot;K&quot;</span><span class="s2">:</span>
        <span class="s2">obj = value.slice(</span><span class="s5">2</span><span class="s2">);</span>
        <span class="s4">var </span><span class="s2">formPrefix = response._prefix + obj + </span><span class="s3">&quot;_&quot;</span><span class="s2">,</span>
          <span class="s2">data = </span><span class="s4">new </span><span class="s2">FormData();</span>
        <span class="s2">response._formData.forEach(</span><span class="s4">function </span><span class="s2">(entry, entryKey) {</span>
          <span class="s2">entryKey.startsWith(formPrefix) &amp;&amp;</span>
            <span class="s2">data.append(entryKey.slice(formPrefix.length), entry);</span>
        <span class="s2">});</span>
        <span class="s4">return </span><span class="s2">data;</span>
      <span class="s4">case </span><span class="s3">&quot;i&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">(value = value.slice(</span><span class="s5">2</span><span class="s2">)),</span>
          <span class="s2">getOutlinedModel(response, value, obj, key, extractIterator)</span>
        <span class="s2">);</span>
      <span class="s4">case </span><span class="s3">&quot;I&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">Infinity;</span>
      <span class="s4">case </span><span class="s3">&quot;-&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s3">&quot;$-0&quot; </span><span class="s2">=== value ? -</span><span class="s5">0 </span><span class="s2">: -Infinity;</span>
      <span class="s4">case </span><span class="s3">&quot;N&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">NaN;</span>
      <span class="s4">case </span><span class="s3">&quot;u&quot;</span><span class="s2">:</span>
        <span class="s4">return</span><span class="s2">;</span>
      <span class="s4">case </span><span class="s3">&quot;D&quot;</span><span class="s2">:</span>
        <span class="s4">return new </span><span class="s2">Date(Date.parse(value.slice(</span><span class="s5">2</span><span class="s2">)));</span>
      <span class="s4">case </span><span class="s3">&quot;n&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">BigInt(value.slice(</span><span class="s5">2</span><span class="s2">));</span>
    <span class="s2">}</span>
    <span class="s4">switch </span><span class="s2">(value[</span><span class="s5">1</span><span class="s2">]) {</span>
      <span class="s4">case </span><span class="s3">&quot;A&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">parseTypedArray(response, value, ArrayBuffer, </span><span class="s5">1</span><span class="s2">, obj, key);</span>
      <span class="s4">case </span><span class="s3">&quot;O&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">parseTypedArray(response, value, Int8Array, </span><span class="s5">1</span><span class="s2">, obj, key);</span>
      <span class="s4">case </span><span class="s3">&quot;o&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">parseTypedArray(response, value, Uint8Array, </span><span class="s5">1</span><span class="s2">, obj, key);</span>
      <span class="s4">case </span><span class="s3">&quot;U&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">parseTypedArray(response, value, Uint8ClampedArray, </span><span class="s5">1</span><span class="s2">, obj, key);</span>
      <span class="s4">case </span><span class="s3">&quot;S&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">parseTypedArray(response, value, Int16Array, </span><span class="s5">2</span><span class="s2">, obj, key);</span>
      <span class="s4">case </span><span class="s3">&quot;s&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">parseTypedArray(response, value, Uint16Array, </span><span class="s5">2</span><span class="s2">, obj, key);</span>
      <span class="s4">case </span><span class="s3">&quot;L&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">parseTypedArray(response, value, Int32Array, </span><span class="s5">4</span><span class="s2">, obj, key);</span>
      <span class="s4">case </span><span class="s3">&quot;l&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">parseTypedArray(response, value, Uint32Array, </span><span class="s5">4</span><span class="s2">, obj, key);</span>
      <span class="s4">case </span><span class="s3">&quot;G&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">parseTypedArray(response, value, Float32Array, </span><span class="s5">4</span><span class="s2">, obj, key);</span>
      <span class="s4">case </span><span class="s3">&quot;g&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">parseTypedArray(response, value, Float64Array, </span><span class="s5">8</span><span class="s2">, obj, key);</span>
      <span class="s4">case </span><span class="s3">&quot;M&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">parseTypedArray(response, value, BigInt64Array, </span><span class="s5">8</span><span class="s2">, obj, key);</span>
      <span class="s4">case </span><span class="s3">&quot;m&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">parseTypedArray(response, value, BigUint64Array, </span><span class="s5">8</span><span class="s2">, obj, key);</span>
      <span class="s4">case </span><span class="s3">&quot;V&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">parseTypedArray(response, value, DataView, </span><span class="s5">1</span><span class="s2">, obj, key);</span>
      <span class="s4">case </span><span class="s3">&quot;B&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">(</span>
          <span class="s2">(obj = parseInt(value.slice(</span><span class="s5">2</span><span class="s2">), </span><span class="s5">16</span><span class="s2">)),</span>
          <span class="s2">response._formData.get(response._prefix + obj)</span>
        <span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s4">switch </span><span class="s2">(value[</span><span class="s5">1</span><span class="s2">]) {</span>
      <span class="s4">case </span><span class="s3">&quot;R&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">parseReadableStream(response, value, </span><span class="s4">void </span><span class="s5">0</span><span class="s2">);</span>
      <span class="s4">case </span><span class="s3">&quot;r&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">parseReadableStream(response, value, </span><span class="s3">&quot;bytes&quot;</span><span class="s2">);</span>
      <span class="s4">case </span><span class="s3">&quot;X&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">parseAsyncIterable(response, value, !</span><span class="s5">1</span><span class="s2">);</span>
      <span class="s4">case </span><span class="s3">&quot;x&quot;</span><span class="s2">:</span>
        <span class="s4">return </span><span class="s2">parseAsyncIterable(response, value, !</span><span class="s5">0</span><span class="s2">);</span>
    <span class="s2">}</span>
    <span class="s2">value = value.slice(</span><span class="s5">1</span><span class="s2">);</span>
    <span class="s4">return </span><span class="s2">getOutlinedModel(response, value, obj, key, createModel);</span>
  <span class="s2">}</span>
  <span class="s4">return </span><span class="s2">value;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createResponse(bundlerConfig, formFieldPrefix, temporaryReferences) {</span>
  <span class="s4">var </span><span class="s2">backingFormData =</span>
      <span class="s5">3 </span><span class="s2">&lt; arguments.length &amp;&amp; </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">!== arguments[</span><span class="s5">3</span><span class="s2">]</span>
        <span class="s2">? arguments[</span><span class="s5">3</span><span class="s2">]</span>
        <span class="s2">: </span><span class="s4">new </span><span class="s2">FormData(),</span>
    <span class="s2">chunks = </span><span class="s4">new </span><span class="s2">Map();</span>
  <span class="s4">return </span><span class="s2">{</span>
    <span class="s2">_bundlerConfig: bundlerConfig,</span>
    <span class="s2">_prefix: formFieldPrefix,</span>
    <span class="s2">_formData: backingFormData,</span>
    <span class="s2">_chunks: chunks,</span>
    <span class="s2">_closed: !</span><span class="s5">1</span><span class="s2">,</span>
    <span class="s2">_closedReason: </span><span class="s4">null</span><span class="s2">,</span>
    <span class="s2">_temporaryReferences: temporaryReferences</span>
  <span class="s2">};</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">resolveField(response, key, value) {</span>
  <span class="s2">response._formData.append(key, value);</span>
  <span class="s4">var </span><span class="s2">prefix = response._prefix;</span>
  <span class="s2">key.startsWith(prefix) &amp;&amp;</span>
    <span class="s2">((response = response._chunks),</span>
    <span class="s2">(key = +key.slice(prefix.length)),</span>
    <span class="s2">(prefix = response.get(key)) &amp;&amp; resolveModelChunk(prefix, value, key));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">close(response) {</span>
  <span class="s2">reportGlobalError(response, Error(</span><span class="s3">&quot;Connection closed.&quot;</span><span class="s2">));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">loadServerReference(bundlerConfig, id, bound) {</span>
  <span class="s4">var </span><span class="s2">serverReference = resolveServerReference(bundlerConfig, id);</span>
  <span class="s2">bundlerConfig = preloadModule(serverReference);</span>
  <span class="s4">return </span><span class="s2">bound</span>
    <span class="s2">? Promise.all([bound, bundlerConfig]).then(</span><span class="s4">function </span><span class="s2">(_ref) {</span>
        <span class="s2">_ref = _ref[</span><span class="s5">0</span><span class="s2">];</span>
        <span class="s4">var </span><span class="s2">fn = requireModule(serverReference);</span>
        <span class="s4">return </span><span class="s2">fn.bind.apply(fn, [</span><span class="s4">null</span><span class="s2">].concat(_ref));</span>
      <span class="s2">})</span>
    <span class="s2">: bundlerConfig</span>
      <span class="s2">? Promise.resolve(bundlerConfig).then(</span><span class="s4">function </span><span class="s2">() {</span>
          <span class="s4">return </span><span class="s2">requireModule(serverReference);</span>
        <span class="s2">})</span>
      <span class="s2">: Promise.resolve(requireModule(serverReference));</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">decodeBoundActionMetaData(body, serverManifest, formFieldPrefix) {</span>
  <span class="s2">body = createResponse(serverManifest, formFieldPrefix, </span><span class="s4">void </span><span class="s5">0</span><span class="s2">, body);</span>
  <span class="s2">close(body);</span>
  <span class="s2">body = getChunk(body, </span><span class="s5">0</span><span class="s2">);</span>
  <span class="s2">body.then(</span><span class="s4">function </span><span class="s2">() {});</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;fulfilled&quot; </span><span class="s2">!== body.status) </span><span class="s4">throw </span><span class="s2">body.reason;</span>
  <span class="s4">return </span><span class="s2">body.value;</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createDrainHandler(destination, request) {</span>
  <span class="s4">return function </span><span class="s2">() {</span>
    <span class="s4">return </span><span class="s2">startFlowing(request, destination);</span>
  <span class="s2">};</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createCancelHandler(request, reason) {</span>
  <span class="s4">return function </span><span class="s2">() {</span>
    <span class="s2">request.destination = </span><span class="s4">null</span><span class="s2">;</span>
    <span class="s2">abort(request, Error(reason));</span>
  <span class="s2">};</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createFakeWritableFromReadableStreamController(controller) {</span>
  <span class="s4">return </span><span class="s2">{</span>
    <span class="s2">write: </span><span class="s4">function </span><span class="s2">(chunk) {</span>
      <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">chunk &amp;&amp; (chunk = textEncoder.encode(chunk));</span>
      <span class="s2">controller.enqueue(chunk);</span>
      <span class="s4">return </span><span class="s2">!</span><span class="s5">0</span><span class="s2">;</span>
    <span class="s2">},</span>
    <span class="s2">end: </span><span class="s4">function </span><span class="s2">() {</span>
      <span class="s2">controller.close();</span>
    <span class="s2">},</span>
    <span class="s2">destroy: </span><span class="s4">function </span><span class="s2">(error) {</span>
      <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">controller.error</span>
        <span class="s2">? controller.error(error)</span>
        <span class="s2">: controller.close();</span>
    <span class="s2">}</span>
  <span class="s2">};</span>
<span class="s2">}</span>
<span class="s4">function </span><span class="s2">createFakeWritableFromNodeReadable(readable) {</span>
  <span class="s4">return </span><span class="s2">{</span>
    <span class="s2">write: </span><span class="s4">function </span><span class="s2">(chunk) {</span>
      <span class="s4">return </span><span class="s2">readable.push(chunk);</span>
    <span class="s2">},</span>
    <span class="s2">end: </span><span class="s4">function </span><span class="s2">() {</span>
      <span class="s2">readable.push(</span><span class="s4">null</span><span class="s2">);</span>
    <span class="s2">},</span>
    <span class="s2">destroy: </span><span class="s4">function </span><span class="s2">(error) {</span>
      <span class="s2">readable.destroy(error);</span>
    <span class="s2">}</span>
  <span class="s2">};</span>
<span class="s2">}</span>
<span class="s2">exports.createClientModuleProxy = </span><span class="s4">function </span><span class="s2">(moduleId) {</span>
  <span class="s2">moduleId = registerClientReferenceImpl({}, moduleId, !</span><span class="s5">1</span><span class="s2">);</span>
  <span class="s4">return new </span><span class="s2">Proxy(moduleId, proxyHandlers$1);</span>
<span class="s2">};</span>
<span class="s2">exports.createTemporaryReferenceSet = </span><span class="s4">function </span><span class="s2">() {</span>
  <span class="s4">return new </span><span class="s2">WeakMap();</span>
<span class="s2">};</span>
<span class="s2">exports.decodeAction = </span><span class="s4">function </span><span class="s2">(body, serverManifest) {</span>
  <span class="s4">var </span><span class="s2">formData = </span><span class="s4">new </span><span class="s2">FormData(),</span>
    <span class="s2">action = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">body.forEach(</span><span class="s4">function </span><span class="s2">(value, key) {</span>
    <span class="s2">key.startsWith(</span><span class="s3">&quot;$ACTION_&quot;</span><span class="s2">)</span>
      <span class="s2">? key.startsWith(</span><span class="s3">&quot;$ACTION_REF_&quot;</span><span class="s2">)</span>
        <span class="s2">? ((value = </span><span class="s3">&quot;$ACTION_&quot; </span><span class="s2">+ key.slice(</span><span class="s5">12</span><span class="s2">) + </span><span class="s3">&quot;:&quot;</span><span class="s2">),</span>
          <span class="s2">(value = decodeBoundActionMetaData(body, serverManifest, value)),</span>
          <span class="s2">(action = loadServerReference(serverManifest, value.id, value.bound)))</span>
        <span class="s2">: key.startsWith(</span><span class="s3">&quot;$ACTION_ID_&quot;</span><span class="s2">) &amp;&amp;</span>
          <span class="s2">((value = key.slice(</span><span class="s5">11</span><span class="s2">)),</span>
          <span class="s2">(action = loadServerReference(serverManifest, value, </span><span class="s4">null</span><span class="s2">)))</span>
      <span class="s2">: formData.append(key, value);</span>
  <span class="s2">});</span>
  <span class="s4">return null </span><span class="s2">=== action</span>
    <span class="s2">? </span><span class="s4">null</span>
    <span class="s2">: action.then(</span><span class="s4">function </span><span class="s2">(fn) {</span>
        <span class="s4">return </span><span class="s2">fn.bind(</span><span class="s4">null</span><span class="s2">, formData);</span>
      <span class="s2">});</span>
<span class="s2">};</span>
<span class="s2">exports.decodeFormState = </span><span class="s4">function </span><span class="s2">(actionResult, body, serverManifest) {</span>
  <span class="s4">var </span><span class="s2">keyPath = body.get(</span><span class="s3">&quot;$ACTION_KEY&quot;</span><span class="s2">);</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">!== </span><span class="s4">typeof </span><span class="s2">keyPath) </span><span class="s4">return </span><span class="s2">Promise.resolve(</span><span class="s4">null</span><span class="s2">);</span>
  <span class="s4">var </span><span class="s2">metaData = </span><span class="s4">null</span><span class="s2">;</span>
  <span class="s2">body.forEach(</span><span class="s4">function </span><span class="s2">(value, key) {</span>
    <span class="s2">key.startsWith(</span><span class="s3">&quot;$ACTION_REF_&quot;</span><span class="s2">) &amp;&amp;</span>
      <span class="s2">((value = </span><span class="s3">&quot;$ACTION_&quot; </span><span class="s2">+ key.slice(</span><span class="s5">12</span><span class="s2">) + </span><span class="s3">&quot;:&quot;</span><span class="s2">),</span>
      <span class="s2">(metaData = decodeBoundActionMetaData(body, serverManifest, value)));</span>
  <span class="s2">});</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s4">null </span><span class="s2">=== metaData) </span><span class="s4">return </span><span class="s2">Promise.resolve(</span><span class="s4">null</span><span class="s2">);</span>
  <span class="s4">var </span><span class="s2">referenceId = metaData.id;</span>
  <span class="s4">return </span><span class="s2">Promise.resolve(metaData.bound).then(</span><span class="s4">function </span><span class="s2">(bound) {</span>
    <span class="s4">return null </span><span class="s2">=== bound</span>
      <span class="s2">? </span><span class="s4">null</span>
      <span class="s2">: [actionResult, keyPath, referenceId, bound.length - </span><span class="s5">1</span><span class="s2">];</span>
  <span class="s2">});</span>
<span class="s2">};</span>
<span class="s2">exports.decodeReply = </span><span class="s4">function </span><span class="s2">(body, webpackMap, options) {</span>
  <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">body) {</span>
    <span class="s4">var </span><span class="s2">form = </span><span class="s4">new </span><span class="s2">FormData();</span>
    <span class="s2">form.append(</span><span class="s3">&quot;0&quot;</span><span class="s2">, body);</span>
    <span class="s2">body = form;</span>
  <span class="s2">}</span>
  <span class="s2">body = createResponse(</span>
    <span class="s2">webpackMap,</span>
    <span class="s3">&quot;&quot;</span><span class="s2">,</span>
    <span class="s2">options ? options.temporaryReferences : </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">body</span>
  <span class="s2">);</span>
  <span class="s2">webpackMap = getChunk(body, </span><span class="s5">0</span><span class="s2">);</span>
  <span class="s2">close(body);</span>
  <span class="s4">return </span><span class="s2">webpackMap;</span>
<span class="s2">};</span>
<span class="s2">exports.decodeReplyFromAsyncIterable = </span><span class="s4">function </span><span class="s2">(</span>
  <span class="s2">iterable,</span>
  <span class="s2">webpackMap,</span>
  <span class="s2">options</span>
<span class="s2">) {</span>
  <span class="s4">function </span><span class="s2">progress(entry) {</span>
    <span class="s4">if </span><span class="s2">(entry.done) close(response);</span>
    <span class="s4">else </span><span class="s2">{</span>
      <span class="s4">var </span><span class="s2">_entry$value = entry.value;</span>
      <span class="s2">entry = _entry$value[</span><span class="s5">0</span><span class="s2">];</span>
      <span class="s2">_entry$value = _entry$value[</span><span class="s5">1</span><span class="s2">];</span>
      <span class="s3">&quot;string&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">_entry$value</span>
        <span class="s2">? resolveField(response, entry, _entry$value)</span>
        <span class="s2">: response._formData.append(entry, _entry$value);</span>
      <span class="s2">iterator.next().then(progress, error);</span>
    <span class="s2">}</span>
  <span class="s2">}</span>
  <span class="s4">function </span><span class="s2">error(reason) {</span>
    <span class="s2">reportGlobalError(response, reason);</span>
    <span class="s3">&quot;function&quot; </span><span class="s2">=== </span><span class="s4">typeof </span><span class="s2">iterator.throw &amp;&amp;</span>
      <span class="s2">iterator.throw(reason).then(error, error);</span>
  <span class="s2">}</span>
  <span class="s4">var </span><span class="s2">iterator = iterable[ASYNC_ITERATOR](),</span>
    <span class="s2">response = createResponse(</span>
      <span class="s2">webpackMap,</span>
      <span class="s3">&quot;&quot;</span><span class="s2">,</span>
      <span class="s2">options ? options.temporaryReferences : </span><span class="s4">void </span><span class="s5">0</span>
    <span class="s2">);</span>
  <span class="s2">iterator.next().then(progress, error);</span>
  <span class="s4">return </span><span class="s2">getChunk(response, </span><span class="s5">0</span><span class="s2">);</span>
<span class="s2">};</span>
<span class="s2">exports.decodeReplyFromBusboy = </span><span class="s4">function </span><span class="s2">(busboyStream, webpackMap, options) {</span>
  <span class="s4">var </span><span class="s2">response = createResponse(</span>
      <span class="s2">webpackMap,</span>
      <span class="s3">&quot;&quot;</span><span class="s2">,</span>
      <span class="s2">options ? options.temporaryReferences : </span><span class="s4">void </span><span class="s5">0</span>
    <span class="s2">),</span>
    <span class="s2">pendingFiles = </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">queuedFields = [];</span>
  <span class="s2">busboyStream.on(</span><span class="s3">&quot;field&quot;</span><span class="s2">, </span><span class="s4">function </span><span class="s2">(name, value) {</span>
    <span class="s5">0 </span><span class="s2">&lt; pendingFiles</span>
      <span class="s2">? queuedFields.push(name, value)</span>
      <span class="s2">: resolveField(response, name, value);</span>
  <span class="s2">});</span>
  <span class="s2">busboyStream.on(</span><span class="s3">&quot;file&quot;</span><span class="s2">, </span><span class="s4">function </span><span class="s2">(name, value, _ref2) {</span>
    <span class="s4">var </span><span class="s2">filename = _ref2.filename,</span>
      <span class="s2">mimeType = _ref2.mimeType;</span>
    <span class="s4">if </span><span class="s2">(</span><span class="s3">&quot;base64&quot; </span><span class="s2">=== _ref2.encoding.toLowerCase())</span>
      <span class="s4">throw </span><span class="s2">Error(</span>
        <span class="s3">&quot;React doesn't accept base64 encoded file uploads because we don't expect form data passed from a browser to ever encode data that way. If that's the wrong assumption, we can easily fix it.&quot;</span>
      <span class="s2">);</span>
    <span class="s2">pendingFiles++;</span>
    <span class="s4">var </span><span class="s2">JSCompiler_object_inline_chunks_272 = [];</span>
    <span class="s2">value.on(</span><span class="s3">&quot;data&quot;</span><span class="s2">, </span><span class="s4">function </span><span class="s2">(chunk) {</span>
      <span class="s2">JSCompiler_object_inline_chunks_272.push(chunk);</span>
    <span class="s2">});</span>
    <span class="s2">value.on(</span><span class="s3">&quot;end&quot;</span><span class="s2">, </span><span class="s4">function </span><span class="s2">() {</span>
      <span class="s4">var </span><span class="s2">blob = </span><span class="s4">new </span><span class="s2">Blob(JSCompiler_object_inline_chunks_272, {</span>
        <span class="s2">type: mimeType</span>
      <span class="s2">});</span>
      <span class="s2">response._formData.append(name, blob, filename);</span>
      <span class="s2">pendingFiles--;</span>
      <span class="s4">if </span><span class="s2">(</span><span class="s5">0 </span><span class="s2">=== pendingFiles) {</span>
        <span class="s4">for </span><span class="s2">(blob = </span><span class="s5">0</span><span class="s2">; blob &lt; queuedFields.length; blob += </span><span class="s5">2</span><span class="s2">)</span>
          <span class="s2">resolveField(response, queuedFields[blob], queuedFields[blob + </span><span class="s5">1</span><span class="s2">]);</span>
        <span class="s2">queuedFields.length = </span><span class="s5">0</span><span class="s2">;</span>
      <span class="s2">}</span>
    <span class="s2">});</span>
  <span class="s2">});</span>
  <span class="s2">busboyStream.on(</span><span class="s3">&quot;finish&quot;</span><span class="s2">, </span><span class="s4">function </span><span class="s2">() {</span>
    <span class="s2">close(response);</span>
  <span class="s2">});</span>
  <span class="s2">busboyStream.on(</span><span class="s3">&quot;error&quot;</span><span class="s2">, </span><span class="s4">function </span><span class="s2">(err) {</span>
    <span class="s2">reportGlobalError(response, err);</span>
  <span class="s2">});</span>
  <span class="s4">return </span><span class="s2">getChunk(response, </span><span class="s5">0</span><span class="s2">);</span>
<span class="s2">};</span>
<span class="s2">exports.registerClientReference = </span><span class="s4">function </span><span class="s2">(</span>
  <span class="s2">proxyImplementation,</span>
  <span class="s2">id,</span>
  <span class="s2">exportName</span>
<span class="s2">) {</span>
  <span class="s4">return </span><span class="s2">registerClientReferenceImpl(</span>
    <span class="s2">proxyImplementation,</span>
    <span class="s2">id + </span><span class="s3">&quot;#&quot; </span><span class="s2">+ exportName,</span>
    <span class="s2">!</span><span class="s5">1</span>
  <span class="s2">);</span>
<span class="s2">};</span>
<span class="s2">exports.registerServerReference = </span><span class="s4">function </span><span class="s2">(reference, id, exportName) {</span>
  <span class="s4">return </span><span class="s2">Object.defineProperties(reference, {</span>
    <span class="s2">$$typeof: { value: SERVER_REFERENCE_TAG },</span>
    <span class="s2">$$id: {</span>
      <span class="s2">value: </span><span class="s4">null </span><span class="s2">=== exportName ? id : id + </span><span class="s3">&quot;#&quot; </span><span class="s2">+ exportName,</span>
      <span class="s2">configurable: !</span><span class="s5">0</span>
    <span class="s2">},</span>
    <span class="s2">$$bound: { value: </span><span class="s4">null</span><span class="s2">, configurable: !</span><span class="s5">0 </span><span class="s2">},</span>
    <span class="s2">bind: { value: bind, configurable: !</span><span class="s5">0 </span><span class="s2">}</span>
  <span class="s2">});</span>
<span class="s2">};</span>
<span class="s2">exports.renderToPipeableStream = </span><span class="s4">function </span><span class="s2">(model, webpackMap, options) {</span>
  <span class="s4">var </span><span class="s2">request = </span><span class="s4">new </span><span class="s2">RequestInstance(</span>
      <span class="s5">20</span><span class="s2">,</span>
      <span class="s2">model,</span>
      <span class="s2">webpackMap,</span>
      <span class="s2">options ? options.onError : </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
      <span class="s2">options ? options.onPostpone : </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
      <span class="s2">noop,</span>
      <span class="s2">noop,</span>
      <span class="s2">options ? options.identifierPrefix : </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
      <span class="s2">options ? options.temporaryReferences : </span><span class="s4">void </span><span class="s5">0</span>
    <span class="s2">),</span>
    <span class="s2">hasStartedFlowing = !</span><span class="s5">1</span><span class="s2">;</span>
  <span class="s2">startWork(request);</span>
  <span class="s4">return </span><span class="s2">{</span>
    <span class="s2">pipe: </span><span class="s4">function </span><span class="s2">(destination) {</span>
      <span class="s4">if </span><span class="s2">(hasStartedFlowing)</span>
        <span class="s4">throw </span><span class="s2">Error(</span>
          <span class="s3">&quot;React currently only supports piping to one writable stream.&quot;</span>
        <span class="s2">);</span>
      <span class="s2">hasStartedFlowing = !</span><span class="s5">0</span><span class="s2">;</span>
      <span class="s2">startFlowing(request, destination);</span>
      <span class="s2">destination.on(</span><span class="s3">&quot;drain&quot;</span><span class="s2">, createDrainHandler(destination, request));</span>
      <span class="s2">destination.on(</span>
        <span class="s3">&quot;error&quot;</span><span class="s2">,</span>
        <span class="s2">createCancelHandler(</span>
          <span class="s2">request,</span>
          <span class="s3">&quot;The destination stream errored while writing data.&quot;</span>
        <span class="s2">)</span>
      <span class="s2">);</span>
      <span class="s2">destination.on(</span>
        <span class="s3">&quot;close&quot;</span><span class="s2">,</span>
        <span class="s2">createCancelHandler(request, </span><span class="s3">&quot;The destination stream closed early.&quot;</span><span class="s2">)</span>
      <span class="s2">);</span>
      <span class="s4">return </span><span class="s2">destination;</span>
    <span class="s2">},</span>
    <span class="s2">abort: </span><span class="s4">function </span><span class="s2">(reason) {</span>
      <span class="s2">abort(request, reason);</span>
    <span class="s2">}</span>
  <span class="s2">};</span>
<span class="s2">};</span>
<span class="s2">exports.renderToReadableStream = </span><span class="s4">function </span><span class="s2">(model, webpackMap, options) {</span>
  <span class="s4">var </span><span class="s2">request = </span><span class="s4">new </span><span class="s2">RequestInstance(</span>
    <span class="s5">20</span><span class="s2">,</span>
    <span class="s2">model,</span>
    <span class="s2">webpackMap,</span>
    <span class="s2">options ? options.onError : </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">options ? options.onPostpone : </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">noop,</span>
    <span class="s2">noop,</span>
    <span class="s2">options ? options.identifierPrefix : </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
    <span class="s2">options ? options.temporaryReferences : </span><span class="s4">void </span><span class="s5">0</span>
  <span class="s2">);</span>
  <span class="s4">if </span><span class="s2">(options &amp;&amp; options.signal) {</span>
    <span class="s4">var </span><span class="s2">signal = options.signal;</span>
    <span class="s4">if </span><span class="s2">(signal.aborted) abort(request, signal.reason);</span>
    <span class="s4">else </span><span class="s2">{</span>
      <span class="s4">var </span><span class="s2">listener = </span><span class="s4">function </span><span class="s2">() {</span>
        <span class="s2">abort(request, signal.reason);</span>
        <span class="s2">signal.removeEventListener(</span><span class="s3">&quot;abort&quot;</span><span class="s2">, listener);</span>
      <span class="s2">};</span>
      <span class="s2">signal.addEventListener(</span><span class="s3">&quot;abort&quot;</span><span class="s2">, listener);</span>
    <span class="s2">}</span>
  <span class="s2">}</span>
  <span class="s4">var </span><span class="s2">writable;</span>
  <span class="s4">return new </span><span class="s2">ReadableStream(</span>
    <span class="s2">{</span>
      <span class="s2">type: </span><span class="s3">&quot;bytes&quot;</span><span class="s2">,</span>
      <span class="s2">start: </span><span class="s4">function </span><span class="s2">(controller) {</span>
        <span class="s2">writable = createFakeWritableFromReadableStreamController(controller);</span>
        <span class="s2">startWork(request);</span>
      <span class="s2">},</span>
      <span class="s2">pull: </span><span class="s4">function </span><span class="s2">() {</span>
        <span class="s2">startFlowing(request, writable);</span>
      <span class="s2">},</span>
      <span class="s2">cancel: </span><span class="s4">function </span><span class="s2">(reason) {</span>
        <span class="s2">request.destination = </span><span class="s4">null</span><span class="s2">;</span>
        <span class="s2">abort(request, reason);</span>
      <span class="s2">}</span>
    <span class="s2">},</span>
    <span class="s2">{ highWaterMark: </span><span class="s5">0 </span><span class="s2">}</span>
  <span class="s2">);</span>
<span class="s2">};</span>
<span class="s2">exports.unstable_prerender = </span><span class="s4">function </span><span class="s2">(model, webpackMap, options) {</span>
  <span class="s4">return new </span><span class="s2">Promise(</span><span class="s4">function </span><span class="s2">(resolve, reject) {</span>
    <span class="s4">var </span><span class="s2">request = </span><span class="s4">new </span><span class="s2">RequestInstance(</span>
      <span class="s5">21</span><span class="s2">,</span>
      <span class="s2">model,</span>
      <span class="s2">webpackMap,</span>
      <span class="s2">options ? options.onError : </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
      <span class="s2">options ? options.onPostpone : </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
      <span class="s4">function </span><span class="s2">() {</span>
        <span class="s4">var </span><span class="s2">writable,</span>
          <span class="s2">stream = </span><span class="s4">new </span><span class="s2">ReadableStream(</span>
            <span class="s2">{</span>
              <span class="s2">type: </span><span class="s3">&quot;bytes&quot;</span><span class="s2">,</span>
              <span class="s2">start: </span><span class="s4">function </span><span class="s2">(controller) {</span>
                <span class="s2">writable =</span>
                  <span class="s2">createFakeWritableFromReadableStreamController(controller);</span>
              <span class="s2">},</span>
              <span class="s2">pull: </span><span class="s4">function </span><span class="s2">() {</span>
                <span class="s2">startFlowing(request, writable);</span>
              <span class="s2">},</span>
              <span class="s2">cancel: </span><span class="s4">function </span><span class="s2">(reason) {</span>
                <span class="s2">request.destination = </span><span class="s4">null</span><span class="s2">;</span>
                <span class="s2">abort(request, reason);</span>
              <span class="s2">}</span>
            <span class="s2">},</span>
            <span class="s2">{ highWaterMark: </span><span class="s5">0 </span><span class="s2">}</span>
          <span class="s2">);</span>
        <span class="s2">resolve({ prelude: stream });</span>
      <span class="s2">},</span>
      <span class="s2">reject,</span>
      <span class="s2">options ? options.identifierPrefix : </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
      <span class="s2">options ? options.temporaryReferences : </span><span class="s4">void </span><span class="s5">0</span>
    <span class="s2">);</span>
    <span class="s4">if </span><span class="s2">(options &amp;&amp; options.signal) {</span>
      <span class="s4">var </span><span class="s2">signal = options.signal;</span>
      <span class="s4">if </span><span class="s2">(signal.aborted) abort(request, signal.reason);</span>
      <span class="s4">else </span><span class="s2">{</span>
        <span class="s4">var </span><span class="s2">listener = </span><span class="s4">function </span><span class="s2">() {</span>
          <span class="s2">abort(request, signal.reason);</span>
          <span class="s2">signal.removeEventListener(</span><span class="s3">&quot;abort&quot;</span><span class="s2">, listener);</span>
        <span class="s2">};</span>
        <span class="s2">signal.addEventListener(</span><span class="s3">&quot;abort&quot;</span><span class="s2">, listener);</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s2">startWork(request);</span>
  <span class="s2">});</span>
<span class="s2">};</span>
<span class="s2">exports.unstable_prerenderToNodeStream = </span><span class="s4">function </span><span class="s2">(model, webpackMap, options) {</span>
  <span class="s4">return new </span><span class="s2">Promise(</span><span class="s4">function </span><span class="s2">(resolve, reject) {</span>
    <span class="s4">var </span><span class="s2">request = </span><span class="s4">new </span><span class="s2">RequestInstance(</span>
      <span class="s5">21</span><span class="s2">,</span>
      <span class="s2">model,</span>
      <span class="s2">webpackMap,</span>
      <span class="s2">options ? options.onError : </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
      <span class="s2">options ? options.onPostpone : </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
      <span class="s4">function </span><span class="s2">() {</span>
        <span class="s4">var </span><span class="s2">readable = </span><span class="s4">new </span><span class="s2">stream.Readable({</span>
            <span class="s2">read: </span><span class="s4">function </span><span class="s2">() {</span>
              <span class="s2">startFlowing(request, writable);</span>
            <span class="s2">}</span>
          <span class="s2">}),</span>
          <span class="s2">writable = createFakeWritableFromNodeReadable(readable);</span>
        <span class="s2">resolve({ prelude: readable });</span>
      <span class="s2">},</span>
      <span class="s2">reject,</span>
      <span class="s2">options ? options.identifierPrefix : </span><span class="s4">void </span><span class="s5">0</span><span class="s2">,</span>
      <span class="s2">options ? options.temporaryReferences : </span><span class="s4">void </span><span class="s5">0</span>
    <span class="s2">);</span>
    <span class="s4">if </span><span class="s2">(options &amp;&amp; options.signal) {</span>
      <span class="s4">var </span><span class="s2">signal = options.signal;</span>
      <span class="s4">if </span><span class="s2">(signal.aborted) abort(request, signal.reason);</span>
      <span class="s4">else </span><span class="s2">{</span>
        <span class="s4">var </span><span class="s2">listener = </span><span class="s4">function </span><span class="s2">() {</span>
          <span class="s2">abort(request, signal.reason);</span>
          <span class="s2">signal.removeEventListener(</span><span class="s3">&quot;abort&quot;</span><span class="s2">, listener);</span>
        <span class="s2">};</span>
        <span class="s2">signal.addEventListener(</span><span class="s3">&quot;abort&quot;</span><span class="s2">, listener);</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
    <span class="s2">startWork(request);</span>
  <span class="s2">});</span>
<span class="s2">};</span>
</pre>
</body>
</html>