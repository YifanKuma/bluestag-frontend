<html>
<head>
<title>globals.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #0033b3;}
.s2 { color: #8c8c8c; font-style: italic;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #067d17;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
globals.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">declare </span><span class="s1">var </span><span class="s0">global: </span><span class="s1">typeof </span><span class="s0">globalThis;</span>

<span class="s0">declare </span><span class="s1">var </span><span class="s0">process: NodeJS.Process;</span>
<span class="s0">declare </span><span class="s1">var </span><span class="s0">console: Console;</span>

<span class="s1">interface </span><span class="s0">ErrorConstructor {</span>
    <span class="s2">/**</span>
     <span class="s2">* Creates a `.stack` property on `targetObject`, which when accessed returns</span>
     <span class="s2">* a string representing the location in the code at which</span>
     <span class="s2">* `Error.captureStackTrace()` was called.</span>
     <span class="s2">*</span>
     <span class="s2">* ```js</span>
     <span class="s2">* const myObject = {};</span>
     <span class="s2">* Error.captureStackTrace(myObject);</span>
     <span class="s2">* myObject.stack;  // Similar to `new Error().stack`</span>
     <span class="s2">* ```</span>
     <span class="s2">*</span>
     <span class="s2">* The first line of the trace will be prefixed with</span>
     <span class="s2">* `${myObject.name}: ${myObject.message}`.</span>
     <span class="s2">*</span>
     <span class="s2">* The optional `constructorOpt` argument accepts a function. If given, all frames</span>
     <span class="s2">* above `constructorOpt`, including `constructorOpt`, will be omitted from the</span>
     <span class="s2">* generated stack trace.</span>
     <span class="s2">*</span>
     <span class="s2">* The `constructorOpt` argument is useful for hiding implementation</span>
     <span class="s2">* details of error generation from the user. For instance:</span>
     <span class="s2">*</span>
     <span class="s2">* ```js</span>
     <span class="s2">* function a() {</span>
     <span class="s2">*   b();</span>
     <span class="s2">* }</span>
     <span class="s2">*</span>
     <span class="s2">* function b() {</span>
     <span class="s2">*   c();</span>
     <span class="s2">* }</span>
     <span class="s2">*</span>
     <span class="s2">* function c() {</span>
     <span class="s2">*   // Create an error without stack trace to avoid calculating the stack trace twice.</span>
     <span class="s2">*   const { stackTraceLimit } = Error;</span>
     <span class="s2">*   Error.stackTraceLimit = 0;</span>
     <span class="s2">*   const error = new Error();</span>
     <span class="s2">*   Error.stackTraceLimit = stackTraceLimit;</span>
     <span class="s2">*</span>
     <span class="s2">*   // Capture the stack trace above function b</span>
     <span class="s2">*   Error.captureStackTrace(error, b); // Neither function c, nor b is included in the stack trace</span>
     <span class="s2">*   throw error;</span>
     <span class="s2">* }</span>
     <span class="s2">*</span>
     <span class="s2">* a();</span>
     <span class="s2">* ```</span>
     <span class="s2">*/</span>
    <span class="s0">captureStackTrace(targetObject: object, constructorOpt?: Function): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s2">/**</span>
     <span class="s2">* </span><span class="s3">@see </span><span class="s2">https://v8.dev/docs/stack-trace-api#customizing-stack-traces</span>
     <span class="s2">*/</span>
    <span class="s0">prepareStackTrace(err: Error, stackTraces: NodeJS.CallSite[]): any;</span>
    <span class="s2">/**</span>
     <span class="s2">* The `Error.stackTraceLimit` property specifies the number of stack frames</span>
     <span class="s2">* collected by a stack trace (whether generated by `new Error().stack` or</span>
     <span class="s2">* `Error.captureStackTrace(obj)`).</span>
     <span class="s2">*</span>
     <span class="s2">* The default value is `10` but may be set to any valid JavaScript number. Changes</span>
     <span class="s2">* will affect any stack trace captured _after_ the value has been changed.</span>
     <span class="s2">*</span>
     <span class="s2">* If set to a non-number value, or set to a negative number, stack traces will</span>
     <span class="s2">* not capture any frames.</span>
     <span class="s2">*/</span>
    <span class="s0">stackTraceLimit: number;</span>
<span class="s0">}</span>

<span class="s2">/**</span>
 <span class="s2">* Enable this API with the `--expose-gc` CLI flag.</span>
 <span class="s2">*/</span>
<span class="s0">declare </span><span class="s1">var </span><span class="s0">gc: NodeJS.GCFunction | undefined;</span>

<span class="s0">declare namespace NodeJS {</span>
    <span class="s1">interface </span><span class="s0">CallSite {</span>
        <span class="s0">getColumnNumber(): number | </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s0">getEnclosingColumnNumber(): number | </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s0">getEnclosingLineNumber(): number | </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s0">getEvalOrigin(): string | undefined;</span>
        <span class="s0">getFileName(): string | </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s0">getFunction(): Function | undefined;</span>
        <span class="s0">getFunctionName(): string | </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s0">getLineNumber(): number | </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s0">getMethodName(): string | </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s0">getPosition(): number;</span>
        <span class="s0">getPromiseIndex(): number | </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s0">getScriptHash(): string;</span>
        <span class="s0">getScriptNameOrSourceURL(): string | </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s0">getThis(): unknown;</span>
        <span class="s0">getTypeName(): string | </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s0">isAsync(): boolean;</span>
        <span class="s0">isConstructor(): boolean;</span>
        <span class="s0">isEval(): boolean;</span>
        <span class="s0">isNative(): boolean;</span>
        <span class="s0">isPromiseAll(): boolean;</span>
        <span class="s0">isToplevel(): boolean;</span>
    <span class="s0">}</span>

    <span class="s1">interface </span><span class="s0">ErrnoException </span><span class="s1">extends </span><span class="s0">Error {</span>
        <span class="s0">errno?: number | undefined;</span>
        <span class="s0">code?: string | undefined;</span>
        <span class="s0">path?: string | undefined;</span>
        <span class="s0">syscall?: string | undefined;</span>
    <span class="s0">}</span>

    <span class="s1">interface </span><span class="s0">ReadableStream </span><span class="s1">extends </span><span class="s0">EventEmitter {</span>
        <span class="s0">readable: boolean;</span>
        <span class="s0">read(size?: number): string | Buffer;</span>
        <span class="s0">setEncoding(encoding: BufferEncoding): </span><span class="s1">this</span><span class="s0">;</span>
        <span class="s0">pause(): </span><span class="s1">this</span><span class="s0">;</span>
        <span class="s0">resume(): </span><span class="s1">this</span><span class="s0">;</span>
        <span class="s0">isPaused(): boolean;</span>
        <span class="s0">pipe&lt;T </span><span class="s1">extends </span><span class="s0">WritableStream&gt;(destination: T, options?: { end?: boolean | undefined }): T;</span>
        <span class="s0">unpipe(destination?: WritableStream): </span><span class="s1">this</span><span class="s0">;</span>
        <span class="s0">unshift(chunk: string | Uint8Array, encoding?: BufferEncoding): </span><span class="s1">void</span><span class="s0">;</span>
        <span class="s0">wrap(oldStream: ReadableStream): </span><span class="s1">this</span><span class="s0">;</span>
        <span class="s0">[Symbol.asyncIterator](): AsyncIterableIterator&lt;string | Buffer&gt;;</span>
    <span class="s0">}</span>

    <span class="s1">interface </span><span class="s0">WritableStream </span><span class="s1">extends </span><span class="s0">EventEmitter {</span>
        <span class="s0">writable: boolean;</span>
        <span class="s0">write(buffer: Uint8Array | string, cb?: (err?: Error | </span><span class="s1">null</span><span class="s0">) =&gt; </span><span class="s1">void</span><span class="s0">): boolean;</span>
        <span class="s0">write(str: string, encoding?: BufferEncoding, cb?: (err?: Error | </span><span class="s1">null</span><span class="s0">) =&gt; </span><span class="s1">void</span><span class="s0">): boolean;</span>
        <span class="s0">end(cb?: () =&gt; </span><span class="s1">void</span><span class="s0">): </span><span class="s1">this</span><span class="s0">;</span>
        <span class="s0">end(data: string | Uint8Array, cb?: () =&gt; </span><span class="s1">void</span><span class="s0">): </span><span class="s1">this</span><span class="s0">;</span>
        <span class="s0">end(str: string, encoding?: BufferEncoding, cb?: () =&gt; </span><span class="s1">void</span><span class="s0">): </span><span class="s1">this</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">interface </span><span class="s0">ReadWriteStream </span><span class="s1">extends </span><span class="s0">ReadableStream, WritableStream {}</span>

    <span class="s1">interface </span><span class="s0">RefCounted {</span>
        <span class="s0">ref(): </span><span class="s1">this</span><span class="s0">;</span>
        <span class="s0">unref(): </span><span class="s1">this</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">interface </span><span class="s0">Dict&lt;T&gt; {</span>
        <span class="s0">[key: string]: T | undefined;</span>
    <span class="s0">}</span>

    <span class="s1">interface </span><span class="s0">ReadOnlyDict&lt;T&gt; {</span>
        <span class="s0">readonly [key: string]: T | undefined;</span>
    <span class="s0">}</span>

    <span class="s1">interface </span><span class="s0">GCFunction {</span>
        <span class="s0">(minor?: boolean): </span><span class="s1">void</span><span class="s0">;</span>
        <span class="s0">(options: NodeJS.GCOptions &amp; { execution: </span><span class="s4">&quot;async&quot; </span><span class="s0">}): Promise&lt;</span><span class="s1">void</span><span class="s0">&gt;;</span>
        <span class="s0">(options: NodeJS.GCOptions): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">interface </span><span class="s0">GCOptions {</span>
        <span class="s0">execution?: </span><span class="s4">&quot;sync&quot; </span><span class="s0">| </span><span class="s4">&quot;async&quot; </span><span class="s0">| undefined;</span>
        <span class="s0">flavor?: </span><span class="s4">&quot;regular&quot; </span><span class="s0">| </span><span class="s4">&quot;last-resort&quot; </span><span class="s0">| undefined;</span>
        <span class="s0">type?: </span><span class="s4">&quot;major-snapshot&quot; </span><span class="s0">| </span><span class="s4">&quot;major&quot; </span><span class="s0">| </span><span class="s4">&quot;minor&quot; </span><span class="s0">| undefined;</span>
        <span class="s0">filename?: string | undefined;</span>
    <span class="s0">}</span>

    <span class="s2">/** An iterable iterator returned by the Node.js API. */</span>
    <span class="s2">// Default TReturn/TNext in v20 is `any`, for compatibility with the previously-used IterableIterator.</span>
    <span class="s1">interface </span><span class="s0">Iterator&lt;T, TReturn = any, TNext = any&gt; </span><span class="s1">extends </span><span class="s0">IteratorObject&lt;T, TReturn, TNext&gt; {</span>
        <span class="s0">[Symbol.iterator](): NodeJS.Iterator&lt;T, TReturn, TNext&gt;;</span>
    <span class="s0">}</span>

    <span class="s2">/** An async iterable iterator returned by the Node.js API. */</span>
    <span class="s2">// Default TReturn/TNext in v20 is `any`, for compatibility with the previously-used AsyncIterableIterator.</span>
    <span class="s1">interface </span><span class="s0">AsyncIterator&lt;T, TReturn = any, TNext = any&gt; </span><span class="s1">extends </span><span class="s0">AsyncIteratorObject&lt;T, TReturn, TNext&gt; {</span>
        <span class="s0">[Symbol.asyncIterator](): NodeJS.AsyncIterator&lt;T, TReturn, TNext&gt;;</span>
    <span class="s0">}</span>
<span class="s0">}</span>
</pre>
</body>
</html>