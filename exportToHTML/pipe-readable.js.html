<html>
<head>
<title>pipe-readable.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
pipe-readable.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s3">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">isAbortError: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">pipeToNodeResponse: </span><span class="s2">null</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">_export(target, all) {</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">name </span><span class="s2">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">isAbortError: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">isAbortError;</span>
    <span class="s1">},</span>
    <span class="s1">pipeToNodeResponse: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">pipeToNodeResponse;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_nextrequest = require(</span><span class="s0">&quot;./web/spec-extension/adapters/next-request&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_detachedpromise = require(</span><span class="s0">&quot;../lib/detached-promise&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_tracer = require(</span><span class="s0">&quot;./lib/trace/tracer&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_constants = require(</span><span class="s0">&quot;./lib/trace/constants&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_clientcomponentrendererlogger = require(</span><span class="s0">&quot;./client-component-renderer-logger&quot;</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">isAbortError(e) {</span>
    <span class="s2">return </span><span class="s1">(e == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: e.name) === </span><span class="s0">'AbortError' </span><span class="s1">|| (e == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: e.name) === _nextrequest.ResponseAbortedName;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createWriterFromResponse(res, waitUntilForEnd) {</span>
    <span class="s2">let </span><span class="s1">started = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s4">// Create a promise that will resolve once the response has drained. See</span>
    <span class="s4">// https://nodejs.org/api/stream.html#stream_event_drain</span>
    <span class="s2">let </span><span class="s1">drained = </span><span class="s2">new </span><span class="s1">_detachedpromise.DetachedPromise();</span>
    <span class="s2">function </span><span class="s1">onDrain() {</span>
        <span class="s1">drained.resolve();</span>
    <span class="s1">}</span>
    <span class="s1">res.on(</span><span class="s0">'drain'</span><span class="s1">, onDrain);</span>
    <span class="s4">// If the finish event fires, it means we shouldn't block and wait for the</span>
    <span class="s4">// drain event.</span>
    <span class="s1">res.once(</span><span class="s0">'close'</span><span class="s1">, ()=&gt;{</span>
        <span class="s1">res.off(</span><span class="s0">'drain'</span><span class="s1">, onDrain);</span>
        <span class="s1">drained.resolve();</span>
    <span class="s1">});</span>
    <span class="s4">// Create a promise that will resolve once the response has finished. See</span>
    <span class="s4">// https://nodejs.org/api/http.html#event-finish_1</span>
    <span class="s2">const </span><span class="s1">finished = </span><span class="s2">new </span><span class="s1">_detachedpromise.DetachedPromise();</span>
    <span class="s1">res.once(</span><span class="s0">'finish'</span><span class="s1">, ()=&gt;{</span>
        <span class="s1">finished.resolve();</span>
    <span class="s1">});</span>
    <span class="s4">// Create a writable stream that will write to the response.</span>
    <span class="s2">return new </span><span class="s1">WritableStream({</span>
        <span class="s1">write: async (chunk)=&gt;{</span>
            <span class="s4">// You'd think we'd want to use `start` instead of placing this in `write`</span>
            <span class="s4">// but this ensures that we don't actually flush the headers until we've</span>
            <span class="s4">// started writing chunks.</span>
            <span class="s2">if </span><span class="s1">(!started) {</span>
                <span class="s1">started = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s0">'performance' </span><span class="s2">in </span><span class="s1">globalThis &amp;&amp; process.env.NEXT_OTEL_PERFORMANCE_PREFIX) {</span>
                    <span class="s2">const </span><span class="s1">metrics = (</span><span class="s3">0</span><span class="s1">, _clientcomponentrendererlogger.getClientComponentLoaderMetrics)();</span>
                    <span class="s2">if </span><span class="s1">(metrics) {</span>
                        <span class="s1">performance.measure(</span><span class="s0">`</span><span class="s1">${process.env.NEXT_OTEL_PERFORMANCE_PREFIX}</span><span class="s0">:next-client-component-loading`</span><span class="s1">, {</span>
                            <span class="s1">start: metrics.clientComponentLoadStart,</span>
                            <span class="s1">end: metrics.clientComponentLoadStart + metrics.clientComponentLoadTimes</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s1">res.flushHeaders();</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, _tracer.getTracer)().trace(_constants.NextNodeServerSpan.startResponse, {</span>
                    <span class="s1">spanName: </span><span class="s0">'start response'</span>
                <span class="s1">}, ()=&gt;undefined);</span>
            <span class="s1">}</span>
            <span class="s2">try </span><span class="s1">{</span>
                <span class="s2">const </span><span class="s1">ok = res.write(chunk);</span>
                <span class="s4">// Added by the `compression` middleware, this is a function that will</span>
                <span class="s4">// flush the partially-compressed response to the client.</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s0">'flush' </span><span class="s2">in </span><span class="s1">res &amp;&amp; </span><span class="s2">typeof </span><span class="s1">res.flush === </span><span class="s0">'function'</span><span class="s1">) {</span>
                    <span class="s1">res.flush();</span>
                <span class="s1">}</span>
                <span class="s4">// If the write returns false, it means there's some backpressure, so</span>
                <span class="s4">// wait until it's streamed before continuing.</span>
                <span class="s2">if </span><span class="s1">(!ok) {</span>
                    <span class="s2">await </span><span class="s1">drained.promise;</span>
                    <span class="s4">// Reset the drained promise so that we can wait for the next drain event.</span>
                    <span class="s1">drained = </span><span class="s2">new </span><span class="s1">_detachedpromise.DetachedPromise();</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
                <span class="s1">res.end();</span>
                <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'failed to write chunk to response'</span><span class="s1">, {</span>
                    <span class="s1">cause: err</span>
                <span class="s1">}), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s0">&quot;E321&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s2">true</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
        <span class="s1">},</span>
        <span class="s1">abort: (err)=&gt;{</span>
            <span class="s2">if </span><span class="s1">(res.writableFinished) </span><span class="s2">return</span><span class="s1">;</span>
            <span class="s1">res.destroy(err);</span>
        <span class="s1">},</span>
        <span class="s1">close: async ()=&gt;{</span>
            <span class="s4">// if a waitUntil promise was passed, wait for it to resolve before</span>
            <span class="s4">// ending the response.</span>
            <span class="s2">if </span><span class="s1">(waitUntilForEnd) {</span>
                <span class="s2">await </span><span class="s1">waitUntilForEnd;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(res.writableFinished) </span><span class="s2">return</span><span class="s1">;</span>
            <span class="s1">res.end();</span>
            <span class="s2">return </span><span class="s1">finished.promise;</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">pipeToNodeResponse(readable, res, waitUntilForEnd) {</span>
    <span class="s2">try </span><span class="s1">{</span>
        <span class="s4">// If the response has already errored, then just return now.</span>
        <span class="s2">const </span><span class="s1">{ errored, destroyed } = res;</span>
        <span class="s2">if </span><span class="s1">(errored || destroyed) </span><span class="s2">return</span><span class="s1">;</span>
        <span class="s4">// Create a new AbortController so that we can abort the readable if the</span>
        <span class="s4">// client disconnects.</span>
        <span class="s2">const </span><span class="s1">controller = (</span><span class="s3">0</span><span class="s1">, _nextrequest.createAbortController)(res);</span>
        <span class="s2">const </span><span class="s1">writer = createWriterFromResponse(res, waitUntilForEnd);</span>
        <span class="s2">await </span><span class="s1">readable.pipeTo(writer, {</span>
            <span class="s1">signal: controller.signal</span>
        <span class="s1">});</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
        <span class="s4">// If this isn't related to an abort error, re-throw it.</span>
        <span class="s2">if </span><span class="s1">(isAbortError(err)) </span><span class="s2">return</span><span class="s1">;</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'failed to pipe response'</span><span class="s1">, {</span>
            <span class="s1">cause: err</span>
        <span class="s1">}), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E180&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=pipe-readable.js.map</span></pre>
</body>
</html>