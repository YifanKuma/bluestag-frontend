<html>
<head>
<title>turbopack-utils.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #8c8c8c; font-style: italic;}
.s6 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
turbopack-utils.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s3">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">AssetMapper: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">addMetadataIdToRoute: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">addRouteSuffix: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">handleEntrypoints: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">handlePagesErrorRoute: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">handleRouteType: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">hasEntrypointForKey: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">msToNs: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">normalizedPageToTurbopackStructureRoute: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">printNonFatalIssue: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">processTopLevelIssues: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">removeRouteSuffix: </span><span class="s2">null</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">_export(target, all) {</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">name </span><span class="s2">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">AssetMapper: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">AssetMapper;</span>
    <span class="s1">},</span>
    <span class="s1">addMetadataIdToRoute: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">addMetadataIdToRoute;</span>
    <span class="s1">},</span>
    <span class="s1">addRouteSuffix: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">addRouteSuffix;</span>
    <span class="s1">},</span>
    <span class="s1">handleEntrypoints: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">handleEntrypoints;</span>
    <span class="s1">},</span>
    <span class="s1">handlePagesErrorRoute: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">handlePagesErrorRoute;</span>
    <span class="s1">},</span>
    <span class="s1">handleRouteType: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">handleRouteType;</span>
    <span class="s1">},</span>
    <span class="s1">hasEntrypointForKey: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">hasEntrypointForKey;</span>
    <span class="s1">},</span>
    <span class="s1">msToNs: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">msToNs;</span>
    <span class="s1">},</span>
    <span class="s1">normalizedPageToTurbopackStructureRoute: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">normalizedPageToTurbopackStructureRoute;</span>
    <span class="s1">},</span>
    <span class="s1">printNonFatalIssue: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">printNonFatalIssue;</span>
    <span class="s1">},</span>
    <span class="s1">processTopLevelIssues: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">processTopLevelIssues;</span>
    <span class="s1">},</span>
    <span class="s1">removeRouteSuffix: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">removeRouteSuffix;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_hotreloadertypes = require(</span><span class="s0">&quot;./hot-reloader-types&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_log = </span><span class="s4">/*#__PURE__*/ </span><span class="s1">_interop_require_wildcard(require(</span><span class="s0">&quot;../../build/output/log&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_entrykey = require(</span><span class="s0">&quot;../../shared/lib/turbopack/entry-key&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_ismetadataroute = require(</span><span class="s0">&quot;../../lib/metadata/is-metadata-route&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_utils = require(</span><span class="s0">&quot;../../shared/lib/turbopack/utils&quot;</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">_getRequireWildcardCache(nodeInterop) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">WeakMap !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) </span><span class="s2">return null</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">cacheBabelInterop = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
    <span class="s2">var </span><span class="s1">cacheNodeInterop = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
    <span class="s2">return </span><span class="s1">(_getRequireWildcardCache = </span><span class="s2">function</span><span class="s1">(nodeInterop) {</span>
        <span class="s2">return </span><span class="s1">nodeInterop ? cacheNodeInterop : cacheBabelInterop;</span>
    <span class="s1">})(nodeInterop);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_interop_require_wildcard(obj, nodeInterop) {</span>
    <span class="s2">if </span><span class="s1">(!nodeInterop &amp;&amp; obj &amp;&amp; obj.__esModule) {</span>
        <span class="s2">return </span><span class="s1">obj;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(obj === </span><span class="s2">null </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;object&quot; </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s2">default</span><span class="s1">: obj</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">var </span><span class="s1">cache = _getRequireWildcardCache(nodeInterop);</span>
    <span class="s2">if </span><span class="s1">(cache &amp;&amp; cache.has(obj)) {</span>
        <span class="s2">return </span><span class="s1">cache.get(obj);</span>
    <span class="s1">}</span>
    <span class="s2">var </span><span class="s1">newObj = {</span>
        <span class="s1">__proto__: </span><span class="s2">null</span>
    <span class="s1">};</span>
    <span class="s2">var </span><span class="s1">hasPropertyDescriptor = Object.defineProperty &amp;&amp; Object.getOwnPropertyDescriptor;</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">obj){</span>
        <span class="s2">if </span><span class="s1">(key !== </span><span class="s0">&quot;default&quot; </span><span class="s1">&amp;&amp; Object.prototype.hasOwnProperty.call(obj, key)) {</span>
            <span class="s2">var </span><span class="s1">desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(desc &amp;&amp; (desc.get || desc.set)) {</span>
                <span class="s1">Object.defineProperty(newObj, key, desc);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">newObj[key] = obj[key];</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">newObj.default = obj;</span>
    <span class="s2">if </span><span class="s1">(cache) {</span>
        <span class="s1">cache.set(obj, newObj);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">newObj;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">onceErrorSet = </span><span class="s2">new </span><span class="s1">Set();</span>
<span class="s4">/**</span>
 <span class="s4">* Check if given issue is a warning to be display only once.</span>
 <span class="s4">* This mimics behavior of get-page-static-info's warnOnce.</span>
 <span class="s4">* </span><span class="s5">@param </span><span class="s4">issue</span>
 <span class="s4">* </span><span class="s5">@returns</span>
 <span class="s4">*/ </span><span class="s2">function </span><span class="s1">shouldEmitOnceWarning(issue) {</span>
    <span class="s2">const </span><span class="s1">{ severity, title, stage } = issue;</span>
    <span class="s2">if </span><span class="s1">(severity === </span><span class="s0">'warning' </span><span class="s1">&amp;&amp; title.value === </span><span class="s0">'Invalid page configuration'</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(onceErrorSet.has(issue)) {</span>
            <span class="s2">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">onceErrorSet.add(issue);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(severity === </span><span class="s0">'warning' </span><span class="s1">&amp;&amp; stage === </span><span class="s0">'config' </span><span class="s1">&amp;&amp; (</span><span class="s3">0</span><span class="s1">, _utils.renderStyledStringToErrorAnsi)(issue.title).includes(</span><span class="s0">&quot;can't be external&quot;</span><span class="s1">)) {</span>
        <span class="s2">if </span><span class="s1">(onceErrorSet.has(issue)) {</span>
            <span class="s2">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">onceErrorSet.add(issue);</span>
    <span class="s1">}</span>
    <span class="s2">return true</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">printNonFatalIssue(issue) {</span>
    <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _utils.isRelevantWarning)(issue) &amp;&amp; shouldEmitOnceWarning(issue)) {</span>
        <span class="s1">_log.warn((</span><span class="s3">0</span><span class="s1">, _utils.formatIssue)(issue));</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">processTopLevelIssues(currentTopLevelIssues, result) {</span>
    <span class="s1">currentTopLevelIssues.clear();</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">issue of result.issues){</span>
        <span class="s2">const </span><span class="s1">issueKey = (</span><span class="s3">0</span><span class="s1">, _utils.getIssueKey)(issue);</span>
        <span class="s1">currentTopLevelIssues.set(issueKey, issue);</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">MILLISECONDS_IN_NANOSECOND = BigInt(</span><span class="s3">1000000</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">msToNs(ms) {</span>
    <span class="s2">return </span><span class="s1">BigInt(Math.floor(ms)) * MILLISECONDS_IN_NANOSECOND;</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">handleRouteType({ dev, page, pathname, route, currentEntryIssues, entrypoints, manifestLoader, readyIds, devRewrites, productionRewrites, hooks, logErrors }) {</span>
    <span class="s2">const </span><span class="s1">shouldCreateWebpackStats = process.env.TURBOPACK_STATS != </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">switch</span><span class="s1">(route.type){</span>
        <span class="s2">case </span><span class="s0">'page'</span><span class="s1">:</span>
            <span class="s1">{</span>
                <span class="s2">const </span><span class="s1">clientKey = (</span><span class="s3">0</span><span class="s1">, _entrykey.getEntryKey)(</span><span class="s0">'pages'</span><span class="s1">, </span><span class="s0">'client'</span><span class="s1">, page);</span>
                <span class="s2">const </span><span class="s1">serverKey = (</span><span class="s3">0</span><span class="s1">, _entrykey.getEntryKey)(</span><span class="s0">'pages'</span><span class="s1">, </span><span class="s0">'server'</span><span class="s1">, page);</span>
                <span class="s2">try </span><span class="s1">{</span>
                    <span class="s4">// In the best case scenario, Turbopack chunks document, app, page separately in that order,</span>
                    <span class="s4">// so it can happen that the chunks of document change, but the chunks of app and page</span>
                    <span class="s4">// don't. We still need to reload the page chunks in that case though, otherwise the version</span>
                    <span class="s4">// of the document or app component export from the pages template is stale.</span>
                    <span class="s2">let </span><span class="s1">documentOrAppChanged = </span><span class="s2">false</span><span class="s1">;</span>
                    <span class="s2">if </span><span class="s1">(entrypoints.global.app) {</span>
                        <span class="s2">const </span><span class="s1">key = (</span><span class="s3">0</span><span class="s1">, _entrykey.getEntryKey)(</span><span class="s0">'pages'</span><span class="s1">, </span><span class="s0">'server'</span><span class="s1">, </span><span class="s0">'_app'</span><span class="s1">);</span>
                        <span class="s2">const </span><span class="s1">writtenEndpoint = </span><span class="s2">await </span><span class="s1">entrypoints.global.app.writeToDisk();</span>
                        <span class="s1">documentOrAppChanged ||= (hooks == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: hooks.handleWrittenEndpoint(key, writtenEndpoint, </span><span class="s2">false</span><span class="s1">)) ?? </span><span class="s2">false</span><span class="s1">;</span>
                        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _utils.processIssues)(currentEntryIssues, key, writtenEndpoint, </span><span class="s2">false</span><span class="s1">, logErrors);</span>
                    <span class="s1">}</span>
                    <span class="s2">await </span><span class="s1">manifestLoader.loadBuildManifest(</span><span class="s0">'_app'</span><span class="s1">);</span>
                    <span class="s2">await </span><span class="s1">manifestLoader.loadPagesManifest(</span><span class="s0">'_app'</span><span class="s1">);</span>
                    <span class="s2">if </span><span class="s1">(entrypoints.global.document) {</span>
                        <span class="s2">const </span><span class="s1">key = (</span><span class="s3">0</span><span class="s1">, _entrykey.getEntryKey)(</span><span class="s0">'pages'</span><span class="s1">, </span><span class="s0">'server'</span><span class="s1">, </span><span class="s0">'_document'</span><span class="s1">);</span>
                        <span class="s2">const </span><span class="s1">writtenEndpoint = </span><span class="s2">await </span><span class="s1">entrypoints.global.document.writeToDisk();</span>
                        <span class="s1">documentOrAppChanged ||= (hooks == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: hooks.handleWrittenEndpoint(key, writtenEndpoint, </span><span class="s2">false</span><span class="s1">)) ?? </span><span class="s2">false</span><span class="s1">;</span>
                        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _utils.processIssues)(currentEntryIssues, key, writtenEndpoint, </span><span class="s2">false</span><span class="s1">, logErrors);</span>
                    <span class="s1">}</span>
                    <span class="s2">await </span><span class="s1">manifestLoader.loadPagesManifest(</span><span class="s0">'_document'</span><span class="s1">);</span>
                    <span class="s2">const </span><span class="s1">writtenEndpoint = </span><span class="s2">await </span><span class="s1">route.htmlEndpoint.writeToDisk();</span>
                    <span class="s1">hooks == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: hooks.handleWrittenEndpoint(serverKey, writtenEndpoint, documentOrAppChanged);</span>
                    <span class="s2">const </span><span class="s1">type = writtenEndpoint == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: writtenEndpoint.type;</span>
                    <span class="s2">await </span><span class="s1">manifestLoader.loadClientBuildManifest(page);</span>
                    <span class="s2">await </span><span class="s1">manifestLoader.loadBuildManifest(page);</span>
                    <span class="s2">await </span><span class="s1">manifestLoader.loadPagesManifest(page);</span>
                    <span class="s2">if </span><span class="s1">(type === </span><span class="s0">'edge'</span><span class="s1">) {</span>
                        <span class="s2">await </span><span class="s1">manifestLoader.loadMiddlewareManifest(page, </span><span class="s0">'pages'</span><span class="s1">);</span>
                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">manifestLoader.deleteMiddlewareManifest(serverKey);</span>
                    <span class="s1">}</span>
                    <span class="s2">await </span><span class="s1">manifestLoader.loadFontManifest(</span><span class="s0">'/_app'</span><span class="s1">, </span><span class="s0">'pages'</span><span class="s1">);</span>
                    <span class="s2">await </span><span class="s1">manifestLoader.loadFontManifest(page, </span><span class="s0">'pages'</span><span class="s1">);</span>
                    <span class="s2">if </span><span class="s1">(shouldCreateWebpackStats) {</span>
                        <span class="s2">await </span><span class="s1">manifestLoader.loadWebpackStats(page, </span><span class="s0">'pages'</span><span class="s1">);</span>
                    <span class="s1">}</span>
                    <span class="s2">await </span><span class="s1">manifestLoader.writeManifests({</span>
                        <span class="s1">devRewrites,</span>
                        <span class="s1">productionRewrites,</span>
                        <span class="s1">entrypoints</span>
                    <span class="s1">});</span>
                    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _utils.processIssues)(currentEntryIssues, serverKey, writtenEndpoint, </span><span class="s2">false</span><span class="s1">, logErrors);</span>
                <span class="s1">} </span><span class="s2">finally</span><span class="s1">{</span>
                    <span class="s2">if </span><span class="s1">(dev) {</span>
                        <span class="s4">// TODO subscriptions should only be caused by the WebSocket connections</span>
                        <span class="s4">// otherwise we don't known when to unsubscribe and this leaking</span>
                        <span class="s1">hooks == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: hooks.subscribeToChanges(serverKey, </span><span class="s2">false</span><span class="s1">, route.dataEndpoint, ()=&gt;{</span>
                            <span class="s4">// Report the next compilation again</span>
                            <span class="s1">readyIds == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: readyIds.delete(pathname);</span>
                            <span class="s2">return </span><span class="s1">{</span>
                                <span class="s1">event: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.SERVER_ONLY_CHANGES,</span>
                                <span class="s1">pages: [</span>
                                    <span class="s1">page</span>
                                <span class="s1">]</span>
                            <span class="s1">};</span>
                        <span class="s1">}, (e)=&gt;{</span>
                            <span class="s2">return </span><span class="s1">{</span>
                                <span class="s1">action: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.RELOAD_PAGE,</span>
                                <span class="s1">data: </span><span class="s0">`error in </span><span class="s1">${page} </span><span class="s0">data subscription: </span><span class="s1">${e}</span><span class="s0">`</span>
                            <span class="s1">};</span>
                        <span class="s1">});</span>
                        <span class="s1">hooks == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: hooks.subscribeToChanges(clientKey, </span><span class="s2">false</span><span class="s1">, route.htmlEndpoint, ()=&gt;{</span>
                            <span class="s2">return </span><span class="s1">{</span>
                                <span class="s1">event: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.CLIENT_CHANGES</span>
                            <span class="s1">};</span>
                        <span class="s1">}, (e)=&gt;{</span>
                            <span class="s2">return </span><span class="s1">{</span>
                                <span class="s1">action: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.RELOAD_PAGE,</span>
                                <span class="s1">data: </span><span class="s0">`error in </span><span class="s1">${page} </span><span class="s0">html subscription: </span><span class="s1">${e}</span><span class="s0">`</span>
                            <span class="s1">};</span>
                        <span class="s1">});</span>
                        <span class="s2">if </span><span class="s1">(entrypoints.global.document) {</span>
                            <span class="s1">hooks == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: hooks.subscribeToChanges((</span><span class="s3">0</span><span class="s1">, _entrykey.getEntryKey)(</span><span class="s0">'pages'</span><span class="s1">, </span><span class="s0">'server'</span><span class="s1">, </span><span class="s0">'_document'</span><span class="s1">), </span><span class="s2">false</span><span class="s1">, entrypoints.global.document, ()=&gt;{</span>
                                <span class="s2">return </span><span class="s1">{</span>
                                    <span class="s1">action: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.RELOAD_PAGE,</span>
                                    <span class="s1">data: </span><span class="s0">'_document has changed (page route)'</span>
                                <span class="s1">};</span>
                            <span class="s1">}, (e)=&gt;{</span>
                                <span class="s2">return </span><span class="s1">{</span>
                                    <span class="s1">action: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.RELOAD_PAGE,</span>
                                    <span class="s1">data: </span><span class="s0">`error in _document subscription (page route): </span><span class="s1">${e}</span><span class="s0">`</span>
                                <span class="s1">};</span>
                            <span class="s1">});</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">'page-api'</span><span class="s1">:</span>
            <span class="s1">{</span>
                <span class="s2">const </span><span class="s1">key = (</span><span class="s3">0</span><span class="s1">, _entrykey.getEntryKey)(</span><span class="s0">'pages'</span><span class="s1">, </span><span class="s0">'server'</span><span class="s1">, page);</span>
                <span class="s2">const </span><span class="s1">writtenEndpoint = </span><span class="s2">await </span><span class="s1">route.endpoint.writeToDisk();</span>
                <span class="s1">hooks == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: hooks.handleWrittenEndpoint(key, writtenEndpoint, </span><span class="s2">false</span><span class="s1">);</span>
                <span class="s2">const </span><span class="s1">type = writtenEndpoint.type;</span>
                <span class="s2">await </span><span class="s1">manifestLoader.loadPagesManifest(page);</span>
                <span class="s2">if </span><span class="s1">(type === </span><span class="s0">'edge'</span><span class="s1">) {</span>
                    <span class="s2">await </span><span class="s1">manifestLoader.loadMiddlewareManifest(page, </span><span class="s0">'pages'</span><span class="s1">);</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">manifestLoader.deleteMiddlewareManifest(key);</span>
                <span class="s1">}</span>
                <span class="s2">await </span><span class="s1">manifestLoader.writeManifests({</span>
                    <span class="s1">devRewrites,</span>
                    <span class="s1">productionRewrites,</span>
                    <span class="s1">entrypoints</span>
                <span class="s1">});</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, _utils.processIssues)(currentEntryIssues, key, writtenEndpoint, </span><span class="s2">true</span><span class="s1">, logErrors);</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">'app-page'</span><span class="s1">:</span>
            <span class="s1">{</span>
                <span class="s2">const </span><span class="s1">key = (</span><span class="s3">0</span><span class="s1">, _entrykey.getEntryKey)(</span><span class="s0">'app'</span><span class="s1">, </span><span class="s0">'server'</span><span class="s1">, page);</span>
                <span class="s2">const </span><span class="s1">writtenEndpoint = </span><span class="s2">await </span><span class="s1">route.htmlEndpoint.writeToDisk();</span>
                <span class="s1">hooks == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: hooks.handleWrittenEndpoint(key, writtenEndpoint, </span><span class="s2">false</span><span class="s1">);</span>
                <span class="s2">if </span><span class="s1">(dev) {</span>
                    <span class="s4">// TODO subscriptions should only be caused by the WebSocket connections</span>
                    <span class="s4">// otherwise we don't known when to unsubscribe and this leaking</span>
                    <span class="s1">hooks == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: hooks.subscribeToChanges(key, </span><span class="s2">true</span><span class="s1">, route.rscEndpoint, (change, hash)=&gt;{</span>
                        <span class="s2">if </span><span class="s1">(change.issues.some((issue)=&gt;issue.severity === </span><span class="s0">'error'</span><span class="s1">)) {</span>
                            <span class="s4">// Ignore any updates that has errors</span>
                            <span class="s4">// There will be another update without errors eventually</span>
                            <span class="s2">return</span><span class="s1">;</span>
                        <span class="s1">}</span>
                        <span class="s4">// Report the next compilation again</span>
                        <span class="s1">readyIds == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: readyIds.delete(pathname);</span>
                        <span class="s2">return </span><span class="s1">{</span>
                            <span class="s1">action: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.SERVER_COMPONENT_CHANGES,</span>
                            <span class="s1">hash</span>
                        <span class="s1">};</span>
                    <span class="s1">}, (e)=&gt;{</span>
                        <span class="s2">return </span><span class="s1">{</span>
                            <span class="s1">action: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.RELOAD_PAGE,</span>
                            <span class="s1">data: </span><span class="s0">`error in </span><span class="s1">${page} </span><span class="s0">app-page subscription: </span><span class="s1">${e}</span><span class="s0">`</span>
                        <span class="s1">};</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">type = writtenEndpoint.type;</span>
                <span class="s2">if </span><span class="s1">(type === </span><span class="s0">'edge'</span><span class="s1">) {</span>
                    <span class="s2">await </span><span class="s1">manifestLoader.loadMiddlewareManifest(page, </span><span class="s0">'app'</span><span class="s1">);</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">manifestLoader.deleteMiddlewareManifest(key);</span>
                <span class="s1">}</span>
                <span class="s2">await </span><span class="s1">manifestLoader.loadAppBuildManifest(page);</span>
                <span class="s2">await </span><span class="s1">manifestLoader.loadBuildManifest(page, </span><span class="s0">'app'</span><span class="s1">);</span>
                <span class="s2">await </span><span class="s1">manifestLoader.loadAppPathsManifest(page);</span>
                <span class="s2">await </span><span class="s1">manifestLoader.loadActionManifest(page);</span>
                <span class="s2">await </span><span class="s1">manifestLoader.loadFontManifest(page, </span><span class="s0">'app'</span><span class="s1">);</span>
                <span class="s2">if </span><span class="s1">(shouldCreateWebpackStats) {</span>
                    <span class="s2">await </span><span class="s1">manifestLoader.loadWebpackStats(page, </span><span class="s0">'app'</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">await </span><span class="s1">manifestLoader.writeManifests({</span>
                    <span class="s1">devRewrites,</span>
                    <span class="s1">productionRewrites,</span>
                    <span class="s1">entrypoints</span>
                <span class="s1">});</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, _utils.processIssues)(currentEntryIssues, key, writtenEndpoint, dev, logErrors);</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">'app-route'</span><span class="s1">:</span>
            <span class="s1">{</span>
                <span class="s2">const </span><span class="s1">key = (</span><span class="s3">0</span><span class="s1">, _entrykey.getEntryKey)(</span><span class="s0">'app'</span><span class="s1">, </span><span class="s0">'server'</span><span class="s1">, page);</span>
                <span class="s2">const </span><span class="s1">writtenEndpoint = </span><span class="s2">await </span><span class="s1">route.endpoint.writeToDisk();</span>
                <span class="s1">hooks == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: hooks.handleWrittenEndpoint(key, writtenEndpoint, </span><span class="s2">false</span><span class="s1">);</span>
                <span class="s2">const </span><span class="s1">type = writtenEndpoint.type;</span>
                <span class="s2">await </span><span class="s1">manifestLoader.loadAppPathsManifest(page);</span>
                <span class="s2">if </span><span class="s1">(type === </span><span class="s0">'edge'</span><span class="s1">) {</span>
                    <span class="s2">await </span><span class="s1">manifestLoader.loadMiddlewareManifest(page, </span><span class="s0">'app'</span><span class="s1">);</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">manifestLoader.deleteMiddlewareManifest(key);</span>
                <span class="s1">}</span>
                <span class="s2">await </span><span class="s1">manifestLoader.writeManifests({</span>
                    <span class="s1">devRewrites,</span>
                    <span class="s1">productionRewrites,</span>
                    <span class="s1">entrypoints</span>
                <span class="s1">});</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, _utils.processIssues)(currentEntryIssues, key, writtenEndpoint, </span><span class="s2">true</span><span class="s1">, logErrors);</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s2">default</span><span class="s1">:</span>
            <span class="s1">{</span>
                <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`unknown route type </span><span class="s1">${route.type} </span><span class="s0">for </span><span class="s1">${page}</span><span class="s0">`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s0">&quot;E316&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s2">true</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">class </span><span class="s1">AssetMapper {</span>
    <span class="s4">/**</span>
   <span class="s4">* Overrides asset paths for a key and updates the mapping from path to key.</span>
   <span class="s4">*</span>
   <span class="s4">* </span><span class="s5">@param </span><span class="s4">key</span>
   <span class="s4">* </span><span class="s5">@param </span><span class="s4">assetPaths asset paths relative to the .next directory</span>
   <span class="s4">*/ </span><span class="s1">setPathsForKey(key, assetPaths) {</span>
        <span class="s2">this</span><span class="s1">.delete(key);</span>
        <span class="s2">const </span><span class="s1">newAssetPaths = </span><span class="s2">new </span><span class="s1">Set(assetPaths);</span>
        <span class="s2">this</span><span class="s1">.entryMap.set(key, newAssetPaths);</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">assetPath of newAssetPaths){</span>
            <span class="s2">let </span><span class="s1">assetPathKeys = </span><span class="s2">this</span><span class="s1">.assetMap.get(assetPath);</span>
            <span class="s2">if </span><span class="s1">(!assetPathKeys) {</span>
                <span class="s1">assetPathKeys = </span><span class="s2">new </span><span class="s1">Set();</span>
                <span class="s2">this</span><span class="s1">.assetMap.set(assetPath, assetPathKeys);</span>
            <span class="s1">}</span>
            <span class="s1">assetPathKeys.add(key);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s4">/**</span>
   <span class="s4">* Deletes the key and any asset only referenced by this key.</span>
   <span class="s4">*</span>
   <span class="s4">* </span><span class="s5">@param </span><span class="s4">key</span>
   <span class="s4">*/ </span><span class="s2">delete</span><span class="s1">(key) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">assetPath of </span><span class="s2">this</span><span class="s1">.getAssetPathsByKey(key)){</span>
            <span class="s2">const </span><span class="s1">assetPathKeys = </span><span class="s2">this</span><span class="s1">.assetMap.get(assetPath);</span>
            <span class="s1">assetPathKeys == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: assetPathKeys.delete(key);</span>
            <span class="s2">if </span><span class="s1">(!(assetPathKeys == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: assetPathKeys.size)) {</span>
                <span class="s2">this</span><span class="s1">.assetMap.delete(assetPath);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.entryMap.delete(key);</span>
    <span class="s1">}</span>
    <span class="s1">getAssetPathsByKey(key) {</span>
        <span class="s2">return </span><span class="s1">Array.from(</span><span class="s2">this</span><span class="s1">.entryMap.get(key) ?? []);</span>
    <span class="s1">}</span>
    <span class="s1">getKeysByAsset(path) {</span>
        <span class="s2">return </span><span class="s1">Array.from(</span><span class="s2">this</span><span class="s1">.assetMap.get(path) ?? []);</span>
    <span class="s1">}</span>
    <span class="s1">keys() {</span>
        <span class="s2">return this</span><span class="s1">.entryMap.keys();</span>
    <span class="s1">}</span>
    <span class="s1">constructor(){</span>
        <span class="s2">this</span><span class="s1">.entryMap = </span><span class="s2">new </span><span class="s1">Map();</span>
        <span class="s2">this</span><span class="s1">.assetMap = </span><span class="s2">new </span><span class="s1">Map();</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">hasEntrypointForKey(entrypoints, key, assetMapper) {</span>
    <span class="s2">const </span><span class="s1">{ type, page } = (</span><span class="s3">0</span><span class="s1">, _entrykey.splitEntryKey)(key);</span>
    <span class="s2">switch</span><span class="s1">(type){</span>
        <span class="s2">case </span><span class="s0">'app'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">entrypoints.app.has(page);</span>
        <span class="s2">case </span><span class="s0">'pages'</span><span class="s1">:</span>
            <span class="s2">switch</span><span class="s1">(page){</span>
                <span class="s2">case </span><span class="s0">'_app'</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">entrypoints.global.app != </span><span class="s2">null</span><span class="s1">;</span>
                <span class="s2">case </span><span class="s0">'_document'</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">entrypoints.global.document != </span><span class="s2">null</span><span class="s1">;</span>
                <span class="s2">case </span><span class="s0">'_error'</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">entrypoints.global.error != </span><span class="s2">null</span><span class="s1">;</span>
                <span class="s2">default</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">entrypoints.page.has(page);</span>
            <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">'root'</span><span class="s1">:</span>
            <span class="s2">switch</span><span class="s1">(page){</span>
                <span class="s2">case </span><span class="s0">'middleware'</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">entrypoints.global.middleware != </span><span class="s2">null</span><span class="s1">;</span>
                <span class="s2">case </span><span class="s0">'instrumentation'</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">entrypoints.global.instrumentation != </span><span class="s2">null</span><span class="s1">;</span>
                <span class="s2">default</span><span class="s1">:</span>
                    <span class="s2">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">'assets'</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">(!assetMapper) {</span>
                <span class="s2">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">assetMapper.getKeysByAsset(page).some((pageKey)=&gt;hasEntrypointForKey(entrypoints, pageKey, assetMapper));</span>
        <span class="s2">default</span><span class="s1">:</span>
            <span class="s1">{</span>
                <span class="s4">// validation that we covered all cases, this should never run.</span>
                <span class="s4">// eslint-disable-next-line @typescript-eslint/no-unused-vars</span>
                <span class="s2">const </span><span class="s1">_ = type;</span>
                <span class="s2">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">handleEntrypoints({ entrypoints, currentEntrypoints, currentEntryIssues, manifestLoader, devRewrites, logErrors, dev }) {</span>
    <span class="s1">currentEntrypoints.global.app = entrypoints.pagesAppEndpoint;</span>
    <span class="s1">currentEntrypoints.global.document = entrypoints.pagesDocumentEndpoint;</span>
    <span class="s1">currentEntrypoints.global.error = entrypoints.pagesErrorEndpoint;</span>
    <span class="s1">currentEntrypoints.global.instrumentation = entrypoints.instrumentation;</span>
    <span class="s1">currentEntrypoints.page.clear();</span>
    <span class="s1">currentEntrypoints.app.clear();</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[pathname, route] of entrypoints.routes){</span>
        <span class="s2">switch</span><span class="s1">(route.type){</span>
            <span class="s2">case </span><span class="s0">'page'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'page-api'</span><span class="s1">:</span>
                <span class="s1">currentEntrypoints.page.set(pathname, route);</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s2">case </span><span class="s0">'app-page'</span><span class="s1">:</span>
                <span class="s1">{</span>
                    <span class="s1">route.pages.forEach((page)=&gt;{</span>
                        <span class="s1">currentEntrypoints.app.set(page.originalName, {</span>
                            <span class="s1">type: </span><span class="s0">'app-page'</span><span class="s1">,</span>
                            <span class="s1">...page</span>
                        <span class="s1">});</span>
                    <span class="s1">});</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s2">case </span><span class="s0">'app-route'</span><span class="s1">:</span>
                <span class="s1">{</span>
                    <span class="s1">currentEntrypoints.app.set(route.originalName, route);</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s2">case </span><span class="s0">'conflict'</span><span class="s1">:</span>
                <span class="s1">_log.info(</span><span class="s0">`skipping </span><span class="s1">${pathname} </span><span class="s0">(</span><span class="s1">${route.type}</span><span class="s0">)`</span><span class="s1">);</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s2">default</span><span class="s1">:</span>
                <span class="s1">route;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(dev) {</span>
        <span class="s2">await </span><span class="s1">handleEntrypointsDevCleanup({</span>
            <span class="s1">currentEntryIssues,</span>
            <span class="s1">currentEntrypoints,</span>
            <span class="s1">...dev</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">{ middleware, instrumentation } = entrypoints;</span>
    <span class="s4">// We check for explicit true/false, since it's initialized to</span>
    <span class="s4">// undefined during the first loop (middlewareChanges event is</span>
    <span class="s4">// unnecessary during the first serve)</span>
    <span class="s2">if </span><span class="s1">(currentEntrypoints.global.middleware &amp;&amp; !middleware) {</span>
        <span class="s2">const </span><span class="s1">key = (</span><span class="s3">0</span><span class="s1">, _entrykey.getEntryKey)(</span><span class="s0">'root'</span><span class="s1">, </span><span class="s0">'server'</span><span class="s1">, </span><span class="s0">'middleware'</span><span class="s1">);</span>
        <span class="s4">// Went from middleware to no middleware</span>
        <span class="s2">await </span><span class="s1">(dev == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: dev.hooks.unsubscribeFromChanges(key));</span>
        <span class="s1">currentEntryIssues.delete(key);</span>
        <span class="s1">dev.hooks.sendHmr(</span><span class="s0">'middleware'</span><span class="s1">, {</span>
            <span class="s1">event: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.MIDDLEWARE_CHANGES</span>
        <span class="s1">});</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!currentEntrypoints.global.middleware &amp;&amp; middleware) {</span>
        <span class="s4">// Went from no middleware to middleware</span>
        <span class="s1">dev.hooks.sendHmr(</span><span class="s0">'middleware'</span><span class="s1">, {</span>
            <span class="s1">event: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.MIDDLEWARE_CHANGES</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">currentEntrypoints.global.middleware = middleware;</span>
    <span class="s2">if </span><span class="s1">(instrumentation) {</span>
        <span class="s2">const </span><span class="s1">processInstrumentation = async (name, prop)=&gt;{</span>
            <span class="s2">const </span><span class="s1">prettyName = {</span>
                <span class="s1">nodeJs: </span><span class="s0">'Node.js'</span><span class="s1">,</span>
                <span class="s1">edge: </span><span class="s0">'Edge'</span>
            <span class="s1">};</span>
            <span class="s2">const </span><span class="s1">finishBuilding = dev.hooks.startBuilding(</span><span class="s0">`instrumentation </span><span class="s1">${prettyName[prop]}</span><span class="s0">`</span><span class="s1">, undefined, </span><span class="s2">true</span><span class="s1">);</span>
            <span class="s2">const </span><span class="s1">key = (</span><span class="s3">0</span><span class="s1">, _entrykey.getEntryKey)(</span><span class="s0">'root'</span><span class="s1">, </span><span class="s0">'server'</span><span class="s1">, name);</span>
            <span class="s2">const </span><span class="s1">writtenEndpoint = </span><span class="s2">await </span><span class="s1">instrumentation[prop].writeToDisk();</span>
            <span class="s1">dev.hooks.handleWrittenEndpoint(key, writtenEndpoint, </span><span class="s2">false</span><span class="s1">);</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _utils.processIssues)(currentEntryIssues, key, writtenEndpoint, </span><span class="s2">false</span><span class="s1">, logErrors);</span>
            <span class="s1">finishBuilding();</span>
        <span class="s1">};</span>
        <span class="s2">await </span><span class="s1">processInstrumentation(</span><span class="s0">'instrumentation.nodeJs'</span><span class="s1">, </span><span class="s0">'nodeJs'</span><span class="s1">);</span>
        <span class="s2">await </span><span class="s1">processInstrumentation(</span><span class="s0">'instrumentation.edge'</span><span class="s1">, </span><span class="s0">'edge'</span><span class="s1">);</span>
        <span class="s2">await </span><span class="s1">manifestLoader.loadMiddlewareManifest(</span><span class="s0">'instrumentation'</span><span class="s1">, </span><span class="s0">'instrumentation'</span><span class="s1">);</span>
        <span class="s2">await </span><span class="s1">manifestLoader.writeManifests({</span>
            <span class="s1">devRewrites,</span>
            <span class="s1">productionRewrites: undefined,</span>
            <span class="s1">entrypoints: currentEntrypoints</span>
        <span class="s1">});</span>
        <span class="s1">dev.serverFields.actualInstrumentationHookFile = </span><span class="s0">'/instrumentation'</span><span class="s1">;</span>
        <span class="s2">await </span><span class="s1">dev.hooks.propagateServerField(</span><span class="s0">'actualInstrumentationHookFile'</span><span class="s1">, dev.serverFields.actualInstrumentationHookFile);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">dev.serverFields.actualInstrumentationHookFile = undefined;</span>
        <span class="s2">await </span><span class="s1">dev.hooks.propagateServerField(</span><span class="s0">'actualInstrumentationHookFile'</span><span class="s1">, dev.serverFields.actualInstrumentationHookFile);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(middleware) {</span>
        <span class="s2">const </span><span class="s1">key = (</span><span class="s3">0</span><span class="s1">, _entrykey.getEntryKey)(</span><span class="s0">'root'</span><span class="s1">, </span><span class="s0">'server'</span><span class="s1">, </span><span class="s0">'middleware'</span><span class="s1">);</span>
        <span class="s2">const </span><span class="s1">endpoint = middleware.endpoint;</span>
        <span class="s1">async </span><span class="s2">function </span><span class="s1">processMiddleware() {</span>
            <span class="s2">var </span><span class="s1">_manifestLoader_getMiddlewareManifest;</span>
            <span class="s2">const </span><span class="s1">finishBuilding = dev.hooks.startBuilding(</span><span class="s0">'middleware'</span><span class="s1">, undefined, </span><span class="s2">true</span><span class="s1">);</span>
            <span class="s2">const </span><span class="s1">writtenEndpoint = </span><span class="s2">await </span><span class="s1">endpoint.writeToDisk();</span>
            <span class="s1">dev.hooks.handleWrittenEndpoint(key, writtenEndpoint, </span><span class="s2">false</span><span class="s1">);</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _utils.processIssues)(currentEntryIssues, key, writtenEndpoint, </span><span class="s2">false</span><span class="s1">, logErrors);</span>
            <span class="s2">await </span><span class="s1">manifestLoader.loadMiddlewareManifest(</span><span class="s0">'middleware'</span><span class="s1">, </span><span class="s0">'middleware'</span><span class="s1">);</span>
            <span class="s2">const </span><span class="s1">middlewareConfig = (_manifestLoader_getMiddlewareManifest = manifestLoader.getMiddlewareManifest(key)) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _manifestLoader_getMiddlewareManifest.middleware[</span><span class="s0">'/'</span><span class="s1">];</span>
            <span class="s2">if </span><span class="s1">(dev &amp;&amp; middlewareConfig) {</span>
                <span class="s1">dev.serverFields.middleware = {</span>
                    <span class="s1">match: </span><span class="s2">null</span><span class="s1">,</span>
                    <span class="s1">page: </span><span class="s0">'/'</span><span class="s1">,</span>
                    <span class="s1">matchers: middlewareConfig.matchers</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
            <span class="s1">finishBuilding();</span>
        <span class="s1">}</span>
        <span class="s2">await </span><span class="s1">processMiddleware();</span>
        <span class="s2">if </span><span class="s1">(dev) {</span>
            <span class="s1">dev == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: dev.hooks.subscribeToChanges(key, </span><span class="s2">false</span><span class="s1">, endpoint, async ()=&gt;{</span>
                <span class="s2">const </span><span class="s1">finishBuilding = dev.hooks.startBuilding(</span><span class="s0">'middleware'</span><span class="s1">, undefined, </span><span class="s2">true</span><span class="s1">);</span>
                <span class="s2">await </span><span class="s1">processMiddleware();</span>
                <span class="s2">await </span><span class="s1">dev.hooks.propagateServerField(</span><span class="s0">'actualMiddlewareFile'</span><span class="s1">, dev.serverFields.actualMiddlewareFile);</span>
                <span class="s2">await </span><span class="s1">dev.hooks.propagateServerField(</span><span class="s0">'middleware'</span><span class="s1">, dev.serverFields.middleware);</span>
                <span class="s2">await </span><span class="s1">manifestLoader.writeManifests({</span>
                    <span class="s1">devRewrites,</span>
                    <span class="s1">productionRewrites: undefined,</span>
                    <span class="s1">entrypoints: currentEntrypoints</span>
                <span class="s1">});</span>
                <span class="s1">finishBuilding == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: finishBuilding();</span>
                <span class="s2">return </span><span class="s1">{</span>
                    <span class="s1">event: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.MIDDLEWARE_CHANGES</span>
                <span class="s1">};</span>
            <span class="s1">}, ()=&gt;{</span>
                <span class="s2">return </span><span class="s1">{</span>
                    <span class="s1">event: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.MIDDLEWARE_CHANGES</span>
                <span class="s1">};</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">manifestLoader.deleteMiddlewareManifest((</span><span class="s3">0</span><span class="s1">, _entrykey.getEntryKey)(</span><span class="s0">'root'</span><span class="s1">, </span><span class="s0">'server'</span><span class="s1">, </span><span class="s0">'middleware'</span><span class="s1">));</span>
        <span class="s1">dev.serverFields.actualMiddlewareFile = undefined;</span>
        <span class="s1">dev.serverFields.middleware = undefined;</span>
    <span class="s1">}</span>
    <span class="s2">await </span><span class="s1">dev.hooks.propagateServerField(</span><span class="s0">'actualMiddlewareFile'</span><span class="s1">, dev.serverFields.actualMiddlewareFile);</span>
    <span class="s2">await </span><span class="s1">dev.hooks.propagateServerField(</span><span class="s0">'middleware'</span><span class="s1">, dev.serverFields.middleware);</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">handleEntrypointsDevCleanup({ currentEntryIssues, currentEntrypoints, assetMapper, changeSubscriptions, clients, clientStates, hooks }) {</span>
    <span class="s4">// this needs to be first as `hasEntrypointForKey` uses the `assetMapper`</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key of assetMapper.keys()){</span>
        <span class="s2">if </span><span class="s1">(!hasEntrypointForKey(currentEntrypoints, key, assetMapper)) {</span>
            <span class="s1">assetMapper.delete(key);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key of changeSubscriptions.keys()){</span>
        <span class="s4">// middleware is handled separately</span>
        <span class="s2">if </span><span class="s1">(!hasEntrypointForKey(currentEntrypoints, key, assetMapper)) {</span>
            <span class="s2">await </span><span class="s1">hooks.unsubscribeFromChanges(key);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[key] of currentEntryIssues){</span>
        <span class="s2">if </span><span class="s1">(!hasEntrypointForKey(currentEntrypoints, key, assetMapper)) {</span>
            <span class="s1">currentEntryIssues.delete(key);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">client of clients){</span>
        <span class="s2">const </span><span class="s1">state = clientStates.get(client);</span>
        <span class="s2">if </span><span class="s1">(!state) {</span>
            <span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key of state.clientIssues.keys()){</span>
            <span class="s2">if </span><span class="s1">(!hasEntrypointForKey(currentEntrypoints, key, assetMapper)) {</span>
                <span class="s1">state.clientIssues.delete(key);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">id of state.subscriptions.keys()){</span>
            <span class="s2">if </span><span class="s1">(!hasEntrypointForKey(currentEntrypoints, (</span><span class="s3">0</span><span class="s1">, _entrykey.getEntryKey)(</span><span class="s0">'assets'</span><span class="s1">, </span><span class="s0">'client'</span><span class="s1">, id), assetMapper)) {</span>
                <span class="s1">hooks.unsubscribeFromHmrEvents(client, id);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s2">function </span><span class="s1">handlePagesErrorRoute({ currentEntryIssues, entrypoints, manifestLoader, devRewrites, productionRewrites, logErrors, hooks }) {</span>
    <span class="s2">if </span><span class="s1">(entrypoints.global.app) {</span>
        <span class="s2">const </span><span class="s1">key = (</span><span class="s3">0</span><span class="s1">, _entrykey.getEntryKey)(</span><span class="s0">'pages'</span><span class="s1">, </span><span class="s0">'server'</span><span class="s1">, </span><span class="s0">'_app'</span><span class="s1">);</span>
        <span class="s2">const </span><span class="s1">writtenEndpoint = </span><span class="s2">await </span><span class="s1">entrypoints.global.app.writeToDisk();</span>
        <span class="s1">hooks.handleWrittenEndpoint(key, writtenEndpoint, </span><span class="s2">false</span><span class="s1">);</span>
        <span class="s1">hooks.subscribeToChanges(key, </span><span class="s2">false</span><span class="s1">, entrypoints.global.app, ()=&gt;{</span>
            <span class="s4">// There's a special case for this in `../client/page-bootstrap.ts`.</span>
            <span class="s4">// https://github.com/vercel/next.js/blob/08d7a7e5189a835f5dcb82af026174e587575c0e/packages/next/src/client/page-bootstrap.ts#L69-L71</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">event: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.CLIENT_CHANGES</span>
            <span class="s1">};</span>
        <span class="s1">}, ()=&gt;{</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">action: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.RELOAD_PAGE,</span>
                <span class="s1">data: </span><span class="s0">'_app has changed (error route)'</span>
            <span class="s1">};</span>
        <span class="s1">});</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _utils.processIssues)(currentEntryIssues, key, writtenEndpoint, </span><span class="s2">false</span><span class="s1">, logErrors);</span>
    <span class="s1">}</span>
    <span class="s2">await </span><span class="s1">manifestLoader.loadBuildManifest(</span><span class="s0">'_app'</span><span class="s1">);</span>
    <span class="s2">await </span><span class="s1">manifestLoader.loadPagesManifest(</span><span class="s0">'_app'</span><span class="s1">);</span>
    <span class="s2">await </span><span class="s1">manifestLoader.loadFontManifest(</span><span class="s0">'_app'</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(entrypoints.global.document) {</span>
        <span class="s2">const </span><span class="s1">key = (</span><span class="s3">0</span><span class="s1">, _entrykey.getEntryKey)(</span><span class="s0">'pages'</span><span class="s1">, </span><span class="s0">'server'</span><span class="s1">, </span><span class="s0">'_document'</span><span class="s1">);</span>
        <span class="s2">const </span><span class="s1">writtenEndpoint = </span><span class="s2">await </span><span class="s1">entrypoints.global.document.writeToDisk();</span>
        <span class="s1">hooks.handleWrittenEndpoint(key, writtenEndpoint, </span><span class="s2">false</span><span class="s1">);</span>
        <span class="s1">hooks.subscribeToChanges(key, </span><span class="s2">false</span><span class="s1">, entrypoints.global.document, ()=&gt;{</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">action: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.RELOAD_PAGE,</span>
                <span class="s1">data: </span><span class="s0">'_document has changed (error route)'</span>
            <span class="s1">};</span>
        <span class="s1">}, (e)=&gt;{</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">action: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.RELOAD_PAGE,</span>
                <span class="s1">data: </span><span class="s0">`error in _document subscription (error route): </span><span class="s1">${e}</span><span class="s0">`</span>
            <span class="s1">};</span>
        <span class="s1">});</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _utils.processIssues)(currentEntryIssues, key, writtenEndpoint, </span><span class="s2">false</span><span class="s1">, logErrors);</span>
    <span class="s1">}</span>
    <span class="s2">await </span><span class="s1">manifestLoader.loadPagesManifest(</span><span class="s0">'_document'</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(entrypoints.global.error) {</span>
        <span class="s2">const </span><span class="s1">key = (</span><span class="s3">0</span><span class="s1">, _entrykey.getEntryKey)(</span><span class="s0">'pages'</span><span class="s1">, </span><span class="s0">'server'</span><span class="s1">, </span><span class="s0">'_error'</span><span class="s1">);</span>
        <span class="s2">const </span><span class="s1">writtenEndpoint = </span><span class="s2">await </span><span class="s1">entrypoints.global.error.writeToDisk();</span>
        <span class="s1">hooks.handleWrittenEndpoint(key, writtenEndpoint, </span><span class="s2">false</span><span class="s1">);</span>
        <span class="s1">hooks.subscribeToChanges(key, </span><span class="s2">false</span><span class="s1">, entrypoints.global.error, ()=&gt;{</span>
            <span class="s4">// There's a special case for this in `../client/page-bootstrap.ts`.</span>
            <span class="s4">// https://github.com/vercel/next.js/blob/08d7a7e5189a835f5dcb82af026174e587575c0e/packages/next/src/client/page-bootstrap.ts#L69-L71</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">event: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.CLIENT_CHANGES</span>
            <span class="s1">};</span>
        <span class="s1">}, (e)=&gt;{</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">action: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.RELOAD_PAGE,</span>
                <span class="s1">data: </span><span class="s0">`error in _error subscription: </span><span class="s1">${e}</span><span class="s0">`</span>
            <span class="s1">};</span>
        <span class="s1">});</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _utils.processIssues)(currentEntryIssues, key, writtenEndpoint, </span><span class="s2">false</span><span class="s1">, logErrors);</span>
    <span class="s1">}</span>
    <span class="s2">await </span><span class="s1">manifestLoader.loadClientBuildManifest(</span><span class="s0">'_error'</span><span class="s1">);</span>
    <span class="s2">await </span><span class="s1">manifestLoader.loadBuildManifest(</span><span class="s0">'_error'</span><span class="s1">);</span>
    <span class="s2">await </span><span class="s1">manifestLoader.loadPagesManifest(</span><span class="s0">'_error'</span><span class="s1">);</span>
    <span class="s2">await </span><span class="s1">manifestLoader.loadFontManifest(</span><span class="s0">'_error'</span><span class="s1">);</span>
    <span class="s2">await </span><span class="s1">manifestLoader.writeManifests({</span>
        <span class="s1">devRewrites,</span>
        <span class="s1">productionRewrites,</span>
        <span class="s1">entrypoints</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">removeRouteSuffix(route) {</span>
    <span class="s2">return </span><span class="s1">route.replace(</span><span class="s6">/\/route$/</span><span class="s1">, </span><span class="s0">''</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">addRouteSuffix(route) {</span>
    <span class="s2">return </span><span class="s1">route + </span><span class="s0">'/route'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">addMetadataIdToRoute(route) {</span>
    <span class="s2">return </span><span class="s1">route + </span><span class="s0">'/[__metadata_id__]'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">normalizedPageToTurbopackStructureRoute(route, ext) {</span>
    <span class="s2">let </span><span class="s1">entrypointKey = route;</span>
    <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _ismetadataroute.isMetadataRoute)(entrypointKey)) {</span>
        <span class="s1">entrypointKey = entrypointKey.endsWith(</span><span class="s0">'/route'</span><span class="s1">) ? entrypointKey.slice(</span><span class="s3">0</span><span class="s1">, -</span><span class="s0">'/route'</span><span class="s1">.length) : entrypointKey;</span>
        <span class="s2">if </span><span class="s1">(ext) {</span>
            <span class="s2">if </span><span class="s1">(entrypointKey.endsWith(</span><span class="s0">'/[__metadata_id__]'</span><span class="s1">)) {</span>
                <span class="s1">entrypointKey = entrypointKey.slice(</span><span class="s3">0</span><span class="s1">, -</span><span class="s0">'/[__metadata_id__]'</span><span class="s1">.length);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(entrypointKey.endsWith(</span><span class="s0">'/sitemap.xml'</span><span class="s1">) &amp;&amp; ext !== </span><span class="s0">'.xml'</span><span class="s1">) {</span>
                <span class="s4">// For dynamic sitemap route, remove the extension</span>
                <span class="s1">entrypointKey = entrypointKey.slice(</span><span class="s3">0</span><span class="s1">, -</span><span class="s0">'.xml'</span><span class="s1">.length);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">entrypointKey = entrypointKey + </span><span class="s0">'/route'</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">entrypointKey;</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=turbopack-utils.js.map</span></pre>
</body>
</html>