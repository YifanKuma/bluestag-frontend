<html>
<head>
<title>generate-interception-routes-rewrites.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
generate-interception-routes-rewrites.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/lib/generate-interception-routes-rewrites.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { NEXT_URL } from '../client/components/app-router-headers'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">extractInterceptionRouteInformation,</span><span class="s3">\n  </span><span class="s1">isInterceptionRouteAppPath,</span><span class="s3">\n</span><span class="s1">} from '../shared/lib/router/utils/interception-routes'</span><span class="s3">\n</span><span class="s1">import type { Rewrite } from './load-custom-routes'</span><span class="s3">\n</span><span class="s1">import { safePathToRegexp } from '../shared/lib/router/utils/route-match-utils'</span><span class="s3">\n</span><span class="s1">import type { DeepReadonly } from '../shared/lib/deep-readonly'</span><span class="s3">\n\n</span><span class="s1">// a function that converts normalised paths (e.g. /foo/[bar]/[baz]) to the format expected by pathToRegexp (e.g. /foo/:bar/:baz)</span><span class="s3">\n</span><span class="s1">function toPathToRegexpPath(path: string): string {</span><span class="s3">\n  </span><span class="s1">return path.replace(/</span><span class="s3">\\</span><span class="s1">[</span><span class="s3">\\</span><span class="s1">[?([^</span><span class="s3">\\</span><span class="s1">]]+)</span><span class="s3">\\</span><span class="s1">]</span><span class="s3">\\</span><span class="s1">]?/g, (_, capture) =&gt; {</span><span class="s3">\n    </span><span class="s1">// path-to-regexp only supports word characters, so we replace any non-word characters with underscores</span><span class="s3">\n    </span><span class="s1">const paramName = capture.replace(/</span><span class="s3">\\</span><span class="s1">W+/g, '_')</span><span class="s3">\n\n    </span><span class="s1">// handle catch-all segments (e.g. /foo/bar/[...baz] or /foo/bar/[[...baz]])</span><span class="s3">\n    </span><span class="s1">if (capture.startsWith('...')) {</span><span class="s3">\n      </span><span class="s1">return `:${capture.slice(3)}*`</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return ':' + paramName</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function generateInterceptionRoutesRewrites(</span><span class="s3">\n  </span><span class="s1">appPaths: string[],</span><span class="s3">\n  </span><span class="s1">basePath = ''</span><span class="s3">\n</span><span class="s1">): Rewrite[] {</span><span class="s3">\n  </span><span class="s1">const rewrites: Rewrite[] = []</span><span class="s3">\n\n  </span><span class="s1">for (const appPath of appPaths) {</span><span class="s3">\n    </span><span class="s1">if (isInterceptionRouteAppPath(appPath)) {</span><span class="s3">\n      </span><span class="s1">const { interceptingRoute, interceptedRoute } =</span><span class="s3">\n        </span><span class="s1">extractInterceptionRouteInformation(appPath)</span><span class="s3">\n\n      </span><span class="s1">const normalizedInterceptingRoute = `${</span><span class="s3">\n        </span><span class="s1">interceptingRoute !== '/' ? toPathToRegexpPath(interceptingRoute) : ''</span><span class="s3">\n      </span><span class="s1">}/(.*)?`</span><span class="s3">\n\n      </span><span class="s1">const normalizedInterceptedRoute = toPathToRegexpPath(interceptedRoute)</span><span class="s3">\n      </span><span class="s1">const normalizedAppPath = toPathToRegexpPath(appPath)</span><span class="s3">\n\n      </span><span class="s1">// pathToRegexp returns a regex that matches the path, but we need to</span><span class="s3">\n      </span><span class="s1">// convert it to a string that can be used in a header value</span><span class="s3">\n      </span><span class="s1">// to the format that Next/the proxy expects</span><span class="s3">\n      </span><span class="s1">let interceptingRouteRegex = safePathToRegexp(normalizedInterceptingRoute)</span><span class="s3">\n        </span><span class="s1">.toString()</span><span class="s3">\n        </span><span class="s1">.slice(2, -3)</span><span class="s3">\n\n      </span><span class="s1">rewrites.push({</span><span class="s3">\n        </span><span class="s1">source: `${basePath}${normalizedInterceptedRoute}`,</span><span class="s3">\n        </span><span class="s1">destination: `${basePath}${normalizedAppPath}`,</span><span class="s3">\n        </span><span class="s1">has: [</span><span class="s3">\n          </span><span class="s1">{</span><span class="s3">\n            </span><span class="s1">type: 'header',</span><span class="s3">\n            </span><span class="s1">key: NEXT_URL,</span><span class="s3">\n            </span><span class="s1">value: interceptingRouteRegex,</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">],</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return rewrites</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isInterceptionRouteRewrite(route: DeepReadonly&lt;Rewrite&gt;) {</span><span class="s3">\n  </span><span class="s1">// When we generate interception rewrites in the above implementation, we always do so with only a single `has` condition.</span><span class="s3">\n  </span><span class="s1">return route.has?.[0]?.key === NEXT_URL</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;generateInterceptionRoutesRewrites&quot;</span><span class="s0">,</span><span class="s1">&quot;isInterceptionRouteRewrite&quot;</span><span class="s0">,</span><span class="s1">&quot;toPathToRegexpPath&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;_&quot;</span><span class="s0">,</span><span class="s1">&quot;capture&quot;</span><span class="s0">,</span><span class="s1">&quot;paramName&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;appPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;basePath&quot;</span><span class="s0">,</span><span class="s1">&quot;rewrites&quot;</span><span class="s0">,</span><span class="s1">&quot;appPath&quot;</span><span class="s0">,</span><span class="s1">&quot;isInterceptionRouteAppPath&quot;</span><span class="s0">,</span><span class="s1">&quot;interceptingRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;interceptedRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;extractInterceptionRouteInformation&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedInterceptingRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedInterceptedRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedAppPath&quot;</span><span class="s0">,</span><span class="s1">&quot;interceptingRouteRegex&quot;</span><span class="s0">,</span><span class="s1">&quot;safePathToRegexp&quot;</span><span class="s0">,</span><span class="s1">&quot;toString&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;source&quot;</span><span class="s0">,</span><span class="s1">&quot;destination&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_URL&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;route&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;IAuBgBA,kCAAkC;eAAlCA;;IA0CAC,0BAA0B;eAA1BA;;;kCAjES;oCAIlB;iCAE0B;AAGjC,iIAAiI;AACjI,SAASC,mBAAmBC,IAAY;IACtC,OAAOA,KAAKC,OAAO,CAAC,uBAAuB,CAACC,GAAGC;QAC7C,uGAAuG;QACvG,MAAMC,YAAYD,QAAQF,OAAO,CAAC,QAAQ;QAE1C,4EAA4E;QAC5E,IAAIE,QAAQE,UAAU,CAAC,QAAQ;YAC7B,OAAO,CAAC,CAAC,EAAEF,QAAQG,KAAK,CAAC,GAAG,CAAC,CAAC;QAChC;QACA,OAAO,MAAMF;IACf;AACF;AAEO,SAASP,mCACdU,QAAkB,EAClBC,WAAW,EAAE;IAEb,MAAMC,WAAsB,EAAE;IAE9B,KAAK,MAAMC,WAAWH,SAAU;QAC9B,IAAII,IAAAA,8CAA0B,EAACD,UAAU;YACvC,MAAM,EAAEE,iBAAiB,EAAEC,gBAAgB,EAAE,GAC3CC,IAAAA,uDAAmC,EAACJ;YAEtC,MAAMK,8BAA8B,GAClCH,sBAAsB,MAAMb,mBAAmBa,qBAAqB,GACrE,MAAM,CAAC;YAER,MAAMI,6BAA6BjB,mBAAmBc;YACtD,MAAMI,oBAAoBlB,mBAAmBW;YAE7C,qEAAqE;YACrE,4DAA4D;YAC5D,4CAA4C;YAC5C,IAAIQ,yBAAyBC,IAAAA,iCAAgB,EAACJ,6BAC3CK,QAAQ,GACRd,KAAK,CAAC,GAAG,CAAC;YAEbG,SAASY,IAAI,CAAC;gBACZC,QAAQ,GAAGd,WAAWQ,4BAA4B;gBAClDO,aAAa,GAAGf,WAAWS,mBAAmB;gBAC9CO,KAAK;oBACH;wBACEC,MAAM;wBACNC,KAAKC,0BAAQ;wBACbC,OAAOV;oBACT;iBACD;YACH;QACF;IACF;IAEA,OAAOT;AACT;AAEO,SAASX,2BAA2B+B,KAA4B;QAE9DA,aAAAA;IADP,0HAA0H;IAC1H,OAAOA,EAAAA,aAAAA,MAAML,GAAG,sBAATK,cAAAA,UAAW,CAAC,EAAE,qBAAdA,YAAgBH,GAAG,MAAKC,0BAAQ;AACzC&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>