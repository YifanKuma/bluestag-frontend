<html>
<head>
<title>mock-request.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
mock-request.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/server/lib/mock-request.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type {</span><span class="s3">\n  </span><span class="s1">ServerResponse,</span><span class="s3">\n  </span><span class="s1">OutgoingHttpHeaders,</span><span class="s3">\n  </span><span class="s1">OutgoingHttpHeader,</span><span class="s3">\n  </span><span class="s1">IncomingMessage,</span><span class="s3">\n  </span><span class="s1">IncomingHttpHeaders,</span><span class="s3">\n</span><span class="s1">} from 'http'</span><span class="s3">\n</span><span class="s1">import type { Socket } from 'net'</span><span class="s3">\n</span><span class="s1">import type { TLSSocket } from 'tls'</span><span class="s3">\n\n</span><span class="s1">import Stream from 'stream'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">fromNodeOutgoingHttpHeaders,</span><span class="s3">\n  </span><span class="s1">toNodeOutgoingHttpHeaders,</span><span class="s3">\n</span><span class="s1">} from '../web/utils'</span><span class="s3">\n\n</span><span class="s1">interface MockedRequestOptions {</span><span class="s3">\n  </span><span class="s1">url: string</span><span class="s3">\n  </span><span class="s1">headers: IncomingHttpHeaders</span><span class="s3">\n  </span><span class="s1">method: string</span><span class="s3">\n  </span><span class="s1">readable?: Stream.Readable</span><span class="s3">\n  </span><span class="s1">socket?: Socket | null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class MockedRequest extends Stream.Readable implements IncomingMessage {</span><span class="s3">\n  </span><span class="s1">public url: string</span><span class="s3">\n  </span><span class="s1">public readonly statusCode?: number | undefined</span><span class="s3">\n  </span><span class="s1">public readonly statusMessage?: string | undefined</span><span class="s3">\n  </span><span class="s1">public readonly headers: IncomingHttpHeaders</span><span class="s3">\n  </span><span class="s1">public readonly method: string</span><span class="s3">\n\n  </span><span class="s1">// This is hardcoded for now, but can be updated to be configurable if needed.</span><span class="s3">\n  </span><span class="s1">public readonly httpVersion = '1.0'</span><span class="s3">\n  </span><span class="s1">public readonly httpVersionMajor = 1</span><span class="s3">\n  </span><span class="s1">public readonly httpVersionMinor = 0</span><span class="s3">\n\n  </span><span class="s1">private bodyReadable?: Stream.Readable</span><span class="s3">\n\n  </span><span class="s1">// If we don't actually have a socket, we'll just use a mock one that</span><span class="s3">\n  </span><span class="s1">// always returns false for the `encrypted` property and undefined for the</span><span class="s3">\n  </span><span class="s1">// `remoteAddress` property.</span><span class="s3">\n  </span><span class="s1">public socket: Socket = new Proxy&lt;TLSSocket&gt;({} as TLSSocket, {</span><span class="s3">\n    </span><span class="s1">get: (_target, prop) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (prop !== 'encrypted' &amp;&amp; prop !== 'remoteAddress') {</span><span class="s3">\n        </span><span class="s1">throw new Error('Method not implemented')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (prop === 'remoteAddress') return undefined</span><span class="s3">\n      </span><span class="s1">// For this mock request, always ensure we just respond with the encrypted</span><span class="s3">\n      </span><span class="s1">// set to false to ensure there's no odd leakages.</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">constructor({</span><span class="s3">\n    </span><span class="s1">url,</span><span class="s3">\n    </span><span class="s1">headers,</span><span class="s3">\n    </span><span class="s1">method,</span><span class="s3">\n    </span><span class="s1">socket = null,</span><span class="s3">\n    </span><span class="s1">readable,</span><span class="s3">\n  </span><span class="s1">}: MockedRequestOptions) {</span><span class="s3">\n    </span><span class="s1">super()</span><span class="s3">\n\n    </span><span class="s1">this.url = url</span><span class="s3">\n    </span><span class="s1">this.headers = headers</span><span class="s3">\n    </span><span class="s1">this.method = method</span><span class="s3">\n\n    </span><span class="s1">if (readable) {</span><span class="s3">\n      </span><span class="s1">this.bodyReadable = readable</span><span class="s3">\n      </span><span class="s1">this.bodyReadable.on('end', () =&gt; this.emit('end'))</span><span class="s3">\n      </span><span class="s1">this.bodyReadable.on('close', () =&gt; this.emit('close'))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (socket) {</span><span class="s3">\n      </span><span class="s1">this.socket = socket</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get headersDistinct(): NodeJS.Dict&lt;string[]&gt; {</span><span class="s3">\n    </span><span class="s1">const headers: NodeJS.Dict&lt;string[]&gt; = {}</span><span class="s3">\n    </span><span class="s1">for (const [key, value] of Object.entries(this.headers)) {</span><span class="s3">\n      </span><span class="s1">if (!value) continue</span><span class="s3">\n\n      </span><span class="s1">headers[key] = Array.isArray(value) ? value : [value]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return headers</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public _read(size: number): void {</span><span class="s3">\n    </span><span class="s1">if (this.bodyReadable) {</span><span class="s3">\n      </span><span class="s1">return this.bodyReadable._read(size)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this.emit('end')</span><span class="s3">\n      </span><span class="s1">this.emit('close')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The `connection` property is just an alias for the `socket` property.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @deprecated — since v13.0.0 - Use socket instead.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public get connection(): Socket {</span><span class="s3">\n    </span><span class="s1">return this.socket</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// The following methods are not implemented as they are not used in the</span><span class="s3">\n  </span><span class="s1">// Next.js codebase.</span><span class="s3">\n\n  </span><span class="s1">public get aborted(): boolean {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get complete(): boolean {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get trailers(): NodeJS.Dict&lt;string&gt; {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get trailersDistinct(): NodeJS.Dict&lt;string[]&gt; {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get rawTrailers(): string[] {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get rawHeaders(): string[] {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public setTimeout(): this {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface MockedResponseOptions {</span><span class="s3">\n  </span><span class="s1">statusCode?: number</span><span class="s3">\n  </span><span class="s1">socket?: Socket | null</span><span class="s3">\n  </span><span class="s1">headers?: OutgoingHttpHeaders</span><span class="s3">\n  </span><span class="s1">resWriter?: (chunk: Uint8Array | Buffer | string) =&gt; boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class MockedResponse extends Stream.Writable implements ServerResponse {</span><span class="s3">\n  </span><span class="s1">public statusCode: number</span><span class="s3">\n  </span><span class="s1">public statusMessage: string = ''</span><span class="s3">\n  </span><span class="s1">public finished = false</span><span class="s3">\n  </span><span class="s1">public headersSent = false</span><span class="s3">\n  </span><span class="s1">public readonly socket: Socket | null</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A promise that resolves to `true` when the response has been streamed.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @internal - used internally by Next.js</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public readonly hasStreamed: Promise&lt;boolean&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A list of buffers that have been written to the response.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @internal - used internally by Next.js</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public readonly buffers: Buffer[] = []</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The headers object that contains the headers that were initialized on the</span><span class="s3">\n   </span><span class="s1">* response and any that were added subsequently.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @internal - used internally by Next.js</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public readonly headers: Headers</span><span class="s3">\n\n  </span><span class="s1">private resWriter: MockedResponseOptions['resWriter']</span><span class="s3">\n\n  </span><span class="s1">public readonly headPromise: Promise&lt;void&gt;</span><span class="s3">\n  </span><span class="s1">private headPromiseResolve?: () =&gt; void</span><span class="s3">\n\n  </span><span class="s1">constructor(res: MockedResponseOptions = {}) {</span><span class="s3">\n    </span><span class="s1">super()</span><span class="s3">\n\n    </span><span class="s1">this.statusCode = res.statusCode ?? 200</span><span class="s3">\n    </span><span class="s1">this.socket = res.socket ?? null</span><span class="s3">\n    </span><span class="s1">this.headers = res.headers</span><span class="s3">\n      </span><span class="s1">? fromNodeOutgoingHttpHeaders(res.headers)</span><span class="s3">\n      </span><span class="s1">: new Headers()</span><span class="s3">\n\n    </span><span class="s1">this.headPromise = new Promise&lt;void&gt;((resolve) =&gt; {</span><span class="s3">\n      </span><span class="s1">this.headPromiseResolve = resolve</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">// Attach listeners for the `finish`, `end`, and `error` events to the</span><span class="s3">\n    </span><span class="s1">// `MockedResponse` instance.</span><span class="s3">\n    </span><span class="s1">this.hasStreamed = new Promise&lt;boolean&gt;((resolve, reject) =&gt; {</span><span class="s3">\n      </span><span class="s1">this.on('finish', () =&gt; resolve(true))</span><span class="s3">\n      </span><span class="s1">this.on('end', () =&gt; resolve(true))</span><span class="s3">\n      </span><span class="s1">this.on('error', (err) =&gt; reject(err))</span><span class="s3">\n    </span><span class="s1">}).then((val) =&gt; {</span><span class="s3">\n      </span><span class="s1">this.headPromiseResolve?.()</span><span class="s3">\n      </span><span class="s1">return val</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">if (res.resWriter) {</span><span class="s3">\n      </span><span class="s1">this.resWriter = res.resWriter</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public appendHeader(name: string, value: string | string[]): this {</span><span class="s3">\n    </span><span class="s1">const values = Array.isArray(value) ? value : [value]</span><span class="s3">\n    </span><span class="s1">for (const v of values) {</span><span class="s3">\n      </span><span class="s1">this.headers.append(name, v)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return this</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns true if the response has been sent, false otherwise.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @internal - used internally by Next.js</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public get isSent() {</span><span class="s3">\n    </span><span class="s1">return this.finished || this.headersSent</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The `connection` property is just an alias for the `socket` property.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @deprecated — since v13.0.0 - Use socket instead.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public get connection(): Socket | null {</span><span class="s3">\n    </span><span class="s1">return this.socket</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public write(chunk: Uint8Array | Buffer | string) {</span><span class="s3">\n    </span><span class="s1">if (this.resWriter) {</span><span class="s3">\n      </span><span class="s1">return this.resWriter(chunk)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.buffers.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk))</span><span class="s3">\n\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public end() {</span><span class="s3">\n    </span><span class="s1">this.finished = true</span><span class="s3">\n    </span><span class="s1">return super.end(...arguments)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* This method is a no-op because the `MockedResponse` instance is not</span><span class="s3">\n   </span><span class="s1">* actually connected to a socket. This method is not specified on the</span><span class="s3">\n   </span><span class="s1">* interface type for `ServerResponse` but is called by Node.js.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @see https://github.com/nodejs/node/pull/7949</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public _implicitHeader() {}</span><span class="s3">\n\n  </span><span class="s1">public _write(</span><span class="s3">\n    </span><span class="s1">chunk: Buffer | string,</span><span class="s3">\n    </span><span class="s1">_encoding: string,</span><span class="s3">\n    </span><span class="s1">callback: () =&gt; void</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">this.write(chunk)</span><span class="s3">\n\n    </span><span class="s1">// According to Node.js documentation, the callback MUST be invoked to</span><span class="s3">\n    </span><span class="s1">// signal that the write completed successfully. If this callback is not</span><span class="s3">\n    </span><span class="s1">// invoked, the 'finish' event will not be emitted.</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">// https://nodejs.org/docs/latest-v16.x/api/stream.html#writable_writechunk-encoding-callback</span><span class="s3">\n    </span><span class="s1">callback()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public writeHead(</span><span class="s3">\n    </span><span class="s1">statusCode: number,</span><span class="s3">\n    </span><span class="s1">statusMessage?: string | undefined,</span><span class="s3">\n    </span><span class="s1">headers?: OutgoingHttpHeaders | OutgoingHttpHeader[] | undefined</span><span class="s3">\n  </span><span class="s1">): this</span><span class="s3">\n  </span><span class="s1">public writeHead(</span><span class="s3">\n    </span><span class="s1">statusCode: number,</span><span class="s3">\n    </span><span class="s1">headers?: OutgoingHttpHeaders | OutgoingHttpHeader[] | undefined</span><span class="s3">\n  </span><span class="s1">): this</span><span class="s3">\n  </span><span class="s1">public writeHead(</span><span class="s3">\n    </span><span class="s1">statusCode: number,</span><span class="s3">\n    </span><span class="s1">statusMessage?:</span><span class="s3">\n      </span><span class="s1">| string</span><span class="s3">\n      </span><span class="s1">| OutgoingHttpHeaders</span><span class="s3">\n      </span><span class="s1">| OutgoingHttpHeader[]</span><span class="s3">\n      </span><span class="s1">| undefined,</span><span class="s3">\n    </span><span class="s1">headers?: OutgoingHttpHeaders | OutgoingHttpHeader[] | undefined</span><span class="s3">\n  </span><span class="s1">): this {</span><span class="s3">\n    </span><span class="s1">if (!headers &amp;&amp; typeof statusMessage !== 'string') {</span><span class="s3">\n      </span><span class="s1">headers = statusMessage</span><span class="s3">\n    </span><span class="s1">} else if (typeof statusMessage === 'string' &amp;&amp; statusMessage.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">this.statusMessage = statusMessage</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (headers) {</span><span class="s3">\n      </span><span class="s1">// When headers have been set with response.setHeader(), they will be</span><span class="s3">\n      </span><span class="s1">// merged with any headers passed to response.writeHead(), with the</span><span class="s3">\n      </span><span class="s1">// headers passed to response.writeHead() given precedence.</span><span class="s3">\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">// https://nodejs.org/api/http.html#responsewriteheadstatuscode-statusmessage-headers</span><span class="s3">\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">// For this reason, we need to only call `set` to ensure that this will</span><span class="s3">\n      </span><span class="s1">// overwrite any existing headers.</span><span class="s3">\n      </span><span class="s1">if (Array.isArray(headers)) {</span><span class="s3">\n        </span><span class="s1">// headers may be an Array where the keys and values are in the same list.</span><span class="s3">\n        </span><span class="s1">// It is not a list of tuples. So, the even-numbered offsets are key</span><span class="s3">\n        </span><span class="s1">// values, and the odd-numbered offsets are the associated values. The</span><span class="s3">\n        </span><span class="s1">// array is in the same format as request.rawHeaders.</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; headers.length; i += 2) {</span><span class="s3">\n          </span><span class="s1">// The header key is always a string according to the spec.</span><span class="s3">\n          </span><span class="s1">this.setHeader(headers[i] as string, headers[i + 1])</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">for (const [key, value] of Object.entries(headers)) {</span><span class="s3">\n          </span><span class="s1">// Skip undefined values</span><span class="s3">\n          </span><span class="s1">if (typeof value === 'undefined') continue</span><span class="s3">\n\n          </span><span class="s1">this.setHeader(key, value)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.statusCode = statusCode</span><span class="s3">\n    </span><span class="s1">this.headersSent = true</span><span class="s3">\n    </span><span class="s1">this.headPromiseResolve?.()</span><span class="s3">\n\n    </span><span class="s1">return this</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public hasHeader(name: string): boolean {</span><span class="s3">\n    </span><span class="s1">return this.headers.has(name)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public getHeader(name: string): string | undefined {</span><span class="s3">\n    </span><span class="s1">return this.headers.get(name) ?? undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public getHeaders(): OutgoingHttpHeaders {</span><span class="s3">\n    </span><span class="s1">return toNodeOutgoingHttpHeaders(this.headers)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public getHeaderNames(): string[] {</span><span class="s3">\n    </span><span class="s1">return Array.from(this.headers.keys())</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public setHeader(name: string, value: OutgoingHttpHeader) {</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(value)) {</span><span class="s3">\n      </span><span class="s1">// Because `set` here should override any existing values, we need to</span><span class="s3">\n      </span><span class="s1">// delete the existing values before setting the new ones via `append`.</span><span class="s3">\n      </span><span class="s1">this.headers.delete(name)</span><span class="s3">\n\n      </span><span class="s1">for (const v of value) {</span><span class="s3">\n        </span><span class="s1">this.headers.append(name, v)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (typeof value === 'number') {</span><span class="s3">\n      </span><span class="s1">this.headers.set(name, value.toString())</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this.headers.set(name, value)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return this</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public removeHeader(name: string): void {</span><span class="s3">\n    </span><span class="s1">this.headers.delete(name)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public flushHeaders(): void {</span><span class="s3">\n    </span><span class="s1">// This is a no-op because we don't actually have a socket to flush the</span><span class="s3">\n    </span><span class="s1">// headers to.</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// The following methods are not implemented as they are not used in the</span><span class="s3">\n  </span><span class="s1">// Next.js codebase.</span><span class="s3">\n\n  </span><span class="s1">public get strictContentLength(): boolean {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public writeEarlyHints() {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get req(): IncomingMessage {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public assignSocket() {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public detachSocket(): void {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public writeContinue(): void {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public writeProcessing(): void {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get upgrading(): boolean {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get chunkedEncoding(): boolean {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get shouldKeepAlive(): boolean {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get useChunkedEncodingByDefault(): boolean {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get sendDate(): boolean {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public setTimeout(): this {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public addTrailers(): void {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public setHeaders(): this {</span><span class="s3">\n    </span><span class="s1">throw new Error('Method not implemented.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface RequestResponseMockerOptions {</span><span class="s3">\n  </span><span class="s1">url: string</span><span class="s3">\n  </span><span class="s1">headers?: IncomingHttpHeaders</span><span class="s3">\n  </span><span class="s1">method?: string</span><span class="s3">\n  </span><span class="s1">bodyReadable?: Stream.Readable</span><span class="s3">\n  </span><span class="s1">resWriter?: (chunk: Uint8Array | Buffer | string) =&gt; boolean</span><span class="s3">\n  </span><span class="s1">socket?: Socket | null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function createRequestResponseMocks({</span><span class="s3">\n  </span><span class="s1">url,</span><span class="s3">\n  </span><span class="s1">headers = {},</span><span class="s3">\n  </span><span class="s1">method = 'GET',</span><span class="s3">\n  </span><span class="s1">bodyReadable,</span><span class="s3">\n  </span><span class="s1">resWriter,</span><span class="s3">\n  </span><span class="s1">socket = null,</span><span class="s3">\n</span><span class="s1">}: RequestResponseMockerOptions) {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">req: new MockedRequest({</span><span class="s3">\n      </span><span class="s1">url,</span><span class="s3">\n      </span><span class="s1">headers,</span><span class="s3">\n      </span><span class="s1">method,</span><span class="s3">\n      </span><span class="s1">socket,</span><span class="s3">\n      </span><span class="s1">readable: bodyReadable,</span><span class="s3">\n    </span><span class="s1">}),</span><span class="s3">\n    </span><span class="s1">res: new MockedResponse({ socket, resWriter }),</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;MockedRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;MockedResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;createRequestResponseMocks&quot;</span><span class="s0">,</span><span class="s1">&quot;Stream&quot;</span><span class="s0">,</span><span class="s1">&quot;Readable&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;headers&quot;</span><span class="s0">,</span><span class="s1">&quot;method&quot;</span><span class="s0">,</span><span class="s1">&quot;socket&quot;</span><span class="s0">,</span><span class="s1">&quot;readable&quot;</span><span class="s0">,</span><span class="s1">&quot;httpVersion&quot;</span><span class="s0">,</span><span class="s1">&quot;httpVersionMajor&quot;</span><span class="s0">,</span><span class="s1">&quot;httpVersionMinor&quot;</span><span class="s0">,</span><span class="s1">&quot;Proxy&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;_target&quot;</span><span class="s0">,</span><span class="s1">&quot;prop&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;bodyReadable&quot;</span><span class="s0">,</span><span class="s1">&quot;on&quot;</span><span class="s0">,</span><span class="s1">&quot;emit&quot;</span><span class="s0">,</span><span class="s1">&quot;headersDistinct&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;entries&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;_read&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">,</span><span class="s1">&quot;connection&quot;</span><span class="s0">,</span><span class="s1">&quot;aborted&quot;</span><span class="s0">,</span><span class="s1">&quot;complete&quot;</span><span class="s0">,</span><span class="s1">&quot;trailers&quot;</span><span class="s0">,</span><span class="s1">&quot;trailersDistinct&quot;</span><span class="s0">,</span><span class="s1">&quot;rawTrailers&quot;</span><span class="s0">,</span><span class="s1">&quot;rawHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;setTimeout&quot;</span><span class="s0">,</span><span class="s1">&quot;Writable&quot;</span><span class="s0">,</span><span class="s1">&quot;res&quot;</span><span class="s0">,</span><span class="s1">&quot;statusMessage&quot;</span><span class="s0">,</span><span class="s1">&quot;finished&quot;</span><span class="s0">,</span><span class="s1">&quot;headersSent&quot;</span><span class="s0">,</span><span class="s1">&quot;buffers&quot;</span><span class="s0">,</span><span class="s1">&quot;statusCode&quot;</span><span class="s0">,</span><span class="s1">&quot;fromNodeOutgoingHttpHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;Headers&quot;</span><span class="s0">,</span><span class="s1">&quot;headPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;headPromiseResolve&quot;</span><span class="s0">,</span><span class="s1">&quot;hasStreamed&quot;</span><span class="s0">,</span><span class="s1">&quot;reject&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;val&quot;</span><span class="s0">,</span><span class="s1">&quot;resWriter&quot;</span><span class="s0">,</span><span class="s1">&quot;appendHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;values&quot;</span><span class="s0">,</span><span class="s1">&quot;v&quot;</span><span class="s0">,</span><span class="s1">&quot;append&quot;</span><span class="s0">,</span><span class="s1">&quot;isSent&quot;</span><span class="s0">,</span><span class="s1">&quot;write&quot;</span><span class="s0">,</span><span class="s1">&quot;chunk&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;Buffer&quot;</span><span class="s0">,</span><span class="s1">&quot;isBuffer&quot;</span><span class="s0">,</span><span class="s1">&quot;from&quot;</span><span class="s0">,</span><span class="s1">&quot;end&quot;</span><span class="s0">,</span><span class="s1">&quot;arguments&quot;</span><span class="s0">,</span><span class="s1">&quot;_implicitHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;_write&quot;</span><span class="s0">,</span><span class="s1">&quot;_encoding&quot;</span><span class="s0">,</span><span class="s1">&quot;callback&quot;</span><span class="s0">,</span><span class="s1">&quot;writeHead&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;setHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;hasHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;getHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;getHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;toNodeOutgoingHttpHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;getHeaderNames&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;toString&quot;</span><span class="s0">,</span><span class="s1">&quot;removeHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;flushHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;strictContentLength&quot;</span><span class="s0">,</span><span class="s1">&quot;writeEarlyHints&quot;</span><span class="s0">,</span><span class="s1">&quot;req&quot;</span><span class="s0">,</span><span class="s1">&quot;assignSocket&quot;</span><span class="s0">,</span><span class="s1">&quot;detachSocket&quot;</span><span class="s0">,</span><span class="s1">&quot;writeContinue&quot;</span><span class="s0">,</span><span class="s1">&quot;writeProcessing&quot;</span><span class="s0">,</span><span class="s1">&quot;upgrading&quot;</span><span class="s0">,</span><span class="s1">&quot;chunkedEncoding&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldKeepAlive&quot;</span><span class="s0">,</span><span class="s1">&quot;useChunkedEncodingByDefault&quot;</span><span class="s0">,</span><span class="s1">&quot;sendDate&quot;</span><span class="s0">,</span><span class="s1">&quot;addTrailers&quot;</span><span class="s0">,</span><span class="s1">&quot;setHeaders&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>