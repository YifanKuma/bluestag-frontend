<html>
<head>
<title>json-schema.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #8c8c8c; font-style: italic;}
.s3 { color: #0033b3;}
.s4 { color: #067d17;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
json-schema.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* This is a fork of https://github.com/DefinitelyTyped/DefinitelyTyped/blob/13f63c2eb8d7479caf01ab8d72f9e3683368a8f5/types/json-schema/index.d.ts</span>
 <span class="s0">* We intentionally fork this because:</span>
 <span class="s0">* - ESLint ***ONLY*** supports JSONSchema v4</span>
 <span class="s0">* - We want to provide stricter types</span>
 <span class="s0">*/</span>
<span class="s0">/**</span>
 <span class="s0">* </span><span class="s2">@see </span><span class="s0">https://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.1</span>
 <span class="s0">*/</span>
<span class="s3">export </span><span class="s1">type JSONSchema4TypeName = </span><span class="s4">'any' </span><span class="s1">| </span><span class="s4">'array' </span><span class="s1">| </span><span class="s4">'boolean' </span><span class="s1">| </span><span class="s4">'integer' </span><span class="s1">| </span><span class="s4">'null' </span><span class="s1">| </span><span class="s4">'number' </span><span class="s1">| </span><span class="s4">'object' </span><span class="s1">| </span><span class="s4">'string'</span><span class="s1">;</span>
<span class="s0">/**</span>
 <span class="s0">* </span><span class="s2">@see </span><span class="s0">https://tools.ietf.org/html/draft-zyp-json-schema-04#section-3.5</span>
 <span class="s0">*/</span>
<span class="s3">export </span><span class="s1">type JSONSchema4Type = boolean | number | string | </span><span class="s3">null</span><span class="s1">;</span>
<span class="s3">export </span><span class="s1">type JSONSchema4TypeExtended = JSONSchema4Array | JSONSchema4Object | JSONSchema4Type;</span>
<span class="s3">export interface </span><span class="s1">JSONSchema4Object {</span>
    <span class="s1">[key: string]: JSONSchema4TypeExtended;</span>
<span class="s1">}</span>
<span class="s3">export interface </span><span class="s1">JSONSchema4Array </span><span class="s3">extends </span><span class="s1">Array&lt;JSONSchema4TypeExtended&gt; {</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* Meta schema</span>
 <span class="s0">*</span>
 <span class="s0">* Recommended values:</span>
 <span class="s0">* - 'http://json-schema.org/schema#'</span>
 <span class="s0">* - 'http://json-schema.org/hyper-schema#'</span>
 <span class="s0">* - 'http://json-schema.org/draft-04/schema#'</span>
 <span class="s0">* - 'http://json-schema.org/draft-04/hyper-schema#'</span>
 <span class="s0">* - 'http://json-schema.org/draft-03/schema#'</span>
 <span class="s0">* - 'http://json-schema.org/draft-03/hyper-schema#'</span>
 <span class="s0">*</span>
 <span class="s0">* </span><span class="s2">@see </span><span class="s0">https://tools.ietf.org/html/draft-handrews-json-schema-validation-01#section-5</span>
 <span class="s0">*/</span>
<span class="s3">export </span><span class="s1">type JSONSchema4Version = string;</span>
<span class="s0">/**</span>
 <span class="s0">* JSON Schema V4</span>
 <span class="s0">* </span><span class="s2">@see </span><span class="s0">https://tools.ietf.org/html/draft-zyp-json-schema-04</span>
 <span class="s0">*/</span>
<span class="s3">export </span><span class="s1">type JSONSchema4 = JSONSchema4AllOfSchema | JSONSchema4AnyOfSchema | JSONSchema4AnySchema | JSONSchema4ArraySchema | JSONSchema4BooleanSchema | JSONSchema4MultiSchema | JSONSchema4NullSchema | JSONSchema4NumberSchema | JSONSchema4ObjectSchema | JSONSchema4OneOfSchema | JSONSchema4RefSchema | JSONSchema4StringSchema;</span>
<span class="s3">interface </span><span class="s1">JSONSchema4Base {</span>
    <span class="s0">/**</span>
     <span class="s0">* Reusable definitions that can be referenced via `$ref`</span>
     <span class="s0">*/</span>
    <span class="s1">$defs?: Record&lt;string, JSONSchema4&gt; | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* Path to a schema defined in `definitions`/`$defs` that will form the base</span>
     <span class="s0">* for this schema.</span>
     <span class="s0">*</span>
     <span class="s0">* If you are defining an &quot;array&quot; schema (`schema: [ ... ]`) for your rule</span>
     <span class="s0">* then you should prefix this with `items/0` so that the validator can find</span>
     <span class="s0">* your definitions.</span>
     <span class="s0">*</span>
     <span class="s0">* eg: `'#/items/0/definitions/myDef'`</span>
     <span class="s0">*</span>
     <span class="s0">* Otherwise if you are defining an &quot;object&quot; schema (`schema: { ... }`) for</span>
     <span class="s0">* your rule you can directly reference your definitions</span>
     <span class="s0">*</span>
     <span class="s0">* eg: `'#/definitions/myDef'`</span>
     <span class="s0">*/</span>
    <span class="s1">$ref?: string | undefined;</span>
    <span class="s1">$schema?: JSONSchema4Version | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* (AND) Must be valid against all of the sub-schemas</span>
     <span class="s0">*/</span>
    <span class="s1">allOf?: JSONSchema4[] | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* (OR) Must be valid against any of the sub-schemas</span>
     <span class="s0">*/</span>
    <span class="s1">anyOf?: JSONSchema4[] | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* The default value for the item if not present</span>
     <span class="s0">*/</span>
    <span class="s3">default</span><span class="s1">?: JSONSchema4TypeExtended | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* Reusable definitions that can be referenced via `$ref`</span>
     <span class="s0">*/</span>
    <span class="s1">definitions?: Record&lt;string, JSONSchema4&gt; | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* This attribute is a string that provides a full description of the of</span>
     <span class="s0">* purpose the instance property.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s2">@see </span><span class="s0">https://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.22</span>
     <span class="s0">*/</span>
    <span class="s1">description?: string | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* The value of this property MUST be another schema which will provide</span>
     <span class="s0">* a base schema which the current schema will inherit from.  The</span>
     <span class="s0">* inheritance rules are such that any instance that is valid according</span>
     <span class="s0">* to the current schema MUST be valid according to the referenced</span>
     <span class="s0">* schema.  This MAY also be an array, in which case, the instance MUST</span>
     <span class="s0">* be valid for all the schemas in the array.  A schema that extends</span>
     <span class="s0">* another schema MAY define additional attributes, constrain existing</span>
     <span class="s0">* attributes, or add other constraints.</span>
     <span class="s0">*</span>
     <span class="s0">* Conceptually, the behavior of extends can be seen as validating an</span>
     <span class="s0">* instance against all constraints in the extending schema as well as</span>
     <span class="s0">* the extended schema(s).</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s2">@see </span><span class="s0">https://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.26</span>
     <span class="s0">*/</span>
    <span class="s3">extends</span><span class="s1">?: string | string[] | undefined;</span>
    <span class="s1">id?: string | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* (NOT) Must not be valid against the given schema</span>
     <span class="s0">*/</span>
    <span class="s1">not?: JSONSchema4 | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* (XOR) Must be valid against exactly one of the sub-schemas</span>
     <span class="s0">*/</span>
    <span class="s1">oneOf?: JSONSchema4[] | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* This attribute indicates if the instance must have a value, and not</span>
     <span class="s0">* be undefined. This is false by default, making the instance</span>
     <span class="s0">* optional.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s2">@see </span><span class="s0">https://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.7</span>
     <span class="s0">*/</span>
    <span class="s1">required?: boolean | string[] | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* This attribute is a string that provides a short description of the</span>
     <span class="s0">* instance property.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s2">@see </span><span class="s0">https://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.21</span>
     <span class="s0">*/</span>
    <span class="s1">title?: string | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* A single type, or a union of simple types</span>
     <span class="s0">*/</span>
    <span class="s1">type?: JSONSchema4TypeName | JSONSchema4TypeName[] | undefined;</span>
<span class="s1">}</span>
<span class="s3">export interface </span><span class="s1">JSONSchema4RefSchema </span><span class="s3">extends </span><span class="s1">JSONSchema4Base {</span>
    <span class="s1">$ref: string;</span>
    <span class="s1">type?: undefined;</span>
<span class="s1">}</span>
<span class="s3">export interface </span><span class="s1">JSONSchema4AllOfSchema </span><span class="s3">extends </span><span class="s1">JSONSchema4Base {</span>
    <span class="s1">allOf: JSONSchema4[];</span>
    <span class="s1">type?: undefined;</span>
<span class="s1">}</span>
<span class="s3">export interface </span><span class="s1">JSONSchema4AnyOfSchema </span><span class="s3">extends </span><span class="s1">JSONSchema4Base {</span>
    <span class="s1">anyOf: JSONSchema4[];</span>
    <span class="s1">type?: undefined;</span>
<span class="s1">}</span>
<span class="s3">export interface </span><span class="s1">JSONSchema4OneOfSchema </span><span class="s3">extends </span><span class="s1">JSONSchema4Base {</span>
    <span class="s1">oneOf: JSONSchema4[];</span>
    <span class="s1">type?: undefined;</span>
<span class="s1">}</span>
<span class="s3">export interface </span><span class="s1">JSONSchema4MultiSchema </span><span class="s3">extends </span><span class="s1">Omit&lt;JSONSchema4ObjectSchema, </span><span class="s4">'enum' </span><span class="s1">| </span><span class="s4">'type'</span><span class="s1">&gt;, Omit&lt;JSONSchema4ArraySchema, </span><span class="s4">'enum' </span><span class="s1">| </span><span class="s4">'type'</span><span class="s1">&gt;, Omit&lt;JSONSchema4StringSchema, </span><span class="s4">'enum' </span><span class="s1">| </span><span class="s4">'type'</span><span class="s1">&gt;, Omit&lt;JSONSchema4NumberSchema, </span><span class="s4">'enum' </span><span class="s1">| </span><span class="s4">'type'</span><span class="s1">&gt;, Omit&lt;JSONSchema4BooleanSchema, </span><span class="s4">'enum' </span><span class="s1">| </span><span class="s4">'type'</span><span class="s1">&gt;, Omit&lt;JSONSchema4NullSchema, </span><span class="s4">'enum' </span><span class="s1">| </span><span class="s4">'type'</span><span class="s1">&gt;, Omit&lt;JSONSchema4AnySchema, </span><span class="s4">'enum' </span><span class="s1">| </span><span class="s4">'type'</span><span class="s1">&gt; {</span>
    <span class="s0">/**</span>
     <span class="s0">* This provides an enumeration of all possible values that are valid</span>
     <span class="s0">* for the instance property. This MUST be an array, and each item in</span>
     <span class="s0">* the array represents a possible value for the instance value. If</span>
     <span class="s0">* this attribute is defined, the instance value MUST be one of the</span>
     <span class="s0">* values in the array in order for the schema to be valid.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s2">@see </span><span class="s0">https://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.19</span>
     <span class="s0">*/</span>
    <span class="s3">enum</span><span class="s1">?: JSONSchema4Type[];</span>
    <span class="s1">type: JSONSchema4TypeName[];</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* </span><span class="s2">@see </span><span class="s0">https://json-schema.org/understanding-json-schema/reference/object.html</span>
 <span class="s0">*/</span>
<span class="s3">export interface </span><span class="s1">JSONSchema4ObjectSchema </span><span class="s3">extends </span><span class="s1">JSONSchema4Base {</span>
    <span class="s0">/**</span>
     <span class="s0">* This attribute defines a schema for all properties that are not</span>
     <span class="s0">* explicitly defined in an object type definition. If specified, the</span>
     <span class="s0">* value MUST be a schema or a boolean. If false is provided, no</span>
     <span class="s0">* additional properties are allowed beyond the properties defined in</span>
     <span class="s0">* the schema. The default value is an empty schema which allows any</span>
     <span class="s0">* value for additional properties.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s2">@see </span><span class="s0">https://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.4</span>
     <span class="s0">*/</span>
    <span class="s1">additionalProperties?: boolean | JSONSchema4 | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* The `dependencies` keyword conditionally applies a sub-schema when a given</span>
     <span class="s0">* property is present. This schema is applied in the same way `allOf` applies</span>
     <span class="s0">* schemas. Nothing is merged or extended. Both schemas apply independently.</span>
     <span class="s0">*/</span>
    <span class="s1">dependencies?: Record&lt;string, JSONSchema4 | string[]&gt; | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* The maximum number of properties allowed for record-style schemas</span>
     <span class="s0">*/</span>
    <span class="s1">maxProperties?: number | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* The minimum number of properties required for record-style schemas</span>
     <span class="s0">*/</span>
    <span class="s1">minProperties?: number | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* This attribute is an object that defines the schema for a set of</span>
     <span class="s0">* property names of an object instance. The name of each property of</span>
     <span class="s0">* this attribute's object is a regular expression pattern in the ECMA</span>
     <span class="s0">* 262/Perl 5 format, while the value is a schema. If the pattern</span>
     <span class="s0">* matches the name of a property on the instance object, the value of</span>
     <span class="s0">* the instance's property MUST be valid against the pattern name's</span>
     <span class="s0">* schema value.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s2">@see </span><span class="s0">https://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.3</span>
     <span class="s0">*/</span>
    <span class="s1">patternProperties?: Record&lt;string, JSONSchema4&gt; | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* This attribute is an object with property definitions that define the</span>
     <span class="s0">* valid values of instance object property values. When the instance</span>
     <span class="s0">* value is an object, the property values of the instance object MUST</span>
     <span class="s0">* conform to the property definitions in this object. In this object,</span>
     <span class="s0">* each property definition's value MUST be a schema, and the property's</span>
     <span class="s0">* name MUST be the name of the instance property that it defines.  The</span>
     <span class="s0">* instance property value MUST be valid according to the schema from</span>
     <span class="s0">* the property definition. Properties are considered unordered, the</span>
     <span class="s0">* order of the instance properties MAY be in any order.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s2">@see </span><span class="s0">https://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.2</span>
     <span class="s0">*/</span>
    <span class="s1">properties?: Record&lt;string, JSONSchema4&gt; | undefined;</span>
    <span class="s1">type: </span><span class="s4">'object'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* </span><span class="s2">@see </span><span class="s0">https://json-schema.org/understanding-json-schema/reference/array.html</span>
 <span class="s0">*/</span>
<span class="s3">export interface </span><span class="s1">JSONSchema4ArraySchema </span><span class="s3">extends </span><span class="s1">JSONSchema4Base {</span>
    <span class="s0">/**</span>
     <span class="s0">* May only be defined when &quot;items&quot; is defined, and is a tuple of JSONSchemas.</span>
     <span class="s0">*</span>
     <span class="s0">* This provides a definition for additional items in an array instance</span>
     <span class="s0">* when tuple definitions of the items is provided.  This can be false</span>
     <span class="s0">* to indicate additional items in the array are not allowed, or it can</span>
     <span class="s0">* be a schema that defines the schema of the additional items.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s2">@see </span><span class="s0">https://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.6</span>
     <span class="s0">*/</span>
    <span class="s1">additionalItems?: boolean | JSONSchema4 | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* This attribute defines the allowed items in an instance array, and</span>
     <span class="s0">* MUST be a schema or an array of schemas.  The default value is an</span>
     <span class="s0">* empty schema which allows any value for items in the instance array.</span>
     <span class="s0">*</span>
     <span class="s0">* When this attribute value is a schema and the instance value is an</span>
     <span class="s0">* array, then all the items in the array MUST be valid according to the</span>
     <span class="s0">* schema.</span>
     <span class="s0">*</span>
     <span class="s0">* When this attribute value is an array of schemas and the instance</span>
     <span class="s0">* value is an array, each position in the instance array MUST conform</span>
     <span class="s0">* to the schema in the corresponding position for this array.  This</span>
     <span class="s0">* called tuple typing.  When tuple typing is used, additional items are</span>
     <span class="s0">* allowed, disallowed, or constrained by the &quot;additionalItems&quot;</span>
     <span class="s0">* (Section 5.6) attribute using the same rules as</span>
     <span class="s0">* &quot;additionalProperties&quot; (Section 5.4) for objects.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s2">@see </span><span class="s0">https://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.5</span>
     <span class="s0">*/</span>
    <span class="s1">items?: JSONSchema4 | JSONSchema4[] | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* Defines the maximum length of an array</span>
     <span class="s0">*/</span>
    <span class="s1">maxItems?: number | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* Defines the minimum length of an array</span>
     <span class="s0">*/</span>
    <span class="s1">minItems?: number | undefined;</span>
    <span class="s1">type: </span><span class="s4">'array'</span><span class="s1">;</span>
    <span class="s0">/**</span>
     <span class="s0">* Enforces that all items in the array are unique</span>
     <span class="s0">*/</span>
    <span class="s1">uniqueItems?: boolean | undefined;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* </span><span class="s2">@see </span><span class="s0">https://json-schema.org/understanding-json-schema/reference/string.html</span>
 <span class="s0">*/</span>
<span class="s3">export interface </span><span class="s1">JSONSchema4StringSchema </span><span class="s3">extends </span><span class="s1">JSONSchema4Base {</span>
    <span class="s3">enum</span><span class="s1">?: string[] | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* The `format` keyword allows for basic semantic identification of certain</span>
     <span class="s0">* kinds of string values that are commonly used.</span>
     <span class="s0">*</span>
     <span class="s0">* For example, because JSON doesn’t have a “DateTime” type, dates need to be</span>
     <span class="s0">* encoded as strings. `format` allows the schema author to indicate that the</span>
     <span class="s0">* string value should be interpreted as a date.</span>
     <span class="s0">*</span>
     <span class="s0">* ajv v6 provides a few built-in formats - all other strings will cause AJV</span>
     <span class="s0">* to throw during schema compilation</span>
     <span class="s0">*/</span>
    <span class="s1">format?: </span><span class="s4">'date' </span><span class="s1">| </span><span class="s4">'date-time' </span><span class="s1">| </span><span class="s4">'email' </span><span class="s1">| </span><span class="s4">'hostname' </span><span class="s1">| </span><span class="s4">'ipv4' </span><span class="s1">| </span><span class="s4">'ipv6' </span><span class="s1">| </span><span class="s4">'json-pointer' </span><span class="s1">| </span><span class="s4">'json-pointer-uri-fragment' </span><span class="s1">| </span><span class="s4">'regex' </span><span class="s1">| </span><span class="s4">'relative-json-pointer' </span><span class="s1">| </span><span class="s4">'time' </span><span class="s1">| </span><span class="s4">'uri' </span><span class="s1">| </span><span class="s4">'uri-reference' </span><span class="s1">| </span><span class="s4">'uri-template' </span><span class="s1">| </span><span class="s4">'url' </span><span class="s1">| </span><span class="s4">'uuid' </span><span class="s1">| undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* The maximum allowed length for the string</span>
     <span class="s0">*/</span>
    <span class="s1">maxLength?: number | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* The minimum allowed length for the string</span>
     <span class="s0">*/</span>
    <span class="s1">minLength?: number | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* The `pattern` keyword is used to restrict a string to a particular regular</span>
     <span class="s0">* expression. The regular expression syntax is the one defined in JavaScript</span>
     <span class="s0">* (ECMA 262 specifically) with Unicode support.</span>
     <span class="s0">*</span>
     <span class="s0">* When defining the regular expressions, it’s important to note that the</span>
     <span class="s0">* string is considered valid if the expression matches anywhere within the</span>
     <span class="s0">* string. For example, the regular expression &quot;p&quot; will match any string with</span>
     <span class="s0">* a p in it, such as &quot;apple&quot; not just a string that is simply &quot;p&quot;. Therefore,</span>
     <span class="s0">* it is usually less confusing, as a matter of course, to surround the</span>
     <span class="s0">* regular expression in ^...$, for example, &quot;^p$&quot;, unless there is a good</span>
     <span class="s0">* reason not to do so.</span>
     <span class="s0">*/</span>
    <span class="s1">pattern?: string | undefined;</span>
    <span class="s1">type: </span><span class="s4">'string'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* </span><span class="s2">@see </span><span class="s0">https://json-schema.org/understanding-json-schema/reference/numeric.html</span>
 <span class="s0">*/</span>
<span class="s3">export interface </span><span class="s1">JSONSchema4NumberSchema </span><span class="s3">extends </span><span class="s1">JSONSchema4Base {</span>
    <span class="s0">/**</span>
     <span class="s0">* This provides an enumeration of all possible values that are valid</span>
     <span class="s0">* for the instance property. This MUST be an array, and each item in</span>
     <span class="s0">* the array represents a possible value for the instance value. If</span>
     <span class="s0">* this attribute is defined, the instance value MUST be one of the</span>
     <span class="s0">* values in the array in order for the schema to be valid.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s2">@see </span><span class="s0">https://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.19</span>
     <span class="s0">*/</span>
    <span class="s3">enum</span><span class="s1">?: number[] | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* The exclusive minimum allowed value for the number</span>
     <span class="s0">* - `true` = `x &lt; maximum`</span>
     <span class="s0">* - `false` = `x &lt;= maximum`</span>
     <span class="s0">*</span>
     <span class="s0">* Default is `false`</span>
     <span class="s0">*/</span>
    <span class="s1">exclusiveMaximum?: boolean | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* Indicates whether or not `minimum` is the inclusive or exclusive minimum</span>
     <span class="s0">* - `true` = `x &gt; minimum`</span>
     <span class="s0">* - `false` = `x ≥ minimum`</span>
     <span class="s0">*</span>
     <span class="s0">* Default is `false`</span>
     <span class="s0">*/</span>
    <span class="s1">exclusiveMinimum?: boolean | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* The maximum allowed value for the number</span>
     <span class="s0">*/</span>
    <span class="s1">maximum?: number | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* The minimum allowed value for the number</span>
     <span class="s0">*/</span>
    <span class="s1">minimum?: number | undefined;</span>
    <span class="s0">/**</span>
     <span class="s0">* Numbers can be restricted to a multiple of a given number, using the</span>
     <span class="s0">* `multipleOf` keyword. It may be set to any positive number.</span>
     <span class="s0">*/</span>
    <span class="s1">multipleOf?: number | undefined;</span>
    <span class="s1">type: </span><span class="s4">'integer' </span><span class="s1">| </span><span class="s4">'number'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* </span><span class="s2">@see </span><span class="s0">https://json-schema.org/understanding-json-schema/reference/boolean.html</span>
 <span class="s0">*/</span>
<span class="s3">export interface </span><span class="s1">JSONSchema4BooleanSchema </span><span class="s3">extends </span><span class="s1">JSONSchema4Base {</span>
    <span class="s0">/**</span>
     <span class="s0">* This provides an enumeration of all possible values that are valid</span>
     <span class="s0">* for the instance property. This MUST be an array, and each item in</span>
     <span class="s0">* the array represents a possible value for the instance value. If</span>
     <span class="s0">* this attribute is defined, the instance value MUST be one of the</span>
     <span class="s0">* values in the array in order for the schema to be valid.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s2">@see </span><span class="s0">https://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.19</span>
     <span class="s0">*/</span>
    <span class="s3">enum</span><span class="s1">?: boolean[] | undefined;</span>
    <span class="s1">type: </span><span class="s4">'boolean'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* </span><span class="s2">@see </span><span class="s0">https://json-schema.org/understanding-json-schema/reference/null.html</span>
 <span class="s0">*/</span>
<span class="s3">export interface </span><span class="s1">JSONSchema4NullSchema </span><span class="s3">extends </span><span class="s1">JSONSchema4Base {</span>
    <span class="s0">/**</span>
     <span class="s0">* This provides an enumeration of all possible values that are valid</span>
     <span class="s0">* for the instance property. This MUST be an array, and each item in</span>
     <span class="s0">* the array represents a possible value for the instance value. If</span>
     <span class="s0">* this attribute is defined, the instance value MUST be one of the</span>
     <span class="s0">* values in the array in order for the schema to be valid.</span>
     <span class="s0">*</span>
     <span class="s0">* </span><span class="s2">@see </span><span class="s0">https://tools.ietf.org/html/draft-zyp-json-schema-03#section-5.19</span>
     <span class="s0">*/</span>
    <span class="s3">enum</span><span class="s1">?: </span><span class="s3">null</span><span class="s1">[] | undefined;</span>
    <span class="s1">type: </span><span class="s4">'null'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">export interface </span><span class="s1">JSONSchema4AnySchema </span><span class="s3">extends </span><span class="s1">JSONSchema4Base {</span>
    <span class="s1">type: </span><span class="s4">'any'</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">export </span><span class="s1">{};</span>
</pre>
</body>
</html>