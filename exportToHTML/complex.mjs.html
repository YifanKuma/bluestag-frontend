<html>
<head>
<title>complex.mjs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
complex.mjs</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">{ pipe, warning } from </span><span class="s2">'motion-utils'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ isCSSVariableToken } from </span><span class="s2">'../../animation/utils/is-css-variable.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ color } from </span><span class="s2">'../../value/types/color/index.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ complex, analyseComplexValue } from </span><span class="s2">'../../value/types/complex/index.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ mixColor } from </span><span class="s2">'./color.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ mixImmediate } from </span><span class="s2">'./immediate.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ mixNumber as mixNumber$1 } from </span><span class="s2">'./number.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ invisibleValues, mixVisibility } from </span><span class="s2">'./visibility.mjs'</span><span class="s1">;</span>

<span class="s0">function </span><span class="s1">mixNumber(a, b) {</span>
    <span class="s0">return </span><span class="s1">(p) =&gt; mixNumber$1(a, b, p);</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">getMixer(a) {</span>
    <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">a === </span><span class="s2">&quot;number&quot;</span><span class="s1">) {</span>
        <span class="s0">return </span><span class="s1">mixNumber;</span>
    <span class="s1">}</span>
    <span class="s0">else if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">a === </span><span class="s2">&quot;string&quot;</span><span class="s1">) {</span>
        <span class="s0">return </span><span class="s1">isCSSVariableToken(a)</span>
            <span class="s1">? mixImmediate</span>
            <span class="s1">: color.test(a)</span>
                <span class="s1">? mixColor</span>
                <span class="s1">: mixComplex;</span>
    <span class="s1">}</span>
    <span class="s0">else if </span><span class="s1">(Array.isArray(a)) {</span>
        <span class="s0">return </span><span class="s1">mixArray;</span>
    <span class="s1">}</span>
    <span class="s0">else if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">a === </span><span class="s2">&quot;object&quot;</span><span class="s1">) {</span>
        <span class="s0">return </span><span class="s1">color.test(a) ? mixColor : mixObject;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">mixImmediate;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">mixArray(a, b) {</span>
    <span class="s0">const </span><span class="s1">output = [...a];</span>
    <span class="s0">const </span><span class="s1">numValues = output.length;</span>
    <span class="s0">const </span><span class="s1">blendValue = a.map((v, i) =&gt; getMixer(v)(v, b[i]));</span>
    <span class="s0">return </span><span class="s1">(p) =&gt; {</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">; i &lt; numValues; i++) {</span>
            <span class="s1">output[i] = blendValue[i](p);</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">output;</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">mixObject(a, b) {</span>
    <span class="s0">const </span><span class="s1">output = { ...a, ...b };</span>
    <span class="s0">const </span><span class="s1">blendValue = {};</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">const </span><span class="s1">key </span><span class="s0">in </span><span class="s1">output) {</span>
        <span class="s0">if </span><span class="s1">(a[key] !== undefined &amp;&amp; b[key] !== undefined) {</span>
            <span class="s1">blendValue[key] = getMixer(a[key])(a[key], b[key]);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">(v) =&gt; {</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">const </span><span class="s1">key </span><span class="s0">in </span><span class="s1">blendValue) {</span>
            <span class="s1">output[key] = blendValue[key](v);</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">output;</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">matchOrder(origin, target) {</span>
    <span class="s0">const </span><span class="s1">orderedOrigin = [];</span>
    <span class="s0">const </span><span class="s1">pointers = { color: </span><span class="s3">0</span><span class="s1">, </span><span class="s0">var</span><span class="s1">: </span><span class="s3">0</span><span class="s1">, number: </span><span class="s3">0 </span><span class="s1">};</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">; i &lt; target.values.length; i++) {</span>
        <span class="s0">const </span><span class="s1">type = target.types[i];</span>
        <span class="s0">const </span><span class="s1">originIndex = origin.indexes[type][pointers[type]];</span>
        <span class="s0">const </span><span class="s1">originValue = origin.values[originIndex] ?? </span><span class="s3">0</span><span class="s1">;</span>
        <span class="s1">orderedOrigin[i] = originValue;</span>
        <span class="s1">pointers[type]++;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">orderedOrigin;</span>
<span class="s1">}</span>
<span class="s0">const </span><span class="s1">mixComplex = (origin, target) =&gt; {</span>
    <span class="s0">const </span><span class="s1">template = complex.createTransformer(target);</span>
    <span class="s0">const </span><span class="s1">originStats = analyseComplexValue(origin);</span>
    <span class="s0">const </span><span class="s1">targetStats = analyseComplexValue(target);</span>
    <span class="s0">const </span><span class="s1">canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length &amp;&amp;</span>
        <span class="s1">originStats.indexes.color.length === targetStats.indexes.color.length &amp;&amp;</span>
        <span class="s1">originStats.indexes.number.length &gt;= targetStats.indexes.number.length;</span>
    <span class="s0">if </span><span class="s1">(canInterpolate) {</span>
        <span class="s0">if </span><span class="s1">((invisibleValues.has(origin) &amp;&amp;</span>
            <span class="s1">!targetStats.values.length) ||</span>
            <span class="s1">(invisibleValues.has(target) &amp;&amp;</span>
                <span class="s1">!originStats.values.length)) {</span>
            <span class="s0">return </span><span class="s1">mixVisibility(origin, target);</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);</span>
    <span class="s1">}</span>
    <span class="s0">else </span><span class="s1">{</span>
        <span class="s1">warning(</span><span class="s0">true</span><span class="s1">, </span><span class="s2">`Complex values '</span><span class="s1">${origin}</span><span class="s2">' and '</span><span class="s1">${target}</span><span class="s2">' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`</span><span class="s1">, </span><span class="s2">&quot;complex-values-different&quot;</span><span class="s1">);</span>
        <span class="s0">return </span><span class="s1">mixImmediate(origin, target);</span>
    <span class="s1">}</span>
<span class="s1">};</span>

<span class="s0">export </span><span class="s1">{ getMixer, mixArray, mixComplex, mixObject };</span>
</pre>
</body>
</html>