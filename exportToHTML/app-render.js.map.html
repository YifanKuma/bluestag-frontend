<html>
<head>
<title>app-render.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
app-render.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/server/app-render/app-render.tsx&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type {</span><span class="s3">\n  </span><span class="s1">ActionResult,</span><span class="s3">\n  </span><span class="s1">DynamicParamTypesShort,</span><span class="s3">\n  </span><span class="s1">FlightRouterState,</span><span class="s3">\n  </span><span class="s1">RenderOpts,</span><span class="s3">\n  </span><span class="s1">Segment,</span><span class="s3">\n  </span><span class="s1">CacheNodeSeedData,</span><span class="s3">\n  </span><span class="s1">PreloadCallbacks,</span><span class="s3">\n  </span><span class="s1">RSCPayload,</span><span class="s3">\n  </span><span class="s1">FlightData,</span><span class="s3">\n  </span><span class="s1">InitialRSCPayload,</span><span class="s3">\n  </span><span class="s1">FlightDataPath,</span><span class="s3">\n</span><span class="s1">} from './types'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">workAsyncStorage,</span><span class="s3">\n  </span><span class="s1">type WorkStore,</span><span class="s3">\n</span><span class="s1">} from '../app-render/work-async-storage.external'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">PrerenderStoreModernRuntime,</span><span class="s3">\n  </span><span class="s1">RequestStore,</span><span class="s3">\n</span><span class="s1">} from '../app-render/work-unit-async-storage.external'</span><span class="s3">\n</span><span class="s1">import type { NextParsedUrlQuery } from '../request-meta'</span><span class="s3">\n</span><span class="s1">import type { LoaderTree } from '../lib/app-dir-module'</span><span class="s3">\n</span><span class="s1">import type { AppPageModule } from '../route-modules/app-page/module'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">ClientReferenceManifest,</span><span class="s3">\n  </span><span class="s1">ManifestNode,</span><span class="s3">\n</span><span class="s1">} from '../../build/webpack/plugins/flight-manifest-plugin'</span><span class="s3">\n</span><span class="s1">import type { DeepReadonly } from '../../shared/lib/deep-readonly'</span><span class="s3">\n</span><span class="s1">import type { BaseNextRequest, BaseNextResponse } from '../base-http'</span><span class="s3">\n</span><span class="s1">import type { IncomingHttpHeaders } from 'http'</span><span class="s3">\n\n</span><span class="s1">import React, { type ErrorInfo, type JSX } from 'react'</span><span class="s3">\n\n</span><span class="s1">import RenderResult, {</span><span class="s3">\n  </span><span class="s1">type AppPageRenderResultMetadata,</span><span class="s3">\n  </span><span class="s1">type RenderResultOptions,</span><span class="s3">\n</span><span class="s1">} from '../render-result'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">chainStreams,</span><span class="s3">\n  </span><span class="s1">renderToInitialFizzStream,</span><span class="s3">\n  </span><span class="s1">createDocumentClosingStream,</span><span class="s3">\n  </span><span class="s1">continueFizzStream,</span><span class="s3">\n  </span><span class="s1">continueDynamicPrerender,</span><span class="s3">\n  </span><span class="s1">continueStaticPrerender,</span><span class="s3">\n  </span><span class="s1">continueDynamicHTMLResume,</span><span class="s3">\n  </span><span class="s1">streamToBuffer,</span><span class="s3">\n  </span><span class="s1">streamToString,</span><span class="s3">\n</span><span class="s1">} from '../stream-utils/node-web-streams-helper'</span><span class="s3">\n</span><span class="s1">import { stripInternalQueries } from '../internal-utils'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">NEXT_HMR_REFRESH_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_PREFETCH_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_STATE_TREE_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_STALE_TIME_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_URL,</span><span class="s3">\n  </span><span class="s1">RSC_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_HMR_REFRESH_HASH_COOKIE,</span><span class="s3">\n  </span><span class="s1">NEXT_DID_POSTPONE_HEADER,</span><span class="s3">\n</span><span class="s1">} from '../../client/components/app-router-headers'</span><span class="s3">\n</span><span class="s1">import { createMetadataContext } from '../../lib/metadata/metadata-context'</span><span class="s3">\n</span><span class="s1">import { createRequestStoreForRender } from '../async-storage/request-store'</span><span class="s3">\n</span><span class="s1">import { createWorkStore } from '../async-storage/work-store'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">getAccessFallbackErrorTypeByStatus,</span><span class="s3">\n  </span><span class="s1">getAccessFallbackHTTPStatus,</span><span class="s3">\n  </span><span class="s1">isHTTPAccessFallbackError,</span><span class="s3">\n</span><span class="s1">} from '../../client/components/http-access-fallback/http-access-fallback'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">getURLFromRedirectError,</span><span class="s3">\n  </span><span class="s1">getRedirectStatusCodeFromError,</span><span class="s3">\n</span><span class="s1">} from '../../client/components/redirect'</span><span class="s3">\n</span><span class="s1">import { isRedirectError } from '../../client/components/redirect-error'</span><span class="s3">\n</span><span class="s1">import { getImplicitTags, type ImplicitTags } from '../lib/implicit-tags'</span><span class="s3">\n</span><span class="s1">import { AppRenderSpan, NextNodeServerSpan } from '../lib/trace/constants'</span><span class="s3">\n</span><span class="s1">import { getTracer } from '../lib/trace/tracer'</span><span class="s3">\n</span><span class="s1">import { FlightRenderResult } from './flight-render-result'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">createFlightReactServerErrorHandler,</span><span class="s3">\n  </span><span class="s1">createHTMLReactServerErrorHandler,</span><span class="s3">\n  </span><span class="s1">createHTMLErrorHandler,</span><span class="s3">\n  </span><span class="s1">type DigestedError,</span><span class="s3">\n  </span><span class="s1">isUserLandError,</span><span class="s3">\n  </span><span class="s1">getDigestForWellKnownError,</span><span class="s3">\n</span><span class="s1">} from './create-error-handler'</span><span class="s3">\n</span><span class="s1">import { dynamicParamTypes } from './get-short-dynamic-param-type'</span><span class="s3">\n</span><span class="s1">import { getSegmentParam } from './get-segment-param'</span><span class="s3">\n</span><span class="s1">import { getScriptNonceFromHeader } from './get-script-nonce-from-header'</span><span class="s3">\n</span><span class="s1">import { parseAndValidateFlightRouterState } from './parse-and-validate-flight-router-state'</span><span class="s3">\n</span><span class="s1">import { createFlightRouterStateFromLoaderTree } from './create-flight-router-state-from-loader-tree'</span><span class="s3">\n</span><span class="s1">import { handleAction } from './action-handler'</span><span class="s3">\n</span><span class="s1">import { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'</span><span class="s3">\n</span><span class="s1">import { warn, error } from '../../build/output/log'</span><span class="s3">\n</span><span class="s1">import { appendMutableCookies } from '../web/spec-extension/adapters/request-cookies'</span><span class="s3">\n</span><span class="s1">import { createServerInsertedHTML } from './server-inserted-html'</span><span class="s3">\n</span><span class="s1">import { getRequiredScripts } from './required-scripts'</span><span class="s3">\n</span><span class="s1">import { addPathPrefix } from '../../shared/lib/router/utils/add-path-prefix'</span><span class="s3">\n</span><span class="s1">import { makeGetServerInsertedHTML } from './make-get-server-inserted-html'</span><span class="s3">\n</span><span class="s1">import { walkTreeWithFlightRouterState } from './walk-tree-with-flight-router-state'</span><span class="s3">\n</span><span class="s1">import { createComponentTree, getRootParams } from './create-component-tree'</span><span class="s3">\n</span><span class="s1">import { getAssetQueryString } from './get-asset-query-string'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">getServerModuleMap,</span><span class="s3">\n  </span><span class="s1">setReferenceManifestsSingleton,</span><span class="s3">\n</span><span class="s1">} from './encryption-utils'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">DynamicState,</span><span class="s3">\n  </span><span class="s1">type PostponedState,</span><span class="s3">\n  </span><span class="s1">DynamicHTMLPreludeState,</span><span class="s3">\n  </span><span class="s1">parsePostponedState,</span><span class="s3">\n</span><span class="s1">} from './postponed-state'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">getDynamicDataPostponedState,</span><span class="s3">\n  </span><span class="s1">getDynamicHTMLPostponedState,</span><span class="s3">\n  </span><span class="s1">getPostponedFromState,</span><span class="s3">\n</span><span class="s1">} from './postponed-state'</span><span class="s3">\n</span><span class="s1">import { isDynamicServerError } from '../../client/components/hooks-server-context'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">useFlightStream,</span><span class="s3">\n  </span><span class="s1">createInlinedDataReadableStream,</span><span class="s3">\n</span><span class="s1">} from './use-flight-response'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">StaticGenBailoutError,</span><span class="s3">\n  </span><span class="s1">isStaticGenBailoutError,</span><span class="s3">\n</span><span class="s1">} from '../../client/components/static-generation-bailout'</span><span class="s3">\n</span><span class="s1">import { getStackWithoutErrorMessage } from '../../lib/format-server-error'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">accessedDynamicData,</span><span class="s3">\n  </span><span class="s1">createRenderInBrowserAbortSignal,</span><span class="s3">\n  </span><span class="s1">formatDynamicAPIAccesses,</span><span class="s3">\n  </span><span class="s1">isPrerenderInterruptedError,</span><span class="s3">\n  </span><span class="s1">createDynamicTrackingState,</span><span class="s3">\n  </span><span class="s1">createDynamicValidationState,</span><span class="s3">\n  </span><span class="s1">trackAllowedDynamicAccess,</span><span class="s3">\n  </span><span class="s1">throwIfDisallowedDynamic,</span><span class="s3">\n  </span><span class="s1">PreludeState,</span><span class="s3">\n  </span><span class="s1">consumeDynamicAccess,</span><span class="s3">\n  </span><span class="s1">type DynamicAccess,</span><span class="s3">\n  </span><span class="s1">logDisallowedDynamicError,</span><span class="s3">\n  </span><span class="s1">warnOnSyncDynamicError,</span><span class="s3">\n</span><span class="s1">} from './dynamic-rendering'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">getClientComponentLoaderMetrics,</span><span class="s3">\n  </span><span class="s1">wrapClientComponentLoader,</span><span class="s3">\n</span><span class="s1">} from '../client-component-renderer-logger'</span><span class="s3">\n</span><span class="s1">import { createServerModuleMap } from './action-utils'</span><span class="s3">\n</span><span class="s1">import { isNodeNextRequest } from '../base-http/helpers'</span><span class="s3">\n</span><span class="s1">import { parseRelativeUrl } from '../../shared/lib/router/utils/parse-relative-url'</span><span class="s3">\n</span><span class="s1">import AppRouter from '../../client/components/app-router'</span><span class="s3">\n</span><span class="s1">import type { ServerComponentsHmrCache } from '../response-cache'</span><span class="s3">\n</span><span class="s1">import type { RequestErrorContext } from '../instrumentation/types'</span><span class="s3">\n</span><span class="s1">import { getIsPossibleServerAction } from '../lib/server-action-request-meta'</span><span class="s3">\n</span><span class="s1">import { createInitialRouterState } from '../../client/components/router-reducer/create-initial-router-state'</span><span class="s3">\n</span><span class="s1">import { createMutableActionQueue } from '../../client/components/app-router-instance'</span><span class="s3">\n</span><span class="s1">import { getRevalidateReason } from '../instrumentation/utils'</span><span class="s3">\n</span><span class="s1">import { PAGE_SEGMENT_KEY } from '../../shared/lib/segment'</span><span class="s3">\n</span><span class="s1">import type { FallbackRouteParams } from '../request/fallback-params'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">prerenderAndAbortInSequentialTasksWithStages,</span><span class="s3">\n  </span><span class="s1">processPrelude,</span><span class="s3">\n</span><span class="s1">} from './app-render-prerender-utils'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">type ReactServerPrerenderResult,</span><span class="s3">\n  </span><span class="s1">ReactServerResult,</span><span class="s3">\n  </span><span class="s1">createReactServerPrerenderResult,</span><span class="s3">\n  </span><span class="s1">createReactServerPrerenderResultFromRender,</span><span class="s3">\n  </span><span class="s1">prerenderAndAbortInSequentialTasks,</span><span class="s3">\n</span><span class="s1">} from './app-render-prerender-utils'</span><span class="s3">\n</span><span class="s1">import { printDebugThrownValueForProspectiveRender } from './prospective-render-utils'</span><span class="s3">\n</span><span class="s1">import { scheduleInSequentialTasks } from './app-render-render-utils'</span><span class="s3">\n</span><span class="s1">import { waitAtLeastOneReactRenderTask } from '../../lib/scheduler'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">workUnitAsyncStorage,</span><span class="s3">\n  </span><span class="s1">type PrerenderStore,</span><span class="s3">\n</span><span class="s1">} from './work-unit-async-storage.external'</span><span class="s3">\n</span><span class="s1">import { CacheSignal } from './cache-signal'</span><span class="s3">\n</span><span class="s1">import { getTracedMetadata } from '../lib/trace/utils'</span><span class="s3">\n</span><span class="s1">import { InvariantError } from '../../shared/lib/invariant-error'</span><span class="s3">\n\n</span><span class="s1">import { HTML_CONTENT_TYPE_HEADER, INFINITE_CACHE } from '../../lib/constants'</span><span class="s3">\n</span><span class="s1">import { createComponentStylesAndScripts } from './create-component-styles-and-scripts'</span><span class="s3">\n</span><span class="s1">import { parseLoaderTree } from './parse-loader-tree'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">createPrerenderResumeDataCache,</span><span class="s3">\n  </span><span class="s1">createRenderResumeDataCache,</span><span class="s3">\n  </span><span class="s1">type PrerenderResumeDataCache,</span><span class="s3">\n  </span><span class="s1">type RenderResumeDataCache,</span><span class="s3">\n</span><span class="s1">} from '../resume-data-cache/resume-data-cache'</span><span class="s3">\n</span><span class="s1">import type { MetadataErrorType } from '../../lib/metadata/resolve-metadata'</span><span class="s3">\n</span><span class="s1">import isError from '../../lib/is-error'</span><span class="s3">\n</span><span class="s1">import { createServerInsertedMetadata } from './metadata-insertion/create-server-inserted-metadata'</span><span class="s3">\n</span><span class="s1">import { getPreviouslyRevalidatedTags } from '../server-utils'</span><span class="s3">\n</span><span class="s1">import { executeRevalidates } from '../revalidation-utils'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">trackPendingChunkLoad,</span><span class="s3">\n  </span><span class="s1">trackPendingImport,</span><span class="s3">\n  </span><span class="s1">trackPendingModules,</span><span class="s3">\n</span><span class="s1">} from './module-loading/track-module-loading.external'</span><span class="s3">\n</span><span class="s1">import { isReactLargeShellError } from './react-large-shell-error'</span><span class="s3">\n</span><span class="s1">import type { GlobalErrorComponent } from '../../client/components/builtin/global-error'</span><span class="s3">\n</span><span class="s1">import { normalizeConventionFilePath } from './segment-explorer-path'</span><span class="s3">\n</span><span class="s1">import { getRequestMeta } from '../request-meta'</span><span class="s3">\n</span><span class="s1">import { getDynamicParam } from '../../shared/lib/router/utils/get-dynamic-param'</span><span class="s3">\n</span><span class="s1">import type { ExperimentalConfig } from '../config-shared'</span><span class="s3">\n</span><span class="s1">import type { Params } from '../request/params'</span><span class="s3">\n</span><span class="s1">import { createPromiseWithResolvers } from '../../shared/lib/promise-with-resolvers'</span><span class="s3">\n\n</span><span class="s1">export type GetDynamicParamFromSegment = (</span><span class="s3">\n  </span><span class="s1">// [slug] / [[slug]] / [...slug]</span><span class="s3">\n  </span><span class="s1">segment: string</span><span class="s3">\n</span><span class="s1">) =&gt; DynamicParam | null</span><span class="s3">\n\n</span><span class="s1">export type DynamicParam = {</span><span class="s3">\n  </span><span class="s1">param: string</span><span class="s3">\n  </span><span class="s1">value: string | string[] | null</span><span class="s3">\n  </span><span class="s1">treeSegment: Segment</span><span class="s3">\n  </span><span class="s1">type: DynamicParamTypesShort</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type GenerateFlight = typeof generateDynamicFlightRenderResult</span><span class="s3">\n\n</span><span class="s1">export type AppSharedContext = {</span><span class="s3">\n  </span><span class="s1">buildId: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type AppRenderContext = {</span><span class="s3">\n  </span><span class="s1">sharedContext: AppSharedContext</span><span class="s3">\n  </span><span class="s1">workStore: WorkStore</span><span class="s3">\n  </span><span class="s1">url: ReturnType&lt;typeof parseRelativeUrl&gt;</span><span class="s3">\n  </span><span class="s1">componentMod: AppPageModule</span><span class="s3">\n  </span><span class="s1">renderOpts: RenderOpts</span><span class="s3">\n  </span><span class="s1">parsedRequestHeaders: ParsedRequestHeaders</span><span class="s3">\n  </span><span class="s1">getDynamicParamFromSegment: GetDynamicParamFromSegment</span><span class="s3">\n  </span><span class="s1">query: NextParsedUrlQuery</span><span class="s3">\n  </span><span class="s1">isPrefetch: boolean</span><span class="s3">\n  </span><span class="s1">isPossibleServerAction: boolean</span><span class="s3">\n  </span><span class="s1">requestTimestamp: number</span><span class="s3">\n  </span><span class="s1">appUsingSizeAdjustment: boolean</span><span class="s3">\n  </span><span class="s1">flightRouterState?: FlightRouterState</span><span class="s3">\n  </span><span class="s1">requestId: string</span><span class="s3">\n  </span><span class="s1">pagePath: string</span><span class="s3">\n  </span><span class="s1">clientReferenceManifest: DeepReadonly&lt;ClientReferenceManifest&gt;</span><span class="s3">\n  </span><span class="s1">assetPrefix: string</span><span class="s3">\n  </span><span class="s1">isNotFoundPath: boolean</span><span class="s3">\n  </span><span class="s1">nonce: string | undefined</span><span class="s3">\n  </span><span class="s1">res: BaseNextResponse</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* For now, the implicit tags are common for the whole route. If we ever start</span><span class="s3">\n   </span><span class="s1">* rendering/revalidating segments independently, they need to move to the</span><span class="s3">\n   </span><span class="s1">* work unit store.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">implicitTags: ImplicitTags</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface ParseRequestHeadersOptions {</span><span class="s3">\n  </span><span class="s1">readonly isDevWarmup: undefined | boolean</span><span class="s3">\n  </span><span class="s1">readonly isRoutePPREnabled: boolean</span><span class="s3">\n  </span><span class="s1">readonly previewModeId: string | undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const flightDataPathHeadKey = 'h'</span><span class="s3">\n</span><span class="s1">const getFlightViewportKey = (requestId: string) =&gt; requestId + 'v'</span><span class="s3">\n</span><span class="s1">const getFlightMetadataKey = (requestId: string) =&gt; requestId + 'm'</span><span class="s3">\n\n</span><span class="s1">const filterStackFrame =</span><span class="s3">\n  </span><span class="s1">process.env.NODE_ENV !== 'production'</span><span class="s3">\n    </span><span class="s1">? (require('../lib/source-maps') as typeof import('../lib/source-maps'))</span><span class="s3">\n        </span><span class="s1">.filterStackFrameDEV</span><span class="s3">\n    </span><span class="s1">: undefined</span><span class="s3">\n\n</span><span class="s1">interface ParsedRequestHeaders {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Router state provided from the client-side router. Used to handle rendering</span><span class="s3">\n   </span><span class="s1">* from the common layout down. This value will be undefined if the request is</span><span class="s3">\n   </span><span class="s1">* not a client-side navigation request, or if the request is a prefetch</span><span class="s3">\n   </span><span class="s1">* request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readonly flightRouterState: FlightRouterState | undefined</span><span class="s3">\n  </span><span class="s1">readonly isPrefetchRequest: boolean</span><span class="s3">\n  </span><span class="s1">readonly isRuntimePrefetchRequest: boolean</span><span class="s3">\n  </span><span class="s1">readonly isRouteTreePrefetchRequest: boolean</span><span class="s3">\n  </span><span class="s1">readonly isDevWarmupRequest: boolean</span><span class="s3">\n  </span><span class="s1">readonly isHmrRefresh: boolean</span><span class="s3">\n  </span><span class="s1">readonly isRSCRequest: boolean</span><span class="s3">\n  </span><span class="s1">readonly nonce: string | undefined</span><span class="s3">\n  </span><span class="s1">readonly previouslyRevalidatedTags: string[]</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function parseRequestHeaders(</span><span class="s3">\n  </span><span class="s1">headers: IncomingHttpHeaders,</span><span class="s3">\n  </span><span class="s1">options: ParseRequestHeadersOptions</span><span class="s3">\n</span><span class="s1">): ParsedRequestHeaders {</span><span class="s3">\n  </span><span class="s1">const isDevWarmupRequest = options.isDevWarmup === true</span><span class="s3">\n\n  </span><span class="s1">// dev warmup requests are treated as prefetch RSC requests</span><span class="s3">\n  </span><span class="s1">// runtime prefetch requests are *not* treated as prefetch requests</span><span class="s3">\n  </span><span class="s1">// (TODO: this is confusing, we should refactor this to express this better)</span><span class="s3">\n  </span><span class="s1">const isPrefetchRequest =</span><span class="s3">\n    </span><span class="s1">isDevWarmupRequest || headers[NEXT_ROUTER_PREFETCH_HEADER] === '1'</span><span class="s3">\n\n  </span><span class="s1">const isRuntimePrefetchRequest = headers[NEXT_ROUTER_PREFETCH_HEADER] === '2'</span><span class="s3">\n\n  </span><span class="s1">const isHmrRefresh = headers[NEXT_HMR_REFRESH_HEADER] !== undefined</span><span class="s3">\n\n  </span><span class="s1">// dev warmup requests are treated as prefetch RSC requests</span><span class="s3">\n  </span><span class="s1">const isRSCRequest = isDevWarmupRequest || headers[RSC_HEADER] !== undefined</span><span class="s3">\n\n  </span><span class="s1">const shouldProvideFlightRouterState =</span><span class="s3">\n    </span><span class="s1">isRSCRequest &amp;&amp; (!isPrefetchRequest || !options.isRoutePPREnabled)</span><span class="s3">\n\n  </span><span class="s1">const flightRouterState = shouldProvideFlightRouterState</span><span class="s3">\n    </span><span class="s1">? parseAndValidateFlightRouterState(headers[NEXT_ROUTER_STATE_TREE_HEADER])</span><span class="s3">\n    </span><span class="s1">: undefined</span><span class="s3">\n\n  </span><span class="s1">// Checks if this is a prefetch of the Route Tree by the Segment Cache</span><span class="s3">\n  </span><span class="s1">const isRouteTreePrefetchRequest =</span><span class="s3">\n    </span><span class="s1">headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER] === '/_tree'</span><span class="s3">\n\n  </span><span class="s1">const csp =</span><span class="s3">\n    </span><span class="s1">headers['content-security-policy'] ||</span><span class="s3">\n    </span><span class="s1">headers['content-security-policy-report-only']</span><span class="s3">\n\n  </span><span class="s1">const nonce =</span><span class="s3">\n    </span><span class="s1">typeof csp === 'string' ? getScriptNonceFromHeader(csp) : undefined</span><span class="s3">\n\n  </span><span class="s1">const previouslyRevalidatedTags = getPreviouslyRevalidatedTags(</span><span class="s3">\n    </span><span class="s1">headers,</span><span class="s3">\n    </span><span class="s1">options.previewModeId</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">flightRouterState,</span><span class="s3">\n    </span><span class="s1">isPrefetchRequest,</span><span class="s3">\n    </span><span class="s1">isRuntimePrefetchRequest,</span><span class="s3">\n    </span><span class="s1">isRouteTreePrefetchRequest,</span><span class="s3">\n    </span><span class="s1">isHmrRefresh,</span><span class="s3">\n    </span><span class="s1">isRSCRequest,</span><span class="s3">\n    </span><span class="s1">isDevWarmupRequest,</span><span class="s3">\n    </span><span class="s1">nonce,</span><span class="s3">\n    </span><span class="s1">previouslyRevalidatedTags,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createNotFoundLoaderTree(loaderTree: LoaderTree): LoaderTree {</span><span class="s3">\n  </span><span class="s1">const components = loaderTree[2]</span><span class="s3">\n  </span><span class="s1">const hasGlobalNotFound = !!components['global-not-found']</span><span class="s3">\n  </span><span class="s1">return [</span><span class="s3">\n    </span><span class="s1">'',</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">children: [</span><span class="s3">\n        </span><span class="s1">PAGE_SEGMENT_KEY,</span><span class="s3">\n        </span><span class="s1">{},</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">page: components['global-not-found'] ?? components['not-found'],</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">// When global-not-found is present, skip layout from components</span><span class="s3">\n    </span><span class="s1">hasGlobalNotFound ? components : {},</span><span class="s3">\n  </span><span class="s1">]</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns a function that parses the dynamic segment and return the associated value.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function makeGetDynamicParamFromSegment(</span><span class="s3">\n  </span><span class="s1">params: { [key: string]: any },</span><span class="s3">\n  </span><span class="s1">pagePath: string,</span><span class="s3">\n  </span><span class="s1">fallbackRouteParams: FallbackRouteParams | null</span><span class="s3">\n</span><span class="s1">): GetDynamicParamFromSegment {</span><span class="s3">\n  </span><span class="s1">return function getDynamicParamFromSegment(</span><span class="s3">\n    </span><span class="s1">// [slug] / [[slug]] / [...slug]</span><span class="s3">\n    </span><span class="s1">segment: string</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const segmentParam = getSegmentParam(segment)</span><span class="s3">\n    </span><span class="s1">if (!segmentParam) {</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const segmentKey = segmentParam.param</span><span class="s3">\n    </span><span class="s1">const dynamicParamType = dynamicParamTypes[segmentParam.type]</span><span class="s3">\n    </span><span class="s1">return getDynamicParam(</span><span class="s3">\n      </span><span class="s1">params,</span><span class="s3">\n      </span><span class="s1">segmentKey,</span><span class="s3">\n      </span><span class="s1">dynamicParamType,</span><span class="s3">\n      </span><span class="s1">pagePath,</span><span class="s3">\n      </span><span class="s1">fallbackRouteParams</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function NonIndex({</span><span class="s3">\n  </span><span class="s1">pagePath,</span><span class="s3">\n  </span><span class="s1">statusCode,</span><span class="s3">\n  </span><span class="s1">isPossibleServerAction,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">pagePath: string</span><span class="s3">\n  </span><span class="s1">statusCode: number | undefined</span><span class="s3">\n  </span><span class="s1">isPossibleServerAction: boolean</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">const is404Page = pagePath === '/404'</span><span class="s3">\n  </span><span class="s1">const isInvalidStatusCode = typeof statusCode === 'number' &amp;&amp; statusCode &gt; 400</span><span class="s3">\n\n  </span><span class="s1">// Only render noindex for page request, skip for server actions</span><span class="s3">\n  </span><span class="s1">// TODO: is this correct if `isPossibleServerAction` is a false positive?</span><span class="s3">\n  </span><span class="s1">if (!isPossibleServerAction &amp;&amp; (is404Page || isInvalidStatusCode)) {</span><span class="s3">\n    </span><span class="s1">return &lt;meta name=</span><span class="s3">\&quot;</span><span class="s1">robots</span><span class="s3">\&quot; </span><span class="s1">content=</span><span class="s3">\&quot;</span><span class="s1">noindex</span><span class="s3">\&quot; </span><span class="s1">/&gt;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This is used by server actions &amp; client-side navigations to generate RSC data from a client-side request.</span><span class="s3">\n </span><span class="s1">* This function is only called on </span><span class="s3">\&quot;</span><span class="s1">dynamic</span><span class="s3">\&quot; </span><span class="s1">requests (ie, there wasn't already a static response).</span><span class="s3">\n </span><span class="s1">* It uses request headers (namely `next-router-state-tree`) to determine where to start rendering.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">async function generateDynamicRSCPayload(</span><span class="s3">\n  </span><span class="s1">ctx: AppRenderContext,</span><span class="s3">\n  </span><span class="s1">options?: {</span><span class="s3">\n    </span><span class="s1">actionResult: ActionResult</span><span class="s3">\n    </span><span class="s1">skipFlight: boolean</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">): Promise&lt;RSCPayload&gt; {</span><span class="s3">\n  </span><span class="s1">// Flight data that is going to be passed to the browser.</span><span class="s3">\n  </span><span class="s1">// Currently a single item array but in the future multiple patches might be combined in a single request.</span><span class="s3">\n\n  </span><span class="s1">// We initialize `flightData` to an empty string because the client router knows how to tolerate</span><span class="s3">\n  </span><span class="s1">// it (treating it as an MPA navigation). The only time this function wouldn't generate flight data</span><span class="s3">\n  </span><span class="s1">// is for server actions, if the server action handler instructs this function to skip it. When the server</span><span class="s3">\n  </span><span class="s1">// action reducer sees a falsy value, it'll simply resolve the action with no data.</span><span class="s3">\n  </span><span class="s1">let flightData: FlightData = ''</span><span class="s3">\n\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">componentMod: {</span><span class="s3">\n      </span><span class="s1">tree: loaderTree,</span><span class="s3">\n      </span><span class="s1">createMetadataComponents,</span><span class="s3">\n      </span><span class="s1">MetadataBoundary,</span><span class="s3">\n      </span><span class="s1">ViewportBoundary,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">getDynamicParamFromSegment,</span><span class="s3">\n    </span><span class="s1">appUsingSizeAdjustment,</span><span class="s3">\n    </span><span class="s1">query,</span><span class="s3">\n    </span><span class="s1">requestId,</span><span class="s3">\n    </span><span class="s1">flightRouterState,</span><span class="s3">\n    </span><span class="s1">workStore,</span><span class="s3">\n    </span><span class="s1">url,</span><span class="s3">\n  </span><span class="s1">} = ctx</span><span class="s3">\n\n  </span><span class="s1">const serveStreamingMetadata = !!ctx.renderOpts.serveStreamingMetadata</span><span class="s3">\n\n  </span><span class="s1">if (!options?.skipFlight) {</span><span class="s3">\n    </span><span class="s1">const preloadCallbacks: PreloadCallbacks = []</span><span class="s3">\n\n    </span><span class="s1">const {</span><span class="s3">\n      </span><span class="s1">ViewportTree,</span><span class="s3">\n      </span><span class="s1">MetadataTree,</span><span class="s3">\n      </span><span class="s1">getViewportReady,</span><span class="s3">\n      </span><span class="s1">getMetadataReady,</span><span class="s3">\n      </span><span class="s1">StreamingMetadataOutlet,</span><span class="s3">\n    </span><span class="s1">} = createMetadataComponents({</span><span class="s3">\n      </span><span class="s1">tree: loaderTree,</span><span class="s3">\n      </span><span class="s1">parsedQuery: query,</span><span class="s3">\n      </span><span class="s1">pathname: url.pathname,</span><span class="s3">\n      </span><span class="s1">metadataContext: createMetadataContext(ctx.renderOpts),</span><span class="s3">\n      </span><span class="s1">getDynamicParamFromSegment,</span><span class="s3">\n      </span><span class="s1">appUsingSizeAdjustment,</span><span class="s3">\n      </span><span class="s1">workStore,</span><span class="s3">\n      </span><span class="s1">MetadataBoundary,</span><span class="s3">\n      </span><span class="s1">ViewportBoundary,</span><span class="s3">\n      </span><span class="s1">serveStreamingMetadata,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">flightData = (</span><span class="s3">\n      </span><span class="s1">await walkTreeWithFlightRouterState({</span><span class="s3">\n        </span><span class="s1">ctx,</span><span class="s3">\n        </span><span class="s1">loaderTreeToFilter: loaderTree,</span><span class="s3">\n        </span><span class="s1">parentParams: {},</span><span class="s3">\n        </span><span class="s1">flightRouterState,</span><span class="s3">\n        </span><span class="s1">// For flight, render metadata inside leaf page</span><span class="s3">\n        </span><span class="s1">rscHead: (</span><span class="s3">\n          </span><span class="s1">&lt;React.Fragment key={flightDataPathHeadKey}&gt;</span><span class="s3">\n            </span><span class="s1">{/* noindex needs to be blocking */}</span><span class="s3">\n            </span><span class="s1">&lt;NonIndex</span><span class="s3">\n              </span><span class="s1">pagePath={ctx.pagePath}</span><span class="s3">\n              </span><span class="s1">statusCode={ctx.res.statusCode}</span><span class="s3">\n              </span><span class="s1">isPossibleServerAction={ctx.isPossibleServerAction}</span><span class="s3">\n            </span><span class="s1">/&gt;</span><span class="s3">\n            </span><span class="s1">{/* Adding requestId as react key to make metadata remount for each render */}</span><span class="s3">\n            </span><span class="s1">&lt;ViewportTree key={getFlightViewportKey(requestId)} /&gt;</span><span class="s3">\n            </span><span class="s1">&lt;MetadataTree key={getFlightMetadataKey(requestId)} /&gt;</span><span class="s3">\n          </span><span class="s1">&lt;/React.Fragment&gt;</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">injectedCSS: new Set(),</span><span class="s3">\n        </span><span class="s1">injectedJS: new Set(),</span><span class="s3">\n        </span><span class="s1">injectedFontPreloadTags: new Set(),</span><span class="s3">\n        </span><span class="s1">rootLayoutIncluded: false,</span><span class="s3">\n        </span><span class="s1">getViewportReady,</span><span class="s3">\n        </span><span class="s1">getMetadataReady,</span><span class="s3">\n        </span><span class="s1">preloadCallbacks,</span><span class="s3">\n        </span><span class="s1">StreamingMetadataOutlet,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">).map((path) =&gt; path.slice(1)) // remove the '' (root) segment</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// If we have an action result, then this is a server action response.</span><span class="s3">\n  </span><span class="s1">// We can rely on this because `ActionResult` will always be a promise, even if</span><span class="s3">\n  </span><span class="s1">// the result is falsey.</span><span class="s3">\n  </span><span class="s1">if (options?.actionResult) {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">a: options.actionResult,</span><span class="s3">\n      </span><span class="s1">f: flightData,</span><span class="s3">\n      </span><span class="s1">b: ctx.sharedContext.buildId,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Otherwise, it's a regular RSC response.</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">b: ctx.sharedContext.buildId,</span><span class="s3">\n    </span><span class="s1">f: flightData,</span><span class="s3">\n    </span><span class="s1">S: workStore.isStaticGeneration,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createErrorContext(</span><span class="s3">\n  </span><span class="s1">ctx: AppRenderContext,</span><span class="s3">\n  </span><span class="s1">renderSource: RequestErrorContext['renderSource']</span><span class="s3">\n</span><span class="s1">): RequestErrorContext {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">routerKind: 'App Router',</span><span class="s3">\n    </span><span class="s1">routePath: ctx.pagePath,</span><span class="s3">\n    </span><span class="s1">// TODO: is this correct if `isPossibleServerAction` is a false positive?</span><span class="s3">\n    </span><span class="s1">routeType: ctx.isPossibleServerAction ? 'action' : 'render',</span><span class="s3">\n    </span><span class="s1">renderSource,</span><span class="s3">\n    </span><span class="s1">revalidateReason: getRevalidateReason(ctx.workStore),</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Produces a RenderResult containing the Flight data for the given request. See</span><span class="s3">\n </span><span class="s1">* `generateDynamicRSCPayload` for information on the contents of the render result.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">async function generateDynamicFlightRenderResult(</span><span class="s3">\n  </span><span class="s1">req: BaseNextRequest,</span><span class="s3">\n  </span><span class="s1">ctx: AppRenderContext,</span><span class="s3">\n  </span><span class="s1">requestStore: RequestStore,</span><span class="s3">\n  </span><span class="s1">options?: {</span><span class="s3">\n    </span><span class="s1">actionResult: ActionResult</span><span class="s3">\n    </span><span class="s1">skipFlight: boolean</span><span class="s3">\n    </span><span class="s1">componentTree?: CacheNodeSeedData</span><span class="s3">\n    </span><span class="s1">preloadCallbacks?: PreloadCallbacks</span><span class="s3">\n    </span><span class="s1">temporaryReferences?: WeakMap&lt;any, string&gt;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">): Promise&lt;RenderResult&gt; {</span><span class="s3">\n  </span><span class="s1">const renderOpts = ctx.renderOpts</span><span class="s3">\n\n  </span><span class="s1">function onFlightDataRenderError(err: DigestedError) {</span><span class="s3">\n    </span><span class="s1">return renderOpts.onInstrumentationRequestError?.(</span><span class="s3">\n      </span><span class="s1">err,</span><span class="s3">\n      </span><span class="s1">req,</span><span class="s3">\n      </span><span class="s1">createErrorContext(ctx, 'react-server-components-payload')</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const onError = createFlightReactServerErrorHandler(</span><span class="s3">\n    </span><span class="s1">!!renderOpts.dev,</span><span class="s3">\n    </span><span class="s1">onFlightDataRenderError</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const RSCPayload: RSCPayload &amp; {</span><span class="s3">\n    </span><span class="s1">/** Only available during cacheComponents development builds. Used for logging errors. */</span><span class="s3">\n    </span><span class="s1">_validation?: Promise&lt;React.ReactNode&gt;</span><span class="s3">\n  </span><span class="s1">} = await workUnitAsyncStorage.run(</span><span class="s3">\n    </span><span class="s1">requestStore,</span><span class="s3">\n    </span><span class="s1">generateDynamicRSCPayload,</span><span class="s3">\n    </span><span class="s1">ctx,</span><span class="s3">\n    </span><span class="s1">options</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">// For app dir, use the bundled version of Flight server renderer (renderToReadableStream)</span><span class="s3">\n  </span><span class="s1">// which contains the subset React.</span><span class="s3">\n  </span><span class="s1">const flightReadableStream = workUnitAsyncStorage.run(</span><span class="s3">\n    </span><span class="s1">requestStore,</span><span class="s3">\n    </span><span class="s1">ctx.componentMod.renderToReadableStream,</span><span class="s3">\n    </span><span class="s1">RSCPayload,</span><span class="s3">\n    </span><span class="s1">ctx.clientReferenceManifest.clientModules,</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">onError,</span><span class="s3">\n      </span><span class="s1">temporaryReferences: options?.temporaryReferences,</span><span class="s3">\n      </span><span class="s1">filterStackFrame,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">return new FlightRenderResult(flightReadableStream, {</span><span class="s3">\n    </span><span class="s1">fetchMetrics: ctx.workStore.fetchMetrics,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">async function generateRuntimePrefetchResult(</span><span class="s3">\n  </span><span class="s1">req: BaseNextRequest,</span><span class="s3">\n  </span><span class="s1">res: BaseNextResponse,</span><span class="s3">\n  </span><span class="s1">ctx: AppRenderContext,</span><span class="s3">\n  </span><span class="s1">requestStore: RequestStore</span><span class="s3">\n</span><span class="s1">): Promise&lt;RenderResult&gt; {</span><span class="s3">\n  </span><span class="s1">const { workStore } = ctx</span><span class="s3">\n  </span><span class="s1">const renderOpts = ctx.renderOpts</span><span class="s3">\n\n  </span><span class="s1">function onFlightDataRenderError(err: DigestedError) {</span><span class="s3">\n    </span><span class="s1">return renderOpts.onInstrumentationRequestError?.(</span><span class="s3">\n      </span><span class="s1">err,</span><span class="s3">\n      </span><span class="s1">req,</span><span class="s3">\n      </span><span class="s1">// TODO(runtime-ppr): should we use a different value?</span><span class="s3">\n      </span><span class="s1">createErrorContext(ctx, 'react-server-components-payload')</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const onError = createFlightReactServerErrorHandler(</span><span class="s3">\n    </span><span class="s1">false,</span><span class="s3">\n    </span><span class="s1">onFlightDataRenderError</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const metadata: AppPageRenderResultMetadata = {}</span><span class="s3">\n\n  </span><span class="s1">const generatePayload = () =&gt; generateDynamicRSCPayload(ctx, undefined)</span><span class="s3">\n\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">componentMod: { tree },</span><span class="s3">\n    </span><span class="s1">getDynamicParamFromSegment,</span><span class="s3">\n  </span><span class="s1">} = ctx</span><span class="s3">\n  </span><span class="s1">const rootParams = getRootParams(tree, getDynamicParamFromSegment)</span><span class="s3">\n\n  </span><span class="s1">// We need to share caches between the prospective prerender and the final prerender,</span><span class="s3">\n  </span><span class="s1">// but we're not going to persist this anywhere.</span><span class="s3">\n  </span><span class="s1">const prerenderResumeDataCache = createPrerenderResumeDataCache()</span><span class="s3">\n  </span><span class="s1">// We're not resuming an existing render.</span><span class="s3">\n  </span><span class="s1">const renderResumeDataCache = null</span><span class="s3">\n\n  </span><span class="s1">await prospectiveRuntimeServerPrerender(</span><span class="s3">\n    </span><span class="s1">ctx,</span><span class="s3">\n    </span><span class="s1">generatePayload,</span><span class="s3">\n    </span><span class="s1">prerenderResumeDataCache,</span><span class="s3">\n    </span><span class="s1">renderResumeDataCache,</span><span class="s3">\n    </span><span class="s1">rootParams,</span><span class="s3">\n    </span><span class="s1">requestStore.cookies,</span><span class="s3">\n    </span><span class="s1">requestStore.draftMode</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const response = await finalRuntimeServerPrerender(</span><span class="s3">\n    </span><span class="s1">ctx,</span><span class="s3">\n    </span><span class="s1">generatePayload,</span><span class="s3">\n    </span><span class="s1">prerenderResumeDataCache,</span><span class="s3">\n    </span><span class="s1">renderResumeDataCache,</span><span class="s3">\n    </span><span class="s1">rootParams,</span><span class="s3">\n    </span><span class="s1">requestStore.cookies,</span><span class="s3">\n    </span><span class="s1">requestStore.draftMode,</span><span class="s3">\n    </span><span class="s1">onError</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">applyMetadataFromPrerenderResult(response, metadata, workStore)</span><span class="s3">\n  </span><span class="s1">metadata.fetchMetrics = ctx.workStore.fetchMetrics</span><span class="s3">\n\n  </span><span class="s1">if (response.isPartial) {</span><span class="s3">\n    </span><span class="s1">res.setHeader(NEXT_DID_POSTPONE_HEADER, '1')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return new FlightRenderResult(response.result.prelude, metadata)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">async function prospectiveRuntimeServerPrerender(</span><span class="s3">\n  </span><span class="s1">ctx: AppRenderContext,</span><span class="s3">\n  </span><span class="s1">getPayload: () =&gt; any,</span><span class="s3">\n  </span><span class="s1">prerenderResumeDataCache: PrerenderResumeDataCache | null,</span><span class="s3">\n  </span><span class="s1">renderResumeDataCache: RenderResumeDataCache | null,</span><span class="s3">\n  </span><span class="s1">rootParams: Params,</span><span class="s3">\n  </span><span class="s1">cookies: PrerenderStoreModernRuntime['cookies'],</span><span class="s3">\n  </span><span class="s1">draftMode: PrerenderStoreModernRuntime['draftMode']</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const { implicitTags, renderOpts, workStore } = ctx</span><span class="s3">\n\n  </span><span class="s1">const { clientReferenceManifest, ComponentMod } = renderOpts</span><span class="s3">\n\n  </span><span class="s1">assertClientReferenceManifest(clientReferenceManifest)</span><span class="s3">\n\n  </span><span class="s1">// Prerender controller represents the lifetime of the prerender.</span><span class="s3">\n  </span><span class="s1">// It will be aborted when a Task is complete or a synchronously aborting</span><span class="s3">\n  </span><span class="s1">// API is called. Notably during cache-filling renders this does not actually</span><span class="s3">\n  </span><span class="s1">// terminate the render itself which will continue until all caches are filled</span><span class="s3">\n  </span><span class="s1">const initialServerPrerenderController = new AbortController()</span><span class="s3">\n\n  </span><span class="s1">// This controller represents the lifetime of the React render call. Notably</span><span class="s3">\n  </span><span class="s1">// during the cache-filling render it is different from the prerender controller</span><span class="s3">\n  </span><span class="s1">// because we don't want to end the react render until all caches are filled.</span><span class="s3">\n  </span><span class="s1">const initialServerRenderController = new AbortController()</span><span class="s3">\n\n  </span><span class="s1">// The cacheSignal helps us track whether caches are still filling or we are ready</span><span class="s3">\n  </span><span class="s1">// to cut the render off.</span><span class="s3">\n  </span><span class="s1">const cacheSignal = new CacheSignal()</span><span class="s3">\n\n  </span><span class="s1">const initialServerPrerenderStore: PrerenderStoreModernRuntime = {</span><span class="s3">\n    </span><span class="s1">type: 'prerender-runtime',</span><span class="s3">\n    </span><span class="s1">phase: 'render',</span><span class="s3">\n    </span><span class="s1">rootParams,</span><span class="s3">\n    </span><span class="s1">implicitTags,</span><span class="s3">\n    </span><span class="s1">renderSignal: initialServerRenderController.signal,</span><span class="s3">\n    </span><span class="s1">controller: initialServerPrerenderController,</span><span class="s3">\n    </span><span class="s1">// During the initial prerender we need to track all cache reads to ensure</span><span class="s3">\n    </span><span class="s1">// we render long enough to fill every cache it is possible to visit during</span><span class="s3">\n    </span><span class="s1">// the final prerender.</span><span class="s3">\n    </span><span class="s1">cacheSignal,</span><span class="s3">\n    </span><span class="s1">// We only need to track dynamic accesses during the final prerender.</span><span class="s3">\n    </span><span class="s1">dynamicTracking: null,</span><span class="s3">\n    </span><span class="s1">// Runtime prefetches are never cached server-side, only client-side,</span><span class="s3">\n    </span><span class="s1">// so we set `expire` and `revalidate` to their minimum values just in case.</span><span class="s3">\n    </span><span class="s1">revalidate: 1,</span><span class="s3">\n    </span><span class="s1">expire: 0,</span><span class="s3">\n    </span><span class="s1">stale: INFINITE_CACHE,</span><span class="s3">\n    </span><span class="s1">tags: [...implicitTags.tags],</span><span class="s3">\n    </span><span class="s1">renderResumeDataCache,</span><span class="s3">\n    </span><span class="s1">prerenderResumeDataCache,</span><span class="s3">\n    </span><span class="s1">hmrRefreshHash: undefined,</span><span class="s3">\n    </span><span class="s1">captureOwnerStack: undefined,</span><span class="s3">\n    </span><span class="s1">// We only need task sequencing in the final prerender.</span><span class="s3">\n    </span><span class="s1">runtimeStagePromise: null,</span><span class="s3">\n    </span><span class="s1">// These are not present in regular prerenders, but allowed in a runtime prerender.</span><span class="s3">\n    </span><span class="s1">cookies,</span><span class="s3">\n    </span><span class="s1">draftMode,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// We're not going to use the result of this render because the only time it could be used</span><span class="s3">\n  </span><span class="s1">// is if it completes in a microtask and that's likely very rare for any non-trivial app</span><span class="s3">\n  </span><span class="s1">const initialServerPayload = await workUnitAsyncStorage.run(</span><span class="s3">\n    </span><span class="s1">initialServerPrerenderStore,</span><span class="s3">\n    </span><span class="s1">getPayload</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const pendingInitialServerResult = workUnitAsyncStorage.run(</span><span class="s3">\n    </span><span class="s1">initialServerPrerenderStore,</span><span class="s3">\n    </span><span class="s1">ComponentMod.prerender,</span><span class="s3">\n    </span><span class="s1">initialServerPayload,</span><span class="s3">\n    </span><span class="s1">clientReferenceManifest.clientModules,</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">filterStackFrame,</span><span class="s3">\n      </span><span class="s1">onError: (err) =&gt; {</span><span class="s3">\n        </span><span class="s1">const digest = getDigestForWellKnownError(err)</span><span class="s3">\n\n        </span><span class="s1">if (digest) {</span><span class="s3">\n          </span><span class="s1">return digest</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (initialServerPrerenderController.signal.aborted) {</span><span class="s3">\n          </span><span class="s1">// The render aborted before this error was handled which indicates</span><span class="s3">\n          </span><span class="s1">// the error is caused by unfinished components within the render</span><span class="s3">\n          </span><span class="s1">return</span><span class="s3">\n        </span><span class="s1">} else if (</span><span class="s3">\n          </span><span class="s1">process.env.NEXT_DEBUG_BUILD ||</span><span class="s3">\n          </span><span class="s1">process.env.__NEXT_VERBOSE_LOGGING</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">printDebugThrownValueForProspectiveRender(err, workStore.route)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">// we don't care to track postpones during the prospective render because we need</span><span class="s3">\n      </span><span class="s1">// to always do a final render anyway</span><span class="s3">\n      </span><span class="s1">onPostpone: undefined,</span><span class="s3">\n      </span><span class="s1">// We don't want to stop rendering until the cacheSignal is complete so we pass</span><span class="s3">\n      </span><span class="s1">// a different signal to this render call than is used by dynamic APIs to signify</span><span class="s3">\n      </span><span class="s1">// transitioning out of the prerender environment</span><span class="s3">\n      </span><span class="s1">signal: initialServerRenderController.signal,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">// Wait for all caches to be finished filling and for async imports to resolve</span><span class="s3">\n  </span><span class="s1">trackPendingModules(cacheSignal)</span><span class="s3">\n  </span><span class="s1">await cacheSignal.cacheReady()</span><span class="s3">\n\n  </span><span class="s1">initialServerRenderController.abort()</span><span class="s3">\n  </span><span class="s1">initialServerPrerenderController.abort()</span><span class="s3">\n\n  </span><span class="s1">// We don't need to continue the prerender process if we already</span><span class="s3">\n  </span><span class="s1">// detected invalid dynamic usage in the initial prerender phase.</span><span class="s3">\n  </span><span class="s1">if (workStore.invalidDynamicUsageError) {</span><span class="s3">\n    </span><span class="s1">throw workStore.invalidDynamicUsageError</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">return await createReactServerPrerenderResult(pendingInitialServerResult)</span><span class="s3">\n  </span><span class="s1">} catch (err) {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">initialServerRenderController.signal.aborted ||</span><span class="s3">\n      </span><span class="s1">initialServerPrerenderController.signal.aborted</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// These are expected errors that might error the prerender. we ignore them.</span><span class="s3">\n    </span><span class="s1">} else if (</span><span class="s3">\n      </span><span class="s1">process.env.NEXT_DEBUG_BUILD ||</span><span class="s3">\n      </span><span class="s1">process.env.__NEXT_VERBOSE_LOGGING</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// We don't normally log these errors because we are going to retry anyway but</span><span class="s3">\n      </span><span class="s1">// it can be useful for debugging Next.js itself to get visibility here when needed</span><span class="s3">\n      </span><span class="s1">printDebugThrownValueForProspectiveRender(err, workStore.route)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">async function finalRuntimeServerPrerender(</span><span class="s3">\n  </span><span class="s1">ctx: AppRenderContext,</span><span class="s3">\n  </span><span class="s1">getPayload: () =&gt; any,</span><span class="s3">\n  </span><span class="s1">prerenderResumeDataCache: PrerenderResumeDataCache | null,</span><span class="s3">\n  </span><span class="s1">renderResumeDataCache: RenderResumeDataCache | null,</span><span class="s3">\n  </span><span class="s1">rootParams: Params,</span><span class="s3">\n  </span><span class="s1">cookies: PrerenderStoreModernRuntime['cookies'],</span><span class="s3">\n  </span><span class="s1">draftMode: PrerenderStoreModernRuntime['draftMode'],</span><span class="s3">\n  </span><span class="s1">onError: (err: unknown) =&gt; string | undefined</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const { implicitTags, renderOpts } = ctx</span><span class="s3">\n\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">clientReferenceManifest,</span><span class="s3">\n    </span><span class="s1">ComponentMod,</span><span class="s3">\n    </span><span class="s1">experimental,</span><span class="s3">\n    </span><span class="s1">isDebugDynamicAccesses,</span><span class="s3">\n  </span><span class="s1">} = renderOpts</span><span class="s3">\n\n  </span><span class="s1">assertClientReferenceManifest(clientReferenceManifest)</span><span class="s3">\n\n  </span><span class="s1">const selectStaleTime = createSelectStaleTime(experimental)</span><span class="s3">\n\n  </span><span class="s1">let serverIsDynamic = false</span><span class="s3">\n  </span><span class="s1">const finalServerController = new AbortController()</span><span class="s3">\n\n  </span><span class="s1">const serverDynamicTracking = createDynamicTrackingState(</span><span class="s3">\n    </span><span class="s1">isDebugDynamicAccesses</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const { promise: runtimeStagePromise, resolve: resolveBlockedRuntimeAPIs } =</span><span class="s3">\n    </span><span class="s1">createPromiseWithResolvers&lt;void&gt;()</span><span class="s3">\n\n  </span><span class="s1">const finalServerPrerenderStore: PrerenderStoreModernRuntime = {</span><span class="s3">\n    </span><span class="s1">type: 'prerender-runtime',</span><span class="s3">\n    </span><span class="s1">phase: 'render',</span><span class="s3">\n    </span><span class="s1">rootParams,</span><span class="s3">\n    </span><span class="s1">implicitTags,</span><span class="s3">\n    </span><span class="s1">renderSignal: finalServerController.signal,</span><span class="s3">\n    </span><span class="s1">controller: finalServerController,</span><span class="s3">\n    </span><span class="s1">// All caches we could read must already be filled so no tracking is necessary</span><span class="s3">\n    </span><span class="s1">cacheSignal: null,</span><span class="s3">\n    </span><span class="s1">dynamicTracking: serverDynamicTracking,</span><span class="s3">\n    </span><span class="s1">// Runtime prefetches are never cached server-side, only client-side,</span><span class="s3">\n    </span><span class="s1">// so we set `expire` and `revalidate` to their minimum values just in case.</span><span class="s3">\n    </span><span class="s1">revalidate: 1,</span><span class="s3">\n    </span><span class="s1">expire: 0,</span><span class="s3">\n    </span><span class="s1">stale: INFINITE_CACHE,</span><span class="s3">\n    </span><span class="s1">tags: [...implicitTags.tags],</span><span class="s3">\n    </span><span class="s1">prerenderResumeDataCache,</span><span class="s3">\n    </span><span class="s1">renderResumeDataCache,</span><span class="s3">\n    </span><span class="s1">hmrRefreshHash: undefined,</span><span class="s3">\n    </span><span class="s1">captureOwnerStack: undefined,</span><span class="s3">\n    </span><span class="s1">// Used to separate the </span><span class="s3">\&quot;</span><span class="s1">Static</span><span class="s3">\&quot; </span><span class="s1">stage from the </span><span class="s3">\&quot;</span><span class="s1">Runtime</span><span class="s3">\&quot; </span><span class="s1">stage.</span><span class="s3">\n    </span><span class="s1">runtimeStagePromise,</span><span class="s3">\n    </span><span class="s1">// These are not present in regular prerenders, but allowed in a runtime prerender.</span><span class="s3">\n    </span><span class="s1">cookies,</span><span class="s3">\n    </span><span class="s1">draftMode,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const finalRSCPayload = await workUnitAsyncStorage.run(</span><span class="s3">\n    </span><span class="s1">finalServerPrerenderStore,</span><span class="s3">\n    </span><span class="s1">getPayload</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">let prerenderIsPending = true</span><span class="s3">\n  </span><span class="s1">const result = await prerenderAndAbortInSequentialTasksWithStages(</span><span class="s3">\n    </span><span class="s1">async () =&gt; {</span><span class="s3">\n      </span><span class="s1">// Static stage</span><span class="s3">\n      </span><span class="s1">const prerenderResult = await workUnitAsyncStorage.run(</span><span class="s3">\n        </span><span class="s1">finalServerPrerenderStore,</span><span class="s3">\n        </span><span class="s1">ComponentMod.prerender,</span><span class="s3">\n        </span><span class="s1">finalRSCPayload,</span><span class="s3">\n        </span><span class="s1">clientReferenceManifest.clientModules,</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">filterStackFrame,</span><span class="s3">\n          </span><span class="s1">onError,</span><span class="s3">\n          </span><span class="s1">signal: finalServerController.signal,</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">prerenderIsPending = false</span><span class="s3">\n      </span><span class="s1">return prerenderResult</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">() =&gt; {</span><span class="s3">\n      </span><span class="s1">// Advance to the runtime stage.</span><span class="s3">\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">// We make runtime APIs hang during the first task (above), and unblock them in the following task (here).</span><span class="s3">\n      </span><span class="s1">// This makes sure that, at this point, we'll have finished all the static parts (what we'd prerender statically).</span><span class="s3">\n      </span><span class="s1">// We know that they don't contain any incorrect sync IO, because that'd have caused a build error.</span><span class="s3">\n      </span><span class="s1">// After we unblock Runtime APIs, if we encounter sync IO (e.g. `await cookies(); Date.now()`),</span><span class="s3">\n      </span><span class="s1">// we'll abort, but we'll produce at least as much output as a static prerender would.</span><span class="s3">\n      </span><span class="s1">resolveBlockedRuntimeAPIs()</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">() =&gt; {</span><span class="s3">\n      </span><span class="s1">// Abort.</span><span class="s3">\n      </span><span class="s1">if (finalServerController.signal.aborted) {</span><span class="s3">\n        </span><span class="s1">// If the server controller is already aborted we must have called something</span><span class="s3">\n        </span><span class="s1">// that required aborting the prerender synchronously such as with new Date()</span><span class="s3">\n        </span><span class="s1">serverIsDynamic = true</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (prerenderIsPending) {</span><span class="s3">\n        </span><span class="s1">// If prerenderIsPending then we have blocked for longer than a Task and we assume</span><span class="s3">\n        </span><span class="s1">// there is something unfinished.</span><span class="s3">\n        </span><span class="s1">serverIsDynamic = true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">finalServerController.abort()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">warnOnSyncDynamicError(serverDynamicTracking)</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">result,</span><span class="s3">\n    </span><span class="s1">// TODO(runtime-ppr): do we need to produce a digest map here?</span><span class="s3">\n    </span><span class="s1">// digestErrorsMap: ...,</span><span class="s3">\n    </span><span class="s1">dynamicAccess: serverDynamicTracking,</span><span class="s3">\n    </span><span class="s1">isPartial: serverIsDynamic,</span><span class="s3">\n    </span><span class="s1">collectedRevalidate: finalServerPrerenderStore.revalidate,</span><span class="s3">\n    </span><span class="s1">collectedExpire: finalServerPrerenderStore.expire,</span><span class="s3">\n    </span><span class="s1">collectedStale: selectStaleTime(finalServerPrerenderStore.stale),</span><span class="s3">\n    </span><span class="s1">collectedTags: finalServerPrerenderStore.tags,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Performs a </span><span class="s3">\&quot;</span><span class="s1">warmup</span><span class="s3">\&quot; </span><span class="s1">render of the RSC payload for a given route. This function is called by the server</span><span class="s3">\n </span><span class="s1">* prior to an actual render request in Dev mode only. It's purpose is to fill caches so the actual render</span><span class="s3">\n </span><span class="s1">* can accurately log activity in the right render context (Prerender vs Render).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* At the moment this implementation is mostly a fork of generateDynamicFlightRenderResult</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">async function warmupDevRender(</span><span class="s3">\n  </span><span class="s1">req: BaseNextRequest,</span><span class="s3">\n  </span><span class="s1">ctx: AppRenderContext</span><span class="s3">\n</span><span class="s1">): Promise&lt;RenderResult&gt; {</span><span class="s3">\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">clientReferenceManifest,</span><span class="s3">\n    </span><span class="s1">componentMod: ComponentMod,</span><span class="s3">\n    </span><span class="s1">getDynamicParamFromSegment,</span><span class="s3">\n    </span><span class="s1">implicitTags,</span><span class="s3">\n    </span><span class="s1">renderOpts,</span><span class="s3">\n    </span><span class="s1">workStore,</span><span class="s3">\n  </span><span class="s1">} = ctx</span><span class="s3">\n\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">allowEmptyStaticShell = false,</span><span class="s3">\n    </span><span class="s1">dev,</span><span class="s3">\n    </span><span class="s1">onInstrumentationRequestError,</span><span class="s3">\n  </span><span class="s1">} = renderOpts</span><span class="s3">\n\n  </span><span class="s1">if (!dev) {</span><span class="s3">\n    </span><span class="s1">throw new InvariantError(</span><span class="s3">\n      </span><span class="s1">'generateDynamicFlightRenderResult should never be called in `next start` mode.'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const rootParams = getRootParams(</span><span class="s3">\n    </span><span class="s1">ComponentMod.tree,</span><span class="s3">\n    </span><span class="s1">getDynamicParamFromSegment</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">function onFlightDataRenderError(err: DigestedError) {</span><span class="s3">\n    </span><span class="s1">return onInstrumentationRequestError?.(</span><span class="s3">\n      </span><span class="s1">err,</span><span class="s3">\n      </span><span class="s1">req,</span><span class="s3">\n      </span><span class="s1">createErrorContext(ctx, 'react-server-components-payload')</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const onError = createFlightReactServerErrorHandler(</span><span class="s3">\n    </span><span class="s1">true,</span><span class="s3">\n    </span><span class="s1">onFlightDataRenderError</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">// We're doing a dev warmup, so we should create a new resume data cache so</span><span class="s3">\n  </span><span class="s1">// we can fill it.</span><span class="s3">\n  </span><span class="s1">const prerenderResumeDataCache = createPrerenderResumeDataCache()</span><span class="s3">\n\n  </span><span class="s1">const renderController = new AbortController()</span><span class="s3">\n  </span><span class="s1">const prerenderController = new AbortController()</span><span class="s3">\n  </span><span class="s1">const reactController = new AbortController()</span><span class="s3">\n  </span><span class="s1">const cacheSignal = new CacheSignal()</span><span class="s3">\n\n  </span><span class="s1">const prerenderStore: PrerenderStore = {</span><span class="s3">\n    </span><span class="s1">type: 'prerender',</span><span class="s3">\n    </span><span class="s1">phase: 'render',</span><span class="s3">\n    </span><span class="s1">rootParams,</span><span class="s3">\n    </span><span class="s1">implicitTags,</span><span class="s3">\n    </span><span class="s1">renderSignal: renderController.signal,</span><span class="s3">\n    </span><span class="s1">controller: prerenderController,</span><span class="s3">\n    </span><span class="s1">cacheSignal,</span><span class="s3">\n    </span><span class="s1">dynamicTracking: null,</span><span class="s3">\n    </span><span class="s1">allowEmptyStaticShell,</span><span class="s3">\n    </span><span class="s1">revalidate: INFINITE_CACHE,</span><span class="s3">\n    </span><span class="s1">expire: INFINITE_CACHE,</span><span class="s3">\n    </span><span class="s1">stale: INFINITE_CACHE,</span><span class="s3">\n    </span><span class="s1">tags: [],</span><span class="s3">\n    </span><span class="s1">prerenderResumeDataCache,</span><span class="s3">\n    </span><span class="s1">renderResumeDataCache: null,</span><span class="s3">\n    </span><span class="s1">hmrRefreshHash: req.cookies[NEXT_HMR_REFRESH_HASH_COOKIE],</span><span class="s3">\n    </span><span class="s1">captureOwnerStack: ComponentMod.captureOwnerStack,</span><span class="s3">\n    </span><span class="s1">// warmup is a dev only feature and no fallback params are used in the</span><span class="s3">\n    </span><span class="s1">// primary render which is static. We only use a prerender store here to</span><span class="s3">\n    </span><span class="s1">// allow the warmup to halt on Request data APIs and fetches.</span><span class="s3">\n    </span><span class="s1">fallbackRouteParams: null,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const rscPayload = await workUnitAsyncStorage.run(</span><span class="s3">\n    </span><span class="s1">prerenderStore,</span><span class="s3">\n    </span><span class="s1">generateDynamicRSCPayload,</span><span class="s3">\n    </span><span class="s1">ctx</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">// For app dir, use the bundled version of Flight server renderer (renderToReadableStream)</span><span class="s3">\n  </span><span class="s1">// which contains the subset React.</span><span class="s3">\n  </span><span class="s1">workUnitAsyncStorage.run(</span><span class="s3">\n    </span><span class="s1">prerenderStore,</span><span class="s3">\n    </span><span class="s1">ComponentMod.renderToReadableStream,</span><span class="s3">\n    </span><span class="s1">rscPayload,</span><span class="s3">\n    </span><span class="s1">clientReferenceManifest.clientModules,</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">filterStackFrame,</span><span class="s3">\n      </span><span class="s1">onError,</span><span class="s3">\n      </span><span class="s1">signal: renderController.signal,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">// Wait for all caches to be finished filling and for async imports to resolve</span><span class="s3">\n  </span><span class="s1">trackPendingModules(cacheSignal)</span><span class="s3">\n  </span><span class="s1">await cacheSignal.cacheReady()</span><span class="s3">\n\n  </span><span class="s1">// We unset the cache so any late over-run renders aren't able to write into this cache</span><span class="s3">\n  </span><span class="s1">prerenderStore.prerenderResumeDataCache = null</span><span class="s3">\n  </span><span class="s1">// Abort the render</span><span class="s3">\n  </span><span class="s1">reactController.abort()</span><span class="s3">\n  </span><span class="s1">renderController.abort()</span><span class="s3">\n\n  </span><span class="s1">// We don't really want to return a result here but the stack of functions</span><span class="s3">\n  </span><span class="s1">// that calls into renderToHTML... expects a result. We should refactor this to</span><span class="s3">\n  </span><span class="s1">// lift the warmup pathway outside of renderToHTML... but for now this suffices</span><span class="s3">\n  </span><span class="s1">return new FlightRenderResult('', {</span><span class="s3">\n    </span><span class="s1">fetchMetrics: workStore.fetchMetrics,</span><span class="s3">\n    </span><span class="s1">renderResumeDataCache: createRenderResumeDataCache(</span><span class="s3">\n      </span><span class="s1">prerenderResumeDataCache</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Crawlers will inadvertently think the canonicalUrl in the RSC payload should be crawled</span><span class="s3">\n </span><span class="s1">* when our intention is to just seed the router state with the current URL.</span><span class="s3">\n </span><span class="s1">* This function splits up the pathname so that we can later join it on</span><span class="s3">\n </span><span class="s1">* when we're ready to consume the path.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function prepareInitialCanonicalUrl(url: RequestStore['url']) {</span><span class="s3">\n  </span><span class="s1">return (url.pathname + url.search).split('/')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// This is the data necessary to render &lt;AppRouter /&gt; when no SSR errors are encountered</span><span class="s3">\n</span><span class="s1">async function getRSCPayload(</span><span class="s3">\n  </span><span class="s1">tree: LoaderTree,</span><span class="s3">\n  </span><span class="s1">ctx: AppRenderContext,</span><span class="s3">\n  </span><span class="s1">is404: boolean</span><span class="s3">\n</span><span class="s1">): Promise&lt;InitialRSCPayload &amp; { P: React.ReactNode }&gt; {</span><span class="s3">\n  </span><span class="s1">const injectedCSS = new Set&lt;string&gt;()</span><span class="s3">\n  </span><span class="s1">const injectedJS = new Set&lt;string&gt;()</span><span class="s3">\n  </span><span class="s1">const injectedFontPreloadTags = new Set&lt;string&gt;()</span><span class="s3">\n  </span><span class="s1">let missingSlots: Set&lt;string&gt; | undefined</span><span class="s3">\n\n  </span><span class="s1">// We only track missing parallel slots in development</span><span class="s3">\n  </span><span class="s1">if (process.env.NODE_ENV === 'development') {</span><span class="s3">\n    </span><span class="s1">missingSlots = new Set&lt;string&gt;()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">getDynamicParamFromSegment,</span><span class="s3">\n    </span><span class="s1">query,</span><span class="s3">\n    </span><span class="s1">appUsingSizeAdjustment,</span><span class="s3">\n    </span><span class="s1">componentMod: {</span><span class="s3">\n      </span><span class="s1">createMetadataComponents,</span><span class="s3">\n      </span><span class="s1">MetadataBoundary,</span><span class="s3">\n      </span><span class="s1">ViewportBoundary,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">url,</span><span class="s3">\n    </span><span class="s1">workStore,</span><span class="s3">\n  </span><span class="s1">} = ctx</span><span class="s3">\n\n  </span><span class="s1">const initialTree = createFlightRouterStateFromLoaderTree(</span><span class="s3">\n    </span><span class="s1">tree,</span><span class="s3">\n    </span><span class="s1">getDynamicParamFromSegment,</span><span class="s3">\n    </span><span class="s1">query</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">const serveStreamingMetadata = !!ctx.renderOpts.serveStreamingMetadata</span><span class="s3">\n  </span><span class="s1">const hasGlobalNotFound = !!tree[2]['global-not-found']</span><span class="s3">\n\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">ViewportTree,</span><span class="s3">\n    </span><span class="s1">MetadataTree,</span><span class="s3">\n    </span><span class="s1">getViewportReady,</span><span class="s3">\n    </span><span class="s1">getMetadataReady,</span><span class="s3">\n    </span><span class="s1">StreamingMetadataOutlet,</span><span class="s3">\n  </span><span class="s1">} = createMetadataComponents({</span><span class="s3">\n    </span><span class="s1">tree,</span><span class="s3">\n    </span><span class="s1">// When it's using global-not-found, metadata errorType is undefined, which will retrieve the</span><span class="s3">\n    </span><span class="s1">// metadata from the page.</span><span class="s3">\n    </span><span class="s1">// When it's using not-found, metadata errorType is 'not-found', which will retrieve the</span><span class="s3">\n    </span><span class="s1">// metadata from the not-found.js boundary.</span><span class="s3">\n    </span><span class="s1">// TODO: remove this condition and keep it undefined when global-not-found is stabilized.</span><span class="s3">\n    </span><span class="s1">errorType: is404 &amp;&amp; !hasGlobalNotFound ? 'not-found' : undefined,</span><span class="s3">\n    </span><span class="s1">parsedQuery: query,</span><span class="s3">\n    </span><span class="s1">pathname: url.pathname,</span><span class="s3">\n    </span><span class="s1">metadataContext: createMetadataContext(ctx.renderOpts),</span><span class="s3">\n    </span><span class="s1">getDynamicParamFromSegment,</span><span class="s3">\n    </span><span class="s1">appUsingSizeAdjustment,</span><span class="s3">\n    </span><span class="s1">workStore,</span><span class="s3">\n    </span><span class="s1">MetadataBoundary,</span><span class="s3">\n    </span><span class="s1">ViewportBoundary,</span><span class="s3">\n    </span><span class="s1">serveStreamingMetadata,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">const preloadCallbacks: PreloadCallbacks = []</span><span class="s3">\n\n  </span><span class="s1">const seedData = await createComponentTree({</span><span class="s3">\n    </span><span class="s1">ctx,</span><span class="s3">\n    </span><span class="s1">loaderTree: tree,</span><span class="s3">\n    </span><span class="s1">parentParams: {},</span><span class="s3">\n    </span><span class="s1">injectedCSS,</span><span class="s3">\n    </span><span class="s1">injectedJS,</span><span class="s3">\n    </span><span class="s1">injectedFontPreloadTags,</span><span class="s3">\n    </span><span class="s1">rootLayoutIncluded: false,</span><span class="s3">\n    </span><span class="s1">getViewportReady,</span><span class="s3">\n    </span><span class="s1">getMetadataReady,</span><span class="s3">\n    </span><span class="s1">missingSlots,</span><span class="s3">\n    </span><span class="s1">preloadCallbacks,</span><span class="s3">\n    </span><span class="s1">authInterrupts: ctx.renderOpts.experimental.authInterrupts,</span><span class="s3">\n    </span><span class="s1">StreamingMetadataOutlet,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">// When the `vary` response header is present with `Next-URL`, that means there's a chance</span><span class="s3">\n  </span><span class="s1">// it could respond differently if there's an interception route. We provide this information</span><span class="s3">\n  </span><span class="s1">// to `AppRouter` so that it can properly seed the prefetch cache with a prefix, if needed.</span><span class="s3">\n  </span><span class="s1">const varyHeader = ctx.res.getHeader('vary')</span><span class="s3">\n  </span><span class="s1">const couldBeIntercepted =</span><span class="s3">\n    </span><span class="s1">typeof varyHeader === 'string' &amp;&amp; varyHeader.includes(NEXT_URL)</span><span class="s3">\n\n  </span><span class="s1">const initialHead = (</span><span class="s3">\n    </span><span class="s1">&lt;React.Fragment key={flightDataPathHeadKey}&gt;</span><span class="s3">\n      </span><span class="s1">&lt;NonIndex</span><span class="s3">\n        </span><span class="s1">pagePath={ctx.pagePath}</span><span class="s3">\n        </span><span class="s1">statusCode={ctx.res.statusCode}</span><span class="s3">\n        </span><span class="s1">isPossibleServerAction={ctx.isPossibleServerAction}</span><span class="s3">\n      </span><span class="s1">/&gt;</span><span class="s3">\n      </span><span class="s1">&lt;ViewportTree /&gt;</span><span class="s3">\n      </span><span class="s1">&lt;MetadataTree /&gt;</span><span class="s3">\n    </span><span class="s1">&lt;/React.Fragment&gt;</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const { GlobalError, styles: globalErrorStyles } = await getGlobalErrorStyles(</span><span class="s3">\n    </span><span class="s1">tree,</span><span class="s3">\n    </span><span class="s1">ctx</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">// Assume the head we're rendering contains only partial data if PPR is</span><span class="s3">\n  </span><span class="s1">// enabled and this is a statically generated response. This is used by the</span><span class="s3">\n  </span><span class="s1">// client Segment Cache after a prefetch to determine if it can skip the</span><span class="s3">\n  </span><span class="s1">// second request to fill in the dynamic data.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// See similar comment in create-component-tree.tsx for more context.</span><span class="s3">\n  </span><span class="s1">const isPossiblyPartialHead =</span><span class="s3">\n    </span><span class="s1">workStore.isStaticGeneration &amp;&amp;</span><span class="s3">\n    </span><span class="s1">ctx.renderOpts.experimental.isRoutePPREnabled === true</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">// See the comment above the `Preloads` component (below) for why this is part of the payload</span><span class="s3">\n    </span><span class="s1">P: &lt;Preloads preloadCallbacks={preloadCallbacks} /&gt;,</span><span class="s3">\n    </span><span class="s1">b: ctx.sharedContext.buildId,</span><span class="s3">\n    </span><span class="s1">p: ctx.assetPrefix,</span><span class="s3">\n    </span><span class="s1">c: prepareInitialCanonicalUrl(url),</span><span class="s3">\n    </span><span class="s1">i: !!couldBeIntercepted,</span><span class="s3">\n    </span><span class="s1">f: [</span><span class="s3">\n      </span><span class="s1">[</span><span class="s3">\n        </span><span class="s1">initialTree,</span><span class="s3">\n        </span><span class="s1">seedData,</span><span class="s3">\n        </span><span class="s1">initialHead,</span><span class="s3">\n        </span><span class="s1">isPossiblyPartialHead,</span><span class="s3">\n      </span><span class="s1">] as FlightDataPath,</span><span class="s3">\n    </span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">m: missingSlots,</span><span class="s3">\n    </span><span class="s1">G: [GlobalError, globalErrorStyles],</span><span class="s3">\n    </span><span class="s1">s: typeof ctx.renderOpts.postponed === 'string',</span><span class="s3">\n    </span><span class="s1">S: workStore.isStaticGeneration,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Preload calls (such as `ReactDOM.preloadStyle` and `ReactDOM.preloadFont`) need to be called during rendering</span><span class="s3">\n </span><span class="s1">* in order to create the appropriate preload tags in the DOM, otherwise they're a no-op. Since we invoke</span><span class="s3">\n </span><span class="s1">* renderToReadableStream with a function that returns component props rather than a component itself, we use</span><span class="s3">\n </span><span class="s1">* this component to </span><span class="s3">\&quot;</span><span class="s1">render  </span><span class="s3">\&quot; </span><span class="s1">the preload calls.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function Preloads({ preloadCallbacks }: { preloadCallbacks: Function[] }) {</span><span class="s3">\n  </span><span class="s1">preloadCallbacks.forEach((preloadFn) =&gt; preloadFn())</span><span class="s3">\n  </span><span class="s1">return null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// This is the data necessary to render &lt;AppRouter /&gt; when an error state is triggered</span><span class="s3">\n</span><span class="s1">async function getErrorRSCPayload(</span><span class="s3">\n  </span><span class="s1">tree: LoaderTree,</span><span class="s3">\n  </span><span class="s1">ctx: AppRenderContext,</span><span class="s3">\n  </span><span class="s1">ssrError: unknown,</span><span class="s3">\n  </span><span class="s1">errorType: MetadataErrorType | 'redirect' | undefined</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">getDynamicParamFromSegment,</span><span class="s3">\n    </span><span class="s1">query,</span><span class="s3">\n    </span><span class="s1">appUsingSizeAdjustment,</span><span class="s3">\n    </span><span class="s1">componentMod: {</span><span class="s3">\n      </span><span class="s1">createMetadataComponents,</span><span class="s3">\n      </span><span class="s1">MetadataBoundary,</span><span class="s3">\n      </span><span class="s1">ViewportBoundary,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">url,</span><span class="s3">\n    </span><span class="s1">workStore,</span><span class="s3">\n  </span><span class="s1">} = ctx</span><span class="s3">\n\n  </span><span class="s1">const serveStreamingMetadata = !!ctx.renderOpts.serveStreamingMetadata</span><span class="s3">\n  </span><span class="s1">const { MetadataTree, ViewportTree } = createMetadataComponents({</span><span class="s3">\n    </span><span class="s1">tree,</span><span class="s3">\n    </span><span class="s1">parsedQuery: query,</span><span class="s3">\n    </span><span class="s1">pathname: url.pathname,</span><span class="s3">\n    </span><span class="s1">metadataContext: createMetadataContext(ctx.renderOpts),</span><span class="s3">\n    </span><span class="s1">errorType,</span><span class="s3">\n    </span><span class="s1">getDynamicParamFromSegment,</span><span class="s3">\n    </span><span class="s1">appUsingSizeAdjustment,</span><span class="s3">\n    </span><span class="s1">workStore,</span><span class="s3">\n    </span><span class="s1">MetadataBoundary,</span><span class="s3">\n    </span><span class="s1">ViewportBoundary,</span><span class="s3">\n    </span><span class="s1">serveStreamingMetadata: serveStreamingMetadata,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">const initialHead = (</span><span class="s3">\n    </span><span class="s1">&lt;React.Fragment key={flightDataPathHeadKey}&gt;</span><span class="s3">\n      </span><span class="s1">&lt;NonIndex</span><span class="s3">\n        </span><span class="s1">pagePath={ctx.pagePath}</span><span class="s3">\n        </span><span class="s1">statusCode={ctx.res.statusCode}</span><span class="s3">\n        </span><span class="s1">isPossibleServerAction={ctx.isPossibleServerAction}</span><span class="s3">\n      </span><span class="s1">/&gt;</span><span class="s3">\n      </span><span class="s1">&lt;ViewportTree /&gt;</span><span class="s3">\n      </span><span class="s1">{process.env.NODE_ENV === 'development' &amp;&amp; (</span><span class="s3">\n        </span><span class="s1">&lt;meta name=</span><span class="s3">\&quot;</span><span class="s1">next-error</span><span class="s3">\&quot; </span><span class="s1">content=</span><span class="s3">\&quot;</span><span class="s1">not-found</span><span class="s3">\&quot; </span><span class="s1">/&gt;</span><span class="s3">\n      </span><span class="s1">)}</span><span class="s3">\n      </span><span class="s1">&lt;MetadataTree /&gt;</span><span class="s3">\n    </span><span class="s1">&lt;/React.Fragment&gt;</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const initialTree = createFlightRouterStateFromLoaderTree(</span><span class="s3">\n    </span><span class="s1">tree,</span><span class="s3">\n    </span><span class="s1">getDynamicParamFromSegment,</span><span class="s3">\n    </span><span class="s1">query</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">let err: Error | undefined = undefined</span><span class="s3">\n  </span><span class="s1">if (ssrError) {</span><span class="s3">\n    </span><span class="s1">err = isError(ssrError) ? ssrError : new Error(ssrError + '')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// For metadata notFound error there's no global not found boundary on top</span><span class="s3">\n  </span><span class="s1">// so we create a not found page with AppRouter</span><span class="s3">\n  </span><span class="s1">const seedData: CacheNodeSeedData = [</span><span class="s3">\n    </span><span class="s1">initialTree[0],</span><span class="s3">\n    </span><span class="s1">&lt;html id=</span><span class="s3">\&quot;</span><span class="s1">__next_error__</span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\n      </span><span class="s1">&lt;head&gt;&lt;/head&gt;</span><span class="s3">\n      </span><span class="s1">&lt;body&gt;</span><span class="s3">\n        </span><span class="s1">{process.env.NODE_ENV !== 'production' &amp;&amp; err ? (</span><span class="s3">\n          </span><span class="s1">&lt;template</span><span class="s3">\n            </span><span class="s1">data-next-error-message={err.message}</span><span class="s3">\n            </span><span class="s1">data-next-error-digest={'digest' in err ? err.digest : ''}</span><span class="s3">\n            </span><span class="s1">data-next-error-stack={err.stack}</span><span class="s3">\n          </span><span class="s1">/&gt;</span><span class="s3">\n        </span><span class="s1">) : null}</span><span class="s3">\n      </span><span class="s1">&lt;/body&gt;</span><span class="s3">\n    </span><span class="s1">&lt;/html&gt;,</span><span class="s3">\n    </span><span class="s1">{},</span><span class="s3">\n    </span><span class="s1">null,</span><span class="s3">\n    </span><span class="s1">false,</span><span class="s3">\n  </span><span class="s1">]</span><span class="s3">\n\n  </span><span class="s1">const { GlobalError, styles: globalErrorStyles } = await getGlobalErrorStyles(</span><span class="s3">\n    </span><span class="s1">tree,</span><span class="s3">\n    </span><span class="s1">ctx</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const isPossiblyPartialHead =</span><span class="s3">\n    </span><span class="s1">workStore.isStaticGeneration &amp;&amp;</span><span class="s3">\n    </span><span class="s1">ctx.renderOpts.experimental.isRoutePPREnabled === true</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">b: ctx.sharedContext.buildId,</span><span class="s3">\n    </span><span class="s1">p: ctx.assetPrefix,</span><span class="s3">\n    </span><span class="s1">c: prepareInitialCanonicalUrl(url),</span><span class="s3">\n    </span><span class="s1">m: undefined,</span><span class="s3">\n    </span><span class="s1">i: false,</span><span class="s3">\n    </span><span class="s1">f: [</span><span class="s3">\n      </span><span class="s1">[</span><span class="s3">\n        </span><span class="s1">initialTree,</span><span class="s3">\n        </span><span class="s1">seedData,</span><span class="s3">\n        </span><span class="s1">initialHead,</span><span class="s3">\n        </span><span class="s1">isPossiblyPartialHead,</span><span class="s3">\n      </span><span class="s1">] as FlightDataPath,</span><span class="s3">\n    </span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">G: [GlobalError, globalErrorStyles],</span><span class="s3">\n    </span><span class="s1">s: typeof ctx.renderOpts.postponed === 'string',</span><span class="s3">\n    </span><span class="s1">S: workStore.isStaticGeneration,</span><span class="s3">\n  </span><span class="s1">} satisfies InitialRSCPayload</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function assertClientReferenceManifest(</span><span class="s3">\n  </span><span class="s1">clientReferenceManifest: RenderOpts['clientReferenceManifest']</span><span class="s3">\n</span><span class="s1">): asserts clientReferenceManifest is NonNullable&lt;</span><span class="s3">\n  </span><span class="s1">RenderOpts['clientReferenceManifest']</span><span class="s3">\n</span><span class="s1">&gt; {</span><span class="s3">\n  </span><span class="s1">if (!clientReferenceManifest) {</span><span class="s3">\n    </span><span class="s1">throw new InvariantError('Expected clientReferenceManifest to be defined.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// This component must run in an SSR context. It will render the RSC root component</span><span class="s3">\n</span><span class="s1">function App&lt;T&gt;({</span><span class="s3">\n  </span><span class="s1">reactServerStream,</span><span class="s3">\n  </span><span class="s1">preinitScripts,</span><span class="s3">\n  </span><span class="s1">clientReferenceManifest,</span><span class="s3">\n  </span><span class="s1">ServerInsertedHTMLProvider,</span><span class="s3">\n  </span><span class="s1">nonce,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">reactServerStream: BinaryStreamOf&lt;T&gt;</span><span class="s3">\n  </span><span class="s1">preinitScripts: () =&gt; void</span><span class="s3">\n  </span><span class="s1">clientReferenceManifest: NonNullable&lt;RenderOpts['clientReferenceManifest']&gt;</span><span class="s3">\n  </span><span class="s1">ServerInsertedHTMLProvider: React.ComponentType&lt;{ children: JSX.Element }&gt;</span><span class="s3">\n  </span><span class="s1">nonce?: string</span><span class="s3">\n</span><span class="s1">}): JSX.Element {</span><span class="s3">\n  </span><span class="s1">preinitScripts()</span><span class="s3">\n  </span><span class="s1">const response = React.use(</span><span class="s3">\n    </span><span class="s1">useFlightStream&lt;InitialRSCPayload&gt;(</span><span class="s3">\n      </span><span class="s1">reactServerStream,</span><span class="s3">\n      </span><span class="s1">clientReferenceManifest,</span><span class="s3">\n      </span><span class="s1">nonce</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const initialState = createInitialRouterState({</span><span class="s3">\n    </span><span class="s1">// This is not used during hydration, so we don't have to pass a</span><span class="s3">\n    </span><span class="s1">// real timestamp.</span><span class="s3">\n    </span><span class="s1">navigatedAt: -1,</span><span class="s3">\n    </span><span class="s1">initialFlightData: response.f,</span><span class="s3">\n    </span><span class="s1">initialCanonicalUrlParts: response.c,</span><span class="s3">\n    </span><span class="s1">initialParallelRoutes: new Map(),</span><span class="s3">\n    </span><span class="s1">// location is not initialized in the SSR render</span><span class="s3">\n    </span><span class="s1">// it's set to window.location during hydration</span><span class="s3">\n    </span><span class="s1">location: null,</span><span class="s3">\n    </span><span class="s1">couldBeIntercepted: response.i,</span><span class="s3">\n    </span><span class="s1">postponed: response.s,</span><span class="s3">\n    </span><span class="s1">prerendered: response.S,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">const actionQueue = createMutableActionQueue(initialState, null)</span><span class="s3">\n\n  </span><span class="s1">const { HeadManagerContext } =</span><span class="s3">\n    </span><span class="s1">require('../../shared/lib/head-manager-context.shared-runtime') as typeof import('../../shared/lib/head-manager-context.shared-runtime')</span><span class="s3">\n\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">&lt;HeadManagerContext.Provider</span><span class="s3">\n      </span><span class="s1">value={{</span><span class="s3">\n        </span><span class="s1">appDir: true,</span><span class="s3">\n        </span><span class="s1">nonce,</span><span class="s3">\n      </span><span class="s1">}}</span><span class="s3">\n    </span><span class="s1">&gt;</span><span class="s3">\n      </span><span class="s1">&lt;ServerInsertedHTMLProvider&gt;</span><span class="s3">\n        </span><span class="s1">&lt;AppRouter</span><span class="s3">\n          </span><span class="s1">actionQueue={actionQueue}</span><span class="s3">\n          </span><span class="s1">globalErrorState={response.G}</span><span class="s3">\n          </span><span class="s1">assetPrefix={response.p}</span><span class="s3">\n        </span><span class="s1">/&gt;</span><span class="s3">\n      </span><span class="s1">&lt;/ServerInsertedHTMLProvider&gt;</span><span class="s3">\n    </span><span class="s1">&lt;/HeadManagerContext.Provider&gt;</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// @TODO our error stream should be probably just use the same root component. But it was previously</span><span class="s3">\n</span><span class="s1">// different I don't want to figure out if that is meaningful at this time so just keeping the behavior</span><span class="s3">\n</span><span class="s1">// consistent for now.</span><span class="s3">\n</span><span class="s1">function ErrorApp&lt;T&gt;({</span><span class="s3">\n  </span><span class="s1">reactServerStream,</span><span class="s3">\n  </span><span class="s1">preinitScripts,</span><span class="s3">\n  </span><span class="s1">clientReferenceManifest,</span><span class="s3">\n  </span><span class="s1">ServerInsertedHTMLProvider,</span><span class="s3">\n  </span><span class="s1">nonce,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">reactServerStream: BinaryStreamOf&lt;T&gt;</span><span class="s3">\n  </span><span class="s1">preinitScripts: () =&gt; void</span><span class="s3">\n  </span><span class="s1">clientReferenceManifest: NonNullable&lt;RenderOpts['clientReferenceManifest']&gt;</span><span class="s3">\n  </span><span class="s1">ServerInsertedHTMLProvider: React.ComponentType&lt;{ children: JSX.Element }&gt;</span><span class="s3">\n  </span><span class="s1">nonce?: string</span><span class="s3">\n</span><span class="s1">}): JSX.Element {</span><span class="s3">\n  </span><span class="s1">preinitScripts()</span><span class="s3">\n  </span><span class="s1">const response = React.use(</span><span class="s3">\n    </span><span class="s1">useFlightStream&lt;InitialRSCPayload&gt;(</span><span class="s3">\n      </span><span class="s1">reactServerStream,</span><span class="s3">\n      </span><span class="s1">clientReferenceManifest,</span><span class="s3">\n      </span><span class="s1">nonce</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const initialState = createInitialRouterState({</span><span class="s3">\n    </span><span class="s1">// This is not used during hydration, so we don't have to pass a</span><span class="s3">\n    </span><span class="s1">// real timestamp.</span><span class="s3">\n    </span><span class="s1">navigatedAt: -1,</span><span class="s3">\n    </span><span class="s1">initialFlightData: response.f,</span><span class="s3">\n    </span><span class="s1">initialCanonicalUrlParts: response.c,</span><span class="s3">\n    </span><span class="s1">initialParallelRoutes: new Map(),</span><span class="s3">\n    </span><span class="s1">// location is not initialized in the SSR render</span><span class="s3">\n    </span><span class="s1">// it's set to window.location during hydration</span><span class="s3">\n    </span><span class="s1">location: null,</span><span class="s3">\n    </span><span class="s1">couldBeIntercepted: response.i,</span><span class="s3">\n    </span><span class="s1">postponed: response.s,</span><span class="s3">\n    </span><span class="s1">prerendered: response.S,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">const actionQueue = createMutableActionQueue(initialState, null)</span><span class="s3">\n\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">&lt;ServerInsertedHTMLProvider&gt;</span><span class="s3">\n      </span><span class="s1">&lt;AppRouter</span><span class="s3">\n        </span><span class="s1">actionQueue={actionQueue}</span><span class="s3">\n        </span><span class="s1">globalErrorState={response.G}</span><span class="s3">\n        </span><span class="s1">assetPrefix={response.p}</span><span class="s3">\n      </span><span class="s1">/&gt;</span><span class="s3">\n    </span><span class="s1">&lt;/ServerInsertedHTMLProvider&gt;</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// We use a trick with TS Generics to branch streams with a type so we can</span><span class="s3">\n</span><span class="s1">// consume the parsed value of a Readable Stream if it was constructed with a</span><span class="s3">\n</span><span class="s1">// certain object shape. The generic type is not used directly in the type so it</span><span class="s3">\n</span><span class="s1">// requires a disabling of the eslint rule disallowing unused vars</span><span class="s3">\n</span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-unused-vars</span><span class="s3">\n</span><span class="s1">export type BinaryStreamOf&lt;T&gt; = ReadableStream&lt;Uint8Array&gt;</span><span class="s3">\n\n</span><span class="s1">async function renderToHTMLOrFlightImpl(</span><span class="s3">\n  </span><span class="s1">req: BaseNextRequest,</span><span class="s3">\n  </span><span class="s1">res: BaseNextResponse,</span><span class="s3">\n  </span><span class="s1">url: ReturnType&lt;typeof parseRelativeUrl&gt;,</span><span class="s3">\n  </span><span class="s1">pagePath: string,</span><span class="s3">\n  </span><span class="s1">query: NextParsedUrlQuery,</span><span class="s3">\n  </span><span class="s1">renderOpts: RenderOpts,</span><span class="s3">\n  </span><span class="s1">workStore: WorkStore,</span><span class="s3">\n  </span><span class="s1">parsedRequestHeaders: ParsedRequestHeaders,</span><span class="s3">\n  </span><span class="s1">postponedState: PostponedState | null,</span><span class="s3">\n  </span><span class="s1">serverComponentsHmrCache: ServerComponentsHmrCache | undefined,</span><span class="s3">\n  </span><span class="s1">sharedContext: AppSharedContext,</span><span class="s3">\n  </span><span class="s1">fallbackRouteParams: FallbackRouteParams | null</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const isNotFoundPath = pagePath === '/404'</span><span class="s3">\n  </span><span class="s1">if (isNotFoundPath) {</span><span class="s3">\n    </span><span class="s1">res.statusCode = 404</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// A unique request timestamp used by development to ensure that it's</span><span class="s3">\n  </span><span class="s1">// consistent and won't change during this request. This is important to</span><span class="s3">\n  </span><span class="s1">// avoid that resources can be deduped by React Float if the same resource is</span><span class="s3">\n  </span><span class="s1">// rendered or preloaded multiple times: `&lt;link href=</span><span class="s3">\&quot;</span><span class="s1">a.css?v={Date.now()}</span><span class="s3">\&quot;</span><span class="s1">/&gt;`.</span><span class="s3">\n  </span><span class="s1">const requestTimestamp = Date.now()</span><span class="s3">\n\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">clientReferenceManifest,</span><span class="s3">\n    </span><span class="s1">serverActionsManifest,</span><span class="s3">\n    </span><span class="s1">ComponentMod,</span><span class="s3">\n    </span><span class="s1">nextFontManifest,</span><span class="s3">\n    </span><span class="s1">serverActions,</span><span class="s3">\n    </span><span class="s1">assetPrefix = '',</span><span class="s3">\n    </span><span class="s1">enableTainting,</span><span class="s3">\n  </span><span class="s1">} = renderOpts</span><span class="s3">\n\n  </span><span class="s1">// We need to expose the bundled `require` API globally for</span><span class="s3">\n  </span><span class="s1">// react-server-dom-webpack. This is a hack until we find a better way.</span><span class="s3">\n  </span><span class="s1">if (ComponentMod.__next_app__) {</span><span class="s3">\n    </span><span class="s1">const instrumented = wrapClientComponentLoader(ComponentMod)</span><span class="s3">\n\n    </span><span class="s1">// When we are prerendering if there is a cacheSignal for tracking</span><span class="s3">\n    </span><span class="s1">// cache reads we track calls to `loadChunk` and `require`. This allows us</span><span class="s3">\n    </span><span class="s1">// to treat chunk/module loading with similar semantics as cache reads to avoid</span><span class="s3">\n    </span><span class="s1">// module loading from causing a prerender to abort too early.</span><span class="s3">\n\n    </span><span class="s1">const shouldTrackModuleLoading = () =&gt; {</span><span class="s3">\n      </span><span class="s1">if (!renderOpts.experimental.cacheComponents) {</span><span class="s3">\n        </span><span class="s1">return false</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (renderOpts.dev) {</span><span class="s3">\n        </span><span class="s1">return true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const workUnitStore = workUnitAsyncStorage.getStore()</span><span class="s3">\n\n      </span><span class="s1">if (!workUnitStore) {</span><span class="s3">\n        </span><span class="s1">return false</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">switch (workUnitStore.type) {</span><span class="s3">\n        </span><span class="s1">case 'prerender':</span><span class="s3">\n        </span><span class="s1">case 'prerender-client':</span><span class="s3">\n        </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n        </span><span class="s1">case 'cache':</span><span class="s3">\n        </span><span class="s1">case 'private-cache':</span><span class="s3">\n          </span><span class="s1">return true</span><span class="s3">\n        </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n        </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n        </span><span class="s1">case 'request':</span><span class="s3">\n        </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n          </span><span class="s1">return false</span><span class="s3">\n        </span><span class="s1">default:</span><span class="s3">\n          </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const __next_require__: typeof instrumented.require = (...args) =&gt; {</span><span class="s3">\n      </span><span class="s1">const exportsOrPromise = instrumented.require(...args)</span><span class="s3">\n      </span><span class="s1">if (shouldTrackModuleLoading()) {</span><span class="s3">\n        </span><span class="s1">// requiring an async module returns a promise.</span><span class="s3">\n        </span><span class="s1">trackPendingImport(exportsOrPromise)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return exportsOrPromise</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error</span><span class="s3">\n    </span><span class="s1">globalThis.__next_require__ = __next_require__</span><span class="s3">\n\n    </span><span class="s1">const __next_chunk_load__: typeof instrumented.loadChunk = (...args) =&gt; {</span><span class="s3">\n      </span><span class="s1">const loadingChunk = instrumented.loadChunk(...args)</span><span class="s3">\n      </span><span class="s1">if (shouldTrackModuleLoading()) {</span><span class="s3">\n        </span><span class="s1">trackPendingChunkLoad(loadingChunk)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return loadingChunk</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error</span><span class="s3">\n    </span><span class="s1">globalThis.__next_chunk_load__ = __next_chunk_load__</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (process.env.NODE_ENV === 'development') {</span><span class="s3">\n    </span><span class="s1">// reset isr status at start of request</span><span class="s3">\n    </span><span class="s1">const { pathname } = new URL(req.url || '/', 'http://n')</span><span class="s3">\n    </span><span class="s1">renderOpts.setIsrStatus?.(pathname, null)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">// The type check here ensures that `req` is correctly typed, and the</span><span class="s3">\n    </span><span class="s1">// environment variable check provides dead code elimination.</span><span class="s3">\n    </span><span class="s1">process.env.NEXT_RUNTIME !== 'edge' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">isNodeNextRequest(req)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">res.onClose(() =&gt; {</span><span class="s3">\n      </span><span class="s1">// We stop tracking fetch metrics when the response closes, since we</span><span class="s3">\n      </span><span class="s1">// report them at that time.</span><span class="s3">\n      </span><span class="s1">workStore.shouldTrackFetchMetrics = false</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">req.originalRequest.on('end', () =&gt; {</span><span class="s3">\n      </span><span class="s1">if ('performance' in globalThis) {</span><span class="s3">\n        </span><span class="s1">const metrics = getClientComponentLoaderMetrics({ reset: true })</span><span class="s3">\n        </span><span class="s1">if (metrics) {</span><span class="s3">\n          </span><span class="s1">getTracer()</span><span class="s3">\n            </span><span class="s1">.startSpan(NextNodeServerSpan.clientComponentLoading, {</span><span class="s3">\n              </span><span class="s1">startTime: metrics.clientComponentLoadStart,</span><span class="s3">\n              </span><span class="s1">attributes: {</span><span class="s3">\n                </span><span class="s1">'next.clientComponentLoadCount':</span><span class="s3">\n                  </span><span class="s1">metrics.clientComponentLoadCount,</span><span class="s3">\n                </span><span class="s1">'next.span_type': NextNodeServerSpan.clientComponentLoading,</span><span class="s3">\n              </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n            </span><span class="s1">.end(</span><span class="s3">\n              </span><span class="s1">metrics.clientComponentLoadStart +</span><span class="s3">\n                </span><span class="s1">metrics.clientComponentLoadTimes</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const metadata: AppPageRenderResultMetadata = {</span><span class="s3">\n    </span><span class="s1">statusCode: isNotFoundPath ? 404 : undefined,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const appUsingSizeAdjustment = !!nextFontManifest?.appUsingSizeAdjust</span><span class="s3">\n\n  </span><span class="s1">assertClientReferenceManifest(clientReferenceManifest)</span><span class="s3">\n\n  </span><span class="s1">const serverModuleMap = createServerModuleMap({ serverActionsManifest })</span><span class="s3">\n\n  </span><span class="s1">setReferenceManifestsSingleton({</span><span class="s3">\n    </span><span class="s1">page: workStore.page,</span><span class="s3">\n    </span><span class="s1">clientReferenceManifest,</span><span class="s3">\n    </span><span class="s1">serverActionsManifest,</span><span class="s3">\n    </span><span class="s1">serverModuleMap,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">ComponentMod.patchFetch()</span><span class="s3">\n\n  </span><span class="s1">// Pull out the hooks/references from the component.</span><span class="s3">\n  </span><span class="s1">const { tree: loaderTree, taintObjectReference } = ComponentMod</span><span class="s3">\n  </span><span class="s1">if (enableTainting) {</span><span class="s3">\n    </span><span class="s1">taintObjectReference(</span><span class="s3">\n      </span><span class="s1">'Do not pass process.env to Client Components since it will leak sensitive data',</span><span class="s3">\n      </span><span class="s1">process.env</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">workStore.fetchMetrics = []</span><span class="s3">\n  </span><span class="s1">metadata.fetchMetrics = workStore.fetchMetrics</span><span class="s3">\n\n  </span><span class="s1">// don't modify original query object</span><span class="s3">\n  </span><span class="s1">query = { ...query }</span><span class="s3">\n  </span><span class="s1">stripInternalQueries(query)</span><span class="s3">\n\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">flightRouterState,</span><span class="s3">\n    </span><span class="s1">isPrefetchRequest,</span><span class="s3">\n    </span><span class="s1">isRuntimePrefetchRequest,</span><span class="s3">\n    </span><span class="s1">isRSCRequest,</span><span class="s3">\n    </span><span class="s1">isDevWarmupRequest,</span><span class="s3">\n    </span><span class="s1">isHmrRefresh,</span><span class="s3">\n    </span><span class="s1">nonce,</span><span class="s3">\n  </span><span class="s1">} = parsedRequestHeaders</span><span class="s3">\n\n  </span><span class="s1">const { isStaticGeneration } = workStore</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The metadata items array created in next-app-loader with all relevant information</span><span class="s3">\n   </span><span class="s1">* that we need to resolve the final metadata.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">let requestId: string</span><span class="s3">\n\n  </span><span class="s1">if (isStaticGeneration) {</span><span class="s3">\n    </span><span class="s1">requestId = Buffer.from(</span><span class="s3">\n      </span><span class="s1">await crypto.subtle.digest('SHA-1', Buffer.from(req.url))</span><span class="s3">\n    </span><span class="s1">).toString('hex')</span><span class="s3">\n  </span><span class="s1">} else if (process.env.NEXT_RUNTIME === 'edge') {</span><span class="s3">\n    </span><span class="s1">requestId = crypto.randomUUID()</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">requestId = (</span><span class="s3">\n      </span><span class="s1">require('next/dist/compiled/nanoid') as typeof import('next/dist/compiled/nanoid')</span><span class="s3">\n    </span><span class="s1">).nanoid()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Dynamic parameters. E.g. when you visit `/dashboard/vercel` which is rendered by `/dashboard/[slug]` the value will be {</span><span class="s3">\&quot;</span><span class="s1">slug</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">vercel</span><span class="s3">\&quot;</span><span class="s1">}.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">const params = renderOpts.params ?? {}</span><span class="s3">\n\n  </span><span class="s1">const getDynamicParamFromSegment = makeGetDynamicParamFromSegment(</span><span class="s3">\n    </span><span class="s1">params,</span><span class="s3">\n    </span><span class="s1">pagePath,</span><span class="s3">\n    </span><span class="s1">fallbackRouteParams</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const isPossibleActionRequest = getIsPossibleServerAction(req)</span><span class="s3">\n\n  </span><span class="s1">const implicitTags = await getImplicitTags(</span><span class="s3">\n    </span><span class="s1">workStore.page,</span><span class="s3">\n    </span><span class="s1">url,</span><span class="s3">\n    </span><span class="s1">fallbackRouteParams</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const ctx: AppRenderContext = {</span><span class="s3">\n    </span><span class="s1">componentMod: ComponentMod,</span><span class="s3">\n    </span><span class="s1">url,</span><span class="s3">\n    </span><span class="s1">renderOpts,</span><span class="s3">\n    </span><span class="s1">workStore,</span><span class="s3">\n    </span><span class="s1">parsedRequestHeaders,</span><span class="s3">\n    </span><span class="s1">getDynamicParamFromSegment,</span><span class="s3">\n    </span><span class="s1">query,</span><span class="s3">\n    </span><span class="s1">isPrefetch: isPrefetchRequest,</span><span class="s3">\n    </span><span class="s1">isPossibleServerAction: isPossibleActionRequest,</span><span class="s3">\n    </span><span class="s1">requestTimestamp,</span><span class="s3">\n    </span><span class="s1">appUsingSizeAdjustment,</span><span class="s3">\n    </span><span class="s1">flightRouterState,</span><span class="s3">\n    </span><span class="s1">requestId,</span><span class="s3">\n    </span><span class="s1">pagePath,</span><span class="s3">\n    </span><span class="s1">clientReferenceManifest,</span><span class="s3">\n    </span><span class="s1">assetPrefix,</span><span class="s3">\n    </span><span class="s1">isNotFoundPath,</span><span class="s3">\n    </span><span class="s1">nonce,</span><span class="s3">\n    </span><span class="s1">res,</span><span class="s3">\n    </span><span class="s1">sharedContext,</span><span class="s3">\n    </span><span class="s1">implicitTags,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">getTracer().setRootSpanAttribute('next.route', pagePath)</span><span class="s3">\n\n  </span><span class="s1">if (isStaticGeneration) {</span><span class="s3">\n    </span><span class="s1">// We're either building or revalidating. In either case we need to</span><span class="s3">\n    </span><span class="s1">// prerender our page rather than render it.</span><span class="s3">\n    </span><span class="s1">const prerenderToStreamWithTracing = getTracer().wrap(</span><span class="s3">\n      </span><span class="s1">AppRenderSpan.getBodyResult,</span><span class="s3">\n      </span><span class="s1">{</span><span class="s3">\n        </span><span class="s1">spanName: `prerender route (app) ${pagePath}`,</span><span class="s3">\n        </span><span class="s1">attributes: {</span><span class="s3">\n          </span><span class="s1">'next.route': pagePath,</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">prerenderToStream</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">const response = await prerenderToStreamWithTracing(</span><span class="s3">\n      </span><span class="s1">req,</span><span class="s3">\n      </span><span class="s1">res,</span><span class="s3">\n      </span><span class="s1">ctx,</span><span class="s3">\n      </span><span class="s1">metadata,</span><span class="s3">\n      </span><span class="s1">loaderTree,</span><span class="s3">\n      </span><span class="s1">fallbackRouteParams</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">// If we're debugging partial prerendering, print all the dynamic API accesses</span><span class="s3">\n    </span><span class="s1">// that occurred during the render.</span><span class="s3">\n    </span><span class="s1">// @TODO move into renderToStream function</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">response.dynamicAccess &amp;&amp;</span><span class="s3">\n      </span><span class="s1">accessedDynamicData(response.dynamicAccess) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">renderOpts.isDebugDynamicAccesses</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">warn('The following dynamic usage was detected:')</span><span class="s3">\n      </span><span class="s1">for (const access of formatDynamicAPIAccesses(response.dynamicAccess)) {</span><span class="s3">\n        </span><span class="s1">warn(access)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If we encountered any unexpected errors during build we fail the</span><span class="s3">\n    </span><span class="s1">// prerendering phase and the build.</span><span class="s3">\n    </span><span class="s1">if (workStore.invalidDynamicUsageError) {</span><span class="s3">\n      </span><span class="s1">logDisallowedDynamicError(workStore, workStore.invalidDynamicUsageError)</span><span class="s3">\n      </span><span class="s1">throw new StaticGenBailoutError()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (response.digestErrorsMap.size) {</span><span class="s3">\n      </span><span class="s1">const buildFailingError = response.digestErrorsMap.values().next().value</span><span class="s3">\n      </span><span class="s1">if (buildFailingError) throw buildFailingError</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Pick first userland SSR error, which is also not a RSC error.</span><span class="s3">\n    </span><span class="s1">if (response.ssrErrors.length) {</span><span class="s3">\n      </span><span class="s1">const buildFailingError = response.ssrErrors.find((err) =&gt;</span><span class="s3">\n        </span><span class="s1">isUserLandError(err)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">if (buildFailingError) throw buildFailingError</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const options: RenderResultOptions = {</span><span class="s3">\n      </span><span class="s1">metadata,</span><span class="s3">\n      </span><span class="s1">contentType: HTML_CONTENT_TYPE_HEADER,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// If we have pending revalidates, wait until they are all resolved.</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">workStore.pendingRevalidates ||</span><span class="s3">\n      </span><span class="s1">workStore.pendingRevalidateWrites ||</span><span class="s3">\n      </span><span class="s1">workStore.pendingRevalidatedTags</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">const pendingPromise = executeRevalidates(workStore).finally(() =&gt; {</span><span class="s3">\n        </span><span class="s1">if (process.env.NEXT_PRIVATE_DEBUG_CACHE) {</span><span class="s3">\n          </span><span class="s1">console.log('pending revalidates promise finished for:', url)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n\n      </span><span class="s1">if (renderOpts.waitUntil) {</span><span class="s3">\n        </span><span class="s1">renderOpts.waitUntil(pendingPromise)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">options.waitUntil = pendingPromise</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">applyMetadataFromPrerenderResult(response, metadata, workStore)</span><span class="s3">\n\n    </span><span class="s1">if (response.renderResumeDataCache) {</span><span class="s3">\n      </span><span class="s1">metadata.renderResumeDataCache = response.renderResumeDataCache</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return new RenderResult(await streamToString(response.stream), options)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// We're rendering dynamically</span><span class="s3">\n    </span><span class="s1">const renderResumeDataCache =</span><span class="s3">\n      </span><span class="s1">renderOpts.renderResumeDataCache ?? postponedState?.renderResumeDataCache</span><span class="s3">\n\n    </span><span class="s1">const rootParams = getRootParams(loaderTree, ctx.getDynamicParamFromSegment)</span><span class="s3">\n    </span><span class="s1">const devValidatingFallbackParams =</span><span class="s3">\n      </span><span class="s1">getRequestMeta(req, 'devValidatingFallbackParams') || null</span><span class="s3">\n    </span><span class="s1">const requestStore = createRequestStoreForRender(</span><span class="s3">\n      </span><span class="s1">req,</span><span class="s3">\n      </span><span class="s1">res,</span><span class="s3">\n      </span><span class="s1">url,</span><span class="s3">\n      </span><span class="s1">rootParams,</span><span class="s3">\n      </span><span class="s1">implicitTags,</span><span class="s3">\n      </span><span class="s1">renderOpts.onUpdateCookies,</span><span class="s3">\n      </span><span class="s1">renderOpts.previewProps,</span><span class="s3">\n      </span><span class="s1">isHmrRefresh,</span><span class="s3">\n      </span><span class="s1">serverComponentsHmrCache,</span><span class="s3">\n      </span><span class="s1">renderResumeDataCache,</span><span class="s3">\n      </span><span class="s1">devValidatingFallbackParams</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">process.env.NODE_ENV === 'development' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">renderOpts.setIsrStatus &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// The type check here ensures that `req` is correctly typed, and the</span><span class="s3">\n      </span><span class="s1">// environment variable check provides dead code elimination.</span><span class="s3">\n      </span><span class="s1">process.env.NEXT_RUNTIME !== 'edge' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">isNodeNextRequest(req) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!isDevWarmupRequest</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">const setIsrStatus = renderOpts.setIsrStatus</span><span class="s3">\n      </span><span class="s1">req.originalRequest.on('end', () =&gt; {</span><span class="s3">\n        </span><span class="s1">if (!requestStore.usedDynamic &amp;&amp; !workStore.forceDynamic) {</span><span class="s3">\n          </span><span class="s1">// only node can be ISR so we only need to update the status here</span><span class="s3">\n          </span><span class="s1">const { pathname } = new URL(req.url || '/', 'http://n')</span><span class="s3">\n          </span><span class="s1">setIsrStatus(pathname, true)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (isDevWarmupRequest) {</span><span class="s3">\n      </span><span class="s1">return warmupDevRender(req, ctx)</span><span class="s3">\n    </span><span class="s1">} else if (isRSCRequest) {</span><span class="s3">\n      </span><span class="s1">if (isRuntimePrefetchRequest) {</span><span class="s3">\n        </span><span class="s1">return generateRuntimePrefetchResult(req, res, ctx, requestStore)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return generateDynamicFlightRenderResult(req, ctx, requestStore)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const renderToStreamWithTracing = getTracer().wrap(</span><span class="s3">\n      </span><span class="s1">AppRenderSpan.getBodyResult,</span><span class="s3">\n      </span><span class="s1">{</span><span class="s3">\n        </span><span class="s1">spanName: `render route (app) ${pagePath}`,</span><span class="s3">\n        </span><span class="s1">attributes: {</span><span class="s3">\n          </span><span class="s1">'next.route': pagePath,</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">renderToStream</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">let formState: null | any = null</span><span class="s3">\n    </span><span class="s1">if (isPossibleActionRequest) {</span><span class="s3">\n      </span><span class="s1">// For action requests, we handle them differently with a special render result.</span><span class="s3">\n      </span><span class="s1">const actionRequestResult = await handleAction({</span><span class="s3">\n        </span><span class="s1">req,</span><span class="s3">\n        </span><span class="s1">res,</span><span class="s3">\n        </span><span class="s1">ComponentMod,</span><span class="s3">\n        </span><span class="s1">serverModuleMap,</span><span class="s3">\n        </span><span class="s1">generateFlight: generateDynamicFlightRenderResult,</span><span class="s3">\n        </span><span class="s1">workStore,</span><span class="s3">\n        </span><span class="s1">requestStore,</span><span class="s3">\n        </span><span class="s1">serverActions,</span><span class="s3">\n        </span><span class="s1">ctx,</span><span class="s3">\n        </span><span class="s1">metadata,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n\n      </span><span class="s1">if (actionRequestResult) {</span><span class="s3">\n        </span><span class="s1">if (actionRequestResult.type === 'not-found') {</span><span class="s3">\n          </span><span class="s1">const notFoundLoaderTree = createNotFoundLoaderTree(loaderTree)</span><span class="s3">\n          </span><span class="s1">res.statusCode = 404</span><span class="s3">\n          </span><span class="s1">metadata.statusCode = 404</span><span class="s3">\n          </span><span class="s1">const stream = await renderToStreamWithTracing(</span><span class="s3">\n            </span><span class="s1">requestStore,</span><span class="s3">\n            </span><span class="s1">req,</span><span class="s3">\n            </span><span class="s1">res,</span><span class="s3">\n            </span><span class="s1">ctx,</span><span class="s3">\n            </span><span class="s1">notFoundLoaderTree,</span><span class="s3">\n            </span><span class="s1">formState,</span><span class="s3">\n            </span><span class="s1">postponedState,</span><span class="s3">\n            </span><span class="s1">metadata,</span><span class="s3">\n            </span><span class="s1">devValidatingFallbackParams</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n\n          </span><span class="s1">return new RenderResult(stream, {</span><span class="s3">\n            </span><span class="s1">metadata,</span><span class="s3">\n            </span><span class="s1">contentType: HTML_CONTENT_TYPE_HEADER,</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">} else if (actionRequestResult.type === 'done') {</span><span class="s3">\n          </span><span class="s1">if (actionRequestResult.result) {</span><span class="s3">\n            </span><span class="s1">actionRequestResult.result.assignMetadata(metadata)</span><span class="s3">\n            </span><span class="s1">return actionRequestResult.result</span><span class="s3">\n          </span><span class="s1">} else if (actionRequestResult.formState) {</span><span class="s3">\n            </span><span class="s1">formState = actionRequestResult.formState</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const options: RenderResultOptions = {</span><span class="s3">\n      </span><span class="s1">metadata,</span><span class="s3">\n      </span><span class="s1">contentType: HTML_CONTENT_TYPE_HEADER,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const stream = await renderToStreamWithTracing(</span><span class="s3">\n      </span><span class="s1">requestStore,</span><span class="s3">\n      </span><span class="s1">req,</span><span class="s3">\n      </span><span class="s1">res,</span><span class="s3">\n      </span><span class="s1">ctx,</span><span class="s3">\n      </span><span class="s1">loaderTree,</span><span class="s3">\n      </span><span class="s1">formState,</span><span class="s3">\n      </span><span class="s1">postponedState,</span><span class="s3">\n      </span><span class="s1">metadata,</span><span class="s3">\n      </span><span class="s1">devValidatingFallbackParams</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">// Invalid dynamic usages should only error the request in development.</span><span class="s3">\n    </span><span class="s1">// In production, it's better to produce a result.</span><span class="s3">\n    </span><span class="s1">// (the dynamic error will still be thrown inside the component tree, but it's catchable by error boundaries)</span><span class="s3">\n    </span><span class="s1">if (workStore.invalidDynamicUsageError &amp;&amp; workStore.dev) {</span><span class="s3">\n      </span><span class="s1">throw workStore.invalidDynamicUsageError</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If we have pending revalidates, wait until they are all resolved.</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">workStore.pendingRevalidates ||</span><span class="s3">\n      </span><span class="s1">workStore.pendingRevalidateWrites ||</span><span class="s3">\n      </span><span class="s1">workStore.pendingRevalidatedTags</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">const pendingPromise = executeRevalidates(workStore).finally(() =&gt; {</span><span class="s3">\n        </span><span class="s1">if (process.env.NEXT_PRIVATE_DEBUG_CACHE) {</span><span class="s3">\n          </span><span class="s1">console.log('pending revalidates promise finished for:', url)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n\n      </span><span class="s1">if (renderOpts.waitUntil) {</span><span class="s3">\n        </span><span class="s1">renderOpts.waitUntil(pendingPromise)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">options.waitUntil = pendingPromise</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Create the new render result for the response.</span><span class="s3">\n    </span><span class="s1">return new RenderResult(stream, options)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type AppPageRender = (</span><span class="s3">\n  </span><span class="s1">req: BaseNextRequest,</span><span class="s3">\n  </span><span class="s1">res: BaseNextResponse,</span><span class="s3">\n  </span><span class="s1">pagePath: string,</span><span class="s3">\n  </span><span class="s1">query: NextParsedUrlQuery,</span><span class="s3">\n  </span><span class="s1">fallbackRouteParams: FallbackRouteParams | null,</span><span class="s3">\n  </span><span class="s1">renderOpts: RenderOpts,</span><span class="s3">\n  </span><span class="s1">serverComponentsHmrCache: ServerComponentsHmrCache | undefined,</span><span class="s3">\n  </span><span class="s1">isDevWarmup: boolean,</span><span class="s3">\n  </span><span class="s1">sharedContext: AppSharedContext</span><span class="s3">\n</span><span class="s1">) =&gt; Promise&lt;RenderResult&lt;AppPageRenderResultMetadata&gt;&gt;</span><span class="s3">\n\n</span><span class="s1">export const renderToHTMLOrFlight: AppPageRender = (</span><span class="s3">\n  </span><span class="s1">req,</span><span class="s3">\n  </span><span class="s1">res,</span><span class="s3">\n  </span><span class="s1">pagePath,</span><span class="s3">\n  </span><span class="s1">query,</span><span class="s3">\n  </span><span class="s1">fallbackRouteParams,</span><span class="s3">\n  </span><span class="s1">renderOpts,</span><span class="s3">\n  </span><span class="s1">serverComponentsHmrCache,</span><span class="s3">\n  </span><span class="s1">isDevWarmup,</span><span class="s3">\n  </span><span class="s1">sharedContext</span><span class="s3">\n</span><span class="s1">) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (!req.url) {</span><span class="s3">\n    </span><span class="s1">throw new Error('Invalid URL')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const url = parseRelativeUrl(req.url, undefined, false)</span><span class="s3">\n\n  </span><span class="s1">// We read these values from the request object as, in certain cases,</span><span class="s3">\n  </span><span class="s1">// base-server will strip them to opt into different rendering behavior.</span><span class="s3">\n  </span><span class="s1">const parsedRequestHeaders = parseRequestHeaders(req.headers, {</span><span class="s3">\n    </span><span class="s1">isDevWarmup,</span><span class="s3">\n    </span><span class="s1">isRoutePPREnabled: renderOpts.experimental.isRoutePPREnabled === true,</span><span class="s3">\n    </span><span class="s1">previewModeId: renderOpts.previewProps?.previewModeId,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">const { isPrefetchRequest, previouslyRevalidatedTags } = parsedRequestHeaders</span><span class="s3">\n\n  </span><span class="s1">let postponedState: PostponedState | null = null</span><span class="s3">\n\n  </span><span class="s1">// If provided, the postpone state should be parsed so it can be provided to</span><span class="s3">\n  </span><span class="s1">// React.</span><span class="s3">\n  </span><span class="s1">if (typeof renderOpts.postponed === 'string') {</span><span class="s3">\n    </span><span class="s1">if (fallbackRouteParams) {</span><span class="s3">\n      </span><span class="s1">throw new InvariantError(</span><span class="s3">\n        </span><span class="s1">'postponed state should not be provided when fallback params are provided'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">postponedState = parsePostponedState(</span><span class="s3">\n      </span><span class="s1">renderOpts.postponed,</span><span class="s3">\n      </span><span class="s1">renderOpts.params</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">postponedState?.renderResumeDataCache &amp;&amp;</span><span class="s3">\n    </span><span class="s1">renderOpts.renderResumeDataCache</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">throw new InvariantError(</span><span class="s3">\n      </span><span class="s1">'postponed state and dev warmup immutable resume data cache should not be provided together'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const workStore = createWorkStore({</span><span class="s3">\n    </span><span class="s1">page: renderOpts.routeModule.definition.page,</span><span class="s3">\n    </span><span class="s1">renderOpts,</span><span class="s3">\n    </span><span class="s1">// @TODO move to workUnitStore of type Request</span><span class="s3">\n    </span><span class="s1">isPrefetchRequest,</span><span class="s3">\n    </span><span class="s1">buildId: sharedContext.buildId,</span><span class="s3">\n    </span><span class="s1">previouslyRevalidatedTags,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">return workAsyncStorage.run(</span><span class="s3">\n    </span><span class="s1">workStore,</span><span class="s3">\n    </span><span class="s1">// The function to run</span><span class="s3">\n    </span><span class="s1">renderToHTMLOrFlightImpl,</span><span class="s3">\n    </span><span class="s1">// all of it's args</span><span class="s3">\n    </span><span class="s1">req,</span><span class="s3">\n    </span><span class="s1">res,</span><span class="s3">\n    </span><span class="s1">url,</span><span class="s3">\n    </span><span class="s1">pagePath,</span><span class="s3">\n    </span><span class="s1">query,</span><span class="s3">\n    </span><span class="s1">renderOpts,</span><span class="s3">\n    </span><span class="s1">workStore,</span><span class="s3">\n    </span><span class="s1">parsedRequestHeaders,</span><span class="s3">\n    </span><span class="s1">postponedState,</span><span class="s3">\n    </span><span class="s1">serverComponentsHmrCache,</span><span class="s3">\n    </span><span class="s1">sharedContext,</span><span class="s3">\n    </span><span class="s1">fallbackRouteParams</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function applyMetadataFromPrerenderResult(</span><span class="s3">\n  </span><span class="s1">response: Pick&lt;</span><span class="s3">\n    </span><span class="s1">PrerenderToStreamResult,</span><span class="s3">\n    </span><span class="s1">| 'collectedExpire'</span><span class="s3">\n    </span><span class="s1">| 'collectedRevalidate'</span><span class="s3">\n    </span><span class="s1">| 'collectedStale'</span><span class="s3">\n    </span><span class="s1">| 'collectedTags'</span><span class="s3">\n  </span><span class="s1">&gt;,</span><span class="s3">\n  </span><span class="s1">metadata: AppPageRenderResultMetadata,</span><span class="s3">\n  </span><span class="s1">workStore: WorkStore</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (response.collectedTags) {</span><span class="s3">\n    </span><span class="s1">metadata.fetchTags = response.collectedTags.join(',')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Let the client router know how long to keep the cached entry around.</span><span class="s3">\n  </span><span class="s1">const staleHeader = String(response.collectedStale)</span><span class="s3">\n  </span><span class="s1">metadata.headers ??= {}</span><span class="s3">\n  </span><span class="s1">metadata.headers[NEXT_ROUTER_STALE_TIME_HEADER] = staleHeader</span><span class="s3">\n\n  </span><span class="s1">// If force static is specifically set to false, we should not revalidate</span><span class="s3">\n  </span><span class="s1">// the page.</span><span class="s3">\n  </span><span class="s1">if (workStore.forceStatic === false || response.collectedRevalidate === 0) {</span><span class="s3">\n    </span><span class="s1">metadata.cacheControl = { revalidate: 0, expire: undefined }</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// Copy the cache control value onto the render result metadata.</span><span class="s3">\n    </span><span class="s1">metadata.cacheControl = {</span><span class="s3">\n      </span><span class="s1">revalidate:</span><span class="s3">\n        </span><span class="s1">response.collectedRevalidate &gt;= INFINITE_CACHE</span><span class="s3">\n          </span><span class="s1">? false</span><span class="s3">\n          </span><span class="s1">: response.collectedRevalidate,</span><span class="s3">\n      </span><span class="s1">expire:</span><span class="s3">\n        </span><span class="s1">response.collectedExpire &gt;= INFINITE_CACHE</span><span class="s3">\n          </span><span class="s1">? undefined</span><span class="s3">\n          </span><span class="s1">: response.collectedExpire,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// provide bailout info for debugging</span><span class="s3">\n  </span><span class="s1">if (metadata.cacheControl?.revalidate === 0) {</span><span class="s3">\n    </span><span class="s1">metadata.staticBailoutInfo = {</span><span class="s3">\n      </span><span class="s1">description: workStore.dynamicUsageDescription,</span><span class="s3">\n      </span><span class="s1">stack: workStore.dynamicUsageStack,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">async function renderToStream(</span><span class="s3">\n  </span><span class="s1">requestStore: RequestStore,</span><span class="s3">\n  </span><span class="s1">req: BaseNextRequest,</span><span class="s3">\n  </span><span class="s1">res: BaseNextResponse,</span><span class="s3">\n  </span><span class="s1">ctx: AppRenderContext,</span><span class="s3">\n  </span><span class="s1">tree: LoaderTree,</span><span class="s3">\n  </span><span class="s1">formState: any,</span><span class="s3">\n  </span><span class="s1">postponedState: PostponedState | null,</span><span class="s3">\n  </span><span class="s1">metadata: AppPageRenderResultMetadata,</span><span class="s3">\n  </span><span class="s1">devValidatingFallbackParams: FallbackRouteParams | null</span><span class="s3">\n</span><span class="s1">): Promise&lt;ReadableStream&lt;Uint8Array&gt;&gt; {</span><span class="s3">\n  </span><span class="s1">const { assetPrefix, nonce, pagePath, renderOpts } = ctx</span><span class="s3">\n\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">basePath,</span><span class="s3">\n    </span><span class="s1">buildManifest,</span><span class="s3">\n    </span><span class="s1">clientReferenceManifest,</span><span class="s3">\n    </span><span class="s1">ComponentMod,</span><span class="s3">\n    </span><span class="s1">crossOrigin,</span><span class="s3">\n    </span><span class="s1">dev = false,</span><span class="s3">\n    </span><span class="s1">experimental,</span><span class="s3">\n    </span><span class="s1">nextExport = false,</span><span class="s3">\n    </span><span class="s1">onInstrumentationRequestError,</span><span class="s3">\n    </span><span class="s1">page,</span><span class="s3">\n    </span><span class="s1">reactMaxHeadersLength,</span><span class="s3">\n    </span><span class="s1">shouldWaitOnAllReady,</span><span class="s3">\n    </span><span class="s1">subresourceIntegrityManifest,</span><span class="s3">\n    </span><span class="s1">supportsDynamicResponse,</span><span class="s3">\n  </span><span class="s1">} = renderOpts</span><span class="s3">\n\n  </span><span class="s1">assertClientReferenceManifest(clientReferenceManifest)</span><span class="s3">\n\n  </span><span class="s1">const { ServerInsertedHTMLProvider, renderServerInsertedHTML } =</span><span class="s3">\n    </span><span class="s1">createServerInsertedHTML()</span><span class="s3">\n  </span><span class="s1">const getServerInsertedMetadata = createServerInsertedMetadata(nonce)</span><span class="s3">\n\n  </span><span class="s1">const tracingMetadata = getTracedMetadata(</span><span class="s3">\n    </span><span class="s1">getTracer().getTracePropagationData(),</span><span class="s3">\n    </span><span class="s1">experimental.clientTraceMetadata</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const polyfills: JSX.IntrinsicElements['script'][] =</span><span class="s3">\n    </span><span class="s1">buildManifest.polyfillFiles</span><span class="s3">\n      </span><span class="s1">.filter(</span><span class="s3">\n        </span><span class="s1">(polyfill) =&gt;</span><span class="s3">\n          </span><span class="s1">polyfill.endsWith('.js') &amp;&amp; !polyfill.endsWith('.module.js')</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">.map((polyfill) =&gt; ({</span><span class="s3">\n        </span><span class="s1">src: `${assetPrefix}/_next/${polyfill}${getAssetQueryString(</span><span class="s3">\n          </span><span class="s1">ctx,</span><span class="s3">\n          </span><span class="s1">false</span><span class="s3">\n        </span><span class="s1">)}`,</span><span class="s3">\n        </span><span class="s1">integrity: subresourceIntegrityManifest?.[polyfill],</span><span class="s3">\n        </span><span class="s1">crossOrigin,</span><span class="s3">\n        </span><span class="s1">noModule: true,</span><span class="s3">\n        </span><span class="s1">nonce,</span><span class="s3">\n      </span><span class="s1">}))</span><span class="s3">\n\n  </span><span class="s1">const [preinitScripts, bootstrapScript] = getRequiredScripts(</span><span class="s3">\n    </span><span class="s1">buildManifest,</span><span class="s3">\n    </span><span class="s1">// Why is assetPrefix optional on renderOpts?</span><span class="s3">\n    </span><span class="s1">// @TODO make it default empty string on renderOpts and get rid of it from ctx</span><span class="s3">\n    </span><span class="s1">assetPrefix,</span><span class="s3">\n    </span><span class="s1">crossOrigin,</span><span class="s3">\n    </span><span class="s1">subresourceIntegrityManifest,</span><span class="s3">\n    </span><span class="s1">getAssetQueryString(ctx, true),</span><span class="s3">\n    </span><span class="s1">nonce,</span><span class="s3">\n    </span><span class="s1">page</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const reactServerErrorsByDigest: Map&lt;string, DigestedError&gt; = new Map()</span><span class="s3">\n  </span><span class="s1">const silenceLogger = false</span><span class="s3">\n  </span><span class="s1">function onHTMLRenderRSCError(err: DigestedError) {</span><span class="s3">\n    </span><span class="s1">return onInstrumentationRequestError?.(</span><span class="s3">\n      </span><span class="s1">err,</span><span class="s3">\n      </span><span class="s1">req,</span><span class="s3">\n      </span><span class="s1">createErrorContext(ctx, 'react-server-components')</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const serverComponentsErrorHandler = createHTMLReactServerErrorHandler(</span><span class="s3">\n    </span><span class="s1">dev,</span><span class="s3">\n    </span><span class="s1">nextExport,</span><span class="s3">\n    </span><span class="s1">reactServerErrorsByDigest,</span><span class="s3">\n    </span><span class="s1">silenceLogger,</span><span class="s3">\n    </span><span class="s1">onHTMLRenderRSCError</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">function onHTMLRenderSSRError(err: DigestedError) {</span><span class="s3">\n    </span><span class="s1">return onInstrumentationRequestError?.(</span><span class="s3">\n      </span><span class="s1">err,</span><span class="s3">\n      </span><span class="s1">req,</span><span class="s3">\n      </span><span class="s1">createErrorContext(ctx, 'server-rendering')</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const allCapturedErrors: Array&lt;unknown&gt; = []</span><span class="s3">\n  </span><span class="s1">const htmlRendererErrorHandler = createHTMLErrorHandler(</span><span class="s3">\n    </span><span class="s1">dev,</span><span class="s3">\n    </span><span class="s1">nextExport,</span><span class="s3">\n    </span><span class="s1">reactServerErrorsByDigest,</span><span class="s3">\n    </span><span class="s1">allCapturedErrors,</span><span class="s3">\n    </span><span class="s1">silenceLogger,</span><span class="s3">\n    </span><span class="s1">onHTMLRenderSSRError</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">let reactServerResult: null | ReactServerResult = null</span><span class="s3">\n\n  </span><span class="s1">const setHeader = res.setHeader.bind(res)</span><span class="s3">\n  </span><span class="s1">const appendHeader = res.appendHeader.bind(res)</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">// We only want this behavior when running `next dev`</span><span class="s3">\n      </span><span class="s1">dev &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// We only want this behavior when we have React's dev builds available</span><span class="s3">\n      </span><span class="s1">process.env.NODE_ENV === 'development' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// Edge routes never prerender so we don't have a Prerender environment for anything in edge runtime</span><span class="s3">\n      </span><span class="s1">process.env.NEXT_RUNTIME !== 'edge' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// We only have a Prerender environment for projects opted into cacheComponents</span><span class="s3">\n      </span><span class="s1">experimental.cacheComponents</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// This is a dynamic render. We don't do dynamic tracking because we're not prerendering</span><span class="s3">\n      </span><span class="s1">const RSCPayload: InitialRSCPayload &amp; {</span><span class="s3">\n        </span><span class="s1">/** Only available during cacheComponents development builds. Used for logging errors. */</span><span class="s3">\n        </span><span class="s1">_validation?: Promise&lt;React.ReactNode&gt;</span><span class="s3">\n      </span><span class="s1">} = await workUnitAsyncStorage.run(</span><span class="s3">\n        </span><span class="s1">requestStore,</span><span class="s3">\n        </span><span class="s1">getRSCPayload,</span><span class="s3">\n        </span><span class="s1">tree,</span><span class="s3">\n        </span><span class="s1">ctx,</span><span class="s3">\n        </span><span class="s1">res.statusCode === 404</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">const [resolveValidation, validationOutlet] = createValidationOutlet()</span><span class="s3">\n      </span><span class="s1">RSCPayload._validation = validationOutlet</span><span class="s3">\n\n      </span><span class="s1">const reactServerStream = await workUnitAsyncStorage.run(</span><span class="s3">\n        </span><span class="s1">requestStore,</span><span class="s3">\n        </span><span class="s1">scheduleInSequentialTasks,</span><span class="s3">\n        </span><span class="s1">() =&gt; {</span><span class="s3">\n          </span><span class="s1">requestStore.prerenderPhase = true</span><span class="s3">\n          </span><span class="s1">return ComponentMod.renderToReadableStream(</span><span class="s3">\n            </span><span class="s1">RSCPayload,</span><span class="s3">\n            </span><span class="s1">clientReferenceManifest.clientModules,</span><span class="s3">\n            </span><span class="s1">{</span><span class="s3">\n              </span><span class="s1">onError: serverComponentsErrorHandler,</span><span class="s3">\n              </span><span class="s1">environmentName: () =&gt;</span><span class="s3">\n                </span><span class="s1">requestStore.prerenderPhase === true ? 'Prerender' : 'Server',</span><span class="s3">\n              </span><span class="s1">filterStackFrame,</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">() =&gt; {</span><span class="s3">\n          </span><span class="s1">requestStore.prerenderPhase = false</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">spawnDynamicValidationInDev(</span><span class="s3">\n        </span><span class="s1">resolveValidation,</span><span class="s3">\n        </span><span class="s1">tree,</span><span class="s3">\n        </span><span class="s1">ctx,</span><span class="s3">\n        </span><span class="s1">res.statusCode === 404,</span><span class="s3">\n        </span><span class="s1">clientReferenceManifest,</span><span class="s3">\n        </span><span class="s1">requestStore,</span><span class="s3">\n        </span><span class="s1">devValidatingFallbackParams</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">reactServerResult = new ReactServerResult(reactServerStream)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// This is a dynamic render. We don't do dynamic tracking because we're not prerendering</span><span class="s3">\n      </span><span class="s1">const RSCPayload = await workUnitAsyncStorage.run(</span><span class="s3">\n        </span><span class="s1">requestStore,</span><span class="s3">\n        </span><span class="s1">getRSCPayload,</span><span class="s3">\n        </span><span class="s1">tree,</span><span class="s3">\n        </span><span class="s1">ctx,</span><span class="s3">\n        </span><span class="s1">res.statusCode === 404</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">reactServerResult = new ReactServerResult(</span><span class="s3">\n        </span><span class="s1">workUnitAsyncStorage.run(</span><span class="s3">\n          </span><span class="s1">requestStore,</span><span class="s3">\n          </span><span class="s1">ComponentMod.renderToReadableStream,</span><span class="s3">\n          </span><span class="s1">RSCPayload,</span><span class="s3">\n          </span><span class="s1">clientReferenceManifest.clientModules,</span><span class="s3">\n          </span><span class="s1">{</span><span class="s3">\n            </span><span class="s1">filterStackFrame,</span><span class="s3">\n            </span><span class="s1">onError: serverComponentsErrorHandler,</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// React doesn't start rendering synchronously but we want the RSC render to have a chance to start</span><span class="s3">\n    </span><span class="s1">// before we begin SSR rendering because we want to capture any available preload headers so we tick</span><span class="s3">\n    </span><span class="s1">// one task before continuing</span><span class="s3">\n    </span><span class="s1">await waitAtLeastOneReactRenderTask()</span><span class="s3">\n\n    </span><span class="s1">// If provided, the postpone state should be parsed as JSON so it can be</span><span class="s3">\n    </span><span class="s1">// provided to React.</span><span class="s3">\n    </span><span class="s1">if (typeof renderOpts.postponed === 'string') {</span><span class="s3">\n      </span><span class="s1">if (postponedState?.type === DynamicState.DATA) {</span><span class="s3">\n        </span><span class="s1">// We have a complete HTML Document in the prerender but we need to</span><span class="s3">\n        </span><span class="s1">// still include the new server component render because it was not included</span><span class="s3">\n        </span><span class="s1">// in the static prelude.</span><span class="s3">\n        </span><span class="s1">const inlinedReactServerDataStream = createInlinedDataReadableStream(</span><span class="s3">\n          </span><span class="s1">reactServerResult.tee(),</span><span class="s3">\n          </span><span class="s1">nonce,</span><span class="s3">\n          </span><span class="s1">formState</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">return chainStreams(</span><span class="s3">\n          </span><span class="s1">inlinedReactServerDataStream,</span><span class="s3">\n          </span><span class="s1">createDocumentClosingStream()</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">} else if (postponedState) {</span><span class="s3">\n        </span><span class="s1">// We assume we have dynamic HTML requiring a resume render to complete</span><span class="s3">\n        </span><span class="s1">const { postponed, preludeState } =</span><span class="s3">\n          </span><span class="s1">getPostponedFromState(postponedState)</span><span class="s3">\n        </span><span class="s1">const resume = (</span><span class="s3">\n          </span><span class="s1">require('react-dom/server') as typeof import('react-dom/server')</span><span class="s3">\n        </span><span class="s1">).resume</span><span class="s3">\n\n        </span><span class="s1">const htmlStream = await workUnitAsyncStorage.run(</span><span class="s3">\n          </span><span class="s1">requestStore,</span><span class="s3">\n          </span><span class="s1">resume,</span><span class="s3">\n          </span><span class="s1">&lt;App</span><span class="s3">\n            </span><span class="s1">reactServerStream={reactServerResult.tee()}</span><span class="s3">\n            </span><span class="s1">preinitScripts={preinitScripts}</span><span class="s3">\n            </span><span class="s1">clientReferenceManifest={clientReferenceManifest}</span><span class="s3">\n            </span><span class="s1">ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}</span><span class="s3">\n            </span><span class="s1">nonce={nonce}</span><span class="s3">\n          </span><span class="s1">/&gt;,</span><span class="s3">\n          </span><span class="s1">postponed,</span><span class="s3">\n          </span><span class="s1">{ onError: htmlRendererErrorHandler, nonce }</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">const getServerInsertedHTML = makeGetServerInsertedHTML({</span><span class="s3">\n          </span><span class="s1">polyfills,</span><span class="s3">\n          </span><span class="s1">renderServerInsertedHTML,</span><span class="s3">\n          </span><span class="s1">serverCapturedErrors: allCapturedErrors,</span><span class="s3">\n          </span><span class="s1">basePath,</span><span class="s3">\n          </span><span class="s1">tracingMetadata: tracingMetadata,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">return await continueDynamicHTMLResume(htmlStream, {</span><span class="s3">\n          </span><span class="s1">// If the prelude is empty (i.e. is no static shell), we should wait for initial HTML to be rendered</span><span class="s3">\n          </span><span class="s1">// to avoid injecting RSC data too early.</span><span class="s3">\n          </span><span class="s1">// If we have a non-empty-prelude (i.e. a static HTML shell), then it's already been sent separately,</span><span class="s3">\n          </span><span class="s1">// so we shouldn't wait for any HTML to be emitted from the resume before sending RSC data.</span><span class="s3">\n          </span><span class="s1">delayDataUntilFirstHtmlChunk:</span><span class="s3">\n            </span><span class="s1">preludeState === DynamicHTMLPreludeState.Empty,</span><span class="s3">\n          </span><span class="s1">inlinedDataStream: createInlinedDataReadableStream(</span><span class="s3">\n            </span><span class="s1">reactServerResult.consume(),</span><span class="s3">\n            </span><span class="s1">nonce,</span><span class="s3">\n            </span><span class="s1">formState</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">getServerInsertedHTML,</span><span class="s3">\n          </span><span class="s1">getServerInsertedMetadata,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// This is a regular dynamic render</span><span class="s3">\n    </span><span class="s1">const renderToReadableStream = (</span><span class="s3">\n      </span><span class="s1">require('react-dom/server') as typeof import('react-dom/server')</span><span class="s3">\n    </span><span class="s1">).renderToReadableStream</span><span class="s3">\n\n    </span><span class="s1">const htmlStream = await workUnitAsyncStorage.run(</span><span class="s3">\n      </span><span class="s1">requestStore,</span><span class="s3">\n      </span><span class="s1">renderToReadableStream,</span><span class="s3">\n      </span><span class="s1">&lt;App</span><span class="s3">\n        </span><span class="s1">reactServerStream={reactServerResult.tee()}</span><span class="s3">\n        </span><span class="s1">preinitScripts={preinitScripts}</span><span class="s3">\n        </span><span class="s1">clientReferenceManifest={clientReferenceManifest}</span><span class="s3">\n        </span><span class="s1">ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}</span><span class="s3">\n        </span><span class="s1">nonce={nonce}</span><span class="s3">\n      </span><span class="s1">/&gt;,</span><span class="s3">\n      </span><span class="s1">{</span><span class="s3">\n        </span><span class="s1">onError: htmlRendererErrorHandler,</span><span class="s3">\n        </span><span class="s1">nonce,</span><span class="s3">\n        </span><span class="s1">onHeaders: (headers: Headers) =&gt; {</span><span class="s3">\n          </span><span class="s1">headers.forEach((value, key) =&gt; {</span><span class="s3">\n            </span><span class="s1">appendHeader(key, value)</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">maxHeadersLength: reactMaxHeadersLength,</span><span class="s3">\n        </span><span class="s1">bootstrapScripts: [bootstrapScript],</span><span class="s3">\n        </span><span class="s1">formState,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">const getServerInsertedHTML = makeGetServerInsertedHTML({</span><span class="s3">\n      </span><span class="s1">polyfills,</span><span class="s3">\n      </span><span class="s1">renderServerInsertedHTML,</span><span class="s3">\n      </span><span class="s1">serverCapturedErrors: allCapturedErrors,</span><span class="s3">\n      </span><span class="s1">basePath,</span><span class="s3">\n      </span><span class="s1">tracingMetadata: tracingMetadata,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Rules of Static &amp; Dynamic HTML:</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">*    1.) We must generate static HTML unless the caller explicitly opts</span><span class="s3">\n     </span><span class="s1">*        in to dynamic HTML support.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">*    2.) If dynamic HTML support is requested, we must honor that request</span><span class="s3">\n     </span><span class="s1">*        or throw an error. It is the sole responsibility of the caller to</span><span class="s3">\n     </span><span class="s1">*        ensure they aren't e.g. requesting dynamic HTML for an AMP page.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">*   3.) If `shouldWaitOnAllReady` is true, which indicates we need to</span><span class="s3">\n     </span><span class="s1">*       resolve all suspenses and generate a full HTML. e.g. when it's a</span><span class="s3">\n     </span><span class="s1">*       html limited bot requests, we produce the full HTML content.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* These rules help ensure that other existing features like request caching,</span><span class="s3">\n     </span><span class="s1">* coalescing, and ISR continue working as intended.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">const generateStaticHTML =</span><span class="s3">\n      </span><span class="s1">supportsDynamicResponse !== true || !!shouldWaitOnAllReady</span><span class="s3">\n\n    </span><span class="s1">return await continueFizzStream(htmlStream, {</span><span class="s3">\n      </span><span class="s1">inlinedDataStream: createInlinedDataReadableStream(</span><span class="s3">\n        </span><span class="s1">reactServerResult.consume(),</span><span class="s3">\n        </span><span class="s1">nonce,</span><span class="s3">\n        </span><span class="s1">formState</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">isStaticGeneration: generateStaticHTML,</span><span class="s3">\n      </span><span class="s1">isBuildTimePrerendering: ctx.workStore.isBuildTimePrerendering === true,</span><span class="s3">\n      </span><span class="s1">buildId: ctx.workStore.buildId,</span><span class="s3">\n      </span><span class="s1">getServerInsertedHTML,</span><span class="s3">\n      </span><span class="s1">getServerInsertedMetadata,</span><span class="s3">\n      </span><span class="s1">validateRootLayout: dev,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">} catch (err) {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">isStaticGenBailoutError(err) ||</span><span class="s3">\n      </span><span class="s1">(typeof err === 'object' &amp;&amp;</span><span class="s3">\n        </span><span class="s1">err !== null &amp;&amp;</span><span class="s3">\n        </span><span class="s1">'message' in err &amp;&amp;</span><span class="s3">\n        </span><span class="s1">typeof err.message === 'string' &amp;&amp;</span><span class="s3">\n        </span><span class="s1">err.message.includes(</span><span class="s3">\n          </span><span class="s1">'https://nextjs.org/docs/advanced-features/static-html-export'</span><span class="s3">\n        </span><span class="s1">))</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// Ensure that </span><span class="s3">\&quot;</span><span class="s1">next dev</span><span class="s3">\&quot; </span><span class="s1">prints the red error overlay</span><span class="s3">\n      </span><span class="s1">throw err</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If a bailout made it to this point, it means it wasn't wrapped inside</span><span class="s3">\n    </span><span class="s1">// a suspense boundary.</span><span class="s3">\n    </span><span class="s1">const shouldBailoutToCSR = isBailoutToCSRError(err)</span><span class="s3">\n    </span><span class="s1">if (shouldBailoutToCSR) {</span><span class="s3">\n      </span><span class="s1">const stack = getStackWithoutErrorMessage(err)</span><span class="s3">\n      </span><span class="s1">error(</span><span class="s3">\n        </span><span class="s1">`${err.reason} should be wrapped in a suspense boundary at page </span><span class="s3">\&quot;</span><span class="s1">${pagePath}</span><span class="s3">\&quot;</span><span class="s1">. Read more: https://nextjs.org/docs/messages/missing-suspense-with-csr-bailout</span><span class="s3">\\</span><span class="s1">n${stack}`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">throw err</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let errorType: MetadataErrorType | 'redirect' | undefined</span><span class="s3">\n\n    </span><span class="s1">if (isHTTPAccessFallbackError(err)) {</span><span class="s3">\n      </span><span class="s1">res.statusCode = getAccessFallbackHTTPStatus(err)</span><span class="s3">\n      </span><span class="s1">metadata.statusCode = res.statusCode</span><span class="s3">\n      </span><span class="s1">errorType = getAccessFallbackErrorTypeByStatus(res.statusCode)</span><span class="s3">\n    </span><span class="s1">} else if (isRedirectError(err)) {</span><span class="s3">\n      </span><span class="s1">errorType = 'redirect'</span><span class="s3">\n      </span><span class="s1">res.statusCode = getRedirectStatusCodeFromError(err)</span><span class="s3">\n      </span><span class="s1">metadata.statusCode = res.statusCode</span><span class="s3">\n\n      </span><span class="s1">const redirectUrl = addPathPrefix(getURLFromRedirectError(err), basePath)</span><span class="s3">\n\n      </span><span class="s1">// If there were mutable cookies set, we need to set them on the</span><span class="s3">\n      </span><span class="s1">// response.</span><span class="s3">\n      </span><span class="s1">const headers = new Headers()</span><span class="s3">\n      </span><span class="s1">if (appendMutableCookies(headers, requestStore.mutableCookies)) {</span><span class="s3">\n        </span><span class="s1">setHeader('set-cookie', Array.from(headers.values()))</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">setHeader('location', redirectUrl)</span><span class="s3">\n    </span><span class="s1">} else if (!shouldBailoutToCSR) {</span><span class="s3">\n      </span><span class="s1">res.statusCode = 500</span><span class="s3">\n      </span><span class="s1">metadata.statusCode = res.statusCode</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const [errorPreinitScripts, errorBootstrapScript] = getRequiredScripts(</span><span class="s3">\n      </span><span class="s1">buildManifest,</span><span class="s3">\n      </span><span class="s1">assetPrefix,</span><span class="s3">\n      </span><span class="s1">crossOrigin,</span><span class="s3">\n      </span><span class="s1">subresourceIntegrityManifest,</span><span class="s3">\n      </span><span class="s1">getAssetQueryString(ctx, false),</span><span class="s3">\n      </span><span class="s1">nonce,</span><span class="s3">\n      </span><span class="s1">'/_not-found/page'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">const errorRSCPayload = await workUnitAsyncStorage.run(</span><span class="s3">\n      </span><span class="s1">requestStore,</span><span class="s3">\n      </span><span class="s1">getErrorRSCPayload,</span><span class="s3">\n      </span><span class="s1">tree,</span><span class="s3">\n      </span><span class="s1">ctx,</span><span class="s3">\n      </span><span class="s1">reactServerErrorsByDigest.has((err as any).digest) ? null : err,</span><span class="s3">\n      </span><span class="s1">errorType</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">const errorServerStream = workUnitAsyncStorage.run(</span><span class="s3">\n      </span><span class="s1">requestStore,</span><span class="s3">\n      </span><span class="s1">ComponentMod.renderToReadableStream,</span><span class="s3">\n      </span><span class="s1">errorRSCPayload,</span><span class="s3">\n      </span><span class="s1">clientReferenceManifest.clientModules,</span><span class="s3">\n      </span><span class="s1">{</span><span class="s3">\n        </span><span class="s1">filterStackFrame,</span><span class="s3">\n        </span><span class="s1">onError: serverComponentsErrorHandler,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">if (reactServerResult === null) {</span><span class="s3">\n      </span><span class="s1">// We errored when we did not have an RSC stream to read from. This is not just a render</span><span class="s3">\n      </span><span class="s1">// error, we need to throw early</span><span class="s3">\n      </span><span class="s1">throw err</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">const fizzStream = await workUnitAsyncStorage.run(</span><span class="s3">\n        </span><span class="s1">requestStore,</span><span class="s3">\n        </span><span class="s1">renderToInitialFizzStream,</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">ReactDOMServer:</span><span class="s3">\n            </span><span class="s1">require('react-dom/server') as typeof import('react-dom/server'),</span><span class="s3">\n          </span><span class="s1">element: (</span><span class="s3">\n            </span><span class="s1">&lt;ErrorApp</span><span class="s3">\n              </span><span class="s1">reactServerStream={errorServerStream}</span><span class="s3">\n              </span><span class="s1">ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}</span><span class="s3">\n              </span><span class="s1">preinitScripts={errorPreinitScripts}</span><span class="s3">\n              </span><span class="s1">clientReferenceManifest={clientReferenceManifest}</span><span class="s3">\n              </span><span class="s1">nonce={nonce}</span><span class="s3">\n            </span><span class="s1">/&gt;</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">streamOptions: {</span><span class="s3">\n            </span><span class="s1">nonce,</span><span class="s3">\n            </span><span class="s1">// Include hydration scripts in the HTML</span><span class="s3">\n            </span><span class="s1">bootstrapScripts: [errorBootstrapScript],</span><span class="s3">\n            </span><span class="s1">formState,</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">/**</span><span class="s3">\n       </span><span class="s1">* Rules of Static &amp; Dynamic HTML:</span><span class="s3">\n       </span><span class="s1">*</span><span class="s3">\n       </span><span class="s1">*    1.) We must generate static HTML unless the caller explicitly opts</span><span class="s3">\n       </span><span class="s1">*        in to dynamic HTML support.</span><span class="s3">\n       </span><span class="s1">*</span><span class="s3">\n       </span><span class="s1">*    2.) If dynamic HTML support is requested, we must honor that request</span><span class="s3">\n       </span><span class="s1">*        or throw an error. It is the sole responsibility of the caller to</span><span class="s3">\n       </span><span class="s1">*        ensure they aren't e.g. requesting dynamic HTML for an AMP page.</span><span class="s3">\n       </span><span class="s1">*    3.) If `shouldWaitOnAllReady` is true, which indicates we need to</span><span class="s3">\n       </span><span class="s1">*        resolve all suspenses and generate a full HTML. e.g. when it's a</span><span class="s3">\n       </span><span class="s1">*        html limited bot requests, we produce the full HTML content.</span><span class="s3">\n       </span><span class="s1">*</span><span class="s3">\n       </span><span class="s1">* These rules help ensure that other existing features like request caching,</span><span class="s3">\n       </span><span class="s1">* coalescing, and ISR continue working as intended.</span><span class="s3">\n       </span><span class="s1">*/</span><span class="s3">\n      </span><span class="s1">const generateStaticHTML =</span><span class="s3">\n        </span><span class="s1">supportsDynamicResponse !== true || !!shouldWaitOnAllReady</span><span class="s3">\n      </span><span class="s1">return await continueFizzStream(fizzStream, {</span><span class="s3">\n        </span><span class="s1">inlinedDataStream: createInlinedDataReadableStream(</span><span class="s3">\n          </span><span class="s1">// This is intentionally using the readable datastream from the</span><span class="s3">\n          </span><span class="s1">// main render rather than the flight data from the error page</span><span class="s3">\n          </span><span class="s1">// render</span><span class="s3">\n          </span><span class="s1">reactServerResult.consume(),</span><span class="s3">\n          </span><span class="s1">nonce,</span><span class="s3">\n          </span><span class="s1">formState</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">isStaticGeneration: generateStaticHTML,</span><span class="s3">\n        </span><span class="s1">isBuildTimePrerendering: ctx.workStore.isBuildTimePrerendering === true,</span><span class="s3">\n        </span><span class="s1">buildId: ctx.workStore.buildId,</span><span class="s3">\n        </span><span class="s1">getServerInsertedHTML: makeGetServerInsertedHTML({</span><span class="s3">\n          </span><span class="s1">polyfills,</span><span class="s3">\n          </span><span class="s1">renderServerInsertedHTML,</span><span class="s3">\n          </span><span class="s1">serverCapturedErrors: [],</span><span class="s3">\n          </span><span class="s1">basePath,</span><span class="s3">\n          </span><span class="s1">tracingMetadata: tracingMetadata,</span><span class="s3">\n        </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">getServerInsertedMetadata,</span><span class="s3">\n        </span><span class="s1">validateRootLayout: dev,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">} catch (finalErr: any) {</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">process.env.NODE_ENV === 'development' &amp;&amp;</span><span class="s3">\n        </span><span class="s1">isHTTPAccessFallbackError(finalErr)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">const { bailOnRootNotFound } =</span><span class="s3">\n          </span><span class="s1">require('../../client/components/dev-root-http-access-fallback-boundary') as typeof import('../../client/components/dev-root-http-access-fallback-boundary')</span><span class="s3">\n        </span><span class="s1">bailOnRootNotFound()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">throw finalErr</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createValidationOutlet() {</span><span class="s3">\n  </span><span class="s1">let resolveValidation: (value: React.ReactNode) =&gt; void</span><span class="s3">\n  </span><span class="s1">let outlet = new Promise&lt;React.ReactNode&gt;((resolve) =&gt; {</span><span class="s3">\n    </span><span class="s1">resolveValidation = resolve</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">return [resolveValidation!, outlet] as const</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This function is a fork of prerenderToStream cacheComponents branch.</span><span class="s3">\n </span><span class="s1">* While it doesn't return a stream we want it to have identical</span><span class="s3">\n </span><span class="s1">* prerender semantics to prerenderToStream and should update it</span><span class="s3">\n </span><span class="s1">* in conjunction with any changes to that function.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">async function spawnDynamicValidationInDev(</span><span class="s3">\n  </span><span class="s1">resolveValidation: (validatingElement: React.ReactNode) =&gt; void,</span><span class="s3">\n  </span><span class="s1">tree: LoaderTree,</span><span class="s3">\n  </span><span class="s1">ctx: AppRenderContext,</span><span class="s3">\n  </span><span class="s1">isNotFound: boolean,</span><span class="s3">\n  </span><span class="s1">clientReferenceManifest: NonNullable&lt;RenderOpts['clientReferenceManifest']&gt;,</span><span class="s3">\n  </span><span class="s1">requestStore: RequestStore,</span><span class="s3">\n  </span><span class="s1">fallbackRouteParams: FallbackRouteParams | null</span><span class="s3">\n</span><span class="s1">): Promise&lt;void&gt; {</span><span class="s3">\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">componentMod: ComponentMod,</span><span class="s3">\n    </span><span class="s1">getDynamicParamFromSegment,</span><span class="s3">\n    </span><span class="s1">implicitTags,</span><span class="s3">\n    </span><span class="s1">nonce,</span><span class="s3">\n    </span><span class="s1">renderOpts,</span><span class="s3">\n    </span><span class="s1">workStore,</span><span class="s3">\n  </span><span class="s1">} = ctx</span><span class="s3">\n\n  </span><span class="s1">const { allowEmptyStaticShell = false } = renderOpts</span><span class="s3">\n\n  </span><span class="s1">// These values are placeholder values for this validating render</span><span class="s3">\n  </span><span class="s1">// that are provided during the actual prerenderToStream.</span><span class="s3">\n  </span><span class="s1">const preinitScripts = () =&gt; {}</span><span class="s3">\n  </span><span class="s1">const { ServerInsertedHTMLProvider } = createServerInsertedHTML()</span><span class="s3">\n\n  </span><span class="s1">const rootParams = getRootParams(</span><span class="s3">\n    </span><span class="s1">ComponentMod.tree,</span><span class="s3">\n    </span><span class="s1">getDynamicParamFromSegment</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const hmrRefreshHash = requestStore.cookies.get(</span><span class="s3">\n    </span><span class="s1">NEXT_HMR_REFRESH_HASH_COOKIE</span><span class="s3">\n  </span><span class="s1">)?.value</span><span class="s3">\n\n  </span><span class="s1">// The prerender controller represents the lifetime of the prerender. It will</span><span class="s3">\n  </span><span class="s1">// be aborted when a task is complete or a synchronously aborting API is</span><span class="s3">\n  </span><span class="s1">// called. Notably, during prospective prerenders, this does not actually</span><span class="s3">\n  </span><span class="s1">// terminate the prerender itself, which will continue until all caches are</span><span class="s3">\n  </span><span class="s1">// filled.</span><span class="s3">\n  </span><span class="s1">const initialServerPrerenderController = new AbortController()</span><span class="s3">\n\n  </span><span class="s1">// This controller is used to abort the React prerender.</span><span class="s3">\n  </span><span class="s1">const initialServerReactController = new AbortController()</span><span class="s3">\n\n  </span><span class="s1">// This controller represents the lifetime of the React prerender. Its signal</span><span class="s3">\n  </span><span class="s1">// can be used for any I/O operation to abort the I/O and/or to reject, when</span><span class="s3">\n  </span><span class="s1">// prerendering aborts. This includes our own hanging promises for accessing</span><span class="s3">\n  </span><span class="s1">// request data, and for fetch calls. It might be replaced in the future by</span><span class="s3">\n  </span><span class="s1">// React.cacheSignal(). It's aborted after the React controller, so that no</span><span class="s3">\n  </span><span class="s1">// pending I/O can register abort listeners that are called before React's</span><span class="s3">\n  </span><span class="s1">// abort listener is called. This ensures that pending I/O is not rejected too</span><span class="s3">\n  </span><span class="s1">// early when aborting the prerender. Notably, during the prospective</span><span class="s3">\n  </span><span class="s1">// prerender, it is different from the prerender controller because we don't</span><span class="s3">\n  </span><span class="s1">// want to end the React prerender until all caches are filled.</span><span class="s3">\n  </span><span class="s1">const initialServerRenderController = new AbortController()</span><span class="s3">\n\n  </span><span class="s1">// The cacheSignal helps us track whether caches are still filling or we are</span><span class="s3">\n  </span><span class="s1">// ready to cut the render off.</span><span class="s3">\n  </span><span class="s1">const cacheSignal = new CacheSignal()</span><span class="s3">\n\n  </span><span class="s1">const captureOwnerStackClient = React.captureOwnerStack</span><span class="s3">\n  </span><span class="s1">const captureOwnerStackServer = ComponentMod.captureOwnerStack</span><span class="s3">\n\n  </span><span class="s1">// The resume data cache here should use a fresh instance as it's</span><span class="s3">\n  </span><span class="s1">// performing a fresh prerender. If we get to implementing the</span><span class="s3">\n  </span><span class="s1">// prerendering of an already prerendered page, we should use the passed</span><span class="s3">\n  </span><span class="s1">// resume data cache instead.</span><span class="s3">\n  </span><span class="s1">const prerenderResumeDataCache = createPrerenderResumeDataCache()</span><span class="s3">\n  </span><span class="s1">const initialServerPayloadPrerenderStore: PrerenderStore = {</span><span class="s3">\n    </span><span class="s1">type: 'prerender',</span><span class="s3">\n    </span><span class="s1">phase: 'render',</span><span class="s3">\n    </span><span class="s1">rootParams,</span><span class="s3">\n    </span><span class="s1">fallbackRouteParams,</span><span class="s3">\n    </span><span class="s1">implicitTags,</span><span class="s3">\n    </span><span class="s1">// While this render signal isn't going to be used to abort a React render while getting the RSC payload</span><span class="s3">\n    </span><span class="s1">// various request data APIs bind to this controller to reject after completion.</span><span class="s3">\n    </span><span class="s1">renderSignal: initialServerRenderController.signal,</span><span class="s3">\n    </span><span class="s1">// When we generate the RSC payload we might abort this controller due to sync IO</span><span class="s3">\n    </span><span class="s1">// but we don't actually care about sync IO in this phase so we use a throw away controller</span><span class="s3">\n    </span><span class="s1">// that isn't connected to anything</span><span class="s3">\n    </span><span class="s1">controller: new AbortController(),</span><span class="s3">\n    </span><span class="s1">// During the initial prerender we need to track all cache reads to ensure</span><span class="s3">\n    </span><span class="s1">// we render long enough to fill every cache it is possible to visit during</span><span class="s3">\n    </span><span class="s1">// the final prerender.</span><span class="s3">\n    </span><span class="s1">cacheSignal,</span><span class="s3">\n    </span><span class="s1">dynamicTracking: null,</span><span class="s3">\n    </span><span class="s1">allowEmptyStaticShell,</span><span class="s3">\n    </span><span class="s1">revalidate: INFINITE_CACHE,</span><span class="s3">\n    </span><span class="s1">expire: INFINITE_CACHE,</span><span class="s3">\n    </span><span class="s1">stale: INFINITE_CACHE,</span><span class="s3">\n    </span><span class="s1">tags: [...implicitTags.tags],</span><span class="s3">\n    </span><span class="s1">prerenderResumeDataCache,</span><span class="s3">\n    </span><span class="s1">renderResumeDataCache: null,</span><span class="s3">\n    </span><span class="s1">hmrRefreshHash,</span><span class="s3">\n    </span><span class="s1">captureOwnerStack: captureOwnerStackServer,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// We're not going to use the result of this render because the only time it could be used</span><span class="s3">\n  </span><span class="s1">// is if it completes in a microtask and that's likely very rare for any non-trivial app</span><span class="s3">\n  </span><span class="s1">const initialServerPayload = await workUnitAsyncStorage.run(</span><span class="s3">\n    </span><span class="s1">initialServerPayloadPrerenderStore,</span><span class="s3">\n    </span><span class="s1">getRSCPayload,</span><span class="s3">\n    </span><span class="s1">tree,</span><span class="s3">\n    </span><span class="s1">ctx,</span><span class="s3">\n    </span><span class="s1">isNotFound</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const initialServerPrerenderStore: PrerenderStore = {</span><span class="s3">\n    </span><span class="s1">type: 'prerender',</span><span class="s3">\n    </span><span class="s1">phase: 'render',</span><span class="s3">\n    </span><span class="s1">rootParams,</span><span class="s3">\n    </span><span class="s1">fallbackRouteParams,</span><span class="s3">\n    </span><span class="s1">implicitTags,</span><span class="s3">\n    </span><span class="s1">renderSignal: initialServerRenderController.signal,</span><span class="s3">\n    </span><span class="s1">controller: initialServerPrerenderController,</span><span class="s3">\n    </span><span class="s1">// During the initial prerender we need to track all cache reads to ensure</span><span class="s3">\n    </span><span class="s1">// we render long enough to fill every cache it is possible to visit during</span><span class="s3">\n    </span><span class="s1">// the final prerender.</span><span class="s3">\n    </span><span class="s1">cacheSignal,</span><span class="s3">\n    </span><span class="s1">dynamicTracking: null,</span><span class="s3">\n    </span><span class="s1">allowEmptyStaticShell,</span><span class="s3">\n    </span><span class="s1">revalidate: INFINITE_CACHE,</span><span class="s3">\n    </span><span class="s1">expire: INFINITE_CACHE,</span><span class="s3">\n    </span><span class="s1">stale: INFINITE_CACHE,</span><span class="s3">\n    </span><span class="s1">tags: [...implicitTags.tags],</span><span class="s3">\n    </span><span class="s1">prerenderResumeDataCache,</span><span class="s3">\n    </span><span class="s1">renderResumeDataCache: null,</span><span class="s3">\n    </span><span class="s1">hmrRefreshHash,</span><span class="s3">\n    </span><span class="s1">captureOwnerStack: captureOwnerStackServer,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const pendingInitialServerResult = workUnitAsyncStorage.run(</span><span class="s3">\n    </span><span class="s1">initialServerPrerenderStore,</span><span class="s3">\n    </span><span class="s1">ComponentMod.prerender,</span><span class="s3">\n    </span><span class="s1">initialServerPayload,</span><span class="s3">\n    </span><span class="s1">clientReferenceManifest.clientModules,</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">filterStackFrame,</span><span class="s3">\n      </span><span class="s1">onError: (err) =&gt; {</span><span class="s3">\n        </span><span class="s1">const digest = getDigestForWellKnownError(err)</span><span class="s3">\n\n        </span><span class="s1">if (digest) {</span><span class="s3">\n          </span><span class="s1">return digest</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (isReactLargeShellError(err)) {</span><span class="s3">\n          </span><span class="s1">// TODO: Aggregate</span><span class="s3">\n          </span><span class="s1">console.error(err)</span><span class="s3">\n          </span><span class="s1">return undefined</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (initialServerPrerenderController.signal.aborted) {</span><span class="s3">\n          </span><span class="s1">// The render aborted before this error was handled which indicates</span><span class="s3">\n          </span><span class="s1">// the error is caused by unfinished components within the render</span><span class="s3">\n          </span><span class="s1">return</span><span class="s3">\n        </span><span class="s1">} else if (</span><span class="s3">\n          </span><span class="s1">process.env.NEXT_DEBUG_BUILD ||</span><span class="s3">\n          </span><span class="s1">process.env.__NEXT_VERBOSE_LOGGING</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">printDebugThrownValueForProspectiveRender(err, workStore.route)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">// we don't care to track postpones during the prospective render because we need</span><span class="s3">\n      </span><span class="s1">// to always do a final render anyway</span><span class="s3">\n      </span><span class="s1">onPostpone: undefined,</span><span class="s3">\n      </span><span class="s1">// We don't want to stop rendering until the cacheSignal is complete so we pass</span><span class="s3">\n      </span><span class="s1">// a different signal to this render call than is used by dynamic APIs to signify</span><span class="s3">\n      </span><span class="s1">// transitioning out of the prerender environment</span><span class="s3">\n      </span><span class="s1">signal: initialServerReactController.signal,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">// The listener to abort our own render controller must be added after React</span><span class="s3">\n  </span><span class="s1">// has added its listener, to ensure that pending I/O is not aborted/rejected</span><span class="s3">\n  </span><span class="s1">// too early.</span><span class="s3">\n  </span><span class="s1">initialServerReactController.signal.addEventListener(</span><span class="s3">\n    </span><span class="s1">'abort',</span><span class="s3">\n    </span><span class="s1">() =&gt; {</span><span class="s3">\n      </span><span class="s1">initialServerRenderController.abort()</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ once: true }</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">// Wait for all caches to be finished filling and for async imports to resolve</span><span class="s3">\n  </span><span class="s1">trackPendingModules(cacheSignal)</span><span class="s3">\n  </span><span class="s1">await cacheSignal.cacheReady()</span><span class="s3">\n\n  </span><span class="s1">initialServerReactController.abort()</span><span class="s3">\n\n  </span><span class="s1">// We don't need to continue the prerender process if we already</span><span class="s3">\n  </span><span class="s1">// detected invalid dynamic usage in the initial prerender phase.</span><span class="s3">\n  </span><span class="s1">const { invalidDynamicUsageError } = workStore</span><span class="s3">\n  </span><span class="s1">if (invalidDynamicUsageError) {</span><span class="s3">\n    </span><span class="s1">resolveValidation(</span><span class="s3">\n      </span><span class="s1">&lt;LogSafely</span><span class="s3">\n        </span><span class="s1">fn={() =&gt; {</span><span class="s3">\n          </span><span class="s1">console.error(invalidDynamicUsageError)</span><span class="s3">\n        </span><span class="s1">}}</span><span class="s3">\n      </span><span class="s1">/&gt;</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let initialServerResult</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">initialServerResult = await createReactServerPrerenderResult(</span><span class="s3">\n      </span><span class="s1">pendingInitialServerResult</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">} catch (err) {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">initialServerReactController.signal.aborted ||</span><span class="s3">\n      </span><span class="s1">initialServerPrerenderController.signal.aborted</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// These are expected errors that might error the prerender. we ignore them.</span><span class="s3">\n    </span><span class="s1">} else if (</span><span class="s3">\n      </span><span class="s1">process.env.NEXT_DEBUG_BUILD ||</span><span class="s3">\n      </span><span class="s1">process.env.__NEXT_VERBOSE_LOGGING</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// We don't normally log these errors because we are going to retry anyway but</span><span class="s3">\n      </span><span class="s1">// it can be useful for debugging Next.js itself to get visibility here when needed</span><span class="s3">\n      </span><span class="s1">printDebugThrownValueForProspectiveRender(err, workStore.route)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (initialServerResult) {</span><span class="s3">\n    </span><span class="s1">const initialClientPrerenderController = new AbortController()</span><span class="s3">\n    </span><span class="s1">const initialClientReactController = new AbortController()</span><span class="s3">\n    </span><span class="s1">const initialClientRenderController = new AbortController()</span><span class="s3">\n\n    </span><span class="s1">const initialClientPrerenderStore: PrerenderStore = {</span><span class="s3">\n      </span><span class="s1">type: 'prerender-client',</span><span class="s3">\n      </span><span class="s1">phase: 'render',</span><span class="s3">\n      </span><span class="s1">rootParams,</span><span class="s3">\n      </span><span class="s1">fallbackRouteParams,</span><span class="s3">\n      </span><span class="s1">implicitTags,</span><span class="s3">\n      </span><span class="s1">renderSignal: initialClientRenderController.signal,</span><span class="s3">\n      </span><span class="s1">controller: initialClientPrerenderController,</span><span class="s3">\n      </span><span class="s1">// For HTML Generation the only cache tracked activity</span><span class="s3">\n      </span><span class="s1">// is module loading, which has it's own cache signal</span><span class="s3">\n      </span><span class="s1">cacheSignal: null,</span><span class="s3">\n      </span><span class="s1">dynamicTracking: null,</span><span class="s3">\n      </span><span class="s1">allowEmptyStaticShell,</span><span class="s3">\n      </span><span class="s1">revalidate: INFINITE_CACHE,</span><span class="s3">\n      </span><span class="s1">expire: INFINITE_CACHE,</span><span class="s3">\n      </span><span class="s1">stale: INFINITE_CACHE,</span><span class="s3">\n      </span><span class="s1">tags: [...implicitTags.tags],</span><span class="s3">\n      </span><span class="s1">prerenderResumeDataCache,</span><span class="s3">\n      </span><span class="s1">renderResumeDataCache: null,</span><span class="s3">\n      </span><span class="s1">hmrRefreshHash: undefined,</span><span class="s3">\n      </span><span class="s1">captureOwnerStack: captureOwnerStackClient,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const prerender = (</span><span class="s3">\n      </span><span class="s1">require('react-dom/static') as typeof import('react-dom/static')</span><span class="s3">\n    </span><span class="s1">).prerender</span><span class="s3">\n    </span><span class="s1">const pendingInitialClientResult = workUnitAsyncStorage.run(</span><span class="s3">\n      </span><span class="s1">initialClientPrerenderStore,</span><span class="s3">\n      </span><span class="s1">prerender,</span><span class="s3">\n      </span><span class="s1">&lt;App</span><span class="s3">\n        </span><span class="s1">reactServerStream={initialServerResult.asUnclosingStream()}</span><span class="s3">\n        </span><span class="s1">preinitScripts={preinitScripts}</span><span class="s3">\n        </span><span class="s1">clientReferenceManifest={clientReferenceManifest}</span><span class="s3">\n        </span><span class="s1">ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}</span><span class="s3">\n        </span><span class="s1">nonce={nonce}</span><span class="s3">\n      </span><span class="s1">/&gt;,</span><span class="s3">\n      </span><span class="s1">{</span><span class="s3">\n        </span><span class="s1">signal: initialClientReactController.signal,</span><span class="s3">\n        </span><span class="s1">onError: (err) =&gt; {</span><span class="s3">\n          </span><span class="s1">const digest = getDigestForWellKnownError(err)</span><span class="s3">\n\n          </span><span class="s1">if (digest) {</span><span class="s3">\n            </span><span class="s1">return digest</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">if (isReactLargeShellError(err)) {</span><span class="s3">\n            </span><span class="s1">// TODO: Aggregate</span><span class="s3">\n            </span><span class="s1">console.error(err)</span><span class="s3">\n            </span><span class="s1">return undefined</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">if (initialClientReactController.signal.aborted) {</span><span class="s3">\n            </span><span class="s1">// These are expected errors that might error the prerender. we ignore them.</span><span class="s3">\n          </span><span class="s1">} else if (</span><span class="s3">\n            </span><span class="s1">process.env.NEXT_DEBUG_BUILD ||</span><span class="s3">\n            </span><span class="s1">process.env.__NEXT_VERBOSE_LOGGING</span><span class="s3">\n          </span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">// We don't normally log these errors because we are going to retry anyway but</span><span class="s3">\n            </span><span class="s1">// it can be useful for debugging Next.js itself to get visibility here when needed</span><span class="s3">\n            </span><span class="s1">printDebugThrownValueForProspectiveRender(err, workStore.route)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">// We don't need bootstrap scripts in this prerender</span><span class="s3">\n        </span><span class="s1">// bootstrapScripts: [bootstrapScript],</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">// The listener to abort our own render controller must be added after React</span><span class="s3">\n    </span><span class="s1">// has added its listener, to ensure that pending I/O is not</span><span class="s3">\n    </span><span class="s1">// aborted/rejected too early.</span><span class="s3">\n    </span><span class="s1">initialClientReactController.signal.addEventListener(</span><span class="s3">\n      </span><span class="s1">'abort',</span><span class="s3">\n      </span><span class="s1">() =&gt; {</span><span class="s3">\n        </span><span class="s1">initialClientRenderController.abort()</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">{ once: true }</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">pendingInitialClientResult.catch((err) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">initialClientReactController.signal.aborted ||</span><span class="s3">\n        </span><span class="s1">isPrerenderInterruptedError(err)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">// These are expected errors that might error the prerender. we ignore them.</span><span class="s3">\n      </span><span class="s1">} else if (</span><span class="s3">\n        </span><span class="s1">process.env.NEXT_DEBUG_BUILD ||</span><span class="s3">\n        </span><span class="s1">process.env.__NEXT_VERBOSE_LOGGING</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">// We don't normally log these errors because we are going to retry anyway but</span><span class="s3">\n        </span><span class="s1">// it can be useful for debugging Next.js itself to get visibility here when needed</span><span class="s3">\n        </span><span class="s1">printDebugThrownValueForProspectiveRender(err, workStore.route)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">// This is mostly needed for dynamic `import()`s in client components.</span><span class="s3">\n    </span><span class="s1">// Promises passed to client were already awaited above (assuming that they came from cached functions)</span><span class="s3">\n    </span><span class="s1">trackPendingModules(cacheSignal)</span><span class="s3">\n    </span><span class="s1">await cacheSignal.cacheReady()</span><span class="s3">\n    </span><span class="s1">initialClientReactController.abort()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const finalServerReactController = new AbortController()</span><span class="s3">\n  </span><span class="s1">const finalServerRenderController = new AbortController()</span><span class="s3">\n\n  </span><span class="s1">const finalServerPayloadPrerenderStore: PrerenderStore = {</span><span class="s3">\n    </span><span class="s1">type: 'prerender',</span><span class="s3">\n    </span><span class="s1">phase: 'render',</span><span class="s3">\n    </span><span class="s1">rootParams,</span><span class="s3">\n    </span><span class="s1">fallbackRouteParams,</span><span class="s3">\n    </span><span class="s1">implicitTags,</span><span class="s3">\n    </span><span class="s1">// While this render signal isn't going to be used to abort a React render while getting the RSC payload</span><span class="s3">\n    </span><span class="s1">// various request data APIs bind to this controller to reject after completion.</span><span class="s3">\n    </span><span class="s1">renderSignal: finalServerRenderController.signal,</span><span class="s3">\n    </span><span class="s1">// When we generate the RSC payload we might abort this controller due to sync IO</span><span class="s3">\n    </span><span class="s1">// but we don't actually care about sync IO in this phase so we use a throw away controller</span><span class="s3">\n    </span><span class="s1">// that isn't connected to anything</span><span class="s3">\n    </span><span class="s1">controller: new AbortController(),</span><span class="s3">\n    </span><span class="s1">// All caches we could read must already be filled so no tracking is necessary</span><span class="s3">\n    </span><span class="s1">cacheSignal: null,</span><span class="s3">\n    </span><span class="s1">dynamicTracking: null,</span><span class="s3">\n    </span><span class="s1">allowEmptyStaticShell,</span><span class="s3">\n    </span><span class="s1">revalidate: INFINITE_CACHE,</span><span class="s3">\n    </span><span class="s1">expire: INFINITE_CACHE,</span><span class="s3">\n    </span><span class="s1">stale: INFINITE_CACHE,</span><span class="s3">\n    </span><span class="s1">tags: [...implicitTags.tags],</span><span class="s3">\n    </span><span class="s1">prerenderResumeDataCache,</span><span class="s3">\n    </span><span class="s1">renderResumeDataCache: null,</span><span class="s3">\n    </span><span class="s1">hmrRefreshHash,</span><span class="s3">\n    </span><span class="s1">captureOwnerStack: captureOwnerStackServer,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const finalAttemptRSCPayload = await workUnitAsyncStorage.run(</span><span class="s3">\n    </span><span class="s1">finalServerPayloadPrerenderStore,</span><span class="s3">\n    </span><span class="s1">getRSCPayload,</span><span class="s3">\n    </span><span class="s1">tree,</span><span class="s3">\n    </span><span class="s1">ctx,</span><span class="s3">\n    </span><span class="s1">isNotFound</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const serverDynamicTracking = createDynamicTrackingState(</span><span class="s3">\n    </span><span class="s1">false // isDebugDynamicAccesses</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const finalServerPrerenderStore: PrerenderStore = {</span><span class="s3">\n    </span><span class="s1">type: 'prerender',</span><span class="s3">\n    </span><span class="s1">phase: 'render',</span><span class="s3">\n    </span><span class="s1">rootParams,</span><span class="s3">\n    </span><span class="s1">fallbackRouteParams,</span><span class="s3">\n    </span><span class="s1">implicitTags,</span><span class="s3">\n    </span><span class="s1">renderSignal: finalServerRenderController.signal,</span><span class="s3">\n    </span><span class="s1">controller: finalServerReactController,</span><span class="s3">\n    </span><span class="s1">// All caches we could read must already be filled so no tracking is necessary</span><span class="s3">\n    </span><span class="s1">cacheSignal: null,</span><span class="s3">\n    </span><span class="s1">dynamicTracking: serverDynamicTracking,</span><span class="s3">\n    </span><span class="s1">allowEmptyStaticShell,</span><span class="s3">\n    </span><span class="s1">revalidate: INFINITE_CACHE,</span><span class="s3">\n    </span><span class="s1">expire: INFINITE_CACHE,</span><span class="s3">\n    </span><span class="s1">stale: INFINITE_CACHE,</span><span class="s3">\n    </span><span class="s1">tags: [...implicitTags.tags],</span><span class="s3">\n    </span><span class="s1">prerenderResumeDataCache,</span><span class="s3">\n    </span><span class="s1">renderResumeDataCache: null,</span><span class="s3">\n    </span><span class="s1">hmrRefreshHash,</span><span class="s3">\n    </span><span class="s1">captureOwnerStack: captureOwnerStackServer,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const reactServerResult = await createReactServerPrerenderResult(</span><span class="s3">\n    </span><span class="s1">prerenderAndAbortInSequentialTasks(</span><span class="s3">\n      </span><span class="s1">async () =&gt; {</span><span class="s3">\n        </span><span class="s1">const pendingPrerenderResult = workUnitAsyncStorage.run(</span><span class="s3">\n          </span><span class="s1">// The store to scope</span><span class="s3">\n          </span><span class="s1">finalServerPrerenderStore,</span><span class="s3">\n          </span><span class="s1">// The function to run</span><span class="s3">\n          </span><span class="s1">ComponentMod.prerender,</span><span class="s3">\n          </span><span class="s1">// ... the arguments for the function to run</span><span class="s3">\n          </span><span class="s1">finalAttemptRSCPayload,</span><span class="s3">\n          </span><span class="s1">clientReferenceManifest.clientModules,</span><span class="s3">\n          </span><span class="s1">{</span><span class="s3">\n            </span><span class="s1">filterStackFrame,</span><span class="s3">\n            </span><span class="s1">onError: (err: unknown) =&gt; {</span><span class="s3">\n              </span><span class="s1">if (</span><span class="s3">\n                </span><span class="s1">finalServerReactController.signal.aborted &amp;&amp;</span><span class="s3">\n                </span><span class="s1">isPrerenderInterruptedError(err)</span><span class="s3">\n              </span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">return err.digest</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n\n              </span><span class="s1">if (isReactLargeShellError(err)) {</span><span class="s3">\n                </span><span class="s1">// TODO: Aggregate</span><span class="s3">\n                </span><span class="s1">console.error(err)</span><span class="s3">\n                </span><span class="s1">return undefined</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n\n              </span><span class="s1">return getDigestForWellKnownError(err)</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">signal: finalServerReactController.signal,</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">// The listener to abort our own render controller must be added after</span><span class="s3">\n        </span><span class="s1">// React has added its listener, to ensure that pending I/O is not</span><span class="s3">\n        </span><span class="s1">// aborted/rejected too early.</span><span class="s3">\n        </span><span class="s1">finalServerReactController.signal.addEventListener(</span><span class="s3">\n          </span><span class="s1">'abort',</span><span class="s3">\n          </span><span class="s1">() =&gt; {</span><span class="s3">\n            </span><span class="s1">finalServerRenderController.abort()</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">{ once: true }</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">return pendingPrerenderResult</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">() =&gt; {</span><span class="s3">\n        </span><span class="s1">finalServerReactController.abort()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const clientDynamicTracking = createDynamicTrackingState(</span><span class="s3">\n    </span><span class="s1">false //isDebugDynamicAccesses</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">const finalClientReactController = new AbortController()</span><span class="s3">\n  </span><span class="s1">const finalClientRenderController = new AbortController()</span><span class="s3">\n\n  </span><span class="s1">const finalClientPrerenderStore: PrerenderStore = {</span><span class="s3">\n    </span><span class="s1">type: 'prerender-client',</span><span class="s3">\n    </span><span class="s1">phase: 'render',</span><span class="s3">\n    </span><span class="s1">rootParams,</span><span class="s3">\n    </span><span class="s1">fallbackRouteParams,</span><span class="s3">\n    </span><span class="s1">implicitTags,</span><span class="s3">\n    </span><span class="s1">renderSignal: finalClientRenderController.signal,</span><span class="s3">\n    </span><span class="s1">controller: finalClientReactController,</span><span class="s3">\n    </span><span class="s1">// No APIs require a cacheSignal through the workUnitStore during the HTML prerender</span><span class="s3">\n    </span><span class="s1">cacheSignal: null,</span><span class="s3">\n    </span><span class="s1">dynamicTracking: clientDynamicTracking,</span><span class="s3">\n    </span><span class="s1">allowEmptyStaticShell,</span><span class="s3">\n    </span><span class="s1">revalidate: INFINITE_CACHE,</span><span class="s3">\n    </span><span class="s1">expire: INFINITE_CACHE,</span><span class="s3">\n    </span><span class="s1">stale: INFINITE_CACHE,</span><span class="s3">\n    </span><span class="s1">tags: [...implicitTags.tags],</span><span class="s3">\n    </span><span class="s1">prerenderResumeDataCache,</span><span class="s3">\n    </span><span class="s1">renderResumeDataCache: null,</span><span class="s3">\n    </span><span class="s1">hmrRefreshHash,</span><span class="s3">\n    </span><span class="s1">captureOwnerStack: captureOwnerStackClient,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let dynamicValidation = createDynamicValidationState()</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">const prerender = (</span><span class="s3">\n      </span><span class="s1">require('react-dom/static') as typeof import('react-dom/static')</span><span class="s3">\n    </span><span class="s1">).prerender</span><span class="s3">\n    </span><span class="s1">let { prelude: unprocessedPrelude } =</span><span class="s3">\n      </span><span class="s1">await prerenderAndAbortInSequentialTasks(</span><span class="s3">\n        </span><span class="s1">() =&gt; {</span><span class="s3">\n          </span><span class="s1">const pendingFinalClientResult = workUnitAsyncStorage.run(</span><span class="s3">\n            </span><span class="s1">finalClientPrerenderStore,</span><span class="s3">\n            </span><span class="s1">prerender,</span><span class="s3">\n            </span><span class="s1">&lt;App</span><span class="s3">\n              </span><span class="s1">reactServerStream={reactServerResult.asUnclosingStream()}</span><span class="s3">\n              </span><span class="s1">preinitScripts={preinitScripts}</span><span class="s3">\n              </span><span class="s1">clientReferenceManifest={clientReferenceManifest}</span><span class="s3">\n              </span><span class="s1">ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}</span><span class="s3">\n              </span><span class="s1">nonce={nonce}</span><span class="s3">\n            </span><span class="s1">/&gt;,</span><span class="s3">\n            </span><span class="s1">{</span><span class="s3">\n              </span><span class="s1">signal: finalClientReactController.signal,</span><span class="s3">\n              </span><span class="s1">onError: (err: unknown, errorInfo: ErrorInfo) =&gt; {</span><span class="s3">\n                </span><span class="s1">if (</span><span class="s3">\n                  </span><span class="s1">isPrerenderInterruptedError(err) ||</span><span class="s3">\n                  </span><span class="s1">finalClientReactController.signal.aborted</span><span class="s3">\n                </span><span class="s1">) {</span><span class="s3">\n                  </span><span class="s1">const componentStack = errorInfo.componentStack</span><span class="s3">\n                  </span><span class="s1">if (typeof componentStack === 'string') {</span><span class="s3">\n                    </span><span class="s1">trackAllowedDynamicAccess(</span><span class="s3">\n                      </span><span class="s1">workStore,</span><span class="s3">\n                      </span><span class="s1">componentStack,</span><span class="s3">\n                      </span><span class="s1">dynamicValidation,</span><span class="s3">\n                      </span><span class="s1">clientDynamicTracking</span><span class="s3">\n                    </span><span class="s1">)</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                  </span><span class="s1">return</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n\n                </span><span class="s1">if (isReactLargeShellError(err)) {</span><span class="s3">\n                  </span><span class="s1">// TODO: Aggregate</span><span class="s3">\n                  </span><span class="s1">console.error(err)</span><span class="s3">\n                  </span><span class="s1">return undefined</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n\n                </span><span class="s1">return getDigestForWellKnownError(err)</span><span class="s3">\n              </span><span class="s1">},</span><span class="s3">\n              </span><span class="s1">// We don't need bootstrap scripts in this prerender</span><span class="s3">\n              </span><span class="s1">// bootstrapScripts: [bootstrapScript],</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n\n          </span><span class="s1">// The listener to abort our own render controller must be added after</span><span class="s3">\n          </span><span class="s1">// React has added its listener, to ensure that pending I/O is not</span><span class="s3">\n          </span><span class="s1">// aborted/rejected too early.</span><span class="s3">\n          </span><span class="s1">finalClientReactController.signal.addEventListener(</span><span class="s3">\n            </span><span class="s1">'abort',</span><span class="s3">\n            </span><span class="s1">() =&gt; {</span><span class="s3">\n              </span><span class="s1">finalClientRenderController.abort()</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ once: true }</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n\n          </span><span class="s1">return pendingFinalClientResult</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">() =&gt; {</span><span class="s3">\n          </span><span class="s1">finalClientReactController.abort()</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">const { preludeIsEmpty } = await processPrelude(unprocessedPrelude)</span><span class="s3">\n    </span><span class="s1">resolveValidation(</span><span class="s3">\n      </span><span class="s1">&lt;LogSafely</span><span class="s3">\n        </span><span class="s1">fn={throwIfDisallowedDynamic.bind(</span><span class="s3">\n          </span><span class="s1">null,</span><span class="s3">\n          </span><span class="s1">workStore,</span><span class="s3">\n          </span><span class="s1">preludeIsEmpty ? PreludeState.Empty : PreludeState.Full,</span><span class="s3">\n          </span><span class="s1">dynamicValidation,</span><span class="s3">\n          </span><span class="s1">serverDynamicTracking</span><span class="s3">\n        </span><span class="s1">)}</span><span class="s3">\n      </span><span class="s1">/&gt;</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">} catch (thrownValue) {</span><span class="s3">\n    </span><span class="s1">// Even if the root errors we still want to report any cache components errors</span><span class="s3">\n    </span><span class="s1">// that were discovered before the root errored.</span><span class="s3">\n\n    </span><span class="s1">let loggingFunction = throwIfDisallowedDynamic.bind(</span><span class="s3">\n      </span><span class="s1">null,</span><span class="s3">\n      </span><span class="s1">workStore,</span><span class="s3">\n      </span><span class="s1">PreludeState.Errored,</span><span class="s3">\n      </span><span class="s1">dynamicValidation,</span><span class="s3">\n      </span><span class="s1">serverDynamicTracking</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">if (process.env.NEXT_DEBUG_BUILD || process.env.__NEXT_VERBOSE_LOGGING) {</span><span class="s3">\n      </span><span class="s1">// We don't normally log these errors because we are going to retry anyway but</span><span class="s3">\n      </span><span class="s1">// it can be useful for debugging Next.js itself to get visibility here when needed</span><span class="s3">\n      </span><span class="s1">const originalLoggingFunction = loggingFunction</span><span class="s3">\n      </span><span class="s1">loggingFunction = () =&gt; {</span><span class="s3">\n        </span><span class="s1">console.error(</span><span class="s3">\n          </span><span class="s1">'During dynamic validation the root of the page errored. The next logged error is the thrown value. It may be a duplicate of errors reported during the normal development mode render.'</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">console.error(thrownValue)</span><span class="s3">\n        </span><span class="s1">originalLoggingFunction()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">resolveValidation(&lt;LogSafely fn={loggingFunction} /&gt;)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">async function LogSafely({ fn }: { fn: () =&gt; unknown }) {</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">await fn()</span><span class="s3">\n  </span><span class="s1">} catch {}</span><span class="s3">\n  </span><span class="s1">return null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type PrerenderToStreamResult = {</span><span class="s3">\n  </span><span class="s1">stream: ReadableStream&lt;Uint8Array&gt;</span><span class="s3">\n  </span><span class="s1">digestErrorsMap: Map&lt;string, DigestedError&gt;</span><span class="s3">\n  </span><span class="s1">ssrErrors: Array&lt;unknown&gt;</span><span class="s3">\n  </span><span class="s1">dynamicAccess?: null | Array&lt;DynamicAccess&gt;</span><span class="s3">\n  </span><span class="s1">collectedRevalidate: number</span><span class="s3">\n  </span><span class="s1">collectedExpire: number</span><span class="s3">\n  </span><span class="s1">collectedStale: number</span><span class="s3">\n  </span><span class="s1">collectedTags: null | string[]</span><span class="s3">\n  </span><span class="s1">renderResumeDataCache?: RenderResumeDataCache</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Determines whether we should generate static flight data.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function shouldGenerateStaticFlightData(workStore: WorkStore): boolean {</span><span class="s3">\n  </span><span class="s1">const { isStaticGeneration } = workStore</span><span class="s3">\n  </span><span class="s1">if (!isStaticGeneration) return false</span><span class="s3">\n\n  </span><span class="s1">return true</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">async function prerenderToStream(</span><span class="s3">\n  </span><span class="s1">req: BaseNextRequest,</span><span class="s3">\n  </span><span class="s1">res: BaseNextResponse,</span><span class="s3">\n  </span><span class="s1">ctx: AppRenderContext,</span><span class="s3">\n  </span><span class="s1">metadata: AppPageRenderResultMetadata,</span><span class="s3">\n  </span><span class="s1">tree: LoaderTree,</span><span class="s3">\n  </span><span class="s1">fallbackRouteParams: FallbackRouteParams | null</span><span class="s3">\n</span><span class="s1">): Promise&lt;PrerenderToStreamResult&gt; {</span><span class="s3">\n  </span><span class="s1">// When prerendering formState is always null. We still include it</span><span class="s3">\n  </span><span class="s1">// because some shared APIs expect a formState value and this is slightly</span><span class="s3">\n  </span><span class="s1">// more explicit than making it an optional function argument</span><span class="s3">\n  </span><span class="s1">const formState = null</span><span class="s3">\n\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">assetPrefix,</span><span class="s3">\n    </span><span class="s1">getDynamicParamFromSegment,</span><span class="s3">\n    </span><span class="s1">implicitTags,</span><span class="s3">\n    </span><span class="s1">nonce,</span><span class="s3">\n    </span><span class="s1">pagePath,</span><span class="s3">\n    </span><span class="s1">renderOpts,</span><span class="s3">\n    </span><span class="s1">workStore,</span><span class="s3">\n  </span><span class="s1">} = ctx</span><span class="s3">\n\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">allowEmptyStaticShell = false,</span><span class="s3">\n    </span><span class="s1">basePath,</span><span class="s3">\n    </span><span class="s1">buildManifest,</span><span class="s3">\n    </span><span class="s1">clientReferenceManifest,</span><span class="s3">\n    </span><span class="s1">ComponentMod,</span><span class="s3">\n    </span><span class="s1">crossOrigin,</span><span class="s3">\n    </span><span class="s1">dev = false,</span><span class="s3">\n    </span><span class="s1">experimental,</span><span class="s3">\n    </span><span class="s1">isDebugDynamicAccesses,</span><span class="s3">\n    </span><span class="s1">nextExport = false,</span><span class="s3">\n    </span><span class="s1">onInstrumentationRequestError,</span><span class="s3">\n    </span><span class="s1">page,</span><span class="s3">\n    </span><span class="s1">reactMaxHeadersLength,</span><span class="s3">\n    </span><span class="s1">subresourceIntegrityManifest,</span><span class="s3">\n  </span><span class="s1">} = renderOpts</span><span class="s3">\n\n  </span><span class="s1">assertClientReferenceManifest(clientReferenceManifest)</span><span class="s3">\n\n  </span><span class="s1">const rootParams = getRootParams(tree, getDynamicParamFromSegment)</span><span class="s3">\n\n  </span><span class="s1">const { ServerInsertedHTMLProvider, renderServerInsertedHTML } =</span><span class="s3">\n    </span><span class="s1">createServerInsertedHTML()</span><span class="s3">\n  </span><span class="s1">const getServerInsertedMetadata = createServerInsertedMetadata(nonce)</span><span class="s3">\n\n  </span><span class="s1">const tracingMetadata = getTracedMetadata(</span><span class="s3">\n    </span><span class="s1">getTracer().getTracePropagationData(),</span><span class="s3">\n    </span><span class="s1">experimental.clientTraceMetadata</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const polyfills: JSX.IntrinsicElements['script'][] =</span><span class="s3">\n    </span><span class="s1">buildManifest.polyfillFiles</span><span class="s3">\n      </span><span class="s1">.filter(</span><span class="s3">\n        </span><span class="s1">(polyfill) =&gt;</span><span class="s3">\n          </span><span class="s1">polyfill.endsWith('.js') &amp;&amp; !polyfill.endsWith('.module.js')</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">.map((polyfill) =&gt; ({</span><span class="s3">\n        </span><span class="s1">src: `${assetPrefix}/_next/${polyfill}${getAssetQueryString(</span><span class="s3">\n          </span><span class="s1">ctx,</span><span class="s3">\n          </span><span class="s1">false</span><span class="s3">\n        </span><span class="s1">)}`,</span><span class="s3">\n        </span><span class="s1">integrity: subresourceIntegrityManifest?.[polyfill],</span><span class="s3">\n        </span><span class="s1">crossOrigin,</span><span class="s3">\n        </span><span class="s1">noModule: true,</span><span class="s3">\n        </span><span class="s1">nonce,</span><span class="s3">\n      </span><span class="s1">}))</span><span class="s3">\n\n  </span><span class="s1">const [preinitScripts, bootstrapScript] = getRequiredScripts(</span><span class="s3">\n    </span><span class="s1">buildManifest,</span><span class="s3">\n    </span><span class="s1">// Why is assetPrefix optional on renderOpts?</span><span class="s3">\n    </span><span class="s1">// @TODO make it default empty string on renderOpts and get rid of it from ctx</span><span class="s3">\n    </span><span class="s1">assetPrefix,</span><span class="s3">\n    </span><span class="s1">crossOrigin,</span><span class="s3">\n    </span><span class="s1">subresourceIntegrityManifest,</span><span class="s3">\n    </span><span class="s1">getAssetQueryString(ctx, true),</span><span class="s3">\n    </span><span class="s1">nonce,</span><span class="s3">\n    </span><span class="s1">page</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const reactServerErrorsByDigest: Map&lt;string, DigestedError&gt; = new Map()</span><span class="s3">\n  </span><span class="s1">// We don't report errors during prerendering through our instrumentation hooks</span><span class="s3">\n  </span><span class="s1">const silenceLogger = !!experimental.isRoutePPREnabled</span><span class="s3">\n  </span><span class="s1">function onHTMLRenderRSCError(err: DigestedError) {</span><span class="s3">\n    </span><span class="s1">return onInstrumentationRequestError?.(</span><span class="s3">\n      </span><span class="s1">err,</span><span class="s3">\n      </span><span class="s1">req,</span><span class="s3">\n      </span><span class="s1">createErrorContext(ctx, 'react-server-components')</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const serverComponentsErrorHandler = createHTMLReactServerErrorHandler(</span><span class="s3">\n    </span><span class="s1">dev,</span><span class="s3">\n    </span><span class="s1">nextExport,</span><span class="s3">\n    </span><span class="s1">reactServerErrorsByDigest,</span><span class="s3">\n    </span><span class="s1">silenceLogger,</span><span class="s3">\n    </span><span class="s1">onHTMLRenderRSCError</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">function onHTMLRenderSSRError(err: DigestedError) {</span><span class="s3">\n    </span><span class="s1">return onInstrumentationRequestError?.(</span><span class="s3">\n      </span><span class="s1">err,</span><span class="s3">\n      </span><span class="s1">req,</span><span class="s3">\n      </span><span class="s1">createErrorContext(ctx, 'server-rendering')</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const allCapturedErrors: Array&lt;unknown&gt; = []</span><span class="s3">\n  </span><span class="s1">const htmlRendererErrorHandler = createHTMLErrorHandler(</span><span class="s3">\n    </span><span class="s1">dev,</span><span class="s3">\n    </span><span class="s1">nextExport,</span><span class="s3">\n    </span><span class="s1">reactServerErrorsByDigest,</span><span class="s3">\n    </span><span class="s1">allCapturedErrors,</span><span class="s3">\n    </span><span class="s1">silenceLogger,</span><span class="s3">\n    </span><span class="s1">onHTMLRenderSSRError</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">let reactServerPrerenderResult: null | ReactServerPrerenderResult = null</span><span class="s3">\n  </span><span class="s1">const setMetadataHeader = (name: string) =&gt; {</span><span class="s3">\n    </span><span class="s1">metadata.headers ??= {}</span><span class="s3">\n    </span><span class="s1">metadata.headers[name] = res.getHeader(name)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const setHeader = (name: string, value: string | string[]) =&gt; {</span><span class="s3">\n    </span><span class="s1">res.setHeader(name, value)</span><span class="s3">\n    </span><span class="s1">setMetadataHeader(name)</span><span class="s3">\n    </span><span class="s1">return res</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const appendHeader = (name: string, value: string | string[]) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(value)) {</span><span class="s3">\n      </span><span class="s1">value.forEach((item) =&gt; {</span><span class="s3">\n        </span><span class="s1">res.appendHeader(name, item)</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">res.appendHeader(name, value)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">setMetadataHeader(name)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const selectStaleTime = createSelectStaleTime(experimental)</span><span class="s3">\n\n  </span><span class="s1">let prerenderStore: PrerenderStore | null = null</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">if (experimental.cacheComponents) {</span><span class="s3">\n      </span><span class="s1">/**</span><span class="s3">\n       </span><span class="s1">* cacheComponents with PPR</span><span class="s3">\n       </span><span class="s1">*</span><span class="s3">\n       </span><span class="s1">* The general approach is to render the RSC stream first allowing any cache reads to resolve.</span><span class="s3">\n       </span><span class="s1">* Once we have settled all cache reads we restart the render and abort after a single Task.</span><span class="s3">\n       </span><span class="s1">*</span><span class="s3">\n       </span><span class="s1">* Unlike with the non PPR case we can't synchronously abort the render when a dynamic API is used</span><span class="s3">\n       </span><span class="s1">* during the initial render because we need to ensure all caches can be filled as part of the initial Task</span><span class="s3">\n       </span><span class="s1">* and a synchronous abort might prevent us from filling all caches.</span><span class="s3">\n       </span><span class="s1">*</span><span class="s3">\n       </span><span class="s1">* Once the render is complete we allow the SSR render to finish and use a combination of the postponed state</span><span class="s3">\n       </span><span class="s1">* and the reactServerIsDynamic value to determine how to treat the resulting render</span><span class="s3">\n       </span><span class="s1">*/</span><span class="s3">\n\n      </span><span class="s1">// The prerender controller represents the lifetime of the prerender. It</span><span class="s3">\n      </span><span class="s1">// will be aborted when a task is complete or a synchronously aborting API</span><span class="s3">\n      </span><span class="s1">// is called. Notably, during prospective prerenders, this does not</span><span class="s3">\n      </span><span class="s1">// actually terminate the prerender itself, which will continue until all</span><span class="s3">\n      </span><span class="s1">// caches are filled.</span><span class="s3">\n      </span><span class="s1">const initialServerPrerenderController = new AbortController()</span><span class="s3">\n\n      </span><span class="s1">// This controller is used to abort the React prerender.</span><span class="s3">\n      </span><span class="s1">const initialServerReactController = new AbortController()</span><span class="s3">\n\n      </span><span class="s1">// This controller represents the lifetime of the React prerender. Its</span><span class="s3">\n      </span><span class="s1">// signal can be used for any I/O operation to abort the I/O and/or to</span><span class="s3">\n      </span><span class="s1">// reject, when prerendering aborts. This includes our own hanging</span><span class="s3">\n      </span><span class="s1">// promises for accessing request data, and for fetch calls. It might be</span><span class="s3">\n      </span><span class="s1">// replaced in the future by React.cacheSignal(). It's aborted after the</span><span class="s3">\n      </span><span class="s1">// React controller, so that no pending I/O can register abort listeners</span><span class="s3">\n      </span><span class="s1">// that are called before React's abort listener is called. This ensures</span><span class="s3">\n      </span><span class="s1">// that pending I/O is not rejected too early when aborting the prerender.</span><span class="s3">\n      </span><span class="s1">// Notably, during the prospective prerender, it is different from the</span><span class="s3">\n      </span><span class="s1">// prerender controller because we don't want to end the React prerender</span><span class="s3">\n      </span><span class="s1">// until all caches are filled.</span><span class="s3">\n      </span><span class="s1">const initialServerRenderController = new AbortController()</span><span class="s3">\n\n      </span><span class="s1">// The cacheSignal helps us track whether caches are still filling or we are ready</span><span class="s3">\n      </span><span class="s1">// to cut the render off.</span><span class="s3">\n      </span><span class="s1">const cacheSignal = new CacheSignal()</span><span class="s3">\n\n      </span><span class="s1">let resumeDataCache: RenderResumeDataCache | PrerenderResumeDataCache</span><span class="s3">\n      </span><span class="s1">let renderResumeDataCache: RenderResumeDataCache | null = null</span><span class="s3">\n      </span><span class="s1">let prerenderResumeDataCache: PrerenderResumeDataCache | null = null</span><span class="s3">\n\n      </span><span class="s1">if (renderOpts.renderResumeDataCache) {</span><span class="s3">\n        </span><span class="s1">// If a prefilled immutable render resume data cache is provided, e.g.</span><span class="s3">\n        </span><span class="s1">// when prerendering an optional fallback shell after having prerendered</span><span class="s3">\n        </span><span class="s1">// pages with defined params, we use this instead of a prerender resume</span><span class="s3">\n        </span><span class="s1">// data cache.</span><span class="s3">\n        </span><span class="s1">resumeDataCache = renderResumeDataCache =</span><span class="s3">\n          </span><span class="s1">renderOpts.renderResumeDataCache</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// Otherwise we create a new mutable prerender resume data cache.</span><span class="s3">\n        </span><span class="s1">resumeDataCache = prerenderResumeDataCache =</span><span class="s3">\n          </span><span class="s1">createPrerenderResumeDataCache()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const initialServerPayloadPrerenderStore: PrerenderStore = {</span><span class="s3">\n        </span><span class="s1">type: 'prerender',</span><span class="s3">\n        </span><span class="s1">phase: 'render',</span><span class="s3">\n        </span><span class="s1">rootParams,</span><span class="s3">\n        </span><span class="s1">fallbackRouteParams,</span><span class="s3">\n        </span><span class="s1">implicitTags,</span><span class="s3">\n        </span><span class="s1">// While this render signal isn't going to be used to abort a React render while getting the RSC payload</span><span class="s3">\n        </span><span class="s1">// various request data APIs bind to this controller to reject after completion.</span><span class="s3">\n        </span><span class="s1">renderSignal: initialServerRenderController.signal,</span><span class="s3">\n        </span><span class="s1">// When we generate the RSC payload we might abort this controller due to sync IO</span><span class="s3">\n        </span><span class="s1">// but we don't actually care about sync IO in this phase so we use a throw away controller</span><span class="s3">\n        </span><span class="s1">// that isn't connected to anything</span><span class="s3">\n        </span><span class="s1">controller: new AbortController(),</span><span class="s3">\n        </span><span class="s1">// During the initial prerender we need to track all cache reads to ensure</span><span class="s3">\n        </span><span class="s1">// we render long enough to fill every cache it is possible to visit during</span><span class="s3">\n        </span><span class="s1">// the final prerender.</span><span class="s3">\n        </span><span class="s1">cacheSignal,</span><span class="s3">\n        </span><span class="s1">dynamicTracking: null,</span><span class="s3">\n        </span><span class="s1">allowEmptyStaticShell,</span><span class="s3">\n        </span><span class="s1">revalidate: INFINITE_CACHE,</span><span class="s3">\n        </span><span class="s1">expire: INFINITE_CACHE,</span><span class="s3">\n        </span><span class="s1">stale: INFINITE_CACHE,</span><span class="s3">\n        </span><span class="s1">tags: [...implicitTags.tags],</span><span class="s3">\n        </span><span class="s1">prerenderResumeDataCache,</span><span class="s3">\n        </span><span class="s1">renderResumeDataCache,</span><span class="s3">\n        </span><span class="s1">hmrRefreshHash: undefined,</span><span class="s3">\n        </span><span class="s1">captureOwnerStack: undefined, // Not available in production.</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// We're not going to use the result of this render because the only time it could be used</span><span class="s3">\n      </span><span class="s1">// is if it completes in a microtask and that's likely very rare for any non-trivial app</span><span class="s3">\n      </span><span class="s1">const initialServerPayload = await workUnitAsyncStorage.run(</span><span class="s3">\n        </span><span class="s1">initialServerPayloadPrerenderStore,</span><span class="s3">\n        </span><span class="s1">getRSCPayload,</span><span class="s3">\n        </span><span class="s1">tree,</span><span class="s3">\n        </span><span class="s1">ctx,</span><span class="s3">\n        </span><span class="s1">res.statusCode === 404</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">const initialServerPrerenderStore: PrerenderStore = (prerenderStore = {</span><span class="s3">\n        </span><span class="s1">type: 'prerender',</span><span class="s3">\n        </span><span class="s1">phase: 'render',</span><span class="s3">\n        </span><span class="s1">rootParams,</span><span class="s3">\n        </span><span class="s1">fallbackRouteParams,</span><span class="s3">\n        </span><span class="s1">implicitTags,</span><span class="s3">\n        </span><span class="s1">renderSignal: initialServerRenderController.signal,</span><span class="s3">\n        </span><span class="s1">controller: initialServerPrerenderController,</span><span class="s3">\n        </span><span class="s1">// During the initial prerender we need to track all cache reads to ensure</span><span class="s3">\n        </span><span class="s1">// we render long enough to fill every cache it is possible to visit during</span><span class="s3">\n        </span><span class="s1">// the final prerender.</span><span class="s3">\n        </span><span class="s1">cacheSignal,</span><span class="s3">\n        </span><span class="s1">dynamicTracking: null,</span><span class="s3">\n        </span><span class="s1">allowEmptyStaticShell,</span><span class="s3">\n        </span><span class="s1">revalidate: INFINITE_CACHE,</span><span class="s3">\n        </span><span class="s1">expire: INFINITE_CACHE,</span><span class="s3">\n        </span><span class="s1">stale: INFINITE_CACHE,</span><span class="s3">\n        </span><span class="s1">tags: [...implicitTags.tags],</span><span class="s3">\n        </span><span class="s1">prerenderResumeDataCache,</span><span class="s3">\n        </span><span class="s1">renderResumeDataCache,</span><span class="s3">\n        </span><span class="s1">hmrRefreshHash: undefined,</span><span class="s3">\n        </span><span class="s1">captureOwnerStack: undefined, // Not available in production.</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n\n      </span><span class="s1">const pendingInitialServerResult = workUnitAsyncStorage.run(</span><span class="s3">\n        </span><span class="s1">initialServerPrerenderStore,</span><span class="s3">\n        </span><span class="s1">ComponentMod.prerender,</span><span class="s3">\n        </span><span class="s1">initialServerPayload,</span><span class="s3">\n        </span><span class="s1">clientReferenceManifest.clientModules,</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">filterStackFrame,</span><span class="s3">\n          </span><span class="s1">onError: (err) =&gt; {</span><span class="s3">\n            </span><span class="s1">const digest = getDigestForWellKnownError(err)</span><span class="s3">\n\n            </span><span class="s1">if (digest) {</span><span class="s3">\n              </span><span class="s1">return digest</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">if (isReactLargeShellError(err)) {</span><span class="s3">\n              </span><span class="s1">// TODO: Aggregate</span><span class="s3">\n              </span><span class="s1">console.error(err)</span><span class="s3">\n              </span><span class="s1">return undefined</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">if (initialServerPrerenderController.signal.aborted) {</span><span class="s3">\n              </span><span class="s1">// The render aborted before this error was handled which indicates</span><span class="s3">\n              </span><span class="s1">// the error is caused by unfinished components within the render</span><span class="s3">\n              </span><span class="s1">return</span><span class="s3">\n            </span><span class="s1">} else if (</span><span class="s3">\n              </span><span class="s1">process.env.NEXT_DEBUG_BUILD ||</span><span class="s3">\n              </span><span class="s1">process.env.__NEXT_VERBOSE_LOGGING</span><span class="s3">\n            </span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">printDebugThrownValueForProspectiveRender(err, workStore.route)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">// we don't care to track postpones during the prospective render because we need</span><span class="s3">\n          </span><span class="s1">// to always do a final render anyway</span><span class="s3">\n          </span><span class="s1">onPostpone: undefined,</span><span class="s3">\n          </span><span class="s1">// We don't want to stop rendering until the cacheSignal is complete so we pass</span><span class="s3">\n          </span><span class="s1">// a different signal to this render call than is used by dynamic APIs to signify</span><span class="s3">\n          </span><span class="s1">// transitioning out of the prerender environment</span><span class="s3">\n          </span><span class="s1">signal: initialServerReactController.signal,</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">// The listener to abort our own render controller must be added after</span><span class="s3">\n      </span><span class="s1">// React has added its listener, to ensure that pending I/O is not</span><span class="s3">\n      </span><span class="s1">// aborted/rejected too early.</span><span class="s3">\n      </span><span class="s1">initialServerReactController.signal.addEventListener(</span><span class="s3">\n        </span><span class="s1">'abort',</span><span class="s3">\n        </span><span class="s1">() =&gt; {</span><span class="s3">\n          </span><span class="s1">initialServerRenderController.abort()</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">{ once: true }</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">// Wait for all caches to be finished filling and for async imports to resolve</span><span class="s3">\n      </span><span class="s1">trackPendingModules(cacheSignal)</span><span class="s3">\n      </span><span class="s1">await cacheSignal.cacheReady()</span><span class="s3">\n\n      </span><span class="s1">initialServerReactController.abort()</span><span class="s3">\n\n      </span><span class="s1">// We don't need to continue the prerender process if we already</span><span class="s3">\n      </span><span class="s1">// detected invalid dynamic usage in the initial prerender phase.</span><span class="s3">\n      </span><span class="s1">if (workStore.invalidDynamicUsageError) {</span><span class="s3">\n        </span><span class="s1">logDisallowedDynamicError(workStore, workStore.invalidDynamicUsageError)</span><span class="s3">\n        </span><span class="s1">throw new StaticGenBailoutError()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">let initialServerResult</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">initialServerResult = await createReactServerPrerenderResult(</span><span class="s3">\n          </span><span class="s1">pendingInitialServerResult</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">} catch (err) {</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">initialServerReactController.signal.aborted ||</span><span class="s3">\n          </span><span class="s1">initialServerPrerenderController.signal.aborted</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">// These are expected errors that might error the prerender. we ignore them.</span><span class="s3">\n        </span><span class="s1">} else if (</span><span class="s3">\n          </span><span class="s1">process.env.NEXT_DEBUG_BUILD ||</span><span class="s3">\n          </span><span class="s1">process.env.__NEXT_VERBOSE_LOGGING</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">// We don't normally log these errors because we are going to retry anyway but</span><span class="s3">\n          </span><span class="s1">// it can be useful for debugging Next.js itself to get visibility here when needed</span><span class="s3">\n          </span><span class="s1">printDebugThrownValueForProspectiveRender(err, workStore.route)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (initialServerResult) {</span><span class="s3">\n        </span><span class="s1">const initialClientPrerenderController = new AbortController()</span><span class="s3">\n        </span><span class="s1">const initialClientReactController = new AbortController()</span><span class="s3">\n        </span><span class="s1">const initialClientRenderController = new AbortController()</span><span class="s3">\n\n        </span><span class="s1">const initialClientPrerenderStore: PrerenderStore = {</span><span class="s3">\n          </span><span class="s1">type: 'prerender-client',</span><span class="s3">\n          </span><span class="s1">phase: 'render',</span><span class="s3">\n          </span><span class="s1">rootParams,</span><span class="s3">\n          </span><span class="s1">fallbackRouteParams,</span><span class="s3">\n          </span><span class="s1">implicitTags,</span><span class="s3">\n          </span><span class="s1">renderSignal: initialClientRenderController.signal,</span><span class="s3">\n          </span><span class="s1">controller: initialClientPrerenderController,</span><span class="s3">\n          </span><span class="s1">// For HTML Generation the only cache tracked activity</span><span class="s3">\n          </span><span class="s1">// is module loading, which has it's own cache signal</span><span class="s3">\n          </span><span class="s1">cacheSignal: null,</span><span class="s3">\n          </span><span class="s1">dynamicTracking: null,</span><span class="s3">\n          </span><span class="s1">allowEmptyStaticShell,</span><span class="s3">\n          </span><span class="s1">revalidate: INFINITE_CACHE,</span><span class="s3">\n          </span><span class="s1">expire: INFINITE_CACHE,</span><span class="s3">\n          </span><span class="s1">stale: INFINITE_CACHE,</span><span class="s3">\n          </span><span class="s1">tags: [...implicitTags.tags],</span><span class="s3">\n          </span><span class="s1">prerenderResumeDataCache,</span><span class="s3">\n          </span><span class="s1">renderResumeDataCache,</span><span class="s3">\n          </span><span class="s1">hmrRefreshHash: undefined,</span><span class="s3">\n          </span><span class="s1">captureOwnerStack: undefined, // Not available in production.</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const prerender = (</span><span class="s3">\n          </span><span class="s1">require('react-dom/static') as typeof import('react-dom/static')</span><span class="s3">\n        </span><span class="s1">).prerender</span><span class="s3">\n        </span><span class="s1">const pendingInitialClientResult = workUnitAsyncStorage.run(</span><span class="s3">\n          </span><span class="s1">initialClientPrerenderStore,</span><span class="s3">\n          </span><span class="s1">prerender,</span><span class="s3">\n          </span><span class="s1">&lt;App</span><span class="s3">\n            </span><span class="s1">reactServerStream={initialServerResult.asUnclosingStream()}</span><span class="s3">\n            </span><span class="s1">preinitScripts={preinitScripts}</span><span class="s3">\n            </span><span class="s1">clientReferenceManifest={clientReferenceManifest}</span><span class="s3">\n            </span><span class="s1">ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}</span><span class="s3">\n            </span><span class="s1">nonce={nonce}</span><span class="s3">\n          </span><span class="s1">/&gt;,</span><span class="s3">\n          </span><span class="s1">{</span><span class="s3">\n            </span><span class="s1">signal: initialClientReactController.signal,</span><span class="s3">\n            </span><span class="s1">onError: (err) =&gt; {</span><span class="s3">\n              </span><span class="s1">const digest = getDigestForWellKnownError(err)</span><span class="s3">\n\n              </span><span class="s1">if (digest) {</span><span class="s3">\n                </span><span class="s1">return digest</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n\n              </span><span class="s1">if (isReactLargeShellError(err)) {</span><span class="s3">\n                </span><span class="s1">// TODO: Aggregate</span><span class="s3">\n                </span><span class="s1">console.error(err)</span><span class="s3">\n                </span><span class="s1">return undefined</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n\n              </span><span class="s1">if (initialClientReactController.signal.aborted) {</span><span class="s3">\n                </span><span class="s1">// These are expected errors that might error the prerender. we ignore them.</span><span class="s3">\n              </span><span class="s1">} else if (</span><span class="s3">\n                </span><span class="s1">process.env.NEXT_DEBUG_BUILD ||</span><span class="s3">\n                </span><span class="s1">process.env.__NEXT_VERBOSE_LOGGING</span><span class="s3">\n              </span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">// We don't normally log these errors because we are going to retry anyway but</span><span class="s3">\n                </span><span class="s1">// it can be useful for debugging Next.js itself to get visibility here when needed</span><span class="s3">\n                </span><span class="s1">printDebugThrownValueForProspectiveRender(err, workStore.route)</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">bootstrapScripts: [bootstrapScript],</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">// The listener to abort our own render controller must be added after</span><span class="s3">\n        </span><span class="s1">// React has added its listener, to ensure that pending I/O is not</span><span class="s3">\n        </span><span class="s1">// aborted/rejected too early.</span><span class="s3">\n        </span><span class="s1">initialClientReactController.signal.addEventListener(</span><span class="s3">\n          </span><span class="s1">'abort',</span><span class="s3">\n          </span><span class="s1">() =&gt; {</span><span class="s3">\n            </span><span class="s1">initialClientRenderController.abort()</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">{ once: true }</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">pendingInitialClientResult.catch((err) =&gt; {</span><span class="s3">\n          </span><span class="s1">if (</span><span class="s3">\n            </span><span class="s1">initialClientReactController.signal.aborted ||</span><span class="s3">\n            </span><span class="s1">isPrerenderInterruptedError(err)</span><span class="s3">\n          </span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">// These are expected errors that might error the prerender. we ignore them.</span><span class="s3">\n          </span><span class="s1">} else if (</span><span class="s3">\n            </span><span class="s1">process.env.NEXT_DEBUG_BUILD ||</span><span class="s3">\n            </span><span class="s1">process.env.__NEXT_VERBOSE_LOGGING</span><span class="s3">\n          </span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">// We don't normally log these errors because we are going to retry anyway but</span><span class="s3">\n            </span><span class="s1">// it can be useful for debugging Next.js itself to get visibility here when needed</span><span class="s3">\n            </span><span class="s1">printDebugThrownValueForProspectiveRender(err, workStore.route)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n\n        </span><span class="s1">// This is mostly needed for dynamic `import()`s in client components.</span><span class="s3">\n        </span><span class="s1">// Promises passed to client were already awaited above (assuming that they came from cached functions)</span><span class="s3">\n        </span><span class="s1">trackPendingModules(cacheSignal)</span><span class="s3">\n        </span><span class="s1">await cacheSignal.cacheReady()</span><span class="s3">\n        </span><span class="s1">initialClientReactController.abort()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const finalServerReactController = new AbortController()</span><span class="s3">\n      </span><span class="s1">const finalServerRenderController = new AbortController()</span><span class="s3">\n\n      </span><span class="s1">const finalServerPayloadPrerenderStore: PrerenderStore = {</span><span class="s3">\n        </span><span class="s1">type: 'prerender',</span><span class="s3">\n        </span><span class="s1">phase: 'render',</span><span class="s3">\n        </span><span class="s1">rootParams,</span><span class="s3">\n        </span><span class="s1">fallbackRouteParams,</span><span class="s3">\n        </span><span class="s1">implicitTags,</span><span class="s3">\n        </span><span class="s1">// While this render signal isn't going to be used to abort a React render while getting the RSC payload</span><span class="s3">\n        </span><span class="s1">// various request data APIs bind to this controller to reject after completion.</span><span class="s3">\n        </span><span class="s1">renderSignal: finalServerRenderController.signal,</span><span class="s3">\n        </span><span class="s1">// When we generate the RSC payload we might abort this controller due to sync IO</span><span class="s3">\n        </span><span class="s1">// but we don't actually care about sync IO in this phase so we use a throw away controller</span><span class="s3">\n        </span><span class="s1">// that isn't connected to anything</span><span class="s3">\n        </span><span class="s1">controller: new AbortController(),</span><span class="s3">\n        </span><span class="s1">// All caches we could read must already be filled so no tracking is necessary</span><span class="s3">\n        </span><span class="s1">cacheSignal: null,</span><span class="s3">\n        </span><span class="s1">dynamicTracking: null,</span><span class="s3">\n        </span><span class="s1">allowEmptyStaticShell,</span><span class="s3">\n        </span><span class="s1">revalidate: INFINITE_CACHE,</span><span class="s3">\n        </span><span class="s1">expire: INFINITE_CACHE,</span><span class="s3">\n        </span><span class="s1">stale: INFINITE_CACHE,</span><span class="s3">\n        </span><span class="s1">tags: [...implicitTags.tags],</span><span class="s3">\n        </span><span class="s1">prerenderResumeDataCache,</span><span class="s3">\n        </span><span class="s1">renderResumeDataCache,</span><span class="s3">\n        </span><span class="s1">hmrRefreshHash: undefined,</span><span class="s3">\n        </span><span class="s1">captureOwnerStack: undefined, // Not available in production.</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const finalAttemptRSCPayload = await workUnitAsyncStorage.run(</span><span class="s3">\n        </span><span class="s1">finalServerPayloadPrerenderStore,</span><span class="s3">\n        </span><span class="s1">getRSCPayload,</span><span class="s3">\n        </span><span class="s1">tree,</span><span class="s3">\n        </span><span class="s1">ctx,</span><span class="s3">\n        </span><span class="s1">res.statusCode === 404</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">const serverDynamicTracking = createDynamicTrackingState(</span><span class="s3">\n        </span><span class="s1">isDebugDynamicAccesses</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">let serverIsDynamic = false</span><span class="s3">\n\n      </span><span class="s1">const finalServerPrerenderStore: PrerenderStore = (prerenderStore = {</span><span class="s3">\n        </span><span class="s1">type: 'prerender',</span><span class="s3">\n        </span><span class="s1">phase: 'render',</span><span class="s3">\n        </span><span class="s1">rootParams,</span><span class="s3">\n        </span><span class="s1">fallbackRouteParams,</span><span class="s3">\n        </span><span class="s1">implicitTags,</span><span class="s3">\n        </span><span class="s1">renderSignal: finalServerRenderController.signal,</span><span class="s3">\n        </span><span class="s1">controller: finalServerReactController,</span><span class="s3">\n        </span><span class="s1">// All caches we could read must already be filled so no tracking is necessary</span><span class="s3">\n        </span><span class="s1">cacheSignal: null,</span><span class="s3">\n        </span><span class="s1">dynamicTracking: serverDynamicTracking,</span><span class="s3">\n        </span><span class="s1">allowEmptyStaticShell,</span><span class="s3">\n        </span><span class="s1">revalidate: INFINITE_CACHE,</span><span class="s3">\n        </span><span class="s1">expire: INFINITE_CACHE,</span><span class="s3">\n        </span><span class="s1">stale: INFINITE_CACHE,</span><span class="s3">\n        </span><span class="s1">tags: [...implicitTags.tags],</span><span class="s3">\n        </span><span class="s1">prerenderResumeDataCache,</span><span class="s3">\n        </span><span class="s1">renderResumeDataCache,</span><span class="s3">\n        </span><span class="s1">hmrRefreshHash: undefined,</span><span class="s3">\n        </span><span class="s1">captureOwnerStack: undefined, // Not available in production.</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n\n      </span><span class="s1">let prerenderIsPending = true</span><span class="s3">\n      </span><span class="s1">const reactServerResult = (reactServerPrerenderResult =</span><span class="s3">\n        </span><span class="s1">await createReactServerPrerenderResult(</span><span class="s3">\n          </span><span class="s1">prerenderAndAbortInSequentialTasks(</span><span class="s3">\n            </span><span class="s1">async () =&gt; {</span><span class="s3">\n              </span><span class="s1">const pendingPrerenderResult = workUnitAsyncStorage.run(</span><span class="s3">\n                </span><span class="s1">// The store to scope</span><span class="s3">\n                </span><span class="s1">finalServerPrerenderStore,</span><span class="s3">\n                </span><span class="s1">// The function to run</span><span class="s3">\n                </span><span class="s1">ComponentMod.prerender,</span><span class="s3">\n                </span><span class="s1">// ... the arguments for the function to run</span><span class="s3">\n                </span><span class="s1">finalAttemptRSCPayload,</span><span class="s3">\n                </span><span class="s1">clientReferenceManifest.clientModules,</span><span class="s3">\n                </span><span class="s1">{</span><span class="s3">\n                  </span><span class="s1">filterStackFrame,</span><span class="s3">\n                  </span><span class="s1">onError: (err: unknown) =&gt; {</span><span class="s3">\n                    </span><span class="s1">return serverComponentsErrorHandler(err)</span><span class="s3">\n                  </span><span class="s1">},</span><span class="s3">\n                  </span><span class="s1">signal: finalServerReactController.signal,</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n\n              </span><span class="s1">// The listener to abort our own render controller must be added</span><span class="s3">\n              </span><span class="s1">// after React has added its listener, to ensure that pending I/O</span><span class="s3">\n              </span><span class="s1">// is not aborted/rejected too early.</span><span class="s3">\n              </span><span class="s1">finalServerReactController.signal.addEventListener(</span><span class="s3">\n                </span><span class="s1">'abort',</span><span class="s3">\n                </span><span class="s1">() =&gt; {</span><span class="s3">\n                  </span><span class="s1">finalServerRenderController.abort()</span><span class="s3">\n                </span><span class="s1">},</span><span class="s3">\n                </span><span class="s1">{ once: true }</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n\n              </span><span class="s1">const prerenderResult = await pendingPrerenderResult</span><span class="s3">\n              </span><span class="s1">prerenderIsPending = false</span><span class="s3">\n\n              </span><span class="s1">return prerenderResult</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">() =&gt; {</span><span class="s3">\n              </span><span class="s1">if (finalServerReactController.signal.aborted) {</span><span class="s3">\n                </span><span class="s1">// If the server controller is already aborted we must have called something</span><span class="s3">\n                </span><span class="s1">// that required aborting the prerender synchronously such as with new Date()</span><span class="s3">\n                </span><span class="s1">serverIsDynamic = true</span><span class="s3">\n                </span><span class="s1">return</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n\n              </span><span class="s1">if (prerenderIsPending) {</span><span class="s3">\n                </span><span class="s1">// If prerenderIsPending then we have blocked for longer than a Task and we assume</span><span class="s3">\n                </span><span class="s1">// there is something unfinished.</span><span class="s3">\n                </span><span class="s1">serverIsDynamic = true</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n\n              </span><span class="s1">finalServerReactController.abort()</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">))</span><span class="s3">\n\n      </span><span class="s1">const clientDynamicTracking = createDynamicTrackingState(</span><span class="s3">\n        </span><span class="s1">isDebugDynamicAccesses</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">const finalClientReactController = new AbortController()</span><span class="s3">\n      </span><span class="s1">const finalClientRenderController = new AbortController()</span><span class="s3">\n\n      </span><span class="s1">const finalClientPrerenderStore: PrerenderStore = {</span><span class="s3">\n        </span><span class="s1">type: 'prerender-client',</span><span class="s3">\n        </span><span class="s1">phase: 'render',</span><span class="s3">\n        </span><span class="s1">rootParams,</span><span class="s3">\n        </span><span class="s1">fallbackRouteParams,</span><span class="s3">\n        </span><span class="s1">implicitTags,</span><span class="s3">\n        </span><span class="s1">renderSignal: finalClientRenderController.signal,</span><span class="s3">\n        </span><span class="s1">controller: finalClientReactController,</span><span class="s3">\n        </span><span class="s1">// No APIs require a cacheSignal through the workUnitStore during the HTML prerender</span><span class="s3">\n        </span><span class="s1">cacheSignal: null,</span><span class="s3">\n        </span><span class="s1">dynamicTracking: clientDynamicTracking,</span><span class="s3">\n        </span><span class="s1">allowEmptyStaticShell,</span><span class="s3">\n        </span><span class="s1">revalidate: INFINITE_CACHE,</span><span class="s3">\n        </span><span class="s1">expire: INFINITE_CACHE,</span><span class="s3">\n        </span><span class="s1">stale: INFINITE_CACHE,</span><span class="s3">\n        </span><span class="s1">tags: [...implicitTags.tags],</span><span class="s3">\n        </span><span class="s1">prerenderResumeDataCache,</span><span class="s3">\n        </span><span class="s1">renderResumeDataCache,</span><span class="s3">\n        </span><span class="s1">hmrRefreshHash: undefined,</span><span class="s3">\n        </span><span class="s1">captureOwnerStack: undefined, // Not available in production.</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">let dynamicValidation = createDynamicValidationState()</span><span class="s3">\n\n      </span><span class="s1">const prerender = (</span><span class="s3">\n        </span><span class="s1">require('react-dom/static') as typeof import('react-dom/static')</span><span class="s3">\n      </span><span class="s1">).prerender</span><span class="s3">\n      </span><span class="s1">let { prelude: unprocessedPrelude, postponed } =</span><span class="s3">\n        </span><span class="s1">await prerenderAndAbortInSequentialTasks(</span><span class="s3">\n          </span><span class="s1">() =&gt; {</span><span class="s3">\n            </span><span class="s1">const pendingFinalClientResult = workUnitAsyncStorage.run(</span><span class="s3">\n              </span><span class="s1">finalClientPrerenderStore,</span><span class="s3">\n              </span><span class="s1">prerender,</span><span class="s3">\n              </span><span class="s1">&lt;App</span><span class="s3">\n                </span><span class="s1">reactServerStream={reactServerResult.asUnclosingStream()}</span><span class="s3">\n                </span><span class="s1">preinitScripts={preinitScripts}</span><span class="s3">\n                </span><span class="s1">clientReferenceManifest={clientReferenceManifest}</span><span class="s3">\n                </span><span class="s1">ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}</span><span class="s3">\n                </span><span class="s1">nonce={nonce}</span><span class="s3">\n              </span><span class="s1">/&gt;,</span><span class="s3">\n              </span><span class="s1">{</span><span class="s3">\n                </span><span class="s1">signal: finalClientReactController.signal,</span><span class="s3">\n                </span><span class="s1">onError: (err: unknown, errorInfo: ErrorInfo) =&gt; {</span><span class="s3">\n                  </span><span class="s1">if (</span><span class="s3">\n                    </span><span class="s1">isPrerenderInterruptedError(err) ||</span><span class="s3">\n                    </span><span class="s1">finalClientReactController.signal.aborted</span><span class="s3">\n                  </span><span class="s1">) {</span><span class="s3">\n                    </span><span class="s1">const componentStack: string | undefined = (</span><span class="s3">\n                      </span><span class="s1">errorInfo as any</span><span class="s3">\n                    </span><span class="s1">).componentStack</span><span class="s3">\n                    </span><span class="s1">if (typeof componentStack === 'string') {</span><span class="s3">\n                      </span><span class="s1">trackAllowedDynamicAccess(</span><span class="s3">\n                        </span><span class="s1">workStore,</span><span class="s3">\n                        </span><span class="s1">componentStack,</span><span class="s3">\n                        </span><span class="s1">dynamicValidation,</span><span class="s3">\n                        </span><span class="s1">clientDynamicTracking</span><span class="s3">\n                      </span><span class="s1">)</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">return</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n\n                  </span><span class="s1">return htmlRendererErrorHandler(err, errorInfo)</span><span class="s3">\n                </span><span class="s1">},</span><span class="s3">\n                </span><span class="s1">onHeaders: (headers: Headers) =&gt; {</span><span class="s3">\n                  </span><span class="s1">headers.forEach((value, key) =&gt; {</span><span class="s3">\n                    </span><span class="s1">appendHeader(key, value)</span><span class="s3">\n                  </span><span class="s1">})</span><span class="s3">\n                </span><span class="s1">},</span><span class="s3">\n                </span><span class="s1">maxHeadersLength: reactMaxHeadersLength,</span><span class="s3">\n                </span><span class="s1">bootstrapScripts: [bootstrapScript],</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n\n            </span><span class="s1">// The listener to abort our own render controller must be added</span><span class="s3">\n            </span><span class="s1">// after React has added its listener, to ensure that pending I/O is</span><span class="s3">\n            </span><span class="s1">// not aborted/rejected too early.</span><span class="s3">\n            </span><span class="s1">finalClientReactController.signal.addEventListener(</span><span class="s3">\n              </span><span class="s1">'abort',</span><span class="s3">\n              </span><span class="s1">() =&gt; {</span><span class="s3">\n                </span><span class="s1">finalClientRenderController.abort()</span><span class="s3">\n              </span><span class="s1">},</span><span class="s3">\n              </span><span class="s1">{ once: true }</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n\n            </span><span class="s1">return pendingFinalClientResult</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">() =&gt; {</span><span class="s3">\n            </span><span class="s1">finalClientReactController.abort()</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">const { prelude, preludeIsEmpty } =</span><span class="s3">\n        </span><span class="s1">await processPrelude(unprocessedPrelude)</span><span class="s3">\n\n      </span><span class="s1">// If we've disabled throwing on empty static shell, then we don't need to</span><span class="s3">\n      </span><span class="s1">// track any dynamic access that occurs above the suspense boundary because</span><span class="s3">\n      </span><span class="s1">// we'll do so in the route shell.</span><span class="s3">\n      </span><span class="s1">if (!allowEmptyStaticShell) {</span><span class="s3">\n        </span><span class="s1">throwIfDisallowedDynamic(</span><span class="s3">\n          </span><span class="s1">workStore,</span><span class="s3">\n          </span><span class="s1">preludeIsEmpty ? PreludeState.Empty : PreludeState.Full,</span><span class="s3">\n          </span><span class="s1">dynamicValidation,</span><span class="s3">\n          </span><span class="s1">serverDynamicTracking</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const getServerInsertedHTML = makeGetServerInsertedHTML({</span><span class="s3">\n        </span><span class="s1">polyfills,</span><span class="s3">\n        </span><span class="s1">renderServerInsertedHTML,</span><span class="s3">\n        </span><span class="s1">serverCapturedErrors: allCapturedErrors,</span><span class="s3">\n        </span><span class="s1">basePath,</span><span class="s3">\n        </span><span class="s1">tracingMetadata: tracingMetadata,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n\n      </span><span class="s1">const flightData = await streamToBuffer(reactServerResult.asStream())</span><span class="s3">\n      </span><span class="s1">metadata.flightData = flightData</span><span class="s3">\n      </span><span class="s1">metadata.segmentData = await collectSegmentData(</span><span class="s3">\n        </span><span class="s1">flightData,</span><span class="s3">\n        </span><span class="s1">finalServerPrerenderStore,</span><span class="s3">\n        </span><span class="s1">ComponentMod,</span><span class="s3">\n        </span><span class="s1">renderOpts</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">// If there are fallback route params, the RSC data is inherently dynamic</span><span class="s3">\n      </span><span class="s1">// today because it's encoded into the flight router state. Until we can</span><span class="s3">\n      </span><span class="s1">// move the fallback route params out of the flight router state, we need</span><span class="s3">\n      </span><span class="s1">// to always perform a dynamic resume after the static prerender.</span><span class="s3">\n      </span><span class="s1">const hasFallbackRouteParams =</span><span class="s3">\n        </span><span class="s1">fallbackRouteParams &amp;&amp; fallbackRouteParams.size &gt; 0</span><span class="s3">\n\n      </span><span class="s1">if (serverIsDynamic || hasFallbackRouteParams) {</span><span class="s3">\n        </span><span class="s1">// Dynamic case</span><span class="s3">\n        </span><span class="s1">// We will always need to perform a </span><span class="s3">\&quot;</span><span class="s1">resume</span><span class="s3">\&quot; </span><span class="s1">render of some kind when this route is accessed</span><span class="s3">\n        </span><span class="s1">// because the RSC data itself is dynamic. We determine if there are any HTML holes or not</span><span class="s3">\n        </span><span class="s1">// but generally this is a </span><span class="s3">\&quot;</span><span class="s1">partial</span><span class="s3">\&quot; </span><span class="s1">prerender in that there will be a per-request compute</span><span class="s3">\n        </span><span class="s1">// concatenated to the static shell.</span><span class="s3">\n        </span><span class="s1">if (postponed != null) {</span><span class="s3">\n          </span><span class="s1">// Dynamic HTML case</span><span class="s3">\n          </span><span class="s1">metadata.postponed = await getDynamicHTMLPostponedState(</span><span class="s3">\n            </span><span class="s1">postponed,</span><span class="s3">\n            </span><span class="s1">preludeIsEmpty</span><span class="s3">\n              </span><span class="s1">? DynamicHTMLPreludeState.Empty</span><span class="s3">\n              </span><span class="s1">: DynamicHTMLPreludeState.Full,</span><span class="s3">\n            </span><span class="s1">fallbackRouteParams,</span><span class="s3">\n            </span><span class="s1">resumeDataCache</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// Dynamic Data case</span><span class="s3">\n          </span><span class="s1">metadata.postponed =</span><span class="s3">\n            </span><span class="s1">await getDynamicDataPostponedState(resumeDataCache)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">reactServerResult.consume()</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">digestErrorsMap: reactServerErrorsByDigest,</span><span class="s3">\n          </span><span class="s1">ssrErrors: allCapturedErrors,</span><span class="s3">\n          </span><span class="s1">stream: await continueDynamicPrerender(prelude, {</span><span class="s3">\n            </span><span class="s1">getServerInsertedHTML,</span><span class="s3">\n            </span><span class="s1">getServerInsertedMetadata,</span><span class="s3">\n          </span><span class="s1">}),</span><span class="s3">\n          </span><span class="s1">dynamicAccess: consumeDynamicAccess(</span><span class="s3">\n            </span><span class="s1">serverDynamicTracking,</span><span class="s3">\n            </span><span class="s1">clientDynamicTracking</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">// TODO: Should this include the SSR pass?</span><span class="s3">\n          </span><span class="s1">collectedRevalidate: finalServerPrerenderStore.revalidate,</span><span class="s3">\n          </span><span class="s1">collectedExpire: finalServerPrerenderStore.expire,</span><span class="s3">\n          </span><span class="s1">collectedStale: selectStaleTime(finalServerPrerenderStore.stale),</span><span class="s3">\n          </span><span class="s1">collectedTags: finalServerPrerenderStore.tags,</span><span class="s3">\n          </span><span class="s1">renderResumeDataCache: createRenderResumeDataCache(resumeDataCache),</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// Static case</span><span class="s3">\n        </span><span class="s1">// We will not perform resumption per request. The result can be served statically to the requestor</span><span class="s3">\n        </span><span class="s1">// and if there was anything dynamic it will only be rendered in the browser.</span><span class="s3">\n        </span><span class="s1">if (workStore.forceDynamic) {</span><span class="s3">\n          </span><span class="s1">throw new StaticGenBailoutError(</span><span class="s3">\n            </span><span class="s1">'Invariant: a Page with `dynamic = </span><span class="s3">\&quot;</span><span class="s1">force-dynamic</span><span class="s3">\&quot;</span><span class="s1">` did not trigger the dynamic pathway. This is a bug in Next.js'</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">let htmlStream = prelude</span><span class="s3">\n        </span><span class="s1">if (postponed != null) {</span><span class="s3">\n          </span><span class="s1">// We postponed but nothing dynamic was used. We resume the render now and immediately abort it</span><span class="s3">\n          </span><span class="s1">// so we can set all the postponed boundaries to client render mode before we store the HTML response</span><span class="s3">\n          </span><span class="s1">const resume = (</span><span class="s3">\n            </span><span class="s1">require('react-dom/server') as typeof import('react-dom/server')</span><span class="s3">\n          </span><span class="s1">).resume</span><span class="s3">\n\n          </span><span class="s1">// We don't actually want to render anything so we just pass a stream</span><span class="s3">\n          </span><span class="s1">// that never resolves. The resume call is going to abort immediately anyway</span><span class="s3">\n          </span><span class="s1">const foreverStream = new ReadableStream&lt;Uint8Array&gt;()</span><span class="s3">\n\n          </span><span class="s1">const resumeStream = await resume(</span><span class="s3">\n            </span><span class="s1">&lt;App</span><span class="s3">\n              </span><span class="s1">reactServerStream={foreverStream}</span><span class="s3">\n              </span><span class="s1">preinitScripts={() =&gt; {}}</span><span class="s3">\n              </span><span class="s1">clientReferenceManifest={clientReferenceManifest}</span><span class="s3">\n              </span><span class="s1">ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}</span><span class="s3">\n              </span><span class="s1">nonce={nonce}</span><span class="s3">\n            </span><span class="s1">/&gt;,</span><span class="s3">\n            </span><span class="s1">JSON.parse(JSON.stringify(postponed)),</span><span class="s3">\n            </span><span class="s1">{</span><span class="s3">\n              </span><span class="s1">signal: createRenderInBrowserAbortSignal(),</span><span class="s3">\n              </span><span class="s1">onError: htmlRendererErrorHandler,</span><span class="s3">\n              </span><span class="s1">nonce,</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n\n          </span><span class="s1">// First we write everything from the prerender, then we write everything from the aborted resume render</span><span class="s3">\n          </span><span class="s1">htmlStream = chainStreams(prelude, resumeStream)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">digestErrorsMap: reactServerErrorsByDigest,</span><span class="s3">\n          </span><span class="s1">ssrErrors: allCapturedErrors,</span><span class="s3">\n          </span><span class="s1">stream: await continueStaticPrerender(htmlStream, {</span><span class="s3">\n            </span><span class="s1">inlinedDataStream: createInlinedDataReadableStream(</span><span class="s3">\n              </span><span class="s1">reactServerResult.consumeAsStream(),</span><span class="s3">\n              </span><span class="s1">nonce,</span><span class="s3">\n              </span><span class="s1">formState</span><span class="s3">\n            </span><span class="s1">),</span><span class="s3">\n            </span><span class="s1">getServerInsertedHTML,</span><span class="s3">\n            </span><span class="s1">getServerInsertedMetadata,</span><span class="s3">\n            </span><span class="s1">isBuildTimePrerendering:</span><span class="s3">\n              </span><span class="s1">ctx.workStore.isBuildTimePrerendering === true,</span><span class="s3">\n            </span><span class="s1">buildId: ctx.workStore.buildId,</span><span class="s3">\n          </span><span class="s1">}),</span><span class="s3">\n          </span><span class="s1">dynamicAccess: consumeDynamicAccess(</span><span class="s3">\n            </span><span class="s1">serverDynamicTracking,</span><span class="s3">\n            </span><span class="s1">clientDynamicTracking</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">// TODO: Should this include the SSR pass?</span><span class="s3">\n          </span><span class="s1">collectedRevalidate: finalServerPrerenderStore.revalidate,</span><span class="s3">\n          </span><span class="s1">collectedExpire: finalServerPrerenderStore.expire,</span><span class="s3">\n          </span><span class="s1">collectedStale: selectStaleTime(finalServerPrerenderStore.stale),</span><span class="s3">\n          </span><span class="s1">collectedTags: finalServerPrerenderStore.tags,</span><span class="s3">\n          </span><span class="s1">renderResumeDataCache: createRenderResumeDataCache(resumeDataCache),</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (experimental.isRoutePPREnabled) {</span><span class="s3">\n      </span><span class="s1">// We're statically generating with PPR and need to do dynamic tracking</span><span class="s3">\n      </span><span class="s1">let dynamicTracking = createDynamicTrackingState(isDebugDynamicAccesses)</span><span class="s3">\n\n      </span><span class="s1">const prerenderResumeDataCache = createPrerenderResumeDataCache()</span><span class="s3">\n      </span><span class="s1">const reactServerPrerenderStore: PrerenderStore = (prerenderStore = {</span><span class="s3">\n        </span><span class="s1">type: 'prerender-ppr',</span><span class="s3">\n        </span><span class="s1">phase: 'render',</span><span class="s3">\n        </span><span class="s1">rootParams,</span><span class="s3">\n        </span><span class="s1">fallbackRouteParams,</span><span class="s3">\n        </span><span class="s1">implicitTags,</span><span class="s3">\n        </span><span class="s1">dynamicTracking,</span><span class="s3">\n        </span><span class="s1">revalidate: INFINITE_CACHE,</span><span class="s3">\n        </span><span class="s1">expire: INFINITE_CACHE,</span><span class="s3">\n        </span><span class="s1">stale: INFINITE_CACHE,</span><span class="s3">\n        </span><span class="s1">tags: [...implicitTags.tags],</span><span class="s3">\n        </span><span class="s1">prerenderResumeDataCache,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">const RSCPayload = await workUnitAsyncStorage.run(</span><span class="s3">\n        </span><span class="s1">reactServerPrerenderStore,</span><span class="s3">\n        </span><span class="s1">getRSCPayload,</span><span class="s3">\n        </span><span class="s1">tree,</span><span class="s3">\n        </span><span class="s1">ctx,</span><span class="s3">\n        </span><span class="s1">res.statusCode === 404</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">const reactServerResult = (reactServerPrerenderResult =</span><span class="s3">\n        </span><span class="s1">await createReactServerPrerenderResultFromRender(</span><span class="s3">\n          </span><span class="s1">workUnitAsyncStorage.run(</span><span class="s3">\n            </span><span class="s1">reactServerPrerenderStore,</span><span class="s3">\n            </span><span class="s1">ComponentMod.renderToReadableStream,</span><span class="s3">\n            </span><span class="s1">// ... the arguments for the function to run</span><span class="s3">\n            </span><span class="s1">RSCPayload,</span><span class="s3">\n            </span><span class="s1">clientReferenceManifest.clientModules,</span><span class="s3">\n            </span><span class="s1">{</span><span class="s3">\n              </span><span class="s1">filterStackFrame,</span><span class="s3">\n              </span><span class="s1">onError: serverComponentsErrorHandler,</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">))</span><span class="s3">\n\n      </span><span class="s1">const ssrPrerenderStore: PrerenderStore = {</span><span class="s3">\n        </span><span class="s1">type: 'prerender-ppr',</span><span class="s3">\n        </span><span class="s1">phase: 'render',</span><span class="s3">\n        </span><span class="s1">rootParams,</span><span class="s3">\n        </span><span class="s1">fallbackRouteParams,</span><span class="s3">\n        </span><span class="s1">implicitTags,</span><span class="s3">\n        </span><span class="s1">dynamicTracking,</span><span class="s3">\n        </span><span class="s1">revalidate: INFINITE_CACHE,</span><span class="s3">\n        </span><span class="s1">expire: INFINITE_CACHE,</span><span class="s3">\n        </span><span class="s1">stale: INFINITE_CACHE,</span><span class="s3">\n        </span><span class="s1">tags: [...implicitTags.tags],</span><span class="s3">\n        </span><span class="s1">prerenderResumeDataCache,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const prerender = (</span><span class="s3">\n        </span><span class="s1">require('react-dom/static') as typeof import('react-dom/static')</span><span class="s3">\n      </span><span class="s1">).prerender</span><span class="s3">\n      </span><span class="s1">const { prelude: unprocessedPrelude, postponed } =</span><span class="s3">\n        </span><span class="s1">await workUnitAsyncStorage.run(</span><span class="s3">\n          </span><span class="s1">ssrPrerenderStore,</span><span class="s3">\n          </span><span class="s1">prerender,</span><span class="s3">\n          </span><span class="s1">&lt;App</span><span class="s3">\n            </span><span class="s1">reactServerStream={reactServerResult.asUnclosingStream()}</span><span class="s3">\n            </span><span class="s1">preinitScripts={preinitScripts}</span><span class="s3">\n            </span><span class="s1">clientReferenceManifest={clientReferenceManifest}</span><span class="s3">\n            </span><span class="s1">ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}</span><span class="s3">\n            </span><span class="s1">nonce={nonce}</span><span class="s3">\n          </span><span class="s1">/&gt;,</span><span class="s3">\n          </span><span class="s1">{</span><span class="s3">\n            </span><span class="s1">onError: htmlRendererErrorHandler,</span><span class="s3">\n            </span><span class="s1">onHeaders: (headers: Headers) =&gt; {</span><span class="s3">\n              </span><span class="s1">headers.forEach((value, key) =&gt; {</span><span class="s3">\n                </span><span class="s1">appendHeader(key, value)</span><span class="s3">\n              </span><span class="s1">})</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">maxHeadersLength: reactMaxHeadersLength,</span><span class="s3">\n            </span><span class="s1">bootstrapScripts: [bootstrapScript],</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">const getServerInsertedHTML = makeGetServerInsertedHTML({</span><span class="s3">\n        </span><span class="s1">polyfills,</span><span class="s3">\n        </span><span class="s1">renderServerInsertedHTML,</span><span class="s3">\n        </span><span class="s1">serverCapturedErrors: allCapturedErrors,</span><span class="s3">\n        </span><span class="s1">basePath,</span><span class="s3">\n        </span><span class="s1">tracingMetadata: tracingMetadata,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n\n      </span><span class="s1">// After awaiting here we've waited for the entire RSC render to complete. Crucially this means</span><span class="s3">\n      </span><span class="s1">// that when we detect whether we've used dynamic APIs below we know we'll have picked up even</span><span class="s3">\n      </span><span class="s1">// parts of the React Server render that might not be used in the SSR render.</span><span class="s3">\n      </span><span class="s1">const flightData = await streamToBuffer(reactServerResult.asStream())</span><span class="s3">\n\n      </span><span class="s1">if (shouldGenerateStaticFlightData(workStore)) {</span><span class="s3">\n        </span><span class="s1">metadata.flightData = flightData</span><span class="s3">\n        </span><span class="s1">metadata.segmentData = await collectSegmentData(</span><span class="s3">\n          </span><span class="s1">flightData,</span><span class="s3">\n          </span><span class="s1">ssrPrerenderStore,</span><span class="s3">\n          </span><span class="s1">ComponentMod,</span><span class="s3">\n          </span><span class="s1">renderOpts</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const { prelude, preludeIsEmpty } =</span><span class="s3">\n        </span><span class="s1">await processPrelude(unprocessedPrelude)</span><span class="s3">\n\n      </span><span class="s1">/**</span><span class="s3">\n       </span><span class="s1">* When prerendering there are three outcomes to consider</span><span class="s3">\n       </span><span class="s1">*</span><span class="s3">\n       </span><span class="s1">*   Dynamic HTML:      The prerender has dynamic holes (caused by using Next.js Dynamic Rendering APIs)</span><span class="s3">\n       </span><span class="s1">*                      We will need to resume this result when requests are handled and we don't include</span><span class="s3">\n       </span><span class="s1">*                      any server inserted HTML or inlined flight data in the static HTML</span><span class="s3">\n       </span><span class="s1">*</span><span class="s3">\n       </span><span class="s1">*   Dynamic Data:      The prerender has no dynamic holes but dynamic APIs were used. We will not</span><span class="s3">\n       </span><span class="s1">*                      resume this render when requests are handled but we will generate new inlined</span><span class="s3">\n       </span><span class="s1">*                      flight data since it is dynamic and differences may end up reconciling on the client</span><span class="s3">\n       </span><span class="s1">*</span><span class="s3">\n       </span><span class="s1">*   Static:            The prerender has no dynamic holes and no dynamic APIs were used. We statically encode</span><span class="s3">\n       </span><span class="s1">*                      all server inserted HTML and flight data</span><span class="s3">\n       </span><span class="s1">*/</span><span class="s3">\n      </span><span class="s1">// First we check if we have any dynamic holes in our HTML prerender</span><span class="s3">\n      </span><span class="s1">if (accessedDynamicData(dynamicTracking.dynamicAccesses)) {</span><span class="s3">\n        </span><span class="s1">if (postponed != null) {</span><span class="s3">\n          </span><span class="s1">// Dynamic HTML case.</span><span class="s3">\n          </span><span class="s1">metadata.postponed = await getDynamicHTMLPostponedState(</span><span class="s3">\n            </span><span class="s1">postponed,</span><span class="s3">\n            </span><span class="s1">preludeIsEmpty</span><span class="s3">\n              </span><span class="s1">? DynamicHTMLPreludeState.Empty</span><span class="s3">\n              </span><span class="s1">: DynamicHTMLPreludeState.Full,</span><span class="s3">\n            </span><span class="s1">fallbackRouteParams,</span><span class="s3">\n            </span><span class="s1">prerenderResumeDataCache</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// Dynamic Data case.</span><span class="s3">\n          </span><span class="s1">metadata.postponed = await getDynamicDataPostponedState(</span><span class="s3">\n            </span><span class="s1">prerenderResumeDataCache</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Regardless of whether this is the Dynamic HTML or Dynamic Data case we need to ensure we include</span><span class="s3">\n        </span><span class="s1">// server inserted html in the static response because the html that is part of the prerender may depend on it</span><span class="s3">\n        </span><span class="s1">// It is possible in the set of stream transforms for Dynamic HTML vs Dynamic Data may differ but currently both states</span><span class="s3">\n        </span><span class="s1">// require the same set so we unify the code path here</span><span class="s3">\n        </span><span class="s1">reactServerResult.consume()</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">digestErrorsMap: reactServerErrorsByDigest,</span><span class="s3">\n          </span><span class="s1">ssrErrors: allCapturedErrors,</span><span class="s3">\n          </span><span class="s1">stream: await continueDynamicPrerender(prelude, {</span><span class="s3">\n            </span><span class="s1">getServerInsertedHTML,</span><span class="s3">\n            </span><span class="s1">getServerInsertedMetadata,</span><span class="s3">\n          </span><span class="s1">}),</span><span class="s3">\n          </span><span class="s1">dynamicAccess: dynamicTracking.dynamicAccesses,</span><span class="s3">\n          </span><span class="s1">// TODO: Should this include the SSR pass?</span><span class="s3">\n          </span><span class="s1">collectedRevalidate: reactServerPrerenderStore.revalidate,</span><span class="s3">\n          </span><span class="s1">collectedExpire: reactServerPrerenderStore.expire,</span><span class="s3">\n          </span><span class="s1">collectedStale: selectStaleTime(reactServerPrerenderStore.stale),</span><span class="s3">\n          </span><span class="s1">collectedTags: reactServerPrerenderStore.tags,</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else if (fallbackRouteParams &amp;&amp; fallbackRouteParams.size &gt; 0) {</span><span class="s3">\n        </span><span class="s1">// Rendering the fallback case.</span><span class="s3">\n        </span><span class="s1">metadata.postponed = await getDynamicDataPostponedState(</span><span class="s3">\n          </span><span class="s1">prerenderResumeDataCache</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">digestErrorsMap: reactServerErrorsByDigest,</span><span class="s3">\n          </span><span class="s1">ssrErrors: allCapturedErrors,</span><span class="s3">\n          </span><span class="s1">stream: await continueDynamicPrerender(prelude, {</span><span class="s3">\n            </span><span class="s1">getServerInsertedHTML,</span><span class="s3">\n            </span><span class="s1">getServerInsertedMetadata,</span><span class="s3">\n          </span><span class="s1">}),</span><span class="s3">\n          </span><span class="s1">dynamicAccess: dynamicTracking.dynamicAccesses,</span><span class="s3">\n          </span><span class="s1">// TODO: Should this include the SSR pass?</span><span class="s3">\n          </span><span class="s1">collectedRevalidate: reactServerPrerenderStore.revalidate,</span><span class="s3">\n          </span><span class="s1">collectedExpire: reactServerPrerenderStore.expire,</span><span class="s3">\n          </span><span class="s1">collectedStale: selectStaleTime(reactServerPrerenderStore.stale),</span><span class="s3">\n          </span><span class="s1">collectedTags: reactServerPrerenderStore.tags,</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// Static case</span><span class="s3">\n        </span><span class="s1">// We still have not used any dynamic APIs. At this point we can produce an entirely static prerender response</span><span class="s3">\n        </span><span class="s1">if (workStore.forceDynamic) {</span><span class="s3">\n          </span><span class="s1">throw new StaticGenBailoutError(</span><span class="s3">\n            </span><span class="s1">'Invariant: a Page with `dynamic = </span><span class="s3">\&quot;</span><span class="s1">force-dynamic</span><span class="s3">\&quot;</span><span class="s1">` did not trigger the dynamic pathway. This is a bug in Next.js'</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">let htmlStream = prelude</span><span class="s3">\n        </span><span class="s1">if (postponed != null) {</span><span class="s3">\n          </span><span class="s1">// We postponed but nothing dynamic was used. We resume the render now and immediately abort it</span><span class="s3">\n          </span><span class="s1">// so we can set all the postponed boundaries to client render mode before we store the HTML response</span><span class="s3">\n          </span><span class="s1">const resume = (</span><span class="s3">\n            </span><span class="s1">require('react-dom/server') as typeof import('react-dom/server')</span><span class="s3">\n          </span><span class="s1">).resume</span><span class="s3">\n\n          </span><span class="s1">// We don't actually want to render anything so we just pass a stream</span><span class="s3">\n          </span><span class="s1">// that never resolves. The resume call is going to abort immediately anyway</span><span class="s3">\n          </span><span class="s1">const foreverStream = new ReadableStream&lt;Uint8Array&gt;()</span><span class="s3">\n\n          </span><span class="s1">const resumeStream = await resume(</span><span class="s3">\n            </span><span class="s1">&lt;App</span><span class="s3">\n              </span><span class="s1">reactServerStream={foreverStream}</span><span class="s3">\n              </span><span class="s1">preinitScripts={() =&gt; {}}</span><span class="s3">\n              </span><span class="s1">clientReferenceManifest={clientReferenceManifest}</span><span class="s3">\n              </span><span class="s1">ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}</span><span class="s3">\n              </span><span class="s1">nonce={nonce}</span><span class="s3">\n            </span><span class="s1">/&gt;,</span><span class="s3">\n            </span><span class="s1">JSON.parse(JSON.stringify(postponed)),</span><span class="s3">\n            </span><span class="s1">{</span><span class="s3">\n              </span><span class="s1">signal: createRenderInBrowserAbortSignal(),</span><span class="s3">\n              </span><span class="s1">onError: htmlRendererErrorHandler,</span><span class="s3">\n              </span><span class="s1">nonce,</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n\n          </span><span class="s1">// First we write everything from the prerender, then we write everything from the aborted resume render</span><span class="s3">\n          </span><span class="s1">htmlStream = chainStreams(prelude, resumeStream)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">digestErrorsMap: reactServerErrorsByDigest,</span><span class="s3">\n          </span><span class="s1">ssrErrors: allCapturedErrors,</span><span class="s3">\n          </span><span class="s1">stream: await continueStaticPrerender(htmlStream, {</span><span class="s3">\n            </span><span class="s1">inlinedDataStream: createInlinedDataReadableStream(</span><span class="s3">\n              </span><span class="s1">reactServerResult.consumeAsStream(),</span><span class="s3">\n              </span><span class="s1">nonce,</span><span class="s3">\n              </span><span class="s1">formState</span><span class="s3">\n            </span><span class="s1">),</span><span class="s3">\n            </span><span class="s1">getServerInsertedHTML,</span><span class="s3">\n            </span><span class="s1">getServerInsertedMetadata,</span><span class="s3">\n            </span><span class="s1">isBuildTimePrerendering:</span><span class="s3">\n              </span><span class="s1">ctx.workStore.isBuildTimePrerendering === true,</span><span class="s3">\n            </span><span class="s1">buildId: ctx.workStore.buildId,</span><span class="s3">\n          </span><span class="s1">}),</span><span class="s3">\n          </span><span class="s1">dynamicAccess: dynamicTracking.dynamicAccesses,</span><span class="s3">\n          </span><span class="s1">// TODO: Should this include the SSR pass?</span><span class="s3">\n          </span><span class="s1">collectedRevalidate: reactServerPrerenderStore.revalidate,</span><span class="s3">\n          </span><span class="s1">collectedExpire: reactServerPrerenderStore.expire,</span><span class="s3">\n          </span><span class="s1">collectedStale: selectStaleTime(reactServerPrerenderStore.stale),</span><span class="s3">\n          </span><span class="s1">collectedTags: reactServerPrerenderStore.tags,</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">const prerenderLegacyStore: PrerenderStore = (prerenderStore = {</span><span class="s3">\n        </span><span class="s1">type: 'prerender-legacy',</span><span class="s3">\n        </span><span class="s1">phase: 'render',</span><span class="s3">\n        </span><span class="s1">rootParams,</span><span class="s3">\n        </span><span class="s1">implicitTags,</span><span class="s3">\n        </span><span class="s1">revalidate: INFINITE_CACHE,</span><span class="s3">\n        </span><span class="s1">expire: INFINITE_CACHE,</span><span class="s3">\n        </span><span class="s1">stale: INFINITE_CACHE,</span><span class="s3">\n        </span><span class="s1">tags: [...implicitTags.tags],</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">// This is a regular static generation. We don't do dynamic tracking because we rely on</span><span class="s3">\n      </span><span class="s1">// the old-school dynamic error handling to bail out of static generation</span><span class="s3">\n      </span><span class="s1">const RSCPayload = await workUnitAsyncStorage.run(</span><span class="s3">\n        </span><span class="s1">prerenderLegacyStore,</span><span class="s3">\n        </span><span class="s1">getRSCPayload,</span><span class="s3">\n        </span><span class="s1">tree,</span><span class="s3">\n        </span><span class="s1">ctx,</span><span class="s3">\n        </span><span class="s1">res.statusCode === 404</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">const reactServerResult = (reactServerPrerenderResult =</span><span class="s3">\n        </span><span class="s1">await createReactServerPrerenderResultFromRender(</span><span class="s3">\n          </span><span class="s1">workUnitAsyncStorage.run(</span><span class="s3">\n            </span><span class="s1">prerenderLegacyStore,</span><span class="s3">\n            </span><span class="s1">ComponentMod.renderToReadableStream,</span><span class="s3">\n            </span><span class="s1">RSCPayload,</span><span class="s3">\n            </span><span class="s1">clientReferenceManifest.clientModules,</span><span class="s3">\n            </span><span class="s1">{</span><span class="s3">\n              </span><span class="s1">filterStackFrame,</span><span class="s3">\n              </span><span class="s1">onError: serverComponentsErrorHandler,</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">))</span><span class="s3">\n\n      </span><span class="s1">const renderToReadableStream = (</span><span class="s3">\n        </span><span class="s1">require('react-dom/server') as typeof import('react-dom/server')</span><span class="s3">\n      </span><span class="s1">).renderToReadableStream</span><span class="s3">\n      </span><span class="s1">const htmlStream = await workUnitAsyncStorage.run(</span><span class="s3">\n        </span><span class="s1">prerenderLegacyStore,</span><span class="s3">\n        </span><span class="s1">renderToReadableStream,</span><span class="s3">\n        </span><span class="s1">&lt;App</span><span class="s3">\n          </span><span class="s1">reactServerStream={reactServerResult.asUnclosingStream()}</span><span class="s3">\n          </span><span class="s1">preinitScripts={preinitScripts}</span><span class="s3">\n          </span><span class="s1">clientReferenceManifest={clientReferenceManifest}</span><span class="s3">\n          </span><span class="s1">ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}</span><span class="s3">\n          </span><span class="s1">nonce={nonce}</span><span class="s3">\n        </span><span class="s1">/&gt;,</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">onError: htmlRendererErrorHandler,</span><span class="s3">\n          </span><span class="s1">nonce,</span><span class="s3">\n          </span><span class="s1">bootstrapScripts: [bootstrapScript],</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">if (shouldGenerateStaticFlightData(workStore)) {</span><span class="s3">\n        </span><span class="s1">const flightData = await streamToBuffer(reactServerResult.asStream())</span><span class="s3">\n        </span><span class="s1">metadata.flightData = flightData</span><span class="s3">\n        </span><span class="s1">metadata.segmentData = await collectSegmentData(</span><span class="s3">\n          </span><span class="s1">flightData,</span><span class="s3">\n          </span><span class="s1">prerenderLegacyStore,</span><span class="s3">\n          </span><span class="s1">ComponentMod,</span><span class="s3">\n          </span><span class="s1">renderOpts</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const getServerInsertedHTML = makeGetServerInsertedHTML({</span><span class="s3">\n        </span><span class="s1">polyfills,</span><span class="s3">\n        </span><span class="s1">renderServerInsertedHTML,</span><span class="s3">\n        </span><span class="s1">serverCapturedErrors: allCapturedErrors,</span><span class="s3">\n        </span><span class="s1">basePath,</span><span class="s3">\n        </span><span class="s1">tracingMetadata: tracingMetadata,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">digestErrorsMap: reactServerErrorsByDigest,</span><span class="s3">\n        </span><span class="s1">ssrErrors: allCapturedErrors,</span><span class="s3">\n        </span><span class="s1">stream: await continueFizzStream(htmlStream, {</span><span class="s3">\n          </span><span class="s1">inlinedDataStream: createInlinedDataReadableStream(</span><span class="s3">\n            </span><span class="s1">reactServerResult.consumeAsStream(),</span><span class="s3">\n            </span><span class="s1">nonce,</span><span class="s3">\n            </span><span class="s1">formState</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">isStaticGeneration: true,</span><span class="s3">\n          </span><span class="s1">isBuildTimePrerendering:</span><span class="s3">\n            </span><span class="s1">ctx.workStore.isBuildTimePrerendering === true,</span><span class="s3">\n          </span><span class="s1">buildId: ctx.workStore.buildId,</span><span class="s3">\n          </span><span class="s1">getServerInsertedHTML,</span><span class="s3">\n          </span><span class="s1">getServerInsertedMetadata,</span><span class="s3">\n        </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">// TODO: Should this include the SSR pass?</span><span class="s3">\n        </span><span class="s1">collectedRevalidate: prerenderLegacyStore.revalidate,</span><span class="s3">\n        </span><span class="s1">collectedExpire: prerenderLegacyStore.expire,</span><span class="s3">\n        </span><span class="s1">collectedStale: selectStaleTime(prerenderLegacyStore.stale),</span><span class="s3">\n        </span><span class="s1">collectedTags: prerenderLegacyStore.tags,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} catch (err) {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">isStaticGenBailoutError(err) ||</span><span class="s3">\n      </span><span class="s1">(typeof err === 'object' &amp;&amp;</span><span class="s3">\n        </span><span class="s1">err !== null &amp;&amp;</span><span class="s3">\n        </span><span class="s1">'message' in err &amp;&amp;</span><span class="s3">\n        </span><span class="s1">typeof err.message === 'string' &amp;&amp;</span><span class="s3">\n        </span><span class="s1">err.message.includes(</span><span class="s3">\n          </span><span class="s1">'https://nextjs.org/docs/advanced-features/static-html-export'</span><span class="s3">\n        </span><span class="s1">))</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// Ensure that </span><span class="s3">\&quot;</span><span class="s1">next dev</span><span class="s3">\&quot; </span><span class="s1">prints the red error overlay</span><span class="s3">\n      </span><span class="s1">throw err</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If this is a static generation error, we need to throw it so that it</span><span class="s3">\n    </span><span class="s1">// can be handled by the caller if we're in static generation mode.</span><span class="s3">\n    </span><span class="s1">if (isDynamicServerError(err)) {</span><span class="s3">\n      </span><span class="s1">throw err</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If a bailout made it to this point, it means it wasn't wrapped inside</span><span class="s3">\n    </span><span class="s1">// a suspense boundary.</span><span class="s3">\n    </span><span class="s1">const shouldBailoutToCSR = isBailoutToCSRError(err)</span><span class="s3">\n    </span><span class="s1">if (shouldBailoutToCSR) {</span><span class="s3">\n      </span><span class="s1">const stack = getStackWithoutErrorMessage(err)</span><span class="s3">\n      </span><span class="s1">error(</span><span class="s3">\n        </span><span class="s1">`${err.reason} should be wrapped in a suspense boundary at page </span><span class="s3">\&quot;</span><span class="s1">${pagePath}</span><span class="s3">\&quot;</span><span class="s1">. Read more: https://nextjs.org/docs/messages/missing-suspense-with-csr-bailout</span><span class="s3">\\</span><span class="s1">n${stack}`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">throw err</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If we errored when we did not have an RSC stream to read from. This is</span><span class="s3">\n    </span><span class="s1">// not just a render error, we need to throw early.</span><span class="s3">\n    </span><span class="s1">if (reactServerPrerenderResult === null) {</span><span class="s3">\n      </span><span class="s1">throw err</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let errorType: MetadataErrorType | 'redirect' | undefined</span><span class="s3">\n\n    </span><span class="s1">if (isHTTPAccessFallbackError(err)) {</span><span class="s3">\n      </span><span class="s1">res.statusCode = getAccessFallbackHTTPStatus(err)</span><span class="s3">\n      </span><span class="s1">metadata.statusCode = res.statusCode</span><span class="s3">\n      </span><span class="s1">errorType = getAccessFallbackErrorTypeByStatus(res.statusCode)</span><span class="s3">\n    </span><span class="s1">} else if (isRedirectError(err)) {</span><span class="s3">\n      </span><span class="s1">errorType = 'redirect'</span><span class="s3">\n      </span><span class="s1">res.statusCode = getRedirectStatusCodeFromError(err)</span><span class="s3">\n      </span><span class="s1">metadata.statusCode = res.statusCode</span><span class="s3">\n\n      </span><span class="s1">const redirectUrl = addPathPrefix(getURLFromRedirectError(err), basePath)</span><span class="s3">\n\n      </span><span class="s1">setHeader('location', redirectUrl)</span><span class="s3">\n    </span><span class="s1">} else if (!shouldBailoutToCSR) {</span><span class="s3">\n      </span><span class="s1">res.statusCode = 500</span><span class="s3">\n      </span><span class="s1">metadata.statusCode = res.statusCode</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const [errorPreinitScripts, errorBootstrapScript] = getRequiredScripts(</span><span class="s3">\n      </span><span class="s1">buildManifest,</span><span class="s3">\n      </span><span class="s1">assetPrefix,</span><span class="s3">\n      </span><span class="s1">crossOrigin,</span><span class="s3">\n      </span><span class="s1">subresourceIntegrityManifest,</span><span class="s3">\n      </span><span class="s1">getAssetQueryString(ctx, false),</span><span class="s3">\n      </span><span class="s1">nonce,</span><span class="s3">\n      </span><span class="s1">'/_not-found/page'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">const prerenderLegacyStore: PrerenderStore = (prerenderStore = {</span><span class="s3">\n      </span><span class="s1">type: 'prerender-legacy',</span><span class="s3">\n      </span><span class="s1">phase: 'render',</span><span class="s3">\n      </span><span class="s1">rootParams,</span><span class="s3">\n      </span><span class="s1">implicitTags: implicitTags,</span><span class="s3">\n      </span><span class="s1">revalidate:</span><span class="s3">\n        </span><span class="s1">typeof prerenderStore?.revalidate !== 'undefined'</span><span class="s3">\n          </span><span class="s1">? prerenderStore.revalidate</span><span class="s3">\n          </span><span class="s1">: INFINITE_CACHE,</span><span class="s3">\n      </span><span class="s1">expire:</span><span class="s3">\n        </span><span class="s1">typeof prerenderStore?.expire !== 'undefined'</span><span class="s3">\n          </span><span class="s1">? prerenderStore.expire</span><span class="s3">\n          </span><span class="s1">: INFINITE_CACHE,</span><span class="s3">\n      </span><span class="s1">stale:</span><span class="s3">\n        </span><span class="s1">typeof prerenderStore?.stale !== 'undefined'</span><span class="s3">\n          </span><span class="s1">? prerenderStore.stale</span><span class="s3">\n          </span><span class="s1">: INFINITE_CACHE,</span><span class="s3">\n      </span><span class="s1">tags: [...(prerenderStore?.tags || implicitTags.tags)],</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">const errorRSCPayload = await workUnitAsyncStorage.run(</span><span class="s3">\n      </span><span class="s1">prerenderLegacyStore,</span><span class="s3">\n      </span><span class="s1">getErrorRSCPayload,</span><span class="s3">\n      </span><span class="s1">tree,</span><span class="s3">\n      </span><span class="s1">ctx,</span><span class="s3">\n      </span><span class="s1">reactServerErrorsByDigest.has((err as any).digest) ? undefined : err,</span><span class="s3">\n      </span><span class="s1">errorType</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">const errorServerStream = workUnitAsyncStorage.run(</span><span class="s3">\n      </span><span class="s1">prerenderLegacyStore,</span><span class="s3">\n      </span><span class="s1">ComponentMod.renderToReadableStream,</span><span class="s3">\n      </span><span class="s1">errorRSCPayload,</span><span class="s3">\n      </span><span class="s1">clientReferenceManifest.clientModules,</span><span class="s3">\n      </span><span class="s1">{</span><span class="s3">\n        </span><span class="s1">filterStackFrame,</span><span class="s3">\n        </span><span class="s1">onError: serverComponentsErrorHandler,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">// TODO we should use the same prerender semantics that we initially rendered</span><span class="s3">\n      </span><span class="s1">// with in this case too. The only reason why this is ok atm is because it's essentially</span><span class="s3">\n      </span><span class="s1">// an empty page and no user code runs.</span><span class="s3">\n      </span><span class="s1">const fizzStream = await workUnitAsyncStorage.run(</span><span class="s3">\n        </span><span class="s1">prerenderLegacyStore,</span><span class="s3">\n        </span><span class="s1">renderToInitialFizzStream,</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">ReactDOMServer:</span><span class="s3">\n            </span><span class="s1">require('react-dom/server') as typeof import('react-dom/server'),</span><span class="s3">\n          </span><span class="s1">element: (</span><span class="s3">\n            </span><span class="s1">&lt;ErrorApp</span><span class="s3">\n              </span><span class="s1">reactServerStream={errorServerStream}</span><span class="s3">\n              </span><span class="s1">ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}</span><span class="s3">\n              </span><span class="s1">preinitScripts={errorPreinitScripts}</span><span class="s3">\n              </span><span class="s1">clientReferenceManifest={clientReferenceManifest}</span><span class="s3">\n              </span><span class="s1">nonce={nonce}</span><span class="s3">\n            </span><span class="s1">/&gt;</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">streamOptions: {</span><span class="s3">\n            </span><span class="s1">nonce,</span><span class="s3">\n            </span><span class="s1">// Include hydration scripts in the HTML</span><span class="s3">\n            </span><span class="s1">bootstrapScripts: [errorBootstrapScript],</span><span class="s3">\n            </span><span class="s1">formState,</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">if (shouldGenerateStaticFlightData(workStore)) {</span><span class="s3">\n        </span><span class="s1">const flightData = await streamToBuffer(</span><span class="s3">\n          </span><span class="s1">reactServerPrerenderResult.asStream()</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">metadata.flightData = flightData</span><span class="s3">\n        </span><span class="s1">metadata.segmentData = await collectSegmentData(</span><span class="s3">\n          </span><span class="s1">flightData,</span><span class="s3">\n          </span><span class="s1">prerenderLegacyStore,</span><span class="s3">\n          </span><span class="s1">ComponentMod,</span><span class="s3">\n          </span><span class="s1">renderOpts</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// This is intentionally using the readable datastream from the main</span><span class="s3">\n      </span><span class="s1">// render rather than the flight data from the error page render</span><span class="s3">\n      </span><span class="s1">const flightStream = reactServerPrerenderResult.consumeAsStream()</span><span class="s3">\n\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">// Returning the error that was thrown so it can be used to handle</span><span class="s3">\n        </span><span class="s1">// the response in the caller.</span><span class="s3">\n        </span><span class="s1">digestErrorsMap: reactServerErrorsByDigest,</span><span class="s3">\n        </span><span class="s1">ssrErrors: allCapturedErrors,</span><span class="s3">\n        </span><span class="s1">stream: await continueFizzStream(fizzStream, {</span><span class="s3">\n          </span><span class="s1">inlinedDataStream: createInlinedDataReadableStream(</span><span class="s3">\n            </span><span class="s1">flightStream,</span><span class="s3">\n            </span><span class="s1">nonce,</span><span class="s3">\n            </span><span class="s1">formState</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">isStaticGeneration: true,</span><span class="s3">\n          </span><span class="s1">isBuildTimePrerendering:</span><span class="s3">\n            </span><span class="s1">ctx.workStore.isBuildTimePrerendering === true,</span><span class="s3">\n          </span><span class="s1">buildId: ctx.workStore.buildId,</span><span class="s3">\n          </span><span class="s1">getServerInsertedHTML: makeGetServerInsertedHTML({</span><span class="s3">\n            </span><span class="s1">polyfills,</span><span class="s3">\n            </span><span class="s1">renderServerInsertedHTML,</span><span class="s3">\n            </span><span class="s1">serverCapturedErrors: [],</span><span class="s3">\n            </span><span class="s1">basePath,</span><span class="s3">\n            </span><span class="s1">tracingMetadata: tracingMetadata,</span><span class="s3">\n          </span><span class="s1">}),</span><span class="s3">\n          </span><span class="s1">getServerInsertedMetadata,</span><span class="s3">\n          </span><span class="s1">validateRootLayout: dev,</span><span class="s3">\n        </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">dynamicAccess: null,</span><span class="s3">\n        </span><span class="s1">collectedRevalidate:</span><span class="s3">\n          </span><span class="s1">prerenderStore !== null ? prerenderStore.revalidate : INFINITE_CACHE,</span><span class="s3">\n        </span><span class="s1">collectedExpire:</span><span class="s3">\n          </span><span class="s1">prerenderStore !== null ? prerenderStore.expire : INFINITE_CACHE,</span><span class="s3">\n        </span><span class="s1">collectedStale: selectStaleTime(</span><span class="s3">\n          </span><span class="s1">prerenderStore !== null ? prerenderStore.stale : INFINITE_CACHE</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">collectedTags: prerenderStore !== null ? prerenderStore.tags : null,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} catch (finalErr: any) {</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">process.env.NODE_ENV === 'development' &amp;&amp;</span><span class="s3">\n        </span><span class="s1">isHTTPAccessFallbackError(finalErr)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">const { bailOnRootNotFound } =</span><span class="s3">\n          </span><span class="s1">require('../../client/components/dev-root-http-access-fallback-boundary') as typeof import('../../client/components/dev-root-http-access-fallback-boundary')</span><span class="s3">\n        </span><span class="s1">bailOnRootNotFound()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">throw finalErr</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const getGlobalErrorStyles = async (</span><span class="s3">\n  </span><span class="s1">tree: LoaderTree,</span><span class="s3">\n  </span><span class="s1">ctx: AppRenderContext</span><span class="s3">\n</span><span class="s1">): Promise&lt;{</span><span class="s3">\n  </span><span class="s1">GlobalError: GlobalErrorComponent</span><span class="s3">\n  </span><span class="s1">styles: React.ReactNode | undefined</span><span class="s3">\n</span><span class="s1">}&gt; =&gt; {</span><span class="s3">\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">modules: { 'global-error': globalErrorModule },</span><span class="s3">\n  </span><span class="s1">} = parseLoaderTree(tree)</span><span class="s3">\n\n  </span><span class="s1">const GlobalErrorComponent: GlobalErrorComponent =</span><span class="s3">\n    </span><span class="s1">ctx.componentMod.GlobalError</span><span class="s3">\n  </span><span class="s1">let globalErrorStyles</span><span class="s3">\n  </span><span class="s1">if (globalErrorModule) {</span><span class="s3">\n    </span><span class="s1">const [, styles] = await createComponentStylesAndScripts({</span><span class="s3">\n      </span><span class="s1">ctx,</span><span class="s3">\n      </span><span class="s1">filePath: globalErrorModule[1],</span><span class="s3">\n      </span><span class="s1">getComponent: globalErrorModule[0],</span><span class="s3">\n      </span><span class="s1">injectedCSS: new Set(),</span><span class="s3">\n      </span><span class="s1">injectedJS: new Set(),</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">globalErrorStyles = styles</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (ctx.renderOpts.dev) {</span><span class="s3">\n    </span><span class="s1">const dir =</span><span class="s3">\n      </span><span class="s1">(process.env.NEXT_RUNTIME === 'edge'</span><span class="s3">\n        </span><span class="s1">? process.env.__NEXT_EDGE_PROJECT_DIR</span><span class="s3">\n        </span><span class="s1">: ctx.renderOpts.dir) || ''</span><span class="s3">\n\n    </span><span class="s1">const globalErrorModulePath = normalizeConventionFilePath(</span><span class="s3">\n      </span><span class="s1">dir,</span><span class="s3">\n      </span><span class="s1">globalErrorModule?.[1]</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">if (ctx.renderOpts.devtoolSegmentExplorer &amp;&amp; globalErrorModulePath) {</span><span class="s3">\n      </span><span class="s1">const SegmentViewNode = ctx.componentMod.SegmentViewNode</span><span class="s3">\n      </span><span class="s1">globalErrorStyles = (</span><span class="s3">\n        </span><span class="s1">// This will be rendered next to GlobalError component under ErrorBoundary,</span><span class="s3">\n        </span><span class="s1">// it requires a key to avoid React warning about duplicate keys.</span><span class="s3">\n        </span><span class="s1">&lt;SegmentViewNode</span><span class="s3">\n          </span><span class="s1">key=</span><span class="s3">\&quot;</span><span class="s1">ge-svn</span><span class="s3">\&quot;\n          </span><span class="s1">type=</span><span class="s3">\&quot;</span><span class="s1">global-error</span><span class="s3">\&quot;\n          </span><span class="s1">pagePath={globalErrorModulePath}</span><span class="s3">\n        </span><span class="s1">&gt;</span><span class="s3">\n          </span><span class="s1">{globalErrorStyles}</span><span class="s3">\n        </span><span class="s1">&lt;/SegmentViewNode&gt;</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">GlobalError: GlobalErrorComponent,</span><span class="s3">\n    </span><span class="s1">styles: globalErrorStyles,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createSelectStaleTime(experimental: ExperimentalConfig) {</span><span class="s3">\n  </span><span class="s1">return (stale: number) =&gt;</span><span class="s3">\n    </span><span class="s1">stale === INFINITE_CACHE &amp;&amp;</span><span class="s3">\n    </span><span class="s1">typeof experimental.staleTimes?.static === 'number'</span><span class="s3">\n      </span><span class="s1">? experimental.staleTimes.static</span><span class="s3">\n      </span><span class="s1">: stale</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">async function collectSegmentData(</span><span class="s3">\n  </span><span class="s1">fullPageDataBuffer: Buffer,</span><span class="s3">\n  </span><span class="s1">prerenderStore: PrerenderStore,</span><span class="s3">\n  </span><span class="s1">ComponentMod: AppPageModule,</span><span class="s3">\n  </span><span class="s1">renderOpts: RenderOpts</span><span class="s3">\n</span><span class="s1">): Promise&lt;Map&lt;string, Buffer&gt; | undefined&gt; {</span><span class="s3">\n  </span><span class="s1">// Per-segment prefetch data</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// All of the segments for a page are generated simultaneously, including</span><span class="s3">\n  </span><span class="s1">// during revalidations. This is to ensure consistency, because it's</span><span class="s3">\n  </span><span class="s1">// possible for a mismatch between a layout and page segment can cause the</span><span class="s3">\n  </span><span class="s1">// client to error during rendering. We want to preserve the ability of the</span><span class="s3">\n  </span><span class="s1">// client to recover from such a mismatch by re-requesting all the segments</span><span class="s3">\n  </span><span class="s1">// to get a consistent view of the page.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// For performance, we reuse the Flight output that was created when</span><span class="s3">\n  </span><span class="s1">// generating the initial page HTML. The Flight stream for the whole page is</span><span class="s3">\n  </span><span class="s1">// decomposed into a separate stream per segment.</span><span class="s3">\n\n  </span><span class="s1">const clientReferenceManifest = renderOpts.clientReferenceManifest</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">!clientReferenceManifest ||</span><span class="s3">\n    </span><span class="s1">// Do not generate per-segment data unless the experimental Segment Cache</span><span class="s3">\n    </span><span class="s1">// flag is enabled.</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">// We also skip generating segment data if flag is set to </span><span class="s3">\&quot;</span><span class="s1">client-only</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">// rather than true. (The </span><span class="s3">\&quot;</span><span class="s1">client-only</span><span class="s3">\&quot; </span><span class="s1">option only affects the behavior of</span><span class="s3">\n    </span><span class="s1">// the client-side implementation; per-segment prefetches are intentionally</span><span class="s3">\n    </span><span class="s1">// disabled in that configuration).</span><span class="s3">\n    </span><span class="s1">renderOpts.experimental.clientSegmentCache !== true</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Manifest passed to the Flight client for reading the full-page Flight</span><span class="s3">\n  </span><span class="s1">// stream. Based off similar code in use-cache-wrapper.ts.</span><span class="s3">\n  </span><span class="s1">const isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge'</span><span class="s3">\n  </span><span class="s1">const serverConsumerManifest = {</span><span class="s3">\n    </span><span class="s1">// moduleLoading must be null because we don't want to trigger preloads of ClientReferences</span><span class="s3">\n    </span><span class="s1">// to be added to the consumer. Instead, we'll wait for any ClientReference to be emitted</span><span class="s3">\n    </span><span class="s1">// which themselves will handle the preloading.</span><span class="s3">\n    </span><span class="s1">moduleLoading: null,</span><span class="s3">\n    </span><span class="s1">moduleMap: isEdgeRuntime</span><span class="s3">\n      </span><span class="s1">? clientReferenceManifest.edgeRscModuleMapping</span><span class="s3">\n      </span><span class="s1">: clientReferenceManifest.rscModuleMapping,</span><span class="s3">\n    </span><span class="s1">serverModuleMap: getServerModuleMap(),</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const staleTime = prerenderStore.stale</span><span class="s3">\n  </span><span class="s1">return await ComponentMod.collectSegmentData(</span><span class="s3">\n    </span><span class="s1">renderOpts.experimental.clientParamParsing,</span><span class="s3">\n    </span><span class="s1">fullPageDataBuffer,</span><span class="s3">\n    </span><span class="s1">staleTime,</span><span class="s3">\n    </span><span class="s1">clientReferenceManifest.clientModules as ManifestNode,</span><span class="s3">\n    </span><span class="s1">serverConsumerManifest</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;renderToHTMLOrFlight&quot;</span><span class="s0">,</span><span class="s1">&quot;flightDataPathHeadKey&quot;</span><span class="s0">,</span><span class="s1">&quot;getFlightViewportKey&quot;</span><span class="s0">,</span><span class="s1">&quot;requestId&quot;</span><span class="s0">,</span><span class="s1">&quot;getFlightMetadataKey&quot;</span><span class="s0">,</span><span class="s1">&quot;filterStackFrame&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;filterStackFrameDEV&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;parseRequestHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;headers&quot;</span><span class="s0">,</span><span class="s1">&quot;options&quot;</span><span class="s0">,</span><span class="s1">&quot;isDevWarmupRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;isDevWarmup&quot;</span><span class="s0">,</span><span class="s1">&quot;isPrefetchRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_ROUTER_PREFETCH_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;isRuntimePrefetchRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;isHmrRefresh&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_HMR_REFRESH_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;isRSCRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;RSC_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldProvideFlightRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;isRoutePPREnabled&quot;</span><span class="s0">,</span><span class="s1">&quot;flightRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;parseAndValidateFlightRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_ROUTER_STATE_TREE_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;isRouteTreePrefetchRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_ROUTER_SEGMENT_PREFETCH_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;csp&quot;</span><span class="s0">,</span><span class="s1">&quot;nonce&quot;</span><span class="s0">,</span><span class="s1">&quot;getScriptNonceFromHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;previouslyRevalidatedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;getPreviouslyRevalidatedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;previewModeId&quot;</span><span class="s0">,</span><span class="s1">&quot;createNotFoundLoaderTree&quot;</span><span class="s0">,</span><span class="s1">&quot;loaderTree&quot;</span><span class="s0">,</span><span class="s1">&quot;components&quot;</span><span class="s0">,</span><span class="s1">&quot;hasGlobalNotFound&quot;</span><span class="s0">,</span><span class="s1">&quot;children&quot;</span><span class="s0">,</span><span class="s1">&quot;PAGE_SEGMENT_KEY&quot;</span><span class="s0">,</span><span class="s1">&quot;page&quot;</span><span class="s0">,</span><span class="s1">&quot;makeGetDynamicParamFromSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;params&quot;</span><span class="s0">,</span><span class="s1">&quot;pagePath&quot;</span><span class="s0">,</span><span class="s1">&quot;fallbackRouteParams&quot;</span><span class="s0">,</span><span class="s1">&quot;getDynamicParamFromSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentParam&quot;</span><span class="s0">,</span><span class="s1">&quot;getSegmentParam&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentKey&quot;</span><span class="s0">,</span><span class="s1">&quot;param&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicParamType&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicParamTypes&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;getDynamicParam&quot;</span><span class="s0">,</span><span class="s1">&quot;NonIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;statusCode&quot;</span><span class="s0">,</span><span class="s1">&quot;isPossibleServerAction&quot;</span><span class="s0">,</span><span class="s1">&quot;is404Page&quot;</span><span class="s0">,</span><span class="s1">&quot;isInvalidStatusCode&quot;</span><span class="s0">,</span><span class="s1">&quot;meta&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;content&quot;</span><span class="s0">,</span><span class="s1">&quot;generateDynamicRSCPayload&quot;</span><span class="s0">,</span><span class="s1">&quot;ctx&quot;</span><span class="s0">,</span><span class="s1">&quot;flightData&quot;</span><span class="s0">,</span><span class="s1">&quot;componentMod&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;createMetadataComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;MetadataBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;ViewportBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;appUsingSizeAdjustment&quot;</span><span class="s0">,</span><span class="s1">&quot;query&quot;</span><span class="s0">,</span><span class="s1">&quot;workStore&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;serveStreamingMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;renderOpts&quot;</span><span class="s0">,</span><span class="s1">&quot;skipFlight&quot;</span><span class="s0">,</span><span class="s1">&quot;preloadCallbacks&quot;</span><span class="s0">,</span><span class="s1">&quot;ViewportTree&quot;</span><span class="s0">,</span><span class="s1">&quot;MetadataTree&quot;</span><span class="s0">,</span><span class="s1">&quot;getViewportReady&quot;</span><span class="s0">,</span><span class="s1">&quot;getMetadataReady&quot;</span><span class="s0">,</span><span class="s1">&quot;StreamingMetadataOutlet&quot;</span><span class="s0">,</span><span class="s1">&quot;parsedQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;metadataContext&quot;</span><span class="s0">,</span><span class="s1">&quot;createMetadataContext&quot;</span><span class="s0">,</span><span class="s1">&quot;walkTreeWithFlightRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;loaderTreeToFilter&quot;</span><span class="s0">,</span><span class="s1">&quot;parentParams&quot;</span><span class="s0">,</span><span class="s1">&quot;rscHead&quot;</span><span class="s0">,</span><span class="s1">&quot;React&quot;</span><span class="s0">,</span><span class="s1">&quot;Fragment&quot;</span><span class="s0">,</span><span class="s1">&quot;res&quot;</span><span class="s0">,</span><span class="s1">&quot;injectedCSS&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;injectedJS&quot;</span><span class="s0">,</span><span class="s1">&quot;injectedFontPreloadTags&quot;</span><span class="s0">,</span><span class="s1">&quot;rootLayoutIncluded&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;actionResult&quot;</span><span class="s0">,</span><span class="s1">&quot;a&quot;</span><span class="s0">,</span><span class="s1">&quot;f&quot;</span><span class="s0">,</span><span class="s1">&quot;b&quot;</span><span class="s0">,</span><span class="s1">&quot;sharedContext&quot;</span><span class="s0">,</span><span class="s1">&quot;buildId&quot;</span><span class="s0">,</span><span class="s1">&quot;S&quot;</span><span class="s0">,</span><span class="s1">&quot;isStaticGeneration&quot;</span><span class="s0">,</span><span class="s1">&quot;createErrorContext&quot;</span><span class="s0">,</span><span class="s1">&quot;renderSource&quot;</span><span class="s0">,</span><span class="s1">&quot;routerKind&quot;</span><span class="s0">,</span><span class="s1">&quot;routePath&quot;</span><span class="s0">,</span><span class="s1">&quot;routeType&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidateReason&quot;</span><span class="s0">,</span><span class="s1">&quot;getRevalidateReason&quot;</span><span class="s0">,</span><span class="s1">&quot;generateDynamicFlightRenderResult&quot;</span><span class="s0">,</span><span class="s1">&quot;req&quot;</span><span class="s0">,</span><span class="s1">&quot;requestStore&quot;</span><span class="s0">,</span><span class="s1">&quot;onFlightDataRenderError&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;onInstrumentationRequestError&quot;</span><span class="s0">,</span><span class="s1">&quot;onError&quot;</span><span class="s0">,</span><span class="s1">&quot;createFlightReactServerErrorHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;dev&quot;</span><span class="s0">,</span><span class="s1">&quot;RSCPayload&quot;</span><span class="s0">,</span><span class="s1">&quot;workUnitAsyncStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;run&quot;</span><span class="s0">,</span><span class="s1">&quot;flightReadableStream&quot;</span><span class="s0">,</span><span class="s1">&quot;renderToReadableStream&quot;</span><span class="s0">,</span><span class="s1">&quot;clientReferenceManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;clientModules&quot;</span><span class="s0">,</span><span class="s1">&quot;temporaryReferences&quot;</span><span class="s0">,</span><span class="s1">&quot;FlightRenderResult&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchMetrics&quot;</span><span class="s0">,</span><span class="s1">&quot;generateRuntimePrefetchResult&quot;</span><span class="s0">,</span><span class="s1">&quot;metadata&quot;</span><span class="s0">,</span><span class="s1">&quot;generatePayload&quot;</span><span class="s0">,</span><span class="s1">&quot;rootParams&quot;</span><span class="s0">,</span><span class="s1">&quot;getRootParams&quot;</span><span class="s0">,</span><span class="s1">&quot;prerenderResumeDataCache&quot;</span><span class="s0">,</span><span class="s1">&quot;createPrerenderResumeDataCache&quot;</span><span class="s0">,</span><span class="s1">&quot;renderResumeDataCache&quot;</span><span class="s0">,</span><span class="s1">&quot;prospectiveRuntimeServerPrerender&quot;</span><span class="s0">,</span><span class="s1">&quot;cookies&quot;</span><span class="s0">,</span><span class="s1">&quot;draftMode&quot;</span><span class="s0">,</span><span class="s1">&quot;response&quot;</span><span class="s0">,</span><span class="s1">&quot;finalRuntimeServerPrerender&quot;</span><span class="s0">,</span><span class="s1">&quot;applyMetadataFromPrerenderResult&quot;</span><span class="s0">,</span><span class="s1">&quot;isPartial&quot;</span><span class="s0">,</span><span class="s1">&quot;setHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_DID_POSTPONE_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;prelude&quot;</span><span class="s0">,</span><span class="s1">&quot;getPayload&quot;</span><span class="s0">,</span><span class="s1">&quot;implicitTags&quot;</span><span class="s0">,</span><span class="s1">&quot;ComponentMod&quot;</span><span class="s0">,</span><span class="s1">&quot;assertClientReferenceManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;initialServerPrerenderController&quot;</span><span class="s0">,</span><span class="s1">&quot;AbortController&quot;</span><span class="s0">,</span><span class="s1">&quot;initialServerRenderController&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheSignal&quot;</span><span class="s0">,</span><span class="s1">&quot;CacheSignal&quot;</span><span class="s0">,</span><span class="s1">&quot;initialServerPrerenderStore&quot;</span><span class="s0">,</span><span class="s1">&quot;phase&quot;</span><span class="s0">,</span><span class="s1">&quot;renderSignal&quot;</span><span class="s0">,</span><span class="s1">&quot;signal&quot;</span><span class="s0">,</span><span class="s1">&quot;controller&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicTracking&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;expire&quot;</span><span class="s0">,</span><span class="s1">&quot;stale&quot;</span><span class="s0">,</span><span class="s1">&quot;INFINITE_CACHE&quot;</span><span class="s0">,</span><span class="s1">&quot;tags&quot;</span><span class="s0">,</span><span class="s1">&quot;hmrRefreshHash&quot;</span><span class="s0">,</span><span class="s1">&quot;captureOwnerStack&quot;</span><span class="s0">,</span><span class="s1">&quot;runtimeStagePromise&quot;</span><span class="s0">,</span><span class="s1">&quot;initialServerPayload&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingInitialServerResult&quot;</span><span class="s0">,</span><span class="s1">&quot;prerender&quot;</span><span class="s0">,</span><span class="s1">&quot;digest&quot;</span><span class="s0">,</span><span class="s1">&quot;getDigestForWellKnownError&quot;</span><span class="s0">,</span><span class="s1">&quot;aborted&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_DEBUG_BUILD&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_VERBOSE_LOGGING&quot;</span><span class="s0">,</span><span class="s1">&quot;printDebugThrownValueForProspectiveRender&quot;</span><span class="s0">,</span><span class="s1">&quot;route&quot;</span><span class="s0">,</span><span class="s1">&quot;onPostpone&quot;</span><span class="s0">,</span><span class="s1">&quot;trackPendingModules&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheReady&quot;</span><span class="s0">,</span><span class="s1">&quot;abort&quot;</span><span class="s0">,</span><span class="s1">&quot;invalidDynamicUsageError&quot;</span><span class="s0">,</span><span class="s1">&quot;createReactServerPrerenderResult&quot;</span><span class="s0">,</span><span class="s1">&quot;experimental&quot;</span><span class="s0">,</span><span class="s1">&quot;isDebugDynamicAccesses&quot;</span><span class="s0">,</span><span class="s1">&quot;selectStaleTime&quot;</span><span class="s0">,</span><span class="s1">&quot;createSelectStaleTime&quot;</span><span class="s0">,</span><span class="s1">&quot;serverIsDynamic&quot;</span><span class="s0">,</span><span class="s1">&quot;finalServerController&quot;</span><span class="s0">,</span><span class="s1">&quot;serverDynamicTracking&quot;</span><span class="s0">,</span><span class="s1">&quot;createDynamicTrackingState&quot;</span><span class="s0">,</span><span class="s1">&quot;promise&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveBlockedRuntimeAPIs&quot;</span><span class="s0">,</span><span class="s1">&quot;createPromiseWithResolvers&quot;</span><span class="s0">,</span><span class="s1">&quot;finalServerPrerenderStore&quot;</span><span class="s0">,</span><span class="s1">&quot;finalRSCPayload&quot;</span><span class="s0">,</span><span class="s1">&quot;prerenderIsPending&quot;</span><span class="s0">,</span><span class="s1">&quot;prerenderAndAbortInSequentialTasksWithStages&quot;</span><span class="s0">,</span><span class="s1">&quot;prerenderResult&quot;</span><span class="s0">,</span><span class="s1">&quot;warnOnSyncDynamicError&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicAccess&quot;</span><span class="s0">,</span><span class="s1">&quot;collectedRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;collectedExpire&quot;</span><span class="s0">,</span><span class="s1">&quot;collectedStale&quot;</span><span class="s0">,</span><span class="s1">&quot;collectedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;warmupDevRender&quot;</span><span class="s0">,</span><span class="s1">&quot;allowEmptyStaticShell&quot;</span><span class="s0">,</span><span class="s1">&quot;InvariantError&quot;</span><span class="s0">,</span><span class="s1">&quot;renderController&quot;</span><span class="s0">,</span><span class="s1">&quot;prerenderController&quot;</span><span class="s0">,</span><span class="s1">&quot;reactController&quot;</span><span class="s0">,</span><span class="s1">&quot;prerenderStore&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_HMR_REFRESH_HASH_COOKIE&quot;</span><span class="s0">,</span><span class="s1">&quot;rscPayload&quot;</span><span class="s0">,</span><span class="s1">&quot;createRenderResumeDataCache&quot;</span><span class="s0">,</span><span class="s1">&quot;prepareInitialCanonicalUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;search&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;getRSCPayload&quot;</span><span class="s0">,</span><span class="s1">&quot;is404&quot;</span><span class="s0">,</span><span class="s1">&quot;missingSlots&quot;</span><span class="s0">,</span><span class="s1">&quot;initialTree&quot;</span><span class="s0">,</span><span class="s1">&quot;createFlightRouterStateFromLoaderTree&quot;</span><span class="s0">,</span><span class="s1">&quot;errorType&quot;</span><span class="s0">,</span><span class="s1">&quot;seedData&quot;</span><span class="s0">,</span><span class="s1">&quot;createComponentTree&quot;</span><span class="s0">,</span><span class="s1">&quot;authInterrupts&quot;</span><span class="s0">,</span><span class="s1">&quot;varyHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;getHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;couldBeIntercepted&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_URL&quot;</span><span class="s0">,</span><span class="s1">&quot;initialHead&quot;</span><span class="s0">,</span><span class="s1">&quot;GlobalError&quot;</span><span class="s0">,</span><span class="s1">&quot;styles&quot;</span><span class="s0">,</span><span class="s1">&quot;globalErrorStyles&quot;</span><span class="s0">,</span><span class="s1">&quot;getGlobalErrorStyles&quot;</span><span class="s0">,</span><span class="s1">&quot;isPossiblyPartialHead&quot;</span><span class="s0">,</span><span class="s1">&quot;P&quot;</span><span class="s0">,</span><span class="s1">&quot;Preloads&quot;</span><span class="s0">,</span><span class="s1">&quot;p&quot;</span><span class="s0">,</span><span class="s1">&quot;assetPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;c&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;m&quot;</span><span class="s0">,</span><span class="s1">&quot;G&quot;</span><span class="s0">,</span><span class="s1">&quot;s&quot;</span><span class="s0">,</span><span class="s1">&quot;postponed&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;preloadFn&quot;</span><span class="s0">,</span><span class="s1">&quot;getErrorRSCPayload&quot;</span><span class="s0">,</span><span class="s1">&quot;ssrError&quot;</span><span class="s0">,</span><span class="s1">&quot;isError&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;html&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;head&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;template&quot;</span><span class="s0">,</span><span class="s1">&quot;data-next-error-message&quot;</span><span class="s0">,</span><span class="s1">&quot;message&quot;</span><span class="s0">,</span><span class="s1">&quot;data-next-error-digest&quot;</span><span class="s0">,</span><span class="s1">&quot;data-next-error-stack&quot;</span><span class="s0">,</span><span class="s1">&quot;stack&quot;</span><span class="s0">,</span><span class="s1">&quot;App&quot;</span><span class="s0">,</span><span class="s1">&quot;reactServerStream&quot;</span><span class="s0">,</span><span class="s1">&quot;preinitScripts&quot;</span><span class="s0">,</span><span class="s1">&quot;ServerInsertedHTMLProvider&quot;</span><span class="s0">,</span><span class="s1">&quot;use&quot;</span><span class="s0">,</span><span class="s1">&quot;useFlightStream&quot;</span><span class="s0">,</span><span class="s1">&quot;initialState&quot;</span><span class="s0">,</span><span class="s1">&quot;createInitialRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;navigatedAt&quot;</span><span class="s0">,</span><span class="s1">&quot;initialFlightData&quot;</span><span class="s0">,</span><span class="s1">&quot;initialCanonicalUrlParts&quot;</span><span class="s0">,</span><span class="s1">&quot;initialParallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;location&quot;</span><span class="s0">,</span><span class="s1">&quot;prerendered&quot;</span><span class="s0">,</span><span class="s1">&quot;actionQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;createMutableActionQueue&quot;</span><span class="s0">,</span><span class="s1">&quot;HeadManagerContext&quot;</span><span class="s0">,</span><span class="s1">&quot;Provider&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;appDir&quot;</span><span class="s0">,</span><span class="s1">&quot;AppRouter&quot;</span><span class="s0">,</span><span class="s1">&quot;globalErrorState&quot;</span><span class="s0">,</span><span class="s1">&quot;ErrorApp&quot;</span><span class="s0">,</span><span class="s1">&quot;renderToHTMLOrFlightImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;parsedRequestHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;postponedState&quot;</span><span class="s0">,</span><span class="s1">&quot;serverComponentsHmrCache&quot;</span><span class="s0">,</span><span class="s1">&quot;isNotFoundPath&quot;</span><span class="s0">,</span><span class="s1">&quot;requestTimestamp&quot;</span><span class="s0">,</span><span class="s1">&quot;Date&quot;</span><span class="s0">,</span><span class="s1">&quot;now&quot;</span><span class="s0">,</span><span class="s1">&quot;serverActionsManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;nextFontManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;serverActions&quot;</span><span class="s0">,</span><span class="s1">&quot;enableTainting&quot;</span><span class="s0">,</span><span class="s1">&quot;__next_app__&quot;</span><span class="s0">,</span><span class="s1">&quot;instrumented&quot;</span><span class="s0">,</span><span class="s1">&quot;wrapClientComponentLoader&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldTrackModuleLoading&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;workUnitStore&quot;</span><span class="s0">,</span><span class="s1">&quot;getStore&quot;</span><span class="s0">,</span><span class="s1">&quot;__next_require__&quot;</span><span class="s0">,</span><span class="s1">&quot;args&quot;</span><span class="s0">,</span><span class="s1">&quot;exportsOrPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;trackPendingImport&quot;</span><span class="s0">,</span><span class="s1">&quot;globalThis&quot;</span><span class="s0">,</span><span class="s1">&quot;__next_chunk_load__&quot;</span><span class="s0">,</span><span class="s1">&quot;loadingChunk&quot;</span><span class="s0">,</span><span class="s1">&quot;loadChunk&quot;</span><span class="s0">,</span><span class="s1">&quot;trackPendingChunkLoad&quot;</span><span class="s0">,</span><span class="s1">&quot;URL&quot;</span><span class="s0">,</span><span class="s1">&quot;setIsrStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_RUNTIME&quot;</span><span class="s0">,</span><span class="s1">&quot;isNodeNextRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;onClose&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldTrackFetchMetrics&quot;</span><span class="s0">,</span><span class="s1">&quot;originalRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;on&quot;</span><span class="s0">,</span><span class="s1">&quot;metrics&quot;</span><span class="s0">,</span><span class="s1">&quot;getClientComponentLoaderMetrics&quot;</span><span class="s0">,</span><span class="s1">&quot;reset&quot;</span><span class="s0">,</span><span class="s1">&quot;getTracer&quot;</span><span class="s0">,</span><span class="s1">&quot;startSpan&quot;</span><span class="s0">,</span><span class="s1">&quot;NextNodeServerSpan&quot;</span><span class="s0">,</span><span class="s1">&quot;clientComponentLoading&quot;</span><span class="s0">,</span><span class="s1">&quot;startTime&quot;</span><span class="s0">,</span><span class="s1">&quot;clientComponentLoadStart&quot;</span><span class="s0">,</span><span class="s1">&quot;attributes&quot;</span><span class="s0">,</span><span class="s1">&quot;clientComponentLoadCount&quot;</span><span class="s0">,</span><span class="s1">&quot;end&quot;</span><span class="s0">,</span><span class="s1">&quot;clientComponentLoadTimes&quot;</span><span class="s0">,</span><span class="s1">&quot;appUsingSizeAdjust&quot;</span><span class="s0">,</span><span class="s1">&quot;serverModuleMap&quot;</span><span class="s0">,</span><span class="s1">&quot;createServerModuleMap&quot;</span><span class="s0">,</span><span class="s1">&quot;setReferenceManifestsSingleton&quot;</span><span class="s0">,</span><span class="s1">&quot;patchFetch&quot;</span><span class="s0">,</span><span class="s1">&quot;taintObjectReference&quot;</span><span class="s0">,</span><span class="s1">&quot;stripInternalQueries&quot;</span><span class="s0">,</span><span class="s1">&quot;Buffer&quot;</span><span class="s0">,</span><span class="s1">&quot;from&quot;</span><span class="s0">,</span><span class="s1">&quot;crypto&quot;</span><span class="s0">,</span><span class="s1">&quot;subtle&quot;</span><span class="s0">,</span><span class="s1">&quot;toString&quot;</span><span class="s0">,</span><span class="s1">&quot;randomUUID&quot;</span><span class="s0">,</span><span class="s1">&quot;nanoid&quot;</span><span class="s0">,</span><span class="s1">&quot;isPossibleActionRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;getIsPossibleServerAction&quot;</span><span class="s0">,</span><span class="s1">&quot;getImplicitTags&quot;</span><span class="s0">,</span><span class="s1">&quot;isPrefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;setRootSpanAttribute&quot;</span><span class="s0">,</span><span class="s1">&quot;prerenderToStreamWithTracing&quot;</span><span class="s0">,</span><span class="s1">&quot;wrap&quot;</span><span class="s0">,</span><span class="s1">&quot;AppRenderSpan&quot;</span><span class="s0">,</span><span class="s1">&quot;getBodyResult&quot;</span><span class="s0">,</span><span class="s1">&quot;spanName&quot;</span><span class="s0">,</span><span class="s1">&quot;prerenderToStream&quot;</span><span class="s0">,</span><span class="s1">&quot;accessedDynamicData&quot;</span><span class="s0">,</span><span class="s1">&quot;warn&quot;</span><span class="s0">,</span><span class="s1">&quot;access&quot;</span><span class="s0">,</span><span class="s1">&quot;formatDynamicAPIAccesses&quot;</span><span class="s0">,</span><span class="s1">&quot;logDisallowedDynamicError&quot;</span><span class="s0">,</span><span class="s1">&quot;StaticGenBailoutError&quot;</span><span class="s0">,</span><span class="s1">&quot;digestErrorsMap&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">,</span><span class="s1">&quot;buildFailingError&quot;</span><span class="s0">,</span><span class="s1">&quot;values&quot;</span><span class="s0">,</span><span class="s1">&quot;next&quot;</span><span class="s0">,</span><span class="s1">&quot;ssrErrors&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;find&quot;</span><span class="s0">,</span><span class="s1">&quot;isUserLandError&quot;</span><span class="s0">,</span><span class="s1">&quot;contentType&quot;</span><span class="s0">,</span><span class="s1">&quot;HTML_CONTENT_TYPE_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingRevalidates&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingRevalidateWrites&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingRevalidatedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;executeRevalidates&quot;</span><span class="s0">,</span><span class="s1">&quot;finally&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_PRIVATE_DEBUG_CACHE&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;log&quot;</span><span class="s0">,</span><span class="s1">&quot;waitUntil&quot;</span><span class="s0">,</span><span class="s1">&quot;RenderResult&quot;</span><span class="s0">,</span><span class="s1">&quot;streamToString&quot;</span><span class="s0">,</span><span class="s1">&quot;stream&quot;</span><span class="s0">,</span><span class="s1">&quot;devValidatingFallbackParams&quot;</span><span class="s0">,</span><span class="s1">&quot;getRequestMeta&quot;</span><span class="s0">,</span><span class="s1">&quot;createRequestStoreForRender&quot;</span><span class="s0">,</span><span class="s1">&quot;onUpdateCookies&quot;</span><span class="s0">,</span><span class="s1">&quot;previewProps&quot;</span><span class="s0">,</span><span class="s1">&quot;usedDynamic&quot;</span><span class="s0">,</span><span class="s1">&quot;forceDynamic&quot;</span><span class="s0">,</span><span class="s1">&quot;renderToStreamWithTracing&quot;</span><span class="s0">,</span><span class="s1">&quot;renderToStream&quot;</span><span class="s0">,</span><span class="s1">&quot;formState&quot;</span><span class="s0">,</span><span class="s1">&quot;actionRequestResult&quot;</span><span class="s0">,</span><span class="s1">&quot;handleAction&quot;</span><span class="s0">,</span><span class="s1">&quot;generateFlight&quot;</span><span class="s0">,</span><span class="s1">&quot;notFoundLoaderTree&quot;</span><span class="s0">,</span><span class="s1">&quot;assignMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;parseRelativeUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;parsePostponedState&quot;</span><span class="s0">,</span><span class="s1">&quot;createWorkStore&quot;</span><span class="s0">,</span><span class="s1">&quot;routeModule&quot;</span><span class="s0">,</span><span class="s1">&quot;definition&quot;</span><span class="s0">,</span><span class="s1">&quot;workAsyncStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchTags&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;staleHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;String&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_ROUTER_STALE_TIME_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;forceStatic&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheControl&quot;</span><span class="s0">,</span><span class="s1">&quot;staticBailoutInfo&quot;</span><span class="s0">,</span><span class="s1">&quot;description&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicUsageDescription&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicUsageStack&quot;</span><span class="s0">,</span><span class="s1">&quot;basePath&quot;</span><span class="s0">,</span><span class="s1">&quot;buildManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;crossOrigin&quot;</span><span class="s0">,</span><span class="s1">&quot;nextExport&quot;</span><span class="s0">,</span><span class="s1">&quot;reactMaxHeadersLength&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldWaitOnAllReady&quot;</span><span class="s0">,</span><span class="s1">&quot;subresourceIntegrityManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;supportsDynamicResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;renderServerInsertedHTML&quot;</span><span class="s0">,</span><span class="s1">&quot;createServerInsertedHTML&quot;</span><span class="s0">,</span><span class="s1">&quot;getServerInsertedMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;createServerInsertedMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;tracingMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;getTracedMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;getTracePropagationData&quot;</span><span class="s0">,</span><span class="s1">&quot;clientTraceMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;polyfills&quot;</span><span class="s0">,</span><span class="s1">&quot;polyfillFiles&quot;</span><span class="s0">,</span><span class="s1">&quot;filter&quot;</span><span class="s0">,</span><span class="s1">&quot;polyfill&quot;</span><span class="s0">,</span><span class="s1">&quot;endsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;src&quot;</span><span class="s0">,</span><span class="s1">&quot;getAssetQueryString&quot;</span><span class="s0">,</span><span class="s1">&quot;integrity&quot;</span><span class="s0">,</span><span class="s1">&quot;noModule&quot;</span><span class="s0">,</span><span class="s1">&quot;bootstrapScript&quot;</span><span class="s0">,</span><span class="s1">&quot;getRequiredScripts&quot;</span><span class="s0">,</span><span class="s1">&quot;reactServerErrorsByDigest&quot;</span><span class="s0">,</span><span class="s1">&quot;silenceLogger&quot;</span><span class="s0">,</span><span class="s1">&quot;onHTMLRenderRSCError&quot;</span><span class="s0">,</span><span class="s1">&quot;serverComponentsErrorHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;createHTMLReactServerErrorHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;onHTMLRenderSSRError&quot;</span><span class="s0">,</span><span class="s1">&quot;allCapturedErrors&quot;</span><span class="s0">,</span><span class="s1">&quot;htmlRendererErrorHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;createHTMLErrorHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;reactServerResult&quot;</span><span class="s0">,</span><span class="s1">&quot;bind&quot;</span><span class="s0">,</span><span class="s1">&quot;appendHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveValidation&quot;</span><span class="s0">,</span><span class="s1">&quot;validationOutlet&quot;</span><span class="s0">,</span><span class="s1">&quot;createValidationOutlet&quot;</span><span class="s0">,</span><span class="s1">&quot;_validation&quot;</span><span class="s0">,</span><span class="s1">&quot;scheduleInSequentialTasks&quot;</span><span class="s0">,</span><span class="s1">&quot;prerenderPhase&quot;</span><span class="s0">,</span><span class="s1">&quot;environmentName&quot;</span><span class="s0">,</span><span class="s1">&quot;spawnDynamicValidationInDev&quot;</span><span class="s0">,</span><span class="s1">&quot;ReactServerResult&quot;</span><span class="s0">,</span><span class="s1">&quot;waitAtLeastOneReactRenderTask&quot;</span><span class="s0">,</span><span class="s1">&quot;DynamicState&quot;</span><span class="s0">,</span><span class="s1">&quot;DATA&quot;</span><span class="s0">,</span><span class="s1">&quot;inlinedReactServerDataStream&quot;</span><span class="s0">,</span><span class="s1">&quot;createInlinedDataReadableStream&quot;</span><span class="s0">,</span><span class="s1">&quot;tee&quot;</span><span class="s0">,</span><span class="s1">&quot;chainStreams&quot;</span><span class="s0">,</span><span class="s1">&quot;createDocumentClosingStream&quot;</span><span class="s0">,</span><span class="s1">&quot;preludeState&quot;</span><span class="s0">,</span><span class="s1">&quot;getPostponedFromState&quot;</span><span class="s0">,</span><span class="s1">&quot;resume&quot;</span><span class="s0">,</span><span class="s1">&quot;htmlStream&quot;</span><span class="s0">,</span><span class="s1">&quot;getServerInsertedHTML&quot;</span><span class="s0">,</span><span class="s1">&quot;makeGetServerInsertedHTML&quot;</span><span class="s0">,</span><span class="s1">&quot;serverCapturedErrors&quot;</span><span class="s0">,</span><span class="s1">&quot;continueDynamicHTMLResume&quot;</span><span class="s0">,</span><span class="s1">&quot;delayDataUntilFirstHtmlChunk&quot;</span><span class="s0">,</span><span class="s1">&quot;DynamicHTMLPreludeState&quot;</span><span class="s0">,</span><span class="s1">&quot;Empty&quot;</span><span class="s0">,</span><span class="s1">&quot;inlinedDataStream&quot;</span><span class="s0">,</span><span class="s1">&quot;consume&quot;</span><span class="s0">,</span><span class="s1">&quot;onHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;maxHeadersLength&quot;</span><span class="s0">,</span><span class="s1">&quot;bootstrapScripts&quot;</span><span class="s0">,</span><span class="s1">&quot;generateStaticHTML&quot;</span><span class="s0">,</span><span class="s1">&quot;continueFizzStream&quot;</span><span class="s0">,</span><span class="s1">&quot;isBuildTimePrerendering&quot;</span><span class="s0">,</span><span class="s1">&quot;validateRootLayout&quot;</span><span class="s0">,</span><span class="s1">&quot;isStaticGenBailoutError&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldBailoutToCSR&quot;</span><span class="s0">,</span><span class="s1">&quot;isBailoutToCSRError&quot;</span><span class="s0">,</span><span class="s1">&quot;getStackWithoutErrorMessage&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;reason&quot;</span><span class="s0">,</span><span class="s1">&quot;isHTTPAccessFallbackError&quot;</span><span class="s0">,</span><span class="s1">&quot;getAccessFallbackHTTPStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;getAccessFallbackErrorTypeByStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;isRedirectError&quot;</span><span class="s0">,</span><span class="s1">&quot;getRedirectStatusCodeFromError&quot;</span><span class="s0">,</span><span class="s1">&quot;redirectUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;addPathPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;getURLFromRedirectError&quot;</span><span class="s0">,</span><span class="s1">&quot;Headers&quot;</span><span class="s0">,</span><span class="s1">&quot;appendMutableCookies&quot;</span><span class="s0">,</span><span class="s1">&quot;mutableCookies&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;errorPreinitScripts&quot;</span><span class="s0">,</span><span class="s1">&quot;errorBootstrapScript&quot;</span><span class="s0">,</span><span class="s1">&quot;errorRSCPayload&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;errorServerStream&quot;</span><span class="s0">,</span><span class="s1">&quot;fizzStream&quot;</span><span class="s0">,</span><span class="s1">&quot;renderToInitialFizzStream&quot;</span><span class="s0">,</span><span class="s1">&quot;ReactDOMServer&quot;</span><span class="s0">,</span><span class="s1">&quot;element&quot;</span><span class="s0">,</span><span class="s1">&quot;streamOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;finalErr&quot;</span><span class="s0">,</span><span class="s1">&quot;bailOnRootNotFound&quot;</span><span class="s0">,</span><span class="s1">&quot;outlet&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;isNotFound&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;initialServerReactController&quot;</span><span class="s0">,</span><span class="s1">&quot;captureOwnerStackClient&quot;</span><span class="s0">,</span><span class="s1">&quot;captureOwnerStackServer&quot;</span><span class="s0">,</span><span class="s1">&quot;initialServerPayloadPrerenderStore&quot;</span><span class="s0">,</span><span class="s1">&quot;isReactLargeShellError&quot;</span><span class="s0">,</span><span class="s1">&quot;addEventListener&quot;</span><span class="s0">,</span><span class="s1">&quot;once&quot;</span><span class="s0">,</span><span class="s1">&quot;LogSafely&quot;</span><span class="s0">,</span><span class="s1">&quot;fn&quot;</span><span class="s0">,</span><span class="s1">&quot;initialServerResult&quot;</span><span class="s0">,</span><span class="s1">&quot;initialClientPrerenderController&quot;</span><span class="s0">,</span><span class="s1">&quot;initialClientReactController&quot;</span><span class="s0">,</span><span class="s1">&quot;initialClientRenderController&quot;</span><span class="s0">,</span><span class="s1">&quot;initialClientPrerenderStore&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingInitialClientResult&quot;</span><span class="s0">,</span><span class="s1">&quot;asUnclosingStream&quot;</span><span class="s0">,</span><span class="s1">&quot;catch&quot;</span><span class="s0">,</span><span class="s1">&quot;isPrerenderInterruptedError&quot;</span><span class="s0">,</span><span class="s1">&quot;finalServerReactController&quot;</span><span class="s0">,</span><span class="s1">&quot;finalServerRenderController&quot;</span><span class="s0">,</span><span class="s1">&quot;finalServerPayloadPrerenderStore&quot;</span><span class="s0">,</span><span class="s1">&quot;finalAttemptRSCPayload&quot;</span><span class="s0">,</span><span class="s1">&quot;prerenderAndAbortInSequentialTasks&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingPrerenderResult&quot;</span><span class="s0">,</span><span class="s1">&quot;clientDynamicTracking&quot;</span><span class="s0">,</span><span class="s1">&quot;finalClientReactController&quot;</span><span class="s0">,</span><span class="s1">&quot;finalClientRenderController&quot;</span><span class="s0">,</span><span class="s1">&quot;finalClientPrerenderStore&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicValidation&quot;</span><span class="s0">,</span><span class="s1">&quot;createDynamicValidationState&quot;</span><span class="s0">,</span><span class="s1">&quot;unprocessedPrelude&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingFinalClientResult&quot;</span><span class="s0">,</span><span class="s1">&quot;errorInfo&quot;</span><span class="s0">,</span><span class="s1">&quot;componentStack&quot;</span><span class="s0">,</span><span class="s1">&quot;trackAllowedDynamicAccess&quot;</span><span class="s0">,</span><span class="s1">&quot;preludeIsEmpty&quot;</span><span class="s0">,</span><span class="s1">&quot;processPrelude&quot;</span><span class="s0">,</span><span class="s1">&quot;throwIfDisallowedDynamic&quot;</span><span class="s0">,</span><span class="s1">&quot;PreludeState&quot;</span><span class="s0">,</span><span class="s1">&quot;Full&quot;</span><span class="s0">,</span><span class="s1">&quot;thrownValue&quot;</span><span class="s0">,</span><span class="s1">&quot;loggingFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;Errored&quot;</span><span class="s0">,</span><span class="s1">&quot;originalLoggingFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldGenerateStaticFlightData&quot;</span><span class="s0">,</span><span class="s1">&quot;reactServerPrerenderResult&quot;</span><span class="s0">,</span><span class="s1">&quot;setMetadataHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;item&quot;</span><span class="s0">,</span><span class="s1">&quot;resumeDataCache&quot;</span><span class="s0">,</span><span class="s1">&quot;streamToBuffer&quot;</span><span class="s0">,</span><span class="s1">&quot;asStream&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentData&quot;</span><span class="s0">,</span><span class="s1">&quot;collectSegmentData&quot;</span><span class="s0">,</span><span class="s1">&quot;hasFallbackRouteParams&quot;</span><span class="s0">,</span><span class="s1">&quot;getDynamicHTMLPostponedState&quot;</span><span class="s0">,</span><span class="s1">&quot;getDynamicDataPostponedState&quot;</span><span class="s0">,</span><span class="s1">&quot;continueDynamicPrerender&quot;</span><span class="s0">,</span><span class="s1">&quot;consumeDynamicAccess&quot;</span><span class="s0">,</span><span class="s1">&quot;foreverStream&quot;</span><span class="s0">,</span><span class="s1">&quot;ReadableStream&quot;</span><span class="s0">,</span><span class="s1">&quot;resumeStream&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON&quot;</span><span class="s0">,</span><span class="s1">&quot;parse&quot;</span><span class="s0">,</span><span class="s1">&quot;stringify&quot;</span><span class="s0">,</span><span class="s1">&quot;createRenderInBrowserAbortSignal&quot;</span><span class="s0">,</span><span class="s1">&quot;continueStaticPrerender&quot;</span><span class="s0">,</span><span class="s1">&quot;consumeAsStream&quot;</span><span class="s0">,</span><span class="s1">&quot;reactServerPrerenderStore&quot;</span><span class="s0">,</span><span class="s1">&quot;createReactServerPrerenderResultFromRender&quot;</span><span class="s0">,</span><span class="s1">&quot;ssrPrerenderStore&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicAccesses&quot;</span><span class="s0">,</span><span class="s1">&quot;prerenderLegacyStore&quot;</span><span class="s0">,</span><span class="s1">&quot;isDynamicServerError&quot;</span><span class="s0">,</span><span class="s1">&quot;flightStream&quot;</span><span class="s0">,</span><span class="s1">&quot;modules&quot;</span><span class="s0">,</span><span class="s1">&quot;globalErrorModule&quot;</span><span class="s0">,</span><span class="s1">&quot;parseLoaderTree&quot;</span><span class="s0">,</span><span class="s1">&quot;GlobalErrorComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;createComponentStylesAndScripts&quot;</span><span class="s0">,</span><span class="s1">&quot;filePath&quot;</span><span class="s0">,</span><span class="s1">&quot;getComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;dir&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_EDGE_PROJECT_DIR&quot;</span><span class="s0">,</span><span class="s1">&quot;globalErrorModulePath&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeConventionFilePath&quot;</span><span class="s0">,</span><span class="s1">&quot;devtoolSegmentExplorer&quot;</span><span class="s0">,</span><span class="s1">&quot;SegmentViewNode&quot;</span><span class="s0">,</span><span class="s1">&quot;staleTimes&quot;</span><span class="s0">,</span><span class="s1">&quot;static&quot;</span><span class="s0">,</span><span class="s1">&quot;fullPageDataBuffer&quot;</span><span class="s0">,</span><span class="s1">&quot;clientSegmentCache&quot;</span><span class="s0">,</span><span class="s1">&quot;isEdgeRuntime&quot;</span><span class="s0">,</span><span class="s1">&quot;serverConsumerManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;moduleLoading&quot;</span><span class="s0">,</span><span class="s1">&quot;moduleMap&quot;</span><span class="s0">,</span><span class="s1">&quot;edgeRscModuleMapping&quot;</span><span class="s0">,</span><span class="s1">&quot;rscModuleMapping&quot;</span><span class="s0">,</span><span class="s1">&quot;getServerModuleMap&quot;</span><span class="s0">,</span><span class="s1">&quot;staleTime&quot;</span><span class="s0">,</span><span class="s1">&quot;clientParamParsing&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>