<html>
<head>
<title>animate-elements.mjs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
animate-elements.mjs</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">{ resolveElements, getValueTransition, getAnimationMap, animationMapKey, getComputedStyle, fillWildcards, applyPxDefaults, NativeAnimation } from </span><span class="s2">'motion-dom'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ invariant, secondsToMilliseconds } from </span><span class="s2">'motion-utils'</span><span class="s1">;</span>

<span class="s0">function </span><span class="s1">animateElements(elementOrSelector, keyframes, options, scope) {</span>
    <span class="s0">const </span><span class="s1">elements = resolveElements(elementOrSelector, scope);</span>
    <span class="s0">const </span><span class="s1">numElements = elements.length;</span>
    <span class="s1">invariant(Boolean(numElements), </span><span class="s2">&quot;No valid elements provided.&quot;</span><span class="s1">, </span><span class="s2">&quot;no-valid-elements&quot;</span><span class="s1">);</span>
    <span class="s3">/**</span>
     <span class="s3">* WAAPI doesn't support interrupting animations.</span>
     <span class="s3">*</span>
     <span class="s3">* Therefore, starting animations requires a three-step process:</span>
     <span class="s3">* 1. Stop existing animations (write styles to DOM)</span>
     <span class="s3">* 2. Resolve keyframes (read styles from DOM)</span>
     <span class="s3">* 3. Create new animations (write styles to DOM)</span>
     <span class="s3">*</span>
     <span class="s3">* The hybrid `animate()` function uses AsyncAnimation to resolve</span>
     <span class="s3">* keyframes before creating new animations, which removes style</span>
     <span class="s3">* thrashing. Here, we have much stricter filesize constraints.</span>
     <span class="s3">* Therefore we do this in a synchronous way that ensures that</span>
     <span class="s3">* at least within `animate()` calls there is no style thrashing.</span>
     <span class="s3">*</span>
     <span class="s3">* In the motion-native-animate-mini-interrupt benchmark this</span>
     <span class="s3">* was 80% faster than a single loop.</span>
     <span class="s3">*/</span>
    <span class="s0">const </span><span class="s1">animationDefinitions = [];</span>
    <span class="s3">/**</span>
     <span class="s3">* Step 1: Build options and stop existing animations (write)</span>
     <span class="s3">*/</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; numElements; i++) {</span>
        <span class="s0">const </span><span class="s1">element = elements[i];</span>
        <span class="s0">const </span><span class="s1">elementTransition = { ...options };</span>
        <span class="s3">/**</span>
         <span class="s3">* Resolve stagger function if provided.</span>
         <span class="s3">*/</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">elementTransition.delay === </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
            <span class="s1">elementTransition.delay = elementTransition.delay(i, numElements);</span>
        <span class="s1">}</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">const </span><span class="s1">valueName </span><span class="s0">in </span><span class="s1">keyframes) {</span>
            <span class="s0">let </span><span class="s1">valueKeyframes = keyframes[valueName];</span>
            <span class="s0">if </span><span class="s1">(!Array.isArray(valueKeyframes)) {</span>
                <span class="s1">valueKeyframes = [valueKeyframes];</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">valueOptions = {</span>
                <span class="s1">...getValueTransition(elementTransition, valueName),</span>
            <span class="s1">};</span>
            <span class="s1">valueOptions.duration &amp;&amp; (valueOptions.duration = secondsToMilliseconds(valueOptions.duration));</span>
            <span class="s1">valueOptions.delay &amp;&amp; (valueOptions.delay = secondsToMilliseconds(valueOptions.delay));</span>
            <span class="s3">/**</span>
             <span class="s3">* If there's an existing animation playing on this element then stop it</span>
             <span class="s3">* before creating a new one.</span>
             <span class="s3">*/</span>
            <span class="s0">const </span><span class="s1">map = getAnimationMap(element);</span>
            <span class="s0">const </span><span class="s1">key = animationMapKey(valueName, valueOptions.pseudoElement || </span><span class="s2">&quot;&quot;</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">currentAnimation = map.get(key);</span>
            <span class="s1">currentAnimation &amp;&amp; currentAnimation.stop();</span>
            <span class="s1">animationDefinitions.push({</span>
                <span class="s1">map,</span>
                <span class="s1">key,</span>
                <span class="s1">unresolvedKeyframes: valueKeyframes,</span>
                <span class="s1">options: {</span>
                    <span class="s1">...valueOptions,</span>
                    <span class="s1">element,</span>
                    <span class="s1">name: valueName,</span>
                    <span class="s1">allowFlatten: !elementTransition.type &amp;&amp; !elementTransition.ease,</span>
                <span class="s1">},</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Step 2: Resolve keyframes (read)</span>
     <span class="s3">*/</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; animationDefinitions.length; i++) {</span>
        <span class="s0">const </span><span class="s1">{ unresolvedKeyframes, options: animationOptions } = animationDefinitions[i];</span>
        <span class="s0">const </span><span class="s1">{ element, name, pseudoElement } = animationOptions;</span>
        <span class="s0">if </span><span class="s1">(!pseudoElement &amp;&amp; unresolvedKeyframes[</span><span class="s4">0</span><span class="s1">] === </span><span class="s0">null</span><span class="s1">) {</span>
            <span class="s1">unresolvedKeyframes[</span><span class="s4">0</span><span class="s1">] = getComputedStyle(element, name);</span>
        <span class="s1">}</span>
        <span class="s1">fillWildcards(unresolvedKeyframes);</span>
        <span class="s1">applyPxDefaults(unresolvedKeyframes, name);</span>
        <span class="s3">/**</span>
         <span class="s3">* If we only have one keyframe, explicitly read the initial keyframe</span>
         <span class="s3">* from the computed style. This is to ensure consistency with WAAPI behaviour</span>
         <span class="s3">* for restarting animations, for instance .play() after finish, when it</span>
         <span class="s3">* has one vs two keyframes.</span>
         <span class="s3">*/</span>
        <span class="s0">if </span><span class="s1">(!pseudoElement &amp;&amp; unresolvedKeyframes.length &lt; </span><span class="s4">2</span><span class="s1">) {</span>
            <span class="s1">unresolvedKeyframes.unshift(getComputedStyle(element, name));</span>
        <span class="s1">}</span>
        <span class="s1">animationOptions.keyframes = unresolvedKeyframes;</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Step 3: Create new animations (write)</span>
     <span class="s3">*/</span>
    <span class="s0">const </span><span class="s1">animations = [];</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; animationDefinitions.length; i++) {</span>
        <span class="s0">const </span><span class="s1">{ map, key, options: animationOptions } = animationDefinitions[i];</span>
        <span class="s0">const </span><span class="s1">animation = </span><span class="s0">new </span><span class="s1">NativeAnimation(animationOptions);</span>
        <span class="s1">map.set(key, animation);</span>
        <span class="s1">animation.finished.finally(() =&gt; map.delete(key));</span>
        <span class="s1">animations.push(animation);</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">animations;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">{ animateElements };</span>
</pre>
</body>
</html>