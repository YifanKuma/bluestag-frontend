<html>
<head>
<title>motion-dom.dev.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #0033b3;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
.s5 { color: #264eff;}
.s6 { color: #8c8c8c; font-style: italic;}
.s7 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
motion-dom.dev.js</font>
</center></td></tr></table>
<pre><span class="s0">(</span><span class="s1">function </span><span class="s0">(global, factory) {</span>
    <span class="s1">typeof </span><span class="s0">exports === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">module !== </span><span class="s2">'undefined' </span><span class="s0">? factory(exports, require(</span><span class="s2">'motion-utils'</span><span class="s0">)) :</span>
    <span class="s1">typeof </span><span class="s0">define === </span><span class="s2">'function' </span><span class="s0">&amp;&amp; define.amd ? define([</span><span class="s2">'exports'</span><span class="s0">, </span><span class="s2">'motion-utils'</span><span class="s0">], factory) :</span>
    <span class="s0">(global = </span><span class="s1">typeof </span><span class="s0">globalThis !== </span><span class="s2">'undefined' </span><span class="s0">? globalThis : global || self, factory(global.MotionDom = {}, global.MotionUtils));</span>
<span class="s0">})(</span><span class="s1">this</span><span class="s0">, (</span><span class="s1">function </span><span class="s0">(exports, motionUtils) { </span><span class="s2">'use strict'</span><span class="s0">;</span>

    <span class="s1">const </span><span class="s0">stepsOrder = [</span>
        <span class="s2">&quot;setup&quot;</span><span class="s0">, </span><span class="s3">// Compute</span>
        <span class="s2">&quot;read&quot;</span><span class="s0">, </span><span class="s3">// Read</span>
        <span class="s2">&quot;resolveKeyframes&quot;</span><span class="s0">, </span><span class="s3">// Write/Read/Write/Read</span>
        <span class="s2">&quot;preUpdate&quot;</span><span class="s0">, </span><span class="s3">// Compute</span>
        <span class="s2">&quot;update&quot;</span><span class="s0">, </span><span class="s3">// Compute</span>
        <span class="s2">&quot;preRender&quot;</span><span class="s0">, </span><span class="s3">// Compute</span>
        <span class="s2">&quot;render&quot;</span><span class="s0">, </span><span class="s3">// Write</span>
        <span class="s2">&quot;postRender&quot;</span><span class="s0">, </span><span class="s3">// Compute</span>
    <span class="s0">];</span>

    <span class="s1">const </span><span class="s0">statsBuffer = {</span>
        <span class="s0">value: </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">addProjectionMetrics: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">};</span>

    <span class="s1">function </span><span class="s0">createRenderStep(runNextFrame, stepName) {</span>
        <span class="s3">/**</span>
         <span class="s3">* We create and reuse two queues, one to queue jobs for the current frame</span>
         <span class="s3">* and one for the next. We reuse to avoid triggering GC after x frames.</span>
         <span class="s3">*/</span>
        <span class="s1">let </span><span class="s0">thisFrame = </span><span class="s1">new </span><span class="s0">Set();</span>
        <span class="s1">let </span><span class="s0">nextFrame = </span><span class="s1">new </span><span class="s0">Set();</span>
        <span class="s3">/**</span>
         <span class="s3">* Track whether we're currently processing jobs in this step. This way</span>
         <span class="s3">* we can decide whether to schedule new jobs for this frame or next.</span>
         <span class="s3">*/</span>
        <span class="s1">let </span><span class="s0">isProcessing = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">flushNextFrame = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s3">/**</span>
         <span class="s3">* A set of processes which were marked keepAlive when scheduled.</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">toKeepAlive = </span><span class="s1">new </span><span class="s0">WeakSet();</span>
        <span class="s1">let </span><span class="s0">latestFrameData = {</span>
            <span class="s0">delta: </span><span class="s4">0.0</span><span class="s0">,</span>
            <span class="s0">timestamp: </span><span class="s4">0.0</span><span class="s0">,</span>
            <span class="s0">isProcessing: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">};</span>
        <span class="s1">let </span><span class="s0">numCalls = </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s1">function </span><span class="s0">triggerCallback(callback) {</span>
            <span class="s1">if </span><span class="s0">(toKeepAlive.has(callback)) {</span>
                <span class="s0">step.schedule(callback);</span>
                <span class="s0">runNextFrame();</span>
            <span class="s0">}</span>
            <span class="s0">numCalls++;</span>
            <span class="s0">callback(latestFrameData);</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">step = {</span>
            <span class="s3">/**</span>
             <span class="s3">* Schedule a process to run on the next frame.</span>
             <span class="s3">*/</span>
            <span class="s0">schedule: (callback, keepAlive = </span><span class="s1">false</span><span class="s0">, immediate = </span><span class="s1">false</span><span class="s0">) =&gt; {</span>
                <span class="s1">const </span><span class="s0">addToCurrentFrame = immediate &amp;&amp; isProcessing;</span>
                <span class="s1">const </span><span class="s0">queue = addToCurrentFrame ? thisFrame : nextFrame;</span>
                <span class="s1">if </span><span class="s0">(keepAlive)</span>
                    <span class="s0">toKeepAlive.add(callback);</span>
                <span class="s1">if </span><span class="s0">(!queue.has(callback))</span>
                    <span class="s0">queue.add(callback);</span>
                <span class="s1">return </span><span class="s0">callback;</span>
            <span class="s0">},</span>
            <span class="s3">/**</span>
             <span class="s3">* Cancel the provided callback from running on the next frame.</span>
             <span class="s3">*/</span>
            <span class="s0">cancel: (callback) =&gt; {</span>
                <span class="s0">nextFrame.delete(callback);</span>
                <span class="s0">toKeepAlive.delete(callback);</span>
            <span class="s0">},</span>
            <span class="s3">/**</span>
             <span class="s3">* Execute all schedule callbacks.</span>
             <span class="s3">*/</span>
            <span class="s0">process: (frameData) =&gt; {</span>
                <span class="s0">latestFrameData = frameData;</span>
                <span class="s3">/**</span>
                 <span class="s3">* If we're already processing we've probably been triggered by a flushSync</span>
                 <span class="s3">* inside an existing process. Instead of executing, mark flushNextFrame</span>
                 <span class="s3">* as true and ensure we flush the following frame at the end of this one.</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(isProcessing) {</span>
                    <span class="s0">flushNextFrame = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s0">isProcessing = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s0">[thisFrame, nextFrame] = [nextFrame, thisFrame];</span>
                <span class="s3">// Execute this frame</span>
                <span class="s0">thisFrame.forEach(triggerCallback);</span>
                <span class="s3">/**</span>
                 <span class="s3">* If we're recording stats then</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(stepName &amp;&amp; statsBuffer.value) {</span>
                    <span class="s0">statsBuffer.value.frameloop[stepName].push(numCalls);</span>
                <span class="s0">}</span>
                <span class="s0">numCalls = </span><span class="s4">0</span><span class="s0">;</span>
                <span class="s3">// Clear the frame so no callbacks remain. This is to avoid</span>
                <span class="s3">// memory leaks should this render step not run for a while.</span>
                <span class="s0">thisFrame.clear();</span>
                <span class="s0">isProcessing = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s1">if </span><span class="s0">(flushNextFrame) {</span>
                    <span class="s0">flushNextFrame = </span><span class="s1">false</span><span class="s0">;</span>
                    <span class="s0">step.process(frameData);</span>
                <span class="s0">}</span>
            <span class="s0">},</span>
        <span class="s0">};</span>
        <span class="s1">return </span><span class="s0">step;</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">maxElapsed = </span><span class="s4">40</span><span class="s0">;</span>
    <span class="s1">function </span><span class="s0">createRenderBatcher(scheduleNextBatch, allowKeepAlive) {</span>
        <span class="s1">let </span><span class="s0">runNextFrame = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">useDefaultElapsed = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">state = {</span>
            <span class="s0">delta: </span><span class="s4">0.0</span><span class="s0">,</span>
            <span class="s0">timestamp: </span><span class="s4">0.0</span><span class="s0">,</span>
            <span class="s0">isProcessing: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">};</span>
        <span class="s1">const </span><span class="s0">flagRunNextFrame = () =&gt; (runNextFrame = </span><span class="s1">true</span><span class="s0">);</span>
        <span class="s1">const </span><span class="s0">steps = stepsOrder.reduce((acc, key) =&gt; {</span>
            <span class="s0">acc[key] = createRenderStep(flagRunNextFrame, allowKeepAlive ? key : undefined);</span>
            <span class="s1">return </span><span class="s0">acc;</span>
        <span class="s0">}, {});</span>
        <span class="s1">const </span><span class="s0">{ setup, read, resolveKeyframes, preUpdate, update, preRender, render, postRender, } = steps;</span>
        <span class="s1">const </span><span class="s0">processBatch = () =&gt; {</span>
            <span class="s1">const </span><span class="s0">timestamp = motionUtils.MotionGlobalConfig.useManualTiming</span>
                <span class="s0">? state.timestamp</span>
                <span class="s0">: performance.now();</span>
            <span class="s0">runNextFrame = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(!motionUtils.MotionGlobalConfig.useManualTiming) {</span>
                <span class="s0">state.delta = useDefaultElapsed</span>
                    <span class="s0">? </span><span class="s4">1000 </span><span class="s0">/ </span><span class="s4">60</span>
                    <span class="s0">: Math.max(Math.min(timestamp - state.timestamp, maxElapsed), </span><span class="s4">1</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s0">state.timestamp = timestamp;</span>
            <span class="s0">state.isProcessing = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s3">// Unrolled render loop for better per-frame performance</span>
            <span class="s0">setup.process(state);</span>
            <span class="s0">read.process(state);</span>
            <span class="s0">resolveKeyframes.process(state);</span>
            <span class="s0">preUpdate.process(state);</span>
            <span class="s0">update.process(state);</span>
            <span class="s0">preRender.process(state);</span>
            <span class="s0">render.process(state);</span>
            <span class="s0">postRender.process(state);</span>
            <span class="s0">state.isProcessing = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(runNextFrame &amp;&amp; allowKeepAlive) {</span>
                <span class="s0">useDefaultElapsed = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s0">scheduleNextBatch(processBatch);</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
        <span class="s1">const </span><span class="s0">wake = () =&gt; {</span>
            <span class="s0">runNextFrame = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">useDefaultElapsed = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(!state.isProcessing) {</span>
                <span class="s0">scheduleNextBatch(processBatch);</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
        <span class="s1">const </span><span class="s0">schedule = stepsOrder.reduce((acc, key) =&gt; {</span>
            <span class="s1">const </span><span class="s0">step = steps[key];</span>
            <span class="s0">acc[key] = (process, keepAlive = </span><span class="s1">false</span><span class="s0">, immediate = </span><span class="s1">false</span><span class="s0">) =&gt; {</span>
                <span class="s1">if </span><span class="s0">(!runNextFrame)</span>
                    <span class="s0">wake();</span>
                <span class="s1">return </span><span class="s0">step.schedule(process, keepAlive, immediate);</span>
            <span class="s0">};</span>
            <span class="s1">return </span><span class="s0">acc;</span>
        <span class="s0">}, {});</span>
        <span class="s1">const </span><span class="s0">cancel = (process) =&gt; {</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; stepsOrder.length; i++) {</span>
                <span class="s0">steps[stepsOrder[i]].cancel(process);</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
        <span class="s1">return </span><span class="s0">{ schedule, cancel, state, steps };</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">{ schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps, } = </span><span class="s3">/* @__PURE__ */ </span><span class="s0">createRenderBatcher(</span><span class="s1">typeof </span><span class="s0">requestAnimationFrame !== </span><span class="s2">&quot;undefined&quot; </span><span class="s0">? requestAnimationFrame : motionUtils.noop, </span><span class="s1">true</span><span class="s0">);</span>

    <span class="s1">let </span><span class="s0">now;</span>
    <span class="s1">function </span><span class="s0">clearTime() {</span>
        <span class="s0">now = undefined;</span>
    <span class="s0">}</span>
    <span class="s3">/**</span>
     <span class="s3">* An eventloop-synchronous alternative to performance.now().</span>
     <span class="s3">*</span>
     <span class="s3">* Ensures that time measurements remain consistent within a synchronous context.</span>
     <span class="s3">* Usually calling performance.now() twice within the same synchronous context</span>
     <span class="s3">* will return different values which isn't useful for animations when we're usually</span>
     <span class="s3">* trying to sync animations to the same frame.</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">time = {</span>
        <span class="s0">now: () =&gt; {</span>
            <span class="s1">if </span><span class="s0">(now === undefined) {</span>
                <span class="s0">time.set(frameData.isProcessing || motionUtils.MotionGlobalConfig.useManualTiming</span>
                    <span class="s0">? frameData.timestamp</span>
                    <span class="s0">: performance.now());</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">now;</span>
        <span class="s0">},</span>
        <span class="s0">set: (newTime) =&gt; {</span>
            <span class="s0">now = newTime;</span>
            <span class="s0">queueMicrotask(clearTime);</span>
        <span class="s0">},</span>
    <span class="s0">};</span>

    <span class="s1">const </span><span class="s0">activeAnimations = {</span>
        <span class="s0">layout: </span><span class="s4">0</span><span class="s0">,</span>
        <span class="s0">mainThread: </span><span class="s4">0</span><span class="s0">,</span>
        <span class="s0">waapi: </span><span class="s4">0</span><span class="s0">,</span>
    <span class="s0">};</span>

    <span class="s1">const </span><span class="s0">checkStringStartsWith = (token) =&gt; (key) =&gt; </span><span class="s1">typeof </span><span class="s0">key === </span><span class="s2">&quot;string&quot; </span><span class="s0">&amp;&amp; key.startsWith(token);</span>
    <span class="s1">const </span><span class="s0">isCSSVariableName = </span>
    <span class="s3">/*@__PURE__*/ </span><span class="s0">checkStringStartsWith(</span><span class="s2">&quot;--&quot;</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">startsAsVariableToken = </span>
    <span class="s3">/*@__PURE__*/ </span><span class="s0">checkStringStartsWith(</span><span class="s2">&quot;var(--&quot;</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">isCSSVariableToken = (value) =&gt; {</span>
        <span class="s1">const </span><span class="s0">startsWithToken = startsAsVariableToken(value);</span>
        <span class="s1">if </span><span class="s0">(!startsWithToken)</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s3">// Ensure any comments are stripped from the value as this can harm performance of the regex.</span>
        <span class="s1">return </span><span class="s0">singleCssVariableRegex.test(value.split(</span><span class="s2">&quot;/*&quot;</span><span class="s0">)[</span><span class="s4">0</span><span class="s0">].trim());</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">singleCssVariableRegex = </span><span class="s5">/var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu</span><span class="s0">;</span>

    <span class="s1">const </span><span class="s0">number = {</span>
        <span class="s0">test: (v) =&gt; </span><span class="s1">typeof </span><span class="s0">v === </span><span class="s2">&quot;number&quot;</span><span class="s0">,</span>
        <span class="s0">parse: parseFloat,</span>
        <span class="s0">transform: (v) =&gt; v,</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">alpha = {</span>
        <span class="s0">...number,</span>
        <span class="s0">transform: (v) =&gt; motionUtils.clamp(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, v),</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">scale = {</span>
        <span class="s0">...number,</span>
        <span class="s1">default</span><span class="s0">: </span><span class="s4">1</span><span class="s0">,</span>
    <span class="s0">};</span>

    <span class="s3">// If this number is a decimal, make it just five decimal places</span>
    <span class="s3">// to avoid exponents</span>
    <span class="s1">const </span><span class="s0">sanitize = (v) =&gt; Math.round(v * </span><span class="s4">100000</span><span class="s0">) / </span><span class="s4">100000</span><span class="s0">;</span>

    <span class="s1">const </span><span class="s0">floatRegex = </span><span class="s5">/-?(?:\d+(?:\.\d+)?|\.\d+)/gu</span><span class="s0">;</span>

    <span class="s1">function </span><span class="s0">isNullish(v) {</span>
        <span class="s1">return </span><span class="s0">v == </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">singleColorRegex = </span><span class="s5">/^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu</span><span class="s0">;</span>

    <span class="s3">/**</span>
     <span class="s3">* Returns true if the provided string is a color, ie rgba(0,0,0,0) or #000,</span>
     <span class="s3">* but false if a number or multiple colors</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">isColorString = (type, testProp) =&gt; (v) =&gt; {</span>
        <span class="s1">return </span><span class="s0">Boolean((</span><span class="s1">typeof </span><span class="s0">v === </span><span class="s2">&quot;string&quot; </span><span class="s0">&amp;&amp;</span>
            <span class="s0">singleColorRegex.test(v) &amp;&amp;</span>
            <span class="s0">v.startsWith(type)) ||</span>
            <span class="s0">(testProp &amp;&amp;</span>
                <span class="s0">!isNullish(v) &amp;&amp;</span>
                <span class="s0">Object.prototype.hasOwnProperty.call(v, testProp)));</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">splitColor = (aName, bName, cName) =&gt; (v) =&gt; {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">v !== </span><span class="s2">&quot;string&quot;</span><span class="s0">)</span>
            <span class="s1">return </span><span class="s0">v;</span>
        <span class="s1">const </span><span class="s0">[a, b, c, alpha] = v.match(floatRegex);</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">[aName]: parseFloat(a),</span>
            <span class="s0">[bName]: parseFloat(b),</span>
            <span class="s0">[cName]: parseFloat(c),</span>
            <span class="s0">alpha: alpha !== undefined ? parseFloat(alpha) : </span><span class="s4">1</span><span class="s0">,</span>
        <span class="s0">};</span>
    <span class="s0">};</span>

    <span class="s1">const </span><span class="s0">clampRgbUnit = (v) =&gt; motionUtils.clamp(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">255</span><span class="s0">, v);</span>
    <span class="s1">const </span><span class="s0">rgbUnit = {</span>
        <span class="s0">...number,</span>
        <span class="s0">transform: (v) =&gt; Math.round(clampRgbUnit(v)),</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">rgba = {</span>
        <span class="s0">test: </span><span class="s3">/*@__PURE__*/ </span><span class="s0">isColorString(</span><span class="s2">&quot;rgb&quot;</span><span class="s0">, </span><span class="s2">&quot;red&quot;</span><span class="s0">),</span>
        <span class="s0">parse: </span><span class="s3">/*@__PURE__*/ </span><span class="s0">splitColor(</span><span class="s2">&quot;red&quot;</span><span class="s0">, </span><span class="s2">&quot;green&quot;</span><span class="s0">, </span><span class="s2">&quot;blue&quot;</span><span class="s0">),</span>
        <span class="s0">transform: ({ red, green, blue, alpha: alpha$1 = </span><span class="s4">1 </span><span class="s0">}) =&gt; </span><span class="s2">&quot;rgba(&quot; </span><span class="s0">+</span>
            <span class="s0">rgbUnit.transform(red) +</span>
            <span class="s2">&quot;, &quot; </span><span class="s0">+</span>
            <span class="s0">rgbUnit.transform(green) +</span>
            <span class="s2">&quot;, &quot; </span><span class="s0">+</span>
            <span class="s0">rgbUnit.transform(blue) +</span>
            <span class="s2">&quot;, &quot; </span><span class="s0">+</span>
            <span class="s0">sanitize(alpha.transform(alpha$1)) +</span>
            <span class="s2">&quot;)&quot;</span><span class="s0">,</span>
    <span class="s0">};</span>

    <span class="s1">function </span><span class="s0">parseHex(v) {</span>
        <span class="s1">let </span><span class="s0">r = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">g = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">b = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">a = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
        <span class="s3">// If we have 6 characters, ie #FF0000</span>
        <span class="s1">if </span><span class="s0">(v.length &gt; </span><span class="s4">5</span><span class="s0">) {</span>
            <span class="s0">r = v.substring(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s0">);</span>
            <span class="s0">g = v.substring(</span><span class="s4">3</span><span class="s0">, </span><span class="s4">5</span><span class="s0">);</span>
            <span class="s0">b = v.substring(</span><span class="s4">5</span><span class="s0">, </span><span class="s4">7</span><span class="s0">);</span>
            <span class="s0">a = v.substring(</span><span class="s4">7</span><span class="s0">, </span><span class="s4">9</span><span class="s0">);</span>
            <span class="s3">// Or we have 3 characters, ie #F00</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s0">r = v.substring(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">);</span>
            <span class="s0">g = v.substring(</span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">);</span>
            <span class="s0">b = v.substring(</span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s0">);</span>
            <span class="s0">a = v.substring(</span><span class="s4">4</span><span class="s0">, </span><span class="s4">5</span><span class="s0">);</span>
            <span class="s0">r += r;</span>
            <span class="s0">g += g;</span>
            <span class="s0">b += b;</span>
            <span class="s0">a += a;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">red: parseInt(r, </span><span class="s4">16</span><span class="s0">),</span>
            <span class="s0">green: parseInt(g, </span><span class="s4">16</span><span class="s0">),</span>
            <span class="s0">blue: parseInt(b, </span><span class="s4">16</span><span class="s0">),</span>
            <span class="s0">alpha: a ? parseInt(a, </span><span class="s4">16</span><span class="s0">) / </span><span class="s4">255 </span><span class="s0">: </span><span class="s4">1</span><span class="s0">,</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">hex = {</span>
        <span class="s0">test: </span><span class="s3">/*@__PURE__*/ </span><span class="s0">isColorString(</span><span class="s2">&quot;#&quot;</span><span class="s0">),</span>
        <span class="s0">parse: parseHex,</span>
        <span class="s0">transform: rgba.transform,</span>
    <span class="s0">};</span>

    <span class="s3">/*#__NO_SIDE_EFFECTS__*/</span>
    <span class="s1">const </span><span class="s0">createUnitType = (unit) =&gt; ({</span>
        <span class="s0">test: (v) =&gt; </span><span class="s1">typeof </span><span class="s0">v === </span><span class="s2">&quot;string&quot; </span><span class="s0">&amp;&amp; v.endsWith(unit) &amp;&amp; v.split(</span><span class="s2">&quot; &quot;</span><span class="s0">).length === </span><span class="s4">1</span><span class="s0">,</span>
        <span class="s0">parse: parseFloat,</span>
        <span class="s0">transform: (v) =&gt; </span><span class="s2">`</span><span class="s0">${v}${unit}</span><span class="s2">`</span><span class="s0">,</span>
    <span class="s0">});</span>
    <span class="s1">const </span><span class="s0">degrees = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">createUnitType(</span><span class="s2">&quot;deg&quot;</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">percent = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">createUnitType(</span><span class="s2">&quot;%&quot;</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">px = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">createUnitType(</span><span class="s2">&quot;px&quot;</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">vh = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">createUnitType(</span><span class="s2">&quot;vh&quot;</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">vw = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">createUnitType(</span><span class="s2">&quot;vw&quot;</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">progressPercentage = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">(() =&gt; ({</span>
        <span class="s0">...percent,</span>
        <span class="s0">parse: (v) =&gt; percent.parse(v) / </span><span class="s4">100</span><span class="s0">,</span>
        <span class="s0">transform: (v) =&gt; percent.transform(v * </span><span class="s4">100</span><span class="s0">),</span>
    <span class="s0">}))();</span>

    <span class="s1">const </span><span class="s0">hsla = {</span>
        <span class="s0">test: </span><span class="s3">/*@__PURE__*/ </span><span class="s0">isColorString(</span><span class="s2">&quot;hsl&quot;</span><span class="s0">, </span><span class="s2">&quot;hue&quot;</span><span class="s0">),</span>
        <span class="s0">parse: </span><span class="s3">/*@__PURE__*/ </span><span class="s0">splitColor(</span><span class="s2">&quot;hue&quot;</span><span class="s0">, </span><span class="s2">&quot;saturation&quot;</span><span class="s0">, </span><span class="s2">&quot;lightness&quot;</span><span class="s0">),</span>
        <span class="s0">transform: ({ hue, saturation, lightness, alpha: alpha$1 = </span><span class="s4">1 </span><span class="s0">}) =&gt; {</span>
            <span class="s1">return </span><span class="s0">(</span><span class="s2">&quot;hsla(&quot; </span><span class="s0">+</span>
                <span class="s0">Math.round(hue) +</span>
                <span class="s2">&quot;, &quot; </span><span class="s0">+</span>
                <span class="s0">percent.transform(sanitize(saturation)) +</span>
                <span class="s2">&quot;, &quot; </span><span class="s0">+</span>
                <span class="s0">percent.transform(sanitize(lightness)) +</span>
                <span class="s2">&quot;, &quot; </span><span class="s0">+</span>
                <span class="s0">sanitize(alpha.transform(alpha$1)) +</span>
                <span class="s2">&quot;)&quot;</span><span class="s0">);</span>
        <span class="s0">},</span>
    <span class="s0">};</span>

    <span class="s1">const </span><span class="s0">color = {</span>
        <span class="s0">test: (v) =&gt; rgba.test(v) || hex.test(v) || hsla.test(v),</span>
        <span class="s0">parse: (v) =&gt; {</span>
            <span class="s1">if </span><span class="s0">(rgba.test(v)) {</span>
                <span class="s1">return </span><span class="s0">rgba.parse(v);</span>
            <span class="s0">}</span>
            <span class="s1">else if </span><span class="s0">(hsla.test(v)) {</span>
                <span class="s1">return </span><span class="s0">hsla.parse(v);</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">return </span><span class="s0">hex.parse(v);</span>
            <span class="s0">}</span>
        <span class="s0">},</span>
        <span class="s0">transform: (v) =&gt; {</span>
            <span class="s1">return typeof </span><span class="s0">v === </span><span class="s2">&quot;string&quot;</span>
                <span class="s0">? v</span>
                <span class="s0">: v.hasOwnProperty(</span><span class="s2">&quot;red&quot;</span><span class="s0">)</span>
                    <span class="s0">? rgba.transform(v)</span>
                    <span class="s0">: hsla.transform(v);</span>
        <span class="s0">},</span>
        <span class="s0">getAnimatableNone: (v) =&gt; {</span>
            <span class="s1">const </span><span class="s0">parsed = color.parse(v);</span>
            <span class="s0">parsed.alpha = </span><span class="s4">0</span><span class="s0">;</span>
            <span class="s1">return </span><span class="s0">color.transform(parsed);</span>
        <span class="s0">},</span>
    <span class="s0">};</span>

    <span class="s1">const </span><span class="s0">colorRegex = </span><span class="s5">/(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu</span><span class="s0">;</span>

    <span class="s1">function </span><span class="s0">test(v) {</span>
        <span class="s1">return </span><span class="s0">(isNaN(v) &amp;&amp;</span>
            <span class="s1">typeof </span><span class="s0">v === </span><span class="s2">&quot;string&quot; </span><span class="s0">&amp;&amp;</span>
            <span class="s0">(v.match(floatRegex)?.length || </span><span class="s4">0</span><span class="s0">) +</span>
                <span class="s0">(v.match(colorRegex)?.length || </span><span class="s4">0</span><span class="s0">) &gt;</span>
                <span class="s4">0</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">NUMBER_TOKEN = </span><span class="s2">&quot;number&quot;</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">COLOR_TOKEN = </span><span class="s2">&quot;color&quot;</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">VAR_TOKEN = </span><span class="s2">&quot;var&quot;</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">VAR_FUNCTION_TOKEN = </span><span class="s2">&quot;var(&quot;</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">SPLIT_TOKEN = </span><span class="s2">&quot;${}&quot;</span><span class="s0">;</span>
    <span class="s3">// this regex consists of the `singleCssVariableRegex|rgbHSLValueRegex|digitRegex`</span>
    <span class="s1">const </span><span class="s0">complexRegex = </span><span class="s5">/var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu</span><span class="s0">;</span>
    <span class="s1">function </span><span class="s0">analyseComplexValue(value) {</span>
        <span class="s1">const </span><span class="s0">originalValue = value.toString();</span>
        <span class="s1">const </span><span class="s0">values = [];</span>
        <span class="s1">const </span><span class="s0">indexes = {</span>
            <span class="s0">color: [],</span>
            <span class="s0">number: [],</span>
            <span class="s1">var</span><span class="s0">: [],</span>
        <span class="s0">};</span>
        <span class="s1">const </span><span class="s0">types = [];</span>
        <span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">tokenised = originalValue.replace(complexRegex, (parsedValue) =&gt; {</span>
            <span class="s1">if </span><span class="s0">(color.test(parsedValue)) {</span>
                <span class="s0">indexes.color.push(i);</span>
                <span class="s0">types.push(COLOR_TOKEN);</span>
                <span class="s0">values.push(color.parse(parsedValue));</span>
            <span class="s0">}</span>
            <span class="s1">else if </span><span class="s0">(parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {</span>
                <span class="s0">indexes.var.push(i);</span>
                <span class="s0">types.push(VAR_TOKEN);</span>
                <span class="s0">values.push(parsedValue);</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s0">indexes.number.push(i);</span>
                <span class="s0">types.push(NUMBER_TOKEN);</span>
                <span class="s0">values.push(parseFloat(parsedValue));</span>
            <span class="s0">}</span>
            <span class="s0">++i;</span>
            <span class="s1">return </span><span class="s0">SPLIT_TOKEN;</span>
        <span class="s0">});</span>
        <span class="s1">const </span><span class="s0">split = tokenised.split(SPLIT_TOKEN);</span>
        <span class="s1">return </span><span class="s0">{ values, split, indexes, types };</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">parseComplexValue(v) {</span>
        <span class="s1">return </span><span class="s0">analyseComplexValue(v).values;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">createTransformer(source) {</span>
        <span class="s1">const </span><span class="s0">{ split, types } = analyseComplexValue(source);</span>
        <span class="s1">const </span><span class="s0">numSections = split.length;</span>
        <span class="s1">return </span><span class="s0">(v) =&gt; {</span>
            <span class="s1">let </span><span class="s0">output = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; numSections; i++) {</span>
                <span class="s0">output += split[i];</span>
                <span class="s1">if </span><span class="s0">(v[i] !== undefined) {</span>
                    <span class="s1">const </span><span class="s0">type = types[i];</span>
                    <span class="s1">if </span><span class="s0">(type === NUMBER_TOKEN) {</span>
                        <span class="s0">output += sanitize(v[i]);</span>
                    <span class="s0">}</span>
                    <span class="s1">else if </span><span class="s0">(type === COLOR_TOKEN) {</span>
                        <span class="s0">output += color.transform(v[i]);</span>
                    <span class="s0">}</span>
                    <span class="s1">else </span><span class="s0">{</span>
                        <span class="s0">output += v[i];</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">output;</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">convertNumbersToZero = (v) =&gt; </span><span class="s1">typeof </span><span class="s0">v === </span><span class="s2">&quot;number&quot; </span><span class="s0">? </span><span class="s4">0 </span><span class="s0">: color.test(v) ? color.getAnimatableNone(v) : v;</span>
    <span class="s1">function </span><span class="s0">getAnimatableNone$1(v) {</span>
        <span class="s1">const </span><span class="s0">parsed = parseComplexValue(v);</span>
        <span class="s1">const </span><span class="s0">transformer = createTransformer(v);</span>
        <span class="s1">return </span><span class="s0">transformer(parsed.map(convertNumbersToZero));</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">complex = {</span>
        <span class="s0">test,</span>
        <span class="s0">parse: parseComplexValue,</span>
        <span class="s0">createTransformer,</span>
        <span class="s0">getAnimatableNone: getAnimatableNone$1,</span>
    <span class="s0">};</span>

    <span class="s3">// Adapted from https://gist.github.com/mjackson/5311256</span>
    <span class="s1">function </span><span class="s0">hueToRgb(p, q, t) {</span>
        <span class="s1">if </span><span class="s0">(t &lt; </span><span class="s4">0</span><span class="s0">)</span>
            <span class="s0">t += </span><span class="s4">1</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(t &gt; </span><span class="s4">1</span><span class="s0">)</span>
            <span class="s0">t -= </span><span class="s4">1</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(t &lt; </span><span class="s4">1 </span><span class="s0">/ </span><span class="s4">6</span><span class="s0">)</span>
            <span class="s1">return </span><span class="s0">p + (q - p) * </span><span class="s4">6 </span><span class="s0">* t;</span>
        <span class="s1">if </span><span class="s0">(t &lt; </span><span class="s4">1 </span><span class="s0">/ </span><span class="s4">2</span><span class="s0">)</span>
            <span class="s1">return </span><span class="s0">q;</span>
        <span class="s1">if </span><span class="s0">(t &lt; </span><span class="s4">2 </span><span class="s0">/ </span><span class="s4">3</span><span class="s0">)</span>
            <span class="s1">return </span><span class="s0">p + (q - p) * (</span><span class="s4">2 </span><span class="s0">/ </span><span class="s4">3 </span><span class="s0">- t) * </span><span class="s4">6</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">p;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">hslaToRgba({ hue, saturation, lightness, alpha }) {</span>
        <span class="s0">hue /= </span><span class="s4">360</span><span class="s0">;</span>
        <span class="s0">saturation /= </span><span class="s4">100</span><span class="s0">;</span>
        <span class="s0">lightness /= </span><span class="s4">100</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">red = </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">green = </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">blue = </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(!saturation) {</span>
            <span class="s0">red = green = blue = lightness;</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s1">const </span><span class="s0">q = lightness &lt; </span><span class="s4">0.5</span>
                <span class="s0">? lightness * (</span><span class="s4">1 </span><span class="s0">+ saturation)</span>
                <span class="s0">: lightness + saturation - lightness * saturation;</span>
            <span class="s1">const </span><span class="s0">p = </span><span class="s4">2 </span><span class="s0">* lightness - q;</span>
            <span class="s0">red = hueToRgb(p, q, hue + </span><span class="s4">1 </span><span class="s0">/ </span><span class="s4">3</span><span class="s0">);</span>
            <span class="s0">green = hueToRgb(p, q, hue);</span>
            <span class="s0">blue = hueToRgb(p, q, hue - </span><span class="s4">1 </span><span class="s0">/ </span><span class="s4">3</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">red: Math.round(red * </span><span class="s4">255</span><span class="s0">),</span>
            <span class="s0">green: Math.round(green * </span><span class="s4">255</span><span class="s0">),</span>
            <span class="s0">blue: Math.round(blue * </span><span class="s4">255</span><span class="s0">),</span>
            <span class="s0">alpha,</span>
        <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">mixImmediate(a, b) {</span>
        <span class="s1">return </span><span class="s0">(p) =&gt; (p &gt; </span><span class="s4">0 </span><span class="s0">? b : a);</span>
    <span class="s0">}</span>

    <span class="s3">/* 
      Value in range from progress 
 
      Given a lower limit and an upper limit, we return the value within 
      that range as expressed by progress (usually a number from 0 to 1) 
 
      So progress = 0.5 would change 
 
      from -------- to 
 
      to 
 
      from ---- to 
 
      E.g. from = 10, to = 20, progress = 0.5 =&gt; 15 
 
      @param [number]: Lower limit of range 
      @param [number]: Upper limit of range 
      @param [number]: The progress between lower and upper limits expressed 0-1 
      @return [number]: Value as calculated from progress within range (not limited within range) 
    */</span>
    <span class="s1">const </span><span class="s0">mixNumber$1 = (from, to, progress) =&gt; {</span>
        <span class="s1">return </span><span class="s0">from + (to - from) * progress;</span>
    <span class="s0">};</span>

    <span class="s3">// Linear color space blending</span>
    <span class="s3">// Explained https://www.youtube.com/watch?v=LKnqECcg6Gw</span>
    <span class="s3">// Demonstrated http://codepen.io/osublake/pen/xGVVaN</span>
    <span class="s1">const </span><span class="s0">mixLinearColor = (from, to, v) =&gt; {</span>
        <span class="s1">const </span><span class="s0">fromExpo = from * from;</span>
        <span class="s1">const </span><span class="s0">expo = v * (to * to - fromExpo) + fromExpo;</span>
        <span class="s1">return </span><span class="s0">expo &lt; </span><span class="s4">0 </span><span class="s0">? </span><span class="s4">0 </span><span class="s0">: Math.sqrt(expo);</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">colorTypes = [hex, rgba, hsla];</span>
    <span class="s1">const </span><span class="s0">getColorType = (v) =&gt; colorTypes.find((type) =&gt; type.test(v));</span>
    <span class="s1">function </span><span class="s0">asRGBA(color) {</span>
        <span class="s1">const </span><span class="s0">type = getColorType(color);</span>
        <span class="s0">motionUtils.warning(Boolean(type), </span><span class="s2">`'</span><span class="s0">${color}</span><span class="s2">' is not an animatable color. Use the equivalent color code instead.`</span><span class="s0">, </span><span class="s2">&quot;color-not-animatable&quot;</span><span class="s0">);</span>
        <span class="s1">if </span><span class="s0">(!Boolean(type))</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">model = type.parse(color);</span>
        <span class="s1">if </span><span class="s0">(type === hsla) {</span>
            <span class="s3">// TODO Remove this cast - needed since Motion's stricter typing</span>
            <span class="s0">model = hslaToRgba(model);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">model;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">mixColor = (from, to) =&gt; {</span>
        <span class="s1">const </span><span class="s0">fromRGBA = asRGBA(from);</span>
        <span class="s1">const </span><span class="s0">toRGBA = asRGBA(to);</span>
        <span class="s1">if </span><span class="s0">(!fromRGBA || !toRGBA) {</span>
            <span class="s1">return </span><span class="s0">mixImmediate(from, to);</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">blended = { ...fromRGBA };</span>
        <span class="s1">return </span><span class="s0">(v) =&gt; {</span>
            <span class="s0">blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);</span>
            <span class="s0">blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);</span>
            <span class="s0">blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);</span>
            <span class="s0">blended.alpha = mixNumber$1(fromRGBA.alpha, toRGBA.alpha, v);</span>
            <span class="s1">return </span><span class="s0">rgba.transform(blended);</span>
        <span class="s0">};</span>
    <span class="s0">};</span>

    <span class="s1">const </span><span class="s0">invisibleValues = </span><span class="s1">new </span><span class="s0">Set([</span><span class="s2">&quot;none&quot;</span><span class="s0">, </span><span class="s2">&quot;hidden&quot;</span><span class="s0">]);</span>
    <span class="s3">/**</span>
     <span class="s3">* Returns a function that, when provided a progress value between 0 and 1,</span>
     <span class="s3">* will return the &quot;none&quot; or &quot;hidden&quot; string only when the progress is that of</span>
     <span class="s3">* the origin or target.</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">mixVisibility(origin, target) {</span>
        <span class="s1">if </span><span class="s0">(invisibleValues.has(origin)) {</span>
            <span class="s1">return </span><span class="s0">(p) =&gt; (p &lt;= </span><span class="s4">0 </span><span class="s0">? origin : target);</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s1">return </span><span class="s0">(p) =&gt; (p &gt;= </span><span class="s4">1 </span><span class="s0">? target : origin);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">mixNumber(a, b) {</span>
        <span class="s1">return </span><span class="s0">(p) =&gt; mixNumber$1(a, b, p);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">getMixer(a) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">a === </span><span class="s2">&quot;number&quot;</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">mixNumber;</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">a === </span><span class="s2">&quot;string&quot;</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">isCSSVariableToken(a)</span>
                <span class="s0">? mixImmediate</span>
                <span class="s0">: color.test(a)</span>
                    <span class="s0">? mixColor</span>
                    <span class="s0">: mixComplex;</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(Array.isArray(a)) {</span>
            <span class="s1">return </span><span class="s0">mixArray;</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">a === </span><span class="s2">&quot;object&quot;</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">color.test(a) ? mixColor : mixObject;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">mixImmediate;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">mixArray(a, b) {</span>
        <span class="s1">const </span><span class="s0">output = [...a];</span>
        <span class="s1">const </span><span class="s0">numValues = output.length;</span>
        <span class="s1">const </span><span class="s0">blendValue = a.map((v, i) =&gt; getMixer(v)(v, b[i]));</span>
        <span class="s1">return </span><span class="s0">(p) =&gt; {</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; numValues; i++) {</span>
                <span class="s0">output[i] = blendValue[i](p);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">output;</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">mixObject(a, b) {</span>
        <span class="s1">const </span><span class="s0">output = { ...a, ...b };</span>
        <span class="s1">const </span><span class="s0">blendValue = {};</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in </span><span class="s0">output) {</span>
            <span class="s1">if </span><span class="s0">(a[key] !== undefined &amp;&amp; b[key] !== undefined) {</span>
                <span class="s0">blendValue[key] = getMixer(a[key])(a[key], b[key]);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">(v) =&gt; {</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in </span><span class="s0">blendValue) {</span>
                <span class="s0">output[key] = blendValue[key](v);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">output;</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">matchOrder(origin, target) {</span>
        <span class="s1">const </span><span class="s0">orderedOrigin = [];</span>
        <span class="s1">const </span><span class="s0">pointers = { color: </span><span class="s4">0</span><span class="s0">, </span><span class="s1">var</span><span class="s0">: </span><span class="s4">0</span><span class="s0">, number: </span><span class="s4">0 </span><span class="s0">};</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; target.values.length; i++) {</span>
            <span class="s1">const </span><span class="s0">type = target.types[i];</span>
            <span class="s1">const </span><span class="s0">originIndex = origin.indexes[type][pointers[type]];</span>
            <span class="s1">const </span><span class="s0">originValue = origin.values[originIndex] ?? </span><span class="s4">0</span><span class="s0">;</span>
            <span class="s0">orderedOrigin[i] = originValue;</span>
            <span class="s0">pointers[type]++;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">orderedOrigin;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">mixComplex = (origin, target) =&gt; {</span>
        <span class="s1">const </span><span class="s0">template = complex.createTransformer(target);</span>
        <span class="s1">const </span><span class="s0">originStats = analyseComplexValue(origin);</span>
        <span class="s1">const </span><span class="s0">targetStats = analyseComplexValue(target);</span>
        <span class="s1">const </span><span class="s0">canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length &amp;&amp;</span>
            <span class="s0">originStats.indexes.color.length === targetStats.indexes.color.length &amp;&amp;</span>
            <span class="s0">originStats.indexes.number.length &gt;= targetStats.indexes.number.length;</span>
        <span class="s1">if </span><span class="s0">(canInterpolate) {</span>
            <span class="s1">if </span><span class="s0">((invisibleValues.has(origin) &amp;&amp;</span>
                <span class="s0">!targetStats.values.length) ||</span>
                <span class="s0">(invisibleValues.has(target) &amp;&amp;</span>
                    <span class="s0">!originStats.values.length)) {</span>
                <span class="s1">return </span><span class="s0">mixVisibility(origin, target);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">motionUtils.pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s0">motionUtils.warning(</span><span class="s1">true</span><span class="s0">, </span><span class="s2">`Complex values '</span><span class="s0">${origin}</span><span class="s2">' and '</span><span class="s0">${target}</span><span class="s2">' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`</span><span class="s0">, </span><span class="s2">&quot;complex-values-different&quot;</span><span class="s0">);</span>
            <span class="s1">return </span><span class="s0">mixImmediate(origin, target);</span>
        <span class="s0">}</span>
    <span class="s0">};</span>

    <span class="s1">function </span><span class="s0">mix(from, to, p) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">from === </span><span class="s2">&quot;number&quot; </span><span class="s0">&amp;&amp;</span>
            <span class="s1">typeof </span><span class="s0">to === </span><span class="s2">&quot;number&quot; </span><span class="s0">&amp;&amp;</span>
            <span class="s1">typeof </span><span class="s0">p === </span><span class="s2">&quot;number&quot;</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">mixNumber$1(from, to, p);</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">mixer = getMixer(from);</span>
        <span class="s1">return </span><span class="s0">mixer(from, to);</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">frameloopDriver = (update) =&gt; {</span>
        <span class="s1">const </span><span class="s0">passTimestamp = ({ timestamp }) =&gt; update(timestamp);</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">start: (keepAlive = </span><span class="s1">true</span><span class="s0">) =&gt; frame.update(passTimestamp, keepAlive),</span>
            <span class="s0">stop: () =&gt; cancelFrame(passTimestamp),</span>
            <span class="s3">/**</span>
             <span class="s3">* If we're processing this frame we can use the</span>
             <span class="s3">* framelocked timestamp to keep things in sync.</span>
             <span class="s3">*/</span>
            <span class="s0">now: () =&gt; (frameData.isProcessing ? frameData.timestamp : time.now()),</span>
        <span class="s0">};</span>
    <span class="s0">};</span>

    <span class="s1">const </span><span class="s0">generateLinearEasing = (easing, duration, </span><span class="s3">// as milliseconds</span>
    <span class="s0">resolution = </span><span class="s4">10 </span><span class="s3">// as milliseconds</span>
    <span class="s0">) =&gt; {</span>
        <span class="s1">let </span><span class="s0">points = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">numPoints = Math.max(Math.round(duration / resolution), </span><span class="s4">2</span><span class="s0">);</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; numPoints; i++) {</span>
            <span class="s0">points += Math.round(easing(i / (numPoints - </span><span class="s4">1</span><span class="s0">)) * </span><span class="s4">10000</span><span class="s0">) / </span><span class="s4">10000 </span><span class="s0">+ </span><span class="s2">&quot;, &quot;</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s2">`linear(</span><span class="s0">${points.substring(</span><span class="s4">0</span><span class="s0">, points.length - </span><span class="s4">2</span><span class="s0">)}</span><span class="s2">)`</span><span class="s0">;</span>
    <span class="s0">};</span>

    <span class="s3">/**</span>
     <span class="s3">* Implement a practical max duration for keyframe generation</span>
     <span class="s3">* to prevent infinite loops</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">maxGeneratorDuration = </span><span class="s4">20000</span><span class="s0">;</span>
    <span class="s1">function </span><span class="s0">calcGeneratorDuration(generator) {</span>
        <span class="s1">let </span><span class="s0">duration = </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">timeStep = </span><span class="s4">50</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">state = generator.next(duration);</span>
        <span class="s1">while </span><span class="s0">(!state.done &amp;&amp; duration &lt; maxGeneratorDuration) {</span>
            <span class="s0">duration += timeStep;</span>
            <span class="s0">state = generator.next(duration);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">duration &gt;= maxGeneratorDuration ? Infinity : duration;</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Create a progress =&gt; progress easing function from a generator.</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">createGeneratorEasing(options, scale = </span><span class="s4">100</span><span class="s0">, createGenerator) {</span>
        <span class="s1">const </span><span class="s0">generator = createGenerator({ ...options, keyframes: [</span><span class="s4">0</span><span class="s0">, scale] });</span>
        <span class="s1">const </span><span class="s0">duration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">type: </span><span class="s2">&quot;keyframes&quot;</span><span class="s0">,</span>
            <span class="s0">ease: (progress) =&gt; {</span>
                <span class="s1">return </span><span class="s0">generator.next(duration * progress).value / scale;</span>
            <span class="s0">},</span>
            <span class="s0">duration: motionUtils.millisecondsToSeconds(duration),</span>
        <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">velocitySampleDuration = </span><span class="s4">5</span><span class="s0">; </span><span class="s3">// ms</span>
    <span class="s1">function </span><span class="s0">calcGeneratorVelocity(resolveValue, t, current) {</span>
        <span class="s1">const </span><span class="s0">prevT = Math.max(t - velocitySampleDuration, </span><span class="s4">0</span><span class="s0">);</span>
        <span class="s1">return </span><span class="s0">motionUtils.velocityPerSecond(current - resolveValue(prevT), t - prevT);</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">springDefaults = {</span>
        <span class="s3">// Default spring physics</span>
        <span class="s0">stiffness: </span><span class="s4">100</span><span class="s0">,</span>
        <span class="s0">damping: </span><span class="s4">10</span><span class="s0">,</span>
        <span class="s0">mass: </span><span class="s4">1.0</span><span class="s0">,</span>
        <span class="s0">velocity: </span><span class="s4">0.0</span><span class="s0">,</span>
        <span class="s3">// Default duration/bounce-based options</span>
        <span class="s0">duration: </span><span class="s4">800</span><span class="s0">, </span><span class="s3">// in ms</span>
        <span class="s0">bounce: </span><span class="s4">0.3</span><span class="s0">,</span>
        <span class="s0">visualDuration: </span><span class="s4">0.3</span><span class="s0">, </span><span class="s3">// in seconds</span>
        <span class="s3">// Rest thresholds</span>
        <span class="s0">restSpeed: {</span>
            <span class="s0">granular: </span><span class="s4">0.01</span><span class="s0">,</span>
            <span class="s1">default</span><span class="s0">: </span><span class="s4">2</span><span class="s0">,</span>
        <span class="s0">},</span>
        <span class="s0">restDelta: {</span>
            <span class="s0">granular: </span><span class="s4">0.005</span><span class="s0">,</span>
            <span class="s1">default</span><span class="s0">: </span><span class="s4">0.5</span><span class="s0">,</span>
        <span class="s0">},</span>
        <span class="s3">// Limits</span>
        <span class="s0">minDuration: </span><span class="s4">0.01</span><span class="s0">, </span><span class="s3">// in seconds</span>
        <span class="s0">maxDuration: </span><span class="s4">10.0</span><span class="s0">, </span><span class="s3">// in seconds</span>
        <span class="s0">minDamping: </span><span class="s4">0.05</span><span class="s0">,</span>
        <span class="s0">maxDamping: </span><span class="s4">1</span><span class="s0">,</span>
    <span class="s0">};</span>

    <span class="s1">const </span><span class="s0">safeMin = </span><span class="s4">0.001</span><span class="s0">;</span>
    <span class="s1">function </span><span class="s0">findSpring({ duration = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass, }) {</span>
        <span class="s1">let </span><span class="s0">envelope;</span>
        <span class="s1">let </span><span class="s0">derivative;</span>
        <span class="s0">motionUtils.warning(duration &lt;= motionUtils.secondsToMilliseconds(springDefaults.maxDuration), </span><span class="s2">&quot;Spring duration must be 10 seconds or less&quot;</span><span class="s0">, </span><span class="s2">&quot;spring-duration-limit&quot;</span><span class="s0">);</span>
        <span class="s1">let </span><span class="s0">dampingRatio = </span><span class="s4">1 </span><span class="s0">- bounce;</span>
        <span class="s3">/**</span>
         <span class="s3">* Restrict dampingRatio and duration to within acceptable ranges.</span>
         <span class="s3">*/</span>
        <span class="s0">dampingRatio = motionUtils.clamp(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);</span>
        <span class="s0">duration = motionUtils.clamp(springDefaults.minDuration, springDefaults.maxDuration, motionUtils.millisecondsToSeconds(duration));</span>
        <span class="s1">if </span><span class="s0">(dampingRatio &lt; </span><span class="s4">1</span><span class="s0">) {</span>
            <span class="s3">/**</span>
             <span class="s3">* Underdamped spring</span>
             <span class="s3">*/</span>
            <span class="s0">envelope = (undampedFreq) =&gt; {</span>
                <span class="s1">const </span><span class="s0">exponentialDecay = undampedFreq * dampingRatio;</span>
                <span class="s1">const </span><span class="s0">delta = exponentialDecay * duration;</span>
                <span class="s1">const </span><span class="s0">a = exponentialDecay - velocity;</span>
                <span class="s1">const </span><span class="s0">b = calcAngularFreq(undampedFreq, dampingRatio);</span>
                <span class="s1">const </span><span class="s0">c = Math.exp(-delta);</span>
                <span class="s1">return </span><span class="s0">safeMin - (a / b) * c;</span>
            <span class="s0">};</span>
            <span class="s0">derivative = (undampedFreq) =&gt; {</span>
                <span class="s1">const </span><span class="s0">exponentialDecay = undampedFreq * dampingRatio;</span>
                <span class="s1">const </span><span class="s0">delta = exponentialDecay * duration;</span>
                <span class="s1">const </span><span class="s0">d = delta * velocity + velocity;</span>
                <span class="s1">const </span><span class="s0">e = Math.pow(dampingRatio, </span><span class="s4">2</span><span class="s0">) * Math.pow(undampedFreq, </span><span class="s4">2</span><span class="s0">) * duration;</span>
                <span class="s1">const </span><span class="s0">f = Math.exp(-delta);</span>
                <span class="s1">const </span><span class="s0">g = calcAngularFreq(Math.pow(undampedFreq, </span><span class="s4">2</span><span class="s0">), dampingRatio);</span>
                <span class="s1">const </span><span class="s0">factor = -envelope(undampedFreq) + safeMin &gt; </span><span class="s4">0 </span><span class="s0">? -</span><span class="s4">1 </span><span class="s0">: </span><span class="s4">1</span><span class="s0">;</span>
                <span class="s1">return </span><span class="s0">(factor * ((d - e) * f)) / g;</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s3">/**</span>
             <span class="s3">* Critically-damped spring</span>
             <span class="s3">*/</span>
            <span class="s0">envelope = (undampedFreq) =&gt; {</span>
                <span class="s1">const </span><span class="s0">a = Math.exp(-undampedFreq * duration);</span>
                <span class="s1">const </span><span class="s0">b = (undampedFreq - velocity) * duration + </span><span class="s4">1</span><span class="s0">;</span>
                <span class="s1">return </span><span class="s0">-safeMin + a * b;</span>
            <span class="s0">};</span>
            <span class="s0">derivative = (undampedFreq) =&gt; {</span>
                <span class="s1">const </span><span class="s0">a = Math.exp(-undampedFreq * duration);</span>
                <span class="s1">const </span><span class="s0">b = (velocity - undampedFreq) * (duration * duration);</span>
                <span class="s1">return </span><span class="s0">a * b;</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">initialGuess = </span><span class="s4">5 </span><span class="s0">/ duration;</span>
        <span class="s1">const </span><span class="s0">undampedFreq = approximateRoot(envelope, derivative, initialGuess);</span>
        <span class="s0">duration = motionUtils.secondsToMilliseconds(duration);</span>
        <span class="s1">if </span><span class="s0">(isNaN(undampedFreq)) {</span>
            <span class="s1">return </span><span class="s0">{</span>
                <span class="s0">stiffness: springDefaults.stiffness,</span>
                <span class="s0">damping: springDefaults.damping,</span>
                <span class="s0">duration,</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s1">const </span><span class="s0">stiffness = Math.pow(undampedFreq, </span><span class="s4">2</span><span class="s0">) * mass;</span>
            <span class="s1">return </span><span class="s0">{</span>
                <span class="s0">stiffness,</span>
                <span class="s0">damping: dampingRatio * </span><span class="s4">2 </span><span class="s0">* Math.sqrt(mass * stiffness),</span>
                <span class="s0">duration,</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">rootIterations = </span><span class="s4">12</span><span class="s0">;</span>
    <span class="s1">function </span><span class="s0">approximateRoot(envelope, derivative, initialGuess) {</span>
        <span class="s1">let </span><span class="s0">result = initialGuess;</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">1</span><span class="s0">; i &lt; rootIterations; i++) {</span>
            <span class="s0">result = result - envelope(result) / derivative(result);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">result;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">calcAngularFreq(undampedFreq, dampingRatio) {</span>
        <span class="s1">return </span><span class="s0">undampedFreq * Math.sqrt(</span><span class="s4">1 </span><span class="s0">- dampingRatio * dampingRatio);</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">durationKeys = [</span><span class="s2">&quot;duration&quot;</span><span class="s0">, </span><span class="s2">&quot;bounce&quot;</span><span class="s0">];</span>
    <span class="s1">const </span><span class="s0">physicsKeys = [</span><span class="s2">&quot;stiffness&quot;</span><span class="s0">, </span><span class="s2">&quot;damping&quot;</span><span class="s0">, </span><span class="s2">&quot;mass&quot;</span><span class="s0">];</span>
    <span class="s1">function </span><span class="s0">isSpringType(options, keys) {</span>
        <span class="s1">return </span><span class="s0">keys.some((key) =&gt; options[key] !== undefined);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">getSpringOptions(options) {</span>
        <span class="s1">let </span><span class="s0">springOptions = {</span>
            <span class="s0">velocity: springDefaults.velocity,</span>
            <span class="s0">stiffness: springDefaults.stiffness,</span>
            <span class="s0">damping: springDefaults.damping,</span>
            <span class="s0">mass: springDefaults.mass,</span>
            <span class="s0">isResolvedFromDuration: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">...options,</span>
        <span class="s0">};</span>
        <span class="s3">// stiffness/damping/mass overrides duration/bounce</span>
        <span class="s1">if </span><span class="s0">(!isSpringType(options, physicsKeys) &amp;&amp;</span>
            <span class="s0">isSpringType(options, durationKeys)) {</span>
            <span class="s1">if </span><span class="s0">(options.visualDuration) {</span>
                <span class="s1">const </span><span class="s0">visualDuration = options.visualDuration;</span>
                <span class="s1">const </span><span class="s0">root = (</span><span class="s4">2 </span><span class="s0">* Math.PI) / (visualDuration * </span><span class="s4">1.2</span><span class="s0">);</span>
                <span class="s1">const </span><span class="s0">stiffness = root * root;</span>
                <span class="s1">const </span><span class="s0">damping = </span><span class="s4">2 </span><span class="s0">*</span>
                    <span class="s0">motionUtils.clamp(</span><span class="s4">0.05</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1 </span><span class="s0">- (options.bounce || </span><span class="s4">0</span><span class="s0">)) *</span>
                    <span class="s0">Math.sqrt(stiffness);</span>
                <span class="s0">springOptions = {</span>
                    <span class="s0">...springOptions,</span>
                    <span class="s0">mass: springDefaults.mass,</span>
                    <span class="s0">stiffness,</span>
                    <span class="s0">damping,</span>
                <span class="s0">};</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">const </span><span class="s0">derived = findSpring(options);</span>
                <span class="s0">springOptions = {</span>
                    <span class="s0">...springOptions,</span>
                    <span class="s0">...derived,</span>
                    <span class="s0">mass: springDefaults.mass,</span>
                <span class="s0">};</span>
                <span class="s0">springOptions.isResolvedFromDuration = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">springOptions;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {</span>
        <span class="s1">const </span><span class="s0">options = </span><span class="s1">typeof </span><span class="s0">optionsOrVisualDuration !== </span><span class="s2">&quot;object&quot;</span>
            <span class="s0">? {</span>
                <span class="s0">visualDuration: optionsOrVisualDuration,</span>
                <span class="s0">keyframes: [</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">],</span>
                <span class="s0">bounce,</span>
            <span class="s0">}</span>
            <span class="s0">: optionsOrVisualDuration;</span>
        <span class="s1">let </span><span class="s0">{ restSpeed, restDelta } = options;</span>
        <span class="s1">const </span><span class="s0">origin = options.keyframes[</span><span class="s4">0</span><span class="s0">];</span>
        <span class="s1">const </span><span class="s0">target = options.keyframes[options.keyframes.length - </span><span class="s4">1</span><span class="s0">];</span>
        <span class="s3">/**</span>
         <span class="s3">* This is the Iterator-spec return value. We ensure it's mutable rather than using a generator</span>
         <span class="s3">* to reduce GC during animation.</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">state = { done: </span><span class="s1">false</span><span class="s0">, value: origin };</span>
        <span class="s1">const </span><span class="s0">{ stiffness, damping, mass, duration, velocity, isResolvedFromDuration, } = getSpringOptions({</span>
            <span class="s0">...options,</span>
            <span class="s0">velocity: -motionUtils.millisecondsToSeconds(options.velocity || </span><span class="s4">0</span><span class="s0">),</span>
        <span class="s0">});</span>
        <span class="s1">const </span><span class="s0">initialVelocity = velocity || </span><span class="s4">0.0</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">dampingRatio = damping / (</span><span class="s4">2 </span><span class="s0">* Math.sqrt(stiffness * mass));</span>
        <span class="s1">const </span><span class="s0">initialDelta = target - origin;</span>
        <span class="s1">const </span><span class="s0">undampedAngularFreq = motionUtils.millisecondsToSeconds(Math.sqrt(stiffness / mass));</span>
        <span class="s3">/**</span>
         <span class="s3">* If we're working on a granular scale, use smaller defaults for determining</span>
         <span class="s3">* when the spring is finished.</span>
         <span class="s3">*</span>
         <span class="s3">* These defaults have been selected emprically based on what strikes a good</span>
         <span class="s3">* ratio between feeling good and finishing as soon as changes are imperceptible.</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">isGranularScale = Math.abs(initialDelta) &lt; </span><span class="s4">5</span><span class="s0">;</span>
        <span class="s0">restSpeed || (restSpeed = isGranularScale</span>
            <span class="s0">? springDefaults.restSpeed.granular</span>
            <span class="s0">: springDefaults.restSpeed.default);</span>
        <span class="s0">restDelta || (restDelta = isGranularScale</span>
            <span class="s0">? springDefaults.restDelta.granular</span>
            <span class="s0">: springDefaults.restDelta.default);</span>
        <span class="s1">let </span><span class="s0">resolveSpring;</span>
        <span class="s1">if </span><span class="s0">(dampingRatio &lt; </span><span class="s4">1</span><span class="s0">) {</span>
            <span class="s1">const </span><span class="s0">angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);</span>
            <span class="s3">// Underdamped spring</span>
            <span class="s0">resolveSpring = (t) =&gt; {</span>
                <span class="s1">const </span><span class="s0">envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);</span>
                <span class="s1">return </span><span class="s0">(target -</span>
                    <span class="s0">envelope *</span>
                        <span class="s0">(((initialVelocity +</span>
                            <span class="s0">dampingRatio * undampedAngularFreq * initialDelta) /</span>
                            <span class="s0">angularFreq) *</span>
                            <span class="s0">Math.sin(angularFreq * t) +</span>
                            <span class="s0">initialDelta * Math.cos(angularFreq * t)));</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(dampingRatio === </span><span class="s4">1</span><span class="s0">) {</span>
            <span class="s3">// Critically damped spring</span>
            <span class="s0">resolveSpring = (t) =&gt; target -</span>
                <span class="s0">Math.exp(-undampedAngularFreq * t) *</span>
                    <span class="s0">(initialDelta +</span>
                        <span class="s0">(initialVelocity + undampedAngularFreq * initialDelta) * t);</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s3">// Overdamped spring</span>
            <span class="s1">const </span><span class="s0">dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - </span><span class="s4">1</span><span class="s0">);</span>
            <span class="s0">resolveSpring = (t) =&gt; {</span>
                <span class="s1">const </span><span class="s0">envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);</span>
                <span class="s3">// When performing sinh or cosh values can hit Infinity so we cap them here</span>
                <span class="s1">const </span><span class="s0">freqForT = Math.min(dampedAngularFreq * t, </span><span class="s4">300</span><span class="s0">);</span>
                <span class="s1">return </span><span class="s0">(target -</span>
                    <span class="s0">(envelope *</span>
                        <span class="s0">((initialVelocity +</span>
                            <span class="s0">dampingRatio * undampedAngularFreq * initialDelta) *</span>
                            <span class="s0">Math.sinh(freqForT) +</span>
                            <span class="s0">dampedAngularFreq *</span>
                                <span class="s0">initialDelta *</span>
                                <span class="s0">Math.cosh(freqForT))) /</span>
                        <span class="s0">dampedAngularFreq);</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">generator = {</span>
            <span class="s0">calculatedDuration: isResolvedFromDuration ? duration || </span><span class="s1">null </span><span class="s0">: </span><span class="s1">null</span><span class="s0">,</span>
            <span class="s0">next: (t) =&gt; {</span>
                <span class="s1">const </span><span class="s0">current = resolveSpring(t);</span>
                <span class="s1">if </span><span class="s0">(!isResolvedFromDuration) {</span>
                    <span class="s1">let </span><span class="s0">currentVelocity = t === </span><span class="s4">0 </span><span class="s0">? initialVelocity : </span><span class="s4">0.0</span><span class="s0">;</span>
                    <span class="s3">/**</span>
                     <span class="s3">* We only need to calculate velocity for under-damped springs</span>
                     <span class="s3">* as over- and critically-damped springs can't overshoot, so</span>
                     <span class="s3">* checking only for displacement is enough.</span>
                     <span class="s3">*/</span>
                    <span class="s1">if </span><span class="s0">(dampingRatio &lt; </span><span class="s4">1</span><span class="s0">) {</span>
                        <span class="s0">currentVelocity =</span>
                            <span class="s0">t === </span><span class="s4">0</span>
                                <span class="s0">? motionUtils.secondsToMilliseconds(initialVelocity)</span>
                                <span class="s0">: calcGeneratorVelocity(resolveSpring, t, current);</span>
                    <span class="s0">}</span>
                    <span class="s1">const </span><span class="s0">isBelowVelocityThreshold = Math.abs(currentVelocity) &lt;= restSpeed;</span>
                    <span class="s1">const </span><span class="s0">isBelowDisplacementThreshold = Math.abs(target - current) &lt;= restDelta;</span>
                    <span class="s0">state.done =</span>
                        <span class="s0">isBelowVelocityThreshold &amp;&amp; isBelowDisplacementThreshold;</span>
                <span class="s0">}</span>
                <span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">state.done = t &gt;= duration;</span>
                <span class="s0">}</span>
                <span class="s0">state.value = state.done ? target : current;</span>
                <span class="s1">return </span><span class="s0">state;</span>
            <span class="s0">},</span>
            <span class="s0">toString: () =&gt; {</span>
                <span class="s1">const </span><span class="s0">calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);</span>
                <span class="s1">const </span><span class="s0">easing = generateLinearEasing((progress) =&gt; generator.next(calculatedDuration * progress).value, calculatedDuration, </span><span class="s4">30</span><span class="s0">);</span>
                <span class="s1">return </span><span class="s0">calculatedDuration + </span><span class="s2">&quot;ms &quot; </span><span class="s0">+ easing;</span>
            <span class="s0">},</span>
            <span class="s0">toTransition: () =&gt; { },</span>
        <span class="s0">};</span>
        <span class="s1">return </span><span class="s0">generator;</span>
    <span class="s0">}</span>
    <span class="s0">spring.applyToOptions = (options) =&gt; {</span>
        <span class="s1">const </span><span class="s0">generatorOptions = createGeneratorEasing(options, </span><span class="s4">100</span><span class="s0">, spring);</span>
        <span class="s0">options.ease = generatorOptions.ease;</span>
        <span class="s0">options.duration = motionUtils.secondsToMilliseconds(generatorOptions.duration);</span>
        <span class="s0">options.type = </span><span class="s2">&quot;keyframes&quot;</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">options;</span>
    <span class="s0">};</span>

    <span class="s1">function </span><span class="s0">inertia({ keyframes, velocity = </span><span class="s4">0.0</span><span class="s0">, power = </span><span class="s4">0.8</span><span class="s0">, timeConstant = </span><span class="s4">325</span><span class="s0">, bounceDamping = </span><span class="s4">10</span><span class="s0">, bounceStiffness = </span><span class="s4">500</span><span class="s0">, modifyTarget, min, max, restDelta = </span><span class="s4">0.5</span><span class="s0">, restSpeed, }) {</span>
        <span class="s1">const </span><span class="s0">origin = keyframes[</span><span class="s4">0</span><span class="s0">];</span>
        <span class="s1">const </span><span class="s0">state = {</span>
            <span class="s0">done: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">value: origin,</span>
        <span class="s0">};</span>
        <span class="s1">const </span><span class="s0">isOutOfBounds = (v) =&gt; (min !== undefined &amp;&amp; v &lt; min) || (max !== undefined &amp;&amp; v &gt; max);</span>
        <span class="s1">const </span><span class="s0">nearestBoundary = (v) =&gt; {</span>
            <span class="s1">if </span><span class="s0">(min === undefined)</span>
                <span class="s1">return </span><span class="s0">max;</span>
            <span class="s1">if </span><span class="s0">(max === undefined)</span>
                <span class="s1">return </span><span class="s0">min;</span>
            <span class="s1">return </span><span class="s0">Math.abs(min - v) &lt; Math.abs(max - v) ? min : max;</span>
        <span class="s0">};</span>
        <span class="s1">let </span><span class="s0">amplitude = power * velocity;</span>
        <span class="s1">const </span><span class="s0">ideal = origin + amplitude;</span>
        <span class="s1">const </span><span class="s0">target = modifyTarget === undefined ? ideal : modifyTarget(ideal);</span>
        <span class="s3">/**</span>
         <span class="s3">* If the target has changed we need to re-calculate the amplitude, otherwise</span>
         <span class="s3">* the animation will start from the wrong position.</span>
         <span class="s3">*/</span>
        <span class="s1">if </span><span class="s0">(target !== ideal)</span>
            <span class="s0">amplitude = target - origin;</span>
        <span class="s1">const </span><span class="s0">calcDelta = (t) =&gt; -amplitude * Math.exp(-t / timeConstant);</span>
        <span class="s1">const </span><span class="s0">calcLatest = (t) =&gt; target + calcDelta(t);</span>
        <span class="s1">const </span><span class="s0">applyFriction = (t) =&gt; {</span>
            <span class="s1">const </span><span class="s0">delta = calcDelta(t);</span>
            <span class="s1">const </span><span class="s0">latest = calcLatest(t);</span>
            <span class="s0">state.done = Math.abs(delta) &lt;= restDelta;</span>
            <span class="s0">state.value = state.done ? target : latest;</span>
        <span class="s0">};</span>
        <span class="s3">/**</span>
         <span class="s3">* Ideally this would resolve for t in a stateless way, we could</span>
         <span class="s3">* do that by always precalculating the animation but as we know</span>
         <span class="s3">* this will be done anyway we can assume that spring will</span>
         <span class="s3">* be discovered during that.</span>
         <span class="s3">*/</span>
        <span class="s1">let </span><span class="s0">timeReachedBoundary;</span>
        <span class="s1">let </span><span class="s0">spring$1;</span>
        <span class="s1">const </span><span class="s0">checkCatchBoundary = (t) =&gt; {</span>
            <span class="s1">if </span><span class="s0">(!isOutOfBounds(state.value))</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s0">timeReachedBoundary = t;</span>
            <span class="s0">spring$1 = spring({</span>
                <span class="s0">keyframes: [state.value, nearestBoundary(state.value)],</span>
                <span class="s0">velocity: calcGeneratorVelocity(calcLatest, t, state.value), </span><span class="s3">// TODO: This should be passing * 1000</span>
                <span class="s0">damping: bounceDamping,</span>
                <span class="s0">stiffness: bounceStiffness,</span>
                <span class="s0">restDelta,</span>
                <span class="s0">restSpeed,</span>
            <span class="s0">});</span>
        <span class="s0">};</span>
        <span class="s0">checkCatchBoundary(</span><span class="s4">0</span><span class="s0">);</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">calculatedDuration: </span><span class="s1">null</span><span class="s0">,</span>
            <span class="s0">next: (t) =&gt; {</span>
                <span class="s3">/**</span>
                 <span class="s3">* We need to resolve the friction to figure out if we need a</span>
                 <span class="s3">* spring but we don't want to do this twice per frame. So here</span>
                 <span class="s3">* we flag if we updated for this frame and later if we did</span>
                 <span class="s3">* we can skip doing it again.</span>
                 <span class="s3">*/</span>
                <span class="s1">let </span><span class="s0">hasUpdatedFrame = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s1">if </span><span class="s0">(!spring$1 &amp;&amp; timeReachedBoundary === undefined) {</span>
                    <span class="s0">hasUpdatedFrame = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s0">applyFriction(t);</span>
                    <span class="s0">checkCatchBoundary(t);</span>
                <span class="s0">}</span>
                <span class="s3">/**</span>
                 <span class="s3">* If we have a spring and the provided t is beyond the moment the friction</span>
                 <span class="s3">* animation crossed the min/max boundary, use the spring.</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(timeReachedBoundary !== undefined &amp;&amp; t &gt;= timeReachedBoundary) {</span>
                    <span class="s1">return </span><span class="s0">spring$1.next(t - timeReachedBoundary);</span>
                <span class="s0">}</span>
                <span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">!hasUpdatedFrame &amp;&amp; applyFriction(t);</span>
                    <span class="s1">return </span><span class="s0">state;</span>
                <span class="s0">}</span>
            <span class="s0">},</span>
        <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">createMixers(output, ease, customMixer) {</span>
        <span class="s1">const </span><span class="s0">mixers = [];</span>
        <span class="s1">const </span><span class="s0">mixerFactory = customMixer || motionUtils.MotionGlobalConfig.mix || mix;</span>
        <span class="s1">const </span><span class="s0">numMixers = output.length - </span><span class="s4">1</span><span class="s0">;</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; numMixers; i++) {</span>
            <span class="s1">let </span><span class="s0">mixer = mixerFactory(output[i], output[i + </span><span class="s4">1</span><span class="s0">]);</span>
            <span class="s1">if </span><span class="s0">(ease) {</span>
                <span class="s1">const </span><span class="s0">easingFunction = Array.isArray(ease) ? ease[i] || motionUtils.noop : ease;</span>
                <span class="s0">mixer = motionUtils.pipe(easingFunction, mixer);</span>
            <span class="s0">}</span>
            <span class="s0">mixers.push(mixer);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">mixers;</span>
    <span class="s0">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Create a function that maps from a numerical input array to a generic output array.</span>
     <span class="s3">*</span>
     <span class="s3">* Accepts:</span>
     <span class="s3">*   - Numbers</span>
     <span class="s3">*   - Colors (hex, hsl, hsla, rgb, rgba)</span>
     <span class="s3">*   - Complex (combinations of one or more numbers or strings)</span>
     <span class="s3">*</span>
     <span class="s3">* ```jsx</span>
     <span class="s3">* const mixColor = interpolate([0, 1], ['#fff', '#000'])</span>
     <span class="s3">*</span>
     <span class="s3">* mixColor(0.5) // 'rgba(128, 128, 128, 1)'</span>
     <span class="s3">* ```</span>
     <span class="s3">*</span>
     <span class="s3">* TODO Revisit this approach once we've moved to data models for values,</span>
     <span class="s3">* probably not needed to pregenerate mixer functions.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s6">@public</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">interpolate(input, output, { clamp: isClamp = </span><span class="s1">true</span><span class="s0">, ease, mixer } = {}) {</span>
        <span class="s1">const </span><span class="s0">inputLength = input.length;</span>
        <span class="s0">motionUtils.invariant(inputLength === output.length, </span><span class="s2">&quot;Both input and output ranges must be the same length&quot;</span><span class="s0">, </span><span class="s2">&quot;range-length&quot;</span><span class="s0">);</span>
        <span class="s3">/**</span>
         <span class="s3">* If we're only provided a single input, we can just make a function</span>
         <span class="s3">* that returns the output.</span>
         <span class="s3">*/</span>
        <span class="s1">if </span><span class="s0">(inputLength === </span><span class="s4">1</span><span class="s0">)</span>
            <span class="s1">return </span><span class="s0">() =&gt; output[</span><span class="s4">0</span><span class="s0">];</span>
        <span class="s1">if </span><span class="s0">(inputLength === </span><span class="s4">2 </span><span class="s0">&amp;&amp; output[</span><span class="s4">0</span><span class="s0">] === output[</span><span class="s4">1</span><span class="s0">])</span>
            <span class="s1">return </span><span class="s0">() =&gt; output[</span><span class="s4">1</span><span class="s0">];</span>
        <span class="s1">const </span><span class="s0">isZeroDeltaRange = input[</span><span class="s4">0</span><span class="s0">] === input[</span><span class="s4">1</span><span class="s0">];</span>
        <span class="s3">// If input runs highest -&gt; lowest, reverse both arrays</span>
        <span class="s1">if </span><span class="s0">(input[</span><span class="s4">0</span><span class="s0">] &gt; input[inputLength - </span><span class="s4">1</span><span class="s0">]) {</span>
            <span class="s0">input = [...input].reverse();</span>
            <span class="s0">output = [...output].reverse();</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">mixers = createMixers(output, ease, mixer);</span>
        <span class="s1">const </span><span class="s0">numMixers = mixers.length;</span>
        <span class="s1">const </span><span class="s0">interpolator = (v) =&gt; {</span>
            <span class="s1">if </span><span class="s0">(isZeroDeltaRange &amp;&amp; v &lt; input[</span><span class="s4">0</span><span class="s0">])</span>
                <span class="s1">return </span><span class="s0">output[</span><span class="s4">0</span><span class="s0">];</span>
            <span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(numMixers &gt; </span><span class="s4">1</span><span class="s0">) {</span>
                <span class="s1">for </span><span class="s0">(; i &lt; input.length - </span><span class="s4">2</span><span class="s0">; i++) {</span>
                    <span class="s1">if </span><span class="s0">(v &lt; input[i + </span><span class="s4">1</span><span class="s0">])</span>
                        <span class="s1">break</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">progressInRange = motionUtils.progress(input[i], input[i + </span><span class="s4">1</span><span class="s0">], v);</span>
            <span class="s1">return </span><span class="s0">mixers[i](progressInRange);</span>
        <span class="s0">};</span>
        <span class="s1">return </span><span class="s0">isClamp</span>
            <span class="s0">? (v) =&gt; interpolator(motionUtils.clamp(input[</span><span class="s4">0</span><span class="s0">], input[inputLength - </span><span class="s4">1</span><span class="s0">], v))</span>
            <span class="s0">: interpolator;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">fillOffset(offset, remaining) {</span>
        <span class="s1">const </span><span class="s0">min = offset[offset.length - </span><span class="s4">1</span><span class="s0">];</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">1</span><span class="s0">; i &lt;= remaining; i++) {</span>
            <span class="s1">const </span><span class="s0">offsetProgress = motionUtils.progress(</span><span class="s4">0</span><span class="s0">, remaining, i);</span>
            <span class="s0">offset.push(mixNumber$1(min, </span><span class="s4">1</span><span class="s0">, offsetProgress));</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">defaultOffset(arr) {</span>
        <span class="s1">const </span><span class="s0">offset = [</span><span class="s4">0</span><span class="s0">];</span>
        <span class="s0">fillOffset(offset, arr.length - </span><span class="s4">1</span><span class="s0">);</span>
        <span class="s1">return </span><span class="s0">offset;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">convertOffsetToTimes(offset, duration) {</span>
        <span class="s1">return </span><span class="s0">offset.map((o) =&gt; o * duration);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">defaultEasing(values, easing) {</span>
        <span class="s1">return </span><span class="s0">values.map(() =&gt; easing || motionUtils.easeInOut).splice(</span><span class="s4">0</span><span class="s0">, values.length - </span><span class="s4">1</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">keyframes({ duration = </span><span class="s4">300</span><span class="s0">, keyframes: keyframeValues, times, ease = </span><span class="s2">&quot;easeInOut&quot;</span><span class="s0">, }) {</span>
        <span class="s3">/**</span>
         <span class="s3">* Easing functions can be externally defined as strings. Here we convert them</span>
         <span class="s3">* into actual functions.</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">easingFunctions = motionUtils.isEasingArray(ease)</span>
            <span class="s0">? ease.map(motionUtils.easingDefinitionToFunction)</span>
            <span class="s0">: motionUtils.easingDefinitionToFunction(ease);</span>
        <span class="s3">/**</span>
         <span class="s3">* This is the Iterator-spec return value. We ensure it's mutable rather than using a generator</span>
         <span class="s3">* to reduce GC during animation.</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">state = {</span>
            <span class="s0">done: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">value: keyframeValues[</span><span class="s4">0</span><span class="s0">],</span>
        <span class="s0">};</span>
        <span class="s3">/**</span>
         <span class="s3">* Create a times array based on the provided 0-1 offsets</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">absoluteTimes = convertOffsetToTimes(</span>
        <span class="s3">// Only use the provided offsets if they're the correct length</span>
        <span class="s3">// TODO Maybe we should warn here if there's a length mismatch</span>
        <span class="s0">times &amp;&amp; times.length === keyframeValues.length</span>
            <span class="s0">? times</span>
            <span class="s0">: defaultOffset(keyframeValues), duration);</span>
        <span class="s1">const </span><span class="s0">mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {</span>
            <span class="s0">ease: Array.isArray(easingFunctions)</span>
                <span class="s0">? easingFunctions</span>
                <span class="s0">: defaultEasing(keyframeValues, easingFunctions),</span>
        <span class="s0">});</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">calculatedDuration: duration,</span>
            <span class="s0">next: (t) =&gt; {</span>
                <span class="s0">state.value = mapTimeToKeyframe(t);</span>
                <span class="s0">state.done = t &gt;= duration;</span>
                <span class="s1">return </span><span class="s0">state;</span>
            <span class="s0">},</span>
        <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">isNotNull = (value) =&gt; value !== </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s1">function </span><span class="s0">getFinalKeyframe(keyframes, { repeat, repeatType = </span><span class="s2">&quot;loop&quot; </span><span class="s0">}, finalKeyframe, speed = </span><span class="s4">1</span><span class="s0">) {</span>
        <span class="s1">const </span><span class="s0">resolvedKeyframes = keyframes.filter(isNotNull);</span>
        <span class="s1">const </span><span class="s0">useFirstKeyframe = speed &lt; </span><span class="s4">0 </span><span class="s0">|| (repeat &amp;&amp; repeatType !== </span><span class="s2">&quot;loop&quot; </span><span class="s0">&amp;&amp; repeat % </span><span class="s4">2 </span><span class="s0">=== </span><span class="s4">1</span><span class="s0">);</span>
        <span class="s1">const </span><span class="s0">index = useFirstKeyframe ? </span><span class="s4">0 </span><span class="s0">: resolvedKeyframes.length - </span><span class="s4">1</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">!index || finalKeyframe === undefined</span>
            <span class="s0">? resolvedKeyframes[index]</span>
            <span class="s0">: finalKeyframe;</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">transitionTypeMap = {</span>
        <span class="s0">decay: inertia,</span>
        <span class="s0">inertia,</span>
        <span class="s0">tween: keyframes,</span>
        <span class="s0">keyframes: keyframes,</span>
        <span class="s0">spring,</span>
    <span class="s0">};</span>
    <span class="s1">function </span><span class="s0">replaceTransitionType(transition) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">transition.type === </span><span class="s2">&quot;string&quot;</span><span class="s0">) {</span>
            <span class="s0">transition.type = transitionTypeMap[transition.type];</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">class </span><span class="s0">WithPromise {</span>
        <span class="s0">constructor() {</span>
            <span class="s1">this</span><span class="s0">.updateFinished();</span>
        <span class="s0">}</span>
        <span class="s0">get finished() {</span>
            <span class="s1">return this</span><span class="s0">._finished;</span>
        <span class="s0">}</span>
        <span class="s0">updateFinished() {</span>
            <span class="s1">this</span><span class="s0">._finished = </span><span class="s1">new </span><span class="s0">Promise((resolve) =&gt; {</span>
                <span class="s1">this</span><span class="s0">.resolve = resolve;</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s0">notifyFinished() {</span>
            <span class="s1">this</span><span class="s0">.resolve();</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Allows the animation to be awaited.</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s6">@deprecated </span><span class="s3">Use `finished` instead.</span>
         <span class="s3">*/</span>
        <span class="s0">then(onResolve, onReject) {</span>
            <span class="s1">return this</span><span class="s0">.finished.then(onResolve, onReject);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">percentToProgress = (percent) =&gt; percent / </span><span class="s4">100</span><span class="s0">;</span>
    <span class="s1">class </span><span class="s0">JSAnimation </span><span class="s1">extends </span><span class="s0">WithPromise {</span>
        <span class="s0">constructor(options) {</span>
            <span class="s1">super</span><span class="s0">();</span>
            <span class="s1">this</span><span class="s0">.state = </span><span class="s2">&quot;idle&quot;</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.startTime = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.isStopped = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s3">/**</span>
             <span class="s3">* The current time of the animation.</span>
             <span class="s3">*/</span>
            <span class="s1">this</span><span class="s0">.currentTime = </span><span class="s4">0</span><span class="s0">;</span>
            <span class="s3">/**</span>
             <span class="s3">* The time at which the animation was paused.</span>
             <span class="s3">*/</span>
            <span class="s1">this</span><span class="s0">.holdTime = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s3">/**</span>
             <span class="s3">* Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.</span>
             <span class="s3">*/</span>
            <span class="s1">this</span><span class="s0">.playbackSpeed = </span><span class="s4">1</span><span class="s0">;</span>
            <span class="s3">/**</span>
             <span class="s3">* This method is bound to the instance to fix a pattern where</span>
             <span class="s3">* animation.stop is returned as a reference from a useEffect.</span>
             <span class="s3">*/</span>
            <span class="s1">this</span><span class="s0">.stop = () =&gt; {</span>
                <span class="s1">const </span><span class="s0">{ motionValue } = </span><span class="s1">this</span><span class="s0">.options;</span>
                <span class="s1">if </span><span class="s0">(motionValue &amp;&amp; motionValue.updatedAt !== time.now()) {</span>
                    <span class="s1">this</span><span class="s0">.tick(time.now());</span>
                <span class="s0">}</span>
                <span class="s1">this</span><span class="s0">.isStopped = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state === </span><span class="s2">&quot;idle&quot;</span><span class="s0">)</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s1">this</span><span class="s0">.teardown();</span>
                <span class="s1">this</span><span class="s0">.options.onStop?.();</span>
            <span class="s0">};</span>
            <span class="s0">activeAnimations.mainThread++;</span>
            <span class="s1">this</span><span class="s0">.options = options;</span>
            <span class="s1">this</span><span class="s0">.initAnimation();</span>
            <span class="s1">this</span><span class="s0">.play();</span>
            <span class="s1">if </span><span class="s0">(options.autoplay === </span><span class="s1">false</span><span class="s0">)</span>
                <span class="s1">this</span><span class="s0">.pause();</span>
        <span class="s0">}</span>
        <span class="s0">initAnimation() {</span>
            <span class="s1">const </span><span class="s0">{ options } = </span><span class="s1">this</span><span class="s0">;</span>
            <span class="s0">replaceTransitionType(options);</span>
            <span class="s1">const </span><span class="s0">{ type = keyframes, repeat = </span><span class="s4">0</span><span class="s0">, repeatDelay = </span><span class="s4">0</span><span class="s0">, repeatType, velocity = </span><span class="s4">0</span><span class="s0">, } = options;</span>
            <span class="s1">let </span><span class="s0">{ keyframes: keyframes$1 } = options;</span>
            <span class="s1">const </span><span class="s0">generatorFactory = type || keyframes;</span>
            <span class="s1">if </span><span class="s0">(generatorFactory !== keyframes) {</span>
                <span class="s0">motionUtils.invariant(keyframes$1.length &lt;= </span><span class="s4">2</span><span class="s0">, </span><span class="s2">`Only two keyframes currently supported with spring and inertia animations. Trying to animate </span><span class="s0">${keyframes$1}</span><span class="s2">`</span><span class="s0">, </span><span class="s2">&quot;spring-two-frames&quot;</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(generatorFactory !== keyframes &amp;&amp;</span>
                <span class="s1">typeof </span><span class="s0">keyframes$1[</span><span class="s4">0</span><span class="s0">] !== </span><span class="s2">&quot;number&quot;</span><span class="s0">) {</span>
                <span class="s1">this</span><span class="s0">.mixKeyframes = motionUtils.pipe(percentToProgress, mix(keyframes$1[</span><span class="s4">0</span><span class="s0">], keyframes$1[</span><span class="s4">1</span><span class="s0">]));</span>
                <span class="s0">keyframes$1 = [</span><span class="s4">0</span><span class="s0">, </span><span class="s4">100</span><span class="s0">];</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">generator = generatorFactory({ ...options, keyframes: keyframes$1 });</span>
            <span class="s3">/**</span>
             <span class="s3">* If we have a mirror repeat type we need to create a second generator that outputs the</span>
             <span class="s3">* mirrored (not reversed) animation and later ping pong between the two generators.</span>
             <span class="s3">*/</span>
            <span class="s1">if </span><span class="s0">(repeatType === </span><span class="s2">&quot;mirror&quot;</span><span class="s0">) {</span>
                <span class="s1">this</span><span class="s0">.mirroredGenerator = generatorFactory({</span>
                    <span class="s0">...options,</span>
                    <span class="s0">keyframes: [...keyframes$1].reverse(),</span>
                    <span class="s0">velocity: -velocity,</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
            <span class="s3">/**</span>
             <span class="s3">* If duration is undefined and we have repeat options,</span>
             <span class="s3">* we need to calculate a duration from the generator.</span>
             <span class="s3">*</span>
             <span class="s3">* We set it to the generator itself to cache the duration.</span>
             <span class="s3">* Any timeline resolver will need to have already precalculated</span>
             <span class="s3">* the duration by this step.</span>
             <span class="s3">*/</span>
            <span class="s1">if </span><span class="s0">(generator.calculatedDuration === </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s0">generator.calculatedDuration = calcGeneratorDuration(generator);</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">{ calculatedDuration } = generator;</span>
            <span class="s1">this</span><span class="s0">.calculatedDuration = calculatedDuration;</span>
            <span class="s1">this</span><span class="s0">.resolvedDuration = calculatedDuration + repeatDelay;</span>
            <span class="s1">this</span><span class="s0">.totalDuration = </span><span class="s1">this</span><span class="s0">.resolvedDuration * (repeat + </span><span class="s4">1</span><span class="s0">) - repeatDelay;</span>
            <span class="s1">this</span><span class="s0">.generator = generator;</span>
        <span class="s0">}</span>
        <span class="s0">updateTime(timestamp) {</span>
            <span class="s1">const </span><span class="s0">animationTime = Math.round(timestamp - </span><span class="s1">this</span><span class="s0">.startTime) * </span><span class="s1">this</span><span class="s0">.playbackSpeed;</span>
            <span class="s3">// Update currentTime</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.holdTime !== </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s1">this</span><span class="s0">.currentTime = </span><span class="s1">this</span><span class="s0">.holdTime;</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s3">// Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =</span>
                <span class="s3">// 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for</span>
                <span class="s3">// example.</span>
                <span class="s1">this</span><span class="s0">.currentTime = animationTime;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">tick(timestamp, sample = </span><span class="s1">false</span><span class="s0">) {</span>
            <span class="s1">const </span><span class="s0">{ generator, totalDuration, mixKeyframes, mirroredGenerator, resolvedDuration, calculatedDuration, } = </span><span class="s1">this</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.startTime === </span><span class="s1">null</span><span class="s0">)</span>
                <span class="s1">return </span><span class="s0">generator.next(</span><span class="s4">0</span><span class="s0">);</span>
            <span class="s1">const </span><span class="s0">{ delay = </span><span class="s4">0</span><span class="s0">, keyframes, repeat, repeatType, repeatDelay, type, onUpdate, finalKeyframe, } = </span><span class="s1">this</span><span class="s0">.options;</span>
            <span class="s3">/**</span>
             <span class="s3">* requestAnimationFrame timestamps can come through as lower than</span>
             <span class="s3">* the startTime as set by performance.now(). Here we prevent this,</span>
             <span class="s3">* though in the future it could be possible to make setting startTime</span>
             <span class="s3">* a pending operation that gets resolved here.</span>
             <span class="s3">*/</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.speed &gt; </span><span class="s4">0</span><span class="s0">) {</span>
                <span class="s1">this</span><span class="s0">.startTime = Math.min(</span><span class="s1">this</span><span class="s0">.startTime, timestamp);</span>
            <span class="s0">}</span>
            <span class="s1">else if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.speed &lt; </span><span class="s4">0</span><span class="s0">) {</span>
                <span class="s1">this</span><span class="s0">.startTime = Math.min(timestamp - totalDuration / </span><span class="s1">this</span><span class="s0">.speed, </span><span class="s1">this</span><span class="s0">.startTime);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(sample) {</span>
                <span class="s1">this</span><span class="s0">.currentTime = timestamp;</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">this</span><span class="s0">.updateTime(timestamp);</span>
            <span class="s0">}</span>
            <span class="s3">// Rebase on delay</span>
            <span class="s1">const </span><span class="s0">timeWithoutDelay = </span><span class="s1">this</span><span class="s0">.currentTime - delay * (</span><span class="s1">this</span><span class="s0">.playbackSpeed &gt;= </span><span class="s4">0 </span><span class="s0">? </span><span class="s4">1 </span><span class="s0">: -</span><span class="s4">1</span><span class="s0">);</span>
            <span class="s1">const </span><span class="s0">isInDelayPhase = </span><span class="s1">this</span><span class="s0">.playbackSpeed &gt;= </span><span class="s4">0</span>
                <span class="s0">? timeWithoutDelay &lt; </span><span class="s4">0</span>
                <span class="s0">: timeWithoutDelay &gt; totalDuration;</span>
            <span class="s1">this</span><span class="s0">.currentTime = Math.max(timeWithoutDelay, </span><span class="s4">0</span><span class="s0">);</span>
            <span class="s3">// If this animation has finished, set the current time  to the total duration.</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state === </span><span class="s2">&quot;finished&quot; </span><span class="s0">&amp;&amp; </span><span class="s1">this</span><span class="s0">.holdTime === </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s1">this</span><span class="s0">.currentTime = totalDuration;</span>
            <span class="s0">}</span>
            <span class="s1">let </span><span class="s0">elapsed = </span><span class="s1">this</span><span class="s0">.currentTime;</span>
            <span class="s1">let </span><span class="s0">frameGenerator = generator;</span>
            <span class="s1">if </span><span class="s0">(repeat) {</span>
                <span class="s3">/**</span>
                 <span class="s3">* Get the current progress (0-1) of the animation. If t is &gt;</span>
                 <span class="s3">* than duration we'll get values like 2.5 (midway through the</span>
                 <span class="s3">* third iteration)</span>
                 <span class="s3">*/</span>
                <span class="s1">const </span><span class="s0">progress = Math.min(</span><span class="s1">this</span><span class="s0">.currentTime, totalDuration) / resolvedDuration;</span>
                <span class="s3">/**</span>
                 <span class="s3">* Get the current iteration (0 indexed). For instance the floor of</span>
                 <span class="s3">* 2.5 is 2.</span>
                 <span class="s3">*/</span>
                <span class="s1">let </span><span class="s0">currentIteration = Math.floor(progress);</span>
                <span class="s3">/**</span>
                 <span class="s3">* Get the current progress of the iteration by taking the remainder</span>
                 <span class="s3">* so 2.5 is 0.5 through iteration 2</span>
                 <span class="s3">*/</span>
                <span class="s1">let </span><span class="s0">iterationProgress = progress % </span><span class="s4">1.0</span><span class="s0">;</span>
                <span class="s3">/**</span>
                 <span class="s3">* If iteration progress is 1 we count that as the end</span>
                 <span class="s3">* of the previous iteration.</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(!iterationProgress &amp;&amp; progress &gt;= </span><span class="s4">1</span><span class="s0">) {</span>
                    <span class="s0">iterationProgress = </span><span class="s4">1</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s0">iterationProgress === </span><span class="s4">1 </span><span class="s0">&amp;&amp; currentIteration--;</span>
                <span class="s0">currentIteration = Math.min(currentIteration, repeat + </span><span class="s4">1</span><span class="s0">);</span>
                <span class="s3">/**</span>
                 <span class="s3">* Reverse progress if we're not running in &quot;normal&quot; direction</span>
                 <span class="s3">*/</span>
                <span class="s1">const </span><span class="s0">isOddIteration = Boolean(currentIteration % </span><span class="s4">2</span><span class="s0">);</span>
                <span class="s1">if </span><span class="s0">(isOddIteration) {</span>
                    <span class="s1">if </span><span class="s0">(repeatType === </span><span class="s2">&quot;reverse&quot;</span><span class="s0">) {</span>
                        <span class="s0">iterationProgress = </span><span class="s4">1 </span><span class="s0">- iterationProgress;</span>
                        <span class="s1">if </span><span class="s0">(repeatDelay) {</span>
                            <span class="s0">iterationProgress -= repeatDelay / resolvedDuration;</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                    <span class="s1">else if </span><span class="s0">(repeatType === </span><span class="s2">&quot;mirror&quot;</span><span class="s0">) {</span>
                        <span class="s0">frameGenerator = mirroredGenerator;</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
                <span class="s0">elapsed = motionUtils.clamp(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, iterationProgress) * resolvedDuration;</span>
            <span class="s0">}</span>
            <span class="s3">/**</span>
             <span class="s3">* If we're in negative time, set state as the initial keyframe.</span>
             <span class="s3">* This prevents delay: x, duration: 0 animations from finishing</span>
             <span class="s3">* instantly.</span>
             <span class="s3">*/</span>
            <span class="s1">const </span><span class="s0">state = isInDelayPhase</span>
                <span class="s0">? { done: </span><span class="s1">false</span><span class="s0">, value: keyframes[</span><span class="s4">0</span><span class="s0">] }</span>
                <span class="s0">: frameGenerator.next(elapsed);</span>
            <span class="s1">if </span><span class="s0">(mixKeyframes) {</span>
                <span class="s0">state.value = mixKeyframes(state.value);</span>
            <span class="s0">}</span>
            <span class="s1">let </span><span class="s0">{ done } = state;</span>
            <span class="s1">if </span><span class="s0">(!isInDelayPhase &amp;&amp; calculatedDuration !== </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s0">done =</span>
                    <span class="s1">this</span><span class="s0">.playbackSpeed &gt;= </span><span class="s4">0</span>
                        <span class="s0">? </span><span class="s1">this</span><span class="s0">.currentTime &gt;= totalDuration</span>
                        <span class="s0">: </span><span class="s1">this</span><span class="s0">.currentTime &lt;= </span><span class="s4">0</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">isAnimationFinished = </span><span class="s1">this</span><span class="s0">.holdTime === </span><span class="s1">null </span><span class="s0">&amp;&amp;</span>
                <span class="s0">(</span><span class="s1">this</span><span class="s0">.state === </span><span class="s2">&quot;finished&quot; </span><span class="s0">|| (</span><span class="s1">this</span><span class="s0">.state === </span><span class="s2">&quot;running&quot; </span><span class="s0">&amp;&amp; done));</span>
            <span class="s3">// TODO: The exception for inertia could be cleaner here</span>
            <span class="s1">if </span><span class="s0">(isAnimationFinished &amp;&amp; type !== inertia) {</span>
                <span class="s0">state.value = getFinalKeyframe(keyframes, </span><span class="s1">this</span><span class="s0">.options, finalKeyframe, </span><span class="s1">this</span><span class="s0">.speed);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(onUpdate) {</span>
                <span class="s0">onUpdate(state.value);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(isAnimationFinished) {</span>
                <span class="s1">this</span><span class="s0">.finish();</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">state;</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Allows the returned animation to be awaited or promise-chained. Currently</span>
         <span class="s3">* resolves when the animation finishes at all but in a future update could/should</span>
         <span class="s3">* reject if its cancels.</span>
         <span class="s3">*/</span>
        <span class="s0">then(resolve, reject) {</span>
            <span class="s1">return this</span><span class="s0">.finished.then(resolve, reject);</span>
        <span class="s0">}</span>
        <span class="s0">get duration() {</span>
            <span class="s1">return </span><span class="s0">motionUtils.millisecondsToSeconds(</span><span class="s1">this</span><span class="s0">.calculatedDuration);</span>
        <span class="s0">}</span>
        <span class="s0">get iterationDuration() {</span>
            <span class="s1">const </span><span class="s0">{ delay = </span><span class="s4">0 </span><span class="s0">} = </span><span class="s1">this</span><span class="s0">.options || {};</span>
            <span class="s1">return this</span><span class="s0">.duration + motionUtils.millisecondsToSeconds(delay);</span>
        <span class="s0">}</span>
        <span class="s0">get time() {</span>
            <span class="s1">return </span><span class="s0">motionUtils.millisecondsToSeconds(</span><span class="s1">this</span><span class="s0">.currentTime);</span>
        <span class="s0">}</span>
        <span class="s0">set time(newTime) {</span>
            <span class="s0">newTime = motionUtils.secondsToMilliseconds(newTime);</span>
            <span class="s1">this</span><span class="s0">.currentTime = newTime;</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.startTime === </span><span class="s1">null </span><span class="s0">||</span>
                <span class="s1">this</span><span class="s0">.holdTime !== </span><span class="s1">null </span><span class="s0">||</span>
                <span class="s1">this</span><span class="s0">.playbackSpeed === </span><span class="s4">0</span><span class="s0">) {</span>
                <span class="s1">this</span><span class="s0">.holdTime = newTime;</span>
            <span class="s0">}</span>
            <span class="s1">else if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.driver) {</span>
                <span class="s1">this</span><span class="s0">.startTime = </span><span class="s1">this</span><span class="s0">.driver.now() - newTime / </span><span class="s1">this</span><span class="s0">.playbackSpeed;</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.driver?.start(</span><span class="s1">false</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">get speed() {</span>
            <span class="s1">return this</span><span class="s0">.playbackSpeed;</span>
        <span class="s0">}</span>
        <span class="s0">set speed(newSpeed) {</span>
            <span class="s1">this</span><span class="s0">.updateTime(time.now());</span>
            <span class="s1">const </span><span class="s0">hasChanged = </span><span class="s1">this</span><span class="s0">.playbackSpeed !== newSpeed;</span>
            <span class="s1">this</span><span class="s0">.playbackSpeed = newSpeed;</span>
            <span class="s1">if </span><span class="s0">(hasChanged) {</span>
                <span class="s1">this</span><span class="s0">.time = motionUtils.millisecondsToSeconds(</span><span class="s1">this</span><span class="s0">.currentTime);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">play() {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isStopped)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">const </span><span class="s0">{ driver = frameloopDriver, startTime } = </span><span class="s1">this</span><span class="s0">.options;</span>
            <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.driver) {</span>
                <span class="s1">this</span><span class="s0">.driver = driver((timestamp) =&gt; </span><span class="s1">this</span><span class="s0">.tick(timestamp));</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.options.onPlay?.();</span>
            <span class="s1">const </span><span class="s0">now = </span><span class="s1">this</span><span class="s0">.driver.now();</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state === </span><span class="s2">&quot;finished&quot;</span><span class="s0">) {</span>
                <span class="s1">this</span><span class="s0">.updateFinished();</span>
                <span class="s1">this</span><span class="s0">.startTime = now;</span>
            <span class="s0">}</span>
            <span class="s1">else if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.holdTime !== </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s1">this</span><span class="s0">.startTime = now - </span><span class="s1">this</span><span class="s0">.holdTime;</span>
            <span class="s0">}</span>
            <span class="s1">else if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.startTime) {</span>
                <span class="s1">this</span><span class="s0">.startTime = startTime ?? now;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state === </span><span class="s2">&quot;finished&quot; </span><span class="s0">&amp;&amp; </span><span class="s1">this</span><span class="s0">.speed &lt; </span><span class="s4">0</span><span class="s0">) {</span>
                <span class="s1">this</span><span class="s0">.startTime += </span><span class="s1">this</span><span class="s0">.calculatedDuration;</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.holdTime = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s3">/**</span>
             <span class="s3">* Set playState to running only after we've used it in</span>
             <span class="s3">* the previous logic.</span>
             <span class="s3">*/</span>
            <span class="s1">this</span><span class="s0">.state = </span><span class="s2">&quot;running&quot;</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.driver.start();</span>
        <span class="s0">}</span>
        <span class="s0">pause() {</span>
            <span class="s1">this</span><span class="s0">.state = </span><span class="s2">&quot;paused&quot;</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.updateTime(time.now());</span>
            <span class="s1">this</span><span class="s0">.holdTime = </span><span class="s1">this</span><span class="s0">.currentTime;</span>
        <span class="s0">}</span>
        <span class="s0">complete() {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state !== </span><span class="s2">&quot;running&quot;</span><span class="s0">) {</span>
                <span class="s1">this</span><span class="s0">.play();</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.state = </span><span class="s2">&quot;finished&quot;</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.holdTime = </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">finish() {</span>
            <span class="s1">this</span><span class="s0">.notifyFinished();</span>
            <span class="s1">this</span><span class="s0">.teardown();</span>
            <span class="s1">this</span><span class="s0">.state = </span><span class="s2">&quot;finished&quot;</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.options.onComplete?.();</span>
        <span class="s0">}</span>
        <span class="s0">cancel() {</span>
            <span class="s1">this</span><span class="s0">.holdTime = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.startTime = </span><span class="s4">0</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.tick(</span><span class="s4">0</span><span class="s0">);</span>
            <span class="s1">this</span><span class="s0">.teardown();</span>
            <span class="s1">this</span><span class="s0">.options.onCancel?.();</span>
        <span class="s0">}</span>
        <span class="s0">teardown() {</span>
            <span class="s1">this</span><span class="s0">.state = </span><span class="s2">&quot;idle&quot;</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.stopDriver();</span>
            <span class="s1">this</span><span class="s0">.startTime = </span><span class="s1">this</span><span class="s0">.holdTime = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s0">activeAnimations.mainThread--;</span>
        <span class="s0">}</span>
        <span class="s0">stopDriver() {</span>
            <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.driver)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.driver.stop();</span>
            <span class="s1">this</span><span class="s0">.driver = undefined;</span>
        <span class="s0">}</span>
        <span class="s0">sample(sampleTime) {</span>
            <span class="s1">this</span><span class="s0">.startTime = </span><span class="s4">0</span><span class="s0">;</span>
            <span class="s1">return this</span><span class="s0">.tick(sampleTime, </span><span class="s1">true</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">attachTimeline(timeline) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.options.allowFlatten) {</span>
                <span class="s1">this</span><span class="s0">.options.type = </span><span class="s2">&quot;keyframes&quot;</span><span class="s0">;</span>
                <span class="s1">this</span><span class="s0">.options.ease = </span><span class="s2">&quot;linear&quot;</span><span class="s0">;</span>
                <span class="s1">this</span><span class="s0">.initAnimation();</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.driver?.stop();</span>
            <span class="s1">return </span><span class="s0">timeline.observe(</span><span class="s1">this</span><span class="s0">);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s3">// Legacy function support</span>
    <span class="s1">function </span><span class="s0">animateValue(options) {</span>
        <span class="s1">return new </span><span class="s0">JSAnimation(options);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">fillWildcards(keyframes) {</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">1</span><span class="s0">; i &lt; keyframes.length; i++) {</span>
            <span class="s0">keyframes[i] ?? (keyframes[i] = keyframes[i - </span><span class="s4">1</span><span class="s0">]);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">radToDeg = (rad) =&gt; (rad * </span><span class="s4">180</span><span class="s0">) / Math.PI;</span>
    <span class="s1">const </span><span class="s0">rotate = (v) =&gt; {</span>
        <span class="s1">const </span><span class="s0">angle = radToDeg(Math.atan2(v[</span><span class="s4">1</span><span class="s0">], v[</span><span class="s4">0</span><span class="s0">]));</span>
        <span class="s1">return </span><span class="s0">rebaseAngle(angle);</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">matrix2dParsers = {</span>
        <span class="s0">x: </span><span class="s4">4</span><span class="s0">,</span>
        <span class="s0">y: </span><span class="s4">5</span><span class="s0">,</span>
        <span class="s0">translateX: </span><span class="s4">4</span><span class="s0">,</span>
        <span class="s0">translateY: </span><span class="s4">5</span><span class="s0">,</span>
        <span class="s0">scaleX: </span><span class="s4">0</span><span class="s0">,</span>
        <span class="s0">scaleY: </span><span class="s4">3</span><span class="s0">,</span>
        <span class="s0">scale: (v) =&gt; (Math.abs(v[</span><span class="s4">0</span><span class="s0">]) + Math.abs(v[</span><span class="s4">3</span><span class="s0">])) / </span><span class="s4">2</span><span class="s0">,</span>
        <span class="s0">rotate,</span>
        <span class="s0">rotateZ: rotate,</span>
        <span class="s0">skewX: (v) =&gt; radToDeg(Math.atan(v[</span><span class="s4">1</span><span class="s0">])),</span>
        <span class="s0">skewY: (v) =&gt; radToDeg(Math.atan(v[</span><span class="s4">2</span><span class="s0">])),</span>
        <span class="s0">skew: (v) =&gt; (Math.abs(v[</span><span class="s4">1</span><span class="s0">]) + Math.abs(v[</span><span class="s4">2</span><span class="s0">])) / </span><span class="s4">2</span><span class="s0">,</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">rebaseAngle = (angle) =&gt; {</span>
        <span class="s0">angle = angle % </span><span class="s4">360</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(angle &lt; </span><span class="s4">0</span><span class="s0">)</span>
            <span class="s0">angle += </span><span class="s4">360</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">angle;</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">rotateZ = rotate;</span>
    <span class="s1">const </span><span class="s0">scaleX = (v) =&gt; Math.sqrt(v[</span><span class="s4">0</span><span class="s0">] * v[</span><span class="s4">0</span><span class="s0">] + v[</span><span class="s4">1</span><span class="s0">] * v[</span><span class="s4">1</span><span class="s0">]);</span>
    <span class="s1">const </span><span class="s0">scaleY = (v) =&gt; Math.sqrt(v[</span><span class="s4">4</span><span class="s0">] * v[</span><span class="s4">4</span><span class="s0">] + v[</span><span class="s4">5</span><span class="s0">] * v[</span><span class="s4">5</span><span class="s0">]);</span>
    <span class="s1">const </span><span class="s0">matrix3dParsers = {</span>
        <span class="s0">x: </span><span class="s4">12</span><span class="s0">,</span>
        <span class="s0">y: </span><span class="s4">13</span><span class="s0">,</span>
        <span class="s0">z: </span><span class="s4">14</span><span class="s0">,</span>
        <span class="s0">translateX: </span><span class="s4">12</span><span class="s0">,</span>
        <span class="s0">translateY: </span><span class="s4">13</span><span class="s0">,</span>
        <span class="s0">translateZ: </span><span class="s4">14</span><span class="s0">,</span>
        <span class="s0">scaleX,</span>
        <span class="s0">scaleY,</span>
        <span class="s0">scale: (v) =&gt; (scaleX(v) + scaleY(v)) / </span><span class="s4">2</span><span class="s0">,</span>
        <span class="s0">rotateX: (v) =&gt; rebaseAngle(radToDeg(Math.atan2(v[</span><span class="s4">6</span><span class="s0">], v[</span><span class="s4">5</span><span class="s0">]))),</span>
        <span class="s0">rotateY: (v) =&gt; rebaseAngle(radToDeg(Math.atan2(-v[</span><span class="s4">2</span><span class="s0">], v[</span><span class="s4">0</span><span class="s0">]))),</span>
        <span class="s0">rotateZ,</span>
        <span class="s0">rotate: rotateZ,</span>
        <span class="s0">skewX: (v) =&gt; radToDeg(Math.atan(v[</span><span class="s4">4</span><span class="s0">])),</span>
        <span class="s0">skewY: (v) =&gt; radToDeg(Math.atan(v[</span><span class="s4">1</span><span class="s0">])),</span>
        <span class="s0">skew: (v) =&gt; (Math.abs(v[</span><span class="s4">1</span><span class="s0">]) + Math.abs(v[</span><span class="s4">4</span><span class="s0">])) / </span><span class="s4">2</span><span class="s0">,</span>
    <span class="s0">};</span>
    <span class="s1">function </span><span class="s0">defaultTransformValue(name) {</span>
        <span class="s1">return </span><span class="s0">name.includes(</span><span class="s2">&quot;scale&quot;</span><span class="s0">) ? </span><span class="s4">1 </span><span class="s0">: </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">parseValueFromTransform(transform, name) {</span>
        <span class="s1">if </span><span class="s0">(!transform || transform === </span><span class="s2">&quot;none&quot;</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">defaultTransformValue(name);</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">matrix3dMatch = transform.match(</span><span class="s5">/^matrix3d\(([-\d.e\s,]+)\)$/u</span><span class="s0">);</span>
        <span class="s1">let </span><span class="s0">parsers;</span>
        <span class="s1">let </span><span class="s0">match;</span>
        <span class="s1">if </span><span class="s0">(matrix3dMatch) {</span>
            <span class="s0">parsers = matrix3dParsers;</span>
            <span class="s0">match = matrix3dMatch;</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s1">const </span><span class="s0">matrix2dMatch = transform.match(</span><span class="s5">/^matrix\(([-\d.e\s,]+)\)$/u</span><span class="s0">);</span>
            <span class="s0">parsers = matrix2dParsers;</span>
            <span class="s0">match = matrix2dMatch;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(!match) {</span>
            <span class="s1">return </span><span class="s0">defaultTransformValue(name);</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">valueParser = parsers[name];</span>
        <span class="s1">const </span><span class="s0">values = match[</span><span class="s4">1</span><span class="s0">].split(</span><span class="s2">&quot;,&quot;</span><span class="s0">).map(convertTransformToNumber);</span>
        <span class="s1">return typeof </span><span class="s0">valueParser === </span><span class="s2">&quot;function&quot;</span>
            <span class="s0">? valueParser(values)</span>
            <span class="s0">: values[valueParser];</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">readTransformValue = (instance, name) =&gt; {</span>
        <span class="s1">const </span><span class="s0">{ transform = </span><span class="s2">&quot;none&quot; </span><span class="s0">} = getComputedStyle(instance);</span>
        <span class="s1">return </span><span class="s0">parseValueFromTransform(transform, name);</span>
    <span class="s0">};</span>
    <span class="s1">function </span><span class="s0">convertTransformToNumber(value) {</span>
        <span class="s1">return </span><span class="s0">parseFloat(value.trim());</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Generate a list of every possible transform key.</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">transformPropOrder = [</span>
        <span class="s2">&quot;transformPerspective&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;x&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;y&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;z&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;translateX&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;translateY&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;translateZ&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;scale&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;scaleX&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;scaleY&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;rotate&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;rotateX&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;rotateY&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;rotateZ&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;skew&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;skewX&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;skewY&quot;</span><span class="s0">,</span>
    <span class="s0">];</span>
    <span class="s3">/**</span>
     <span class="s3">* A quick lookup for transform props.</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">transformProps = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">(() =&gt; </span><span class="s1">new </span><span class="s0">Set(transformPropOrder))();</span>

    <span class="s1">const </span><span class="s0">isNumOrPxType = (v) =&gt; v === number || v === px;</span>
    <span class="s1">const </span><span class="s0">transformKeys = </span><span class="s1">new </span><span class="s0">Set([</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s0">, </span><span class="s2">&quot;z&quot;</span><span class="s0">]);</span>
    <span class="s1">const </span><span class="s0">nonTranslationalTransformKeys = transformPropOrder.filter((key) =&gt; !transformKeys.has(key));</span>
    <span class="s1">function </span><span class="s0">removeNonTranslationalTransform(visualElement) {</span>
        <span class="s1">const </span><span class="s0">removedTransforms = [];</span>
        <span class="s0">nonTranslationalTransformKeys.forEach((key) =&gt; {</span>
            <span class="s1">const </span><span class="s0">value = visualElement.getValue(key);</span>
            <span class="s1">if </span><span class="s0">(value !== undefined) {</span>
                <span class="s0">removedTransforms.push([key, value.get()]);</span>
                <span class="s0">value.set(key.startsWith(</span><span class="s2">&quot;scale&quot;</span><span class="s0">) ? </span><span class="s4">1 </span><span class="s0">: </span><span class="s4">0</span><span class="s0">);</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
        <span class="s1">return </span><span class="s0">removedTransforms;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">positionalValues = {</span>
        <span class="s3">// Dimensions</span>
        <span class="s0">width: ({ x }, { paddingLeft = </span><span class="s2">&quot;0&quot;</span><span class="s0">, paddingRight = </span><span class="s2">&quot;0&quot; </span><span class="s0">}) =&gt; x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),</span>
        <span class="s0">height: ({ y }, { paddingTop = </span><span class="s2">&quot;0&quot;</span><span class="s0">, paddingBottom = </span><span class="s2">&quot;0&quot; </span><span class="s0">}) =&gt; y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),</span>
        <span class="s0">top: (_bbox, { top }) =&gt; parseFloat(top),</span>
        <span class="s0">left: (_bbox, { left }) =&gt; parseFloat(left),</span>
        <span class="s0">bottom: ({ y }, { top }) =&gt; parseFloat(top) + (y.max - y.min),</span>
        <span class="s0">right: ({ x }, { left }) =&gt; parseFloat(left) + (x.max - x.min),</span>
        <span class="s3">// Transform</span>
        <span class="s0">x: (_bbox, { transform }) =&gt; parseValueFromTransform(transform, </span><span class="s2">&quot;x&quot;</span><span class="s0">),</span>
        <span class="s0">y: (_bbox, { transform }) =&gt; parseValueFromTransform(transform, </span><span class="s2">&quot;y&quot;</span><span class="s0">),</span>
    <span class="s0">};</span>
    <span class="s3">// Alias translate longform names</span>
    <span class="s0">positionalValues.translateX = positionalValues.x;</span>
    <span class="s0">positionalValues.translateY = positionalValues.y;</span>

    <span class="s1">const </span><span class="s0">toResolve = </span><span class="s1">new </span><span class="s0">Set();</span>
    <span class="s1">let </span><span class="s0">isScheduled = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s1">let </span><span class="s0">anyNeedsMeasurement = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s1">let </span><span class="s0">isForced = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s1">function </span><span class="s0">measureAllKeyframes() {</span>
        <span class="s1">if </span><span class="s0">(anyNeedsMeasurement) {</span>
            <span class="s1">const </span><span class="s0">resolversToMeasure = Array.from(toResolve).filter((resolver) =&gt; resolver.needsMeasurement);</span>
            <span class="s1">const </span><span class="s0">elementsToMeasure = </span><span class="s1">new </span><span class="s0">Set(resolversToMeasure.map((resolver) =&gt; resolver.element));</span>
            <span class="s1">const </span><span class="s0">transformsToRestore = </span><span class="s1">new </span><span class="s0">Map();</span>
            <span class="s3">/**</span>
             <span class="s3">* Write pass</span>
             <span class="s3">* If we're measuring elements we want to remove bounding box-changing transforms.</span>
             <span class="s3">*/</span>
            <span class="s0">elementsToMeasure.forEach((element) =&gt; {</span>
                <span class="s1">const </span><span class="s0">removedTransforms = removeNonTranslationalTransform(element);</span>
                <span class="s1">if </span><span class="s0">(!removedTransforms.length)</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s0">transformsToRestore.set(element, removedTransforms);</span>
                <span class="s0">element.render();</span>
            <span class="s0">});</span>
            <span class="s3">// Read</span>
            <span class="s0">resolversToMeasure.forEach((resolver) =&gt; resolver.measureInitialState());</span>
            <span class="s3">// Write</span>
            <span class="s0">elementsToMeasure.forEach((element) =&gt; {</span>
                <span class="s0">element.render();</span>
                <span class="s1">const </span><span class="s0">restore = transformsToRestore.get(element);</span>
                <span class="s1">if </span><span class="s0">(restore) {</span>
                    <span class="s0">restore.forEach(([key, value]) =&gt; {</span>
                        <span class="s0">element.getValue(key)?.set(value);</span>
                    <span class="s0">});</span>
                <span class="s0">}</span>
            <span class="s0">});</span>
            <span class="s3">// Read</span>
            <span class="s0">resolversToMeasure.forEach((resolver) =&gt; resolver.measureEndState());</span>
            <span class="s3">// Write</span>
            <span class="s0">resolversToMeasure.forEach((resolver) =&gt; {</span>
                <span class="s1">if </span><span class="s0">(resolver.suspendedScrollY !== undefined) {</span>
                    <span class="s0">window.scrollTo(</span><span class="s4">0</span><span class="s0">, resolver.suspendedScrollY);</span>
                <span class="s0">}</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s0">anyNeedsMeasurement = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s0">isScheduled = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s0">toResolve.forEach((resolver) =&gt; resolver.complete(isForced));</span>
        <span class="s0">toResolve.clear();</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">readAllKeyframes() {</span>
        <span class="s0">toResolve.forEach((resolver) =&gt; {</span>
            <span class="s0">resolver.readKeyframes();</span>
            <span class="s1">if </span><span class="s0">(resolver.needsMeasurement) {</span>
                <span class="s0">anyNeedsMeasurement = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">flushKeyframeResolvers() {</span>
        <span class="s0">isForced = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s0">readAllKeyframes();</span>
        <span class="s0">measureAllKeyframes();</span>
        <span class="s0">isForced = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">class </span><span class="s0">KeyframeResolver {</span>
        <span class="s0">constructor(unresolvedKeyframes, onComplete, name, motionValue, element, isAsync = </span><span class="s1">false</span><span class="s0">) {</span>
            <span class="s1">this</span><span class="s0">.state = </span><span class="s2">&quot;pending&quot;</span><span class="s0">;</span>
            <span class="s3">/**</span>
             <span class="s3">* Track whether this resolver is async. If it is, it'll be added to the</span>
             <span class="s3">* resolver queue and flushed in the next frame. Resolvers that aren't going</span>
             <span class="s3">* to trigger read/write thrashing don't need to be async.</span>
             <span class="s3">*/</span>
            <span class="s1">this</span><span class="s0">.isAsync = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s3">/**</span>
             <span class="s3">* Track whether this resolver needs to perform a measurement</span>
             <span class="s3">* to resolve its keyframes.</span>
             <span class="s3">*/</span>
            <span class="s1">this</span><span class="s0">.needsMeasurement = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.unresolvedKeyframes = [...unresolvedKeyframes];</span>
            <span class="s1">this</span><span class="s0">.onComplete = onComplete;</span>
            <span class="s1">this</span><span class="s0">.name = name;</span>
            <span class="s1">this</span><span class="s0">.motionValue = motionValue;</span>
            <span class="s1">this</span><span class="s0">.element = element;</span>
            <span class="s1">this</span><span class="s0">.isAsync = isAsync;</span>
        <span class="s0">}</span>
        <span class="s0">scheduleResolve() {</span>
            <span class="s1">this</span><span class="s0">.state = </span><span class="s2">&quot;scheduled&quot;</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isAsync) {</span>
                <span class="s0">toResolve.add(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">if </span><span class="s0">(!isScheduled) {</span>
                    <span class="s0">isScheduled = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s0">frame.read(readAllKeyframes);</span>
                    <span class="s0">frame.resolveKeyframes(measureAllKeyframes);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">this</span><span class="s0">.readKeyframes();</span>
                <span class="s1">this</span><span class="s0">.complete();</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">readKeyframes() {</span>
            <span class="s1">const </span><span class="s0">{ unresolvedKeyframes, name, element, motionValue } = </span><span class="s1">this</span><span class="s0">;</span>
            <span class="s3">// If initial keyframe is null we need to read it from the DOM</span>
            <span class="s1">if </span><span class="s0">(unresolvedKeyframes[</span><span class="s4">0</span><span class="s0">] === </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s1">const </span><span class="s0">currentValue = motionValue?.get();</span>
                <span class="s3">// TODO: This doesn't work if the final keyframe is a wildcard</span>
                <span class="s1">const </span><span class="s0">finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - </span><span class="s4">1</span><span class="s0">];</span>
                <span class="s1">if </span><span class="s0">(currentValue !== undefined) {</span>
                    <span class="s0">unresolvedKeyframes[</span><span class="s4">0</span><span class="s0">] = currentValue;</span>
                <span class="s0">}</span>
                <span class="s1">else if </span><span class="s0">(element &amp;&amp; name) {</span>
                    <span class="s1">const </span><span class="s0">valueAsRead = element.readValue(name, finalKeyframe);</span>
                    <span class="s1">if </span><span class="s0">(valueAsRead !== undefined &amp;&amp; valueAsRead !== </span><span class="s1">null</span><span class="s0">) {</span>
                        <span class="s0">unresolvedKeyframes[</span><span class="s4">0</span><span class="s0">] = valueAsRead;</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(unresolvedKeyframes[</span><span class="s4">0</span><span class="s0">] === undefined) {</span>
                    <span class="s0">unresolvedKeyframes[</span><span class="s4">0</span><span class="s0">] = finalKeyframe;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(motionValue &amp;&amp; currentValue === undefined) {</span>
                    <span class="s0">motionValue.set(unresolvedKeyframes[</span><span class="s4">0</span><span class="s0">]);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s0">fillWildcards(unresolvedKeyframes);</span>
        <span class="s0">}</span>
        <span class="s0">setFinalKeyframe() { }</span>
        <span class="s0">measureInitialState() { }</span>
        <span class="s0">renderEndStyles() { }</span>
        <span class="s0">measureEndState() { }</span>
        <span class="s0">complete(isForcedComplete = </span><span class="s1">false</span><span class="s0">) {</span>
            <span class="s1">this</span><span class="s0">.state = </span><span class="s2">&quot;complete&quot;</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.onComplete(</span><span class="s1">this</span><span class="s0">.unresolvedKeyframes, </span><span class="s1">this</span><span class="s0">.finalKeyframe, isForcedComplete);</span>
            <span class="s0">toResolve.delete(</span><span class="s1">this</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">cancel() {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state === </span><span class="s2">&quot;scheduled&quot;</span><span class="s0">) {</span>
                <span class="s0">toResolve.delete(</span><span class="s1">this</span><span class="s0">);</span>
                <span class="s1">this</span><span class="s0">.state = </span><span class="s2">&quot;pending&quot;</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">resume() {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state === </span><span class="s2">&quot;pending&quot;</span><span class="s0">)</span>
                <span class="s1">this</span><span class="s0">.scheduleResolve();</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">isCSSVar = (name) =&gt; name.startsWith(</span><span class="s2">&quot;--&quot;</span><span class="s0">);</span>

    <span class="s1">function </span><span class="s0">setStyle(element, name, value) {</span>
        <span class="s0">isCSSVar(name)</span>
            <span class="s0">? element.style.setProperty(name, value)</span>
            <span class="s0">: (element.style[name] = value);</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">supportsScrollTimeline = </span><span class="s3">/* @__PURE__ */ </span><span class="s0">motionUtils.memo(() =&gt; window.ScrollTimeline !== undefined);</span>

    <span class="s3">/**</span>
     <span class="s3">* Add the ability for test suites to manually set support flags</span>
     <span class="s3">* to better test more environments.</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">supportsFlags = {};</span>

    <span class="s1">function </span><span class="s0">memoSupports(callback, supportsFlag) {</span>
        <span class="s1">const </span><span class="s0">memoized = motionUtils.memo(callback);</span>
        <span class="s1">return </span><span class="s0">() =&gt; supportsFlags[supportsFlag] ?? memoized();</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">supportsLinearEasing = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">memoSupports(() =&gt; {</span>
        <span class="s1">try </span><span class="s0">{</span>
            <span class="s0">document</span>
                <span class="s0">.createElement(</span><span class="s2">&quot;div&quot;</span><span class="s0">)</span>
                <span class="s0">.animate({ opacity: </span><span class="s4">0 </span><span class="s0">}, { easing: </span><span class="s2">&quot;linear(0, 1)&quot; </span><span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s1">catch </span><span class="s0">(e) {</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">}, </span><span class="s2">&quot;linearEasing&quot;</span><span class="s0">);</span>

    <span class="s1">const </span><span class="s0">cubicBezierAsString = ([a, b, c, d]) =&gt; </span><span class="s2">`cubic-bezier(</span><span class="s0">${a}</span><span class="s2">, </span><span class="s0">${b}</span><span class="s2">, </span><span class="s0">${c}</span><span class="s2">, </span><span class="s0">${d}</span><span class="s2">)`</span><span class="s0">;</span>

    <span class="s1">const </span><span class="s0">supportedWaapiEasing = {</span>
        <span class="s0">linear: </span><span class="s2">&quot;linear&quot;</span><span class="s0">,</span>
        <span class="s0">ease: </span><span class="s2">&quot;ease&quot;</span><span class="s0">,</span>
        <span class="s0">easeIn: </span><span class="s2">&quot;ease-in&quot;</span><span class="s0">,</span>
        <span class="s0">easeOut: </span><span class="s2">&quot;ease-out&quot;</span><span class="s0">,</span>
        <span class="s0">easeInOut: </span><span class="s2">&quot;ease-in-out&quot;</span><span class="s0">,</span>
        <span class="s0">circIn: </span><span class="s3">/*@__PURE__*/ </span><span class="s0">cubicBezierAsString([</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0.65</span><span class="s0">, </span><span class="s4">0.55</span><span class="s0">, </span><span class="s4">1</span><span class="s0">]),</span>
        <span class="s0">circOut: </span><span class="s3">/*@__PURE__*/ </span><span class="s0">cubicBezierAsString([</span><span class="s4">0.55</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0.45</span><span class="s0">]),</span>
        <span class="s0">backIn: </span><span class="s3">/*@__PURE__*/ </span><span class="s0">cubicBezierAsString([</span><span class="s4">0.31</span><span class="s0">, </span><span class="s4">0.01</span><span class="s0">, </span><span class="s4">0.66</span><span class="s0">, -</span><span class="s4">0.59</span><span class="s0">]),</span>
        <span class="s0">backOut: </span><span class="s3">/*@__PURE__*/ </span><span class="s0">cubicBezierAsString([</span><span class="s4">0.33</span><span class="s0">, </span><span class="s4">1.53</span><span class="s0">, </span><span class="s4">0.69</span><span class="s0">, </span><span class="s4">0.99</span><span class="s0">]),</span>
    <span class="s0">};</span>

    <span class="s1">function </span><span class="s0">mapEasingToNativeEasing(easing, duration) {</span>
        <span class="s1">if </span><span class="s0">(!easing) {</span>
            <span class="s1">return </span><span class="s0">undefined;</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">easing === </span><span class="s2">&quot;function&quot;</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">supportsLinearEasing()</span>
                <span class="s0">? generateLinearEasing(easing, duration)</span>
                <span class="s0">: </span><span class="s2">&quot;ease-out&quot;</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(motionUtils.isBezierDefinition(easing)) {</span>
            <span class="s1">return </span><span class="s0">cubicBezierAsString(easing);</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(Array.isArray(easing)) {</span>
            <span class="s1">return </span><span class="s0">easing.map((segmentEasing) =&gt; mapEasingToNativeEasing(segmentEasing, duration) ||</span>
                <span class="s0">supportedWaapiEasing.easeOut);</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s1">return </span><span class="s0">supportedWaapiEasing[easing];</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">startWaapiAnimation(element, valueName, keyframes, { delay = </span><span class="s4">0</span><span class="s0">, duration = </span><span class="s4">300</span><span class="s0">, repeat = </span><span class="s4">0</span><span class="s0">, repeatType = </span><span class="s2">&quot;loop&quot;</span><span class="s0">, ease = </span><span class="s2">&quot;easeOut&quot;</span><span class="s0">, times, } = {}, pseudoElement = undefined) {</span>
        <span class="s1">const </span><span class="s0">keyframeOptions = {</span>
            <span class="s0">[valueName]: keyframes,</span>
        <span class="s0">};</span>
        <span class="s1">if </span><span class="s0">(times)</span>
            <span class="s0">keyframeOptions.offset = times;</span>
        <span class="s1">const </span><span class="s0">easing = mapEasingToNativeEasing(ease, duration);</span>
        <span class="s3">/**</span>
         <span class="s3">* If this is an easing array, apply to keyframes, not animation as a whole</span>
         <span class="s3">*/</span>
        <span class="s1">if </span><span class="s0">(Array.isArray(easing))</span>
            <span class="s0">keyframeOptions.easing = easing;</span>
        <span class="s1">if </span><span class="s0">(statsBuffer.value) {</span>
            <span class="s0">activeAnimations.waapi++;</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">options = {</span>
            <span class="s0">delay,</span>
            <span class="s0">duration,</span>
            <span class="s0">easing: !Array.isArray(easing) ? easing : </span><span class="s2">&quot;linear&quot;</span><span class="s0">,</span>
            <span class="s0">fill: </span><span class="s2">&quot;both&quot;</span><span class="s0">,</span>
            <span class="s0">iterations: repeat + </span><span class="s4">1</span><span class="s0">,</span>
            <span class="s0">direction: repeatType === </span><span class="s2">&quot;reverse&quot; </span><span class="s0">? </span><span class="s2">&quot;alternate&quot; </span><span class="s0">: </span><span class="s2">&quot;normal&quot;</span><span class="s0">,</span>
        <span class="s0">};</span>
        <span class="s1">if </span><span class="s0">(pseudoElement)</span>
            <span class="s0">options.pseudoElement = pseudoElement;</span>
        <span class="s1">const </span><span class="s0">animation = element.animate(keyframeOptions, options);</span>
        <span class="s1">if </span><span class="s0">(statsBuffer.value) {</span>
            <span class="s0">animation.finished.finally(() =&gt; {</span>
                <span class="s0">activeAnimations.waapi--;</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">animation;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">isGenerator(type) {</span>
        <span class="s1">return typeof </span><span class="s0">type === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; </span><span class="s2">&quot;applyToOptions&quot; </span><span class="s1">in </span><span class="s0">type;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">applyGeneratorOptions({ type, ...options }) {</span>
        <span class="s1">if </span><span class="s0">(isGenerator(type) &amp;&amp; supportsLinearEasing()) {</span>
            <span class="s1">return </span><span class="s0">type.applyToOptions(options);</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s0">options.duration ?? (options.duration = </span><span class="s4">300</span><span class="s0">);</span>
            <span class="s0">options.ease ?? (options.ease = </span><span class="s2">&quot;easeOut&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">options;</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* NativeAnimation implements AnimationPlaybackControls for the browser's Web Animations API.</span>
     <span class="s3">*/</span>
    <span class="s1">class </span><span class="s0">NativeAnimation </span><span class="s1">extends </span><span class="s0">WithPromise {</span>
        <span class="s0">constructor(options) {</span>
            <span class="s1">super</span><span class="s0">();</span>
            <span class="s1">this</span><span class="s0">.finishedTime = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.isStopped = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(!options)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">const </span><span class="s0">{ element, name, keyframes, pseudoElement, allowFlatten = </span><span class="s1">false</span><span class="s0">, finalKeyframe, onComplete, } = options;</span>
            <span class="s1">this</span><span class="s0">.isPseudoElement = Boolean(pseudoElement);</span>
            <span class="s1">this</span><span class="s0">.allowFlatten = allowFlatten;</span>
            <span class="s1">this</span><span class="s0">.options = options;</span>
            <span class="s0">motionUtils.invariant(</span><span class="s1">typeof </span><span class="s0">options.type !== </span><span class="s2">&quot;string&quot;</span><span class="s0">, </span><span class="s2">`Mini animate() doesn't support &quot;type&quot; as a string.`</span><span class="s0">, </span><span class="s2">&quot;mini-spring&quot;</span><span class="s0">);</span>
            <span class="s1">const </span><span class="s0">transition = applyGeneratorOptions(options);</span>
            <span class="s1">this</span><span class="s0">.animation = startWaapiAnimation(element, name, keyframes, transition, pseudoElement);</span>
            <span class="s1">if </span><span class="s0">(transition.autoplay === </span><span class="s1">false</span><span class="s0">) {</span>
                <span class="s1">this</span><span class="s0">.animation.pause();</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.animation.onfinish = () =&gt; {</span>
                <span class="s1">this</span><span class="s0">.finishedTime = </span><span class="s1">this</span><span class="s0">.time;</span>
                <span class="s1">if </span><span class="s0">(!pseudoElement) {</span>
                    <span class="s1">const </span><span class="s0">keyframe = getFinalKeyframe(keyframes, </span><span class="s1">this</span><span class="s0">.options, finalKeyframe, </span><span class="s1">this</span><span class="s0">.speed);</span>
                    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.updateMotionValue) {</span>
                        <span class="s1">this</span><span class="s0">.updateMotionValue(keyframe);</span>
                    <span class="s0">}</span>
                    <span class="s1">else </span><span class="s0">{</span>
                        <span class="s3">/**</span>
                         <span class="s3">* If we can, we want to commit the final style as set by the user,</span>
                         <span class="s3">* rather than the computed keyframe value supplied by the animation.</span>
                         <span class="s3">*/</span>
                        <span class="s0">setStyle(element, name, keyframe);</span>
                    <span class="s0">}</span>
                    <span class="s1">this</span><span class="s0">.animation.cancel();</span>
                <span class="s0">}</span>
                <span class="s0">onComplete?.();</span>
                <span class="s1">this</span><span class="s0">.notifyFinished();</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s0">play() {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isStopped)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.animation.play();</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state === </span><span class="s2">&quot;finished&quot;</span><span class="s0">) {</span>
                <span class="s1">this</span><span class="s0">.updateFinished();</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">pause() {</span>
            <span class="s1">this</span><span class="s0">.animation.pause();</span>
        <span class="s0">}</span>
        <span class="s0">complete() {</span>
            <span class="s1">this</span><span class="s0">.animation.finish?.();</span>
        <span class="s0">}</span>
        <span class="s0">cancel() {</span>
            <span class="s1">try </span><span class="s0">{</span>
                <span class="s1">this</span><span class="s0">.animation.cancel();</span>
            <span class="s0">}</span>
            <span class="s1">catch </span><span class="s0">(e) { }</span>
        <span class="s0">}</span>
        <span class="s0">stop() {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isStopped)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.isStopped = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s1">const </span><span class="s0">{ state } = </span><span class="s1">this</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(state === </span><span class="s2">&quot;idle&quot; </span><span class="s0">|| state === </span><span class="s2">&quot;finished&quot;</span><span class="s0">) {</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.updateMotionValue) {</span>
                <span class="s1">this</span><span class="s0">.updateMotionValue();</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">this</span><span class="s0">.commitStyles();</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.isPseudoElement)</span>
                <span class="s1">this</span><span class="s0">.cancel();</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* WAAPI doesn't natively have any interruption capabilities.</span>
         <span class="s3">*</span>
         <span class="s3">* In this method, we commit styles back to the DOM before cancelling</span>
         <span class="s3">* the animation.</span>
         <span class="s3">*</span>
         <span class="s3">* This is designed to be overridden by NativeAnimationExtended, which</span>
         <span class="s3">* will create a renderless JS animation and sample it twice to calculate</span>
         <span class="s3">* its current value, &quot;previous&quot; value, and therefore allow</span>
         <span class="s3">* Motion to also correctly calculate velocity for any subsequent animation</span>
         <span class="s3">* while deferring the commit until the next animation frame.</span>
         <span class="s3">*/</span>
        <span class="s0">commitStyles() {</span>
            <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.isPseudoElement) {</span>
                <span class="s1">this</span><span class="s0">.animation.commitStyles?.();</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">get duration() {</span>
            <span class="s1">const </span><span class="s0">duration = </span><span class="s1">this</span><span class="s0">.animation.effect?.getComputedTiming?.().duration || </span><span class="s4">0</span><span class="s0">;</span>
            <span class="s1">return </span><span class="s0">motionUtils.millisecondsToSeconds(Number(duration));</span>
        <span class="s0">}</span>
        <span class="s0">get iterationDuration() {</span>
            <span class="s1">const </span><span class="s0">{ delay = </span><span class="s4">0 </span><span class="s0">} = </span><span class="s1">this</span><span class="s0">.options || {};</span>
            <span class="s1">return this</span><span class="s0">.duration + motionUtils.millisecondsToSeconds(delay);</span>
        <span class="s0">}</span>
        <span class="s0">get time() {</span>
            <span class="s1">return </span><span class="s0">motionUtils.millisecondsToSeconds(Number(</span><span class="s1">this</span><span class="s0">.animation.currentTime) || </span><span class="s4">0</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">set time(newTime) {</span>
            <span class="s1">this</span><span class="s0">.finishedTime = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.animation.currentTime = motionUtils.secondsToMilliseconds(newTime);</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* The playback speed of the animation.</span>
         <span class="s3">* 1 = normal speed, 2 = double speed, 0.5 = half speed.</span>
         <span class="s3">*/</span>
        <span class="s0">get speed() {</span>
            <span class="s1">return this</span><span class="s0">.animation.playbackRate;</span>
        <span class="s0">}</span>
        <span class="s0">set speed(newSpeed) {</span>
            <span class="s3">// Allow backwards playback after finishing</span>
            <span class="s1">if </span><span class="s0">(newSpeed &lt; </span><span class="s4">0</span><span class="s0">)</span>
                <span class="s1">this</span><span class="s0">.finishedTime = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.animation.playbackRate = newSpeed;</span>
        <span class="s0">}</span>
        <span class="s0">get state() {</span>
            <span class="s1">return this</span><span class="s0">.finishedTime !== </span><span class="s1">null</span>
                <span class="s0">? </span><span class="s2">&quot;finished&quot;</span>
                <span class="s0">: </span><span class="s1">this</span><span class="s0">.animation.playState;</span>
        <span class="s0">}</span>
        <span class="s0">get startTime() {</span>
            <span class="s1">return </span><span class="s0">Number(</span><span class="s1">this</span><span class="s0">.animation.startTime);</span>
        <span class="s0">}</span>
        <span class="s0">set startTime(newStartTime) {</span>
            <span class="s1">this</span><span class="s0">.animation.startTime = newStartTime;</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Attaches a timeline to the animation, for instance the `ScrollTimeline`.</span>
         <span class="s3">*/</span>
        <span class="s0">attachTimeline({ timeline, observe }) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.allowFlatten) {</span>
                <span class="s1">this</span><span class="s0">.animation.effect?.updateTiming({ easing: </span><span class="s2">&quot;linear&quot; </span><span class="s0">});</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.animation.onfinish = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(timeline &amp;&amp; supportsScrollTimeline()) {</span>
                <span class="s1">this</span><span class="s0">.animation.timeline = timeline;</span>
                <span class="s1">return </span><span class="s0">motionUtils.noop;</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">return </span><span class="s0">observe(</span><span class="s1">this</span><span class="s0">);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">unsupportedEasingFunctions = {</span>
        <span class="s0">anticipate: motionUtils.anticipate,</span>
        <span class="s0">backInOut: motionUtils.backInOut,</span>
        <span class="s0">circInOut: motionUtils.circInOut,</span>
    <span class="s0">};</span>
    <span class="s1">function </span><span class="s0">isUnsupportedEase(key) {</span>
        <span class="s1">return </span><span class="s0">key </span><span class="s1">in </span><span class="s0">unsupportedEasingFunctions;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">replaceStringEasing(transition) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">transition.ease === </span><span class="s2">&quot;string&quot; </span><span class="s0">&amp;&amp;</span>
            <span class="s0">isUnsupportedEase(transition.ease)) {</span>
            <span class="s0">transition.ease = unsupportedEasingFunctions[transition.ease];</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* 10ms is chosen here as it strikes a balance between smooth</span>
     <span class="s3">* results (more than one keyframe per frame at 60fps) and</span>
     <span class="s3">* keyframe quantity.</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">sampleDelta = </span><span class="s4">10</span><span class="s0">; </span><span class="s3">//ms</span>
    <span class="s1">class </span><span class="s0">NativeAnimationExtended </span><span class="s1">extends </span><span class="s0">NativeAnimation {</span>
        <span class="s0">constructor(options) {</span>
            <span class="s3">/**</span>
             <span class="s3">* The base NativeAnimation function only supports a subset</span>
             <span class="s3">* of Motion easings, and WAAPI also only supports some</span>
             <span class="s3">* easing functions via string/cubic-bezier definitions.</span>
             <span class="s3">*</span>
             <span class="s3">* This function replaces those unsupported easing functions</span>
             <span class="s3">* with a JS easing function. This will later get compiled</span>
             <span class="s3">* to a linear() easing function.</span>
             <span class="s3">*/</span>
            <span class="s0">replaceStringEasing(options);</span>
            <span class="s3">/**</span>
             <span class="s3">* Ensure we replace the transition type with a generator function</span>
             <span class="s3">* before passing to WAAPI.</span>
             <span class="s3">*</span>
             <span class="s3">* TODO: Does this have a better home? It could be shared with</span>
             <span class="s3">* JSAnimation.</span>
             <span class="s3">*/</span>
            <span class="s0">replaceTransitionType(options);</span>
            <span class="s1">super</span><span class="s0">(options);</span>
            <span class="s1">if </span><span class="s0">(options.startTime) {</span>
                <span class="s1">this</span><span class="s0">.startTime = options.startTime;</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.options = options;</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* WAAPI doesn't natively have any interruption capabilities.</span>
         <span class="s3">*</span>
         <span class="s3">* Rather than read commited styles back out of the DOM, we can</span>
         <span class="s3">* create a renderless JS animation and sample it twice to calculate</span>
         <span class="s3">* its current value, &quot;previous&quot; value, and therefore allow</span>
         <span class="s3">* Motion to calculate velocity for any subsequent animation.</span>
         <span class="s3">*/</span>
        <span class="s0">updateMotionValue(value) {</span>
            <span class="s1">const </span><span class="s0">{ motionValue, onUpdate, onComplete, element, ...options } = </span><span class="s1">this</span><span class="s0">.options;</span>
            <span class="s1">if </span><span class="s0">(!motionValue)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(value !== undefined) {</span>
                <span class="s0">motionValue.set(value);</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">sampleAnimation = </span><span class="s1">new </span><span class="s0">JSAnimation({</span>
                <span class="s0">...options,</span>
                <span class="s0">autoplay: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">});</span>
            <span class="s1">const </span><span class="s0">sampleTime = motionUtils.secondsToMilliseconds(</span><span class="s1">this</span><span class="s0">.finishedTime ?? </span><span class="s1">this</span><span class="s0">.time);</span>
            <span class="s0">motionValue.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);</span>
            <span class="s0">sampleAnimation.stop();</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Check if a value is animatable. Examples:</span>
     <span class="s3">*</span>
     <span class="s3">* : 100, &quot;100px&quot;, &quot;#fff&quot;</span>
     <span class="s3">* : &quot;block&quot;, &quot;url(2.jpg)&quot;</span>
     <span class="s3">* </span><span class="s6">@param </span><span class="s3">value</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s6">@internal</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">isAnimatable = (value, name) =&gt; {</span>
        <span class="s3">// If the list of keys that might be non-animatable grows, replace with Set</span>
        <span class="s1">if </span><span class="s0">(name === </span><span class="s2">&quot;zIndex&quot;</span><span class="s0">)</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s3">// If it's a number or a keyframes array, we can animate it. We might at some point</span>
        <span class="s3">// need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,</span>
        <span class="s3">// but for now lets leave it like this for performance reasons</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">value === </span><span class="s2">&quot;number&quot; </span><span class="s0">|| Array.isArray(value))</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">value === </span><span class="s2">&quot;string&quot; </span><span class="s0">&amp;&amp; </span><span class="s3">// It's animatable if we have a string</span>
            <span class="s0">(complex.test(value) || value === </span><span class="s2">&quot;0&quot;</span><span class="s0">) &amp;&amp; </span><span class="s3">// And it contains numbers and/or colors</span>
            <span class="s0">!value.startsWith(</span><span class="s2">&quot;url(&quot;</span><span class="s0">) </span><span class="s3">// Unless it starts with &quot;url(&quot;</span>
        <span class="s0">) {</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">return false</span><span class="s0">;</span>
    <span class="s0">};</span>

    <span class="s1">function </span><span class="s0">hasKeyframesChanged(keyframes) {</span>
        <span class="s1">const </span><span class="s0">current = keyframes[</span><span class="s4">0</span><span class="s0">];</span>
        <span class="s1">if </span><span class="s0">(keyframes.length === </span><span class="s4">1</span><span class="s0">)</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; keyframes.length; i++) {</span>
            <span class="s1">if </span><span class="s0">(keyframes[i] !== current)</span>
                <span class="s1">return true</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">canAnimate(keyframes, name, type, velocity) {</span>
        <span class="s3">/**</span>
         <span class="s3">* Check if we're able to animate between the start and end keyframes,</span>
         <span class="s3">* and throw a warning if we're attempting to animate between one that's</span>
         <span class="s3">* animatable and another that isn't.</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">originKeyframe = keyframes[</span><span class="s4">0</span><span class="s0">];</span>
        <span class="s1">if </span><span class="s0">(originKeyframe === </span><span class="s1">null</span><span class="s0">)</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s3">/**</span>
         <span class="s3">* These aren't traditionally animatable but we do support them.</span>
         <span class="s3">* In future we could look into making this more generic or replacing</span>
         <span class="s3">* this function with mix() === mixImmediate</span>
         <span class="s3">*/</span>
        <span class="s1">if </span><span class="s0">(name === </span><span class="s2">&quot;display&quot; </span><span class="s0">|| name === </span><span class="s2">&quot;visibility&quot;</span><span class="s0">)</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">targetKeyframe = keyframes[keyframes.length - </span><span class="s4">1</span><span class="s0">];</span>
        <span class="s1">const </span><span class="s0">isOriginAnimatable = isAnimatable(originKeyframe, name);</span>
        <span class="s1">const </span><span class="s0">isTargetAnimatable = isAnimatable(targetKeyframe, name);</span>
        <span class="s0">motionUtils.warning(isOriginAnimatable === isTargetAnimatable, </span><span class="s2">`You are trying to animate </span><span class="s0">${name} </span><span class="s2">from &quot;</span><span class="s0">${originKeyframe}</span><span class="s2">&quot; to &quot;</span><span class="s0">${targetKeyframe}</span><span class="s2">&quot;. &quot;</span><span class="s0">${isOriginAnimatable ? targetKeyframe : originKeyframe}</span><span class="s2">&quot; is not an animatable value.`</span><span class="s0">, </span><span class="s2">&quot;value-not-animatable&quot;</span><span class="s0">);</span>
        <span class="s3">// Always skip if any of these are true</span>
        <span class="s1">if </span><span class="s0">(!isOriginAnimatable || !isTargetAnimatable) {</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">(hasKeyframesChanged(keyframes) ||</span>
            <span class="s0">((type === </span><span class="s2">&quot;spring&quot; </span><span class="s0">|| isGenerator(type)) &amp;&amp; velocity));</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">makeAnimationInstant(options) {</span>
        <span class="s0">options.duration = </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s0">options.type = </span><span class="s2">&quot;keyframes&quot;</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* A list of values that can be hardware-accelerated.</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">acceleratedValues$1 = </span><span class="s1">new </span><span class="s0">Set([</span>
        <span class="s2">&quot;opacity&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;clipPath&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;filter&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;transform&quot;</span><span class="s0">,</span>
        <span class="s3">// TODO: Could be re-enabled now we have support for linear() easing</span>
        <span class="s3">// &quot;background-color&quot;</span>
    <span class="s0">]);</span>
    <span class="s1">const </span><span class="s0">supportsWaapi = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">motionUtils.memo(() =&gt; Object.hasOwnProperty.call(Element.prototype, </span><span class="s2">&quot;animate&quot;</span><span class="s0">));</span>
    <span class="s1">function </span><span class="s0">supportsBrowserAnimation(options) {</span>
        <span class="s1">const </span><span class="s0">{ motionValue, name, repeatDelay, repeatType, damping, type } = options;</span>
        <span class="s1">const </span><span class="s0">subject = motionValue?.owner?.current;</span>
        <span class="s3">/**</span>
         <span class="s3">* We use this check instead of isHTMLElement() because we explicitly</span>
         <span class="s3">* **don't** want elements in different timing contexts (i.e. popups)</span>
         <span class="s3">* to be accelerated, as it's not possible to sync these animations</span>
         <span class="s3">* properly with those driven from the main window frameloop.</span>
         <span class="s3">*/</span>
        <span class="s1">if </span><span class="s0">(!(subject </span><span class="s1">instanceof </span><span class="s0">HTMLElement)) {</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">{ onUpdate, transformTemplate } = motionValue.owner.getProps();</span>
        <span class="s1">return </span><span class="s0">(supportsWaapi() &amp;&amp;</span>
            <span class="s0">name &amp;&amp;</span>
            <span class="s0">acceleratedValues$1.has(name) &amp;&amp;</span>
            <span class="s0">(name !== </span><span class="s2">&quot;transform&quot; </span><span class="s0">|| !transformTemplate) &amp;&amp;</span>
            <span class="s3">/**</span>
             <span class="s3">* If we're outputting values to onUpdate then we can't use WAAPI as there's</span>
             <span class="s3">* no way to read the value from WAAPI every frame.</span>
             <span class="s3">*/</span>
            <span class="s0">!onUpdate &amp;&amp;</span>
            <span class="s0">!repeatDelay &amp;&amp;</span>
            <span class="s0">repeatType !== </span><span class="s2">&quot;mirror&quot; </span><span class="s0">&amp;&amp;</span>
            <span class="s0">damping !== </span><span class="s4">0 </span><span class="s0">&amp;&amp;</span>
            <span class="s0">type !== </span><span class="s2">&quot;inertia&quot;</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Maximum time allowed between an animation being created and it being</span>
     <span class="s3">* resolved for us to use the latter as the start time.</span>
     <span class="s3">*</span>
     <span class="s3">* This is to ensure that while we prefer to &quot;start&quot; an animation as soon</span>
     <span class="s3">* as it's triggered, we also want to avoid a visual jump if there's a big delay</span>
     <span class="s3">* between these two moments.</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">MAX_RESOLVE_DELAY = </span><span class="s4">40</span><span class="s0">;</span>
    <span class="s1">class </span><span class="s0">AsyncMotionValueAnimation </span><span class="s1">extends </span><span class="s0">WithPromise {</span>
        <span class="s0">constructor({ autoplay = </span><span class="s1">true</span><span class="s0">, delay = </span><span class="s4">0</span><span class="s0">, type = </span><span class="s2">&quot;keyframes&quot;</span><span class="s0">, repeat = </span><span class="s4">0</span><span class="s0">, repeatDelay = </span><span class="s4">0</span><span class="s0">, repeatType = </span><span class="s2">&quot;loop&quot;</span><span class="s0">, keyframes, name, motionValue, element, ...options }) {</span>
            <span class="s1">super</span><span class="s0">();</span>
            <span class="s3">/**</span>
             <span class="s3">* Bound to support return animation.stop pattern</span>
             <span class="s3">*/</span>
            <span class="s1">this</span><span class="s0">.stop = () =&gt; {</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">._animation) {</span>
                    <span class="s1">this</span><span class="s0">._animation.stop();</span>
                    <span class="s1">this</span><span class="s0">.stopTimeline?.();</span>
                <span class="s0">}</span>
                <span class="s1">this</span><span class="s0">.keyframeResolver?.cancel();</span>
            <span class="s0">};</span>
            <span class="s1">this</span><span class="s0">.createdAt = time.now();</span>
            <span class="s1">const </span><span class="s0">optionsWithDefaults = {</span>
                <span class="s0">autoplay,</span>
                <span class="s0">delay,</span>
                <span class="s0">type,</span>
                <span class="s0">repeat,</span>
                <span class="s0">repeatDelay,</span>
                <span class="s0">repeatType,</span>
                <span class="s0">name,</span>
                <span class="s0">motionValue,</span>
                <span class="s0">element,</span>
                <span class="s0">...options,</span>
            <span class="s0">};</span>
            <span class="s1">const </span><span class="s0">KeyframeResolver$1 = element?.KeyframeResolver || KeyframeResolver;</span>
            <span class="s1">this</span><span class="s0">.keyframeResolver = </span><span class="s1">new </span><span class="s0">KeyframeResolver$1(keyframes, (resolvedKeyframes, finalKeyframe, forced) =&gt; </span><span class="s1">this</span><span class="s0">.onKeyframesResolved(resolvedKeyframes, finalKeyframe, optionsWithDefaults, !forced), name, motionValue, element);</span>
            <span class="s1">this</span><span class="s0">.keyframeResolver?.scheduleResolve();</span>
        <span class="s0">}</span>
        <span class="s0">onKeyframesResolved(keyframes, finalKeyframe, options, sync) {</span>
            <span class="s1">this</span><span class="s0">.keyframeResolver = undefined;</span>
            <span class="s1">const </span><span class="s0">{ name, type, velocity, delay, isHandoff, onUpdate } = options;</span>
            <span class="s1">this</span><span class="s0">.resolvedAt = time.now();</span>
            <span class="s3">/**</span>
             <span class="s3">* If we can't animate this value with the resolved keyframes</span>
             <span class="s3">* then we should complete it immediately.</span>
             <span class="s3">*/</span>
            <span class="s1">if </span><span class="s0">(!canAnimate(keyframes, name, type, velocity)) {</span>
                <span class="s1">if </span><span class="s0">(motionUtils.MotionGlobalConfig.instantAnimations || !delay) {</span>
                    <span class="s0">onUpdate?.(getFinalKeyframe(keyframes, options, finalKeyframe));</span>
                <span class="s0">}</span>
                <span class="s0">keyframes[</span><span class="s4">0</span><span class="s0">] = keyframes[keyframes.length - </span><span class="s4">1</span><span class="s0">];</span>
                <span class="s0">makeAnimationInstant(options);</span>
                <span class="s0">options.repeat = </span><span class="s4">0</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s3">/**</span>
             <span class="s3">* Resolve startTime for the animation.</span>
             <span class="s3">*</span>
             <span class="s3">* This method uses the createdAt and resolvedAt to calculate the</span>
             <span class="s3">* animation startTime. *Ideally*, we would use the createdAt time as t=0</span>
             <span class="s3">* as the following frame would then be the first frame of the animation in</span>
             <span class="s3">* progress, which would feel snappier.</span>
             <span class="s3">*</span>
             <span class="s3">* However, if there's a delay (main thread work) between the creation of</span>
             <span class="s3">* the animation and the first commited frame, we prefer to use resolvedAt</span>
             <span class="s3">* to avoid a sudden jump into the animation.</span>
             <span class="s3">*/</span>
            <span class="s1">const </span><span class="s0">startTime = sync</span>
                <span class="s0">? !</span><span class="s1">this</span><span class="s0">.resolvedAt</span>
                    <span class="s0">? </span><span class="s1">this</span><span class="s0">.createdAt</span>
                    <span class="s0">: </span><span class="s1">this</span><span class="s0">.resolvedAt - </span><span class="s1">this</span><span class="s0">.createdAt &gt; MAX_RESOLVE_DELAY</span>
                        <span class="s0">? </span><span class="s1">this</span><span class="s0">.resolvedAt</span>
                        <span class="s0">: </span><span class="s1">this</span><span class="s0">.createdAt</span>
                <span class="s0">: undefined;</span>
            <span class="s1">const </span><span class="s0">resolvedOptions = {</span>
                <span class="s0">startTime,</span>
                <span class="s0">finalKeyframe,</span>
                <span class="s0">...options,</span>
                <span class="s0">keyframes,</span>
            <span class="s0">};</span>
            <span class="s3">/**</span>
             <span class="s3">* Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via</span>
             <span class="s3">* WAAPI. Therefore, this animation must be JS to ensure it runs &quot;under&quot; the</span>
             <span class="s3">* optimised animation.</span>
             <span class="s3">*/</span>
            <span class="s1">const </span><span class="s0">animation = !isHandoff &amp;&amp; supportsBrowserAnimation(resolvedOptions)</span>
                <span class="s0">? </span><span class="s1">new </span><span class="s0">NativeAnimationExtended({</span>
                    <span class="s0">...resolvedOptions,</span>
                    <span class="s0">element: resolvedOptions.motionValue.owner.current,</span>
                <span class="s0">})</span>
                <span class="s0">: </span><span class="s1">new </span><span class="s0">JSAnimation(resolvedOptions);</span>
            <span class="s0">animation.finished.then(() =&gt; </span><span class="s1">this</span><span class="s0">.notifyFinished()).catch(motionUtils.noop);</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.pendingTimeline) {</span>
                <span class="s1">this</span><span class="s0">.stopTimeline = animation.attachTimeline(</span><span class="s1">this</span><span class="s0">.pendingTimeline);</span>
                <span class="s1">this</span><span class="s0">.pendingTimeline = undefined;</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">._animation = animation;</span>
        <span class="s0">}</span>
        <span class="s0">get finished() {</span>
            <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">._animation) {</span>
                <span class="s1">return this</span><span class="s0">._finished;</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">return this</span><span class="s0">.animation.finished;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">then(onResolve, _onReject) {</span>
            <span class="s1">return this</span><span class="s0">.finished.finally(onResolve).then(() =&gt; { });</span>
        <span class="s0">}</span>
        <span class="s0">get animation() {</span>
            <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">._animation) {</span>
                <span class="s1">this</span><span class="s0">.keyframeResolver?.resume();</span>
                <span class="s0">flushKeyframeResolvers();</span>
            <span class="s0">}</span>
            <span class="s1">return this</span><span class="s0">._animation;</span>
        <span class="s0">}</span>
        <span class="s0">get duration() {</span>
            <span class="s1">return this</span><span class="s0">.animation.duration;</span>
        <span class="s0">}</span>
        <span class="s0">get iterationDuration() {</span>
            <span class="s1">return this</span><span class="s0">.animation.iterationDuration;</span>
        <span class="s0">}</span>
        <span class="s0">get time() {</span>
            <span class="s1">return this</span><span class="s0">.animation.time;</span>
        <span class="s0">}</span>
        <span class="s0">set time(newTime) {</span>
            <span class="s1">this</span><span class="s0">.animation.time = newTime;</span>
        <span class="s0">}</span>
        <span class="s0">get speed() {</span>
            <span class="s1">return this</span><span class="s0">.animation.speed;</span>
        <span class="s0">}</span>
        <span class="s0">get state() {</span>
            <span class="s1">return this</span><span class="s0">.animation.state;</span>
        <span class="s0">}</span>
        <span class="s0">set speed(newSpeed) {</span>
            <span class="s1">this</span><span class="s0">.animation.speed = newSpeed;</span>
        <span class="s0">}</span>
        <span class="s0">get startTime() {</span>
            <span class="s1">return this</span><span class="s0">.animation.startTime;</span>
        <span class="s0">}</span>
        <span class="s0">attachTimeline(timeline) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">._animation) {</span>
                <span class="s1">this</span><span class="s0">.stopTimeline = </span><span class="s1">this</span><span class="s0">.animation.attachTimeline(timeline);</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">this</span><span class="s0">.pendingTimeline = timeline;</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">() =&gt; </span><span class="s1">this</span><span class="s0">.stop();</span>
        <span class="s0">}</span>
        <span class="s0">play() {</span>
            <span class="s1">this</span><span class="s0">.animation.play();</span>
        <span class="s0">}</span>
        <span class="s0">pause() {</span>
            <span class="s1">this</span><span class="s0">.animation.pause();</span>
        <span class="s0">}</span>
        <span class="s0">complete() {</span>
            <span class="s1">this</span><span class="s0">.animation.complete();</span>
        <span class="s0">}</span>
        <span class="s0">cancel() {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">._animation) {</span>
                <span class="s1">this</span><span class="s0">.animation.cancel();</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.keyframeResolver?.cancel();</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">class </span><span class="s0">GroupAnimation {</span>
        <span class="s0">constructor(animations) {</span>
            <span class="s3">// Bound to accomadate common `return animation.stop` pattern</span>
            <span class="s1">this</span><span class="s0">.stop = () =&gt; </span><span class="s1">this</span><span class="s0">.runAll(</span><span class="s2">&quot;stop&quot;</span><span class="s0">);</span>
            <span class="s1">this</span><span class="s0">.animations = animations.filter(Boolean);</span>
        <span class="s0">}</span>
        <span class="s0">get finished() {</span>
            <span class="s1">return </span><span class="s0">Promise.all(</span><span class="s1">this</span><span class="s0">.animations.map((animation) =&gt; animation.finished));</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* TODO: Filter out cancelled or stopped animations before returning</span>
         <span class="s3">*/</span>
        <span class="s0">getAll(propName) {</span>
            <span class="s1">return this</span><span class="s0">.animations[</span><span class="s4">0</span><span class="s0">][propName];</span>
        <span class="s0">}</span>
        <span class="s0">setAll(propName, newValue) {</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; </span><span class="s1">this</span><span class="s0">.animations.length; i++) {</span>
                <span class="s1">this</span><span class="s0">.animations[i][propName] = newValue;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">attachTimeline(timeline) {</span>
            <span class="s1">const </span><span class="s0">subscriptions = </span><span class="s1">this</span><span class="s0">.animations.map((animation) =&gt; animation.attachTimeline(timeline));</span>
            <span class="s1">return </span><span class="s0">() =&gt; {</span>
                <span class="s0">subscriptions.forEach((cancel, i) =&gt; {</span>
                    <span class="s0">cancel &amp;&amp; cancel();</span>
                    <span class="s1">this</span><span class="s0">.animations[i].stop();</span>
                <span class="s0">});</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s0">get time() {</span>
            <span class="s1">return this</span><span class="s0">.getAll(</span><span class="s2">&quot;time&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">set time(time) {</span>
            <span class="s1">this</span><span class="s0">.setAll(</span><span class="s2">&quot;time&quot;</span><span class="s0">, time);</span>
        <span class="s0">}</span>
        <span class="s0">get speed() {</span>
            <span class="s1">return this</span><span class="s0">.getAll(</span><span class="s2">&quot;speed&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">set speed(speed) {</span>
            <span class="s1">this</span><span class="s0">.setAll(</span><span class="s2">&quot;speed&quot;</span><span class="s0">, speed);</span>
        <span class="s0">}</span>
        <span class="s0">get state() {</span>
            <span class="s1">return this</span><span class="s0">.getAll(</span><span class="s2">&quot;state&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">get startTime() {</span>
            <span class="s1">return this</span><span class="s0">.getAll(</span><span class="s2">&quot;startTime&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">get duration() {</span>
            <span class="s1">return </span><span class="s0">getMax(</span><span class="s1">this</span><span class="s0">.animations, </span><span class="s2">&quot;duration&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">get iterationDuration() {</span>
            <span class="s1">return </span><span class="s0">getMax(</span><span class="s1">this</span><span class="s0">.animations, </span><span class="s2">&quot;iterationDuration&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">runAll(methodName) {</span>
            <span class="s1">this</span><span class="s0">.animations.forEach((controls) =&gt; controls[methodName]());</span>
        <span class="s0">}</span>
        <span class="s0">play() {</span>
            <span class="s1">this</span><span class="s0">.runAll(</span><span class="s2">&quot;play&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">pause() {</span>
            <span class="s1">this</span><span class="s0">.runAll(</span><span class="s2">&quot;pause&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">cancel() {</span>
            <span class="s1">this</span><span class="s0">.runAll(</span><span class="s2">&quot;cancel&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">complete() {</span>
            <span class="s1">this</span><span class="s0">.runAll(</span><span class="s2">&quot;complete&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">getMax(animations, propName) {</span>
        <span class="s1">let </span><span class="s0">max = </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; animations.length; i++) {</span>
            <span class="s1">const </span><span class="s0">value = animations[i][propName];</span>
            <span class="s1">if </span><span class="s0">(value !== </span><span class="s1">null </span><span class="s0">&amp;&amp; value &gt; max) {</span>
                <span class="s0">max = value;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">max;</span>
    <span class="s0">}</span>

    <span class="s1">class </span><span class="s0">GroupAnimationWithThen </span><span class="s1">extends </span><span class="s0">GroupAnimation {</span>
        <span class="s0">then(onResolve, _onReject) {</span>
            <span class="s1">return this</span><span class="s0">.finished.finally(onResolve).then(() =&gt; { });</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">class </span><span class="s0">NativeAnimationWrapper </span><span class="s1">extends </span><span class="s0">NativeAnimation {</span>
        <span class="s0">constructor(animation) {</span>
            <span class="s1">super</span><span class="s0">();</span>
            <span class="s1">this</span><span class="s0">.animation = animation;</span>
            <span class="s0">animation.onfinish = () =&gt; {</span>
                <span class="s1">this</span><span class="s0">.finishedTime = </span><span class="s1">this</span><span class="s0">.time;</span>
                <span class="s1">this</span><span class="s0">.notifyFinished();</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">animationMaps = </span><span class="s1">new </span><span class="s0">WeakMap();</span>
    <span class="s1">const </span><span class="s0">animationMapKey = (name, pseudoElement = </span><span class="s2">&quot;&quot;</span><span class="s0">) =&gt; </span><span class="s2">`</span><span class="s0">${name}</span><span class="s2">:</span><span class="s0">${pseudoElement}</span><span class="s2">`</span><span class="s0">;</span>
    <span class="s1">function </span><span class="s0">getAnimationMap(element) {</span>
        <span class="s1">const </span><span class="s0">map = animationMaps.get(element) || </span><span class="s1">new </span><span class="s0">Map();</span>
        <span class="s0">animationMaps.set(element, map);</span>
        <span class="s1">return </span><span class="s0">map;</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Parse Framer's special CSS variable format into a CSS token and a fallback.</span>
     <span class="s3">*</span>
     <span class="s3">* ```</span>
     <span class="s3">* `var(--foo, #fff)` =&gt; [`--foo`, '#fff']</span>
     <span class="s3">* ```</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s6">@param </span><span class="s3">current</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">splitCSSVariableRegex = </span>
    <span class="s3">// eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words</span>
    <span class="s5">/^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u</span><span class="s0">;</span>
    <span class="s1">function </span><span class="s0">parseCSSVariable(current) {</span>
        <span class="s1">const </span><span class="s0">match = splitCSSVariableRegex.exec(current);</span>
        <span class="s1">if </span><span class="s0">(!match)</span>
            <span class="s1">return </span><span class="s0">[,];</span>
        <span class="s1">const </span><span class="s0">[, token1, token2, fallback] = match;</span>
        <span class="s1">return </span><span class="s0">[</span><span class="s2">`--</span><span class="s0">${token1 ?? token2}</span><span class="s2">`</span><span class="s0">, fallback];</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">maxDepth = </span><span class="s4">4</span><span class="s0">;</span>
    <span class="s1">function </span><span class="s0">getVariableValue(current, element, depth = </span><span class="s4">1</span><span class="s0">) {</span>
        <span class="s0">motionUtils.invariant(depth &lt;= maxDepth, </span><span class="s2">`Max CSS variable fallback depth detected in property &quot;</span><span class="s0">${current}</span><span class="s2">&quot;. This may indicate a circular fallback dependency.`</span><span class="s0">, </span><span class="s2">&quot;max-css-var-depth&quot;</span><span class="s0">);</span>
        <span class="s1">const </span><span class="s0">[token, fallback] = parseCSSVariable(current);</span>
        <span class="s3">// No CSS variable detected</span>
        <span class="s1">if </span><span class="s0">(!token)</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s3">// Attempt to read this CSS variable off the element</span>
        <span class="s1">const </span><span class="s0">resolved = window.getComputedStyle(element).getPropertyValue(token);</span>
        <span class="s1">if </span><span class="s0">(resolved) {</span>
            <span class="s1">const </span><span class="s0">trimmed = resolved.trim();</span>
            <span class="s1">return </span><span class="s0">motionUtils.isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">isCSSVariableToken(fallback)</span>
            <span class="s0">? getVariableValue(fallback, element, depth + </span><span class="s4">1</span><span class="s0">)</span>
            <span class="s0">: fallback;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">getValueTransition(transition, key) {</span>
        <span class="s1">return </span><span class="s0">(transition?.[key] ??</span>
            <span class="s0">transition?.[</span><span class="s2">&quot;default&quot;</span><span class="s0">] ??</span>
            <span class="s0">transition);</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">positionalKeys = </span><span class="s1">new </span><span class="s0">Set([</span>
        <span class="s2">&quot;width&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;height&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;top&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;left&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;right&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;bottom&quot;</span><span class="s0">,</span>
        <span class="s0">...transformPropOrder,</span>
    <span class="s0">]);</span>

    <span class="s3">/**</span>
     <span class="s3">* ValueType for &quot;auto&quot;</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">auto = {</span>
        <span class="s0">test: (v) =&gt; v === </span><span class="s2">&quot;auto&quot;</span><span class="s0">,</span>
        <span class="s0">parse: (v) =&gt; v,</span>
    <span class="s0">};</span>

    <span class="s3">/**</span>
     <span class="s3">* Tests a provided value against a ValueType</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">testValueType = (v) =&gt; (type) =&gt; type.test(v);</span>

    <span class="s3">/**</span>
     <span class="s3">* A list of value types commonly used for dimensions</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];</span>
    <span class="s3">/**</span>
     <span class="s3">* Tests a dimensional value against the list of dimension ValueTypes</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">findDimensionValueType = (v) =&gt; dimensionValueTypes.find(testValueType(v));</span>

    <span class="s1">function </span><span class="s0">isNone(value) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">value === </span><span class="s2">&quot;number&quot;</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">value === </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(value !== </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">value === </span><span class="s2">&quot;none&quot; </span><span class="s0">|| value === </span><span class="s2">&quot;0&quot; </span><span class="s0">|| motionUtils.isZeroValueString(value);</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Properties that should default to 1 or 100%</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">maxDefaults = </span><span class="s1">new </span><span class="s0">Set([</span><span class="s2">&quot;brightness&quot;</span><span class="s0">, </span><span class="s2">&quot;contrast&quot;</span><span class="s0">, </span><span class="s2">&quot;saturate&quot;</span><span class="s0">, </span><span class="s2">&quot;opacity&quot;</span><span class="s0">]);</span>
    <span class="s1">function </span><span class="s0">applyDefaultFilter(v) {</span>
        <span class="s1">const </span><span class="s0">[name, value] = v.slice(</span><span class="s4">0</span><span class="s0">, -</span><span class="s4">1</span><span class="s0">).split(</span><span class="s2">&quot;(&quot;</span><span class="s0">);</span>
        <span class="s1">if </span><span class="s0">(name === </span><span class="s2">&quot;drop-shadow&quot;</span><span class="s0">)</span>
            <span class="s1">return </span><span class="s0">v;</span>
        <span class="s1">const </span><span class="s0">[number] = value.match(floatRegex) || [];</span>
        <span class="s1">if </span><span class="s0">(!number)</span>
            <span class="s1">return </span><span class="s0">v;</span>
        <span class="s1">const </span><span class="s0">unit = value.replace(number, </span><span class="s2">&quot;&quot;</span><span class="s0">);</span>
        <span class="s1">let </span><span class="s0">defaultValue = maxDefaults.has(name) ? </span><span class="s4">1 </span><span class="s0">: </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(number !== value)</span>
            <span class="s0">defaultValue *= </span><span class="s4">100</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">name + </span><span class="s2">&quot;(&quot; </span><span class="s0">+ defaultValue + unit + </span><span class="s2">&quot;)&quot;</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">functionRegex = </span><span class="s5">/\b([a-z-]*)\(.*?\)/gu</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">filter = {</span>
        <span class="s0">...complex,</span>
        <span class="s0">getAnimatableNone: (v) =&gt; {</span>
            <span class="s1">const </span><span class="s0">functions = v.match(functionRegex);</span>
            <span class="s1">return </span><span class="s0">functions ? functions.map(applyDefaultFilter).join(</span><span class="s2">&quot; &quot;</span><span class="s0">) : v;</span>
        <span class="s0">},</span>
    <span class="s0">};</span>

    <span class="s1">const </span><span class="s0">int = {</span>
        <span class="s0">...number,</span>
        <span class="s0">transform: Math.round,</span>
    <span class="s0">};</span>

    <span class="s1">const </span><span class="s0">transformValueTypes = {</span>
        <span class="s0">rotate: degrees,</span>
        <span class="s0">rotateX: degrees,</span>
        <span class="s0">rotateY: degrees,</span>
        <span class="s0">rotateZ: degrees,</span>
        <span class="s0">scale,</span>
        <span class="s0">scaleX: scale,</span>
        <span class="s0">scaleY: scale,</span>
        <span class="s0">scaleZ: scale,</span>
        <span class="s0">skew: degrees,</span>
        <span class="s0">skewX: degrees,</span>
        <span class="s0">skewY: degrees,</span>
        <span class="s0">distance: px,</span>
        <span class="s0">translateX: px,</span>
        <span class="s0">translateY: px,</span>
        <span class="s0">translateZ: px,</span>
        <span class="s0">x: px,</span>
        <span class="s0">y: px,</span>
        <span class="s0">z: px,</span>
        <span class="s0">perspective: px,</span>
        <span class="s0">transformPerspective: px,</span>
        <span class="s0">opacity: alpha,</span>
        <span class="s0">originX: progressPercentage,</span>
        <span class="s0">originY: progressPercentage,</span>
        <span class="s0">originZ: px,</span>
    <span class="s0">};</span>

    <span class="s1">const </span><span class="s0">numberValueTypes = {</span>
        <span class="s3">// Border props</span>
        <span class="s0">borderWidth: px,</span>
        <span class="s0">borderTopWidth: px,</span>
        <span class="s0">borderRightWidth: px,</span>
        <span class="s0">borderBottomWidth: px,</span>
        <span class="s0">borderLeftWidth: px,</span>
        <span class="s0">borderRadius: px,</span>
        <span class="s0">radius: px,</span>
        <span class="s0">borderTopLeftRadius: px,</span>
        <span class="s0">borderTopRightRadius: px,</span>
        <span class="s0">borderBottomRightRadius: px,</span>
        <span class="s0">borderBottomLeftRadius: px,</span>
        <span class="s3">// Positioning props</span>
        <span class="s0">width: px,</span>
        <span class="s0">maxWidth: px,</span>
        <span class="s0">height: px,</span>
        <span class="s0">maxHeight: px,</span>
        <span class="s0">top: px,</span>
        <span class="s0">right: px,</span>
        <span class="s0">bottom: px,</span>
        <span class="s0">left: px,</span>
        <span class="s3">// Spacing props</span>
        <span class="s0">padding: px,</span>
        <span class="s0">paddingTop: px,</span>
        <span class="s0">paddingRight: px,</span>
        <span class="s0">paddingBottom: px,</span>
        <span class="s0">paddingLeft: px,</span>
        <span class="s0">margin: px,</span>
        <span class="s0">marginTop: px,</span>
        <span class="s0">marginRight: px,</span>
        <span class="s0">marginBottom: px,</span>
        <span class="s0">marginLeft: px,</span>
        <span class="s3">// Misc</span>
        <span class="s0">backgroundPositionX: px,</span>
        <span class="s0">backgroundPositionY: px,</span>
        <span class="s0">...transformValueTypes,</span>
        <span class="s0">zIndex: int,</span>
        <span class="s3">// SVG</span>
        <span class="s0">fillOpacity: alpha,</span>
        <span class="s0">strokeOpacity: alpha,</span>
        <span class="s0">numOctaves: int,</span>
    <span class="s0">};</span>

    <span class="s3">/**</span>
     <span class="s3">* A map of default value types for common values</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">defaultValueTypes = {</span>
        <span class="s0">...numberValueTypes,</span>
        <span class="s3">// Color props</span>
        <span class="s0">color,</span>
        <span class="s0">backgroundColor: color,</span>
        <span class="s0">outlineColor: color,</span>
        <span class="s0">fill: color,</span>
        <span class="s0">stroke: color,</span>
        <span class="s3">// Border props</span>
        <span class="s0">borderColor: color,</span>
        <span class="s0">borderTopColor: color,</span>
        <span class="s0">borderRightColor: color,</span>
        <span class="s0">borderBottomColor: color,</span>
        <span class="s0">borderLeftColor: color,</span>
        <span class="s0">filter,</span>
        <span class="s0">WebkitFilter: filter,</span>
    <span class="s0">};</span>
    <span class="s3">/**</span>
     <span class="s3">* Gets the default ValueType for the provided value key</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">getDefaultValueType = (key) =&gt; defaultValueTypes[key];</span>

    <span class="s1">function </span><span class="s0">getAnimatableNone(key, value) {</span>
        <span class="s1">let </span><span class="s0">defaultValueType = getDefaultValueType(key);</span>
        <span class="s1">if </span><span class="s0">(defaultValueType !== filter)</span>
            <span class="s0">defaultValueType = complex;</span>
        <span class="s3">// If value is not recognised as animatable, ie &quot;none&quot;, create an animatable version origin based on the target</span>
        <span class="s1">return </span><span class="s0">defaultValueType.getAnimatableNone</span>
            <span class="s0">? defaultValueType.getAnimatableNone(value)</span>
            <span class="s0">: undefined;</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* If we encounter keyframes like &quot;none&quot; or &quot;0&quot; and we also have keyframes like</span>
     <span class="s3">* &quot;#fff&quot; or &quot;200px 200px&quot; we want to find a keyframe to serve as a template for</span>
     <span class="s3">* the &quot;none&quot; keyframes. In this case &quot;#fff&quot; or &quot;200px 200px&quot; - then these get turned into</span>
     <span class="s3">* zero equivalents, i.e. &quot;#fff0&quot; or &quot;0px 0px&quot;.</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">invalidTemplates = </span><span class="s1">new </span><span class="s0">Set([</span><span class="s2">&quot;auto&quot;</span><span class="s0">, </span><span class="s2">&quot;none&quot;</span><span class="s0">, </span><span class="s2">&quot;0&quot;</span><span class="s0">]);</span>
    <span class="s1">function </span><span class="s0">makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {</span>
        <span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">animatableTemplate = undefined;</span>
        <span class="s1">while </span><span class="s0">(i &lt; unresolvedKeyframes.length &amp;&amp; !animatableTemplate) {</span>
            <span class="s1">const </span><span class="s0">keyframe = unresolvedKeyframes[i];</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">keyframe === </span><span class="s2">&quot;string&quot; </span><span class="s0">&amp;&amp;</span>
                <span class="s0">!invalidTemplates.has(keyframe) &amp;&amp;</span>
                <span class="s0">analyseComplexValue(keyframe).values.length) {</span>
                <span class="s0">animatableTemplate = unresolvedKeyframes[i];</span>
            <span class="s0">}</span>
            <span class="s0">i++;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(animatableTemplate &amp;&amp; name) {</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">noneIndex of noneKeyframeIndexes) {</span>
                <span class="s0">unresolvedKeyframes[noneIndex] = getAnimatableNone(name, animatableTemplate);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">class </span><span class="s0">DOMKeyframesResolver </span><span class="s1">extends </span><span class="s0">KeyframeResolver {</span>
        <span class="s0">constructor(unresolvedKeyframes, onComplete, name, motionValue, element) {</span>
            <span class="s1">super</span><span class="s0">(unresolvedKeyframes, onComplete, name, motionValue, element, </span><span class="s1">true</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">readKeyframes() {</span>
            <span class="s1">const </span><span class="s0">{ unresolvedKeyframes, element, name } = </span><span class="s1">this</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(!element || !element.current)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">super</span><span class="s0">.readKeyframes();</span>
            <span class="s3">/**</span>
             <span class="s3">* If any keyframe is a CSS variable, we need to find its value by sampling the element</span>
             <span class="s3">*/</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; unresolvedKeyframes.length; i++) {</span>
                <span class="s1">let </span><span class="s0">keyframe = unresolvedKeyframes[i];</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">keyframe === </span><span class="s2">&quot;string&quot;</span><span class="s0">) {</span>
                    <span class="s0">keyframe = keyframe.trim();</span>
                    <span class="s1">if </span><span class="s0">(isCSSVariableToken(keyframe)) {</span>
                        <span class="s1">const </span><span class="s0">resolved = getVariableValue(keyframe, element.current);</span>
                        <span class="s1">if </span><span class="s0">(resolved !== undefined) {</span>
                            <span class="s0">unresolvedKeyframes[i] = resolved;</span>
                        <span class="s0">}</span>
                        <span class="s1">if </span><span class="s0">(i === unresolvedKeyframes.length - </span><span class="s4">1</span><span class="s0">) {</span>
                            <span class="s1">this</span><span class="s0">.finalKeyframe = keyframe;</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s3">/**</span>
             <span class="s3">* Resolve &quot;none&quot; values. We do this potentially twice - once before and once after measuring keyframes.</span>
             <span class="s3">* This could be seen as inefficient but it's a trade-off to avoid measurements in more situations, which</span>
             <span class="s3">* have a far bigger performance impact.</span>
             <span class="s3">*/</span>
            <span class="s1">this</span><span class="s0">.resolveNoneKeyframes();</span>
            <span class="s3">/**</span>
             <span class="s3">* Check to see if unit type has changed. If so schedule jobs that will</span>
             <span class="s3">* temporarily set styles to the destination keyframes.</span>
             <span class="s3">* Skip if we have more than two keyframes or this isn't a positional value.</span>
             <span class="s3">* TODO: We can throw if there are multiple keyframes and the value type changes.</span>
             <span class="s3">*/</span>
            <span class="s1">if </span><span class="s0">(!positionalKeys.has(name) || unresolvedKeyframes.length !== </span><span class="s4">2</span><span class="s0">) {</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">[origin, target] = unresolvedKeyframes;</span>
            <span class="s1">const </span><span class="s0">originType = findDimensionValueType(origin);</span>
            <span class="s1">const </span><span class="s0">targetType = findDimensionValueType(target);</span>
            <span class="s3">/**</span>
             <span class="s3">* Either we don't recognise these value types or we can animate between them.</span>
             <span class="s3">*/</span>
            <span class="s1">if </span><span class="s0">(originType === targetType)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s3">/**</span>
             <span class="s3">* If both values are numbers or pixels, we can animate between them by</span>
             <span class="s3">* converting them to numbers.</span>
             <span class="s3">*/</span>
            <span class="s1">if </span><span class="s0">(isNumOrPxType(originType) &amp;&amp; isNumOrPxType(targetType)) {</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; unresolvedKeyframes.length; i++) {</span>
                    <span class="s1">const </span><span class="s0">value = unresolvedKeyframes[i];</span>
                    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">value === </span><span class="s2">&quot;string&quot;</span><span class="s0">) {</span>
                        <span class="s0">unresolvedKeyframes[i] = parseFloat(value);</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">else if </span><span class="s0">(positionalValues[name]) {</span>
                <span class="s3">/**</span>
                 <span class="s3">* Else, the only way to resolve this is by measuring the element.</span>
                 <span class="s3">*/</span>
                <span class="s1">this</span><span class="s0">.needsMeasurement = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">resolveNoneKeyframes() {</span>
            <span class="s1">const </span><span class="s0">{ unresolvedKeyframes, name } = </span><span class="s1">this</span><span class="s0">;</span>
            <span class="s1">const </span><span class="s0">noneKeyframeIndexes = [];</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; unresolvedKeyframes.length; i++) {</span>
                <span class="s1">if </span><span class="s0">(unresolvedKeyframes[i] === </span><span class="s1">null </span><span class="s0">||</span>
                    <span class="s0">isNone(unresolvedKeyframes[i])) {</span>
                    <span class="s0">noneKeyframeIndexes.push(i);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(noneKeyframeIndexes.length) {</span>
                <span class="s0">makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">measureInitialState() {</span>
            <span class="s1">const </span><span class="s0">{ element, unresolvedKeyframes, name } = </span><span class="s1">this</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(!element || !element.current)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(name === </span><span class="s2">&quot;height&quot;</span><span class="s0">) {</span>
                <span class="s1">this</span><span class="s0">.suspendedScrollY = window.pageYOffset;</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));</span>
            <span class="s0">unresolvedKeyframes[</span><span class="s4">0</span><span class="s0">] = </span><span class="s1">this</span><span class="s0">.measuredOrigin;</span>
            <span class="s3">// Set final key frame to measure after next render</span>
            <span class="s1">const </span><span class="s0">measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - </span><span class="s4">1</span><span class="s0">];</span>
            <span class="s1">if </span><span class="s0">(measureKeyframe !== undefined) {</span>
                <span class="s0">element.getValue(name, measureKeyframe).jump(measureKeyframe, </span><span class="s1">false</span><span class="s0">);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">measureEndState() {</span>
            <span class="s1">const </span><span class="s0">{ element, name, unresolvedKeyframes } = </span><span class="s1">this</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(!element || !element.current)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">const </span><span class="s0">value = element.getValue(name);</span>
            <span class="s0">value &amp;&amp; value.jump(</span><span class="s1">this</span><span class="s0">.measuredOrigin, </span><span class="s1">false</span><span class="s0">);</span>
            <span class="s1">const </span><span class="s0">finalKeyframeIndex = unresolvedKeyframes.length - </span><span class="s4">1</span><span class="s0">;</span>
            <span class="s1">const </span><span class="s0">finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];</span>
            <span class="s0">unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));</span>
            <span class="s1">if </span><span class="s0">(finalKeyframe !== </span><span class="s1">null </span><span class="s0">&amp;&amp; </span><span class="s1">this</span><span class="s0">.finalKeyframe === undefined) {</span>
                <span class="s1">this</span><span class="s0">.finalKeyframe = finalKeyframe;</span>
            <span class="s0">}</span>
            <span class="s3">// If we removed transform values, reapply them before the next render</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.removedTransforms?.length) {</span>
                <span class="s1">this</span><span class="s0">.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) =&gt; {</span>
                    <span class="s0">element</span>
                        <span class="s0">.getValue(unsetTransformName)</span>
                        <span class="s0">.set(unsetTransformValue);</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.resolveNoneKeyframes();</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">pxValues = </span><span class="s1">new </span><span class="s0">Set([</span>
        <span class="s3">// Border props</span>
        <span class="s2">&quot;borderWidth&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;borderTopWidth&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;borderRightWidth&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;borderBottomWidth&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;borderLeftWidth&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;borderRadius&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;radius&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;borderTopLeftRadius&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;borderTopRightRadius&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;borderBottomRightRadius&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;borderBottomLeftRadius&quot;</span><span class="s0">,</span>
        <span class="s3">// Positioning props</span>
        <span class="s2">&quot;width&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;maxWidth&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;height&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;maxHeight&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;top&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;right&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;bottom&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;left&quot;</span><span class="s0">,</span>
        <span class="s3">// Spacing props</span>
        <span class="s2">&quot;padding&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;paddingTop&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;paddingRight&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;paddingBottom&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;paddingLeft&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;margin&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;marginTop&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;marginRight&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;marginBottom&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;marginLeft&quot;</span><span class="s0">,</span>
        <span class="s3">// Misc</span>
        <span class="s2">&quot;backgroundPositionX&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;backgroundPositionY&quot;</span><span class="s0">,</span>
    <span class="s0">]);</span>

    <span class="s1">function </span><span class="s0">applyPxDefaults(keyframes, name) {</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; keyframes.length; i++) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">keyframes[i] === </span><span class="s2">&quot;number&quot; </span><span class="s0">&amp;&amp; pxValues.has(name)) {</span>
                <span class="s0">keyframes[i] = keyframes[i] + </span><span class="s2">&quot;px&quot;</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">isWaapiSupportedEasing(easing) {</span>
        <span class="s1">return </span><span class="s0">Boolean((</span><span class="s1">typeof </span><span class="s0">easing === </span><span class="s2">&quot;function&quot; </span><span class="s0">&amp;&amp; supportsLinearEasing()) ||</span>
            <span class="s0">!easing ||</span>
            <span class="s0">(</span><span class="s1">typeof </span><span class="s0">easing === </span><span class="s2">&quot;string&quot; </span><span class="s0">&amp;&amp;</span>
                <span class="s0">(easing </span><span class="s1">in </span><span class="s0">supportedWaapiEasing || supportsLinearEasing())) ||</span>
            <span class="s0">motionUtils.isBezierDefinition(easing) ||</span>
            <span class="s0">(Array.isArray(easing) &amp;&amp; easing.every(isWaapiSupportedEasing)));</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">supportsPartialKeyframes = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">motionUtils.memo(() =&gt; {</span>
        <span class="s1">try </span><span class="s0">{</span>
            <span class="s0">document.createElement(</span><span class="s2">&quot;div&quot;</span><span class="s0">).animate({ opacity: [</span><span class="s4">1</span><span class="s0">] });</span>
        <span class="s0">}</span>
        <span class="s1">catch </span><span class="s0">(e) {</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">});</span>

    <span class="s3">/**</span>
     <span class="s3">* A list of values that can be hardware-accelerated.</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">acceleratedValues = </span><span class="s1">new </span><span class="s0">Set([</span>
        <span class="s2">&quot;opacity&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;clipPath&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;filter&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;transform&quot;</span><span class="s0">,</span>
        <span class="s3">// TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved</span>
        <span class="s3">// or until we implement support for linear() easing.</span>
        <span class="s3">// &quot;background-color&quot;</span>
    <span class="s0">]);</span>

    <span class="s1">function </span><span class="s0">camelToDash(str) {</span>
        <span class="s1">return </span><span class="s0">str.replace(</span><span class="s5">/([A-Z])/g</span><span class="s0">, (match) =&gt; </span><span class="s2">`-</span><span class="s0">${match.toLowerCase()}</span><span class="s2">`</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">resolveElements(elementOrSelector, scope, selectorCache) {</span>
        <span class="s1">if </span><span class="s0">(elementOrSelector </span><span class="s1">instanceof </span><span class="s0">EventTarget) {</span>
            <span class="s1">return </span><span class="s0">[elementOrSelector];</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">elementOrSelector === </span><span class="s2">&quot;string&quot;</span><span class="s0">) {</span>
            <span class="s1">let </span><span class="s0">root = document;</span>
            <span class="s1">if </span><span class="s0">(scope) {</span>
                <span class="s0">root = scope.current;</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">elements = selectorCache?.[elementOrSelector] ??</span>
                <span class="s0">root.querySelectorAll(elementOrSelector);</span>
            <span class="s1">return </span><span class="s0">elements ? Array.from(elements) : [];</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">Array.from(elementOrSelector);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">createSelectorEffect(subjectEffect) {</span>
        <span class="s1">return </span><span class="s0">(subject, values) =&gt; {</span>
            <span class="s1">const </span><span class="s0">elements = resolveElements(subject);</span>
            <span class="s1">const </span><span class="s0">subscriptions = [];</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">element of elements) {</span>
                <span class="s1">const </span><span class="s0">remove = subjectEffect(element, values);</span>
                <span class="s0">subscriptions.push(remove);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">() =&gt; {</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">remove of subscriptions)</span>
                    <span class="s0">remove();</span>
            <span class="s0">};</span>
        <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Provided a value and a ValueType, returns the value as that value type.</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">getValueAsType = (value, type) =&gt; {</span>
        <span class="s1">return </span><span class="s0">type &amp;&amp; </span><span class="s1">typeof </span><span class="s0">value === </span><span class="s2">&quot;number&quot;</span>
            <span class="s0">? type.transform(value)</span>
            <span class="s0">: value;</span>
    <span class="s0">};</span>

    <span class="s1">class </span><span class="s0">MotionValueState {</span>
        <span class="s0">constructor() {</span>
            <span class="s1">this</span><span class="s0">.latest = {};</span>
            <span class="s1">this</span><span class="s0">.values = </span><span class="s1">new </span><span class="s0">Map();</span>
        <span class="s0">}</span>
        <span class="s0">set(name, value, render, computed, useDefaultValueType = </span><span class="s1">true</span><span class="s0">) {</span>
            <span class="s1">const </span><span class="s0">existingValue = </span><span class="s1">this</span><span class="s0">.values.get(name);</span>
            <span class="s1">if </span><span class="s0">(existingValue) {</span>
                <span class="s0">existingValue.onRemove();</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">onChange = () =&gt; {</span>
                <span class="s1">const </span><span class="s0">v = value.get();</span>
                <span class="s1">if </span><span class="s0">(useDefaultValueType) {</span>
                    <span class="s1">this</span><span class="s0">.latest[name] = getValueAsType(v, numberValueTypes[name]);</span>
                <span class="s0">}</span>
                <span class="s1">else </span><span class="s0">{</span>
                    <span class="s1">this</span><span class="s0">.latest[name] = v;</span>
                <span class="s0">}</span>
                <span class="s0">render &amp;&amp; frame.render(render);</span>
            <span class="s0">};</span>
            <span class="s0">onChange();</span>
            <span class="s1">const </span><span class="s0">cancelOnChange = value.on(</span><span class="s2">&quot;change&quot;</span><span class="s0">, onChange);</span>
            <span class="s0">computed &amp;&amp; value.addDependent(computed);</span>
            <span class="s1">const </span><span class="s0">remove = () =&gt; {</span>
                <span class="s0">cancelOnChange();</span>
                <span class="s0">render &amp;&amp; cancelFrame(render);</span>
                <span class="s1">this</span><span class="s0">.values.delete(name);</span>
                <span class="s0">computed &amp;&amp; value.removeDependent(computed);</span>
            <span class="s0">};</span>
            <span class="s1">this</span><span class="s0">.values.set(name, { value, onRemove: remove });</span>
            <span class="s1">return </span><span class="s0">remove;</span>
        <span class="s0">}</span>
        <span class="s0">get(name) {</span>
            <span class="s1">return this</span><span class="s0">.values.get(name)?.value;</span>
        <span class="s0">}</span>
        <span class="s0">destroy() {</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">value of </span><span class="s1">this</span><span class="s0">.values.values()) {</span>
                <span class="s0">value.onRemove();</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">createEffect(addValue) {</span>
        <span class="s1">const </span><span class="s0">stateCache = </span><span class="s1">new </span><span class="s0">WeakMap();</span>
        <span class="s1">const </span><span class="s0">subscriptions = [];</span>
        <span class="s1">return </span><span class="s0">(subject, values) =&gt; {</span>
            <span class="s1">const </span><span class="s0">state = stateCache.get(subject) ?? </span><span class="s1">new </span><span class="s0">MotionValueState();</span>
            <span class="s0">stateCache.set(subject, state);</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in </span><span class="s0">values) {</span>
                <span class="s1">const </span><span class="s0">value = values[key];</span>
                <span class="s1">const </span><span class="s0">remove = addValue(subject, state, key, value);</span>
                <span class="s0">subscriptions.push(remove);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">() =&gt; {</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">cancel of subscriptions)</span>
                    <span class="s0">cancel();</span>
            <span class="s0">};</span>
        <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">canSetAsProperty(element, name) {</span>
        <span class="s1">if </span><span class="s0">(!(name </span><span class="s1">in </span><span class="s0">element))</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">descriptor = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(element), name) ||</span>
            <span class="s0">Object.getOwnPropertyDescriptor(element, name);</span>
        <span class="s3">// Check if it has a setter</span>
        <span class="s1">return </span><span class="s0">descriptor &amp;&amp; </span><span class="s1">typeof </span><span class="s0">descriptor.set === </span><span class="s2">&quot;function&quot;</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">addAttrValue = (element, state, key, value) =&gt; {</span>
        <span class="s1">const </span><span class="s0">isProp = canSetAsProperty(element, key);</span>
        <span class="s1">const </span><span class="s0">name = isProp</span>
            <span class="s0">? key</span>
            <span class="s0">: key.startsWith(</span><span class="s2">&quot;data&quot;</span><span class="s0">) || key.startsWith(</span><span class="s2">&quot;aria&quot;</span><span class="s0">)</span>
                <span class="s0">? camelToDash(key)</span>
                <span class="s0">: key;</span>
        <span class="s3">/**</span>
         <span class="s3">* Set attribute directly via property if available</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">render = isProp</span>
            <span class="s0">? () =&gt; {</span>
                <span class="s0">element[name] = state.latest[key];</span>
            <span class="s0">}</span>
            <span class="s0">: () =&gt; {</span>
                <span class="s1">const </span><span class="s0">v = state.latest[key];</span>
                <span class="s1">if </span><span class="s0">(v === </span><span class="s1">null </span><span class="s0">|| v === undefined) {</span>
                    <span class="s0">element.removeAttribute(name);</span>
                <span class="s0">}</span>
                <span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">element.setAttribute(name, String(v));</span>
                <span class="s0">}</span>
            <span class="s0">};</span>
        <span class="s1">return </span><span class="s0">state.set(key, value, render);</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">attrEffect = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">createSelectorEffect(</span>
    <span class="s3">/*@__PURE__*/ </span><span class="s0">createEffect(addAttrValue));</span>

    <span class="s1">const </span><span class="s0">propEffect = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">createEffect((subject, state, key, value) =&gt; {</span>
        <span class="s1">return </span><span class="s0">state.set(key, value, () =&gt; {</span>
            <span class="s0">subject[key] = state.latest[key];</span>
        <span class="s0">}, undefined, </span><span class="s1">false</span><span class="s0">);</span>
    <span class="s0">});</span>

    <span class="s3">/**</span>
     <span class="s3">* Checks if an element is an HTML element in a way</span>
     <span class="s3">* that works across iframes</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">isHTMLElement(element) {</span>
        <span class="s1">return </span><span class="s0">motionUtils.isObject(element) &amp;&amp; </span><span class="s2">&quot;offsetHeight&quot; </span><span class="s1">in </span><span class="s0">element;</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Maximum time between the value of two frames, beyond which we</span>
     <span class="s3">* assume the velocity has since been 0.</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">MAX_VELOCITY_DELTA = </span><span class="s4">30</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">isFloat = (value) =&gt; {</span>
        <span class="s1">return </span><span class="s0">!isNaN(parseFloat(value));</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">collectMotionValues = {</span>
        <span class="s0">current: undefined,</span>
    <span class="s0">};</span>
    <span class="s3">/**</span>
     <span class="s3">* `MotionValue` is used to track the state and velocity of motion values.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s6">@public</span>
     <span class="s3">*/</span>
    <span class="s1">class </span><span class="s0">MotionValue {</span>
        <span class="s3">/**</span>
         <span class="s3">* </span><span class="s6">@param </span><span class="s3">init - The initiating value</span>
         <span class="s3">* </span><span class="s6">@param </span><span class="s3">config - Optional configuration options</span>
         <span class="s3">*</span>
         <span class="s3">* -  `transformer`: A function to transform incoming values with.</span>
         <span class="s3">*/</span>
        <span class="s0">constructor(init, options = {}) {</span>
            <span class="s3">/**</span>
             <span class="s3">* Tracks whether this value can output a velocity. Currently this is only true</span>
             <span class="s3">* if the value is numerical, but we might be able to widen the scope here and support</span>
             <span class="s3">* other value types.</span>
             <span class="s3">*</span>
             <span class="s3">* </span><span class="s6">@internal</span>
             <span class="s3">*/</span>
            <span class="s1">this</span><span class="s0">.canTrackVelocity = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s3">/**</span>
             <span class="s3">* An object containing a SubscriptionManager for each active event.</span>
             <span class="s3">*/</span>
            <span class="s1">this</span><span class="s0">.events = {};</span>
            <span class="s1">this</span><span class="s0">.updateAndNotify = (v) =&gt; {</span>
                <span class="s1">const </span><span class="s0">currentTime = time.now();</span>
                <span class="s3">/**</span>
                 <span class="s3">* If we're updating the value during another frame or eventloop</span>
                 <span class="s3">* than the previous frame, then the we set the previous frame value</span>
                 <span class="s3">* to current.</span>
                 <span class="s3">*/</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.updatedAt !== currentTime) {</span>
                    <span class="s1">this</span><span class="s0">.setPrevFrameValue();</span>
                <span class="s0">}</span>
                <span class="s1">this</span><span class="s0">.prev = </span><span class="s1">this</span><span class="s0">.current;</span>
                <span class="s1">this</span><span class="s0">.setCurrent(v);</span>
                <span class="s3">// Update update subscribers</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.current !== </span><span class="s1">this</span><span class="s0">.prev) {</span>
                    <span class="s1">this</span><span class="s0">.events.change?.notify(</span><span class="s1">this</span><span class="s0">.current);</span>
                    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.dependents) {</span>
                        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">dependent of </span><span class="s1">this</span><span class="s0">.dependents) {</span>
                            <span class="s0">dependent.dirty();</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
            <span class="s0">};</span>
            <span class="s1">this</span><span class="s0">.hasAnimated = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.setCurrent(init);</span>
            <span class="s1">this</span><span class="s0">.owner = options.owner;</span>
        <span class="s0">}</span>
        <span class="s0">setCurrent(current) {</span>
            <span class="s1">this</span><span class="s0">.current = current;</span>
            <span class="s1">this</span><span class="s0">.updatedAt = time.now();</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.canTrackVelocity === </span><span class="s1">null </span><span class="s0">&amp;&amp; current !== undefined) {</span>
                <span class="s1">this</span><span class="s0">.canTrackVelocity = isFloat(</span><span class="s1">this</span><span class="s0">.current);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">setPrevFrameValue(prevFrameValue = </span><span class="s1">this</span><span class="s0">.current) {</span>
            <span class="s1">this</span><span class="s0">.prevFrameValue = prevFrameValue;</span>
            <span class="s1">this</span><span class="s0">.prevUpdatedAt = </span><span class="s1">this</span><span class="s0">.updatedAt;</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Adds a function that will be notified when the `MotionValue` is updated.</span>
         <span class="s3">*</span>
         <span class="s3">* It returns a function that, when called, will cancel the subscription.</span>
         <span class="s3">*</span>
         <span class="s3">* When calling `onChange` inside a React component, it should be wrapped with the</span>
         <span class="s3">* `useEffect` hook. As it returns an unsubscribe function, this should be returned</span>
         <span class="s3">* from the `useEffect` function to ensure you don't add duplicate subscribers..</span>
         <span class="s3">*</span>
         <span class="s3">* ```jsx</span>
         <span class="s3">* export const MyComponent = () =&gt; {</span>
         <span class="s3">*   const x = useMotionValue(0)</span>
         <span class="s3">*   const y = useMotionValue(0)</span>
         <span class="s3">*   const opacity = useMotionValue(1)</span>
         <span class="s3">*</span>
         <span class="s3">*   useEffect(() =&gt; {</span>
         <span class="s3">*     function updateOpacity() {</span>
         <span class="s3">*       const maxXY = Math.max(x.get(), y.get())</span>
         <span class="s3">*       const newOpacity = transform(maxXY, [0, 100], [1, 0])</span>
         <span class="s3">*       opacity.set(newOpacity)</span>
         <span class="s3">*     }</span>
         <span class="s3">*</span>
         <span class="s3">*     const unsubscribeX = x.on(&quot;change&quot;, updateOpacity)</span>
         <span class="s3">*     const unsubscribeY = y.on(&quot;change&quot;, updateOpacity)</span>
         <span class="s3">*</span>
         <span class="s3">*     return () =&gt; {</span>
         <span class="s3">*       unsubscribeX()</span>
         <span class="s3">*       unsubscribeY()</span>
         <span class="s3">*     }</span>
         <span class="s3">*   }, [])</span>
         <span class="s3">*</span>
         <span class="s3">*   return &lt;motion.div style={{ x }} /&gt;</span>
         <span class="s3">* }</span>
         <span class="s3">* ```</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s6">@param </span><span class="s3">subscriber - A function that receives the latest value.</span>
         <span class="s3">* </span><span class="s6">@returns </span><span class="s3">A function that, when called, will cancel this subscription.</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s6">@deprecated</span>
         <span class="s3">*/</span>
        <span class="s0">onChange(subscription) {</span>
            <span class="s0">{</span>
                <span class="s0">motionUtils.warnOnce(</span><span class="s1">false</span><span class="s0">, </span><span class="s2">`value.onChange(callback) is deprecated. Switch to value.on(&quot;change&quot;, callback).`</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">return this</span><span class="s0">.on(</span><span class="s2">&quot;change&quot;</span><span class="s0">, subscription);</span>
        <span class="s0">}</span>
        <span class="s0">on(eventName, callback) {</span>
            <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.events[eventName]) {</span>
                <span class="s1">this</span><span class="s0">.events[eventName] = </span><span class="s1">new </span><span class="s0">motionUtils.SubscriptionManager();</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">unsubscribe = </span><span class="s1">this</span><span class="s0">.events[eventName].add(callback);</span>
            <span class="s1">if </span><span class="s0">(eventName === </span><span class="s2">&quot;change&quot;</span><span class="s0">) {</span>
                <span class="s1">return </span><span class="s0">() =&gt; {</span>
                    <span class="s0">unsubscribe();</span>
                    <span class="s3">/**</span>
                     <span class="s3">* If we have no more change listeners by the start</span>
                     <span class="s3">* of the next frame, stop active animations.</span>
                     <span class="s3">*/</span>
                    <span class="s0">frame.read(() =&gt; {</span>
                        <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.events.change.getSize()) {</span>
                            <span class="s1">this</span><span class="s0">.stop();</span>
                        <span class="s0">}</span>
                    <span class="s0">});</span>
                <span class="s0">};</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">unsubscribe;</span>
        <span class="s0">}</span>
        <span class="s0">clearListeners() {</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">eventManagers </span><span class="s1">in this</span><span class="s0">.events) {</span>
                <span class="s1">this</span><span class="s0">.events[eventManagers].clear();</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Attaches a passive effect to the `MotionValue`.</span>
         <span class="s3">*/</span>
        <span class="s0">attach(passiveEffect, stopPassiveEffect) {</span>
            <span class="s1">this</span><span class="s0">.passiveEffect = passiveEffect;</span>
            <span class="s1">this</span><span class="s0">.stopPassiveEffect = stopPassiveEffect;</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Sets the state of the `MotionValue`.</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s6">@remarks</span>
         <span class="s3">*</span>
         <span class="s3">* ```jsx</span>
         <span class="s3">* const x = useMotionValue(0)</span>
         <span class="s3">* x.set(10)</span>
         <span class="s3">* ```</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s6">@param </span><span class="s3">latest - Latest value to set.</span>
         <span class="s3">* </span><span class="s6">@param </span><span class="s3">render - Whether to notify render subscribers. Defaults to `true`</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s6">@public</span>
         <span class="s3">*/</span>
        <span class="s0">set(v) {</span>
            <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.passiveEffect) {</span>
                <span class="s1">this</span><span class="s0">.updateAndNotify(v);</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">this</span><span class="s0">.passiveEffect(v, </span><span class="s1">this</span><span class="s0">.updateAndNotify);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">setWithVelocity(prev, current, delta) {</span>
            <span class="s1">this</span><span class="s0">.set(current);</span>
            <span class="s1">this</span><span class="s0">.prev = undefined;</span>
            <span class="s1">this</span><span class="s0">.prevFrameValue = prev;</span>
            <span class="s1">this</span><span class="s0">.prevUpdatedAt = </span><span class="s1">this</span><span class="s0">.updatedAt - delta;</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Set the state of the `MotionValue`, stopping any active animations,</span>
         <span class="s3">* effects, and resets velocity to `0`.</span>
         <span class="s3">*/</span>
        <span class="s0">jump(v, endAnimation = </span><span class="s1">true</span><span class="s0">) {</span>
            <span class="s1">this</span><span class="s0">.updateAndNotify(v);</span>
            <span class="s1">this</span><span class="s0">.prev = v;</span>
            <span class="s1">this</span><span class="s0">.prevUpdatedAt = </span><span class="s1">this</span><span class="s0">.prevFrameValue = undefined;</span>
            <span class="s0">endAnimation &amp;&amp; </span><span class="s1">this</span><span class="s0">.stop();</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.stopPassiveEffect)</span>
                <span class="s1">this</span><span class="s0">.stopPassiveEffect();</span>
        <span class="s0">}</span>
        <span class="s0">dirty() {</span>
            <span class="s1">this</span><span class="s0">.events.change?.notify(</span><span class="s1">this</span><span class="s0">.current);</span>
        <span class="s0">}</span>
        <span class="s0">addDependent(dependent) {</span>
            <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.dependents) {</span>
                <span class="s1">this</span><span class="s0">.dependents = </span><span class="s1">new </span><span class="s0">Set();</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.dependents.add(dependent);</span>
        <span class="s0">}</span>
        <span class="s0">removeDependent(dependent) {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.dependents) {</span>
                <span class="s1">this</span><span class="s0">.dependents.delete(dependent);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Returns the latest state of `MotionValue`</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s6">@returns </span><span class="s3">- The latest state of `MotionValue`</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s6">@public</span>
         <span class="s3">*/</span>
        <span class="s0">get() {</span>
            <span class="s1">if </span><span class="s0">(collectMotionValues.current) {</span>
                <span class="s0">collectMotionValues.current.push(</span><span class="s1">this</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">return this</span><span class="s0">.current;</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* </span><span class="s6">@public</span>
         <span class="s3">*/</span>
        <span class="s0">getPrevious() {</span>
            <span class="s1">return this</span><span class="s0">.prev;</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Returns the latest velocity of `MotionValue`</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s6">@returns </span><span class="s3">- The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s6">@public</span>
         <span class="s3">*/</span>
        <span class="s0">getVelocity() {</span>
            <span class="s1">const </span><span class="s0">currentTime = time.now();</span>
            <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.canTrackVelocity ||</span>
                <span class="s1">this</span><span class="s0">.prevFrameValue === undefined ||</span>
                <span class="s0">currentTime - </span><span class="s1">this</span><span class="s0">.updatedAt &gt; MAX_VELOCITY_DELTA) {</span>
                <span class="s1">return </span><span class="s4">0</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">delta = Math.min(</span><span class="s1">this</span><span class="s0">.updatedAt - </span><span class="s1">this</span><span class="s0">.prevUpdatedAt, MAX_VELOCITY_DELTA);</span>
            <span class="s3">// Casts because of parseFloat's poor typing</span>
            <span class="s1">return </span><span class="s0">motionUtils.velocityPerSecond(parseFloat(</span><span class="s1">this</span><span class="s0">.current) -</span>
                <span class="s0">parseFloat(</span><span class="s1">this</span><span class="s0">.prevFrameValue), delta);</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Registers a new animation to control this `MotionValue`. Only one</span>
         <span class="s3">* animation can drive a `MotionValue` at one time.</span>
         <span class="s3">*</span>
         <span class="s3">* ```jsx</span>
         <span class="s3">* value.start()</span>
         <span class="s3">* ```</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s6">@param </span><span class="s3">animation - A function that starts the provided animation</span>
         <span class="s3">*/</span>
        <span class="s0">start(startAnimation) {</span>
            <span class="s1">this</span><span class="s0">.stop();</span>
            <span class="s1">return new </span><span class="s0">Promise((resolve) =&gt; {</span>
                <span class="s1">this</span><span class="s0">.hasAnimated = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s1">this</span><span class="s0">.animation = startAnimation(resolve);</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.events.animationStart) {</span>
                    <span class="s1">this</span><span class="s0">.events.animationStart.notify();</span>
                <span class="s0">}</span>
            <span class="s0">}).then(() =&gt; {</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.events.animationComplete) {</span>
                    <span class="s1">this</span><span class="s0">.events.animationComplete.notify();</span>
                <span class="s0">}</span>
                <span class="s1">this</span><span class="s0">.clearAnimation();</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Stop the currently active animation.</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s6">@public</span>
         <span class="s3">*/</span>
        <span class="s0">stop() {</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.animation) {</span>
                <span class="s1">this</span><span class="s0">.animation.stop();</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.events.animationCancel) {</span>
                    <span class="s1">this</span><span class="s0">.events.animationCancel.notify();</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">this</span><span class="s0">.clearAnimation();</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Returns `true` if this value is currently animating.</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s6">@public</span>
         <span class="s3">*/</span>
        <span class="s0">isAnimating() {</span>
            <span class="s1">return </span><span class="s0">!!</span><span class="s1">this</span><span class="s0">.animation;</span>
        <span class="s0">}</span>
        <span class="s0">clearAnimation() {</span>
            <span class="s1">delete this</span><span class="s0">.animation;</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Destroy and clean up subscribers to this `MotionValue`.</span>
         <span class="s3">*</span>
         <span class="s3">* The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically</span>
         <span class="s3">* handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually</span>
         <span class="s3">* created a `MotionValue` via the `motionValue` function.</span>
         <span class="s3">*</span>
         <span class="s3">* </span><span class="s6">@public</span>
         <span class="s3">*/</span>
        <span class="s0">destroy() {</span>
            <span class="s1">this</span><span class="s0">.dependents?.clear();</span>
            <span class="s1">this</span><span class="s0">.events.destroy?.notify();</span>
            <span class="s1">this</span><span class="s0">.clearListeners();</span>
            <span class="s1">this</span><span class="s0">.stop();</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.stopPassiveEffect) {</span>
                <span class="s1">this</span><span class="s0">.stopPassiveEffect();</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">motionValue(init, options) {</span>
        <span class="s1">return new </span><span class="s0">MotionValue(init, options);</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">translateAlias = {</span>
        <span class="s0">x: </span><span class="s2">&quot;translateX&quot;</span><span class="s0">,</span>
        <span class="s0">y: </span><span class="s2">&quot;translateY&quot;</span><span class="s0">,</span>
        <span class="s0">z: </span><span class="s2">&quot;translateZ&quot;</span><span class="s0">,</span>
        <span class="s0">transformPerspective: </span><span class="s2">&quot;perspective&quot;</span><span class="s0">,</span>
    <span class="s0">};</span>
    <span class="s1">function </span><span class="s0">buildTransform(state) {</span>
        <span class="s1">let </span><span class="s0">transform = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">transformIsDefault = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s3">/**</span>
         <span class="s3">* Loop over all possible transforms in order, adding the ones that</span>
         <span class="s3">* are present to the transform string.</span>
         <span class="s3">*/</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; transformPropOrder.length; i++) {</span>
            <span class="s1">const </span><span class="s0">key = transformPropOrder[i];</span>
            <span class="s1">const </span><span class="s0">value = state.latest[key];</span>
            <span class="s1">if </span><span class="s0">(value === undefined)</span>
                <span class="s1">continue</span><span class="s0">;</span>
            <span class="s1">let </span><span class="s0">valueIsDefault = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">value === </span><span class="s2">&quot;number&quot;</span><span class="s0">) {</span>
                <span class="s0">valueIsDefault = value === (key.startsWith(</span><span class="s2">&quot;scale&quot;</span><span class="s0">) ? </span><span class="s4">1 </span><span class="s0">: </span><span class="s4">0</span><span class="s0">);</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s0">valueIsDefault = parseFloat(value) === </span><span class="s4">0</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(!valueIsDefault) {</span>
                <span class="s0">transformIsDefault = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s1">const </span><span class="s0">transformName = translateAlias[key] || key;</span>
                <span class="s1">const </span><span class="s0">valueToRender = state.latest[key];</span>
                <span class="s0">transform += </span><span class="s2">`</span><span class="s0">${transformName}</span><span class="s2">(</span><span class="s0">${valueToRender}</span><span class="s2">) `</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">transformIsDefault ? </span><span class="s2">&quot;none&quot; </span><span class="s0">: transform.trim();</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">originProps = </span><span class="s1">new </span><span class="s0">Set([</span><span class="s2">&quot;originX&quot;</span><span class="s0">, </span><span class="s2">&quot;originY&quot;</span><span class="s0">, </span><span class="s2">&quot;originZ&quot;</span><span class="s0">]);</span>
    <span class="s1">const </span><span class="s0">addStyleValue = (element, state, key, value) =&gt; {</span>
        <span class="s1">let </span><span class="s0">render = undefined;</span>
        <span class="s1">let </span><span class="s0">computed = undefined;</span>
        <span class="s1">if </span><span class="s0">(transformProps.has(key)) {</span>
            <span class="s1">if </span><span class="s0">(!state.get(</span><span class="s2">&quot;transform&quot;</span><span class="s0">)) {</span>
                <span class="s3">// If this is an HTML element, we need to set the transform-box to fill-box</span>
                <span class="s3">// to normalise the transform relative to the element's bounding box</span>
                <span class="s1">if </span><span class="s0">(!isHTMLElement(element) &amp;&amp; !state.get(</span><span class="s2">&quot;transformBox&quot;</span><span class="s0">)) {</span>
                    <span class="s0">addStyleValue(element, state, </span><span class="s2">&quot;transformBox&quot;</span><span class="s0">, </span><span class="s1">new </span><span class="s0">MotionValue(</span><span class="s2">&quot;fill-box&quot;</span><span class="s0">));</span>
                <span class="s0">}</span>
                <span class="s0">state.set(</span><span class="s2">&quot;transform&quot;</span><span class="s0">, </span><span class="s1">new </span><span class="s0">MotionValue(</span><span class="s2">&quot;none&quot;</span><span class="s0">), () =&gt; {</span>
                    <span class="s0">element.style.transform = buildTransform(state);</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
            <span class="s0">computed = state.get(</span><span class="s2">&quot;transform&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(originProps.has(key)) {</span>
            <span class="s1">if </span><span class="s0">(!state.get(</span><span class="s2">&quot;transformOrigin&quot;</span><span class="s0">)) {</span>
                <span class="s0">state.set(</span><span class="s2">&quot;transformOrigin&quot;</span><span class="s0">, </span><span class="s1">new </span><span class="s0">MotionValue(</span><span class="s2">&quot;&quot;</span><span class="s0">), () =&gt; {</span>
                    <span class="s1">const </span><span class="s0">originX = state.latest.originX ?? </span><span class="s2">&quot;50%&quot;</span><span class="s0">;</span>
                    <span class="s1">const </span><span class="s0">originY = state.latest.originY ?? </span><span class="s2">&quot;50%&quot;</span><span class="s0">;</span>
                    <span class="s1">const </span><span class="s0">originZ = state.latest.originZ ?? </span><span class="s4">0</span><span class="s0">;</span>
                    <span class="s0">element.style.transformOrigin = </span><span class="s2">`</span><span class="s0">${originX} ${originY} ${originZ}</span><span class="s2">`</span><span class="s0">;</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
            <span class="s0">computed = state.get(</span><span class="s2">&quot;transformOrigin&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(isCSSVar(key)) {</span>
            <span class="s0">render = () =&gt; {</span>
                <span class="s0">element.style.setProperty(key, state.latest[key]);</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s0">render = () =&gt; {</span>
                <span class="s0">element.style[key] = state.latest[key];</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">state.set(key, value, render, computed);</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">styleEffect = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">createSelectorEffect(</span>
    <span class="s3">/*@__PURE__*/ </span><span class="s0">createEffect(addStyleValue));</span>

    <span class="s1">const </span><span class="s0">toPx = px.transform;</span>
    <span class="s1">function </span><span class="s0">addSVGPathValue(element, state, key, value) {</span>
        <span class="s0">frame.render(() =&gt; element.setAttribute(</span><span class="s2">&quot;pathLength&quot;</span><span class="s0">, </span><span class="s2">&quot;1&quot;</span><span class="s0">));</span>
        <span class="s1">if </span><span class="s0">(key === </span><span class="s2">&quot;pathOffset&quot;</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">state.set(key, value, () =&gt; element.setAttribute(</span><span class="s2">&quot;stroke-dashoffset&quot;</span><span class="s0">, toPx(-state.latest[key])));</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s1">if </span><span class="s0">(!state.get(</span><span class="s2">&quot;stroke-dasharray&quot;</span><span class="s0">)) {</span>
                <span class="s0">state.set(</span><span class="s2">&quot;stroke-dasharray&quot;</span><span class="s0">, </span><span class="s1">new </span><span class="s0">MotionValue(</span><span class="s2">&quot;1 1&quot;</span><span class="s0">), () =&gt; {</span>
                    <span class="s1">const </span><span class="s0">{ pathLength = </span><span class="s4">1</span><span class="s0">, pathSpacing } = state.latest;</span>
                    <span class="s0">element.setAttribute(</span><span class="s2">&quot;stroke-dasharray&quot;</span><span class="s0">, </span><span class="s2">`</span><span class="s0">${toPx(pathLength)} ${toPx(pathSpacing ?? </span><span class="s4">1 </span><span class="s0">- Number(pathLength))}</span><span class="s2">`</span><span class="s0">);</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">state.set(key, value, undefined, state.get(</span><span class="s2">&quot;stroke-dasharray&quot;</span><span class="s0">));</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">addSVGValue = (element, state, key, value) =&gt; {</span>
        <span class="s1">if </span><span class="s0">(key.startsWith(</span><span class="s2">&quot;path&quot;</span><span class="s0">)) {</span>
            <span class="s1">return </span><span class="s0">addSVGPathValue(element, state, key, value);</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(key.startsWith(</span><span class="s2">&quot;attr&quot;</span><span class="s0">)) {</span>
            <span class="s1">return </span><span class="s0">addAttrValue(element, state, convertAttrKey(key), value);</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">handler = key </span><span class="s1">in </span><span class="s0">element.style ? addStyleValue : addAttrValue;</span>
        <span class="s1">return </span><span class="s0">handler(element, state, key, value);</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">svgEffect = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">createSelectorEffect(</span>
    <span class="s3">/*@__PURE__*/ </span><span class="s0">createEffect(addSVGValue));</span>
    <span class="s1">function </span><span class="s0">convertAttrKey(key) {</span>
        <span class="s1">return </span><span class="s0">key.replace(</span><span class="s5">/^attr([A-Z])/</span><span class="s0">, (_, firstChar) =&gt; firstChar.toLowerCase());</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">{ schedule: microtask, cancel: cancelMicrotask } = </span>
    <span class="s3">/* @__PURE__ */ </span><span class="s0">createRenderBatcher(queueMicrotask, </span><span class="s1">false</span><span class="s0">);</span>

    <span class="s1">const </span><span class="s0">isDragging = {</span>
        <span class="s0">x: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">y: </span><span class="s1">false</span><span class="s0">,</span>
    <span class="s0">};</span>
    <span class="s1">function </span><span class="s0">isDragActive() {</span>
        <span class="s1">return </span><span class="s0">isDragging.x || isDragging.y;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">setDragLock(axis) {</span>
        <span class="s1">if </span><span class="s0">(axis === </span><span class="s2">&quot;x&quot; </span><span class="s0">|| axis === </span><span class="s2">&quot;y&quot;</span><span class="s0">) {</span>
            <span class="s1">if </span><span class="s0">(isDragging[axis]) {</span>
                <span class="s1">return null</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s0">isDragging[axis] = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s1">return </span><span class="s0">() =&gt; {</span>
                    <span class="s0">isDragging[axis] = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s0">};</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s1">if </span><span class="s0">(isDragging.x || isDragging.y) {</span>
                <span class="s1">return null</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s0">isDragging.x = isDragging.y = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s1">return </span><span class="s0">() =&gt; {</span>
                    <span class="s0">isDragging.x = isDragging.y = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s0">};</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">setupGesture(elementOrSelector, options) {</span>
        <span class="s1">const </span><span class="s0">elements = resolveElements(elementOrSelector);</span>
        <span class="s1">const </span><span class="s0">gestureAbortController = </span><span class="s1">new </span><span class="s0">AbortController();</span>
        <span class="s1">const </span><span class="s0">eventOptions = {</span>
            <span class="s0">passive: </span><span class="s1">true</span><span class="s0">,</span>
            <span class="s0">...options,</span>
            <span class="s0">signal: gestureAbortController.signal,</span>
        <span class="s0">};</span>
        <span class="s1">const </span><span class="s0">cancel = () =&gt; gestureAbortController.abort();</span>
        <span class="s1">return </span><span class="s0">[elements, eventOptions, cancel];</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">isValidHover(event) {</span>
        <span class="s1">return </span><span class="s0">!(event.pointerType === </span><span class="s2">&quot;touch&quot; </span><span class="s0">|| isDragActive());</span>
    <span class="s0">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Create a hover gesture. hover() is different to .addEventListener(&quot;pointerenter&quot;)</span>
     <span class="s3">* in that it has an easier syntax, filters out polyfilled touch events, interoperates</span>
     <span class="s3">* with drag gestures, and automatically removes the &quot;pointerennd&quot; event listener when the hover ends.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s6">@public</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">hover(elementOrSelector, onHoverStart, options = {}) {</span>
        <span class="s1">const </span><span class="s0">[elements, eventOptions, cancel] = setupGesture(elementOrSelector, options);</span>
        <span class="s1">const </span><span class="s0">onPointerEnter = (enterEvent) =&gt; {</span>
            <span class="s1">if </span><span class="s0">(!isValidHover(enterEvent))</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">const </span><span class="s0">{ target } = enterEvent;</span>
            <span class="s1">const </span><span class="s0">onHoverEnd = onHoverStart(target, enterEvent);</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">onHoverEnd !== </span><span class="s2">&quot;function&quot; </span><span class="s0">|| !target)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">const </span><span class="s0">onPointerLeave = (leaveEvent) =&gt; {</span>
                <span class="s1">if </span><span class="s0">(!isValidHover(leaveEvent))</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s0">onHoverEnd(leaveEvent);</span>
                <span class="s0">target.removeEventListener(</span><span class="s2">&quot;pointerleave&quot;</span><span class="s0">, onPointerLeave);</span>
            <span class="s0">};</span>
            <span class="s0">target.addEventListener(</span><span class="s2">&quot;pointerleave&quot;</span><span class="s0">, onPointerLeave, eventOptions);</span>
        <span class="s0">};</span>
        <span class="s0">elements.forEach((element) =&gt; {</span>
            <span class="s0">element.addEventListener(</span><span class="s2">&quot;pointerenter&quot;</span><span class="s0">, onPointerEnter, eventOptions);</span>
        <span class="s0">});</span>
        <span class="s1">return </span><span class="s0">cancel;</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Recursively traverse up the tree to check whether the provided child node</span>
     <span class="s3">* is the parent or a descendant of it.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s6">@param </span><span class="s3">parent - Element to find</span>
     <span class="s3">* </span><span class="s6">@param </span><span class="s3">child - Element to test against parent</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">isNodeOrChild = (parent, child) =&gt; {</span>
        <span class="s1">if </span><span class="s0">(!child) {</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(parent === child) {</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s1">return </span><span class="s0">isNodeOrChild(parent, child.parentElement);</span>
        <span class="s0">}</span>
    <span class="s0">};</span>

    <span class="s1">const </span><span class="s0">isPrimaryPointer = (event) =&gt; {</span>
        <span class="s1">if </span><span class="s0">(event.pointerType === </span><span class="s2">&quot;mouse&quot;</span><span class="s0">) {</span>
            <span class="s1">return typeof </span><span class="s0">event.button !== </span><span class="s2">&quot;number&quot; </span><span class="s0">|| event.button &lt;= </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s3">/**</span>
             <span class="s3">* isPrimary is true for all mice buttons, whereas every touch point</span>
             <span class="s3">* is regarded as its own input. So subsequent concurrent touch points</span>
             <span class="s3">* will be false.</span>
             <span class="s3">*</span>
             <span class="s3">* Specifically match against false here as incomplete versions of</span>
             <span class="s3">* PointerEvents in very old browser might have it set as undefined.</span>
             <span class="s3">*/</span>
            <span class="s1">return </span><span class="s0">event.isPrimary !== </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">};</span>

    <span class="s1">const </span><span class="s0">focusableElements = </span><span class="s1">new </span><span class="s0">Set([</span>
        <span class="s2">&quot;BUTTON&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;INPUT&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;SELECT&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;TEXTAREA&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;A&quot;</span><span class="s0">,</span>
    <span class="s0">]);</span>
    <span class="s1">function </span><span class="s0">isElementKeyboardAccessible(element) {</span>
        <span class="s1">return </span><span class="s0">(focusableElements.has(element.tagName) ||</span>
            <span class="s0">element.tabIndex !== -</span><span class="s4">1</span><span class="s0">);</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">isPressing = </span><span class="s1">new </span><span class="s0">WeakSet();</span>

    <span class="s3">/**</span>
     <span class="s3">* Filter out events that are not &quot;Enter&quot; keys.</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">filterEvents(callback) {</span>
        <span class="s1">return </span><span class="s0">(event) =&gt; {</span>
            <span class="s1">if </span><span class="s0">(event.key !== </span><span class="s2">&quot;Enter&quot;</span><span class="s0">)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s0">callback(event);</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">firePointerEvent(target, type) {</span>
        <span class="s0">target.dispatchEvent(</span><span class="s1">new </span><span class="s0">PointerEvent(</span><span class="s2">&quot;pointer&quot; </span><span class="s0">+ type, { isPrimary: </span><span class="s1">true</span><span class="s0">, bubbles: </span><span class="s1">true </span><span class="s0">}));</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">enableKeyboardPress = (focusEvent, eventOptions) =&gt; {</span>
        <span class="s1">const </span><span class="s0">element = focusEvent.currentTarget;</span>
        <span class="s1">if </span><span class="s0">(!element)</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">handleKeydown = filterEvents(() =&gt; {</span>
            <span class="s1">if </span><span class="s0">(isPressing.has(element))</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s0">firePointerEvent(element, </span><span class="s2">&quot;down&quot;</span><span class="s0">);</span>
            <span class="s1">const </span><span class="s0">handleKeyup = filterEvents(() =&gt; {</span>
                <span class="s0">firePointerEvent(element, </span><span class="s2">&quot;up&quot;</span><span class="s0">);</span>
            <span class="s0">});</span>
            <span class="s1">const </span><span class="s0">handleBlur = () =&gt; firePointerEvent(element, </span><span class="s2">&quot;cancel&quot;</span><span class="s0">);</span>
            <span class="s0">element.addEventListener(</span><span class="s2">&quot;keyup&quot;</span><span class="s0">, handleKeyup, eventOptions);</span>
            <span class="s0">element.addEventListener(</span><span class="s2">&quot;blur&quot;</span><span class="s0">, handleBlur, eventOptions);</span>
        <span class="s0">});</span>
        <span class="s0">element.addEventListener(</span><span class="s2">&quot;keydown&quot;</span><span class="s0">, handleKeydown, eventOptions);</span>
        <span class="s3">/**</span>
         <span class="s3">* Add an event listener that fires on blur to remove the keydown events.</span>
         <span class="s3">*/</span>
        <span class="s0">element.addEventListener(</span><span class="s2">&quot;blur&quot;</span><span class="s0">, () =&gt; element.removeEventListener(</span><span class="s2">&quot;keydown&quot;</span><span class="s0">, handleKeydown), eventOptions);</span>
    <span class="s0">};</span>

    <span class="s3">/**</span>
     <span class="s3">* Filter out events that are not primary pointer events, or are triggering</span>
     <span class="s3">* while a Motion gesture is active.</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">isValidPressEvent(event) {</span>
        <span class="s1">return </span><span class="s0">isPrimaryPointer(event) &amp;&amp; !isDragActive();</span>
    <span class="s0">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Create a press gesture.</span>
     <span class="s3">*</span>
     <span class="s3">* Press is different to `&quot;pointerdown&quot;`, `&quot;pointerup&quot;` in that it</span>
     <span class="s3">* automatically filters out secondary pointer events like right</span>
     <span class="s3">* click and multitouch.</span>
     <span class="s3">*</span>
     <span class="s3">* It also adds accessibility support for keyboards, where</span>
     <span class="s3">* an element with a press gesture will receive focus and</span>
     <span class="s3">*  trigger on Enter `&quot;keydown&quot;` and `&quot;keyup&quot;` events.</span>
     <span class="s3">*</span>
     <span class="s3">* This is different to a browser's `&quot;click&quot;` event, which does</span>
     <span class="s3">* respond to keyboards but only for the `&quot;click&quot;` itself, rather</span>
     <span class="s3">* than the press start and end/cancel. The element also needs</span>
     <span class="s3">* to be focusable for this to work, whereas a press gesture will</span>
     <span class="s3">* make an element focusable by default.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s6">@public</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">press(targetOrSelector, onPressStart, options = {}) {</span>
        <span class="s1">const </span><span class="s0">[targets, eventOptions, cancelEvents] = setupGesture(targetOrSelector, options);</span>
        <span class="s1">const </span><span class="s0">startPress = (startEvent) =&gt; {</span>
            <span class="s1">const </span><span class="s0">target = startEvent.currentTarget;</span>
            <span class="s1">if </span><span class="s0">(!isValidPressEvent(startEvent))</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s0">isPressing.add(target);</span>
            <span class="s1">const </span><span class="s0">onPressEnd = onPressStart(target, startEvent);</span>
            <span class="s1">const </span><span class="s0">onPointerEnd = (endEvent, success) =&gt; {</span>
                <span class="s0">window.removeEventListener(</span><span class="s2">&quot;pointerup&quot;</span><span class="s0">, onPointerUp);</span>
                <span class="s0">window.removeEventListener(</span><span class="s2">&quot;pointercancel&quot;</span><span class="s0">, onPointerCancel);</span>
                <span class="s1">if </span><span class="s0">(isPressing.has(target)) {</span>
                    <span class="s0">isPressing.delete(target);</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(!isValidPressEvent(endEvent)) {</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">onPressEnd === </span><span class="s2">&quot;function&quot;</span><span class="s0">) {</span>
                    <span class="s0">onPressEnd(endEvent, { success });</span>
                <span class="s0">}</span>
            <span class="s0">};</span>
            <span class="s1">const </span><span class="s0">onPointerUp = (upEvent) =&gt; {</span>
                <span class="s0">onPointerEnd(upEvent, target === window ||</span>
                    <span class="s0">target === document ||</span>
                    <span class="s0">options.useGlobalTarget ||</span>
                    <span class="s0">isNodeOrChild(target, upEvent.target));</span>
            <span class="s0">};</span>
            <span class="s1">const </span><span class="s0">onPointerCancel = (cancelEvent) =&gt; {</span>
                <span class="s0">onPointerEnd(cancelEvent, </span><span class="s1">false</span><span class="s0">);</span>
            <span class="s0">};</span>
            <span class="s0">window.addEventListener(</span><span class="s2">&quot;pointerup&quot;</span><span class="s0">, onPointerUp, eventOptions);</span>
            <span class="s0">window.addEventListener(</span><span class="s2">&quot;pointercancel&quot;</span><span class="s0">, onPointerCancel, eventOptions);</span>
        <span class="s0">};</span>
        <span class="s0">targets.forEach((target) =&gt; {</span>
            <span class="s1">const </span><span class="s0">pointerDownTarget = options.useGlobalTarget ? window : target;</span>
            <span class="s0">pointerDownTarget.addEventListener(</span><span class="s2">&quot;pointerdown&quot;</span><span class="s0">, startPress, eventOptions);</span>
            <span class="s1">if </span><span class="s0">(isHTMLElement(target)) {</span>
                <span class="s0">target.addEventListener(</span><span class="s2">&quot;focus&quot;</span><span class="s0">, (event) =&gt; enableKeyboardPress(event, eventOptions));</span>
                <span class="s1">if </span><span class="s0">(!isElementKeyboardAccessible(target) &amp;&amp;</span>
                    <span class="s0">!target.hasAttribute(</span><span class="s2">&quot;tabindex&quot;</span><span class="s0">)) {</span>
                    <span class="s0">target.tabIndex = </span><span class="s4">0</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
        <span class="s1">return </span><span class="s0">cancelEvents;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">getComputedStyle$1(element, name) {</span>
        <span class="s1">const </span><span class="s0">computedStyle = window.getComputedStyle(element);</span>
        <span class="s1">return </span><span class="s0">isCSSVar(name)</span>
            <span class="s0">? computedStyle.getPropertyValue(name)</span>
            <span class="s0">: computedStyle[name];</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Checks if an element is an SVG element in a way</span>
     <span class="s3">* that works across iframes</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">isSVGElement(element) {</span>
        <span class="s1">return </span><span class="s0">motionUtils.isObject(element) &amp;&amp; </span><span class="s2">&quot;ownerSVGElement&quot; </span><span class="s1">in </span><span class="s0">element;</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">resizeHandlers = </span><span class="s1">new </span><span class="s0">WeakMap();</span>
    <span class="s1">let </span><span class="s0">observer;</span>
    <span class="s1">const </span><span class="s0">getSize = (borderBoxAxis, svgAxis, htmlAxis) =&gt; (target, borderBoxSize) =&gt; {</span>
        <span class="s1">if </span><span class="s0">(borderBoxSize &amp;&amp; borderBoxSize[</span><span class="s4">0</span><span class="s0">]) {</span>
            <span class="s1">return </span><span class="s0">borderBoxSize[</span><span class="s4">0</span><span class="s0">][(borderBoxAxis + </span><span class="s2">&quot;Size&quot;</span><span class="s0">)];</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(isSVGElement(target) &amp;&amp; </span><span class="s2">&quot;getBBox&quot; </span><span class="s1">in </span><span class="s0">target) {</span>
            <span class="s1">return </span><span class="s0">target.getBBox()[svgAxis];</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s1">return </span><span class="s0">target[htmlAxis];</span>
        <span class="s0">}</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">getWidth = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">getSize(</span><span class="s2">&quot;inline&quot;</span><span class="s0">, </span><span class="s2">&quot;width&quot;</span><span class="s0">, </span><span class="s2">&quot;offsetWidth&quot;</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">getHeight = </span><span class="s3">/*@__PURE__*/ </span><span class="s0">getSize(</span><span class="s2">&quot;block&quot;</span><span class="s0">, </span><span class="s2">&quot;height&quot;</span><span class="s0">, </span><span class="s2">&quot;offsetHeight&quot;</span><span class="s0">);</span>
    <span class="s1">function </span><span class="s0">notifyTarget({ target, borderBoxSize }) {</span>
        <span class="s0">resizeHandlers.get(target)?.forEach((handler) =&gt; {</span>
            <span class="s0">handler(target, {</span>
                <span class="s0">get width() {</span>
                    <span class="s1">return </span><span class="s0">getWidth(target, borderBoxSize);</span>
                <span class="s0">},</span>
                <span class="s0">get height() {</span>
                    <span class="s1">return </span><span class="s0">getHeight(target, borderBoxSize);</span>
                <span class="s0">},</span>
            <span class="s0">});</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">notifyAll(entries) {</span>
        <span class="s0">entries.forEach(notifyTarget);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">createResizeObserver() {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">ResizeObserver === </span><span class="s2">&quot;undefined&quot;</span><span class="s0">)</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s0">observer = </span><span class="s1">new </span><span class="s0">ResizeObserver(notifyAll);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">resizeElement(target, handler) {</span>
        <span class="s1">if </span><span class="s0">(!observer)</span>
            <span class="s0">createResizeObserver();</span>
        <span class="s1">const </span><span class="s0">elements = resolveElements(target);</span>
        <span class="s0">elements.forEach((element) =&gt; {</span>
            <span class="s1">let </span><span class="s0">elementHandlers = resizeHandlers.get(element);</span>
            <span class="s1">if </span><span class="s0">(!elementHandlers) {</span>
                <span class="s0">elementHandlers = </span><span class="s1">new </span><span class="s0">Set();</span>
                <span class="s0">resizeHandlers.set(element, elementHandlers);</span>
            <span class="s0">}</span>
            <span class="s0">elementHandlers.add(handler);</span>
            <span class="s0">observer?.observe(element);</span>
        <span class="s0">});</span>
        <span class="s1">return </span><span class="s0">() =&gt; {</span>
            <span class="s0">elements.forEach((element) =&gt; {</span>
                <span class="s1">const </span><span class="s0">elementHandlers = resizeHandlers.get(element);</span>
                <span class="s0">elementHandlers?.delete(handler);</span>
                <span class="s1">if </span><span class="s0">(!elementHandlers?.size) {</span>
                    <span class="s0">observer?.unobserve(element);</span>
                <span class="s0">}</span>
            <span class="s0">});</span>
        <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">windowCallbacks = </span><span class="s1">new </span><span class="s0">Set();</span>
    <span class="s1">let </span><span class="s0">windowResizeHandler;</span>
    <span class="s1">function </span><span class="s0">createWindowResizeHandler() {</span>
        <span class="s0">windowResizeHandler = () =&gt; {</span>
            <span class="s1">const </span><span class="s0">info = {</span>
                <span class="s0">get width() {</span>
                    <span class="s1">return </span><span class="s0">window.innerWidth;</span>
                <span class="s0">},</span>
                <span class="s0">get height() {</span>
                    <span class="s1">return </span><span class="s0">window.innerHeight;</span>
                <span class="s0">},</span>
            <span class="s0">};</span>
            <span class="s0">windowCallbacks.forEach((callback) =&gt; callback(info));</span>
        <span class="s0">};</span>
        <span class="s0">window.addEventListener(</span><span class="s2">&quot;resize&quot;</span><span class="s0">, windowResizeHandler);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">resizeWindow(callback) {</span>
        <span class="s0">windowCallbacks.add(callback);</span>
        <span class="s1">if </span><span class="s0">(!windowResizeHandler)</span>
            <span class="s0">createWindowResizeHandler();</span>
        <span class="s1">return </span><span class="s0">() =&gt; {</span>
            <span class="s0">windowCallbacks.delete(callback);</span>
            <span class="s1">if </span><span class="s0">(!windowCallbacks.size &amp;&amp;</span>
                <span class="s1">typeof </span><span class="s0">windowResizeHandler === </span><span class="s2">&quot;function&quot;</span><span class="s0">) {</span>
                <span class="s0">window.removeEventListener(</span><span class="s2">&quot;resize&quot;</span><span class="s0">, windowResizeHandler);</span>
                <span class="s0">windowResizeHandler = undefined;</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">resize(a, b) {</span>
        <span class="s1">return typeof </span><span class="s0">a === </span><span class="s2">&quot;function&quot; </span><span class="s0">? resizeWindow(a) : resizeElement(a, b);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">observeTimeline(update, timeline) {</span>
        <span class="s1">let </span><span class="s0">prevProgress;</span>
        <span class="s1">const </span><span class="s0">onFrame = () =&gt; {</span>
            <span class="s1">const </span><span class="s0">{ currentTime } = timeline;</span>
            <span class="s1">const </span><span class="s0">percentage = currentTime === </span><span class="s1">null </span><span class="s0">? </span><span class="s4">0 </span><span class="s0">: currentTime.value;</span>
            <span class="s1">const </span><span class="s0">progress = percentage / </span><span class="s4">100</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(prevProgress !== progress) {</span>
                <span class="s0">update(progress);</span>
            <span class="s0">}</span>
            <span class="s0">prevProgress = progress;</span>
        <span class="s0">};</span>
        <span class="s0">frame.preUpdate(onFrame, </span><span class="s1">true</span><span class="s0">);</span>
        <span class="s1">return </span><span class="s0">() =&gt; cancelFrame(onFrame);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">record() {</span>
        <span class="s1">const </span><span class="s0">{ value } = statsBuffer;</span>
        <span class="s1">if </span><span class="s0">(value === </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s0">cancelFrame(record);</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">value.frameloop.rate.push(frameData.delta);</span>
        <span class="s0">value.animations.mainThread.push(activeAnimations.mainThread);</span>
        <span class="s0">value.animations.waapi.push(activeAnimations.waapi);</span>
        <span class="s0">value.animations.layout.push(activeAnimations.layout);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">mean(values) {</span>
        <span class="s1">return </span><span class="s0">values.reduce((acc, value) =&gt; acc + value, </span><span class="s4">0</span><span class="s0">) / values.length;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">summarise(values, calcAverage = mean) {</span>
        <span class="s1">if </span><span class="s0">(values.length === </span><span class="s4">0</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">{</span>
                <span class="s0">min: </span><span class="s4">0</span><span class="s0">,</span>
                <span class="s0">max: </span><span class="s4">0</span><span class="s0">,</span>
                <span class="s0">avg: </span><span class="s4">0</span><span class="s0">,</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">min: Math.min(...values),</span>
            <span class="s0">max: Math.max(...values),</span>
            <span class="s0">avg: calcAverage(values),</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">msToFps = (ms) =&gt; Math.round(</span><span class="s4">1000 </span><span class="s0">/ ms);</span>
    <span class="s1">function </span><span class="s0">clearStatsBuffer() {</span>
        <span class="s0">statsBuffer.value = </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s0">statsBuffer.addProjectionMetrics = </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">reportStats() {</span>
        <span class="s1">const </span><span class="s0">{ value } = statsBuffer;</span>
        <span class="s1">if </span><span class="s0">(!value) {</span>
            <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Stats are not being measured&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">clearStatsBuffer();</span>
        <span class="s0">cancelFrame(record);</span>
        <span class="s1">const </span><span class="s0">summary = {</span>
            <span class="s0">frameloop: {</span>
                <span class="s0">setup: summarise(value.frameloop.setup),</span>
                <span class="s0">rate: summarise(value.frameloop.rate),</span>
                <span class="s0">read: summarise(value.frameloop.read),</span>
                <span class="s0">resolveKeyframes: summarise(value.frameloop.resolveKeyframes),</span>
                <span class="s0">preUpdate: summarise(value.frameloop.preUpdate),</span>
                <span class="s0">update: summarise(value.frameloop.update),</span>
                <span class="s0">preRender: summarise(value.frameloop.preRender),</span>
                <span class="s0">render: summarise(value.frameloop.render),</span>
                <span class="s0">postRender: summarise(value.frameloop.postRender),</span>
            <span class="s0">},</span>
            <span class="s0">animations: {</span>
                <span class="s0">mainThread: summarise(value.animations.mainThread),</span>
                <span class="s0">waapi: summarise(value.animations.waapi),</span>
                <span class="s0">layout: summarise(value.animations.layout),</span>
            <span class="s0">},</span>
            <span class="s0">layoutProjection: {</span>
                <span class="s0">nodes: summarise(value.layoutProjection.nodes),</span>
                <span class="s0">calculatedTargetDeltas: summarise(value.layoutProjection.calculatedTargetDeltas),</span>
                <span class="s0">calculatedProjections: summarise(value.layoutProjection.calculatedProjections),</span>
            <span class="s0">},</span>
        <span class="s0">};</span>
        <span class="s3">/**</span>
         <span class="s3">* Convert the rate to FPS</span>
         <span class="s3">*/</span>
        <span class="s1">const </span><span class="s0">{ rate } = summary.frameloop;</span>
        <span class="s0">rate.min = msToFps(rate.min);</span>
        <span class="s0">rate.max = msToFps(rate.max);</span>
        <span class="s0">rate.avg = msToFps(rate.avg);</span>
        <span class="s0">[rate.min, rate.max] = [rate.max, rate.min];</span>
        <span class="s1">return </span><span class="s0">summary;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">recordStats() {</span>
        <span class="s1">if </span><span class="s0">(statsBuffer.value) {</span>
            <span class="s0">clearStatsBuffer();</span>
            <span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Stats are already being measured&quot;</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">newStatsBuffer = statsBuffer;</span>
        <span class="s0">newStatsBuffer.value = {</span>
            <span class="s0">frameloop: {</span>
                <span class="s0">setup: [],</span>
                <span class="s0">rate: [],</span>
                <span class="s0">read: [],</span>
                <span class="s0">resolveKeyframes: [],</span>
                <span class="s0">preUpdate: [],</span>
                <span class="s0">update: [],</span>
                <span class="s0">preRender: [],</span>
                <span class="s0">render: [],</span>
                <span class="s0">postRender: [],</span>
            <span class="s0">},</span>
            <span class="s0">animations: {</span>
                <span class="s0">mainThread: [],</span>
                <span class="s0">waapi: [],</span>
                <span class="s0">layout: [],</span>
            <span class="s0">},</span>
            <span class="s0">layoutProjection: {</span>
                <span class="s0">nodes: [],</span>
                <span class="s0">calculatedTargetDeltas: [],</span>
                <span class="s0">calculatedProjections: [],</span>
            <span class="s0">},</span>
        <span class="s0">};</span>
        <span class="s0">newStatsBuffer.addProjectionMetrics = (metrics) =&gt; {</span>
            <span class="s1">const </span><span class="s0">{ layoutProjection } = newStatsBuffer.value;</span>
            <span class="s0">layoutProjection.nodes.push(metrics.nodes);</span>
            <span class="s0">layoutProjection.calculatedTargetDeltas.push(metrics.calculatedTargetDeltas);</span>
            <span class="s0">layoutProjection.calculatedProjections.push(metrics.calculatedProjections);</span>
        <span class="s0">};</span>
        <span class="s0">frame.postRender(record, </span><span class="s1">true</span><span class="s0">);</span>
        <span class="s1">return </span><span class="s0">reportStats;</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Checks if an element is specifically an SVGSVGElement (the root SVG element)</span>
     <span class="s3">* in a way that works across iframes</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">isSVGSVGElement(element) {</span>
        <span class="s1">return </span><span class="s0">isSVGElement(element) &amp;&amp; element.tagName === </span><span class="s2">&quot;svg&quot;</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">getOriginIndex(from, total) {</span>
        <span class="s1">if </span><span class="s0">(from === </span><span class="s2">&quot;first&quot;</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s1">const </span><span class="s0">lastIndex = total - </span><span class="s4">1</span><span class="s0">;</span>
            <span class="s1">return </span><span class="s0">from === </span><span class="s2">&quot;last&quot; </span><span class="s0">? lastIndex : lastIndex / </span><span class="s4">2</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">stagger(duration = </span><span class="s4">0.1</span><span class="s0">, { startDelay = </span><span class="s4">0</span><span class="s0">, from = </span><span class="s4">0</span><span class="s0">, ease } = {}) {</span>
        <span class="s1">return </span><span class="s0">(i, total) =&gt; {</span>
            <span class="s1">const </span><span class="s0">fromIndex = </span><span class="s1">typeof </span><span class="s0">from === </span><span class="s2">&quot;number&quot; </span><span class="s0">? from : getOriginIndex(from, total);</span>
            <span class="s1">const </span><span class="s0">distance = Math.abs(fromIndex - i);</span>
            <span class="s1">let </span><span class="s0">delay = duration * distance;</span>
            <span class="s1">if </span><span class="s0">(ease) {</span>
                <span class="s1">const </span><span class="s0">maxDelay = total * duration;</span>
                <span class="s1">const </span><span class="s0">easingFunction = motionUtils.easingDefinitionToFunction(ease);</span>
                <span class="s0">delay = easingFunction(delay / maxDelay) * maxDelay;</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">startDelay + delay;</span>
        <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">transform(...args) {</span>
        <span class="s1">const </span><span class="s0">useImmediate = !Array.isArray(args[</span><span class="s4">0</span><span class="s0">]);</span>
        <span class="s1">const </span><span class="s0">argOffset = useImmediate ? </span><span class="s4">0 </span><span class="s0">: -</span><span class="s4">1</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">inputValue = args[</span><span class="s4">0 </span><span class="s0">+ argOffset];</span>
        <span class="s1">const </span><span class="s0">inputRange = args[</span><span class="s4">1 </span><span class="s0">+ argOffset];</span>
        <span class="s1">const </span><span class="s0">outputRange = args[</span><span class="s4">2 </span><span class="s0">+ argOffset];</span>
        <span class="s1">const </span><span class="s0">options = args[</span><span class="s4">3 </span><span class="s0">+ argOffset];</span>
        <span class="s1">const </span><span class="s0">interpolator = interpolate(inputRange, outputRange, options);</span>
        <span class="s1">return </span><span class="s0">useImmediate ? interpolator(inputValue) : interpolator;</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">subscribeValue(inputValues, outputValue, getLatest) {</span>
        <span class="s1">const </span><span class="s0">update = () =&gt; outputValue.set(getLatest());</span>
        <span class="s1">const </span><span class="s0">scheduleUpdate = () =&gt; frame.preRender(update, </span><span class="s1">false</span><span class="s0">, </span><span class="s1">true</span><span class="s0">);</span>
        <span class="s1">const </span><span class="s0">subscriptions = inputValues.map((v) =&gt; v.on(</span><span class="s2">&quot;change&quot;</span><span class="s0">, scheduleUpdate));</span>
        <span class="s0">outputValue.on(</span><span class="s2">&quot;destroy&quot;</span><span class="s0">, () =&gt; {</span>
            <span class="s0">subscriptions.forEach((unsubscribe) =&gt; unsubscribe());</span>
            <span class="s0">cancelFrame(update);</span>
        <span class="s0">});</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Create a `MotionValue` that transforms the output of other `MotionValue`s by</span>
     <span class="s3">* passing their latest values through a transform function.</span>
     <span class="s3">*</span>
     <span class="s3">* Whenever a `MotionValue` referred to in the provided function is updated,</span>
     <span class="s3">* it will be re-evaluated.</span>
     <span class="s3">*</span>
     <span class="s3">* ```jsx</span>
     <span class="s3">* const x = motionValue(0)</span>
     <span class="s3">* const y = transformValue(() =&gt; x.get() * 2) // double x</span>
     <span class="s3">* ```</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s6">@param </span><span class="s3">transformer - A transform function. This function must be pure with no side-effects or conditional statements.</span>
     <span class="s3">* </span><span class="s6">@returns </span><span class="s3">`MotionValue`</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s6">@public</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">transformValue(transform) {</span>
        <span class="s1">const </span><span class="s0">collectedValues = [];</span>
        <span class="s3">/**</span>
         <span class="s3">* Open session of collectMotionValues. Any MotionValue that calls get()</span>
         <span class="s3">* inside transform will be saved into this array.</span>
         <span class="s3">*/</span>
        <span class="s0">collectMotionValues.current = collectedValues;</span>
        <span class="s1">const </span><span class="s0">initialValue = transform();</span>
        <span class="s0">collectMotionValues.current = undefined;</span>
        <span class="s1">const </span><span class="s0">value = motionValue(initialValue);</span>
        <span class="s0">subscribeValue(collectedValues, value, transform);</span>
        <span class="s1">return </span><span class="s0">value;</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Create a `MotionValue` that maps the output of another `MotionValue` by</span>
     <span class="s3">* mapping it from one range of values into another.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s6">@remarks</span>
     <span class="s3">*</span>
     <span class="s3">* Given an input range of `[-200, -100, 100, 200]` and an output range of</span>
     <span class="s3">* `[0, 1, 1, 0]`, the returned `MotionValue` will:</span>
     <span class="s3">*</span>
     <span class="s3">* - When provided a value between `-200` and `-100`, will return a value between `0` and  `1`.</span>
     <span class="s3">* - When provided a value between `-100` and `100`, will return `1`.</span>
     <span class="s3">* - When provided a value between `100` and `200`, will return a value between `1` and  `0`</span>
     <span class="s3">*</span>
     <span class="s3">* The input range must be a linear series of numbers. The output range</span>
     <span class="s3">* can be any value type supported by Motion: numbers, colors, shadows, etc.</span>
     <span class="s3">*</span>
     <span class="s3">* Every value in the output range must be of the same type and in the same format.</span>
     <span class="s3">*</span>
     <span class="s3">* ```jsx</span>
     <span class="s3">* const x = motionValue(0)</span>
     <span class="s3">* const xRange = [-200, -100, 100, 200]</span>
     <span class="s3">* const opacityRange = [0, 1, 1, 0]</span>
     <span class="s3">* const opacity = mapValue(x, xRange, opacityRange)</span>
     <span class="s3">* ```</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s6">@param </span><span class="s3">inputValue - `MotionValue`</span>
     <span class="s3">* </span><span class="s6">@param </span><span class="s3">inputRange - A linear series of numbers (either all increasing or decreasing)</span>
     <span class="s3">* </span><span class="s6">@param </span><span class="s3">outputRange - A series of numbers, colors or strings. Must be the same length as `inputRange`.</span>
     <span class="s3">* </span><span class="s6">@param </span><span class="s3">options -</span>
     <span class="s3">*</span>
     <span class="s3">*  - clamp: boolean. Clamp values to within the given range. Defaults to `true`</span>
     <span class="s3">*  - ease: EasingFunction[]. Easing functions to use on the interpolations between each value in the input and output ranges. If provided as an array, the array must be one item shorter than the input and output ranges, as the easings apply to the transition between each.</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s6">@returns </span><span class="s3">`MotionValue`</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s6">@public</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">mapValue(inputValue, inputRange, outputRange, options) {</span>
        <span class="s1">const </span><span class="s0">map = transform(inputRange, outputRange, options);</span>
        <span class="s1">return </span><span class="s0">transformValue(() =&gt; map(inputValue.get()));</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">isMotionValue = (value) =&gt; Boolean(value &amp;&amp; value.getVelocity);</span>

    <span class="s3">/**</span>
     <span class="s3">* Create a `MotionValue` that animates to its latest value using a spring.</span>
     <span class="s3">* Can either be a value or track another `MotionValue`.</span>
     <span class="s3">*</span>
     <span class="s3">* ```jsx</span>
     <span class="s3">* const x = motionValue(0)</span>
     <span class="s3">* const y = transformValue(() =&gt; x.get() * 2) // double x</span>
     <span class="s3">* ```</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s6">@param </span><span class="s3">transformer - A transform function. This function must be pure with no side-effects or conditional statements.</span>
     <span class="s3">* </span><span class="s6">@returns </span><span class="s3">`MotionValue`</span>
     <span class="s3">*</span>
     <span class="s3">* </span><span class="s6">@public</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">springValue(source, options) {</span>
        <span class="s1">const </span><span class="s0">initialValue = isMotionValue(source) ? source.get() : source;</span>
        <span class="s1">const </span><span class="s0">value = motionValue(initialValue);</span>
        <span class="s0">attachSpring(value, source, options);</span>
        <span class="s1">return </span><span class="s0">value;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">attachSpring(value, source, options) {</span>
        <span class="s1">const </span><span class="s0">initialValue = value.get();</span>
        <span class="s1">let </span><span class="s0">activeAnimation = </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">latestValue = initialValue;</span>
        <span class="s1">let </span><span class="s0">latestSetter;</span>
        <span class="s1">const </span><span class="s0">unit = </span><span class="s1">typeof </span><span class="s0">initialValue === </span><span class="s2">&quot;string&quot;</span>
            <span class="s0">? initialValue.replace(</span><span class="s5">/[\d.-]/g</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s0">)</span>
            <span class="s0">: undefined;</span>
        <span class="s1">const </span><span class="s0">stopAnimation = () =&gt; {</span>
            <span class="s1">if </span><span class="s0">(activeAnimation) {</span>
                <span class="s0">activeAnimation.stop();</span>
                <span class="s0">activeAnimation = </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
        <span class="s1">const </span><span class="s0">startAnimation = () =&gt; {</span>
            <span class="s0">stopAnimation();</span>
            <span class="s0">activeAnimation = </span><span class="s1">new </span><span class="s0">JSAnimation({</span>
                <span class="s0">keyframes: [asNumber(value.get()), asNumber(latestValue)],</span>
                <span class="s0">velocity: value.getVelocity(),</span>
                <span class="s0">type: </span><span class="s2">&quot;spring&quot;</span><span class="s0">,</span>
                <span class="s0">restDelta: </span><span class="s4">0.001</span><span class="s0">,</span>
                <span class="s0">restSpeed: </span><span class="s4">0.01</span><span class="s0">,</span>
                <span class="s0">...options,</span>
                <span class="s0">onUpdate: latestSetter,</span>
            <span class="s0">});</span>
        <span class="s0">};</span>
        <span class="s0">value.attach((v, set) =&gt; {</span>
            <span class="s0">latestValue = v;</span>
            <span class="s0">latestSetter = (latest) =&gt; set(parseValue(latest, unit));</span>
            <span class="s0">frame.postRender(startAnimation);</span>
            <span class="s1">return </span><span class="s0">value.get();</span>
        <span class="s0">}, stopAnimation);</span>
        <span class="s1">if </span><span class="s0">(isMotionValue(source)) {</span>
            <span class="s1">const </span><span class="s0">removeSourceOnChange = source.on(</span><span class="s2">&quot;change&quot;</span><span class="s0">, (v) =&gt; value.set(parseValue(v, unit)));</span>
            <span class="s1">const </span><span class="s0">removeValueOnDestroy = value.on(</span><span class="s2">&quot;destroy&quot;</span><span class="s0">, removeSourceOnChange);</span>
            <span class="s1">return </span><span class="s0">() =&gt; {</span>
                <span class="s0">removeSourceOnChange();</span>
                <span class="s0">removeValueOnDestroy();</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">stopAnimation;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">parseValue(v, unit) {</span>
        <span class="s1">return </span><span class="s0">unit ? v + unit : v;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">asNumber(v) {</span>
        <span class="s1">return typeof </span><span class="s0">v === </span><span class="s2">&quot;number&quot; </span><span class="s0">? v : parseFloat(v);</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* A list of all ValueTypes</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">valueTypes = [...dimensionValueTypes, color, complex];</span>
    <span class="s3">/**</span>
     <span class="s3">* Tests a value against the list of ValueTypes</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">findValueType = (v) =&gt; valueTypes.find(testValueType(v));</span>

    <span class="s1">function </span><span class="s0">chooseLayerType(valueName) {</span>
        <span class="s1">if </span><span class="s0">(valueName === </span><span class="s2">&quot;layout&quot;</span><span class="s0">)</span>
            <span class="s1">return </span><span class="s2">&quot;group&quot;</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(valueName === </span><span class="s2">&quot;enter&quot; </span><span class="s0">|| valueName === </span><span class="s2">&quot;new&quot;</span><span class="s0">)</span>
            <span class="s1">return </span><span class="s2">&quot;new&quot;</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(valueName === </span><span class="s2">&quot;exit&quot; </span><span class="s0">|| valueName === </span><span class="s2">&quot;old&quot;</span><span class="s0">)</span>
            <span class="s1">return </span><span class="s2">&quot;old&quot;</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s2">&quot;group&quot;</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">let </span><span class="s0">pendingRules = {};</span>
    <span class="s1">let </span><span class="s0">style = </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">css = {</span>
        <span class="s0">set: (selector, values) =&gt; {</span>
            <span class="s0">pendingRules[selector] = values;</span>
        <span class="s0">},</span>
        <span class="s0">commit: () =&gt; {</span>
            <span class="s1">if </span><span class="s0">(!style) {</span>
                <span class="s0">style = document.createElement(</span><span class="s2">&quot;style&quot;</span><span class="s0">);</span>
                <span class="s0">style.id = </span><span class="s2">&quot;motion-view&quot;</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s1">let </span><span class="s0">cssText = </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">selector </span><span class="s1">in </span><span class="s0">pendingRules) {</span>
                <span class="s1">const </span><span class="s0">rule = pendingRules[selector];</span>
                <span class="s0">cssText += </span><span class="s2">`</span><span class="s0">${selector} </span><span class="s2">{</span><span class="s7">\n</span><span class="s2">`</span><span class="s0">;</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">[property, value] of Object.entries(rule)) {</span>
                    <span class="s0">cssText += </span><span class="s2">`  </span><span class="s0">${property}</span><span class="s2">: </span><span class="s0">${value}</span><span class="s2">;</span><span class="s7">\n</span><span class="s2">`</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s0">cssText += </span><span class="s2">&quot;}</span><span class="s7">\n</span><span class="s2">&quot;</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s0">style.textContent = cssText;</span>
            <span class="s0">document.head.appendChild(style);</span>
            <span class="s0">pendingRules = {};</span>
        <span class="s0">},</span>
        <span class="s0">remove: () =&gt; {</span>
            <span class="s1">if </span><span class="s0">(style &amp;&amp; style.parentElement) {</span>
                <span class="s0">style.parentElement.removeChild(style);</span>
            <span class="s0">}</span>
        <span class="s0">},</span>
    <span class="s0">};</span>

    <span class="s1">function </span><span class="s0">getViewAnimationLayerInfo(pseudoElement) {</span>
        <span class="s1">const </span><span class="s0">match = pseudoElement.match(</span><span class="s5">/::view-transition-(old|new|group|image-pair)\((.*?)\)/</span><span class="s0">);</span>
        <span class="s1">if </span><span class="s0">(!match)</span>
            <span class="s1">return null</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">{ layer: match[</span><span class="s4">2</span><span class="s0">], type: match[</span><span class="s4">1</span><span class="s0">] };</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">filterViewAnimations(animation) {</span>
        <span class="s1">const </span><span class="s0">{ effect } = animation;</span>
        <span class="s1">if </span><span class="s0">(!effect)</span>
            <span class="s1">return false</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">(effect.target === document.documentElement &amp;&amp;</span>
            <span class="s0">effect.pseudoElement?.startsWith(</span><span class="s2">&quot;::view-transition&quot;</span><span class="s0">));</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">getViewAnimations() {</span>
        <span class="s1">return </span><span class="s0">document.getAnimations().filter(filterViewAnimations);</span>
    <span class="s0">}</span>

    <span class="s1">function </span><span class="s0">hasTarget(target, targets) {</span>
        <span class="s1">return </span><span class="s0">targets.has(target) &amp;&amp; Object.keys(targets.get(target)).length &gt; </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">definitionNames = [</span><span class="s2">&quot;layout&quot;</span><span class="s0">, </span><span class="s2">&quot;enter&quot;</span><span class="s0">, </span><span class="s2">&quot;exit&quot;</span><span class="s0">, </span><span class="s2">&quot;new&quot;</span><span class="s0">, </span><span class="s2">&quot;old&quot;</span><span class="s0">];</span>
    <span class="s1">function </span><span class="s0">startViewAnimation(builder) {</span>
        <span class="s1">const </span><span class="s0">{ update, targets, options: defaultOptions } = builder;</span>
        <span class="s1">if </span><span class="s0">(!document.startViewTransition) {</span>
            <span class="s1">return new </span><span class="s0">Promise(async (resolve) =&gt; {</span>
                <span class="s1">await </span><span class="s0">update();</span>
                <span class="s0">resolve(</span><span class="s1">new </span><span class="s0">GroupAnimation([]));</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s3">// TODO: Go over existing targets and ensure they all have ids</span>
        <span class="s3">/**</span>
         <span class="s3">* If we don't have any animations defined for the root target,</span>
         <span class="s3">* remove it from being captured.</span>
         <span class="s3">*/</span>
        <span class="s1">if </span><span class="s0">(!hasTarget(</span><span class="s2">&quot;root&quot;</span><span class="s0">, targets)) {</span>
            <span class="s0">css.set(</span><span class="s2">&quot;:root&quot;</span><span class="s0">, {</span>
                <span class="s2">&quot;view-transition-name&quot;</span><span class="s0">: </span><span class="s2">&quot;none&quot;</span><span class="s0">,</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Set the timing curve to linear for all view transition layers.</span>
         <span class="s3">* This gets baked into the keyframes, which can't be changed</span>
         <span class="s3">* without breaking the generated animation.</span>
         <span class="s3">*</span>
         <span class="s3">* This allows us to set easing via updateTiming - which can be changed.</span>
         <span class="s3">*/</span>
        <span class="s0">css.set(</span><span class="s2">&quot;::view-transition-group(*), ::view-transition-old(*), ::view-transition-new(*)&quot;</span><span class="s0">, { </span><span class="s2">&quot;animation-timing-function&quot;</span><span class="s0">: </span><span class="s2">&quot;linear !important&quot; </span><span class="s0">});</span>
        <span class="s0">css.commit(); </span><span class="s3">// Write</span>
        <span class="s1">const </span><span class="s0">transition = document.startViewTransition(async () =&gt; {</span>
            <span class="s1">await </span><span class="s0">update();</span>
            <span class="s3">// TODO: Go over new targets and ensure they all have ids</span>
        <span class="s0">});</span>
        <span class="s0">transition.finished.finally(() =&gt; {</span>
            <span class="s0">css.remove(); </span><span class="s3">// Write</span>
        <span class="s0">});</span>
        <span class="s1">return new </span><span class="s0">Promise((resolve) =&gt; {</span>
            <span class="s0">transition.ready.then(() =&gt; {</span>
                <span class="s1">const </span><span class="s0">generatedViewAnimations = getViewAnimations();</span>
                <span class="s1">const </span><span class="s0">animations = [];</span>
                <span class="s3">/**</span>
                 <span class="s3">* Create animations for each of our explicitly-defined subjects.</span>
                 <span class="s3">*/</span>
                <span class="s0">targets.forEach((definition, target) =&gt; {</span>
                    <span class="s3">// TODO: If target is not &quot;root&quot;, resolve elements</span>
                    <span class="s3">// and iterate over each</span>
                    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">key of definitionNames) {</span>
                        <span class="s1">if </span><span class="s0">(!definition[key])</span>
                            <span class="s1">continue</span><span class="s0">;</span>
                        <span class="s1">const </span><span class="s0">{ keyframes, options } = definition[key];</span>
                        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">[valueName, valueKeyframes] of Object.entries(keyframes)) {</span>
                            <span class="s1">if </span><span class="s0">(!valueKeyframes)</span>
                                <span class="s1">continue</span><span class="s0">;</span>
                            <span class="s1">const </span><span class="s0">valueOptions = {</span>
                                <span class="s0">...getValueTransition(defaultOptions, valueName),</span>
                                <span class="s0">...getValueTransition(options, valueName),</span>
                            <span class="s0">};</span>
                            <span class="s1">const </span><span class="s0">type = chooseLayerType(key);</span>
                            <span class="s3">/**</span>
                             <span class="s3">* If this is an opacity animation, and keyframes are not an array,</span>
                             <span class="s3">* we need to convert them into an array and set an initial value.</span>
                             <span class="s3">*/</span>
                            <span class="s1">if </span><span class="s0">(valueName === </span><span class="s2">&quot;opacity&quot; </span><span class="s0">&amp;&amp;</span>
                                <span class="s0">!Array.isArray(valueKeyframes)) {</span>
                                <span class="s1">const </span><span class="s0">initialValue = type === </span><span class="s2">&quot;new&quot; </span><span class="s0">? </span><span class="s4">0 </span><span class="s0">: </span><span class="s4">1</span><span class="s0">;</span>
                                <span class="s0">valueKeyframes = [initialValue, valueKeyframes];</span>
                            <span class="s0">}</span>
                            <span class="s3">/**</span>
                             <span class="s3">* Resolve stagger function if provided.</span>
                             <span class="s3">*/</span>
                            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">valueOptions.delay === </span><span class="s2">&quot;function&quot;</span><span class="s0">) {</span>
                                <span class="s0">valueOptions.delay = valueOptions.delay(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">);</span>
                            <span class="s0">}</span>
                            <span class="s0">valueOptions.duration &amp;&amp; (valueOptions.duration = motionUtils.secondsToMilliseconds(valueOptions.duration));</span>
                            <span class="s0">valueOptions.delay &amp;&amp; (valueOptions.delay = motionUtils.secondsToMilliseconds(valueOptions.delay));</span>
                            <span class="s1">const </span><span class="s0">animation = </span><span class="s1">new </span><span class="s0">NativeAnimation({</span>
                                <span class="s0">...valueOptions,</span>
                                <span class="s0">element: document.documentElement,</span>
                                <span class="s0">name: valueName,</span>
                                <span class="s0">pseudoElement: </span><span class="s2">`::view-transition-</span><span class="s0">${type}</span><span class="s2">(</span><span class="s0">${target}</span><span class="s2">)`</span><span class="s0">,</span>
                                <span class="s0">keyframes: valueKeyframes,</span>
                            <span class="s0">});</span>
                            <span class="s0">animations.push(animation);</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                <span class="s0">});</span>
                <span class="s3">/**</span>
                 <span class="s3">* Handle browser generated animations</span>
                 <span class="s3">*/</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">animation of generatedViewAnimations) {</span>
                    <span class="s1">if </span><span class="s0">(animation.playState === </span><span class="s2">&quot;finished&quot;</span><span class="s0">)</span>
                        <span class="s1">continue</span><span class="s0">;</span>
                    <span class="s1">const </span><span class="s0">{ effect } = animation;</span>
                    <span class="s1">if </span><span class="s0">(!effect || !(effect </span><span class="s1">instanceof </span><span class="s0">KeyframeEffect))</span>
                        <span class="s1">continue</span><span class="s0">;</span>
                    <span class="s1">const </span><span class="s0">{ pseudoElement } = effect;</span>
                    <span class="s1">if </span><span class="s0">(!pseudoElement)</span>
                        <span class="s1">continue</span><span class="s0">;</span>
                    <span class="s1">const </span><span class="s0">name = getViewAnimationLayerInfo(pseudoElement);</span>
                    <span class="s1">if </span><span class="s0">(!name)</span>
                        <span class="s1">continue</span><span class="s0">;</span>
                    <span class="s1">const </span><span class="s0">targetDefinition = targets.get(name.layer);</span>
                    <span class="s1">if </span><span class="s0">(!targetDefinition) {</span>
                        <span class="s3">/**</span>
                         <span class="s3">* If transition name is group then update the timing of the animation</span>
                         <span class="s3">* whereas if it's old or new then we could possibly replace it using</span>
                         <span class="s3">* the above method.</span>
                         <span class="s3">*/</span>
                        <span class="s1">const </span><span class="s0">transitionName = name.type === </span><span class="s2">&quot;group&quot; </span><span class="s0">? </span><span class="s2">&quot;layout&quot; </span><span class="s0">: </span><span class="s2">&quot;&quot;</span><span class="s0">;</span>
                        <span class="s1">let </span><span class="s0">animationTransition = {</span>
                            <span class="s0">...getValueTransition(defaultOptions, transitionName),</span>
                        <span class="s0">};</span>
                        <span class="s0">animationTransition.duration &amp;&amp; (animationTransition.duration = motionUtils.secondsToMilliseconds(animationTransition.duration));</span>
                        <span class="s0">animationTransition =</span>
                            <span class="s0">applyGeneratorOptions(animationTransition);</span>
                        <span class="s1">const </span><span class="s0">easing = mapEasingToNativeEasing(animationTransition.ease, animationTransition.duration);</span>
                        <span class="s0">effect.updateTiming({</span>
                            <span class="s0">delay: motionUtils.secondsToMilliseconds(animationTransition.delay ?? </span><span class="s4">0</span><span class="s0">),</span>
                            <span class="s0">duration: animationTransition.duration,</span>
                            <span class="s0">easing,</span>
                        <span class="s0">});</span>
                        <span class="s0">animations.push(</span><span class="s1">new </span><span class="s0">NativeAnimationWrapper(animation));</span>
                    <span class="s0">}</span>
                    <span class="s1">else if </span><span class="s0">(hasOpacity(targetDefinition, </span><span class="s2">&quot;enter&quot;</span><span class="s0">) &amp;&amp;</span>
                        <span class="s0">hasOpacity(targetDefinition, </span><span class="s2">&quot;exit&quot;</span><span class="s0">) &amp;&amp;</span>
                        <span class="s0">effect</span>
                            <span class="s0">.getKeyframes()</span>
                            <span class="s0">.some((keyframe) =&gt; keyframe.mixBlendMode)) {</span>
                        <span class="s0">animations.push(</span><span class="s1">new </span><span class="s0">NativeAnimationWrapper(animation));</span>
                    <span class="s0">}</span>
                    <span class="s1">else </span><span class="s0">{</span>
                        <span class="s0">animation.cancel();</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
                <span class="s0">resolve(</span><span class="s1">new </span><span class="s0">GroupAnimation(animations));</span>
            <span class="s0">});</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">hasOpacity(target, key) {</span>
        <span class="s1">return </span><span class="s0">target?.[key]?.keyframes.opacity;</span>
    <span class="s0">}</span>

    <span class="s1">let </span><span class="s0">builders = [];</span>
    <span class="s1">let </span><span class="s0">current = </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s1">function </span><span class="s0">next() {</span>
        <span class="s0">current = </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">[nextBuilder] = builders;</span>
        <span class="s1">if </span><span class="s0">(nextBuilder)</span>
            <span class="s0">start(nextBuilder);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">start(builder) {</span>
        <span class="s0">motionUtils.removeItem(builders, builder);</span>
        <span class="s0">current = builder;</span>
        <span class="s0">startViewAnimation(builder).then((animation) =&gt; {</span>
            <span class="s0">builder.notifyReady(animation);</span>
            <span class="s0">animation.finished.finally(next);</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">processQueue() {</span>
        <span class="s3">/**</span>
         <span class="s3">* Iterate backwards over the builders array. We can ignore the</span>
         <span class="s3">* &quot;wait&quot; animations. If we have an interrupting animation in the</span>
         <span class="s3">* queue then we need to batch all preceeding animations into it.</span>
         <span class="s3">* Currently this only batches the update functions but will also</span>
         <span class="s3">* need to batch the targets.</span>
         <span class="s3">*/</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = builders.length - </span><span class="s4">1</span><span class="s0">; i &gt;= </span><span class="s4">0</span><span class="s0">; i--) {</span>
            <span class="s1">const </span><span class="s0">builder = builders[i];</span>
            <span class="s1">const </span><span class="s0">{ interrupt } = builder.options;</span>
            <span class="s1">if </span><span class="s0">(interrupt === </span><span class="s2">&quot;immediate&quot;</span><span class="s0">) {</span>
                <span class="s1">const </span><span class="s0">batchedUpdates = builders.slice(</span><span class="s4">0</span><span class="s0">, i + </span><span class="s4">1</span><span class="s0">).map((b) =&gt; b.update);</span>
                <span class="s1">const </span><span class="s0">remaining = builders.slice(i + </span><span class="s4">1</span><span class="s0">);</span>
                <span class="s0">builder.update = () =&gt; {</span>
                    <span class="s0">batchedUpdates.forEach((update) =&gt; update());</span>
                <span class="s0">};</span>
                <span class="s3">// Put the current builder at the front, followed by any &quot;wait&quot; builders</span>
                <span class="s0">builders = [builder, ...remaining];</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(!current || builders[</span><span class="s4">0</span><span class="s0">]?.options.interrupt === </span><span class="s2">&quot;immediate&quot;</span><span class="s0">) {</span>
            <span class="s0">next();</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">addToQueue(builder) {</span>
        <span class="s0">builders.push(builder);</span>
        <span class="s0">microtask.render(processQueue);</span>
    <span class="s0">}</span>

    <span class="s1">class </span><span class="s0">ViewTransitionBuilder {</span>
        <span class="s0">constructor(update, options = {}) {</span>
            <span class="s1">this</span><span class="s0">.currentSubject = </span><span class="s2">&quot;root&quot;</span><span class="s0">;</span>
            <span class="s1">this</span><span class="s0">.targets = </span><span class="s1">new </span><span class="s0">Map();</span>
            <span class="s1">this</span><span class="s0">.notifyReady = motionUtils.noop;</span>
            <span class="s1">this</span><span class="s0">.readyPromise = </span><span class="s1">new </span><span class="s0">Promise((resolve) =&gt; {</span>
                <span class="s1">this</span><span class="s0">.notifyReady = resolve;</span>
            <span class="s0">});</span>
            <span class="s1">this</span><span class="s0">.update = update;</span>
            <span class="s1">this</span><span class="s0">.options = {</span>
                <span class="s0">interrupt: </span><span class="s2">&quot;wait&quot;</span><span class="s0">,</span>
                <span class="s0">...options,</span>
            <span class="s0">};</span>
            <span class="s0">addToQueue(</span><span class="s1">this</span><span class="s0">);</span>
        <span class="s0">}</span>
        <span class="s0">get(subject) {</span>
            <span class="s1">this</span><span class="s0">.currentSubject = subject;</span>
            <span class="s1">return this</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">layout(keyframes, options) {</span>
            <span class="s1">this</span><span class="s0">.updateTarget(</span><span class="s2">&quot;layout&quot;</span><span class="s0">, keyframes, options);</span>
            <span class="s1">return this</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">new</span><span class="s0">(keyframes, options) {</span>
            <span class="s1">this</span><span class="s0">.updateTarget(</span><span class="s2">&quot;new&quot;</span><span class="s0">, keyframes, options);</span>
            <span class="s1">return this</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">old(keyframes, options) {</span>
            <span class="s1">this</span><span class="s0">.updateTarget(</span><span class="s2">&quot;old&quot;</span><span class="s0">, keyframes, options);</span>
            <span class="s1">return this</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">enter(keyframes, options) {</span>
            <span class="s1">this</span><span class="s0">.updateTarget(</span><span class="s2">&quot;enter&quot;</span><span class="s0">, keyframes, options);</span>
            <span class="s1">return this</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">exit(keyframes, options) {</span>
            <span class="s1">this</span><span class="s0">.updateTarget(</span><span class="s2">&quot;exit&quot;</span><span class="s0">, keyframes, options);</span>
            <span class="s1">return this</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">crossfade(options) {</span>
            <span class="s1">this</span><span class="s0">.updateTarget(</span><span class="s2">&quot;enter&quot;</span><span class="s0">, { opacity: </span><span class="s4">1 </span><span class="s0">}, options);</span>
            <span class="s1">this</span><span class="s0">.updateTarget(</span><span class="s2">&quot;exit&quot;</span><span class="s0">, { opacity: </span><span class="s4">0 </span><span class="s0">}, options);</span>
            <span class="s1">return this</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">updateTarget(target, keyframes, options = {}) {</span>
            <span class="s1">const </span><span class="s0">{ currentSubject, targets } = </span><span class="s1">this</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(!targets.has(currentSubject)) {</span>
                <span class="s0">targets.set(currentSubject, {});</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">targetData = targets.get(currentSubject);</span>
            <span class="s0">targetData[target] = { keyframes, options };</span>
        <span class="s0">}</span>
        <span class="s0">then(resolve, reject) {</span>
            <span class="s1">return this</span><span class="s0">.readyPromise.then(resolve, reject);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">animateView(update, defaultOptions = {}) {</span>
        <span class="s1">return new </span><span class="s0">ViewTransitionBuilder(update, defaultOptions);</span>
    <span class="s0">}</span>

    <span class="s3">/**</span>
     <span class="s3">* </span><span class="s6">@deprecated</span>
     <span class="s3">*</span>
     <span class="s3">* Import as `frame` instead.</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">sync = frame;</span>
    <span class="s3">/**</span>
     <span class="s3">* </span><span class="s6">@deprecated</span>
     <span class="s3">*</span>
     <span class="s3">* Use cancelFrame(callback) instead.</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">cancelSync = stepsOrder.reduce((acc, key) =&gt; {</span>
        <span class="s0">acc[key] = (process) =&gt; cancelFrame(process);</span>
        <span class="s1">return </span><span class="s0">acc;</span>
    <span class="s0">}, {});</span>

    <span class="s0">exports.AsyncMotionValueAnimation = AsyncMotionValueAnimation;</span>
    <span class="s0">exports.DOMKeyframesResolver = DOMKeyframesResolver;</span>
    <span class="s0">exports.GroupAnimation = GroupAnimation;</span>
    <span class="s0">exports.GroupAnimationWithThen = GroupAnimationWithThen;</span>
    <span class="s0">exports.JSAnimation = JSAnimation;</span>
    <span class="s0">exports.KeyframeResolver = KeyframeResolver;</span>
    <span class="s0">exports.MotionValue = MotionValue;</span>
    <span class="s0">exports.NativeAnimation = NativeAnimation;</span>
    <span class="s0">exports.NativeAnimationExtended = NativeAnimationExtended;</span>
    <span class="s0">exports.NativeAnimationWrapper = NativeAnimationWrapper;</span>
    <span class="s0">exports.ViewTransitionBuilder = ViewTransitionBuilder;</span>
    <span class="s0">exports.acceleratedValues = acceleratedValues;</span>
    <span class="s0">exports.activeAnimations = activeAnimations;</span>
    <span class="s0">exports.addAttrValue = addAttrValue;</span>
    <span class="s0">exports.addStyleValue = addStyleValue;</span>
    <span class="s0">exports.alpha = alpha;</span>
    <span class="s0">exports.analyseComplexValue = analyseComplexValue;</span>
    <span class="s0">exports.animateValue = animateValue;</span>
    <span class="s0">exports.animateView = animateView;</span>
    <span class="s0">exports.animationMapKey = animationMapKey;</span>
    <span class="s0">exports.applyGeneratorOptions = applyGeneratorOptions;</span>
    <span class="s0">exports.applyPxDefaults = applyPxDefaults;</span>
    <span class="s0">exports.attachSpring = attachSpring;</span>
    <span class="s0">exports.attrEffect = attrEffect;</span>
    <span class="s0">exports.calcGeneratorDuration = calcGeneratorDuration;</span>
    <span class="s0">exports.cancelFrame = cancelFrame;</span>
    <span class="s0">exports.cancelMicrotask = cancelMicrotask;</span>
    <span class="s0">exports.cancelSync = cancelSync;</span>
    <span class="s0">exports.collectMotionValues = collectMotionValues;</span>
    <span class="s0">exports.color = color;</span>
    <span class="s0">exports.complex = complex;</span>
    <span class="s0">exports.convertOffsetToTimes = convertOffsetToTimes;</span>
    <span class="s0">exports.createGeneratorEasing = createGeneratorEasing;</span>
    <span class="s0">exports.createRenderBatcher = createRenderBatcher;</span>
    <span class="s0">exports.cubicBezierAsString = cubicBezierAsString;</span>
    <span class="s0">exports.defaultEasing = defaultEasing;</span>
    <span class="s0">exports.defaultOffset = defaultOffset;</span>
    <span class="s0">exports.defaultTransformValue = defaultTransformValue;</span>
    <span class="s0">exports.defaultValueTypes = defaultValueTypes;</span>
    <span class="s0">exports.degrees = degrees;</span>
    <span class="s0">exports.dimensionValueTypes = dimensionValueTypes;</span>
    <span class="s0">exports.fillOffset = fillOffset;</span>
    <span class="s0">exports.fillWildcards = fillWildcards;</span>
    <span class="s0">exports.findDimensionValueType = findDimensionValueType;</span>
    <span class="s0">exports.findValueType = findValueType;</span>
    <span class="s0">exports.flushKeyframeResolvers = flushKeyframeResolvers;</span>
    <span class="s0">exports.frame = frame;</span>
    <span class="s0">exports.frameData = frameData;</span>
    <span class="s0">exports.frameSteps = frameSteps;</span>
    <span class="s0">exports.generateLinearEasing = generateLinearEasing;</span>
    <span class="s0">exports.getAnimatableNone = getAnimatableNone;</span>
    <span class="s0">exports.getAnimationMap = getAnimationMap;</span>
    <span class="s0">exports.getComputedStyle = getComputedStyle$1;</span>
    <span class="s0">exports.getDefaultValueType = getDefaultValueType;</span>
    <span class="s0">exports.getMixer = getMixer;</span>
    <span class="s0">exports.getOriginIndex = getOriginIndex;</span>
    <span class="s0">exports.getValueAsType = getValueAsType;</span>
    <span class="s0">exports.getValueTransition = getValueTransition;</span>
    <span class="s0">exports.getVariableValue = getVariableValue;</span>
    <span class="s0">exports.getViewAnimationLayerInfo = getViewAnimationLayerInfo;</span>
    <span class="s0">exports.getViewAnimations = getViewAnimations;</span>
    <span class="s0">exports.hex = hex;</span>
    <span class="s0">exports.hover = hover;</span>
    <span class="s0">exports.hsla = hsla;</span>
    <span class="s0">exports.hslaToRgba = hslaToRgba;</span>
    <span class="s0">exports.inertia = inertia;</span>
    <span class="s0">exports.interpolate = interpolate;</span>
    <span class="s0">exports.invisibleValues = invisibleValues;</span>
    <span class="s0">exports.isCSSVariableName = isCSSVariableName;</span>
    <span class="s0">exports.isCSSVariableToken = isCSSVariableToken;</span>
    <span class="s0">exports.isDragActive = isDragActive;</span>
    <span class="s0">exports.isDragging = isDragging;</span>
    <span class="s0">exports.isGenerator = isGenerator;</span>
    <span class="s0">exports.isHTMLElement = isHTMLElement;</span>
    <span class="s0">exports.isMotionValue = isMotionValue;</span>
    <span class="s0">exports.isNodeOrChild = isNodeOrChild;</span>
    <span class="s0">exports.isPrimaryPointer = isPrimaryPointer;</span>
    <span class="s0">exports.isSVGElement = isSVGElement;</span>
    <span class="s0">exports.isSVGSVGElement = isSVGSVGElement;</span>
    <span class="s0">exports.isWaapiSupportedEasing = isWaapiSupportedEasing;</span>
    <span class="s0">exports.keyframes = keyframes;</span>
    <span class="s0">exports.makeAnimationInstant = makeAnimationInstant;</span>
    <span class="s0">exports.mapEasingToNativeEasing = mapEasingToNativeEasing;</span>
    <span class="s0">exports.mapValue = mapValue;</span>
    <span class="s0">exports.maxGeneratorDuration = maxGeneratorDuration;</span>
    <span class="s0">exports.microtask = microtask;</span>
    <span class="s0">exports.mix = mix;</span>
    <span class="s0">exports.mixArray = mixArray;</span>
    <span class="s0">exports.mixColor = mixColor;</span>
    <span class="s0">exports.mixComplex = mixComplex;</span>
    <span class="s0">exports.mixImmediate = mixImmediate;</span>
    <span class="s0">exports.mixLinearColor = mixLinearColor;</span>
    <span class="s0">exports.mixNumber = mixNumber$1;</span>
    <span class="s0">exports.mixObject = mixObject;</span>
    <span class="s0">exports.mixVisibility = mixVisibility;</span>
    <span class="s0">exports.motionValue = motionValue;</span>
    <span class="s0">exports.number = number;</span>
    <span class="s0">exports.numberValueTypes = numberValueTypes;</span>
    <span class="s0">exports.observeTimeline = observeTimeline;</span>
    <span class="s0">exports.parseCSSVariable = parseCSSVariable;</span>
    <span class="s0">exports.parseValueFromTransform = parseValueFromTransform;</span>
    <span class="s0">exports.percent = percent;</span>
    <span class="s0">exports.positionalKeys = positionalKeys;</span>
    <span class="s0">exports.press = press;</span>
    <span class="s0">exports.progressPercentage = progressPercentage;</span>
    <span class="s0">exports.propEffect = propEffect;</span>
    <span class="s0">exports.px = px;</span>
    <span class="s0">exports.readTransformValue = readTransformValue;</span>
    <span class="s0">exports.recordStats = recordStats;</span>
    <span class="s0">exports.resize = resize;</span>
    <span class="s0">exports.resolveElements = resolveElements;</span>
    <span class="s0">exports.rgbUnit = rgbUnit;</span>
    <span class="s0">exports.rgba = rgba;</span>
    <span class="s0">exports.scale = scale;</span>
    <span class="s0">exports.setDragLock = setDragLock;</span>
    <span class="s0">exports.setStyle = setStyle;</span>
    <span class="s0">exports.spring = spring;</span>
    <span class="s0">exports.springValue = springValue;</span>
    <span class="s0">exports.stagger = stagger;</span>
    <span class="s0">exports.startWaapiAnimation = startWaapiAnimation;</span>
    <span class="s0">exports.statsBuffer = statsBuffer;</span>
    <span class="s0">exports.styleEffect = styleEffect;</span>
    <span class="s0">exports.supportedWaapiEasing = supportedWaapiEasing;</span>
    <span class="s0">exports.supportsBrowserAnimation = supportsBrowserAnimation;</span>
    <span class="s0">exports.supportsFlags = supportsFlags;</span>
    <span class="s0">exports.supportsLinearEasing = supportsLinearEasing;</span>
    <span class="s0">exports.supportsPartialKeyframes = supportsPartialKeyframes;</span>
    <span class="s0">exports.supportsScrollTimeline = supportsScrollTimeline;</span>
    <span class="s0">exports.svgEffect = svgEffect;</span>
    <span class="s0">exports.sync = sync;</span>
    <span class="s0">exports.testValueType = testValueType;</span>
    <span class="s0">exports.time = time;</span>
    <span class="s0">exports.transform = transform;</span>
    <span class="s0">exports.transformPropOrder = transformPropOrder;</span>
    <span class="s0">exports.transformProps = transformProps;</span>
    <span class="s0">exports.transformValue = transformValue;</span>
    <span class="s0">exports.transformValueTypes = transformValueTypes;</span>
    <span class="s0">exports.vh = vh;</span>
    <span class="s0">exports.vw = vw;</span>

<span class="s0">}));</span>
</pre>
</body>
</html>