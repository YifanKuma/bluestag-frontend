<html>
<head>
<title>create.mjs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
create.mjs</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">{ isMotionValue, defaultOffset, isGenerator, createGeneratorEasing, fillOffset } from </span><span class="s2">'motion-dom'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ progress, secondsToMilliseconds, invariant, getEasingForSegment } from </span><span class="s2">'motion-utils'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ resolveSubjects } from </span><span class="s2">'../animate/resolve-subjects.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ calculateRepeatDuration } from </span><span class="s2">'./utils/calc-repeat-duration.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ calcNextTime } from </span><span class="s2">'./utils/calc-time.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ addKeyframes } from </span><span class="s2">'./utils/edit.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ normalizeTimes } from </span><span class="s2">'./utils/normalize-times.mjs'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">{ compareByTime } from </span><span class="s2">'./utils/sort.mjs'</span><span class="s1">;</span>

<span class="s0">const </span><span class="s1">defaultSegmentEasing = </span><span class="s2">&quot;easeInOut&quot;</span><span class="s1">;</span>
<span class="s0">const </span><span class="s1">MAX_REPEAT = </span><span class="s3">20</span><span class="s1">;</span>
<span class="s0">function </span><span class="s1">createAnimationsFromSequence(sequence, { defaultTransition = {}, ...sequenceTransition } = {}, scope, generators) {</span>
    <span class="s0">const </span><span class="s1">defaultDuration = defaultTransition.duration || </span><span class="s3">0.3</span><span class="s1">;</span>
    <span class="s0">const </span><span class="s1">animationDefinitions = </span><span class="s0">new </span><span class="s1">Map();</span>
    <span class="s0">const </span><span class="s1">sequences = </span><span class="s0">new </span><span class="s1">Map();</span>
    <span class="s0">const </span><span class="s1">elementCache = {};</span>
    <span class="s0">const </span><span class="s1">timeLabels = </span><span class="s0">new </span><span class="s1">Map();</span>
    <span class="s0">let </span><span class="s1">prevTime = </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s0">let </span><span class="s1">currentTime = </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s0">let </span><span class="s1">totalDuration = </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s4">/**</span>
     <span class="s4">* Build the timeline by mapping over the sequence array and converting</span>
     <span class="s4">* the definitions into keyframes and offsets with absolute time values.</span>
     <span class="s4">* These will later get converted into relative offsets in a second pass.</span>
     <span class="s4">*/</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">; i &lt; sequence.length; i++) {</span>
        <span class="s0">const </span><span class="s1">segment = sequence[i];</span>
        <span class="s4">/**</span>
         <span class="s4">* If this is a timeline label, mark it and skip the rest of this iteration.</span>
         <span class="s4">*/</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">segment === </span><span class="s2">&quot;string&quot;</span><span class="s1">) {</span>
            <span class="s1">timeLabels.set(segment, currentTime);</span>
            <span class="s0">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s0">else if </span><span class="s1">(!Array.isArray(segment)) {</span>
            <span class="s1">timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));</span>
            <span class="s0">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s0">let </span><span class="s1">[subject, keyframes, transition = {}] = segment;</span>
        <span class="s4">/**</span>
         <span class="s4">* If a relative or absolute time value has been specified we need to resolve</span>
         <span class="s4">* it in relation to the currentTime.</span>
         <span class="s4">*/</span>
        <span class="s0">if </span><span class="s1">(transition.at !== undefined) {</span>
            <span class="s1">currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels);</span>
        <span class="s1">}</span>
        <span class="s4">/**</span>
         <span class="s4">* Keep track of the maximum duration in this definition. This will be</span>
         <span class="s4">* applied to currentTime once the definition has been parsed.</span>
         <span class="s4">*/</span>
        <span class="s0">let </span><span class="s1">maxDuration = </span><span class="s3">0</span><span class="s1">;</span>
        <span class="s0">const </span><span class="s1">resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = </span><span class="s3">0</span><span class="s1">, numSubjects = </span><span class="s3">0</span><span class="s1">) =&gt; {</span>
            <span class="s0">const </span><span class="s1">valueKeyframesAsList = keyframesAsList(valueKeyframes);</span>
            <span class="s0">const </span><span class="s1">{ delay = </span><span class="s3">0</span><span class="s1">, times = defaultOffset(valueKeyframesAsList), type = </span><span class="s2">&quot;keyframes&quot;</span><span class="s1">, repeat, repeatType, repeatDelay = </span><span class="s3">0</span><span class="s1">, ...remainingTransition } = valueTransition;</span>
            <span class="s0">let </span><span class="s1">{ ease = defaultTransition.ease || </span><span class="s2">&quot;easeOut&quot;</span><span class="s1">, duration } = valueTransition;</span>
            <span class="s4">/**</span>
             <span class="s4">* Resolve stagger() if defined.</span>
             <span class="s4">*/</span>
            <span class="s0">const </span><span class="s1">calculatedDelay = </span><span class="s0">typeof </span><span class="s1">delay === </span><span class="s2">&quot;function&quot;</span>
                <span class="s1">? delay(elementIndex, numSubjects)</span>
                <span class="s1">: delay;</span>
            <span class="s4">/**</span>
             <span class="s4">* If this animation should and can use a spring, generate a spring easing function.</span>
             <span class="s4">*/</span>
            <span class="s0">const </span><span class="s1">numKeyframes = valueKeyframesAsList.length;</span>
            <span class="s0">const </span><span class="s1">createGenerator = isGenerator(type)</span>
                <span class="s1">? type</span>
                <span class="s1">: generators?.[type || </span><span class="s2">&quot;keyframes&quot;</span><span class="s1">];</span>
            <span class="s0">if </span><span class="s1">(numKeyframes &lt;= </span><span class="s3">2 </span><span class="s1">&amp;&amp; createGenerator) {</span>
                <span class="s4">/**</span>
                 <span class="s4">* As we're creating an easing function from a spring,</span>
                 <span class="s4">* ideally we want to generate it using the real distance</span>
                 <span class="s4">* between the two keyframes. However this isn't always</span>
                 <span class="s4">* possible - in these situations we use 0-100.</span>
                 <span class="s4">*/</span>
                <span class="s0">let </span><span class="s1">absoluteDelta = </span><span class="s3">100</span><span class="s1">;</span>
                <span class="s0">if </span><span class="s1">(numKeyframes === </span><span class="s3">2 </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">isNumberKeyframesArray(valueKeyframesAsList)) {</span>
                    <span class="s0">const </span><span class="s1">delta = valueKeyframesAsList[</span><span class="s3">1</span><span class="s1">] - valueKeyframesAsList[</span><span class="s3">0</span><span class="s1">];</span>
                    <span class="s1">absoluteDelta = Math.abs(delta);</span>
                <span class="s1">}</span>
                <span class="s0">const </span><span class="s1">springTransition = { ...remainingTransition };</span>
                <span class="s0">if </span><span class="s1">(duration !== undefined) {</span>
                    <span class="s1">springTransition.duration = secondsToMilliseconds(duration);</span>
                <span class="s1">}</span>
                <span class="s0">const </span><span class="s1">springEasing = createGeneratorEasing(springTransition, absoluteDelta, createGenerator);</span>
                <span class="s1">ease = springEasing.ease;</span>
                <span class="s1">duration = springEasing.duration;</span>
            <span class="s1">}</span>
            <span class="s1">duration ?? (duration = defaultDuration);</span>
            <span class="s0">const </span><span class="s1">startTime = currentTime + calculatedDelay;</span>
            <span class="s4">/**</span>
             <span class="s4">* If there's only one time offset of 0, fill in a second with length 1</span>
             <span class="s4">*/</span>
            <span class="s0">if </span><span class="s1">(times.length === </span><span class="s3">1 </span><span class="s1">&amp;&amp; times[</span><span class="s3">0</span><span class="s1">] === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s1">times[</span><span class="s3">1</span><span class="s1">] = </span><span class="s3">1</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">/**</span>
             <span class="s4">* Fill out if offset if fewer offsets than keyframes</span>
             <span class="s4">*/</span>
            <span class="s0">const </span><span class="s1">remainder = times.length - valueKeyframesAsList.length;</span>
            <span class="s1">remainder &gt; </span><span class="s3">0 </span><span class="s1">&amp;&amp; fillOffset(times, remainder);</span>
            <span class="s4">/**</span>
             <span class="s4">* If only one value has been set, ie [1], push a null to the start of</span>
             <span class="s4">* the keyframe array. This will let us mark a keyframe at this point</span>
             <span class="s4">* that will later be hydrated with the previous value.</span>
             <span class="s4">*/</span>
            <span class="s1">valueKeyframesAsList.length === </span><span class="s3">1 </span><span class="s1">&amp;&amp;</span>
                <span class="s1">valueKeyframesAsList.unshift(</span><span class="s0">null</span><span class="s1">);</span>
            <span class="s4">/**</span>
             <span class="s4">* Handle repeat options</span>
             <span class="s4">*/</span>
            <span class="s0">if </span><span class="s1">(repeat) {</span>
                <span class="s1">invariant(repeat &lt; MAX_REPEAT, </span><span class="s2">&quot;Repeat count too high, must be less than 20&quot;</span><span class="s1">, </span><span class="s2">&quot;repeat-count-high&quot;</span><span class="s1">);</span>
                <span class="s1">duration = calculateRepeatDuration(duration, repeat);</span>
                <span class="s0">const </span><span class="s1">originalKeyframes = [...valueKeyframesAsList];</span>
                <span class="s0">const </span><span class="s1">originalTimes = [...times];</span>
                <span class="s1">ease = Array.isArray(ease) ? [...ease] : [ease];</span>
                <span class="s0">const </span><span class="s1">originalEase = [...ease];</span>
                <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">repeatIndex = </span><span class="s3">0</span><span class="s1">; repeatIndex &lt; repeat; repeatIndex++) {</span>
                    <span class="s1">valueKeyframesAsList.push(...originalKeyframes);</span>
                    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">keyframeIndex = </span><span class="s3">0</span><span class="s1">; keyframeIndex &lt; originalKeyframes.length; keyframeIndex++) {</span>
                        <span class="s1">times.push(originalTimes[keyframeIndex] + (repeatIndex + </span><span class="s3">1</span><span class="s1">));</span>
                        <span class="s1">ease.push(keyframeIndex === </span><span class="s3">0</span>
                            <span class="s1">? </span><span class="s2">&quot;linear&quot;</span>
                            <span class="s1">: getEasingForSegment(originalEase, keyframeIndex - </span><span class="s3">1</span><span class="s1">));</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s1">normalizeTimes(times, repeat);</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">targetTime = startTime + duration;</span>
            <span class="s4">/**</span>
             <span class="s4">* Add keyframes, mapping offsets to absolute time.</span>
             <span class="s4">*/</span>
            <span class="s1">addKeyframes(valueSequence, valueKeyframesAsList, ease, times, startTime, targetTime);</span>
            <span class="s1">maxDuration = Math.max(calculatedDelay + duration, maxDuration);</span>
            <span class="s1">totalDuration = Math.max(targetTime, totalDuration);</span>
        <span class="s1">};</span>
        <span class="s0">if </span><span class="s1">(isMotionValue(subject)) {</span>
            <span class="s0">const </span><span class="s1">subjectSequence = getSubjectSequence(subject, sequences);</span>
            <span class="s1">resolveValueSequence(keyframes, transition, getValueSequence(</span><span class="s2">&quot;default&quot;</span><span class="s1">, subjectSequence));</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s0">const </span><span class="s1">subjects = resolveSubjects(subject, keyframes, scope, elementCache);</span>
            <span class="s0">const </span><span class="s1">numSubjects = subjects.length;</span>
            <span class="s4">/**</span>
             <span class="s4">* For every element in this segment, process the defined values.</span>
             <span class="s4">*/</span>
            <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">subjectIndex = </span><span class="s3">0</span><span class="s1">; subjectIndex &lt; numSubjects; subjectIndex++) {</span>
                <span class="s4">/**</span>
                 <span class="s4">* Cast necessary, but we know these are of this type</span>
                 <span class="s4">*/</span>
                <span class="s1">keyframes = keyframes;</span>
                <span class="s1">transition = transition;</span>
                <span class="s0">const </span><span class="s1">thisSubject = subjects[subjectIndex];</span>
                <span class="s0">const </span><span class="s1">subjectSequence = getSubjectSequence(thisSubject, sequences);</span>
                <span class="s0">for </span><span class="s1">(</span><span class="s0">const </span><span class="s1">key </span><span class="s0">in </span><span class="s1">keyframes) {</span>
                    <span class="s1">resolveValueSequence(keyframes[key], getValueTransition(transition, key), getValueSequence(key, subjectSequence), subjectIndex, numSubjects);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">prevTime = currentTime;</span>
        <span class="s1">currentTime += maxDuration;</span>
    <span class="s1">}</span>
    <span class="s4">/**</span>
     <span class="s4">* For every element and value combination create a new animation.</span>
     <span class="s4">*/</span>
    <span class="s1">sequences.forEach((valueSequences, element) =&gt; {</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">const </span><span class="s1">key </span><span class="s0">in </span><span class="s1">valueSequences) {</span>
            <span class="s0">const </span><span class="s1">valueSequence = valueSequences[key];</span>
            <span class="s4">/**</span>
             <span class="s4">* Arrange all the keyframes in ascending time order.</span>
             <span class="s4">*/</span>
            <span class="s1">valueSequence.sort(compareByTime);</span>
            <span class="s0">const </span><span class="s1">keyframes = [];</span>
            <span class="s0">const </span><span class="s1">valueOffset = [];</span>
            <span class="s0">const </span><span class="s1">valueEasing = [];</span>
            <span class="s4">/**</span>
             <span class="s4">* For each keyframe, translate absolute times into</span>
             <span class="s4">* relative offsets based on the total duration of the timeline.</span>
             <span class="s4">*/</span>
            <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">; i &lt; valueSequence.length; i++) {</span>
                <span class="s0">const </span><span class="s1">{ at, value, easing } = valueSequence[i];</span>
                <span class="s1">keyframes.push(value);</span>
                <span class="s1">valueOffset.push(progress(</span><span class="s3">0</span><span class="s1">, totalDuration, at));</span>
                <span class="s1">valueEasing.push(easing || </span><span class="s2">&quot;easeOut&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s4">/**</span>
             <span class="s4">* If the first keyframe doesn't land on offset: 0</span>
             <span class="s4">* provide one by duplicating the initial keyframe. This ensures</span>
             <span class="s4">* it snaps to the first keyframe when the animation starts.</span>
             <span class="s4">*/</span>
            <span class="s0">if </span><span class="s1">(valueOffset[</span><span class="s3">0</span><span class="s1">] !== </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s1">valueOffset.unshift(</span><span class="s3">0</span><span class="s1">);</span>
                <span class="s1">keyframes.unshift(keyframes[</span><span class="s3">0</span><span class="s1">]);</span>
                <span class="s1">valueEasing.unshift(defaultSegmentEasing);</span>
            <span class="s1">}</span>
            <span class="s4">/**</span>
             <span class="s4">* If the last keyframe doesn't land on offset: 1</span>
             <span class="s4">* provide one with a null wildcard value. This will ensure it</span>
             <span class="s4">* stays static until the end of the animation.</span>
             <span class="s4">*/</span>
            <span class="s0">if </span><span class="s1">(valueOffset[valueOffset.length - </span><span class="s3">1</span><span class="s1">] !== </span><span class="s3">1</span><span class="s1">) {</span>
                <span class="s1">valueOffset.push(</span><span class="s3">1</span><span class="s1">);</span>
                <span class="s1">keyframes.push(</span><span class="s0">null</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">(!animationDefinitions.has(element)) {</span>
                <span class="s1">animationDefinitions.set(element, {</span>
                    <span class="s1">keyframes: {},</span>
                    <span class="s1">transition: {},</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">definition = animationDefinitions.get(element);</span>
            <span class="s1">definition.keyframes[key] = keyframes;</span>
            <span class="s1">definition.transition[key] = {</span>
                <span class="s1">...defaultTransition,</span>
                <span class="s1">duration: totalDuration,</span>
                <span class="s1">ease: valueEasing,</span>
                <span class="s1">times: valueOffset,</span>
                <span class="s1">...sequenceTransition,</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s0">return </span><span class="s1">animationDefinitions;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">getSubjectSequence(subject, sequences) {</span>
    <span class="s1">!sequences.has(subject) &amp;&amp; sequences.set(subject, {});</span>
    <span class="s0">return </span><span class="s1">sequences.get(subject);</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">getValueSequence(name, sequences) {</span>
    <span class="s0">if </span><span class="s1">(!sequences[name])</span>
        <span class="s1">sequences[name] = [];</span>
    <span class="s0">return </span><span class="s1">sequences[name];</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">keyframesAsList(keyframes) {</span>
    <span class="s0">return </span><span class="s1">Array.isArray(keyframes) ? keyframes : [keyframes];</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">getValueTransition(transition, key) {</span>
    <span class="s0">return </span><span class="s1">transition &amp;&amp; transition[key]</span>
        <span class="s1">? {</span>
            <span class="s1">...transition,</span>
            <span class="s1">...transition[key],</span>
        <span class="s1">}</span>
        <span class="s1">: { ...transition };</span>
<span class="s1">}</span>
<span class="s0">const </span><span class="s1">isNumber = (keyframe) =&gt; </span><span class="s0">typeof </span><span class="s1">keyframe === </span><span class="s2">&quot;number&quot;</span><span class="s1">;</span>
<span class="s0">const </span><span class="s1">isNumberKeyframesArray = (keyframes) =&gt; keyframes.every(isNumber);</span>

<span class="s0">export </span><span class="s1">{ createAnimationsFromSequence, getValueTransition };</span>
</pre>
</body>
</html>