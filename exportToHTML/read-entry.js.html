<html>
<head>
<title>read-entry.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
read-entry.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
<span class="s1">exports.ReadEntry = </span><span class="s2">void </span><span class="s3">0</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">minipass_1 = require(</span><span class="s0">&quot;minipass&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">normalize_windows_path_js_1 = require(</span><span class="s0">&quot;./normalize-windows-path.js&quot;</span><span class="s1">);</span>
<span class="s2">class </span><span class="s1">ReadEntry </span><span class="s2">extends </span><span class="s1">minipass_1.Minipass {</span>
    <span class="s1">extended;</span>
    <span class="s1">globalExtended;</span>
    <span class="s1">header;</span>
    <span class="s1">startBlockSize;</span>
    <span class="s1">blockRemain;</span>
    <span class="s1">remain;</span>
    <span class="s1">type;</span>
    <span class="s1">meta = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">ignore = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">path;</span>
    <span class="s1">mode;</span>
    <span class="s1">uid;</span>
    <span class="s1">gid;</span>
    <span class="s1">uname;</span>
    <span class="s1">gname;</span>
    <span class="s1">size = </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s1">mtime;</span>
    <span class="s1">atime;</span>
    <span class="s1">ctime;</span>
    <span class="s1">linkpath;</span>
    <span class="s1">dev;</span>
    <span class="s1">ino;</span>
    <span class="s1">nlink;</span>
    <span class="s1">invalid = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">absolute;</span>
    <span class="s1">unsupported = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">constructor(header, ex, gex) {</span>
        <span class="s2">super</span><span class="s1">({});</span>
        <span class="s4">// read entries always start life paused.  this is to avoid the</span>
        <span class="s4">// situation where Minipass's auto-ending empty streams results</span>
        <span class="s4">// in an entry ending before we're ready for it.</span>
        <span class="s2">this</span><span class="s1">.pause();</span>
        <span class="s2">this</span><span class="s1">.extended = ex;</span>
        <span class="s2">this</span><span class="s1">.globalExtended = gex;</span>
        <span class="s2">this</span><span class="s1">.header = header;</span>
        <span class="s4">/* c8 ignore start */</span>
        <span class="s2">this</span><span class="s1">.remain = header.size ?? </span><span class="s3">0</span><span class="s1">;</span>
        <span class="s4">/* c8 ignore stop */</span>
        <span class="s2">this</span><span class="s1">.startBlockSize = </span><span class="s3">512 </span><span class="s1">* Math.ceil(</span><span class="s2">this</span><span class="s1">.remain / </span><span class="s3">512</span><span class="s1">);</span>
        <span class="s2">this</span><span class="s1">.blockRemain = </span><span class="s2">this</span><span class="s1">.startBlockSize;</span>
        <span class="s2">this</span><span class="s1">.type = header.type;</span>
        <span class="s2">switch </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.type) {</span>
            <span class="s2">case </span><span class="s0">'File'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'OldFile'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'Link'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'SymbolicLink'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'CharacterDevice'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'BlockDevice'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'Directory'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'FIFO'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'ContiguousFile'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'GNUDumpDir'</span><span class="s1">:</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s2">case </span><span class="s0">'NextFileHasLongLinkpath'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'NextFileHasLongPath'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'OldGnuLongPath'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'GlobalExtendedHeader'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'ExtendedHeader'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'OldExtendedHeader'</span><span class="s1">:</span>
                <span class="s2">this</span><span class="s1">.meta = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s4">// NOTE: gnutar and bsdtar treat unrecognized types as 'File'</span>
            <span class="s4">// it may be worth doing the same, but with a warning.</span>
            <span class="s2">default</span><span class="s1">:</span>
                <span class="s2">this</span><span class="s1">.ignore = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s4">/* c8 ignore start */</span>
        <span class="s2">if </span><span class="s1">(!header.path) {</span>
            <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'no path provided for tar.ReadEntry'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s4">/* c8 ignore stop */</span>
        <span class="s2">this</span><span class="s1">.path = (</span><span class="s3">0</span><span class="s1">, normalize_windows_path_js_1.normalizeWindowsPath)(header.path);</span>
        <span class="s2">this</span><span class="s1">.mode = header.mode;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.mode) {</span>
            <span class="s2">this</span><span class="s1">.mode = </span><span class="s2">this</span><span class="s1">.mode &amp; </span><span class="s3">0o7777</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.uid = header.uid;</span>
        <span class="s2">this</span><span class="s1">.gid = header.gid;</span>
        <span class="s2">this</span><span class="s1">.uname = header.uname;</span>
        <span class="s2">this</span><span class="s1">.gname = header.gname;</span>
        <span class="s2">this</span><span class="s1">.size = </span><span class="s2">this</span><span class="s1">.remain;</span>
        <span class="s2">this</span><span class="s1">.mtime = header.mtime;</span>
        <span class="s2">this</span><span class="s1">.atime = header.atime;</span>
        <span class="s2">this</span><span class="s1">.ctime = header.ctime;</span>
        <span class="s4">/* c8 ignore start */</span>
        <span class="s2">this</span><span class="s1">.linkpath =</span>
            <span class="s1">header.linkpath ?</span>
                <span class="s1">(</span><span class="s3">0</span><span class="s1">, normalize_windows_path_js_1.normalizeWindowsPath)(header.linkpath)</span>
                <span class="s1">: undefined;</span>
        <span class="s4">/* c8 ignore stop */</span>
        <span class="s2">this</span><span class="s1">.uname = header.uname;</span>
        <span class="s2">this</span><span class="s1">.gname = header.gname;</span>
        <span class="s2">if </span><span class="s1">(ex) {</span>
            <span class="s2">this</span><span class="s1">.#slurp(ex);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(gex) {</span>
            <span class="s2">this</span><span class="s1">.#slurp(gex, </span><span class="s2">true</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">write(data) {</span>
        <span class="s2">const </span><span class="s1">writeLen = data.length;</span>
        <span class="s2">if </span><span class="s1">(writeLen &gt; </span><span class="s2">this</span><span class="s1">.blockRemain) {</span>
            <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">'writing more to entry than is appropriate'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">r = </span><span class="s2">this</span><span class="s1">.remain;</span>
        <span class="s2">const </span><span class="s1">br = </span><span class="s2">this</span><span class="s1">.blockRemain;</span>
        <span class="s2">this</span><span class="s1">.remain = Math.max(</span><span class="s3">0</span><span class="s1">, r - writeLen);</span>
        <span class="s2">this</span><span class="s1">.blockRemain = Math.max(</span><span class="s3">0</span><span class="s1">, br - writeLen);</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.ignore) {</span>
            <span class="s2">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(r &gt;= writeLen) {</span>
            <span class="s2">return super</span><span class="s1">.write(data);</span>
        <span class="s1">}</span>
        <span class="s4">// r &lt; writeLen</span>
        <span class="s2">return super</span><span class="s1">.write(data.subarray(</span><span class="s3">0</span><span class="s1">, r));</span>
    <span class="s1">}</span>
    <span class="s1">#slurp(ex, gex = </span><span class="s2">false</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(ex.path)</span>
            <span class="s1">ex.path = (</span><span class="s3">0</span><span class="s1">, normalize_windows_path_js_1.normalizeWindowsPath)(ex.path);</span>
        <span class="s2">if </span><span class="s1">(ex.linkpath)</span>
            <span class="s1">ex.linkpath = (</span><span class="s3">0</span><span class="s1">, normalize_windows_path_js_1.normalizeWindowsPath)(ex.linkpath);</span>
        <span class="s1">Object.assign(</span><span class="s2">this</span><span class="s1">, Object.fromEntries(Object.entries(ex).filter(([k, v]) =&gt; {</span>
            <span class="s4">// we slurp in everything except for the path attribute in</span>
            <span class="s4">// a global extended header, because that's weird. Also, any</span>
            <span class="s4">// null/undefined values are ignored.</span>
            <span class="s2">return </span><span class="s1">!(v === </span><span class="s2">null </span><span class="s1">||</span>
                <span class="s1">v === undefined ||</span>
                <span class="s1">(k === </span><span class="s0">'path' </span><span class="s1">&amp;&amp; gex));</span>
        <span class="s1">})));</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">exports.ReadEntry = ReadEntry;</span>
<span class="s4">//# sourceMappingURL=read-entry.js.map</span></pre>
</body>
</html>