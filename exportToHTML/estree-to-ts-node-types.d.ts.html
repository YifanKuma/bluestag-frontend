<html>
<head>
<title>estree-to-ts-node-types.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
estree-to-ts-node-types.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">type { AST_NODE_TYPES, TSESTree } from </span><span class="s2">'@typescript-eslint/types'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type * as ts from </span><span class="s2">'typescript'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { TSNode } from </span><span class="s2">'./ts-nodes'</span><span class="s1">;</span>
<span class="s0">export interface </span><span class="s1">EstreeToTsNodeTypes {</span>
    <span class="s1">[AST_NODE_TYPES.AccessorProperty]: ts.PropertyDeclaration;</span>
    <span class="s1">[AST_NODE_TYPES.ArrayExpression]: ts.ArrayLiteralExpression;</span>
    <span class="s1">[AST_NODE_TYPES.ArrayPattern]: ts.ArrayBindingPattern | ts.ArrayLiteralExpression;</span>
    <span class="s1">[AST_NODE_TYPES.ArrowFunctionExpression]: ts.ArrowFunction;</span>
    <span class="s1">[AST_NODE_TYPES.AssignmentExpression]: ts.BinaryExpression;</span>
    <span class="s1">[AST_NODE_TYPES.AssignmentPattern]: ts.BinaryExpression | ts.BindingElement | ts.ParameterDeclaration | ts.ShorthandPropertyAssignment;</span>
    <span class="s1">[AST_NODE_TYPES.AwaitExpression]: ts.AwaitExpression;</span>
    <span class="s1">[AST_NODE_TYPES.BinaryExpression]: ts.BinaryExpression;</span>
    <span class="s1">[AST_NODE_TYPES.BlockStatement]: ts.Block;</span>
    <span class="s1">[AST_NODE_TYPES.BreakStatement]: ts.BreakStatement;</span>
    <span class="s1">[AST_NODE_TYPES.CallExpression]: ts.CallExpression;</span>
    <span class="s1">[AST_NODE_TYPES.CatchClause]: ts.CatchClause;</span>
    <span class="s1">[AST_NODE_TYPES.ChainExpression]: ts.CallExpression | ts.ElementAccessExpression | ts.NonNullExpression | ts.PropertyAccessExpression;</span>
    <span class="s1">[AST_NODE_TYPES.ClassBody]: ts.ClassDeclaration | ts.ClassExpression;</span>
    <span class="s1">[AST_NODE_TYPES.ClassDeclaration]: ts.ClassDeclaration;</span>
    <span class="s1">[AST_NODE_TYPES.ClassExpression]: ts.ClassExpression;</span>
    <span class="s1">[AST_NODE_TYPES.ConditionalExpression]: ts.ConditionalExpression;</span>
    <span class="s1">[AST_NODE_TYPES.ContinueStatement]: ts.ContinueStatement;</span>
    <span class="s1">[AST_NODE_TYPES.DebuggerStatement]: ts.DebuggerStatement;</span>
    <span class="s1">[AST_NODE_TYPES.Decorator]: ts.Decorator;</span>
    <span class="s1">[AST_NODE_TYPES.DoWhileStatement]: ts.DoStatement;</span>
    <span class="s1">[AST_NODE_TYPES.EmptyStatement]: ts.EmptyStatement;</span>
    <span class="s1">[AST_NODE_TYPES.ExportAllDeclaration]: ts.ExportDeclaration;</span>
    <span class="s1">[AST_NODE_TYPES.ExportDefaultDeclaration]: ts.ClassDeclaration | ts.ClassExpression | ts.EnumDeclaration | ts.ExportAssignment | ts.FunctionDeclaration | ts.InterfaceDeclaration | ts.ModuleDeclaration | ts.TypeAliasDeclaration | ts.VariableStatement;</span>
    <span class="s1">[AST_NODE_TYPES.ExportNamedDeclaration]: ts.ClassDeclaration | ts.ClassExpression | ts.EnumDeclaration | ts.ExportDeclaration | ts.FunctionDeclaration | ts.ImportEqualsDeclaration | ts.InterfaceDeclaration | ts.ModuleDeclaration | ts.TypeAliasDeclaration | ts.VariableStatement;</span>
    <span class="s1">[AST_NODE_TYPES.ExportSpecifier]: ts.ExportSpecifier;</span>
    <span class="s1">[AST_NODE_TYPES.ExpressionStatement]: ts.ExpressionStatement;</span>
    <span class="s1">[AST_NODE_TYPES.ForInStatement]: ts.ForInStatement;</span>
    <span class="s1">[AST_NODE_TYPES.ForOfStatement]: ts.ForOfStatement;</span>
    <span class="s1">[AST_NODE_TYPES.ForStatement]: ts.ForStatement;</span>
    <span class="s1">[AST_NODE_TYPES.FunctionDeclaration]: ts.FunctionDeclaration;</span>
    <span class="s1">[AST_NODE_TYPES.FunctionExpression]: ts.ConstructorDeclaration | ts.FunctionExpression | ts.GetAccessorDeclaration | ts.MethodDeclaration | ts.SetAccessorDeclaration;</span>
    <span class="s1">[AST_NODE_TYPES.Identifier]: ts.ConstructorDeclaration | ts.Identifier | ts.Token&lt;ts.SyntaxKind.ImportKeyword | ts.SyntaxKind.NewKeyword&gt;;</span>
    <span class="s1">[AST_NODE_TYPES.IfStatement]: ts.IfStatement;</span>
    <span class="s1">[AST_NODE_TYPES.PrivateIdentifier]: ts.PrivateIdentifier;</span>
    <span class="s1">[AST_NODE_TYPES.PropertyDefinition]: ts.PropertyDeclaration;</span>
    <span class="s1">[AST_NODE_TYPES.ImportAttribute]: </span><span class="s2">'ImportAttribute' </span><span class="s0">extends </span><span class="s1">keyof </span><span class="s0">typeof </span><span class="s1">ts ? ts.ImportAttribute : ts.AssertEntry;</span>
    <span class="s1">[AST_NODE_TYPES.ImportDeclaration]: ts.ImportDeclaration;</span>
    <span class="s1">[AST_NODE_TYPES.ImportDefaultSpecifier]: ts.ImportClause;</span>
    <span class="s1">[AST_NODE_TYPES.ImportExpression]: ts.CallExpression;</span>
    <span class="s1">[AST_NODE_TYPES.ImportNamespaceSpecifier]: ts.NamespaceImport;</span>
    <span class="s1">[AST_NODE_TYPES.ImportSpecifier]: ts.ImportSpecifier;</span>
    <span class="s1">[AST_NODE_TYPES.JSXAttribute]: ts.JsxAttribute;</span>
    <span class="s1">[AST_NODE_TYPES.JSXClosingElement]: ts.JsxClosingElement;</span>
    <span class="s1">[AST_NODE_TYPES.JSXClosingFragment]: ts.JsxClosingFragment;</span>
    <span class="s1">[AST_NODE_TYPES.JSXElement]: ts.JsxElement | ts.JsxSelfClosingElement;</span>
    <span class="s1">[AST_NODE_TYPES.JSXEmptyExpression]: ts.JsxExpression;</span>
    <span class="s1">[AST_NODE_TYPES.JSXExpressionContainer]: ts.JsxExpression;</span>
    <span class="s1">[AST_NODE_TYPES.JSXFragment]: ts.JsxFragment;</span>
    <span class="s1">[AST_NODE_TYPES.JSXIdentifier]: ts.Identifier | ts.ThisExpression;</span>
    <span class="s1">[AST_NODE_TYPES.JSXMemberExpression]: ts.PropertyAccessExpression;</span>
    <span class="s1">[AST_NODE_TYPES.JSXNamespacedName]: ts.JsxNamespacedName;</span>
    <span class="s1">[AST_NODE_TYPES.JSXOpeningElement]: ts.JsxOpeningElement | ts.JsxSelfClosingElement;</span>
    <span class="s1">[AST_NODE_TYPES.JSXOpeningFragment]: ts.JsxOpeningFragment;</span>
    <span class="s1">[AST_NODE_TYPES.JSXSpreadAttribute]: ts.JsxSpreadAttribute;</span>
    <span class="s1">[AST_NODE_TYPES.JSXSpreadChild]: ts.JsxExpression;</span>
    <span class="s1">[AST_NODE_TYPES.JSXText]: ts.JsxText;</span>
    <span class="s1">[AST_NODE_TYPES.LabeledStatement]: ts.LabeledStatement;</span>
    <span class="s1">[AST_NODE_TYPES.Literal]: ts.BigIntLiteral | ts.BooleanLiteral | ts.NullLiteral | ts.NumericLiteral | ts.RegularExpressionLiteral | ts.StringLiteral;</span>
    <span class="s1">[AST_NODE_TYPES.LogicalExpression]: ts.BinaryExpression;</span>
    <span class="s1">[AST_NODE_TYPES.MemberExpression]: ts.ElementAccessExpression | ts.PropertyAccessExpression;</span>
    <span class="s1">[AST_NODE_TYPES.MetaProperty]: ts.MetaProperty;</span>
    <span class="s1">[AST_NODE_TYPES.MethodDefinition]: ts.ConstructorDeclaration | ts.GetAccessorDeclaration | ts.MethodDeclaration | ts.SetAccessorDeclaration;</span>
    <span class="s1">[AST_NODE_TYPES.NewExpression]: ts.NewExpression;</span>
    <span class="s1">[AST_NODE_TYPES.ObjectExpression]: ts.ObjectLiteralExpression;</span>
    <span class="s1">[AST_NODE_TYPES.ObjectPattern]: ts.ObjectBindingPattern | ts.ObjectLiteralExpression;</span>
    <span class="s1">[AST_NODE_TYPES.Program]: ts.SourceFile;</span>
    <span class="s1">[AST_NODE_TYPES.Property]: ts.BindingElement | ts.GetAccessorDeclaration | ts.MethodDeclaration | ts.PropertyAssignment | ts.SetAccessorDeclaration | ts.ShorthandPropertyAssignment;</span>
    <span class="s1">[AST_NODE_TYPES.RestElement]: ts.BindingElement | ts.ParameterDeclaration | ts.SpreadAssignment | ts.SpreadElement;</span>
    <span class="s1">[AST_NODE_TYPES.ReturnStatement]: ts.ReturnStatement;</span>
    <span class="s1">[AST_NODE_TYPES.SequenceExpression]: ts.BinaryExpression;</span>
    <span class="s1">[AST_NODE_TYPES.SpreadElement]: ts.SpreadAssignment | ts.SpreadElement;</span>
    <span class="s1">[AST_NODE_TYPES.StaticBlock]: ts.ClassStaticBlockDeclaration;</span>
    <span class="s1">[AST_NODE_TYPES.Super]: ts.SuperExpression;</span>
    <span class="s1">[AST_NODE_TYPES.SwitchCase]: ts.CaseClause | ts.DefaultClause;</span>
    <span class="s1">[AST_NODE_TYPES.SwitchStatement]: ts.SwitchStatement;</span>
    <span class="s1">[AST_NODE_TYPES.TaggedTemplateExpression]: ts.TaggedTemplateExpression;</span>
    <span class="s1">[AST_NODE_TYPES.TemplateElement]: ts.NoSubstitutionTemplateLiteral | ts.TemplateHead | ts.TemplateMiddle | ts.TemplateTail;</span>
    <span class="s1">[AST_NODE_TYPES.TemplateLiteral]: ts.NoSubstitutionTemplateLiteral | ts.TemplateExpression;</span>
    <span class="s1">[AST_NODE_TYPES.ThisExpression]: ts.Identifier | ts.KeywordTypeNode | ts.ThisExpression;</span>
    <span class="s1">[AST_NODE_TYPES.ThrowStatement]: ts.ThrowStatement;</span>
    <span class="s1">[AST_NODE_TYPES.TryStatement]: ts.TryStatement;</span>
    <span class="s1">[AST_NODE_TYPES.TSAbstractAccessorProperty]: ts.PropertyDeclaration;</span>
    <span class="s1">[AST_NODE_TYPES.TSAbstractMethodDefinition]: ts.ConstructorDeclaration | ts.GetAccessorDeclaration | ts.MethodDeclaration | ts.SetAccessorDeclaration;</span>
    <span class="s1">[AST_NODE_TYPES.TSAbstractPropertyDefinition]: ts.PropertyDeclaration;</span>
    <span class="s1">[AST_NODE_TYPES.TSArrayType]: ts.ArrayTypeNode;</span>
    <span class="s1">[AST_NODE_TYPES.TSAsExpression]: ts.AsExpression;</span>
    <span class="s1">[AST_NODE_TYPES.TSCallSignatureDeclaration]: ts.CallSignatureDeclaration;</span>
    <span class="s1">[AST_NODE_TYPES.TSClassImplements]: ts.ExpressionWithTypeArguments;</span>
    <span class="s1">[AST_NODE_TYPES.TSConditionalType]: ts.ConditionalTypeNode;</span>
    <span class="s1">[AST_NODE_TYPES.TSConstructorType]: ts.ConstructorTypeNode;</span>
    <span class="s1">[AST_NODE_TYPES.TSConstructSignatureDeclaration]: ts.ConstructSignatureDeclaration;</span>
    <span class="s1">[AST_NODE_TYPES.TSDeclareFunction]: ts.FunctionDeclaration;</span>
    <span class="s1">[AST_NODE_TYPES.TSEnumBody]: ts.EnumDeclaration;</span>
    <span class="s1">[AST_NODE_TYPES.TSEnumDeclaration]: ts.EnumDeclaration;</span>
    <span class="s1">[AST_NODE_TYPES.TSEnumMember]: ts.EnumMember;</span>
    <span class="s1">[AST_NODE_TYPES.TSExportAssignment]: ts.ExportAssignment;</span>
    <span class="s1">[AST_NODE_TYPES.TSExternalModuleReference]: ts.ExternalModuleReference;</span>
    <span class="s1">[AST_NODE_TYPES.TSFunctionType]: ts.FunctionTypeNode;</span>
    <span class="s1">[AST_NODE_TYPES.TSImportEqualsDeclaration]: ts.ImportEqualsDeclaration;</span>
    <span class="s1">[AST_NODE_TYPES.TSImportType]: ts.ImportTypeNode;</span>
    <span class="s1">[AST_NODE_TYPES.TSIndexedAccessType]: ts.IndexedAccessTypeNode;</span>
    <span class="s1">[AST_NODE_TYPES.TSIndexSignature]: ts.IndexSignatureDeclaration;</span>
    <span class="s1">[AST_NODE_TYPES.TSInferType]: ts.InferTypeNode;</span>
    <span class="s1">[AST_NODE_TYPES.TSInstantiationExpression]: ts.ExpressionWithTypeArguments;</span>
    <span class="s1">[AST_NODE_TYPES.TSInterfaceBody]: ts.InterfaceDeclaration;</span>
    <span class="s1">[AST_NODE_TYPES.TSInterfaceDeclaration]: ts.InterfaceDeclaration;</span>
    <span class="s1">[AST_NODE_TYPES.TSInterfaceHeritage]: ts.ExpressionWithTypeArguments;</span>
    <span class="s1">[AST_NODE_TYPES.TSIntersectionType]: ts.IntersectionTypeNode;</span>
    <span class="s1">[AST_NODE_TYPES.TSLiteralType]: ts.LiteralTypeNode;</span>
    <span class="s1">[AST_NODE_TYPES.TSMappedType]: ts.MappedTypeNode;</span>
    <span class="s1">[AST_NODE_TYPES.TSMethodSignature]: ts.GetAccessorDeclaration | ts.MethodSignature | ts.SetAccessorDeclaration;</span>
    <span class="s1">[AST_NODE_TYPES.TSModuleBlock]: ts.ModuleBlock;</span>
    <span class="s1">[AST_NODE_TYPES.TSModuleDeclaration]: ts.ModuleDeclaration;</span>
    <span class="s1">[AST_NODE_TYPES.TSNamedTupleMember]: ts.NamedTupleMember;</span>
    <span class="s1">[AST_NODE_TYPES.TSNamespaceExportDeclaration]: ts.NamespaceExportDeclaration;</span>
    <span class="s1">[AST_NODE_TYPES.TSNonNullExpression]: ts.NonNullExpression;</span>
    <span class="s1">[AST_NODE_TYPES.TSOptionalType]: ts.OptionalTypeNode;</span>
    <span class="s1">[AST_NODE_TYPES.TSParameterProperty]: ts.ParameterDeclaration;</span>
    <span class="s1">[AST_NODE_TYPES.TSPropertySignature]: ts.PropertySignature;</span>
    <span class="s1">[AST_NODE_TYPES.TSQualifiedName]: ts.Identifier | ts.QualifiedName;</span>
    <span class="s1">[AST_NODE_TYPES.TSRestType]: ts.NamedTupleMember | ts.RestTypeNode;</span>
    <span class="s1">[AST_NODE_TYPES.TSSatisfiesExpression]: ts.SatisfiesExpression;</span>
    <span class="s1">[AST_NODE_TYPES.TSTemplateLiteralType]: ts.TemplateLiteralTypeNode;</span>
    <span class="s1">[AST_NODE_TYPES.TSThisType]: ts.ThisTypeNode;</span>
    <span class="s1">[AST_NODE_TYPES.TSTupleType]: ts.TupleTypeNode;</span>
    <span class="s1">[AST_NODE_TYPES.TSTypeAliasDeclaration]: ts.TypeAliasDeclaration;</span>
    <span class="s1">[AST_NODE_TYPES.TSTypeAnnotation]: undefined;</span>
    <span class="s1">[AST_NODE_TYPES.TSTypeAssertion]: ts.TypeAssertion;</span>
    <span class="s1">[AST_NODE_TYPES.TSTypeLiteral]: ts.TypeLiteralNode;</span>
    <span class="s1">[AST_NODE_TYPES.TSTypeOperator]: ts.TypeOperatorNode;</span>
    <span class="s1">[AST_NODE_TYPES.TSTypeParameter]: ts.TypeParameterDeclaration;</span>
    <span class="s1">[AST_NODE_TYPES.TSTypeParameterDeclaration]: undefined;</span>
    <span class="s1">[AST_NODE_TYPES.TSTypeParameterInstantiation]: ts.CallExpression | ts.ExpressionWithTypeArguments | ts.ImportTypeNode | ts.JsxOpeningElement | ts.JsxSelfClosingElement | ts.NewExpression | ts.TaggedTemplateExpression | ts.TypeQueryNode | ts.TypeReferenceNode;</span>
    <span class="s1">[AST_NODE_TYPES.TSTypePredicate]: ts.TypePredicateNode;</span>
    <span class="s1">[AST_NODE_TYPES.TSTypeQuery]: ts.ImportTypeNode | ts.TypeQueryNode;</span>
    <span class="s1">[AST_NODE_TYPES.TSTypeReference]: ts.TypeReferenceNode;</span>
    <span class="s1">[AST_NODE_TYPES.TSUnionType]: ts.UnionTypeNode;</span>
    <span class="s1">[AST_NODE_TYPES.UnaryExpression]: ts.DeleteExpression | ts.PostfixUnaryExpression | ts.PrefixUnaryExpression | ts.TypeOfExpression | ts.VoidExpression;</span>
    <span class="s1">[AST_NODE_TYPES.UpdateExpression]: ts.PostfixUnaryExpression | ts.PrefixUnaryExpression;</span>
    <span class="s1">[AST_NODE_TYPES.VariableDeclaration]: ts.VariableDeclarationList | ts.VariableStatement;</span>
    <span class="s1">[AST_NODE_TYPES.VariableDeclarator]: ts.VariableDeclaration;</span>
    <span class="s1">[AST_NODE_TYPES.WhileStatement]: ts.WhileStatement;</span>
    <span class="s1">[AST_NODE_TYPES.WithStatement]: ts.WithStatement;</span>
    <span class="s1">[AST_NODE_TYPES.YieldExpression]: ts.YieldExpression;</span>
    <span class="s1">[AST_NODE_TYPES.TSEmptyBodyFunctionExpression]: ts.ConstructorDeclaration | ts.FunctionExpression | ts.GetAccessorDeclaration | ts.MethodDeclaration | ts.SetAccessorDeclaration;</span>
    <span class="s1">[AST_NODE_TYPES.TSAbstractKeyword]: ts.Token&lt;ts.SyntaxKind.AbstractKeyword&gt;;</span>
    <span class="s1">[AST_NODE_TYPES.TSAnyKeyword]: ts.KeywordTypeNode;</span>
    <span class="s1">[AST_NODE_TYPES.TSBigIntKeyword]: ts.KeywordTypeNode;</span>
    <span class="s1">[AST_NODE_TYPES.TSBooleanKeyword]: ts.KeywordTypeNode;</span>
    <span class="s1">[AST_NODE_TYPES.TSIntrinsicKeyword]: ts.KeywordTypeNode;</span>
    <span class="s1">[AST_NODE_TYPES.TSNeverKeyword]: ts.KeywordTypeNode;</span>
    <span class="s1">[AST_NODE_TYPES.TSNullKeyword]: ts.KeywordTypeNode | ts.NullLiteral;</span>
    <span class="s1">[AST_NODE_TYPES.TSNumberKeyword]: ts.KeywordTypeNode;</span>
    <span class="s1">[AST_NODE_TYPES.TSObjectKeyword]: ts.KeywordTypeNode;</span>
    <span class="s1">[AST_NODE_TYPES.TSStringKeyword]: ts.KeywordTypeNode;</span>
    <span class="s1">[AST_NODE_TYPES.TSSymbolKeyword]: ts.KeywordTypeNode;</span>
    <span class="s1">[AST_NODE_TYPES.TSUndefinedKeyword]: ts.KeywordTypeNode;</span>
    <span class="s1">[AST_NODE_TYPES.TSUnknownKeyword]: ts.KeywordTypeNode;</span>
    <span class="s1">[AST_NODE_TYPES.TSVoidKeyword]: ts.KeywordTypeNode;</span>
    <span class="s1">[AST_NODE_TYPES.TSAsyncKeyword]: ts.Token&lt;ts.SyntaxKind.AsyncKeyword&gt;;</span>
    <span class="s1">[AST_NODE_TYPES.TSDeclareKeyword]: ts.Token&lt;ts.SyntaxKind.DeclareKeyword&gt;;</span>
    <span class="s1">[AST_NODE_TYPES.TSExportKeyword]: ts.Token&lt;ts.SyntaxKind.ExportKeyword&gt;;</span>
    <span class="s1">[AST_NODE_TYPES.TSPrivateKeyword]: ts.Token&lt;ts.SyntaxKind.PrivateKeyword&gt;;</span>
    <span class="s1">[AST_NODE_TYPES.TSProtectedKeyword]: ts.Token&lt;ts.SyntaxKind.ProtectedKeyword&gt;;</span>
    <span class="s1">[AST_NODE_TYPES.TSPublicKeyword]: ts.Token&lt;ts.SyntaxKind.PublicKeyword&gt;;</span>
    <span class="s1">[AST_NODE_TYPES.TSReadonlyKeyword]: ts.Token&lt;ts.SyntaxKind.ReadonlyKeyword&gt;;</span>
    <span class="s1">[AST_NODE_TYPES.TSStaticKeyword]: ts.Token&lt;ts.SyntaxKind.StaticKeyword&gt;;</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Maps TSESTree AST Node type to the expected TypeScript AST Node type(s).</span>
 <span class="s3">* This mapping is based on the internal logic of the parser.</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">type TSESTreeToTSNode&lt;T </span><span class="s0">extends </span><span class="s1">TSESTree.Node = TSESTree.Node&gt; = Extract&lt;ts.Token&lt;ts.SyntaxKind.ImportKeyword | ts.SyntaxKind.NewKeyword&gt; | TSNode, EstreeToTsNodeTypes[T[</span><span class="s2">'type'</span><span class="s1">]]&gt;;</span>
</pre>
</body>
</html>