<html>
<head>
<title>request-meta.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
request-meta.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/server/request-meta.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/* eslint-disable no-redeclare */</span><span class="s3">\n</span><span class="s1">import type { IncomingMessage } from 'http'</span><span class="s3">\n</span><span class="s1">import type { ParsedUrlQuery } from 'querystring'</span><span class="s3">\n</span><span class="s1">import type { UrlWithParsedQuery } from 'url'</span><span class="s3">\n</span><span class="s1">import type { BaseNextRequest } from './base-http'</span><span class="s3">\n</span><span class="s1">import type { CloneableBody } from './body-streams'</span><span class="s3">\n</span><span class="s1">import type { RouteMatch } from './route-matches/route-match'</span><span class="s3">\n</span><span class="s1">import type { NEXT_RSC_UNION_QUERY } from '../client/components/app-router-headers'</span><span class="s3">\n</span><span class="s1">import type { ServerComponentsHmrCache } from './response-cache'</span><span class="s3">\n</span><span class="s1">import type { PagesDevOverlayBridgeType } from '../next-devtools/userspace/pages/pages-dev-overlay-setup'</span><span class="s3">\n\n</span><span class="s1">// FIXME: (wyattjoh) this is a temporary solution to allow us to pass data between bundled modules</span><span class="s3">\n</span><span class="s1">export const NEXT_REQUEST_META = Symbol.for('NextInternalRequestMeta')</span><span class="s3">\n\n</span><span class="s1">export type NextIncomingMessage = (BaseNextRequest | IncomingMessage) &amp; {</span><span class="s3">\n  </span><span class="s1">[NEXT_REQUEST_META]?: RequestMeta</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface RequestMeta {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The query that was used to make the request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">initQuery?: ParsedUrlQuery</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The URL that was used to make the request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">initURL?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The protocol that was used to make the request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">initProtocol?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The body that was read from the request. This is used to allow the body to</span><span class="s3">\n   </span><span class="s1">* be read multiple times.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">clonableBody?: CloneableBody</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True when the request matched a locale domain that was configured in the</span><span class="s3">\n   </span><span class="s1">* next.config.js file.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isLocaleDomain?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True when the request had locale information stripped from the pathname</span><span class="s3">\n   </span><span class="s1">* part of the URL.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">didStripLocale?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* If the request had it's URL rewritten, this is the URL it was rewritten to.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">rewroteURL?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The cookies that were added by middleware and were added to the response.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">middlewareCookie?: string[]</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The match on the request for a given route.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">match?: RouteMatch</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The incremental cache to use for the request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">incrementalCache?: any</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The server components HMR cache, only for dev.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">serverComponentsHmrCache?: ServerComponentsHmrCache</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Equals the segment path that was used for the prefetch RSC request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">segmentPrefetchRSCRequest?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True when the request is for the prefetch flight data.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isPrefetchRSCRequest?: true</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True when the request is for the flight data.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isRSCRequest?: true</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A search param set by the Next.js client when performing RSC requests.</span><span class="s3">\n   </span><span class="s1">* Because some CDNs do not vary their cache entries on our custom headers,</span><span class="s3">\n   </span><span class="s1">* this search param represents a hash of the header values. For any cached</span><span class="s3">\n   </span><span class="s1">* RSC request, we should verify that the hash matches before responding.</span><span class="s3">\n   </span><span class="s1">* Otherwise this can lead to cache poisoning.</span><span class="s3">\n   </span><span class="s1">* TODO: Consider not using custom request headers at all, and instead encode</span><span class="s3">\n   </span><span class="s1">* everything into the search param.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">cacheBustingSearchParam?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True when the request is for the `/_next/data` route using the pages</span><span class="s3">\n   </span><span class="s1">* router.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isNextDataReq?: true</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Postponed state to use for resumption. If present it's assumed that the</span><span class="s3">\n   </span><span class="s1">* request is for a page that has postponed (there are no guarantees that the</span><span class="s3">\n   </span><span class="s1">* page actually has postponed though as it would incur an additional cache</span><span class="s3">\n   </span><span class="s1">* lookup).</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">postponed?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* If provided, this will be called when a response cache entry was generated</span><span class="s3">\n   </span><span class="s1">* or looked up in the cache.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">onCacheEntry?: (</span><span class="s3">\n    </span><span class="s1">cacheEntry: any,</span><span class="s3">\n    </span><span class="s1">requestMeta: any</span><span class="s3">\n  </span><span class="s1">) =&gt; Promise&lt;boolean | void&gt; | boolean | void</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The previous revalidate before rendering 404 page for notFound: true</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">notFoundRevalidate?: number | false</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* In development, the original source page that returned a 404.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">developmentNotFoundSourcePage?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The path we routed to and should be invoked</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">invokePath?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The specific page output we should be matching</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">invokeOutput?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The status we are invoking the request with from routing</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">invokeStatus?: number</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The routing error we are invoking with</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">invokeError?: Error</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The query parsed for the invocation</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">invokeQuery?: Record&lt;string, undefined | string | string[]&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether the request is a middleware invocation</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">middlewareInvoke?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether the request should render the fallback shell or not.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">renderFallbackShell?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether the request is for the custom error page.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">customErrorRender?: true</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to bubble up the NoFallbackError to the caller when a 404 is</span><span class="s3">\n   </span><span class="s1">* returned.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">bubbleNoFallback?: true</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True when the request had locale information inferred from the default</span><span class="s3">\n   </span><span class="s1">* locale.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">localeInferredFromDefault?: true</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The locale that was inferred or explicitly set for the request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">locale?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The default locale that was inferred or explicitly set for the request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">defaultLocale?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The relative project dir the server is running in from project root</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">relativeProjectDir?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The dist directory the server is currently using</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">distDir?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The query after resolving routes</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">query?: ParsedUrlQuery</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The params after resolving routes</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">params?: ParsedUrlQuery</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The AMP validator to use in development</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">ampValidator?: (html: string, pathname: string) =&gt; Promise&lt;void&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* ErrorOverlay component to use in development for pages router</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">PagesErrorDebug?: PagesDevOverlayBridgeType</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether server is in minimal mode (this will be replaced with more</span><span class="s3">\n   </span><span class="s1">* specific flags in future)</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">minimalMode?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* DEV only: The fallback params that should be used when validating prerenders during dev</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">devValidatingFallbackParams?: Map&lt;string, string&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Gets the request metadata. If no key is provided, the entire metadata object</span><span class="s3">\n </span><span class="s1">* is returned.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param req the request to get the metadata from</span><span class="s3">\n </span><span class="s1">* @param key the key to get from the metadata (optional)</span><span class="s3">\n </span><span class="s1">* @returns the value for the key or the entire metadata object</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getRequestMeta(</span><span class="s3">\n  </span><span class="s1">req: NextIncomingMessage,</span><span class="s3">\n  </span><span class="s1">key?: undefined</span><span class="s3">\n</span><span class="s1">): RequestMeta</span><span class="s3">\n</span><span class="s1">export function getRequestMeta&lt;K extends keyof RequestMeta&gt;(</span><span class="s3">\n  </span><span class="s1">req: NextIncomingMessage,</span><span class="s3">\n  </span><span class="s1">key: K</span><span class="s3">\n</span><span class="s1">): RequestMeta[K]</span><span class="s3">\n</span><span class="s1">export function getRequestMeta&lt;K extends keyof RequestMeta&gt;(</span><span class="s3">\n  </span><span class="s1">req: NextIncomingMessage,</span><span class="s3">\n  </span><span class="s1">key?: K</span><span class="s3">\n</span><span class="s1">): RequestMeta | RequestMeta[K] {</span><span class="s3">\n  </span><span class="s1">const meta = req[NEXT_REQUEST_META] || {}</span><span class="s3">\n  </span><span class="s1">return typeof key === 'string' ? meta[key] : meta</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Sets the request metadata.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param req the request to set the metadata on</span><span class="s3">\n </span><span class="s1">* @param meta the metadata to set</span><span class="s3">\n </span><span class="s1">* @returns the mutated request metadata</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function setRequestMeta(req: NextIncomingMessage, meta: RequestMeta) {</span><span class="s3">\n  </span><span class="s1">req[NEXT_REQUEST_META] = meta</span><span class="s3">\n  </span><span class="s1">return meta</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Adds a value to the request metadata.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param request the request to mutate</span><span class="s3">\n </span><span class="s1">* @param key the key to set</span><span class="s3">\n </span><span class="s1">* @param value the value to set</span><span class="s3">\n </span><span class="s1">* @returns the mutated request metadata</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function addRequestMeta&lt;K extends keyof RequestMeta&gt;(</span><span class="s3">\n  </span><span class="s1">request: NextIncomingMessage,</span><span class="s3">\n  </span><span class="s1">key: K,</span><span class="s3">\n  </span><span class="s1">value: RequestMeta[K]</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const meta = getRequestMeta(request)</span><span class="s3">\n  </span><span class="s1">meta[key] = value</span><span class="s3">\n  </span><span class="s1">return setRequestMeta(request, meta)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Removes a key from the request metadata.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param request the request to mutate</span><span class="s3">\n </span><span class="s1">* @param key the key to remove</span><span class="s3">\n </span><span class="s1">* @returns the mutated request metadata</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function removeRequestMeta&lt;K extends keyof RequestMeta&gt;(</span><span class="s3">\n  </span><span class="s1">request: NextIncomingMessage,</span><span class="s3">\n  </span><span class="s1">key: K</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const meta = getRequestMeta(request)</span><span class="s3">\n  </span><span class="s1">delete meta[key]</span><span class="s3">\n  </span><span class="s1">return setRequestMeta(request, meta)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type NextQueryMetadata = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The `_rsc` query parameter used for cache busting to ensure that the RSC</span><span class="s3">\n   </span><span class="s1">* requests do not get cached by the browser explicitly.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">[NEXT_RSC_UNION_QUERY]?: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type NextParsedUrlQuery = ParsedUrlQuery &amp;</span><span class="s3">\n  </span><span class="s1">NextQueryMetadata &amp; {</span><span class="s3">\n    </span><span class="s1">amp?: '1'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface NextUrlWithParsedQuery extends UrlWithParsedQuery {</span><span class="s3">\n  </span><span class="s1">query: NextParsedUrlQuery</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;NEXT_REQUEST_META&quot;</span><span class="s0">,</span><span class="s1">&quot;addRequestMeta&quot;</span><span class="s0">,</span><span class="s1">&quot;getRequestMeta&quot;</span><span class="s0">,</span><span class="s1">&quot;removeRequestMeta&quot;</span><span class="s0">,</span><span class="s1">&quot;setRequestMeta&quot;</span><span class="s0">,</span><span class="s1">&quot;Symbol&quot;</span><span class="s0">,</span><span class="s1">&quot;for&quot;</span><span class="s0">,</span><span class="s1">&quot;req&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;meta&quot;</span><span class="s0">,</span><span class="s1">&quot;request&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAA,+BAA+B;;;;;;;;;;;;;;;;;;IAYlBA,iBAAiB;eAAjBA;;IAgRGC,cAAc;eAAdA;;IA5BAC,cAAc;eAAdA;;IA6CAC,iBAAiB;eAAjBA;;IA9BAC,cAAc;eAAdA;;;AAnQT,MAAMJ,oBAAoBK,OAAOC,GAAG,CAAC;AAoPrC,SAASJ,eACdK,GAAwB,EACxBC,GAAO;IAEP,MAAMC,OAAOF,GAAG,CAACP,kBAAkB,IAAI,CAAC;IACxC,OAAO,OAAOQ,QAAQ,WAAWC,IAAI,CAACD,IAAI,GAAGC;AAC/C;AASO,SAASL,eAAeG,GAAwB,EAAEE,IAAiB;IACxEF,GAAG,CAACP,kBAAkB,GAAGS;IACzB,OAAOA;AACT;AAUO,SAASR,eACdS,OAA4B,EAC5BF,GAAM,EACNG,KAAqB;IAErB,MAAMF,OAAOP,eAAeQ;IAC5BD,IAAI,CAACD,IAAI,GAAGG;IACZ,OAAOP,eAAeM,SAASD;AACjC;AASO,SAASN,kBACdO,OAA4B,EAC5BF,GAAM;IAEN,MAAMC,OAAOP,eAAeQ;IAC5B,OAAOD,IAAI,CAACD,IAAI;IAChB,OAAOJ,eAAeM,SAASD;AACjC&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>