<html>
<head>
<title>dev-route-matcher-manager.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
dev-route-matcher-manager.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/server/route-matcher-managers/dev-route-matcher-manager.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { RouteKind } from '../route-kind'</span><span class="s3">\n</span><span class="s1">import type { RouteMatch } from '../route-matches/route-match'</span><span class="s3">\n</span><span class="s1">import type { RouteDefinition } from '../route-definitions/route-definition'</span><span class="s3">\n</span><span class="s1">import { DefaultRouteMatcherManager } from './default-route-matcher-manager'</span><span class="s3">\n</span><span class="s1">import type { MatchOptions, RouteMatcherManager } from './route-matcher-manager'</span><span class="s3">\n</span><span class="s1">import path from '../../shared/lib/isomorphic/path'</span><span class="s3">\n</span><span class="s1">import * as Log from '../../build/output/log'</span><span class="s3">\n</span><span class="s1">import { cyan } from '../../lib/picocolors'</span><span class="s3">\n</span><span class="s1">import type { RouteMatcher } from '../route-matchers/route-matcher'</span><span class="s3">\n\n</span><span class="s1">export interface RouteEnsurer {</span><span class="s3">\n  </span><span class="s1">ensure(match: RouteMatch, pathname: string): Promise&lt;void&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class DevRouteMatcherManager extends DefaultRouteMatcherManager {</span><span class="s3">\n  </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">private readonly production: RouteMatcherManager,</span><span class="s3">\n    </span><span class="s1">private readonly ensurer: RouteEnsurer,</span><span class="s3">\n    </span><span class="s1">private readonly dir: string</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">super()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async test(pathname: string, options: MatchOptions): Promise&lt;boolean&gt; {</span><span class="s3">\n    </span><span class="s1">// Try to find a match within the developer routes.</span><span class="s3">\n    </span><span class="s1">const match = await super.match(pathname, options)</span><span class="s3">\n\n    </span><span class="s1">// Return if the match wasn't null. Unlike the implementation of `match`</span><span class="s3">\n    </span><span class="s1">// which uses `matchAll` here, this does not call `ensure` on the match</span><span class="s3">\n    </span><span class="s1">// found via the development matches.</span><span class="s3">\n    </span><span class="s1">return match !== null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">protected validate(</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">matcher: RouteMatcher,</span><span class="s3">\n    </span><span class="s1">options: MatchOptions</span><span class="s3">\n  </span><span class="s1">): RouteMatch | null {</span><span class="s3">\n    </span><span class="s1">const match = super.validate(pathname, matcher, options)</span><span class="s3">\n\n    </span><span class="s1">// If a match was found, check to see if there were any conflicting app or</span><span class="s3">\n    </span><span class="s1">// pages files.</span><span class="s3">\n    </span><span class="s1">// TODO: maybe expand this to _any_ duplicated routes instead?</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">match &amp;&amp;</span><span class="s3">\n      </span><span class="s1">matcher.duplicated &amp;&amp;</span><span class="s3">\n      </span><span class="s1">matcher.duplicated.some(</span><span class="s3">\n        </span><span class="s1">(duplicate) =&gt;</span><span class="s3">\n          </span><span class="s1">duplicate.definition.kind === RouteKind.APP_PAGE ||</span><span class="s3">\n          </span><span class="s1">duplicate.definition.kind === RouteKind.APP_ROUTE</span><span class="s3">\n      </span><span class="s1">) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">matcher.duplicated.some(</span><span class="s3">\n        </span><span class="s1">(duplicate) =&gt;</span><span class="s3">\n          </span><span class="s1">duplicate.definition.kind === RouteKind.PAGES ||</span><span class="s3">\n          </span><span class="s1">duplicate.definition.kind === RouteKind.PAGES_API</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return match</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async *matchAll(</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">options: MatchOptions</span><span class="s3">\n  </span><span class="s1">): AsyncGenerator&lt;RouteMatch&lt;RouteDefinition&lt;RouteKind&gt;&gt;, null, undefined&gt; {</span><span class="s3">\n    </span><span class="s1">// Compile the development routes.</span><span class="s3">\n    </span><span class="s1">// TODO: we may want to only run this during testing, users won't be fast enough to require this many dir scans</span><span class="s3">\n    </span><span class="s1">await super.reload()</span><span class="s3">\n\n    </span><span class="s1">// Iterate over the development matches to see if one of them match the</span><span class="s3">\n    </span><span class="s1">// request path.</span><span class="s3">\n    </span><span class="s1">for await (const developmentMatch of super.matchAll(pathname, options)) {</span><span class="s3">\n      </span><span class="s1">// We're here, which means that we haven't seen this match yet, so we</span><span class="s3">\n      </span><span class="s1">// should try to ensure it and recompile the production matcher.</span><span class="s3">\n      </span><span class="s1">await this.ensurer.ensure(developmentMatch, pathname)</span><span class="s3">\n      </span><span class="s1">await this.production.reload()</span><span class="s3">\n\n      </span><span class="s1">// Iterate over the production matches again, this time we should be able</span><span class="s3">\n      </span><span class="s1">// to match it against the production matcher unless there's an error.</span><span class="s3">\n      </span><span class="s1">for await (const productionMatch of this.production.matchAll(</span><span class="s3">\n        </span><span class="s1">pathname,</span><span class="s3">\n        </span><span class="s1">options</span><span class="s3">\n      </span><span class="s1">)) {</span><span class="s3">\n        </span><span class="s1">yield productionMatch</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// We tried direct matching against the pathname and against all the dynamic</span><span class="s3">\n    </span><span class="s1">// paths, so there was no match.</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async reload(): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">// Compile the production routes again.</span><span class="s3">\n    </span><span class="s1">await this.production.reload()</span><span class="s3">\n\n    </span><span class="s1">// Compile the development routes.</span><span class="s3">\n    </span><span class="s1">await super.reload()</span><span class="s3">\n\n    </span><span class="s1">// Check for and warn of any duplicates.</span><span class="s3">\n    </span><span class="s1">for (const [pathname, matchers] of Object.entries(</span><span class="s3">\n      </span><span class="s1">this.matchers.duplicates</span><span class="s3">\n    </span><span class="s1">)) {</span><span class="s3">\n      </span><span class="s1">// We only want to warn about matchers resolving to the same path if their</span><span class="s3">\n      </span><span class="s1">// identities are different.</span><span class="s3">\n      </span><span class="s1">const identity = matchers[0].identity</span><span class="s3">\n      </span><span class="s1">if (matchers.slice(1).some((matcher) =&gt; matcher.identity !== identity)) {</span><span class="s3">\n        </span><span class="s1">continue</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">Log.warn(</span><span class="s3">\n        </span><span class="s1">`Duplicate page detected. ${matchers</span><span class="s3">\n          </span><span class="s1">.map((matcher) =&gt;</span><span class="s3">\n            </span><span class="s1">cyan(path.relative(this.dir, matcher.definition.filename))</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">.join(' and ')} resolve to ${cyan(pathname)}`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;DevRouteMatcherManager&quot;</span><span class="s0">,</span><span class="s1">&quot;DefaultRouteMatcherManager&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;production&quot;</span><span class="s0">,</span><span class="s1">&quot;ensurer&quot;</span><span class="s0">,</span><span class="s1">&quot;dir&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;options&quot;</span><span class="s0">,</span><span class="s1">&quot;match&quot;</span><span class="s0">,</span><span class="s1">&quot;validate&quot;</span><span class="s0">,</span><span class="s1">&quot;matcher&quot;</span><span class="s0">,</span><span class="s1">&quot;duplicated&quot;</span><span class="s0">,</span><span class="s1">&quot;some&quot;</span><span class="s0">,</span><span class="s1">&quot;duplicate&quot;</span><span class="s0">,</span><span class="s1">&quot;definition&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;RouteKind&quot;</span><span class="s0">,</span><span class="s1">&quot;APP_PAGE&quot;</span><span class="s0">,</span><span class="s1">&quot;APP_ROUTE&quot;</span><span class="s0">,</span><span class="s1">&quot;PAGES&quot;</span><span class="s0">,</span><span class="s1">&quot;PAGES_API&quot;</span><span class="s0">,</span><span class="s1">&quot;matchAll&quot;</span><span class="s0">,</span><span class="s1">&quot;reload&quot;</span><span class="s0">,</span><span class="s1">&quot;developmentMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;ensure&quot;</span><span class="s0">,</span><span class="s1">&quot;productionMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;matchers&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;entries&quot;</span><span class="s0">,</span><span class="s1">&quot;duplicates&quot;</span><span class="s0">,</span><span class="s1">&quot;identity&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;Log&quot;</span><span class="s0">,</span><span class="s1">&quot;warn&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;cyan&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;relative&quot;</span><span class="s0">,</span><span class="s1">&quot;filename&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;+BAcaA;;;eAAAA;;;2BAda;4CAGiB;6DAE1B;6DACI;4BACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOd,MAAMA,+BAA+BC,sDAA0B;IACpEC,YACE,AAAiBC,UAA+B,EAChD,AAAiBC,OAAqB,EACtC,AAAiBC,GAAW,CAC5B;QACA,KAAK,SAJYF,aAAAA,iBACAC,UAAAA,cACAC,MAAAA;IAGnB;IAEA,MAAaC,KAAKC,QAAgB,EAAEC,OAAqB,EAAoB;QAC3E,mDAAmD;QACnD,MAAMC,QAAQ,MAAM,KAAK,CAACA,MAAMF,UAAUC;QAE1C,wEAAwE;QACxE,uEAAuE;QACvE,qCAAqC;QACrC,OAAOC,UAAU;IACnB;IAEUC,SACRH,QAAgB,EAChBI,OAAqB,EACrBH,OAAqB,EACF;QACnB,MAAMC,QAAQ,KAAK,CAACC,SAASH,UAAUI,SAASH;QAEhD,0EAA0E;QAC1E,eAAe;QACf,8DAA8D;QAC9D,IACEC,SACAE,QAAQC,UAAU,IAClBD,QAAQC,UAAU,CAACC,IAAI,CACrB,CAACC,YACCA,UAAUC,UAAU,CAACC,IAAI,KAAKC,oBAAS,CAACC,QAAQ,IAChDJ,UAAUC,UAAU,CAACC,IAAI,KAAKC,oBAAS,CAACE,SAAS,KAErDR,QAAQC,UAAU,CAACC,IAAI,CACrB,CAACC,YACCA,UAAUC,UAAU,CAACC,IAAI,KAAKC,oBAAS,CAACG,KAAK,IAC7CN,UAAUC,UAAU,CAACC,IAAI,KAAKC,oBAAS,CAACI,SAAS,GAErD;YACA,OAAO;QACT;QAEA,OAAOZ;IACT;IAEA,OAAca,SACZf,QAAgB,EAChBC,OAAqB,EACoD;QACzE,kCAAkC;QAClC,+GAA+G;QAC/G,MAAM,KAAK,CAACe;QAEZ,uEAAuE;QACvE,gBAAgB;QAChB,WAAW,MAAMC,oBAAoB,KAAK,CAACF,SAASf,UAAUC,SAAU;YACtE,qEAAqE;YACrE,gEAAgE;YAChE,MAAM,IAAI,CAACJ,OAAO,CAACqB,MAAM,CAACD,kBAAkBjB;YAC5C,MAAM,IAAI,CAACJ,UAAU,CAACoB,MAAM;YAE5B,yEAAyE;YACzE,sEAAsE;YACtE,WAAW,MAAMG,mBAAmB,IAAI,CAACvB,UAAU,CAACmB,QAAQ,CAC1Df,UACAC,SACC;gBACD,MAAMkB;YACR;QACF;QAEA,4EAA4E;QAC5E,gCAAgC;QAChC,OAAO;IACT;IAEA,MAAaH,SAAwB;QACnC,uCAAuC;QACvC,MAAM,IAAI,CAACpB,UAAU,CAACoB,MAAM;QAE5B,kCAAkC;QAClC,MAAM,KAAK,CAACA;QAEZ,wCAAwC;QACxC,KAAK,MAAM,CAAChB,UAAUoB,SAAS,IAAIC,OAAOC,OAAO,CAC/C,IAAI,CAACF,QAAQ,CAACG,UAAU,EACvB;YACD,0EAA0E;YAC1E,4BAA4B;YAC5B,MAAMC,WAAWJ,QAAQ,CAAC,EAAE,CAACI,QAAQ;YACrC,IAAIJ,SAASK,KAAK,CAAC,GAAGnB,IAAI,CAAC,CAACF,UAAYA,QAAQoB,QAAQ,KAAKA,WAAW;gBACtE;YACF;YAEAE,KAAIC,IAAI,CACN,CAAC,yBAAyB,EAAEP,SACzBQ,GAAG,CAAC,CAACxB,UACJyB,IAAAA,gBAAI,EAACC,aAAI,CAACC,QAAQ,CAAC,IAAI,CAACjC,GAAG,EAAEM,QAAQI,UAAU,CAACwB,QAAQ,IAEzDC,IAAI,CAAC,SAAS,YAAY,EAAEJ,IAAAA,gBAAI,EAAC7B,WAAW;QAEnD;IACF;AACF&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>