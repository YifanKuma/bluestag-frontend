<html>
<head>
<title>GraphemerHelper.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
.s5 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
GraphemerHelper.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
<span class="s2">const </span><span class="s1">boundaries_1 = require(</span><span class="s0">&quot;./boundaries&quot;</span><span class="s1">);</span>
<span class="s3">// BreakTypes</span>
<span class="s3">// @type {BreakType}</span>
<span class="s2">const </span><span class="s1">NotBreak = </span><span class="s4">0</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">BreakStart = </span><span class="s4">1</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">Break = </span><span class="s4">2</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">BreakLastRegional = </span><span class="s4">3</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">BreakPenultimateRegional = </span><span class="s4">4</span><span class="s1">;</span>
<span class="s2">class </span><span class="s1">GraphemerHelper {</span>
    <span class="s3">/**</span>
     <span class="s3">* Check if the the character at the position {pos} of the string is surrogate</span>
     <span class="s3">* </span><span class="s5">@param </span><span class="s3">str {string}</span>
     <span class="s3">* </span><span class="s5">@param </span><span class="s3">pos {number}</span>
     <span class="s3">* </span><span class="s5">@returns </span><span class="s3">{boolean}</span>
     <span class="s3">*/</span>
    <span class="s2">static </span><span class="s1">isSurrogate(str, pos) {</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s4">0xd800 </span><span class="s1">&lt;= str.charCodeAt(pos) &amp;&amp;</span>
            <span class="s1">str.charCodeAt(pos) &lt;= </span><span class="s4">0xdbff </span><span class="s1">&amp;&amp;</span>
            <span class="s4">0xdc00 </span><span class="s1">&lt;= str.charCodeAt(pos + </span><span class="s4">1</span><span class="s1">) &amp;&amp;</span>
            <span class="s1">str.charCodeAt(pos + </span><span class="s4">1</span><span class="s1">) &lt;= </span><span class="s4">0xdfff</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* The String.prototype.codePointAt polyfill</span>
     <span class="s3">* Private function, gets a Unicode code point from a JavaScript UTF-16 string</span>
     <span class="s3">* handling surrogate pairs appropriately</span>
     <span class="s3">* </span><span class="s5">@param </span><span class="s3">str {string}</span>
     <span class="s3">* </span><span class="s5">@param </span><span class="s3">idx {number}</span>
     <span class="s3">* </span><span class="s5">@returns </span><span class="s3">{number}</span>
     <span class="s3">*/</span>
    <span class="s2">static </span><span class="s1">codePointAt(str, idx) {</span>
        <span class="s2">if </span><span class="s1">(idx === undefined) {</span>
            <span class="s1">idx = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">code = str.charCodeAt(idx);</span>
        <span class="s3">// if a high surrogate</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s4">0xd800 </span><span class="s1">&lt;= code &amp;&amp; code &lt;= </span><span class="s4">0xdbff </span><span class="s1">&amp;&amp; idx &lt; str.length - </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">hi = code;</span>
            <span class="s2">const </span><span class="s1">low = str.charCodeAt(idx + </span><span class="s4">1</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s4">0xdc00 </span><span class="s1">&lt;= low &amp;&amp; low &lt;= </span><span class="s4">0xdfff</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s1">(hi - </span><span class="s4">0xd800</span><span class="s1">) * </span><span class="s4">0x400 </span><span class="s1">+ (low - </span><span class="s4">0xdc00</span><span class="s1">) + </span><span class="s4">0x10000</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">hi;</span>
        <span class="s1">}</span>
        <span class="s3">// if a low surrogate</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s4">0xdc00 </span><span class="s1">&lt;= code &amp;&amp; code &lt;= </span><span class="s4">0xdfff </span><span class="s1">&amp;&amp; idx &gt;= </span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">hi = str.charCodeAt(idx - </span><span class="s4">1</span><span class="s1">);</span>
            <span class="s2">const </span><span class="s1">low = code;</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s4">0xd800 </span><span class="s1">&lt;= hi &amp;&amp; hi &lt;= </span><span class="s4">0xdbff</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s1">(hi - </span><span class="s4">0xd800</span><span class="s1">) * </span><span class="s4">0x400 </span><span class="s1">+ (low - </span><span class="s4">0xdc00</span><span class="s1">) + </span><span class="s4">0x10000</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">low;</span>
        <span class="s1">}</span>
        <span class="s3">// just return the char if an unmatched surrogate half or a</span>
        <span class="s3">// single-char codepoint</span>
        <span class="s2">return </span><span class="s1">code;</span>
    <span class="s1">}</span>
    <span class="s3">//</span>
    <span class="s3">/**</span>
     <span class="s3">* Private function, returns whether a break is allowed between the two given grapheme breaking classes</span>
     <span class="s3">* Implemented the UAX #29 3.1.1 Grapheme Cluster Boundary Rules on extended grapheme clusters</span>
     <span class="s3">* </span><span class="s5">@param </span><span class="s3">start {number}</span>
     <span class="s3">* </span><span class="s5">@param </span><span class="s3">mid {Array&lt;number&gt;}</span>
     <span class="s3">* </span><span class="s5">@param </span><span class="s3">end {number}</span>
     <span class="s3">* </span><span class="s5">@param </span><span class="s3">startEmoji {number}</span>
     <span class="s3">* </span><span class="s5">@param </span><span class="s3">midEmoji {Array&lt;number&gt;}</span>
     <span class="s3">* </span><span class="s5">@param </span><span class="s3">endEmoji {number}</span>
     <span class="s3">* </span><span class="s5">@returns </span><span class="s3">{number}</span>
     <span class="s3">*/</span>
    <span class="s2">static </span><span class="s1">shouldBreak(start, mid, end, startEmoji, midEmoji, endEmoji) {</span>
        <span class="s2">const </span><span class="s1">all = [start].concat(mid).concat([end]);</span>
        <span class="s2">const </span><span class="s1">allEmoji = [startEmoji].concat(midEmoji).concat([endEmoji]);</span>
        <span class="s2">const </span><span class="s1">previous = all[all.length - </span><span class="s4">2</span><span class="s1">];</span>
        <span class="s2">const </span><span class="s1">next = end;</span>
        <span class="s2">const </span><span class="s1">nextEmoji = endEmoji;</span>
        <span class="s3">// Lookahead terminator for:</span>
        <span class="s3">// GB12. ^ (RI RI)* RI ? RI</span>
        <span class="s3">// GB13. [^RI] (RI RI)* RI ? RI</span>
        <span class="s2">const </span><span class="s1">rIIndex = all.lastIndexOf(boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR);</span>
        <span class="s2">if </span><span class="s1">(rIIndex &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp;</span>
            <span class="s1">all.slice(</span><span class="s4">1</span><span class="s1">, rIIndex).every(</span><span class="s2">function </span><span class="s1">(c) {</span>
                <span class="s2">return </span><span class="s1">c === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR;</span>
            <span class="s1">}) &amp;&amp;</span>
            <span class="s1">[boundaries_1.CLUSTER_BREAK.PREPEND, boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR].indexOf(previous) === -</span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(all.filter(</span><span class="s2">function </span><span class="s1">(c) {</span>
                <span class="s2">return </span><span class="s1">c === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR;</span>
            <span class="s1">}).length %</span>
                <span class="s4">2 </span><span class="s1">===</span>
                <span class="s4">1</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s1">BreakLastRegional;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">return </span><span class="s1">BreakPenultimateRegional;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">// GB3. CR × LF</span>
        <span class="s2">if </span><span class="s1">(previous === boundaries_1.CLUSTER_BREAK.CR &amp;&amp; next === boundaries_1.CLUSTER_BREAK.LF) {</span>
            <span class="s2">return </span><span class="s1">NotBreak;</span>
        <span class="s1">}</span>
        <span class="s3">// GB4. (Control|CR|LF) ÷</span>
        <span class="s2">else if </span><span class="s1">(previous === boundaries_1.CLUSTER_BREAK.CONTROL ||</span>
            <span class="s1">previous === boundaries_1.CLUSTER_BREAK.CR ||</span>
            <span class="s1">previous === boundaries_1.CLUSTER_BREAK.LF) {</span>
            <span class="s2">return </span><span class="s1">BreakStart;</span>
        <span class="s1">}</span>
        <span class="s3">// GB5. ÷ (Control|CR|LF)</span>
        <span class="s2">else if </span><span class="s1">(next === boundaries_1.CLUSTER_BREAK.CONTROL ||</span>
            <span class="s1">next === boundaries_1.CLUSTER_BREAK.CR ||</span>
            <span class="s1">next === boundaries_1.CLUSTER_BREAK.LF) {</span>
            <span class="s2">return </span><span class="s1">BreakStart;</span>
        <span class="s1">}</span>
        <span class="s3">// GB6. L × (L|V|LV|LVT)</span>
        <span class="s2">else if </span><span class="s1">(previous === boundaries_1.CLUSTER_BREAK.L &amp;&amp;</span>
            <span class="s1">(next === boundaries_1.CLUSTER_BREAK.L ||</span>
                <span class="s1">next === boundaries_1.CLUSTER_BREAK.V ||</span>
                <span class="s1">next === boundaries_1.CLUSTER_BREAK.LV ||</span>
                <span class="s1">next === boundaries_1.CLUSTER_BREAK.LVT)) {</span>
            <span class="s2">return </span><span class="s1">NotBreak;</span>
        <span class="s1">}</span>
        <span class="s3">// GB7. (LV|V) × (V|T)</span>
        <span class="s2">else if </span><span class="s1">((previous === boundaries_1.CLUSTER_BREAK.LV || previous === boundaries_1.CLUSTER_BREAK.V) &amp;&amp;</span>
            <span class="s1">(next === boundaries_1.CLUSTER_BREAK.V || next === boundaries_1.CLUSTER_BREAK.T)) {</span>
            <span class="s2">return </span><span class="s1">NotBreak;</span>
        <span class="s1">}</span>
        <span class="s3">// GB8. (LVT|T) × (T)</span>
        <span class="s2">else if </span><span class="s1">((previous === boundaries_1.CLUSTER_BREAK.LVT || previous === boundaries_1.CLUSTER_BREAK.T) &amp;&amp;</span>
            <span class="s1">next === boundaries_1.CLUSTER_BREAK.T) {</span>
            <span class="s2">return </span><span class="s1">NotBreak;</span>
        <span class="s1">}</span>
        <span class="s3">// GB9. × (Extend|ZWJ)</span>
        <span class="s2">else if </span><span class="s1">(next === boundaries_1.CLUSTER_BREAK.EXTEND || next === boundaries_1.CLUSTER_BREAK.ZWJ) {</span>
            <span class="s2">return </span><span class="s1">NotBreak;</span>
        <span class="s1">}</span>
        <span class="s3">// GB9a. × SpacingMark</span>
        <span class="s2">else if </span><span class="s1">(next === boundaries_1.CLUSTER_BREAK.SPACINGMARK) {</span>
            <span class="s2">return </span><span class="s1">NotBreak;</span>
        <span class="s1">}</span>
        <span class="s3">// GB9b. Prepend ×</span>
        <span class="s2">else if </span><span class="s1">(previous === boundaries_1.CLUSTER_BREAK.PREPEND) {</span>
            <span class="s2">return </span><span class="s1">NotBreak;</span>
        <span class="s1">}</span>
        <span class="s3">// GB11. \p{Extended_Pictographic} Extend* ZWJ × \p{Extended_Pictographic}</span>
        <span class="s2">const </span><span class="s1">previousNonExtendIndex = allEmoji</span>
            <span class="s1">.slice(</span><span class="s4">0</span><span class="s1">, -</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">.lastIndexOf(boundaries_1.EXTENDED_PICTOGRAPHIC);</span>
        <span class="s2">if </span><span class="s1">(previousNonExtendIndex !== -</span><span class="s4">1 </span><span class="s1">&amp;&amp;</span>
            <span class="s1">allEmoji[previousNonExtendIndex] === boundaries_1.EXTENDED_PICTOGRAPHIC &amp;&amp;</span>
            <span class="s1">all.slice(previousNonExtendIndex + </span><span class="s4">1</span><span class="s1">, -</span><span class="s4">2</span><span class="s1">).every(</span><span class="s2">function </span><span class="s1">(c) {</span>
                <span class="s2">return </span><span class="s1">c === boundaries_1.CLUSTER_BREAK.EXTEND;</span>
            <span class="s1">}) &amp;&amp;</span>
            <span class="s1">previous === boundaries_1.CLUSTER_BREAK.ZWJ &amp;&amp;</span>
            <span class="s1">nextEmoji === boundaries_1.EXTENDED_PICTOGRAPHIC) {</span>
            <span class="s2">return </span><span class="s1">NotBreak;</span>
        <span class="s1">}</span>
        <span class="s3">// GB12. ^ (RI RI)* RI × RI</span>
        <span class="s3">// GB13. [^RI] (RI RI)* RI × RI</span>
        <span class="s2">if </span><span class="s1">(mid.indexOf(boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR) !== -</span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">Break;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(previous === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR &amp;&amp;</span>
            <span class="s1">next === boundaries_1.CLUSTER_BREAK.REGIONAL_INDICATOR) {</span>
            <span class="s2">return </span><span class="s1">NotBreak;</span>
        <span class="s1">}</span>
        <span class="s3">// GB999. Any ? Any</span>
        <span class="s2">return </span><span class="s1">BreakStart;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">exports.default = GraphemerHelper;</span>
</pre>
</body>
</html>