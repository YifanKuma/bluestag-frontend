<html>
<head>
<title>layout-router.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
layout-router.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/client/components/layout-router.tsx&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;'use client'</span><span class="s3">\n\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">CacheNode,</span><span class="s3">\n  </span><span class="s1">LazyCacheNode,</span><span class="s3">\n  </span><span class="s1">LoadingModuleData,</span><span class="s3">\n</span><span class="s1">} from '../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">FlightRouterState,</span><span class="s3">\n  </span><span class="s1">FlightSegmentPath,</span><span class="s3">\n</span><span class="s1">} from '../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import type { ErrorComponent } from './error-boundary'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">ACTION_SERVER_PATCH,</span><span class="s3">\n  </span><span class="s1">type FocusAndScrollRef,</span><span class="s3">\n</span><span class="s1">} from './router-reducer/router-reducer-types'</span><span class="s3">\n\n</span><span class="s1">import React, {</span><span class="s3">\n  </span><span class="s1">useContext,</span><span class="s3">\n  </span><span class="s1">use,</span><span class="s3">\n  </span><span class="s1">startTransition,</span><span class="s3">\n  </span><span class="s1">Suspense,</span><span class="s3">\n  </span><span class="s1">useDeferredValue,</span><span class="s3">\n  </span><span class="s1">type JSX,</span><span class="s3">\n</span><span class="s1">} from 'react'</span><span class="s3">\n</span><span class="s1">import ReactDOM from 'react-dom'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">LayoutRouterContext,</span><span class="s3">\n  </span><span class="s1">GlobalLayoutRouterContext,</span><span class="s3">\n  </span><span class="s1">TemplateContext,</span><span class="s3">\n</span><span class="s1">} from '../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import { fetchServerResponse } from './router-reducer/fetch-server-response'</span><span class="s3">\n</span><span class="s1">import { unresolvedThenable } from './unresolved-thenable'</span><span class="s3">\n</span><span class="s1">import { ErrorBoundary } from './error-boundary'</span><span class="s3">\n</span><span class="s1">import { matchSegment } from './match-segments'</span><span class="s3">\n</span><span class="s1">import { disableSmoothScrollDuringRouteTransition } from '../../shared/lib/router/utils/disable-smooth-scroll'</span><span class="s3">\n</span><span class="s1">import { RedirectBoundary } from './redirect-boundary'</span><span class="s3">\n</span><span class="s1">import { HTTPAccessFallbackBoundary } from './http-access-fallback/error-boundary'</span><span class="s3">\n</span><span class="s1">import { createRouterCacheKey } from './router-reducer/create-router-cache-key'</span><span class="s3">\n</span><span class="s1">import { hasInterceptionRouteInCurrentTree } from './router-reducer/reducers/has-interception-route-in-current-tree'</span><span class="s3">\n</span><span class="s1">import { dispatchAppRouterAction } from './use-action-queue'</span><span class="s3">\n</span><span class="s1">import { useRouterBFCache, type RouterBFCacheEntry } from './bfcache'</span><span class="s3">\n</span><span class="s1">import { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'</span><span class="s3">\n\n</span><span class="s1">const Activity = process.env.__NEXT_ROUTER_BF_CACHE</span><span class="s3">\n  </span><span class="s1">? (require('react') as typeof import('react')).unstable_Activity</span><span class="s3">\n  </span><span class="s1">: null!</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Add refetch marker to router state at the point of the current layout segment.</span><span class="s3">\n </span><span class="s1">* This ensures the response returned is not further down than the current layout segment.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function walkAddRefetch(</span><span class="s3">\n  </span><span class="s1">segmentPathToWalk: FlightSegmentPath | undefined,</span><span class="s3">\n  </span><span class="s1">treeToRecreate: FlightRouterState</span><span class="s3">\n</span><span class="s1">): FlightRouterState {</span><span class="s3">\n  </span><span class="s1">if (segmentPathToWalk) {</span><span class="s3">\n    </span><span class="s1">const [segment, parallelRouteKey] = segmentPathToWalk</span><span class="s3">\n    </span><span class="s1">const isLast = segmentPathToWalk.length === 2</span><span class="s3">\n\n    </span><span class="s1">if (matchSegment(treeToRecreate[0], segment)) {</span><span class="s3">\n      </span><span class="s1">if (treeToRecreate[1].hasOwnProperty(parallelRouteKey)) {</span><span class="s3">\n        </span><span class="s1">if (isLast) {</span><span class="s3">\n          </span><span class="s1">const subTree = walkAddRefetch(</span><span class="s3">\n            </span><span class="s1">undefined,</span><span class="s3">\n            </span><span class="s1">treeToRecreate[1][parallelRouteKey]</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">return [</span><span class="s3">\n            </span><span class="s1">treeToRecreate[0],</span><span class="s3">\n            </span><span class="s1">{</span><span class="s3">\n              </span><span class="s1">...treeToRecreate[1],</span><span class="s3">\n              </span><span class="s1">[parallelRouteKey]: [</span><span class="s3">\n                </span><span class="s1">subTree[0],</span><span class="s3">\n                </span><span class="s1">subTree[1],</span><span class="s3">\n                </span><span class="s1">subTree[2],</span><span class="s3">\n                </span><span class="s1">'refetch',</span><span class="s3">\n              </span><span class="s1">],</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">]</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">return [</span><span class="s3">\n          </span><span class="s1">treeToRecreate[0],</span><span class="s3">\n          </span><span class="s1">{</span><span class="s3">\n            </span><span class="s1">...treeToRecreate[1],</span><span class="s3">\n            </span><span class="s1">[parallelRouteKey]: walkAddRefetch(</span><span class="s3">\n              </span><span class="s1">segmentPathToWalk.slice(2),</span><span class="s3">\n              </span><span class="s1">treeToRecreate[1][parallelRouteKey]</span><span class="s3">\n            </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">]</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return treeToRecreate</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = (</span><span class="s3">\n  </span><span class="s1">ReactDOM as any</span><span class="s3">\n</span><span class="s1">).__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE</span><span class="s3">\n\n</span><span class="s1">// TODO-APP: Replace with new React API for finding dom nodes without a `ref` when available</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Wraps ReactDOM.findDOMNode with additional logic to hide React Strict Mode warning</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function findDOMNode(</span><span class="s3">\n  </span><span class="s1">instance: React.ReactInstance | null | undefined</span><span class="s3">\n</span><span class="s1">): Element | Text | null {</span><span class="s3">\n  </span><span class="s1">// Tree-shake for server bundle</span><span class="s3">\n  </span><span class="s1">if (typeof window === 'undefined') return null</span><span class="s3">\n\n  </span><span class="s1">// __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.findDOMNode is null during module init.</span><span class="s3">\n  </span><span class="s1">// We need to lazily reference it.</span><span class="s3">\n  </span><span class="s1">const internal_reactDOMfindDOMNode =</span><span class="s3">\n    </span><span class="s1">__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.findDOMNode</span><span class="s3">\n  </span><span class="s1">return internal_reactDOMfindDOMNode(instance)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const rectProperties = [</span><span class="s3">\n  </span><span class="s1">'bottom',</span><span class="s3">\n  </span><span class="s1">'height',</span><span class="s3">\n  </span><span class="s1">'left',</span><span class="s3">\n  </span><span class="s1">'right',</span><span class="s3">\n  </span><span class="s1">'top',</span><span class="s3">\n  </span><span class="s1">'width',</span><span class="s3">\n  </span><span class="s1">'x',</span><span class="s3">\n  </span><span class="s1">'y',</span><span class="s3">\n</span><span class="s1">] as const</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Check if a HTMLElement is hidden or fixed/sticky position</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function shouldSkipElement(element: HTMLElement) {</span><span class="s3">\n  </span><span class="s1">// we ignore fixed or sticky positioned elements since they'll likely pass the </span><span class="s3">\&quot;</span><span class="s1">in-viewport</span><span class="s3">\&quot; </span><span class="s1">check</span><span class="s3">\n  </span><span class="s1">// and will result in a situation we bail on scroll because of something like a fixed nav,</span><span class="s3">\n  </span><span class="s1">// even though the actual page content is offscreen</span><span class="s3">\n  </span><span class="s1">if (['sticky', 'fixed'].includes(getComputedStyle(element).position)) {</span><span class="s3">\n    </span><span class="s1">if (process.env.NODE_ENV === 'development') {</span><span class="s3">\n      </span><span class="s1">console.warn(</span><span class="s3">\n        </span><span class="s1">'Skipping auto-scroll behavior due to `position: sticky` or `position: fixed` on element:',</span><span class="s3">\n        </span><span class="s1">element</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Uses `getBoundingClientRect` to check if the element is hidden instead of `offsetParent`</span><span class="s3">\n  </span><span class="s1">// because `offsetParent` doesn't consider document/body</span><span class="s3">\n  </span><span class="s1">const rect = element.getBoundingClientRect()</span><span class="s3">\n  </span><span class="s1">return rectProperties.every((item) =&gt; rect[item] === 0)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Check if the top corner of the HTMLElement is in the viewport.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function topOfElementInViewport(element: HTMLElement, viewportHeight: number) {</span><span class="s3">\n  </span><span class="s1">const rect = element.getBoundingClientRect()</span><span class="s3">\n  </span><span class="s1">return rect.top &gt;= 0 &amp;&amp; rect.top &lt;= viewportHeight</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Find the DOM node for a hash fragment.</span><span class="s3">\n </span><span class="s1">* If `top` the page has to scroll to the top of the page. This mirrors the browser's behavior.</span><span class="s3">\n </span><span class="s1">* If the hash fragment is an id, the page has to scroll to the element with that id.</span><span class="s3">\n </span><span class="s1">* If the hash fragment is a name, the page has to scroll to the first element with that name.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getHashFragmentDomNode(hashFragment: string) {</span><span class="s3">\n  </span><span class="s1">// If the hash fragment is `top` the page has to scroll to the top of the page.</span><span class="s3">\n  </span><span class="s1">if (hashFragment === 'top') {</span><span class="s3">\n    </span><span class="s1">return document.body</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// If the hash fragment is an id, the page has to scroll to the element with that id.</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">document.getElementById(hashFragment) ??</span><span class="s3">\n    </span><span class="s1">// If the hash fragment is a name, the page has to scroll to the first element with that name.</span><span class="s3">\n    </span><span class="s1">document.getElementsByName(hashFragment)[0]</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">interface ScrollAndFocusHandlerProps {</span><span class="s3">\n  </span><span class="s1">focusAndScrollRef: FocusAndScrollRef</span><span class="s3">\n  </span><span class="s1">children: React.ReactNode</span><span class="s3">\n  </span><span class="s1">segmentPath: FlightSegmentPath</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class InnerScrollAndFocusHandler extends React.Component&lt;ScrollAndFocusHandlerProps&gt; {</span><span class="s3">\n  </span><span class="s1">handlePotentialScroll = () =&gt; {</span><span class="s3">\n    </span><span class="s1">// Handle scroll and focus, it's only applied once in the first useEffect that triggers that changed.</span><span class="s3">\n    </span><span class="s1">const { focusAndScrollRef, segmentPath } = this.props</span><span class="s3">\n\n    </span><span class="s1">if (focusAndScrollRef.apply) {</span><span class="s3">\n      </span><span class="s1">// segmentPaths is an array of segment paths that should be scrolled to</span><span class="s3">\n      </span><span class="s1">// if the current segment path is not in the array, the scroll is not applied</span><span class="s3">\n      </span><span class="s1">// unless the array is empty, in which case the scroll is always applied</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">focusAndScrollRef.segmentPaths.length !== 0 &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!focusAndScrollRef.segmentPaths.some((scrollRefSegmentPath) =&gt;</span><span class="s3">\n          </span><span class="s1">segmentPath.every((segment, index) =&gt;</span><span class="s3">\n            </span><span class="s1">matchSegment(segment, scrollRefSegmentPath[index])</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">let domNode:</span><span class="s3">\n        </span><span class="s1">| ReturnType&lt;typeof getHashFragmentDomNode&gt;</span><span class="s3">\n        </span><span class="s1">| ReturnType&lt;typeof findDOMNode&gt; = null</span><span class="s3">\n      </span><span class="s1">const hashFragment = focusAndScrollRef.hashFragment</span><span class="s3">\n\n      </span><span class="s1">if (hashFragment) {</span><span class="s3">\n        </span><span class="s1">domNode = getHashFragmentDomNode(hashFragment)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// `findDOMNode` is tricky because it returns just the first child if the component is a fragment.</span><span class="s3">\n      </span><span class="s1">// This already caused a bug where the first child was a &lt;link/&gt; in head.</span><span class="s3">\n      </span><span class="s1">if (!domNode) {</span><span class="s3">\n        </span><span class="s1">domNode = findDOMNode(this)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// If there is no DOM node this layout-router level is skipped. It'll be handled higher-up in the tree.</span><span class="s3">\n      </span><span class="s1">if (!(domNode instanceof Element)) {</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Verify if the element is a HTMLElement and if we want to consider it for scroll behavior.</span><span class="s3">\n      </span><span class="s1">// If the element is skipped, try to select the next sibling and try again.</span><span class="s3">\n      </span><span class="s1">while (!(domNode instanceof HTMLElement) || shouldSkipElement(domNode)) {</span><span class="s3">\n        </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n          </span><span class="s1">if (domNode.parentElement?.localName === 'head') {</span><span class="s3">\n            </span><span class="s1">// TODO: We enter this state when metadata was rendered as part of the page or via Next.js.</span><span class="s3">\n            </span><span class="s1">// This is always a bug in Next.js and caused by React hoisting metadata.</span><span class="s3">\n            </span><span class="s1">// We need to replace `findDOMNode` in favor of Fragment Refs (when available) so that we can skip over metadata.</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// No siblings found that match the criteria are found, so handle scroll higher up in the tree instead.</span><span class="s3">\n        </span><span class="s1">if (domNode.nextElementSibling === null) {</span><span class="s3">\n          </span><span class="s1">return</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">domNode = domNode.nextElementSibling</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// State is mutated to ensure that the focus and scroll is applied only once.</span><span class="s3">\n      </span><span class="s1">focusAndScrollRef.apply = false</span><span class="s3">\n      </span><span class="s1">focusAndScrollRef.hashFragment = null</span><span class="s3">\n      </span><span class="s1">focusAndScrollRef.segmentPaths = []</span><span class="s3">\n\n      </span><span class="s1">disableSmoothScrollDuringRouteTransition(</span><span class="s3">\n        </span><span class="s1">() =&gt; {</span><span class="s3">\n          </span><span class="s1">// In case of hash scroll, we only need to scroll the element into view</span><span class="s3">\n          </span><span class="s1">if (hashFragment) {</span><span class="s3">\n            </span><span class="s1">;(domNode as HTMLElement).scrollIntoView()</span><span class="s3">\n\n            </span><span class="s1">return</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">// Store the current viewport height because reading `clientHeight` causes a reflow,</span><span class="s3">\n          </span><span class="s1">// and it won't change during this function.</span><span class="s3">\n          </span><span class="s1">const htmlElement = document.documentElement</span><span class="s3">\n          </span><span class="s1">const viewportHeight = htmlElement.clientHeight</span><span class="s3">\n\n          </span><span class="s1">// If the element's top edge is already in the viewport, exit early.</span><span class="s3">\n          </span><span class="s1">if (topOfElementInViewport(domNode as HTMLElement, viewportHeight)) {</span><span class="s3">\n            </span><span class="s1">return</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">// Otherwise, try scrolling go the top of the document to be backward compatible with pages</span><span class="s3">\n          </span><span class="s1">// scrollIntoView() called on `&lt;html/&gt;` element scrolls horizontally on chrome and firefox (that shouldn't happen)</span><span class="s3">\n          </span><span class="s1">// We could use it to scroll horizontally following RTL but that also seems to be broken - it will always scroll left</span><span class="s3">\n          </span><span class="s1">// scrollLeft = 0 also seems to ignore RTL and manually checking for RTL is too much hassle so we will scroll just vertically</span><span class="s3">\n          </span><span class="s1">htmlElement.scrollTop = 0</span><span class="s3">\n\n          </span><span class="s1">// Scroll to domNode if domNode is not in viewport when scrolled to top of document</span><span class="s3">\n          </span><span class="s1">if (!topOfElementInViewport(domNode as HTMLElement, viewportHeight)) {</span><span class="s3">\n            </span><span class="s1">// Scroll into view doesn't scroll horizontally by default when not needed</span><span class="s3">\n            </span><span class="s1">;(domNode as HTMLElement).scrollIntoView()</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">// We will force layout by querying domNode position</span><span class="s3">\n          </span><span class="s1">dontForceLayout: true,</span><span class="s3">\n          </span><span class="s1">onlyHashChange: focusAndScrollRef.onlyHashChange,</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">// Mutate after scrolling so that it can be read by `disableSmoothScrollDuringRouteTransition`</span><span class="s3">\n      </span><span class="s1">focusAndScrollRef.onlyHashChange = false</span><span class="s3">\n\n      </span><span class="s1">// Set focus on the element</span><span class="s3">\n      </span><span class="s1">domNode.focus()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">componentDidMount() {</span><span class="s3">\n    </span><span class="s1">this.handlePotentialScroll()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">componentDidUpdate() {</span><span class="s3">\n    </span><span class="s1">// Because this property is overwritten in handlePotentialScroll it's fine to always run it when true as it'll be set to false for subsequent renders.</span><span class="s3">\n    </span><span class="s1">if (this.props.focusAndScrollRef.apply) {</span><span class="s3">\n      </span><span class="s1">this.handlePotentialScroll()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">render() {</span><span class="s3">\n    </span><span class="s1">return this.props.children</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function ScrollAndFocusHandler({</span><span class="s3">\n  </span><span class="s1">segmentPath,</span><span class="s3">\n  </span><span class="s1">children,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">segmentPath: FlightSegmentPath</span><span class="s3">\n  </span><span class="s1">children: React.ReactNode</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">const context = useContext(GlobalLayoutRouterContext)</span><span class="s3">\n  </span><span class="s1">if (!context) {</span><span class="s3">\n    </span><span class="s1">throw new Error('invariant global layout router not mounted')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">&lt;InnerScrollAndFocusHandler</span><span class="s3">\n      </span><span class="s1">segmentPath={segmentPath}</span><span class="s3">\n      </span><span class="s1">focusAndScrollRef={context.focusAndScrollRef}</span><span class="s3">\n    </span><span class="s1">&gt;</span><span class="s3">\n      </span><span class="s1">{children}</span><span class="s3">\n    </span><span class="s1">&lt;/InnerScrollAndFocusHandler&gt;</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* InnerLayoutRouter handles rendering the provided segment based on the cache.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function InnerLayoutRouter({</span><span class="s3">\n  </span><span class="s1">tree,</span><span class="s3">\n  </span><span class="s1">segmentPath,</span><span class="s3">\n  </span><span class="s1">cacheNode,</span><span class="s3">\n  </span><span class="s1">url,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">tree: FlightRouterState</span><span class="s3">\n  </span><span class="s1">segmentPath: FlightSegmentPath</span><span class="s3">\n  </span><span class="s1">cacheNode: CacheNode</span><span class="s3">\n  </span><span class="s1">url: string</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">const context = useContext(GlobalLayoutRouterContext)</span><span class="s3">\n  </span><span class="s1">if (!context) {</span><span class="s3">\n    </span><span class="s1">throw new Error('invariant global layout router not mounted')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { tree: fullTree } = context</span><span class="s3">\n\n  </span><span class="s1">// `rsc` represents the renderable node for this segment.</span><span class="s3">\n\n  </span><span class="s1">// If this segment has a `prefetchRsc`, it's the statically prefetched data.</span><span class="s3">\n  </span><span class="s1">// We should use that on initial render instead of `rsc`. Then we'll switch</span><span class="s3">\n  </span><span class="s1">// to `rsc` when the dynamic response streams in.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// If no prefetch data is available, then we go straight to rendering `rsc`.</span><span class="s3">\n  </span><span class="s1">const resolvedPrefetchRsc =</span><span class="s3">\n    </span><span class="s1">cacheNode.prefetchRsc !== null ? cacheNode.prefetchRsc : cacheNode.rsc</span><span class="s3">\n\n  </span><span class="s1">// We use `useDeferredValue` to handle switching between the prefetched and</span><span class="s3">\n  </span><span class="s1">// final values. The second argument is returned on initial render, then it</span><span class="s3">\n  </span><span class="s1">// re-renders with the first argument.</span><span class="s3">\n  </span><span class="s1">const rsc: any = useDeferredValue(cacheNode.rsc, resolvedPrefetchRsc)</span><span class="s3">\n\n  </span><span class="s1">// `rsc` is either a React node or a promise for a React node, except we</span><span class="s3">\n  </span><span class="s1">// special case `null` to represent that this segment's data is missing. If</span><span class="s3">\n  </span><span class="s1">// it's a promise, we need to unwrap it so we can determine whether or not the</span><span class="s3">\n  </span><span class="s1">// data is missing.</span><span class="s3">\n  </span><span class="s1">const resolvedRsc: React.ReactNode =</span><span class="s3">\n    </span><span class="s1">typeof rsc === 'object' &amp;&amp; rsc !== null &amp;&amp; typeof rsc.then === 'function'</span><span class="s3">\n      </span><span class="s1">? use(rsc)</span><span class="s3">\n      </span><span class="s1">: rsc</span><span class="s3">\n\n  </span><span class="s1">if (!resolvedRsc) {</span><span class="s3">\n    </span><span class="s1">// The data for this segment is not available, and there's no pending</span><span class="s3">\n    </span><span class="s1">// navigation that will be able to fulfill it. We need to fetch more from</span><span class="s3">\n    </span><span class="s1">// the server and patch the cache.</span><span class="s3">\n\n    </span><span class="s1">// Check if there's already a pending request.</span><span class="s3">\n    </span><span class="s1">let lazyData = cacheNode.lazyData</span><span class="s3">\n    </span><span class="s1">if (lazyData === null) {</span><span class="s3">\n      </span><span class="s1">/**</span><span class="s3">\n       </span><span class="s1">* Router state with refetch marker added</span><span class="s3">\n       </span><span class="s1">*/</span><span class="s3">\n      </span><span class="s1">// TODO-APP: remove ''</span><span class="s3">\n      </span><span class="s1">const refetchTree = walkAddRefetch(['', ...segmentPath], fullTree)</span><span class="s3">\n      </span><span class="s1">const includeNextUrl = hasInterceptionRouteInCurrentTree(fullTree)</span><span class="s3">\n      </span><span class="s1">const navigatedAt = Date.now()</span><span class="s3">\n      </span><span class="s1">cacheNode.lazyData = lazyData = fetchServerResponse(</span><span class="s3">\n        </span><span class="s1">new URL(url, location.origin),</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">flightRouterState: refetchTree,</span><span class="s3">\n          </span><span class="s1">nextUrl: includeNextUrl ? context.nextUrl : null,</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">).then((serverResponse) =&gt; {</span><span class="s3">\n        </span><span class="s1">startTransition(() =&gt; {</span><span class="s3">\n          </span><span class="s1">dispatchAppRouterAction({</span><span class="s3">\n            </span><span class="s1">type: ACTION_SERVER_PATCH,</span><span class="s3">\n            </span><span class="s1">previousTree: fullTree,</span><span class="s3">\n            </span><span class="s1">serverResponse,</span><span class="s3">\n            </span><span class="s1">navigatedAt,</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n\n        </span><span class="s1">return serverResponse</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n\n      </span><span class="s1">// Suspend while waiting for lazyData to resolve</span><span class="s3">\n      </span><span class="s1">use(lazyData)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Suspend infinitely as `changeByServerResponse` will cause a different part of the tree to be rendered.</span><span class="s3">\n    </span><span class="s1">// A falsey `resolvedRsc` indicates missing data -- we should not commit that branch, and we need to wait for the data to arrive.</span><span class="s3">\n    </span><span class="s1">use(unresolvedThenable) as never</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// If we get to this point, then we know we have something we can render.</span><span class="s3">\n  </span><span class="s1">const subtree = (</span><span class="s3">\n    </span><span class="s1">// The layout router context narrows down tree and childNodes at each level.</span><span class="s3">\n    </span><span class="s1">&lt;LayoutRouterContext.Provider</span><span class="s3">\n      </span><span class="s1">value={{</span><span class="s3">\n        </span><span class="s1">parentTree: tree,</span><span class="s3">\n        </span><span class="s1">parentCacheNode: cacheNode,</span><span class="s3">\n        </span><span class="s1">parentSegmentPath: segmentPath,</span><span class="s3">\n\n        </span><span class="s1">// TODO-APP: overriding of url for parallel routes</span><span class="s3">\n        </span><span class="s1">url: url,</span><span class="s3">\n      </span><span class="s1">}}</span><span class="s3">\n    </span><span class="s1">&gt;</span><span class="s3">\n      </span><span class="s1">{resolvedRsc}</span><span class="s3">\n    </span><span class="s1">&lt;/LayoutRouterContext.Provider&gt;</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">// Ensure root layout is not wrapped in a div as the root layout renders `&lt;html&gt;`</span><span class="s3">\n  </span><span class="s1">return subtree</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Renders suspense boundary with the provided </span><span class="s3">\&quot;</span><span class="s1">loading</span><span class="s3">\&quot; </span><span class="s1">property as the fallback.</span><span class="s3">\n </span><span class="s1">* If no loading property is provided it renders the children without a suspense boundary.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function LoadingBoundary({</span><span class="s3">\n  </span><span class="s1">loading,</span><span class="s3">\n  </span><span class="s1">children,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">loading: LoadingModuleData | Promise&lt;LoadingModuleData&gt;</span><span class="s3">\n  </span><span class="s1">children: React.ReactNode</span><span class="s3">\n</span><span class="s1">}): JSX.Element {</span><span class="s3">\n  </span><span class="s1">// If loading is a promise, unwrap it. This happens in cases where we haven't</span><span class="s3">\n  </span><span class="s1">// yet received the loading data from the server — which includes whether or</span><span class="s3">\n  </span><span class="s1">// not this layout has a loading component at all.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// It's OK to suspend here instead of inside the fallback because this</span><span class="s3">\n  </span><span class="s1">// promise will resolve simultaneously with the data for the segment itself.</span><span class="s3">\n  </span><span class="s1">// So it will never suspend for longer than it would have if we didn't use</span><span class="s3">\n  </span><span class="s1">// a Suspense fallback at all.</span><span class="s3">\n  </span><span class="s1">let loadingModuleData</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">typeof loading === 'object' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">loading !== null &amp;&amp;</span><span class="s3">\n    </span><span class="s1">typeof (loading as any).then === 'function'</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const promiseForLoading = loading as Promise&lt;LoadingModuleData&gt;</span><span class="s3">\n    </span><span class="s1">loadingModuleData = use(promiseForLoading)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">loadingModuleData = loading as LoadingModuleData</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (loadingModuleData) {</span><span class="s3">\n    </span><span class="s1">const loadingRsc = loadingModuleData[0]</span><span class="s3">\n    </span><span class="s1">const loadingStyles = loadingModuleData[1]</span><span class="s3">\n    </span><span class="s1">const loadingScripts = loadingModuleData[2]</span><span class="s3">\n    </span><span class="s1">return (</span><span class="s3">\n      </span><span class="s1">&lt;Suspense</span><span class="s3">\n        </span><span class="s1">fallback={</span><span class="s3">\n          </span><span class="s1">&lt;&gt;</span><span class="s3">\n            </span><span class="s1">{loadingStyles}</span><span class="s3">\n            </span><span class="s1">{loadingScripts}</span><span class="s3">\n            </span><span class="s1">{loadingRsc}</span><span class="s3">\n          </span><span class="s1">&lt;/&gt;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">&gt;</span><span class="s3">\n        </span><span class="s1">{children}</span><span class="s3">\n      </span><span class="s1">&lt;/Suspense&gt;</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return &lt;&gt;{children}&lt;/&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* OuterLayoutRouter handles the current segment as well as &lt;Offscreen&gt; rendering of other segments.</span><span class="s3">\n </span><span class="s1">* It can be rendered next to each other with a different `parallelRouterKey`, allowing for Parallel routes.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function OuterLayoutRouter({</span><span class="s3">\n  </span><span class="s1">parallelRouterKey,</span><span class="s3">\n  </span><span class="s1">error,</span><span class="s3">\n  </span><span class="s1">errorStyles,</span><span class="s3">\n  </span><span class="s1">errorScripts,</span><span class="s3">\n  </span><span class="s1">templateStyles,</span><span class="s3">\n  </span><span class="s1">templateScripts,</span><span class="s3">\n  </span><span class="s1">template,</span><span class="s3">\n  </span><span class="s1">notFound,</span><span class="s3">\n  </span><span class="s1">forbidden,</span><span class="s3">\n  </span><span class="s1">unauthorized,</span><span class="s3">\n  </span><span class="s1">segmentViewBoundaries,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">parallelRouterKey: string</span><span class="s3">\n  </span><span class="s1">error: ErrorComponent | undefined</span><span class="s3">\n  </span><span class="s1">errorStyles: React.ReactNode | undefined</span><span class="s3">\n  </span><span class="s1">errorScripts: React.ReactNode | undefined</span><span class="s3">\n  </span><span class="s1">templateStyles: React.ReactNode | undefined</span><span class="s3">\n  </span><span class="s1">templateScripts: React.ReactNode | undefined</span><span class="s3">\n  </span><span class="s1">template: React.ReactNode</span><span class="s3">\n  </span><span class="s1">notFound: React.ReactNode | undefined</span><span class="s3">\n  </span><span class="s1">forbidden: React.ReactNode | undefined</span><span class="s3">\n  </span><span class="s1">unauthorized: React.ReactNode | undefined</span><span class="s3">\n  </span><span class="s1">segmentViewBoundaries?: React.ReactNode</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">const context = useContext(LayoutRouterContext)</span><span class="s3">\n  </span><span class="s1">if (!context) {</span><span class="s3">\n    </span><span class="s1">throw new Error('invariant expected layout router to be mounted')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { parentTree, parentCacheNode, parentSegmentPath, url } = context</span><span class="s3">\n\n  </span><span class="s1">// Get the CacheNode for this segment by reading it from the parent segment's</span><span class="s3">\n  </span><span class="s1">// child map.</span><span class="s3">\n  </span><span class="s1">const parentParallelRoutes = parentCacheNode.parallelRoutes</span><span class="s3">\n  </span><span class="s1">let segmentMap = parentParallelRoutes.get(parallelRouterKey)</span><span class="s3">\n  </span><span class="s1">// If the parallel router cache node does not exist yet, create it.</span><span class="s3">\n  </span><span class="s1">// This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.</span><span class="s3">\n  </span><span class="s1">if (!segmentMap) {</span><span class="s3">\n    </span><span class="s1">segmentMap = new Map()</span><span class="s3">\n    </span><span class="s1">parentParallelRoutes.set(parallelRouterKey, segmentMap)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const parentTreeSegment = parentTree[0]</span><span class="s3">\n  </span><span class="s1">const segmentPath =</span><span class="s3">\n    </span><span class="s1">parentSegmentPath === null</span><span class="s3">\n      </span><span class="s1">? // TODO: The root segment value is currently omitted from the segment</span><span class="s3">\n        </span><span class="s1">// path. This has led to a bunch of special cases scattered throughout</span><span class="s3">\n        </span><span class="s1">// the code. We should clean this up.</span><span class="s3">\n        </span><span class="s1">[parallelRouterKey]</span><span class="s3">\n      </span><span class="s1">: parentSegmentPath.concat([parentTreeSegment, parallelRouterKey])</span><span class="s3">\n\n  </span><span class="s1">// The </span><span class="s3">\&quot;</span><span class="s1">state</span><span class="s3">\&quot; </span><span class="s1">key of a segment is the one passed to React — it represents the</span><span class="s3">\n  </span><span class="s1">// identity of the UI tree. Whenever the state key changes, the tree is</span><span class="s3">\n  </span><span class="s1">// recreated and the state is reset. In the App Router model, search params do</span><span class="s3">\n  </span><span class="s1">// not cause state to be lost, so two segments with the same segment path but</span><span class="s3">\n  </span><span class="s1">// different search params should have the same state key.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// The </span><span class="s3">\&quot;</span><span class="s1">cache</span><span class="s3">\&quot; </span><span class="s1">key of a segment, however, *does* include the search params, if</span><span class="s3">\n  </span><span class="s1">// it's possible that the segment accessed the search params on the server.</span><span class="s3">\n  </span><span class="s1">// (This only applies to page segments; layout segments cannot access search</span><span class="s3">\n  </span><span class="s1">// params on the server.)</span><span class="s3">\n  </span><span class="s1">const activeTree = parentTree[1][parallelRouterKey]</span><span class="s3">\n  </span><span class="s1">const activeSegment = activeTree[0]</span><span class="s3">\n  </span><span class="s1">const activeStateKey = createRouterCacheKey(activeSegment, true) // no search params</span><span class="s3">\n\n  </span><span class="s1">// At each level of the route tree, not only do we render the currently</span><span class="s3">\n  </span><span class="s1">// active segment — we also render the last N segments that were active at</span><span class="s3">\n  </span><span class="s1">// this level inside a hidden &lt;Activity&gt; boundary, to preserve their state</span><span class="s3">\n  </span><span class="s1">// if or when the user navigates to them again.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// bfcacheEntry is a linked list of FlightRouterStates.</span><span class="s3">\n  </span><span class="s1">let bfcacheEntry: RouterBFCacheEntry | null = useRouterBFCache(</span><span class="s3">\n    </span><span class="s1">activeTree,</span><span class="s3">\n    </span><span class="s1">activeStateKey</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">let children: Array&lt;React.ReactNode&gt; = []</span><span class="s3">\n  </span><span class="s1">do {</span><span class="s3">\n    </span><span class="s1">const tree = bfcacheEntry.tree</span><span class="s3">\n    </span><span class="s1">const stateKey = bfcacheEntry.stateKey</span><span class="s3">\n    </span><span class="s1">const segment = tree[0]</span><span class="s3">\n    </span><span class="s1">const cacheKey = createRouterCacheKey(segment)</span><span class="s3">\n\n    </span><span class="s1">// Read segment path from the parallel router cache node.</span><span class="s3">\n    </span><span class="s1">let cacheNode = segmentMap.get(cacheKey)</span><span class="s3">\n    </span><span class="s1">if (cacheNode === undefined) {</span><span class="s3">\n      </span><span class="s1">// When data is not available during rendering client-side we need to fetch</span><span class="s3">\n      </span><span class="s1">// it from the server.</span><span class="s3">\n      </span><span class="s1">const newLazyCacheNode: LazyCacheNode = {</span><span class="s3">\n        </span><span class="s1">lazyData: null,</span><span class="s3">\n        </span><span class="s1">rsc: null,</span><span class="s3">\n        </span><span class="s1">prefetchRsc: null,</span><span class="s3">\n        </span><span class="s1">head: null,</span><span class="s3">\n        </span><span class="s1">prefetchHead: null,</span><span class="s3">\n        </span><span class="s1">parallelRoutes: new Map(),</span><span class="s3">\n        </span><span class="s1">loading: null,</span><span class="s3">\n        </span><span class="s1">navigatedAt: -1,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Flight data fetch kicked off during render and put into the cache.</span><span class="s3">\n      </span><span class="s1">cacheNode = newLazyCacheNode</span><span class="s3">\n      </span><span class="s1">segmentMap.set(cacheKey, newLazyCacheNode)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">/*</span><span class="s3">\n    </span><span class="s1">- Error boundary</span><span class="s3">\n      </span><span class="s1">- Only renders error boundary if error component is provided.</span><span class="s3">\n      </span><span class="s1">- Rendered for each segment to ensure they have their own error state.</span><span class="s3">\n      </span><span class="s1">- When gracefully degrade for bots, skip rendering error boundary.</span><span class="s3">\n    </span><span class="s1">- Loading boundary</span><span class="s3">\n      </span><span class="s1">- Only renders suspense boundary if loading components is provided.</span><span class="s3">\n      </span><span class="s1">- Rendered for each segment to ensure they have their own loading state.</span><span class="s3">\n      </span><span class="s1">- Passed to the router during rendering to ensure it can be immediately rendered when suspending on a Flight fetch.</span><span class="s3">\n  </span><span class="s1">*/</span><span class="s3">\n\n    </span><span class="s1">let segmentBoundaryTriggerNode: React.ReactNode = null</span><span class="s3">\n    </span><span class="s1">let segmentViewStateNode: React.ReactNode = null</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">process.env.__NEXT_DEVTOOL_SEGMENT_EXPLORER</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">const { SegmentBoundaryTriggerNode, SegmentViewStateNode } =</span><span class="s3">\n        </span><span class="s1">require('../../next-devtools/userspace/app/segment-explorer-node') as typeof import('../../next-devtools/userspace/app/segment-explorer-node')</span><span class="s3">\n\n      </span><span class="s1">const pagePrefix = normalizeAppPath(url)</span><span class="s3">\n      </span><span class="s1">segmentViewStateNode = (</span><span class="s3">\n        </span><span class="s1">&lt;SegmentViewStateNode key={pagePrefix} page={pagePrefix} /&gt;</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">segmentBoundaryTriggerNode = (</span><span class="s3">\n        </span><span class="s1">&lt;&gt;</span><span class="s3">\n          </span><span class="s1">&lt;SegmentBoundaryTriggerNode /&gt;</span><span class="s3">\n        </span><span class="s1">&lt;/&gt;</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// TODO: The loading module data for a segment is stored on the parent, then</span><span class="s3">\n    </span><span class="s1">// applied to each of that parent segment's parallel route slots. In the</span><span class="s3">\n    </span><span class="s1">// simple case where there's only one parallel route (the `children` slot),</span><span class="s3">\n    </span><span class="s1">// this is no different from if the loading module data where stored on the</span><span class="s3">\n    </span><span class="s1">// child directly. But I'm not sure this actually makes sense when there are</span><span class="s3">\n    </span><span class="s1">// multiple parallel routes. It's not a huge issue because you always have</span><span class="s3">\n    </span><span class="s1">// the option to define a narrower loading boundary for a particular slot. But</span><span class="s3">\n    </span><span class="s1">// this sort of smells like an implementation accident to me.</span><span class="s3">\n    </span><span class="s1">const loadingModuleData = parentCacheNode.loading</span><span class="s3">\n    </span><span class="s1">let child = (</span><span class="s3">\n      </span><span class="s1">&lt;TemplateContext.Provider</span><span class="s3">\n        </span><span class="s1">key={stateKey}</span><span class="s3">\n        </span><span class="s1">value={</span><span class="s3">\n          </span><span class="s1">&lt;ScrollAndFocusHandler segmentPath={segmentPath}&gt;</span><span class="s3">\n            </span><span class="s1">&lt;ErrorBoundary</span><span class="s3">\n              </span><span class="s1">errorComponent={error}</span><span class="s3">\n              </span><span class="s1">errorStyles={errorStyles}</span><span class="s3">\n              </span><span class="s1">errorScripts={errorScripts}</span><span class="s3">\n            </span><span class="s1">&gt;</span><span class="s3">\n              </span><span class="s1">&lt;LoadingBoundary loading={loadingModuleData}&gt;</span><span class="s3">\n                </span><span class="s1">&lt;HTTPAccessFallbackBoundary</span><span class="s3">\n                  </span><span class="s1">notFound={notFound}</span><span class="s3">\n                  </span><span class="s1">forbidden={forbidden}</span><span class="s3">\n                  </span><span class="s1">unauthorized={unauthorized}</span><span class="s3">\n                </span><span class="s1">&gt;</span><span class="s3">\n                  </span><span class="s1">&lt;RedirectBoundary&gt;</span><span class="s3">\n                    </span><span class="s1">&lt;InnerLayoutRouter</span><span class="s3">\n                      </span><span class="s1">url={url}</span><span class="s3">\n                      </span><span class="s1">tree={tree}</span><span class="s3">\n                      </span><span class="s1">cacheNode={cacheNode}</span><span class="s3">\n                      </span><span class="s1">segmentPath={segmentPath}</span><span class="s3">\n                    </span><span class="s1">/&gt;</span><span class="s3">\n                    </span><span class="s1">{segmentBoundaryTriggerNode}</span><span class="s3">\n                  </span><span class="s1">&lt;/RedirectBoundary&gt;</span><span class="s3">\n                </span><span class="s1">&lt;/HTTPAccessFallbackBoundary&gt;</span><span class="s3">\n              </span><span class="s1">&lt;/LoadingBoundary&gt;</span><span class="s3">\n            </span><span class="s1">&lt;/ErrorBoundary&gt;</span><span class="s3">\n            </span><span class="s1">{segmentViewStateNode}</span><span class="s3">\n          </span><span class="s1">&lt;/ScrollAndFocusHandler&gt;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">&gt;</span><span class="s3">\n        </span><span class="s1">{templateStyles}</span><span class="s3">\n        </span><span class="s1">{templateScripts}</span><span class="s3">\n        </span><span class="s1">{template}</span><span class="s3">\n      </span><span class="s1">&lt;/TemplateContext.Provider&gt;</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n      </span><span class="s1">const { SegmentStateProvider } =</span><span class="s3">\n        </span><span class="s1">require('../../next-devtools/userspace/app/segment-explorer-node') as typeof import('../../next-devtools/userspace/app/segment-explorer-node')</span><span class="s3">\n\n      </span><span class="s1">child = (</span><span class="s3">\n        </span><span class="s1">&lt;SegmentStateProvider key={stateKey}&gt;</span><span class="s3">\n          </span><span class="s1">{child}</span><span class="s3">\n          </span><span class="s1">{segmentViewBoundaries}</span><span class="s3">\n        </span><span class="s1">&lt;/SegmentStateProvider&gt;</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (process.env.__NEXT_ROUTER_BF_CACHE) {</span><span class="s3">\n      </span><span class="s1">child = (</span><span class="s3">\n        </span><span class="s1">&lt;Activity</span><span class="s3">\n          </span><span class="s1">key={stateKey}</span><span class="s3">\n          </span><span class="s1">mode={stateKey === activeStateKey ? 'visible' : 'hidden'}</span><span class="s3">\n        </span><span class="s1">&gt;</span><span class="s3">\n          </span><span class="s1">{child}</span><span class="s3">\n        </span><span class="s1">&lt;/Activity&gt;</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">children.push(child)</span><span class="s3">\n\n    </span><span class="s1">bfcacheEntry = bfcacheEntry.next</span><span class="s3">\n  </span><span class="s1">} while (bfcacheEntry !== null)</span><span class="s3">\n\n  </span><span class="s1">return children</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;OuterLayoutRouter&quot;</span><span class="s0">,</span><span class="s1">&quot;Activity&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_ROUTER_BF_CACHE&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;unstable_Activity&quot;</span><span class="s0">,</span><span class="s1">&quot;walkAddRefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentPathToWalk&quot;</span><span class="s0">,</span><span class="s1">&quot;treeToRecreate&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRouteKey&quot;</span><span class="s0">,</span><span class="s1">&quot;isLast&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;matchSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;hasOwnProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;subTree&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE&quot;</span><span class="s0">,</span><span class="s1">&quot;ReactDOM&quot;</span><span class="s0">,</span><span class="s1">&quot;findDOMNode&quot;</span><span class="s0">,</span><span class="s1">&quot;instance&quot;</span><span class="s0">,</span><span class="s1">&quot;window&quot;</span><span class="s0">,</span><span class="s1">&quot;internal_reactDOMfindDOMNode&quot;</span><span class="s0">,</span><span class="s1">&quot;rectProperties&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldSkipElement&quot;</span><span class="s0">,</span><span class="s1">&quot;element&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;getComputedStyle&quot;</span><span class="s0">,</span><span class="s1">&quot;position&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;warn&quot;</span><span class="s0">,</span><span class="s1">&quot;rect&quot;</span><span class="s0">,</span><span class="s1">&quot;getBoundingClientRect&quot;</span><span class="s0">,</span><span class="s1">&quot;every&quot;</span><span class="s0">,</span><span class="s1">&quot;item&quot;</span><span class="s0">,</span><span class="s1">&quot;topOfElementInViewport&quot;</span><span class="s0">,</span><span class="s1">&quot;viewportHeight&quot;</span><span class="s0">,</span><span class="s1">&quot;top&quot;</span><span class="s0">,</span><span class="s1">&quot;getHashFragmentDomNode&quot;</span><span class="s0">,</span><span class="s1">&quot;hashFragment&quot;</span><span class="s0">,</span><span class="s1">&quot;document&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;getElementById&quot;</span><span class="s0">,</span><span class="s1">&quot;getElementsByName&quot;</span><span class="s0">,</span><span class="s1">&quot;InnerScrollAndFocusHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;React&quot;</span><span class="s0">,</span><span class="s1">&quot;Component&quot;</span><span class="s0">,</span><span class="s1">&quot;componentDidMount&quot;</span><span class="s0">,</span><span class="s1">&quot;handlePotentialScroll&quot;</span><span class="s0">,</span><span class="s1">&quot;componentDidUpdate&quot;</span><span class="s0">,</span><span class="s1">&quot;props&quot;</span><span class="s0">,</span><span class="s1">&quot;focusAndScrollRef&quot;</span><span class="s0">,</span><span class="s1">&quot;apply&quot;</span><span class="s0">,</span><span class="s1">&quot;render&quot;</span><span class="s0">,</span><span class="s1">&quot;children&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;some&quot;</span><span class="s0">,</span><span class="s1">&quot;scrollRefSegmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;index&quot;</span><span class="s0">,</span><span class="s1">&quot;domNode&quot;</span><span class="s0">,</span><span class="s1">&quot;Element&quot;</span><span class="s0">,</span><span class="s1">&quot;HTMLElement&quot;</span><span class="s0">,</span><span class="s1">&quot;parentElement&quot;</span><span class="s0">,</span><span class="s1">&quot;localName&quot;</span><span class="s0">,</span><span class="s1">&quot;nextElementSibling&quot;</span><span class="s0">,</span><span class="s1">&quot;disableSmoothScrollDuringRouteTransition&quot;</span><span class="s0">,</span><span class="s1">&quot;scrollIntoView&quot;</span><span class="s0">,</span><span class="s1">&quot;htmlElement&quot;</span><span class="s0">,</span><span class="s1">&quot;documentElement&quot;</span><span class="s0">,</span><span class="s1">&quot;clientHeight&quot;</span><span class="s0">,</span><span class="s1">&quot;scrollTop&quot;</span><span class="s0">,</span><span class="s1">&quot;dontForceLayout&quot;</span><span class="s0">,</span><span class="s1">&quot;onlyHashChange&quot;</span><span class="s0">,</span><span class="s1">&quot;focus&quot;</span><span class="s0">,</span><span class="s1">&quot;ScrollAndFocusHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;context&quot;</span><span class="s0">,</span><span class="s1">&quot;useContext&quot;</span><span class="s0">,</span><span class="s1">&quot;GlobalLayoutRouterContext&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;InnerLayoutRouter&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;fullTree&quot;</span><span class="s0">,</span><span class="s1">&quot;resolvedPrefetchRsc&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchRsc&quot;</span><span class="s0">,</span><span class="s1">&quot;rsc&quot;</span><span class="s0">,</span><span class="s1">&quot;useDeferredValue&quot;</span><span class="s0">,</span><span class="s1">&quot;resolvedRsc&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;use&quot;</span><span class="s0">,</span><span class="s1">&quot;lazyData&quot;</span><span class="s0">,</span><span class="s1">&quot;refetchTree&quot;</span><span class="s0">,</span><span class="s1">&quot;includeNextUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;hasInterceptionRouteInCurrentTree&quot;</span><span class="s0">,</span><span class="s1">&quot;navigatedAt&quot;</span><span class="s0">,</span><span class="s1">&quot;Date&quot;</span><span class="s0">,</span><span class="s1">&quot;now&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchServerResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;URL&quot;</span><span class="s0">,</span><span class="s1">&quot;location&quot;</span><span class="s0">,</span><span class="s1">&quot;origin&quot;</span><span class="s0">,</span><span class="s1">&quot;flightRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;nextUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;serverResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;startTransition&quot;</span><span class="s0">,</span><span class="s1">&quot;dispatchAppRouterAction&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;ACTION_SERVER_PATCH&quot;</span><span class="s0">,</span><span class="s1">&quot;previousTree&quot;</span><span class="s0">,</span><span class="s1">&quot;unresolvedThenable&quot;</span><span class="s0">,</span><span class="s1">&quot;subtree&quot;</span><span class="s0">,</span><span class="s1">&quot;LayoutRouterContext&quot;</span><span class="s0">,</span><span class="s1">&quot;Provider&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;parentTree&quot;</span><span class="s0">,</span><span class="s1">&quot;parentCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;parentSegmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;LoadingBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;loading&quot;</span><span class="s0">,</span><span class="s1">&quot;loadingModuleData&quot;</span><span class="s0">,</span><span class="s1">&quot;promiseForLoading&quot;</span><span class="s0">,</span><span class="s1">&quot;loadingRsc&quot;</span><span class="s0">,</span><span class="s1">&quot;loadingStyles&quot;</span><span class="s0">,</span><span class="s1">&quot;loadingScripts&quot;</span><span class="s0">,</span><span class="s1">&quot;Suspense&quot;</span><span class="s0">,</span><span class="s1">&quot;fallback&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRouterKey&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;errorStyles&quot;</span><span class="s0">,</span><span class="s1">&quot;errorScripts&quot;</span><span class="s0">,</span><span class="s1">&quot;templateStyles&quot;</span><span class="s0">,</span><span class="s1">&quot;templateScripts&quot;</span><span class="s0">,</span><span class="s1">&quot;template&quot;</span><span class="s0">,</span><span class="s1">&quot;notFound&quot;</span><span class="s0">,</span><span class="s1">&quot;forbidden&quot;</span><span class="s0">,</span><span class="s1">&quot;unauthorized&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentViewBoundaries&quot;</span><span class="s0">,</span><span class="s1">&quot;parentParallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentMap&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;parentTreeSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;concat&quot;</span><span class="s0">,</span><span class="s1">&quot;activeTree&quot;</span><span class="s0">,</span><span class="s1">&quot;activeSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;activeStateKey&quot;</span><span class="s0">,</span><span class="s1">&quot;createRouterCacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;bfcacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;useRouterBFCache&quot;</span><span class="s0">,</span><span class="s1">&quot;stateKey&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;newLazyCacheNode&quot;</span><span class="s0">,</span><span class="s1">&quot;head&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchHead&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentBoundaryTriggerNode&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentViewStateNode&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_DEVTOOL_SEGMENT_EXPLORER&quot;</span><span class="s0">,</span><span class="s1">&quot;SegmentBoundaryTriggerNode&quot;</span><span class="s0">,</span><span class="s1">&quot;SegmentViewStateNode&quot;</span><span class="s0">,</span><span class="s1">&quot;pagePrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeAppPath&quot;</span><span class="s0">,</span><span class="s1">&quot;page&quot;</span><span class="s0">,</span><span class="s1">&quot;child&quot;</span><span class="s0">,</span><span class="s1">&quot;TemplateContext&quot;</span><span class="s0">,</span><span class="s1">&quot;ErrorBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;errorComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;HTTPAccessFallbackBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;RedirectBoundary&quot;</span><span class="s0">,</span><span class="s1">&quot;SegmentStateProvider&quot;</span><span class="s0">,</span><span class="s1">&quot;mode&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;next&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>