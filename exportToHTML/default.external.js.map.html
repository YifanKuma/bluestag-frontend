<html>
<head>
<title>default.external.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
default.external.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../src/server/lib/cache-handlers/default.external.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* This is the default </span><span class="s3">\&quot;</span><span class="s1">use cache</span><span class="s3">\&quot; </span><span class="s1">handler it defaults to an in-memory store.</span><span class="s3">\n </span><span class="s1">* In-memory caches are fragile and should not use stale-while-revalidate</span><span class="s3">\n </span><span class="s1">* semantics on the caches because it's not worth warming up an entry that's</span><span class="s3">\n </span><span class="s1">* likely going to get evicted before we get to use it anyway. However, we also</span><span class="s3">\n </span><span class="s1">* don't want to reuse a stale entry for too long so stale entries should be</span><span class="s3">\n </span><span class="s1">* considered expired/missing in such cache handlers.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">import { LRUCache } from '../lru-cache'</span><span class="s3">\n</span><span class="s1">import type { CacheEntry, CacheHandlerV2 } from './types'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">isStale,</span><span class="s3">\n  </span><span class="s1">tagsManifest,</span><span class="s3">\n</span><span class="s1">} from '../incremental-cache/tags-manifest.external'</span><span class="s3">\n\n</span><span class="s1">type PrivateCacheEntry = {</span><span class="s3">\n  </span><span class="s1">entry: CacheEntry</span><span class="s3">\n\n  </span><span class="s1">// For the default cache we store errored cache</span><span class="s3">\n  </span><span class="s1">// entries and allow them to be used up to 3 times</span><span class="s3">\n  </span><span class="s1">// after that we want to dispose it and try for fresh</span><span class="s3">\n\n  </span><span class="s1">// If an entry is errored we return no entry</span><span class="s3">\n  </span><span class="s1">// three times so that we retry hitting origin (MISS)</span><span class="s3">\n  </span><span class="s1">// and then if it still fails to set after the third we</span><span class="s3">\n  </span><span class="s1">// return the errored content and use expiration of</span><span class="s3">\n  </span><span class="s1">// Math.min(30, entry.expiration)</span><span class="s3">\n  </span><span class="s1">isErrored: boolean</span><span class="s3">\n  </span><span class="s1">errorRetryCount: number</span><span class="s3">\n\n  </span><span class="s1">// compute size on set since we need to read size</span><span class="s3">\n  </span><span class="s1">// of the ReadableStream for LRU evicting</span><span class="s3">\n  </span><span class="s1">size: number</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// LRU cache default to max 50 MB but in future track</span><span class="s3">\n</span><span class="s1">const memoryCache = new LRUCache&lt;PrivateCacheEntry&gt;(</span><span class="s3">\n  </span><span class="s1">50 * 1024 * 1024,</span><span class="s3">\n  </span><span class="s1">(entry) =&gt; entry.size</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">const pendingSets = new Map&lt;string, Promise&lt;void&gt;&gt;()</span><span class="s3">\n\n</span><span class="s1">const debug = process.env.NEXT_PRIVATE_DEBUG_CACHE</span><span class="s3">\n  </span><span class="s1">? console.debug.bind(console, 'DefaultCacheHandler:')</span><span class="s3">\n  </span><span class="s1">: undefined</span><span class="s3">\n\n</span><span class="s1">const DefaultCacheHandler: CacheHandlerV2 = {</span><span class="s3">\n  </span><span class="s1">async get(cacheKey) {</span><span class="s3">\n    </span><span class="s1">const pendingPromise = pendingSets.get(cacheKey)</span><span class="s3">\n\n    </span><span class="s1">if (pendingPromise) {</span><span class="s3">\n      </span><span class="s1">debug?.('get', cacheKey, 'pending')</span><span class="s3">\n      </span><span class="s1">await pendingPromise</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const privateEntry = memoryCache.get(cacheKey)</span><span class="s3">\n\n    </span><span class="s1">if (!privateEntry) {</span><span class="s3">\n      </span><span class="s1">debug?.('get', cacheKey, 'not found')</span><span class="s3">\n      </span><span class="s1">return undefined</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const entry = privateEntry.entry</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">performance.timeOrigin + performance.now() &gt;</span><span class="s3">\n      </span><span class="s1">entry.timestamp + entry.revalidate * 1000</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// In-memory caches should expire after revalidate time because it is</span><span class="s3">\n      </span><span class="s1">// unlikely that a new entry will be able to be used before it is dropped</span><span class="s3">\n      </span><span class="s1">// from the cache.</span><span class="s3">\n      </span><span class="s1">debug?.('get', cacheKey, 'expired')</span><span class="s3">\n\n      </span><span class="s1">return undefined</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (isStale(entry.tags, entry.timestamp)) {</span><span class="s3">\n      </span><span class="s1">debug?.('get', cacheKey, 'had stale tag')</span><span class="s3">\n\n      </span><span class="s1">return undefined</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const [returnStream, newSaved] = entry.value.tee()</span><span class="s3">\n    </span><span class="s1">entry.value = newSaved</span><span class="s3">\n\n    </span><span class="s1">debug?.('get', cacheKey, 'found', {</span><span class="s3">\n      </span><span class="s1">tags: entry.tags,</span><span class="s3">\n      </span><span class="s1">timestamp: entry.timestamp,</span><span class="s3">\n      </span><span class="s1">revalidate: entry.revalidate,</span><span class="s3">\n      </span><span class="s1">expire: entry.expire,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">...entry,</span><span class="s3">\n      </span><span class="s1">value: returnStream,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">async set(cacheKey, pendingEntry) {</span><span class="s3">\n    </span><span class="s1">debug?.('set', cacheKey, 'start')</span><span class="s3">\n\n    </span><span class="s1">let resolvePending: () =&gt; void = () =&gt; {}</span><span class="s3">\n    </span><span class="s1">const pendingPromise = new Promise&lt;void&gt;((resolve) =&gt; {</span><span class="s3">\n      </span><span class="s1">resolvePending = resolve</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">pendingSets.set(cacheKey, pendingPromise)</span><span class="s3">\n\n    </span><span class="s1">const entry = await pendingEntry</span><span class="s3">\n\n    </span><span class="s1">let size = 0</span><span class="s3">\n\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">const [value, clonedValue] = entry.value.tee()</span><span class="s3">\n      </span><span class="s1">entry.value = value</span><span class="s3">\n      </span><span class="s1">const reader = clonedValue.getReader()</span><span class="s3">\n\n      </span><span class="s1">for (let chunk; !(chunk = await reader.read()).done; ) {</span><span class="s3">\n        </span><span class="s1">size += Buffer.from(chunk.value).byteLength</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">memoryCache.set(cacheKey, {</span><span class="s3">\n        </span><span class="s1">entry,</span><span class="s3">\n        </span><span class="s1">isErrored: false,</span><span class="s3">\n        </span><span class="s1">errorRetryCount: 0,</span><span class="s3">\n        </span><span class="s1">size,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n\n      </span><span class="s1">debug?.('set', cacheKey, 'done')</span><span class="s3">\n    </span><span class="s1">} catch (err) {</span><span class="s3">\n      </span><span class="s1">// TODO: store partial buffer with error after we retry 3 times</span><span class="s3">\n      </span><span class="s1">debug?.('set', cacheKey, 'failed', err)</span><span class="s3">\n    </span><span class="s1">} finally {</span><span class="s3">\n      </span><span class="s1">resolvePending()</span><span class="s3">\n      </span><span class="s1">pendingSets.delete(cacheKey)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">async refreshTags() {</span><span class="s3">\n    </span><span class="s1">// Nothing to do for an in-memory cache handler.</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">async getExpiration(...tags) {</span><span class="s3">\n    </span><span class="s1">const expiration = Math.max(</span><span class="s3">\n      </span><span class="s1">...tags.map((tag) =&gt; tagsManifest.get(tag) ?? 0)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">debug?.('getExpiration', { tags, expiration })</span><span class="s3">\n\n    </span><span class="s1">return expiration</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">async expireTags(...tags) {</span><span class="s3">\n    </span><span class="s1">const timestamp = Math.round(performance.timeOrigin + performance.now())</span><span class="s3">\n    </span><span class="s1">debug?.('expireTags', { tags, timestamp })</span><span class="s3">\n\n    </span><span class="s1">for (const tag of tags) {</span><span class="s3">\n      </span><span class="s1">// TODO: update file-system-cache?</span><span class="s3">\n      </span><span class="s1">tagsManifest.set(tag, timestamp)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default DefaultCacheHandler</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;memoryCache&quot;</span><span class="s0">,</span><span class="s1">&quot;LRUCache&quot;</span><span class="s0">,</span><span class="s1">&quot;entry&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingSets&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;debug&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_PRIVATE_DEBUG_CACHE&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;bind&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;DefaultCacheHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;privateEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;performance&quot;</span><span class="s0">,</span><span class="s1">&quot;timeOrigin&quot;</span><span class="s0">,</span><span class="s1">&quot;now&quot;</span><span class="s0">,</span><span class="s1">&quot;timestamp&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;isStale&quot;</span><span class="s0">,</span><span class="s1">&quot;tags&quot;</span><span class="s0">,</span><span class="s1">&quot;returnStream&quot;</span><span class="s0">,</span><span class="s1">&quot;newSaved&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;tee&quot;</span><span class="s0">,</span><span class="s1">&quot;expire&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;resolvePending&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;clonedValue&quot;</span><span class="s0">,</span><span class="s1">&quot;reader&quot;</span><span class="s0">,</span><span class="s1">&quot;getReader&quot;</span><span class="s0">,</span><span class="s1">&quot;chunk&quot;</span><span class="s0">,</span><span class="s1">&quot;read&quot;</span><span class="s0">,</span><span class="s1">&quot;done&quot;</span><span class="s0">,</span><span class="s1">&quot;Buffer&quot;</span><span class="s0">,</span><span class="s1">&quot;from&quot;</span><span class="s0">,</span><span class="s1">&quot;byteLength&quot;</span><span class="s0">,</span><span class="s1">&quot;isErrored&quot;</span><span class="s0">,</span><span class="s1">&quot;errorRetryCount&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;refreshTags&quot;</span><span class="s0">,</span><span class="s1">&quot;getExpiration&quot;</span><span class="s0">,</span><span class="s1">&quot;expiration&quot;</span><span class="s0">,</span><span class="s1">&quot;Math&quot;</span><span class="s0">,</span><span class="s1">&quot;max&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;tag&quot;</span><span class="s0">,</span><span class="s1">&quot;tagsManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;expireTags&quot;</span><span class="s0">,</span><span class="s1">&quot;round&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAA;;;;;;;CAOC;;;;+BA0JD;;;eAAA;;;0BAxJyB;sCAKlB;AAsBP,qDAAqD;AACrD,MAAMA,cAAc,IAAIC,kBAAQ,CAC9B,KAAK,OAAO,MACZ,CAACC,QAAUA,MAAMC,IAAI;AAEvB,MAAMC,cAAc,IAAIC;AAExB,MAAMC,QAAQC,QAAQC,GAAG,CAACC,wBAAwB,GAC9CC,QAAQJ,KAAK,CAACK,IAAI,CAACD,SAAS,0BAC5BE;AAEJ,MAAMC,sBAAsC;IAC1C,MAAMC,KAAIC,QAAQ;QAChB,MAAMC,iBAAiBZ,YAAYU,GAAG,CAACC;QAEvC,IAAIC,gBAAgB;YAClBV,yBAAAA,MAAQ,OAAOS,UAAU;YACzB,MAAMC;QACR;QAEA,MAAMC,eAAejB,YAAYc,GAAG,CAACC;QAErC,IAAI,CAACE,cAAc;YACjBX,yBAAAA,MAAQ,OAAOS,UAAU;YACzB,OAAOH;QACT;QAEA,MAAMV,QAAQe,aAAaf,KAAK;QAChC,IACEgB,YAAYC,UAAU,GAAGD,YAAYE,GAAG,KACxClB,MAAMmB,SAAS,GAAGnB,MAAMoB,UAAU,GAAG,MACrC;YACA,qEAAqE;YACrE,yEAAyE;YACzE,kBAAkB;YAClBhB,yBAAAA,MAAQ,OAAOS,UAAU;YAEzB,OAAOH;QACT;QAEA,IAAIW,IAAAA,6BAAO,EAACrB,MAAMsB,IAAI,EAAEtB,MAAMmB,SAAS,GAAG;YACxCf,yBAAAA,MAAQ,OAAOS,UAAU;YAEzB,OAAOH;QACT;QACA,MAAM,CAACa,cAAcC,SAAS,GAAGxB,MAAMyB,KAAK,CAACC,GAAG;QAChD1B,MAAMyB,KAAK,GAAGD;QAEdpB,yBAAAA,MAAQ,OAAOS,UAAU,SAAS;YAChCS,MAAMtB,MAAMsB,IAAI;YAChBH,WAAWnB,MAAMmB,SAAS;YAC1BC,YAAYpB,MAAMoB,UAAU;YAC5BO,QAAQ3B,MAAM2B,MAAM;QACtB;QAEA,OAAO;YACL,GAAG3B,KAAK;YACRyB,OAAOF;QACT;IACF;IAEA,MAAMK,KAAIf,QAAQ,EAAEgB,YAAY;QAC9BzB,yBAAAA,MAAQ,OAAOS,UAAU;QAEzB,IAAIiB,iBAA6B,KAAO;QACxC,MAAMhB,iBAAiB,IAAIiB,QAAc,CAACC;YACxCF,iBAAiBE;QACnB;QACA9B,YAAY0B,GAAG,CAACf,UAAUC;QAE1B,MAAMd,QAAQ,MAAM6B;QAEpB,IAAI5B,OAAO;QAEX,IAAI;YACF,MAAM,CAACwB,OAAOQ,YAAY,GAAGjC,MAAMyB,KAAK,CAACC,GAAG;YAC5C1B,MAAMyB,KAAK,GAAGA;YACd,MAAMS,SAASD,YAAYE,SAAS;YAEpC,IAAK,IAAIC,OAAO,CAAC,AAACA,CAAAA,QAAQ,MAAMF,OAAOG,IAAI,EAAC,EAAGC,IAAI,EAAI;gBACrDrC,QAAQsC,OAAOC,IAAI,CAACJ,MAAMX,KAAK,EAAEgB,UAAU;YAC7C;YAEA3C,YAAY8B,GAAG,CAACf,UAAU;gBACxBb;gBACA0C,WAAW;gBACXC,iBAAiB;gBACjB1C;YACF;YAEAG,yBAAAA,MAAQ,OAAOS,UAAU;QAC3B,EAAE,OAAO+B,KAAK;YACZ,+DAA+D;YAC/DxC,yBAAAA,MAAQ,OAAOS,UAAU,UAAU+B;QACrC,SAAU;YACRd;YACA5B,YAAY2C,MAAM,CAAChC;QACrB;IACF;IAEA,MAAMiC;IACJ,gDAAgD;IAClD;IAEA,MAAMC,eAAc,GAAGzB,IAAI;QACzB,MAAM0B,aAAaC,KAAKC,GAAG,IACtB5B,KAAK6B,GAAG,CAAC,CAACC,MAAQC,kCAAY,CAACzC,GAAG,CAACwC,QAAQ;QAGhDhD,yBAAAA,MAAQ,iBAAiB;YAAEkB;YAAM0B;QAAW;QAE5C,OAAOA;IACT;IAEA,MAAMM,YAAW,GAAGhC,IAAI;QACtB,MAAMH,YAAY8B,KAAKM,KAAK,CAACvC,YAAYC,UAAU,GAAGD,YAAYE,GAAG;QACrEd,yBAAAA,MAAQ,cAAc;YAAEkB;YAAMH;QAAU;QAExC,KAAK,MAAMiC,OAAO9B,KAAM;YACtB,kCAAkC;YAClC+B,kCAAY,CAACzB,GAAG,CAACwB,KAAKjC;QACxB;IACF;AACF;MAEA,WAAeR&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>