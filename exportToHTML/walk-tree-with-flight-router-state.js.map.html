<html>
<head>
<title>walk-tree-with-flight-router-state.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
walk-tree-with-flight-router-state.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/server/app-render/walk-tree-with-flight-router-state.tsx&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type {</span><span class="s3">\n  </span><span class="s1">FlightDataPath,</span><span class="s3">\n  </span><span class="s1">FlightDataSegment,</span><span class="s3">\n  </span><span class="s1">FlightRouterState,</span><span class="s3">\n  </span><span class="s1">PreloadCallbacks,</span><span class="s3">\n  </span><span class="s1">Segment,</span><span class="s3">\n</span><span class="s1">} from './types'</span><span class="s3">\n</span><span class="s1">import { matchSegment } from '../../client/components/match-segments'</span><span class="s3">\n</span><span class="s1">import type { LoaderTree } from '../lib/app-dir-module'</span><span class="s3">\n</span><span class="s1">import { getLinkAndScriptTags } from './get-css-inlined-link-tags'</span><span class="s3">\n</span><span class="s1">import { getPreloadableFonts } from './get-preloadable-fonts'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">createFlightRouterStateFromLoaderTree,</span><span class="s3">\n  </span><span class="s1">createRouteTreePrefetch,</span><span class="s3">\n</span><span class="s1">} from './create-flight-router-state-from-loader-tree'</span><span class="s3">\n</span><span class="s1">import type { AppRenderContext } from './app-render'</span><span class="s3">\n</span><span class="s1">import { hasLoadingComponentInTree } from './has-loading-component-in-tree'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">DEFAULT_SEGMENT_KEY,</span><span class="s3">\n  </span><span class="s1">addSearchParamsIfPageSegment,</span><span class="s3">\n</span><span class="s1">} from '../../shared/lib/segment'</span><span class="s3">\n</span><span class="s1">import { createComponentTree } from './create-component-tree'</span><span class="s3">\n</span><span class="s1">import type { HeadData } from '../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import { getSegmentParam } from './get-segment-param'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Use router state to decide at what common layout to render the page.</span><span class="s3">\n </span><span class="s1">* This can either be the common layout between two pages or a specific place to start rendering from using the </span><span class="s3">\&quot;</span><span class="s1">refetch</span><span class="s3">\&quot; </span><span class="s1">marker in the tree.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export async function walkTreeWithFlightRouterState({</span><span class="s3">\n  </span><span class="s1">loaderTreeToFilter,</span><span class="s3">\n  </span><span class="s1">parentParams,</span><span class="s3">\n  </span><span class="s1">flightRouterState,</span><span class="s3">\n  </span><span class="s1">parentIsInsideSharedLayout,</span><span class="s3">\n  </span><span class="s1">rscHead,</span><span class="s3">\n  </span><span class="s1">injectedCSS,</span><span class="s3">\n  </span><span class="s1">injectedJS,</span><span class="s3">\n  </span><span class="s1">injectedFontPreloadTags,</span><span class="s3">\n  </span><span class="s1">rootLayoutIncluded,</span><span class="s3">\n  </span><span class="s1">getViewportReady,</span><span class="s3">\n  </span><span class="s1">getMetadataReady,</span><span class="s3">\n  </span><span class="s1">ctx,</span><span class="s3">\n  </span><span class="s1">preloadCallbacks,</span><span class="s3">\n  </span><span class="s1">StreamingMetadataOutlet,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">loaderTreeToFilter: LoaderTree</span><span class="s3">\n  </span><span class="s1">parentParams: { [key: string]: string | string[] }</span><span class="s3">\n  </span><span class="s1">flightRouterState?: FlightRouterState</span><span class="s3">\n  </span><span class="s1">rscHead: HeadData</span><span class="s3">\n  </span><span class="s1">parentIsInsideSharedLayout?: boolean</span><span class="s3">\n  </span><span class="s1">injectedCSS: Set&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">injectedJS: Set&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">injectedFontPreloadTags: Set&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">rootLayoutIncluded: boolean</span><span class="s3">\n  </span><span class="s1">getMetadataReady: () =&gt; Promise&lt;void&gt;</span><span class="s3">\n  </span><span class="s1">getViewportReady: () =&gt; Promise&lt;void&gt;</span><span class="s3">\n  </span><span class="s1">ctx: AppRenderContext</span><span class="s3">\n  </span><span class="s1">preloadCallbacks: PreloadCallbacks</span><span class="s3">\n  </span><span class="s1">StreamingMetadataOutlet: React.ComponentType | null</span><span class="s3">\n</span><span class="s1">}): Promise&lt;FlightDataPath[]&gt; {</span><span class="s3">\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">renderOpts: { nextFontManifest, experimental },</span><span class="s3">\n    </span><span class="s1">query,</span><span class="s3">\n    </span><span class="s1">isPrefetch,</span><span class="s3">\n    </span><span class="s1">getDynamicParamFromSegment,</span><span class="s3">\n    </span><span class="s1">parsedRequestHeaders,</span><span class="s3">\n  </span><span class="s1">} = ctx</span><span class="s3">\n\n  </span><span class="s1">const [segment, parallelRoutes, modules] = loaderTreeToFilter</span><span class="s3">\n\n  </span><span class="s1">const parallelRoutesKeys = Object.keys(parallelRoutes)</span><span class="s3">\n\n  </span><span class="s1">const { layout } = modules</span><span class="s3">\n  </span><span class="s1">const isLayout = typeof layout !== 'undefined'</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Checks if the current segment is a root layout.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">const rootLayoutAtThisLevel = isLayout &amp;&amp; !rootLayoutIncluded</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Checks if the current segment or any level above it has a root layout.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">const rootLayoutIncludedAtThisLevelOrAbove =</span><span class="s3">\n    </span><span class="s1">rootLayoutIncluded || rootLayoutAtThisLevel</span><span class="s3">\n\n  </span><span class="s1">// Because this function walks to a deeper point in the tree to start rendering we have to track the dynamic parameters up to the point where rendering starts</span><span class="s3">\n  </span><span class="s1">const segmentParam = getDynamicParamFromSegment(segment)</span><span class="s3">\n  </span><span class="s1">const currentParams =</span><span class="s3">\n    </span><span class="s1">// Handle null case where dynamic param is optional</span><span class="s3">\n    </span><span class="s1">segmentParam &amp;&amp; segmentParam.value !== null</span><span class="s3">\n      </span><span class="s1">? {</span><span class="s3">\n          </span><span class="s1">...parentParams,</span><span class="s3">\n          </span><span class="s1">[segmentParam.param]: segmentParam.value,</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">: parentParams</span><span class="s3">\n  </span><span class="s1">const actualSegment: Segment = addSearchParamsIfPageSegment(</span><span class="s3">\n    </span><span class="s1">segmentParam ? segmentParam.treeSegment : segment,</span><span class="s3">\n    </span><span class="s1">query</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Decide if the current segment is where rendering has to start.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">const renderComponentsOnThisLevel =</span><span class="s3">\n    </span><span class="s1">// No further router state available</span><span class="s3">\n    </span><span class="s1">!flightRouterState ||</span><span class="s3">\n    </span><span class="s1">// Segment in router state does not match current segment</span><span class="s3">\n    </span><span class="s1">!matchSegment(actualSegment, flightRouterState[0]) ||</span><span class="s3">\n    </span><span class="s1">// Last item in the tree</span><span class="s3">\n    </span><span class="s1">parallelRoutesKeys.length === 0 ||</span><span class="s3">\n    </span><span class="s1">// Explicit refresh</span><span class="s3">\n    </span><span class="s1">flightRouterState[3] === 'refetch'</span><span class="s3">\n\n  </span><span class="s1">// Pre-PPR, the `loading` component signals to the router how deep to render the component tree</span><span class="s3">\n  </span><span class="s1">// to ensure prefetches are quick and inexpensive. If there's no `loading` component anywhere in the tree being rendered,</span><span class="s3">\n  </span><span class="s1">// the prefetch will be short-circuited to avoid requesting a potentially very expensive subtree. If there's a `loading`</span><span class="s3">\n  </span><span class="s1">// somewhere in the tree, we'll recursively render the component tree up until we encounter that loading component, and then stop.</span><span class="s3">\n\n  </span><span class="s1">// Check if we're inside the </span><span class="s3">\&quot;</span><span class="s1">new</span><span class="s3">\&quot; </span><span class="s1">part of the navigation â€” inside the</span><span class="s3">\n  </span><span class="s1">// shared layout. In the case of a prefetch, this can be true even if the</span><span class="s3">\n  </span><span class="s1">// segment matches, because the client might send a matching segment to</span><span class="s3">\n  </span><span class="s1">// indicate that it already has the data in its cache. But in order to find</span><span class="s3">\n  </span><span class="s1">// the correct loading boundary, we still need to track where the shared</span><span class="s3">\n  </span><span class="s1">// layout begins.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// TODO: We should rethink the protocol for dynamic requests. It might not</span><span class="s3">\n  </span><span class="s1">// make sense for the client to send a FlightRouterState, since that type is</span><span class="s3">\n  </span><span class="s1">// overloaded with other concerns.</span><span class="s3">\n  </span><span class="s1">const isInsideSharedLayout =</span><span class="s3">\n    </span><span class="s1">renderComponentsOnThisLevel ||</span><span class="s3">\n    </span><span class="s1">parentIsInsideSharedLayout ||</span><span class="s3">\n    </span><span class="s1">flightRouterState[3] === 'inside-shared-layout'</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">isInsideSharedLayout &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!experimental.isRoutePPREnabled &amp;&amp;</span><span class="s3">\n    </span><span class="s1">// If PPR is disabled, and this is a request for the route tree, then we</span><span class="s3">\n    </span><span class="s1">// never render any components. Only send the router state.</span><span class="s3">\n    </span><span class="s1">(parsedRequestHeaders.isRouteTreePrefetchRequest ||</span><span class="s3">\n      </span><span class="s1">// Otherwise, check for the presence of a `loading` component.</span><span class="s3">\n      </span><span class="s1">(isPrefetch &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!Boolean(modules.loading) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!hasLoadingComponentInTree(loaderTreeToFilter)))</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">// Send only the router state.</span><span class="s3">\n    </span><span class="s1">// TODO: Even for a dynamic route, we should cache these responses,</span><span class="s3">\n    </span><span class="s1">// because they do not contain any render data (neither segment data nor</span><span class="s3">\n    </span><span class="s1">// the head). They can be made even more cacheable once we move the route</span><span class="s3">\n    </span><span class="s1">// params into a separate data structure.</span><span class="s3">\n    </span><span class="s1">const overriddenSegment =</span><span class="s3">\n      </span><span class="s1">flightRouterState &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// TODO: Why does canSegmentBeOverridden exist? Why don't we always just</span><span class="s3">\n      </span><span class="s1">// use `actualSegment`? Is it to avoid overwriting some state that's</span><span class="s3">\n      </span><span class="s1">// tracked by the client? Dig deeper to see if we can simplify this.</span><span class="s3">\n      </span><span class="s1">canSegmentBeOverridden(actualSegment, flightRouterState[0])</span><span class="s3">\n        </span><span class="s1">? flightRouterState[0]</span><span class="s3">\n        </span><span class="s1">: actualSegment</span><span class="s3">\n\n    </span><span class="s1">const routerState = parsedRequestHeaders.isRouteTreePrefetchRequest</span><span class="s3">\n      </span><span class="s1">? // Route tree prefetch requests contain some extra information</span><span class="s3">\n        </span><span class="s1">createRouteTreePrefetch(loaderTreeToFilter, getDynamicParamFromSegment)</span><span class="s3">\n      </span><span class="s1">: createFlightRouterStateFromLoaderTree(</span><span class="s3">\n          </span><span class="s1">loaderTreeToFilter,</span><span class="s3">\n          </span><span class="s1">getDynamicParamFromSegment,</span><span class="s3">\n          </span><span class="s1">query</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">return [</span><span class="s3">\n      </span><span class="s1">[</span><span class="s3">\n        </span><span class="s1">overriddenSegment,</span><span class="s3">\n        </span><span class="s1">routerState,</span><span class="s3">\n        </span><span class="s1">null,</span><span class="s3">\n        </span><span class="s1">[null, null],</span><span class="s3">\n        </span><span class="s1">true,</span><span class="s3">\n      </span><span class="s1">] satisfies FlightDataSegment,</span><span class="s3">\n    </span><span class="s1">]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Similar to the previous branch. This flag is sent by the client to request</span><span class="s3">\n  </span><span class="s1">// only the metadata for a page. No segment data.</span><span class="s3">\n  </span><span class="s1">if (flightRouterState &amp;&amp; flightRouterState[3] === 'metadata-only') {</span><span class="s3">\n    </span><span class="s1">const overriddenSegment =</span><span class="s3">\n      </span><span class="s1">flightRouterState &amp;&amp;</span><span class="s3">\n      </span><span class="s1">canSegmentBeOverridden(actualSegment, flightRouterState[0])</span><span class="s3">\n        </span><span class="s1">? flightRouterState[0]</span><span class="s3">\n        </span><span class="s1">: actualSegment</span><span class="s3">\n    </span><span class="s1">const routerState = parsedRequestHeaders.isRouteTreePrefetchRequest</span><span class="s3">\n      </span><span class="s1">? createRouteTreePrefetch(loaderTreeToFilter, getDynamicParamFromSegment)</span><span class="s3">\n      </span><span class="s1">: createFlightRouterStateFromLoaderTree(</span><span class="s3">\n          </span><span class="s1">loaderTreeToFilter,</span><span class="s3">\n          </span><span class="s1">getDynamicParamFromSegment,</span><span class="s3">\n          </span><span class="s1">query</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">return [</span><span class="s3">\n      </span><span class="s1">[</span><span class="s3">\n        </span><span class="s1">overriddenSegment,</span><span class="s3">\n        </span><span class="s1">routerState,</span><span class="s3">\n        </span><span class="s1">null,</span><span class="s3">\n        </span><span class="s1">rscHead,</span><span class="s3">\n        </span><span class="s1">false,</span><span class="s3">\n      </span><span class="s1">] satisfies FlightDataSegment,</span><span class="s3">\n    </span><span class="s1">]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (renderComponentsOnThisLevel) {</span><span class="s3">\n    </span><span class="s1">const overriddenSegment =</span><span class="s3">\n      </span><span class="s1">flightRouterState &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// TODO: Why does canSegmentBeOverridden exist? Why don't we always just</span><span class="s3">\n      </span><span class="s1">// use `actualSegment`? Is it to avoid overwriting some state that's</span><span class="s3">\n      </span><span class="s1">// tracked by the client? Dig deeper to see if we can simplify this.</span><span class="s3">\n      </span><span class="s1">canSegmentBeOverridden(actualSegment, flightRouterState[0])</span><span class="s3">\n        </span><span class="s1">? flightRouterState[0]</span><span class="s3">\n        </span><span class="s1">: actualSegment</span><span class="s3">\n\n    </span><span class="s1">const routerState = createFlightRouterStateFromLoaderTree(</span><span class="s3">\n      </span><span class="s1">// Create router state using the slice of the loaderTree</span><span class="s3">\n      </span><span class="s1">loaderTreeToFilter,</span><span class="s3">\n      </span><span class="s1">getDynamicParamFromSegment,</span><span class="s3">\n      </span><span class="s1">query</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">// Create component tree using the slice of the loaderTree</span><span class="s3">\n    </span><span class="s1">const seedData = await createComponentTree(</span><span class="s3">\n      </span><span class="s1">// This ensures flightRouterPath is valid and filters down the tree</span><span class="s3">\n      </span><span class="s1">{</span><span class="s3">\n        </span><span class="s1">ctx,</span><span class="s3">\n        </span><span class="s1">loaderTree: loaderTreeToFilter,</span><span class="s3">\n        </span><span class="s1">parentParams: currentParams,</span><span class="s3">\n        </span><span class="s1">injectedCSS,</span><span class="s3">\n        </span><span class="s1">injectedJS,</span><span class="s3">\n        </span><span class="s1">injectedFontPreloadTags,</span><span class="s3">\n        </span><span class="s1">// This is intentionally not </span><span class="s3">\&quot;</span><span class="s1">rootLayoutIncludedAtThisLevelOrAbove</span><span class="s3">\&quot; </span><span class="s1">as createComponentTree starts at the current level and does a check for </span><span class="s3">\&quot;</span><span class="s1">rootLayoutAtThisLevel</span><span class="s3">\&quot; </span><span class="s1">too.</span><span class="s3">\n        </span><span class="s1">rootLayoutIncluded,</span><span class="s3">\n        </span><span class="s1">getViewportReady,</span><span class="s3">\n        </span><span class="s1">getMetadataReady,</span><span class="s3">\n        </span><span class="s1">preloadCallbacks,</span><span class="s3">\n        </span><span class="s1">authInterrupts: experimental.authInterrupts,</span><span class="s3">\n        </span><span class="s1">StreamingMetadataOutlet,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">return [</span><span class="s3">\n      </span><span class="s1">[</span><span class="s3">\n        </span><span class="s1">overriddenSegment,</span><span class="s3">\n        </span><span class="s1">routerState,</span><span class="s3">\n        </span><span class="s1">seedData,</span><span class="s3">\n        </span><span class="s1">rscHead,</span><span class="s3">\n        </span><span class="s1">false,</span><span class="s3">\n      </span><span class="s1">] satisfies FlightDataSegment,</span><span class="s3">\n    </span><span class="s1">]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// If we are not rendering on this level we need to check if the current</span><span class="s3">\n  </span><span class="s1">// segment has a layout. If so, we need to track all the used CSS to make</span><span class="s3">\n  </span><span class="s1">// the result consistent.</span><span class="s3">\n  </span><span class="s1">const layoutPath = layout?.[1]</span><span class="s3">\n  </span><span class="s1">const injectedCSSWithCurrentLayout = new Set(injectedCSS)</span><span class="s3">\n  </span><span class="s1">const injectedJSWithCurrentLayout = new Set(injectedJS)</span><span class="s3">\n  </span><span class="s1">const injectedFontPreloadTagsWithCurrentLayout = new Set(</span><span class="s3">\n    </span><span class="s1">injectedFontPreloadTags</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">if (layoutPath) {</span><span class="s3">\n    </span><span class="s1">getLinkAndScriptTags(</span><span class="s3">\n      </span><span class="s1">ctx.clientReferenceManifest,</span><span class="s3">\n      </span><span class="s1">layoutPath,</span><span class="s3">\n      </span><span class="s1">injectedCSSWithCurrentLayout,</span><span class="s3">\n      </span><span class="s1">injectedJSWithCurrentLayout,</span><span class="s3">\n      </span><span class="s1">true</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">getPreloadableFonts(</span><span class="s3">\n      </span><span class="s1">nextFontManifest,</span><span class="s3">\n      </span><span class="s1">layoutPath,</span><span class="s3">\n      </span><span class="s1">injectedFontPreloadTagsWithCurrentLayout</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const paths: FlightDataPath[] = []</span><span class="s3">\n\n  </span><span class="s1">// Walk through all parallel routes.</span><span class="s3">\n  </span><span class="s1">for (const parallelRouteKey of parallelRoutesKeys) {</span><span class="s3">\n    </span><span class="s1">const parallelRoute = parallelRoutes[parallelRouteKey]</span><span class="s3">\n\n    </span><span class="s1">const subPaths = await walkTreeWithFlightRouterState({</span><span class="s3">\n      </span><span class="s1">ctx,</span><span class="s3">\n      </span><span class="s1">loaderTreeToFilter: parallelRoute,</span><span class="s3">\n      </span><span class="s1">parentParams: currentParams,</span><span class="s3">\n      </span><span class="s1">flightRouterState:</span><span class="s3">\n        </span><span class="s1">flightRouterState &amp;&amp; flightRouterState[1][parallelRouteKey],</span><span class="s3">\n      </span><span class="s1">parentIsInsideSharedLayout: isInsideSharedLayout,</span><span class="s3">\n      </span><span class="s1">rscHead,</span><span class="s3">\n      </span><span class="s1">injectedCSS: injectedCSSWithCurrentLayout,</span><span class="s3">\n      </span><span class="s1">injectedJS: injectedJSWithCurrentLayout,</span><span class="s3">\n      </span><span class="s1">injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout,</span><span class="s3">\n      </span><span class="s1">rootLayoutIncluded: rootLayoutIncludedAtThisLevelOrAbove,</span><span class="s3">\n      </span><span class="s1">getViewportReady,</span><span class="s3">\n      </span><span class="s1">getMetadataReady,</span><span class="s3">\n      </span><span class="s1">preloadCallbacks,</span><span class="s3">\n      </span><span class="s1">StreamingMetadataOutlet,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">for (const subPath of subPaths) {</span><span class="s3">\n      </span><span class="s1">// we don't need to send over default routes in the flight data</span><span class="s3">\n      </span><span class="s1">// because they are always ignored by the client, unless it's a refetch</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">subPath[0] === DEFAULT_SEGMENT_KEY &amp;&amp;</span><span class="s3">\n        </span><span class="s1">flightRouterState &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!!flightRouterState[1][parallelRouteKey][0] &amp;&amp;</span><span class="s3">\n        </span><span class="s1">flightRouterState[1][parallelRouteKey][3] !== 'refetch'</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">continue</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">paths.push([actualSegment, parallelRouteKey, ...subPath])</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return paths</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* This function is used to determine if an existing segment can be overridden</span><span class="s3">\n </span><span class="s1">* by the incoming segment.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const canSegmentBeOverridden = (</span><span class="s3">\n  </span><span class="s1">existingSegment: Segment,</span><span class="s3">\n  </span><span class="s1">segment: Segment</span><span class="s3">\n</span><span class="s1">): boolean =&gt; {</span><span class="s3">\n  </span><span class="s1">if (Array.isArray(existingSegment) || !Array.isArray(segment)) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return getSegmentParam(existingSegment)?.param === segment[0]</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;walkTreeWithFlightRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;loaderTreeToFilter&quot;</span><span class="s0">,</span><span class="s1">&quot;parentParams&quot;</span><span class="s0">,</span><span class="s1">&quot;flightRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;parentIsInsideSharedLayout&quot;</span><span class="s0">,</span><span class="s1">&quot;rscHead&quot;</span><span class="s0">,</span><span class="s1">&quot;injectedCSS&quot;</span><span class="s0">,</span><span class="s1">&quot;injectedJS&quot;</span><span class="s0">,</span><span class="s1">&quot;injectedFontPreloadTags&quot;</span><span class="s0">,</span><span class="s1">&quot;rootLayoutIncluded&quot;</span><span class="s0">,</span><span class="s1">&quot;getViewportReady&quot;</span><span class="s0">,</span><span class="s1">&quot;getMetadataReady&quot;</span><span class="s0">,</span><span class="s1">&quot;ctx&quot;</span><span class="s0">,</span><span class="s1">&quot;preloadCallbacks&quot;</span><span class="s0">,</span><span class="s1">&quot;StreamingMetadataOutlet&quot;</span><span class="s0">,</span><span class="s1">&quot;renderOpts&quot;</span><span class="s0">,</span><span class="s1">&quot;nextFontManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;experimental&quot;</span><span class="s0">,</span><span class="s1">&quot;query&quot;</span><span class="s0">,</span><span class="s1">&quot;isPrefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;getDynamicParamFromSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;parsedRequestHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;modules&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutesKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;layout&quot;</span><span class="s0">,</span><span class="s1">&quot;isLayout&quot;</span><span class="s0">,</span><span class="s1">&quot;rootLayoutAtThisLevel&quot;</span><span class="s0">,</span><span class="s1">&quot;rootLayoutIncludedAtThisLevelOrAbove&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentParam&quot;</span><span class="s0">,</span><span class="s1">&quot;currentParams&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;param&quot;</span><span class="s0">,</span><span class="s1">&quot;actualSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;addSearchParamsIfPageSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;treeSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;renderComponentsOnThisLevel&quot;</span><span class="s0">,</span><span class="s1">&quot;matchSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;isInsideSharedLayout&quot;</span><span class="s0">,</span><span class="s1">&quot;isRoutePPREnabled&quot;</span><span class="s0">,</span><span class="s1">&quot;isRouteTreePrefetchRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;Boolean&quot;</span><span class="s0">,</span><span class="s1">&quot;loading&quot;</span><span class="s0">,</span><span class="s1">&quot;hasLoadingComponentInTree&quot;</span><span class="s0">,</span><span class="s1">&quot;overriddenSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;canSegmentBeOverridden&quot;</span><span class="s0">,</span><span class="s1">&quot;routerState&quot;</span><span class="s0">,</span><span class="s1">&quot;createRouteTreePrefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;createFlightRouterStateFromLoaderTree&quot;</span><span class="s0">,</span><span class="s1">&quot;seedData&quot;</span><span class="s0">,</span><span class="s1">&quot;createComponentTree&quot;</span><span class="s0">,</span><span class="s1">&quot;loaderTree&quot;</span><span class="s0">,</span><span class="s1">&quot;authInterrupts&quot;</span><span class="s0">,</span><span class="s1">&quot;layoutPath&quot;</span><span class="s0">,</span><span class="s1">&quot;injectedCSSWithCurrentLayout&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;injectedJSWithCurrentLayout&quot;</span><span class="s0">,</span><span class="s1">&quot;injectedFontPreloadTagsWithCurrentLayout&quot;</span><span class="s0">,</span><span class="s1">&quot;getLinkAndScriptTags&quot;</span><span class="s0">,</span><span class="s1">&quot;clientReferenceManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;getPreloadableFonts&quot;</span><span class="s0">,</span><span class="s1">&quot;paths&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRouteKey&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;subPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;subPath&quot;</span><span class="s0">,</span><span class="s1">&quot;DEFAULT_SEGMENT_KEY&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;existingSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;getSegmentParam&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>