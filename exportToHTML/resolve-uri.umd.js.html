<html>
<head>
<title>resolve-uri.umd.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #0033b3;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #264eff;}
.s5 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
resolve-uri.umd.js</font>
</center></td></tr></table>
<pre><span class="s0">(</span><span class="s1">function </span><span class="s0">(global, factory) {</span>
    <span class="s1">typeof </span><span class="s0">exports === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">module !== </span><span class="s2">'undefined' </span><span class="s0">? module.exports = factory() :</span>
    <span class="s1">typeof </span><span class="s0">define === </span><span class="s2">'function' </span><span class="s0">&amp;&amp; define.amd ? define(factory) :</span>
    <span class="s0">(global = </span><span class="s1">typeof </span><span class="s0">globalThis !== </span><span class="s2">'undefined' </span><span class="s0">? globalThis : global || self, global.resolveURI = factory());</span>
<span class="s0">})(</span><span class="s1">this</span><span class="s0">, (</span><span class="s1">function </span><span class="s0">() { </span><span class="s2">'use strict'</span><span class="s0">;</span>

    <span class="s3">// Matches the scheme of a URL, eg &quot;http://&quot;</span>
    <span class="s1">const </span><span class="s0">schemeRegex = </span><span class="s4">/^[\w+.-]+:\/\//</span><span class="s0">;</span>
    <span class="s3">/**</span>
     <span class="s3">* Matches the parts of a URL:</span>
     <span class="s3">* 1. Scheme, including &quot;:&quot;, guaranteed.</span>
     <span class="s3">* 2. User/password, including &quot;@&quot;, optional.</span>
     <span class="s3">* 3. Host, guaranteed.</span>
     <span class="s3">* 4. Port, including &quot;:&quot;, optional.</span>
     <span class="s3">* 5. Path, including &quot;/&quot;, optional.</span>
     <span class="s3">* 6. Query, including &quot;?&quot;, optional.</span>
     <span class="s3">* 7. Hash, including &quot;#&quot;, optional.</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">urlRegex = </span><span class="s4">/^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/</span><span class="s0">;</span>
    <span class="s3">/**</span>
     <span class="s3">* File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start</span>
     <span class="s3">* with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).</span>
     <span class="s3">*</span>
     <span class="s3">* 1. Host, optional.</span>
     <span class="s3">* 2. Path, which may include &quot;/&quot;, guaranteed.</span>
     <span class="s3">* 3. Query, including &quot;?&quot;, optional.</span>
     <span class="s3">* 4. Hash, including &quot;#&quot;, optional.</span>
     <span class="s3">*/</span>
    <span class="s1">const </span><span class="s0">fileRegex = </span><span class="s4">/^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i</span><span class="s0">;</span>
    <span class="s1">function </span><span class="s0">isAbsoluteUrl(input) {</span>
        <span class="s1">return </span><span class="s0">schemeRegex.test(input);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">isSchemeRelativeUrl(input) {</span>
        <span class="s1">return </span><span class="s0">input.startsWith(</span><span class="s2">'//'</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">isAbsolutePath(input) {</span>
        <span class="s1">return </span><span class="s0">input.startsWith(</span><span class="s2">'/'</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">isFileUrl(input) {</span>
        <span class="s1">return </span><span class="s0">input.startsWith(</span><span class="s2">'file:'</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">isRelative(input) {</span>
        <span class="s1">return </span><span class="s4">/^[.?#]/</span><span class="s0">.test(input);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">parseAbsoluteUrl(input) {</span>
        <span class="s1">const </span><span class="s0">match = urlRegex.exec(input);</span>
        <span class="s1">return </span><span class="s0">makeUrl(match[</span><span class="s5">1</span><span class="s0">], match[</span><span class="s5">2</span><span class="s0">] || </span><span class="s2">''</span><span class="s0">, match[</span><span class="s5">3</span><span class="s0">], match[</span><span class="s5">4</span><span class="s0">] || </span><span class="s2">''</span><span class="s0">, match[</span><span class="s5">5</span><span class="s0">] || </span><span class="s2">'/'</span><span class="s0">, match[</span><span class="s5">6</span><span class="s0">] || </span><span class="s2">''</span><span class="s0">, match[</span><span class="s5">7</span><span class="s0">] || </span><span class="s2">''</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">parseFileUrl(input) {</span>
        <span class="s1">const </span><span class="s0">match = fileRegex.exec(input);</span>
        <span class="s1">const </span><span class="s0">path = match[</span><span class="s5">2</span><span class="s0">];</span>
        <span class="s1">return </span><span class="s0">makeUrl(</span><span class="s2">'file:'</span><span class="s0">, </span><span class="s2">''</span><span class="s0">, match[</span><span class="s5">1</span><span class="s0">] || </span><span class="s2">''</span><span class="s0">, </span><span class="s2">''</span><span class="s0">, isAbsolutePath(path) ? path : </span><span class="s2">'/' </span><span class="s0">+ path, match[</span><span class="s5">3</span><span class="s0">] || </span><span class="s2">''</span><span class="s0">, match[</span><span class="s5">4</span><span class="s0">] || </span><span class="s2">''</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">makeUrl(scheme, user, host, port, path, query, hash) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">scheme,</span>
            <span class="s0">user,</span>
            <span class="s0">host,</span>
            <span class="s0">port,</span>
            <span class="s0">path,</span>
            <span class="s0">query,</span>
            <span class="s0">hash,</span>
            <span class="s0">type: </span><span class="s5">7 </span><span class="s3">/* Absolute */</span><span class="s0">,</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">parseUrl(input) {</span>
        <span class="s1">if </span><span class="s0">(isSchemeRelativeUrl(input)) {</span>
            <span class="s1">const </span><span class="s0">url = parseAbsoluteUrl(</span><span class="s2">'http:' </span><span class="s0">+ input);</span>
            <span class="s0">url.scheme = </span><span class="s2">''</span><span class="s0">;</span>
            <span class="s0">url.type = </span><span class="s5">6 </span><span class="s3">/* SchemeRelative */</span><span class="s0">;</span>
            <span class="s1">return </span><span class="s0">url;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(isAbsolutePath(input)) {</span>
            <span class="s1">const </span><span class="s0">url = parseAbsoluteUrl(</span><span class="s2">'http://foo.com' </span><span class="s0">+ input);</span>
            <span class="s0">url.scheme = </span><span class="s2">''</span><span class="s0">;</span>
            <span class="s0">url.host = </span><span class="s2">''</span><span class="s0">;</span>
            <span class="s0">url.type = </span><span class="s5">5 </span><span class="s3">/* AbsolutePath */</span><span class="s0">;</span>
            <span class="s1">return </span><span class="s0">url;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(isFileUrl(input))</span>
            <span class="s1">return </span><span class="s0">parseFileUrl(input);</span>
        <span class="s1">if </span><span class="s0">(isAbsoluteUrl(input))</span>
            <span class="s1">return </span><span class="s0">parseAbsoluteUrl(input);</span>
        <span class="s1">const </span><span class="s0">url = parseAbsoluteUrl(</span><span class="s2">'http://foo.com/' </span><span class="s0">+ input);</span>
        <span class="s0">url.scheme = </span><span class="s2">''</span><span class="s0">;</span>
        <span class="s0">url.host = </span><span class="s2">''</span><span class="s0">;</span>
        <span class="s0">url.type = input</span>
            <span class="s0">? input.startsWith(</span><span class="s2">'?'</span><span class="s0">)</span>
                <span class="s0">? </span><span class="s5">3 </span><span class="s3">/* Query */</span>
                <span class="s0">: input.startsWith(</span><span class="s2">'#'</span><span class="s0">)</span>
                    <span class="s0">? </span><span class="s5">2 </span><span class="s3">/* Hash */</span>
                    <span class="s0">: </span><span class="s5">4 </span><span class="s3">/* RelativePath */</span>
            <span class="s0">: </span><span class="s5">1 </span><span class="s3">/* Empty */</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">url;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">stripPathFilename(path) {</span>
        <span class="s3">// If a path ends with a parent directory &quot;..&quot;, then it's a relative path with excess parent</span>
        <span class="s3">// paths. It's not a file, so we can't strip it.</span>
        <span class="s1">if </span><span class="s0">(path.endsWith(</span><span class="s2">'/..'</span><span class="s0">))</span>
            <span class="s1">return </span><span class="s0">path;</span>
        <span class="s1">const </span><span class="s0">index = path.lastIndexOf(</span><span class="s2">'/'</span><span class="s0">);</span>
        <span class="s1">return </span><span class="s0">path.slice(</span><span class="s5">0</span><span class="s0">, index + </span><span class="s5">1</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">mergePaths(url, base) {</span>
        <span class="s0">normalizePath(base, base.type);</span>
        <span class="s3">// If the path is just a &quot;/&quot;, then it was an empty path to begin with (remember, we're a relative</span>
        <span class="s3">// path).</span>
        <span class="s1">if </span><span class="s0">(url.path === </span><span class="s2">'/'</span><span class="s0">) {</span>
            <span class="s0">url.path = base.path;</span>
        <span class="s0">}</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s3">// Resolution happens relative to the base path's directory, not the file.</span>
            <span class="s0">url.path = stripPathFilename(base.path) + url.path;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s3">/**</span>
     <span class="s3">* The path can have empty directories &quot;//&quot;, unneeded parents &quot;foo/..&quot;, or current directory</span>
     <span class="s3">* &quot;foo/.&quot;. We need to normalize to a standard representation.</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">normalizePath(url, type) {</span>
        <span class="s1">const </span><span class="s0">rel = type &lt;= </span><span class="s5">4 </span><span class="s3">/* RelativePath */</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">pieces = url.path.split(</span><span class="s2">'/'</span><span class="s0">);</span>
        <span class="s3">// We need to preserve the first piece always, so that we output a leading slash. The item at</span>
        <span class="s3">// pieces[0] is an empty string.</span>
        <span class="s1">let </span><span class="s0">pointer = </span><span class="s5">1</span><span class="s0">;</span>
        <span class="s3">// Positive is the number of real directories we've output, used for popping a parent directory.</span>
        <span class="s3">// Eg, &quot;foo/bar/..&quot; will have a positive 2, and we can decrement to be left with just &quot;foo&quot;.</span>
        <span class="s1">let </span><span class="s0">positive = </span><span class="s5">0</span><span class="s0">;</span>
        <span class="s3">// We need to keep a trailing slash if we encounter an empty directory (eg, splitting &quot;foo/&quot; will</span>
        <span class="s3">// generate `[&quot;foo&quot;, &quot;&quot;]` pieces). And, if we pop a parent directory. But once we encounter a</span>
        <span class="s3">// real directory, we won't need to append, unless the other conditions happen again.</span>
        <span class="s1">let </span><span class="s0">addTrailingSlash = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">1</span><span class="s0">; i &lt; pieces.length; i++) {</span>
            <span class="s1">const </span><span class="s0">piece = pieces[i];</span>
            <span class="s3">// An empty directory, could be a trailing slash, or just a double &quot;//&quot; in the path.</span>
            <span class="s1">if </span><span class="s0">(!piece) {</span>
                <span class="s0">addTrailingSlash = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s1">continue</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s3">// If we encounter a real directory, then we don't need to append anymore.</span>
            <span class="s0">addTrailingSlash = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s3">// A current directory, which we can always drop.</span>
            <span class="s1">if </span><span class="s0">(piece === </span><span class="s2">'.'</span><span class="s0">)</span>
                <span class="s1">continue</span><span class="s0">;</span>
            <span class="s3">// A parent directory, we need to see if there are any real directories we can pop. Else, we</span>
            <span class="s3">// have an excess of parents, and we'll need to keep the &quot;..&quot;.</span>
            <span class="s1">if </span><span class="s0">(piece === </span><span class="s2">'..'</span><span class="s0">) {</span>
                <span class="s1">if </span><span class="s0">(positive) {</span>
                    <span class="s0">addTrailingSlash = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s0">positive--;</span>
                    <span class="s0">pointer--;</span>
                <span class="s0">}</span>
                <span class="s1">else if </span><span class="s0">(rel) {</span>
                    <span class="s3">// If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute</span>
                    <span class="s3">// URL, protocol relative URL, or an absolute path, we don't need to keep excess.</span>
                    <span class="s0">pieces[pointer++] = piece;</span>
                <span class="s0">}</span>
                <span class="s1">continue</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s3">// We've encountered a real directory. Move it to the next insertion pointer, which accounts for</span>
            <span class="s3">// any popped or dropped directories.</span>
            <span class="s0">pieces[pointer++] = piece;</span>
            <span class="s0">positive++;</span>
        <span class="s0">}</span>
        <span class="s1">let </span><span class="s0">path = </span><span class="s2">''</span><span class="s0">;</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s5">1</span><span class="s0">; i &lt; pointer; i++) {</span>
            <span class="s0">path += </span><span class="s2">'/' </span><span class="s0">+ pieces[i];</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(!path || (addTrailingSlash &amp;&amp; !path.endsWith(</span><span class="s2">'/..'</span><span class="s0">))) {</span>
            <span class="s0">path += </span><span class="s2">'/'</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">url.path = path;</span>
    <span class="s0">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Attempts to resolve `input` URL/path relative to `base`.</span>
     <span class="s3">*/</span>
    <span class="s1">function </span><span class="s0">resolve(input, base) {</span>
        <span class="s1">if </span><span class="s0">(!input &amp;&amp; !base)</span>
            <span class="s1">return </span><span class="s2">''</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">url = parseUrl(input);</span>
        <span class="s1">let </span><span class="s0">inputType = url.type;</span>
        <span class="s1">if </span><span class="s0">(base &amp;&amp; inputType !== </span><span class="s5">7 </span><span class="s3">/* Absolute */</span><span class="s0">) {</span>
            <span class="s1">const </span><span class="s0">baseUrl = parseUrl(base);</span>
            <span class="s1">const </span><span class="s0">baseType = baseUrl.type;</span>
            <span class="s1">switch </span><span class="s0">(inputType) {</span>
                <span class="s1">case </span><span class="s5">1 </span><span class="s3">/* Empty */</span><span class="s0">:</span>
                    <span class="s0">url.hash = baseUrl.hash;</span>
                <span class="s3">// fall through</span>
                <span class="s1">case </span><span class="s5">2 </span><span class="s3">/* Hash */</span><span class="s0">:</span>
                    <span class="s0">url.query = baseUrl.query;</span>
                <span class="s3">// fall through</span>
                <span class="s1">case </span><span class="s5">3 </span><span class="s3">/* Query */</span><span class="s0">:</span>
                <span class="s1">case </span><span class="s5">4 </span><span class="s3">/* RelativePath */</span><span class="s0">:</span>
                    <span class="s0">mergePaths(url, baseUrl);</span>
                <span class="s3">// fall through</span>
                <span class="s1">case </span><span class="s5">5 </span><span class="s3">/* AbsolutePath */</span><span class="s0">:</span>
                    <span class="s3">// The host, user, and port are joined, you can't copy one without the others.</span>
                    <span class="s0">url.user = baseUrl.user;</span>
                    <span class="s0">url.host = baseUrl.host;</span>
                    <span class="s0">url.port = baseUrl.port;</span>
                <span class="s3">// fall through</span>
                <span class="s1">case </span><span class="s5">6 </span><span class="s3">/* SchemeRelative */</span><span class="s0">:</span>
                    <span class="s3">// The input doesn't have a schema at least, so we need to copy at least that over.</span>
                    <span class="s0">url.scheme = baseUrl.scheme;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(baseType &gt; inputType)</span>
                <span class="s0">inputType = baseType;</span>
        <span class="s0">}</span>
        <span class="s0">normalizePath(url, inputType);</span>
        <span class="s1">const </span><span class="s0">queryHash = url.query + url.hash;</span>
        <span class="s1">switch </span><span class="s0">(inputType) {</span>
            <span class="s3">// This is impossible, because of the empty checks at the start of the function.</span>
            <span class="s3">// case UrlType.Empty:</span>
            <span class="s1">case </span><span class="s5">2 </span><span class="s3">/* Hash */</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s5">3 </span><span class="s3">/* Query */</span><span class="s0">:</span>
                <span class="s1">return </span><span class="s0">queryHash;</span>
            <span class="s1">case </span><span class="s5">4 </span><span class="s3">/* RelativePath */</span><span class="s0">: {</span>
                <span class="s3">// The first char is always a &quot;/&quot;, and we need it to be relative.</span>
                <span class="s1">const </span><span class="s0">path = url.path.slice(</span><span class="s5">1</span><span class="s0">);</span>
                <span class="s1">if </span><span class="s0">(!path)</span>
                    <span class="s1">return </span><span class="s0">queryHash || </span><span class="s2">'.'</span><span class="s0">;</span>
                <span class="s1">if </span><span class="s0">(isRelative(base || input) &amp;&amp; !isRelative(path)) {</span>
                    <span class="s3">// If base started with a leading &quot;.&quot;, or there is no base and input started with a &quot;.&quot;,</span>
                    <span class="s3">// then we need to ensure that the relative path starts with a &quot;.&quot;. We don't know if</span>
                    <span class="s3">// relative starts with a &quot;..&quot;, though, so check before prepending.</span>
                    <span class="s1">return </span><span class="s2">'./' </span><span class="s0">+ path + queryHash;</span>
                <span class="s0">}</span>
                <span class="s1">return </span><span class="s0">path + queryHash;</span>
            <span class="s0">}</span>
            <span class="s1">case </span><span class="s5">5 </span><span class="s3">/* AbsolutePath */</span><span class="s0">:</span>
                <span class="s1">return </span><span class="s0">url.path + queryHash;</span>
            <span class="s1">default</span><span class="s0">:</span>
                <span class="s1">return </span><span class="s0">url.scheme + </span><span class="s2">'//' </span><span class="s0">+ url.user + url.host + url.port + url.path + queryHash;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s1">return </span><span class="s0">resolve;</span>

<span class="s0">}));</span>
<span class="s3">//# sourceMappingURL=resolve-uri.umd.js.map</span>
</pre>
</body>
</html>