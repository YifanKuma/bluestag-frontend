<html>
<head>
<title>dom-mini.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
dom-mini.js</font>
</center></td></tr></table>
<pre><span class="s0">'use strict'</span><span class="s1">;</span>

<span class="s1">Object.defineProperty(exports, </span><span class="s0">'__esModule'</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>

<span class="s2">var </span><span class="s1">motionDom = require(</span><span class="s0">'motion-dom'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">motionUtils = require(</span><span class="s0">'motion-utils'</span><span class="s1">);</span>

<span class="s2">function </span><span class="s1">isDOMKeyframes(keyframes) {</span>
    <span class="s2">return typeof </span><span class="s1">keyframes === </span><span class="s0">&quot;object&quot; </span><span class="s1">&amp;&amp; !Array.isArray(keyframes);</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">resolveSubjects(subject, keyframes, scope, selectorCache) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">subject === </span><span class="s0">&quot;string&quot; </span><span class="s1">&amp;&amp; isDOMKeyframes(keyframes)) {</span>
        <span class="s2">return </span><span class="s1">motionDom.resolveElements(subject, scope, selectorCache);</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(subject </span><span class="s2">instanceof </span><span class="s1">NodeList) {</span>
        <span class="s2">return </span><span class="s1">Array.from(subject);</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(Array.isArray(subject)) {</span>
        <span class="s2">return </span><span class="s1">subject;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s2">return </span><span class="s1">[subject];</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">calculateRepeatDuration(duration, repeat, _repeatDelay) {</span>
    <span class="s2">return </span><span class="s1">duration * (repeat + </span><span class="s3">1</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s4">/**</span>
 <span class="s4">* Given a absolute or relative time definition and current/prev time state of the sequence,</span>
 <span class="s4">* calculate an absolute time for the next keyframes.</span>
 <span class="s4">*/</span>
<span class="s2">function </span><span class="s1">calcNextTime(current, next, prev, labels) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">next === </span><span class="s0">&quot;number&quot;</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">next;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(next.startsWith(</span><span class="s0">&quot;-&quot;</span><span class="s1">) || next.startsWith(</span><span class="s0">&quot;+&quot;</span><span class="s1">)) {</span>
        <span class="s2">return </span><span class="s1">Math.max(</span><span class="s3">0</span><span class="s1">, current + parseFloat(next));</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(next === </span><span class="s0">&quot;&lt;&quot;</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">prev;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(next.startsWith(</span><span class="s0">&quot;&lt;&quot;</span><span class="s1">)) {</span>
        <span class="s2">return </span><span class="s1">Math.max(</span><span class="s3">0</span><span class="s1">, prev + parseFloat(next.slice(</span><span class="s3">1</span><span class="s1">)));</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s2">return </span><span class="s1">labels.get(next) ?? current;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">eraseKeyframes(sequence, startTime, endTime) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">; i &lt; sequence.length; i++) {</span>
        <span class="s2">const </span><span class="s1">keyframe = sequence[i];</span>
        <span class="s2">if </span><span class="s1">(keyframe.at &gt; startTime &amp;&amp; keyframe.at &lt; endTime) {</span>
            <span class="s1">motionUtils.removeItem(sequence, keyframe);</span>
            <span class="s4">// If we remove this item we have to push the pointer back one</span>
            <span class="s1">i--;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">addKeyframes(sequence, keyframes, easing, offset, startTime, endTime) {</span>
    <span class="s4">/**</span>
     <span class="s4">* Erase every existing value between currentTime and targetTime,</span>
     <span class="s4">* this will essentially splice this timeline into any currently</span>
     <span class="s4">* defined ones.</span>
     <span class="s4">*/</span>
    <span class="s1">eraseKeyframes(sequence, startTime, endTime);</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">; i &lt; keyframes.length; i++) {</span>
        <span class="s1">sequence.push({</span>
            <span class="s1">value: keyframes[i],</span>
            <span class="s1">at: motionDom.mixNumber(startTime, endTime, offset[i]),</span>
            <span class="s1">easing: motionUtils.getEasingForSegment(easing, i),</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">/**</span>
 <span class="s4">* Take an array of times that represent repeated keyframes. For instance</span>
 <span class="s4">* if we have original times of [0, 0.5, 1] then our repeated times will</span>
 <span class="s4">* be [0, 0.5, 1, 1, 1.5, 2]. Loop over the times and scale them back</span>
 <span class="s4">* down to a 0-1 scale.</span>
 <span class="s4">*/</span>
<span class="s2">function </span><span class="s1">normalizeTimes(times, repeat) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">; i &lt; times.length; i++) {</span>
        <span class="s1">times[i] = times[i] / (repeat + </span><span class="s3">1</span><span class="s1">);</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">compareByTime(a, b) {</span>
    <span class="s2">if </span><span class="s1">(a.at === b.at) {</span>
        <span class="s2">if </span><span class="s1">(a.value === </span><span class="s2">null</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s3">1</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(b.value === </span><span class="s2">null</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">-</span><span class="s3">1</span><span class="s1">;</span>
        <span class="s2">return </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s2">return </span><span class="s1">a.at - b.at;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">defaultSegmentEasing = </span><span class="s0">&quot;easeInOut&quot;</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">MAX_REPEAT = </span><span class="s3">20</span><span class="s1">;</span>
<span class="s2">function </span><span class="s1">createAnimationsFromSequence(sequence, { defaultTransition = {}, ...sequenceTransition } = {}, scope, generators) {</span>
    <span class="s2">const </span><span class="s1">defaultDuration = defaultTransition.duration || </span><span class="s3">0.3</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">animationDefinitions = </span><span class="s2">new </span><span class="s1">Map();</span>
    <span class="s2">const </span><span class="s1">sequences = </span><span class="s2">new </span><span class="s1">Map();</span>
    <span class="s2">const </span><span class="s1">elementCache = {};</span>
    <span class="s2">const </span><span class="s1">timeLabels = </span><span class="s2">new </span><span class="s1">Map();</span>
    <span class="s2">let </span><span class="s1">prevTime = </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s2">let </span><span class="s1">currentTime = </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s2">let </span><span class="s1">totalDuration = </span><span class="s3">0</span><span class="s1">;</span>
    <span class="s4">/**</span>
     <span class="s4">* Build the timeline by mapping over the sequence array and converting</span>
     <span class="s4">* the definitions into keyframes and offsets with absolute time values.</span>
     <span class="s4">* These will later get converted into relative offsets in a second pass.</span>
     <span class="s4">*/</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">; i &lt; sequence.length; i++) {</span>
        <span class="s2">const </span><span class="s1">segment = sequence[i];</span>
        <span class="s4">/**</span>
         <span class="s4">* If this is a timeline label, mark it and skip the rest of this iteration.</span>
         <span class="s4">*/</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">segment === </span><span class="s0">&quot;string&quot;</span><span class="s1">) {</span>
            <span class="s1">timeLabels.set(segment, currentTime);</span>
            <span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(!Array.isArray(segment)) {</span>
            <span class="s1">timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));</span>
            <span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">[subject, keyframes, transition = {}] = segment;</span>
        <span class="s4">/**</span>
         <span class="s4">* If a relative or absolute time value has been specified we need to resolve</span>
         <span class="s4">* it in relation to the currentTime.</span>
         <span class="s4">*/</span>
        <span class="s2">if </span><span class="s1">(transition.at !== undefined) {</span>
            <span class="s1">currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels);</span>
        <span class="s1">}</span>
        <span class="s4">/**</span>
         <span class="s4">* Keep track of the maximum duration in this definition. This will be</span>
         <span class="s4">* applied to currentTime once the definition has been parsed.</span>
         <span class="s4">*/</span>
        <span class="s2">let </span><span class="s1">maxDuration = </span><span class="s3">0</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = </span><span class="s3">0</span><span class="s1">, numSubjects = </span><span class="s3">0</span><span class="s1">) =&gt; {</span>
            <span class="s2">const </span><span class="s1">valueKeyframesAsList = keyframesAsList(valueKeyframes);</span>
            <span class="s2">const </span><span class="s1">{ delay = </span><span class="s3">0</span><span class="s1">, times = motionDom.defaultOffset(valueKeyframesAsList), type = </span><span class="s0">&quot;keyframes&quot;</span><span class="s1">, repeat, repeatType, repeatDelay = </span><span class="s3">0</span><span class="s1">, ...remainingTransition } = valueTransition;</span>
            <span class="s2">let </span><span class="s1">{ ease = defaultTransition.ease || </span><span class="s0">&quot;easeOut&quot;</span><span class="s1">, duration } = valueTransition;</span>
            <span class="s4">/**</span>
             <span class="s4">* Resolve stagger() if defined.</span>
             <span class="s4">*/</span>
            <span class="s2">const </span><span class="s1">calculatedDelay = </span><span class="s2">typeof </span><span class="s1">delay === </span><span class="s0">&quot;function&quot;</span>
                <span class="s1">? delay(elementIndex, numSubjects)</span>
                <span class="s1">: delay;</span>
            <span class="s4">/**</span>
             <span class="s4">* If this animation should and can use a spring, generate a spring easing function.</span>
             <span class="s4">*/</span>
            <span class="s2">const </span><span class="s1">numKeyframes = valueKeyframesAsList.length;</span>
            <span class="s2">const </span><span class="s1">createGenerator = motionDom.isGenerator(type)</span>
                <span class="s1">? type</span>
                <span class="s1">: generators?.[type || </span><span class="s0">&quot;keyframes&quot;</span><span class="s1">];</span>
            <span class="s2">if </span><span class="s1">(numKeyframes &lt;= </span><span class="s3">2 </span><span class="s1">&amp;&amp; createGenerator) {</span>
                <span class="s4">/**</span>
                 <span class="s4">* As we're creating an easing function from a spring,</span>
                 <span class="s4">* ideally we want to generate it using the real distance</span>
                 <span class="s4">* between the two keyframes. However this isn't always</span>
                 <span class="s4">* possible - in these situations we use 0-100.</span>
                 <span class="s4">*/</span>
                <span class="s2">let </span><span class="s1">absoluteDelta = </span><span class="s3">100</span><span class="s1">;</span>
                <span class="s2">if </span><span class="s1">(numKeyframes === </span><span class="s3">2 </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">isNumberKeyframesArray(valueKeyframesAsList)) {</span>
                    <span class="s2">const </span><span class="s1">delta = valueKeyframesAsList[</span><span class="s3">1</span><span class="s1">] - valueKeyframesAsList[</span><span class="s3">0</span><span class="s1">];</span>
                    <span class="s1">absoluteDelta = Math.abs(delta);</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">springTransition = { ...remainingTransition };</span>
                <span class="s2">if </span><span class="s1">(duration !== undefined) {</span>
                    <span class="s1">springTransition.duration = motionUtils.secondsToMilliseconds(duration);</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">springEasing = motionDom.createGeneratorEasing(springTransition, absoluteDelta, createGenerator);</span>
                <span class="s1">ease = springEasing.ease;</span>
                <span class="s1">duration = springEasing.duration;</span>
            <span class="s1">}</span>
            <span class="s1">duration ?? (duration = defaultDuration);</span>
            <span class="s2">const </span><span class="s1">startTime = currentTime + calculatedDelay;</span>
            <span class="s4">/**</span>
             <span class="s4">* If there's only one time offset of 0, fill in a second with length 1</span>
             <span class="s4">*/</span>
            <span class="s2">if </span><span class="s1">(times.length === </span><span class="s3">1 </span><span class="s1">&amp;&amp; times[</span><span class="s3">0</span><span class="s1">] === </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s1">times[</span><span class="s3">1</span><span class="s1">] = </span><span class="s3">1</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s4">/**</span>
             <span class="s4">* Fill out if offset if fewer offsets than keyframes</span>
             <span class="s4">*/</span>
            <span class="s2">const </span><span class="s1">remainder = times.length - valueKeyframesAsList.length;</span>
            <span class="s1">remainder &gt; </span><span class="s3">0 </span><span class="s1">&amp;&amp; motionDom.fillOffset(times, remainder);</span>
            <span class="s4">/**</span>
             <span class="s4">* If only one value has been set, ie [1], push a null to the start of</span>
             <span class="s4">* the keyframe array. This will let us mark a keyframe at this point</span>
             <span class="s4">* that will later be hydrated with the previous value.</span>
             <span class="s4">*/</span>
            <span class="s1">valueKeyframesAsList.length === </span><span class="s3">1 </span><span class="s1">&amp;&amp;</span>
                <span class="s1">valueKeyframesAsList.unshift(</span><span class="s2">null</span><span class="s1">);</span>
            <span class="s4">/**</span>
             <span class="s4">* Handle repeat options</span>
             <span class="s4">*/</span>
            <span class="s2">if </span><span class="s1">(repeat) {</span>
                <span class="s1">motionUtils.invariant(repeat &lt; MAX_REPEAT, </span><span class="s0">&quot;Repeat count too high, must be less than 20&quot;</span><span class="s1">, </span><span class="s0">&quot;repeat-count-high&quot;</span><span class="s1">);</span>
                <span class="s1">duration = calculateRepeatDuration(duration, repeat);</span>
                <span class="s2">const </span><span class="s1">originalKeyframes = [...valueKeyframesAsList];</span>
                <span class="s2">const </span><span class="s1">originalTimes = [...times];</span>
                <span class="s1">ease = Array.isArray(ease) ? [...ease] : [ease];</span>
                <span class="s2">const </span><span class="s1">originalEase = [...ease];</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">repeatIndex = </span><span class="s3">0</span><span class="s1">; repeatIndex &lt; repeat; repeatIndex++) {</span>
                    <span class="s1">valueKeyframesAsList.push(...originalKeyframes);</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">keyframeIndex = </span><span class="s3">0</span><span class="s1">; keyframeIndex &lt; originalKeyframes.length; keyframeIndex++) {</span>
                        <span class="s1">times.push(originalTimes[keyframeIndex] + (repeatIndex + </span><span class="s3">1</span><span class="s1">));</span>
                        <span class="s1">ease.push(keyframeIndex === </span><span class="s3">0</span>
                            <span class="s1">? </span><span class="s0">&quot;linear&quot;</span>
                            <span class="s1">: motionUtils.getEasingForSegment(originalEase, keyframeIndex - </span><span class="s3">1</span><span class="s1">));</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s1">normalizeTimes(times, repeat);</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">targetTime = startTime + duration;</span>
            <span class="s4">/**</span>
             <span class="s4">* Add keyframes, mapping offsets to absolute time.</span>
             <span class="s4">*/</span>
            <span class="s1">addKeyframes(valueSequence, valueKeyframesAsList, ease, times, startTime, targetTime);</span>
            <span class="s1">maxDuration = Math.max(calculatedDelay + duration, maxDuration);</span>
            <span class="s1">totalDuration = Math.max(targetTime, totalDuration);</span>
        <span class="s1">};</span>
        <span class="s2">if </span><span class="s1">(motionDom.isMotionValue(subject)) {</span>
            <span class="s2">const </span><span class="s1">subjectSequence = getSubjectSequence(subject, sequences);</span>
            <span class="s1">resolveValueSequence(keyframes, transition, getValueSequence(</span><span class="s0">&quot;default&quot;</span><span class="s1">, subjectSequence));</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">const </span><span class="s1">subjects = resolveSubjects(subject, keyframes, scope, elementCache);</span>
            <span class="s2">const </span><span class="s1">numSubjects = subjects.length;</span>
            <span class="s4">/**</span>
             <span class="s4">* For every element in this segment, process the defined values.</span>
             <span class="s4">*/</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">subjectIndex = </span><span class="s3">0</span><span class="s1">; subjectIndex &lt; numSubjects; subjectIndex++) {</span>
                <span class="s4">/**</span>
                 <span class="s4">* Cast necessary, but we know these are of this type</span>
                 <span class="s4">*/</span>
                <span class="s1">keyframes = keyframes;</span>
                <span class="s1">transition = transition;</span>
                <span class="s2">const </span><span class="s1">thisSubject = subjects[subjectIndex];</span>
                <span class="s2">const </span><span class="s1">subjectSequence = getSubjectSequence(thisSubject, sequences);</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">keyframes) {</span>
                    <span class="s1">resolveValueSequence(keyframes[key], getValueTransition(transition, key), getValueSequence(key, subjectSequence), subjectIndex, numSubjects);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">prevTime = currentTime;</span>
        <span class="s1">currentTime += maxDuration;</span>
    <span class="s1">}</span>
    <span class="s4">/**</span>
     <span class="s4">* For every element and value combination create a new animation.</span>
     <span class="s4">*/</span>
    <span class="s1">sequences.forEach((valueSequences, element) =&gt; {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">valueSequences) {</span>
            <span class="s2">const </span><span class="s1">valueSequence = valueSequences[key];</span>
            <span class="s4">/**</span>
             <span class="s4">* Arrange all the keyframes in ascending time order.</span>
             <span class="s4">*/</span>
            <span class="s1">valueSequence.sort(compareByTime);</span>
            <span class="s2">const </span><span class="s1">keyframes = [];</span>
            <span class="s2">const </span><span class="s1">valueOffset = [];</span>
            <span class="s2">const </span><span class="s1">valueEasing = [];</span>
            <span class="s4">/**</span>
             <span class="s4">* For each keyframe, translate absolute times into</span>
             <span class="s4">* relative offsets based on the total duration of the timeline.</span>
             <span class="s4">*/</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">; i &lt; valueSequence.length; i++) {</span>
                <span class="s2">const </span><span class="s1">{ at, value, easing } = valueSequence[i];</span>
                <span class="s1">keyframes.push(value);</span>
                <span class="s1">valueOffset.push(motionUtils.progress(</span><span class="s3">0</span><span class="s1">, totalDuration, at));</span>
                <span class="s1">valueEasing.push(easing || </span><span class="s0">&quot;easeOut&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s4">/**</span>
             <span class="s4">* If the first keyframe doesn't land on offset: 0</span>
             <span class="s4">* provide one by duplicating the initial keyframe. This ensures</span>
             <span class="s4">* it snaps to the first keyframe when the animation starts.</span>
             <span class="s4">*/</span>
            <span class="s2">if </span><span class="s1">(valueOffset[</span><span class="s3">0</span><span class="s1">] !== </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s1">valueOffset.unshift(</span><span class="s3">0</span><span class="s1">);</span>
                <span class="s1">keyframes.unshift(keyframes[</span><span class="s3">0</span><span class="s1">]);</span>
                <span class="s1">valueEasing.unshift(defaultSegmentEasing);</span>
            <span class="s1">}</span>
            <span class="s4">/**</span>
             <span class="s4">* If the last keyframe doesn't land on offset: 1</span>
             <span class="s4">* provide one with a null wildcard value. This will ensure it</span>
             <span class="s4">* stays static until the end of the animation.</span>
             <span class="s4">*/</span>
            <span class="s2">if </span><span class="s1">(valueOffset[valueOffset.length - </span><span class="s3">1</span><span class="s1">] !== </span><span class="s3">1</span><span class="s1">) {</span>
                <span class="s1">valueOffset.push(</span><span class="s3">1</span><span class="s1">);</span>
                <span class="s1">keyframes.push(</span><span class="s2">null</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(!animationDefinitions.has(element)) {</span>
                <span class="s1">animationDefinitions.set(element, {</span>
                    <span class="s1">keyframes: {},</span>
                    <span class="s1">transition: {},</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">definition = animationDefinitions.get(element);</span>
            <span class="s1">definition.keyframes[key] = keyframes;</span>
            <span class="s1">definition.transition[key] = {</span>
                <span class="s1">...defaultTransition,</span>
                <span class="s1">duration: totalDuration,</span>
                <span class="s1">ease: valueEasing,</span>
                <span class="s1">times: valueOffset,</span>
                <span class="s1">...sequenceTransition,</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s2">return </span><span class="s1">animationDefinitions;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getSubjectSequence(subject, sequences) {</span>
    <span class="s1">!sequences.has(subject) &amp;&amp; sequences.set(subject, {});</span>
    <span class="s2">return </span><span class="s1">sequences.get(subject);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getValueSequence(name, sequences) {</span>
    <span class="s2">if </span><span class="s1">(!sequences[name])</span>
        <span class="s1">sequences[name] = [];</span>
    <span class="s2">return </span><span class="s1">sequences[name];</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">keyframesAsList(keyframes) {</span>
    <span class="s2">return </span><span class="s1">Array.isArray(keyframes) ? keyframes : [keyframes];</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getValueTransition(transition, key) {</span>
    <span class="s2">return </span><span class="s1">transition &amp;&amp; transition[key]</span>
        <span class="s1">? {</span>
            <span class="s1">...transition,</span>
            <span class="s1">...transition[key],</span>
        <span class="s1">}</span>
        <span class="s1">: { ...transition };</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">isNumber = (keyframe) =&gt; </span><span class="s2">typeof </span><span class="s1">keyframe === </span><span class="s0">&quot;number&quot;</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">isNumberKeyframesArray = (keyframes) =&gt; keyframes.every(isNumber);</span>

<span class="s2">function </span><span class="s1">animateElements(elementOrSelector, keyframes, options, scope) {</span>
    <span class="s2">const </span><span class="s1">elements = motionDom.resolveElements(elementOrSelector, scope);</span>
    <span class="s2">const </span><span class="s1">numElements = elements.length;</span>
    <span class="s1">motionUtils.invariant(Boolean(numElements), </span><span class="s0">&quot;No valid elements provided.&quot;</span><span class="s1">, </span><span class="s0">&quot;no-valid-elements&quot;</span><span class="s1">);</span>
    <span class="s4">/**</span>
     <span class="s4">* WAAPI doesn't support interrupting animations.</span>
     <span class="s4">*</span>
     <span class="s4">* Therefore, starting animations requires a three-step process:</span>
     <span class="s4">* 1. Stop existing animations (write styles to DOM)</span>
     <span class="s4">* 2. Resolve keyframes (read styles from DOM)</span>
     <span class="s4">* 3. Create new animations (write styles to DOM)</span>
     <span class="s4">*</span>
     <span class="s4">* The hybrid `animate()` function uses AsyncAnimation to resolve</span>
     <span class="s4">* keyframes before creating new animations, which removes style</span>
     <span class="s4">* thrashing. Here, we have much stricter filesize constraints.</span>
     <span class="s4">* Therefore we do this in a synchronous way that ensures that</span>
     <span class="s4">* at least within `animate()` calls there is no style thrashing.</span>
     <span class="s4">*</span>
     <span class="s4">* In the motion-native-animate-mini-interrupt benchmark this</span>
     <span class="s4">* was 80% faster than a single loop.</span>
     <span class="s4">*/</span>
    <span class="s2">const </span><span class="s1">animationDefinitions = [];</span>
    <span class="s4">/**</span>
     <span class="s4">* Step 1: Build options and stop existing animations (write)</span>
     <span class="s4">*/</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">; i &lt; numElements; i++) {</span>
        <span class="s2">const </span><span class="s1">element = elements[i];</span>
        <span class="s2">const </span><span class="s1">elementTransition = { ...options };</span>
        <span class="s4">/**</span>
         <span class="s4">* Resolve stagger function if provided.</span>
         <span class="s4">*/</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">elementTransition.delay === </span><span class="s0">&quot;function&quot;</span><span class="s1">) {</span>
            <span class="s1">elementTransition.delay = elementTransition.delay(i, numElements);</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">valueName </span><span class="s2">in </span><span class="s1">keyframes) {</span>
            <span class="s2">let </span><span class="s1">valueKeyframes = keyframes[valueName];</span>
            <span class="s2">if </span><span class="s1">(!Array.isArray(valueKeyframes)) {</span>
                <span class="s1">valueKeyframes = [valueKeyframes];</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">valueOptions = {</span>
                <span class="s1">...motionDom.getValueTransition(elementTransition, valueName),</span>
            <span class="s1">};</span>
            <span class="s1">valueOptions.duration &amp;&amp; (valueOptions.duration = motionUtils.secondsToMilliseconds(valueOptions.duration));</span>
            <span class="s1">valueOptions.delay &amp;&amp; (valueOptions.delay = motionUtils.secondsToMilliseconds(valueOptions.delay));</span>
            <span class="s4">/**</span>
             <span class="s4">* If there's an existing animation playing on this element then stop it</span>
             <span class="s4">* before creating a new one.</span>
             <span class="s4">*/</span>
            <span class="s2">const </span><span class="s1">map = motionDom.getAnimationMap(element);</span>
            <span class="s2">const </span><span class="s1">key = motionDom.animationMapKey(valueName, valueOptions.pseudoElement || </span><span class="s0">&quot;&quot;</span><span class="s1">);</span>
            <span class="s2">const </span><span class="s1">currentAnimation = map.get(key);</span>
            <span class="s1">currentAnimation &amp;&amp; currentAnimation.stop();</span>
            <span class="s1">animationDefinitions.push({</span>
                <span class="s1">map,</span>
                <span class="s1">key,</span>
                <span class="s1">unresolvedKeyframes: valueKeyframes,</span>
                <span class="s1">options: {</span>
                    <span class="s1">...valueOptions,</span>
                    <span class="s1">element,</span>
                    <span class="s1">name: valueName,</span>
                    <span class="s1">allowFlatten: !elementTransition.type &amp;&amp; !elementTransition.ease,</span>
                <span class="s1">},</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s4">/**</span>
     <span class="s4">* Step 2: Resolve keyframes (read)</span>
     <span class="s4">*/</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">; i &lt; animationDefinitions.length; i++) {</span>
        <span class="s2">const </span><span class="s1">{ unresolvedKeyframes, options: animationOptions } = animationDefinitions[i];</span>
        <span class="s2">const </span><span class="s1">{ element, name, pseudoElement } = animationOptions;</span>
        <span class="s2">if </span><span class="s1">(!pseudoElement &amp;&amp; unresolvedKeyframes[</span><span class="s3">0</span><span class="s1">] === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s1">unresolvedKeyframes[</span><span class="s3">0</span><span class="s1">] = motionDom.getComputedStyle(element, name);</span>
        <span class="s1">}</span>
        <span class="s1">motionDom.fillWildcards(unresolvedKeyframes);</span>
        <span class="s1">motionDom.applyPxDefaults(unresolvedKeyframes, name);</span>
        <span class="s4">/**</span>
         <span class="s4">* If we only have one keyframe, explicitly read the initial keyframe</span>
         <span class="s4">* from the computed style. This is to ensure consistency with WAAPI behaviour</span>
         <span class="s4">* for restarting animations, for instance .play() after finish, when it</span>
         <span class="s4">* has one vs two keyframes.</span>
         <span class="s4">*/</span>
        <span class="s2">if </span><span class="s1">(!pseudoElement &amp;&amp; unresolvedKeyframes.length &lt; </span><span class="s3">2</span><span class="s1">) {</span>
            <span class="s1">unresolvedKeyframes.unshift(motionDom.getComputedStyle(element, name));</span>
        <span class="s1">}</span>
        <span class="s1">animationOptions.keyframes = unresolvedKeyframes;</span>
    <span class="s1">}</span>
    <span class="s4">/**</span>
     <span class="s4">* Step 3: Create new animations (write)</span>
     <span class="s4">*/</span>
    <span class="s2">const </span><span class="s1">animations = [];</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">; i &lt; animationDefinitions.length; i++) {</span>
        <span class="s2">const </span><span class="s1">{ map, key, options: animationOptions } = animationDefinitions[i];</span>
        <span class="s2">const </span><span class="s1">animation = </span><span class="s2">new </span><span class="s1">motionDom.NativeAnimation(animationOptions);</span>
        <span class="s1">map.set(key, animation);</span>
        <span class="s1">animation.finished.finally(() =&gt; map.delete(key));</span>
        <span class="s1">animations.push(animation);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">animations;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">animateSequence(definition, options) {</span>
    <span class="s2">const </span><span class="s1">animations = [];</span>
    <span class="s1">createAnimationsFromSequence(definition, options).forEach(({ keyframes, transition }, element) =&gt; {</span>
        <span class="s1">animations.push(...animateElements(element, keyframes, transition));</span>
    <span class="s1">});</span>
    <span class="s2">return new </span><span class="s1">motionDom.GroupAnimationWithThen(animations);</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">createScopedWaapiAnimate = (scope) =&gt; {</span>
    <span class="s2">function </span><span class="s1">scopedAnimate(elementOrSelector, keyframes, options) {</span>
        <span class="s2">return new </span><span class="s1">motionDom.GroupAnimationWithThen(animateElements(elementOrSelector, keyframes, options, scope));</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">scopedAnimate;</span>
<span class="s1">};</span>
<span class="s2">const </span><span class="s1">animateMini = </span><span class="s4">/*@__PURE__*/ </span><span class="s1">createScopedWaapiAnimate();</span>

<span class="s1">exports.animate = animateMini;</span>
<span class="s1">exports.animateSequence = animateSequence;</span>
</pre>
</body>
</html>