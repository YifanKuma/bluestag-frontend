<html>
<head>
<title>route-regex.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
route-regex.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../../src/shared/lib/router/utils/route-regex.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">NEXT_INTERCEPTION_MARKER_PREFIX,</span><span class="s3">\n  </span><span class="s1">NEXT_QUERY_PARAM_PREFIX,</span><span class="s3">\n</span><span class="s1">} from '../../../../lib/constants'</span><span class="s3">\n</span><span class="s1">import { INTERCEPTION_ROUTE_MARKERS } from './interception-routes'</span><span class="s3">\n</span><span class="s1">import { escapeStringRegexp } from '../../escape-regexp'</span><span class="s3">\n</span><span class="s1">import { removeTrailingSlash } from './remove-trailing-slash'</span><span class="s3">\n</span><span class="s1">import { PARAMETER_PATTERN, parseMatchedParameter } from './get-dynamic-param'</span><span class="s3">\n\n</span><span class="s1">export interface Group {</span><span class="s3">\n  </span><span class="s1">pos: number</span><span class="s3">\n  </span><span class="s1">repeat: boolean</span><span class="s3">\n  </span><span class="s1">optional: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface RouteRegex {</span><span class="s3">\n  </span><span class="s1">groups: { [groupName: string]: Group }</span><span class="s3">\n  </span><span class="s1">re: RegExp</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type GetNamedRouteRegexOptions = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to prefix the route keys with the NEXT_INTERCEPTION_MARKER_PREFIX</span><span class="s3">\n   </span><span class="s1">* or NEXT_QUERY_PARAM_PREFIX. This is only relevant when creating the</span><span class="s3">\n   </span><span class="s1">* routes-manifest during the build.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">prefixRouteKeys: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to include the suffix in the route regex. This means that when you</span><span class="s3">\n   </span><span class="s1">* have something like `/[...slug].json` the `.json` part will be included</span><span class="s3">\n   </span><span class="s1">* in the regex, yielding `/(.*).json` as the regex.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">includeSuffix?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to include the prefix in the route regex. This means that when you</span><span class="s3">\n   </span><span class="s1">* have something like `/[...slug].json` the `/` part will be included</span><span class="s3">\n   </span><span class="s1">* in the regex, yielding `^/(.*).json$` as the regex.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* Note that interception markers will already be included without the need</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">includePrefix?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to exclude the optional trailing slash from the route regex.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">excludeOptionalTrailingSlash?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to backtrack duplicate keys. This is only relevant when creating</span><span class="s3">\n   </span><span class="s1">* the routes-manifest during the build.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">backreferenceDuplicateKeys?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type GetRouteRegexOptions = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to include extra parts in the route regex. This means that when you</span><span class="s3">\n   </span><span class="s1">* have something like `/[...slug].json` the `.json` part will be included</span><span class="s3">\n   </span><span class="s1">* in the regex, yielding `/(.*).json` as the regex.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">includeSuffix?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to include the prefix in the route regex. This means that when you</span><span class="s3">\n   </span><span class="s1">* have something like `/[...slug].json` the `/` part will be included</span><span class="s3">\n   </span><span class="s1">* in the regex, yielding `^/(.*).json$` as the regex.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* Note that interception markers will already be included without the need</span><span class="s3">\n   </span><span class="s1">* of adding this option.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">includePrefix?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to exclude the optional trailing slash from the route regex.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">excludeOptionalTrailingSlash?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getParametrizedRoute(</span><span class="s3">\n  </span><span class="s1">route: string,</span><span class="s3">\n  </span><span class="s1">includeSuffix: boolean,</span><span class="s3">\n  </span><span class="s1">includePrefix: boolean</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const groups: { [groupName: string]: Group } = {}</span><span class="s3">\n  </span><span class="s1">let groupIndex = 1</span><span class="s3">\n\n  </span><span class="s1">const segments: string[] = []</span><span class="s3">\n  </span><span class="s1">for (const segment of removeTrailingSlash(route).slice(1).split('/')) {</span><span class="s3">\n    </span><span class="s1">const markerMatch = INTERCEPTION_ROUTE_MARKERS.find((m) =&gt;</span><span class="s3">\n      </span><span class="s1">segment.startsWith(m)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">const paramMatches = segment.match(PARAMETER_PATTERN) // Check for parameters</span><span class="s3">\n\n    </span><span class="s1">if (markerMatch &amp;&amp; paramMatches &amp;&amp; paramMatches[2]) {</span><span class="s3">\n      </span><span class="s1">const { key, optional, repeat } = parseMatchedParameter(paramMatches[2])</span><span class="s3">\n      </span><span class="s1">groups[key] = { pos: groupIndex++, repeat, optional }</span><span class="s3">\n      </span><span class="s1">segments.push(`/${escapeStringRegexp(markerMatch)}([^/]+?)`)</span><span class="s3">\n    </span><span class="s1">} else if (paramMatches &amp;&amp; paramMatches[2]) {</span><span class="s3">\n      </span><span class="s1">const { key, repeat, optional } = parseMatchedParameter(paramMatches[2])</span><span class="s3">\n      </span><span class="s1">groups[key] = { pos: groupIndex++, repeat, optional }</span><span class="s3">\n\n      </span><span class="s1">if (includePrefix &amp;&amp; paramMatches[1]) {</span><span class="s3">\n        </span><span class="s1">segments.push(`/${escapeStringRegexp(paramMatches[1])}`)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">let s = repeat ? (optional ? '(?:/(.+?))?' : '/(.+?)') : '/([^/]+?)'</span><span class="s3">\n\n      </span><span class="s1">// Remove the leading slash if includePrefix already added it.</span><span class="s3">\n      </span><span class="s1">if (includePrefix &amp;&amp; paramMatches[1]) {</span><span class="s3">\n        </span><span class="s1">s = s.substring(1)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">segments.push(s)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">segments.push(`/${escapeStringRegexp(segment)}`)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If there's a suffix, add it to the segments if it's enabled.</span><span class="s3">\n    </span><span class="s1">if (includeSuffix &amp;&amp; paramMatches &amp;&amp; paramMatches[3]) {</span><span class="s3">\n      </span><span class="s1">segments.push(escapeStringRegexp(paramMatches[3]))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">parameterizedRoute: segments.join(''),</span><span class="s3">\n    </span><span class="s1">groups,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* From a normalized route this function generates a regular expression and</span><span class="s3">\n </span><span class="s1">* a corresponding groups object intended to be used to store matching groups</span><span class="s3">\n </span><span class="s1">* from the regular expression.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getRouteRegex(</span><span class="s3">\n  </span><span class="s1">normalizedRoute: string,</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">includeSuffix = false,</span><span class="s3">\n    </span><span class="s1">includePrefix = false,</span><span class="s3">\n    </span><span class="s1">excludeOptionalTrailingSlash = false,</span><span class="s3">\n  </span><span class="s1">}: GetRouteRegexOptions = {}</span><span class="s3">\n</span><span class="s1">): RouteRegex {</span><span class="s3">\n  </span><span class="s1">const { parameterizedRoute, groups } = getParametrizedRoute(</span><span class="s3">\n    </span><span class="s1">normalizedRoute,</span><span class="s3">\n    </span><span class="s1">includeSuffix,</span><span class="s3">\n    </span><span class="s1">includePrefix</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">let re = parameterizedRoute</span><span class="s3">\n  </span><span class="s1">if (!excludeOptionalTrailingSlash) {</span><span class="s3">\n    </span><span class="s1">re += '(?:/)?'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">re: new RegExp(`^${re}$`),</span><span class="s3">\n    </span><span class="s1">groups: groups,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Builds a function to generate a minimal routeKey using only a-z and minimal</span><span class="s3">\n </span><span class="s1">* number of characters.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function buildGetSafeRouteKey() {</span><span class="s3">\n  </span><span class="s1">let i = 0</span><span class="s3">\n\n  </span><span class="s1">return () =&gt; {</span><span class="s3">\n    </span><span class="s1">let routeKey = ''</span><span class="s3">\n    </span><span class="s1">let j = ++i</span><span class="s3">\n    </span><span class="s1">while (j &gt; 0) {</span><span class="s3">\n      </span><span class="s1">routeKey += String.fromCharCode(97 + ((j - 1) % 26))</span><span class="s3">\n      </span><span class="s1">j = Math.floor((j - 1) / 26)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return routeKey</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getSafeKeyFromSegment({</span><span class="s3">\n  </span><span class="s1">interceptionMarker,</span><span class="s3">\n  </span><span class="s1">getSafeRouteKey,</span><span class="s3">\n  </span><span class="s1">segment,</span><span class="s3">\n  </span><span class="s1">routeKeys,</span><span class="s3">\n  </span><span class="s1">keyPrefix,</span><span class="s3">\n  </span><span class="s1">backreferenceDuplicateKeys,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">interceptionMarker?: string</span><span class="s3">\n  </span><span class="s1">getSafeRouteKey: () =&gt; string</span><span class="s3">\n  </span><span class="s1">segment: string</span><span class="s3">\n  </span><span class="s1">routeKeys: Record&lt;string, string&gt;</span><span class="s3">\n  </span><span class="s1">keyPrefix?: string</span><span class="s3">\n  </span><span class="s1">backreferenceDuplicateKeys: boolean</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">const { key, optional, repeat } = parseMatchedParameter(segment)</span><span class="s3">\n\n  </span><span class="s1">// replace any non-word characters since they can break</span><span class="s3">\n  </span><span class="s1">// the named regex</span><span class="s3">\n  </span><span class="s1">let cleanedKey = key.replace(/</span><span class="s3">\\</span><span class="s1">W/g, '')</span><span class="s3">\n\n  </span><span class="s1">if (keyPrefix) {</span><span class="s3">\n    </span><span class="s1">cleanedKey = `${keyPrefix}${cleanedKey}`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">let invalidKey = false</span><span class="s3">\n\n  </span><span class="s1">// check if the key is still invalid and fallback to using a known</span><span class="s3">\n  </span><span class="s1">// safe key</span><span class="s3">\n  </span><span class="s1">if (cleanedKey.length === 0 || cleanedKey.length &gt; 30) {</span><span class="s3">\n    </span><span class="s1">invalidKey = true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {</span><span class="s3">\n    </span><span class="s1">invalidKey = true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (invalidKey) {</span><span class="s3">\n    </span><span class="s1">cleanedKey = getSafeRouteKey()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const duplicateKey = cleanedKey in routeKeys</span><span class="s3">\n\n  </span><span class="s1">if (keyPrefix) {</span><span class="s3">\n    </span><span class="s1">routeKeys[cleanedKey] = `${keyPrefix}${key}`</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">routeKeys[cleanedKey] = key</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// if the segment has an interception marker, make sure that's part of the regex pattern</span><span class="s3">\n  </span><span class="s1">// this is to ensure that the route with the interception marker doesn't incorrectly match</span><span class="s3">\n  </span><span class="s1">// the non-intercepted route (ie /app/(.)[username] should not match /app/[username])</span><span class="s3">\n  </span><span class="s1">const interceptionPrefix = interceptionMarker</span><span class="s3">\n    </span><span class="s1">? escapeStringRegexp(interceptionMarker)</span><span class="s3">\n    </span><span class="s1">: ''</span><span class="s3">\n\n  </span><span class="s1">let pattern: string</span><span class="s3">\n  </span><span class="s1">if (duplicateKey &amp;&amp; backreferenceDuplicateKeys) {</span><span class="s3">\n    </span><span class="s1">// Use a backreference to the key to ensure that the key is the same value</span><span class="s3">\n    </span><span class="s1">// in each of the placeholders.</span><span class="s3">\n    </span><span class="s1">pattern = `</span><span class="s3">\\\\</span><span class="s1">k&lt;${cleanedKey}&gt;`</span><span class="s3">\n  </span><span class="s1">} else if (repeat) {</span><span class="s3">\n    </span><span class="s1">pattern = `(?&lt;${cleanedKey}&gt;.+?)`</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">pattern = `(?&lt;${cleanedKey}&gt;[^/]+?)`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return optional</span><span class="s3">\n    </span><span class="s1">? `(?:/${interceptionPrefix}${pattern})?`</span><span class="s3">\n    </span><span class="s1">: `/${interceptionPrefix}${pattern}`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getNamedParametrizedRoute(</span><span class="s3">\n  </span><span class="s1">route: string,</span><span class="s3">\n  </span><span class="s1">prefixRouteKeys: boolean,</span><span class="s3">\n  </span><span class="s1">includeSuffix: boolean,</span><span class="s3">\n  </span><span class="s1">includePrefix: boolean,</span><span class="s3">\n  </span><span class="s1">backreferenceDuplicateKeys: boolean</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const getSafeRouteKey = buildGetSafeRouteKey()</span><span class="s3">\n  </span><span class="s1">const routeKeys: { [named: string]: string } = {}</span><span class="s3">\n\n  </span><span class="s1">const segments: string[] = []</span><span class="s3">\n  </span><span class="s1">for (const segment of removeTrailingSlash(route).slice(1).split('/')) {</span><span class="s3">\n    </span><span class="s1">const hasInterceptionMarker = INTERCEPTION_ROUTE_MARKERS.some((m) =&gt;</span><span class="s3">\n      </span><span class="s1">segment.startsWith(m)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">const paramMatches = segment.match(PARAMETER_PATTERN) // Check for parameters</span><span class="s3">\n\n    </span><span class="s1">if (hasInterceptionMarker &amp;&amp; paramMatches &amp;&amp; paramMatches[2]) {</span><span class="s3">\n      </span><span class="s1">// If there's an interception marker, add it to the segments.</span><span class="s3">\n      </span><span class="s1">segments.push(</span><span class="s3">\n        </span><span class="s1">getSafeKeyFromSegment({</span><span class="s3">\n          </span><span class="s1">getSafeRouteKey,</span><span class="s3">\n          </span><span class="s1">interceptionMarker: paramMatches[1],</span><span class="s3">\n          </span><span class="s1">segment: paramMatches[2],</span><span class="s3">\n          </span><span class="s1">routeKeys,</span><span class="s3">\n          </span><span class="s1">keyPrefix: prefixRouteKeys</span><span class="s3">\n            </span><span class="s1">? NEXT_INTERCEPTION_MARKER_PREFIX</span><span class="s3">\n            </span><span class="s1">: undefined,</span><span class="s3">\n          </span><span class="s1">backreferenceDuplicateKeys,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else if (paramMatches &amp;&amp; paramMatches[2]) {</span><span class="s3">\n      </span><span class="s1">// If there's a prefix, add it to the segments if it's enabled.</span><span class="s3">\n      </span><span class="s1">if (includePrefix &amp;&amp; paramMatches[1]) {</span><span class="s3">\n        </span><span class="s1">segments.push(`/${escapeStringRegexp(paramMatches[1])}`)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">let s = getSafeKeyFromSegment({</span><span class="s3">\n        </span><span class="s1">getSafeRouteKey,</span><span class="s3">\n        </span><span class="s1">segment: paramMatches[2],</span><span class="s3">\n        </span><span class="s1">routeKeys,</span><span class="s3">\n        </span><span class="s1">keyPrefix: prefixRouteKeys ? NEXT_QUERY_PARAM_PREFIX : undefined,</span><span class="s3">\n        </span><span class="s1">backreferenceDuplicateKeys,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n\n      </span><span class="s1">// Remove the leading slash if includePrefix already added it.</span><span class="s3">\n      </span><span class="s1">if (includePrefix &amp;&amp; paramMatches[1]) {</span><span class="s3">\n        </span><span class="s1">s = s.substring(1)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">segments.push(s)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">segments.push(`/${escapeStringRegexp(segment)}`)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If there's a suffix, add it to the segments if it's enabled.</span><span class="s3">\n    </span><span class="s1">if (includeSuffix &amp;&amp; paramMatches &amp;&amp; paramMatches[3]) {</span><span class="s3">\n      </span><span class="s1">segments.push(escapeStringRegexp(paramMatches[3]))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">namedParameterizedRoute: segments.join(''),</span><span class="s3">\n    </span><span class="s1">routeKeys,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This function extends `getRouteRegex` generating also a named regexp where</span><span class="s3">\n </span><span class="s1">* each group is named along with a routeKeys object that indexes the assigned</span><span class="s3">\n </span><span class="s1">* named group with its corresponding key. When the routeKeys need to be</span><span class="s3">\n </span><span class="s1">* prefixed to uniquely identify internally the </span><span class="s3">\&quot;</span><span class="s1">prefixRouteKey</span><span class="s3">\&quot; </span><span class="s1">arg should</span><span class="s3">\n </span><span class="s1">* be </span><span class="s3">\&quot;</span><span class="s1">true</span><span class="s3">\&quot; </span><span class="s1">currently this is only the case when creating the routes-manifest</span><span class="s3">\n </span><span class="s1">* during the build</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getNamedRouteRegex(</span><span class="s3">\n  </span><span class="s1">normalizedRoute: string,</span><span class="s3">\n  </span><span class="s1">options: GetNamedRouteRegexOptions</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const result = getNamedParametrizedRoute(</span><span class="s3">\n    </span><span class="s1">normalizedRoute,</span><span class="s3">\n    </span><span class="s1">options.prefixRouteKeys,</span><span class="s3">\n    </span><span class="s1">options.includeSuffix ?? false,</span><span class="s3">\n    </span><span class="s1">options.includePrefix ?? false,</span><span class="s3">\n    </span><span class="s1">options.backreferenceDuplicateKeys ?? false</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">let namedRegex = result.namedParameterizedRoute</span><span class="s3">\n  </span><span class="s1">if (!options.excludeOptionalTrailingSlash) {</span><span class="s3">\n    </span><span class="s1">namedRegex += '(?:/)?'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">...getRouteRegex(normalizedRoute, options),</span><span class="s3">\n    </span><span class="s1">namedRegex: `^${namedRegex}$`,</span><span class="s3">\n    </span><span class="s1">routeKeys: result.routeKeys,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Generates a named regexp.</span><span class="s3">\n </span><span class="s1">* This is intended to be using for build time only.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getNamedMiddlewareRegex(</span><span class="s3">\n  </span><span class="s1">normalizedRoute: string,</span><span class="s3">\n  </span><span class="s1">options: {</span><span class="s3">\n    </span><span class="s1">catchAll?: boolean</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const { parameterizedRoute } = getParametrizedRoute(</span><span class="s3">\n    </span><span class="s1">normalizedRoute,</span><span class="s3">\n    </span><span class="s1">false,</span><span class="s3">\n    </span><span class="s1">false</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">const { catchAll = true } = options</span><span class="s3">\n  </span><span class="s1">if (parameterizedRoute === '/') {</span><span class="s3">\n    </span><span class="s1">let catchAllRegex = catchAll ? '.*' : ''</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">namedRegex: `^/${catchAllRegex}$`,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { namedParameterizedRoute } = getNamedParametrizedRoute(</span><span class="s3">\n    </span><span class="s1">normalizedRoute,</span><span class="s3">\n    </span><span class="s1">false,</span><span class="s3">\n    </span><span class="s1">false,</span><span class="s3">\n    </span><span class="s1">false,</span><span class="s3">\n    </span><span class="s1">false</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">let catchAllGroupedRegex = catchAll ? '(?:(/.*)?)' : ''</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">namedRegex: `^${namedParameterizedRoute}${catchAllGroupedRegex}$`,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;getNamedMiddlewareRegex&quot;</span><span class="s0">,</span><span class="s1">&quot;getNamedRouteRegex&quot;</span><span class="s0">,</span><span class="s1">&quot;getRouteRegex&quot;</span><span class="s0">,</span><span class="s1">&quot;getParametrizedRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;route&quot;</span><span class="s0">,</span><span class="s1">&quot;includeSuffix&quot;</span><span class="s0">,</span><span class="s1">&quot;includePrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;groups&quot;</span><span class="s0">,</span><span class="s1">&quot;groupIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;segments&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;removeTrailingSlash&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;markerMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;INTERCEPTION_ROUTE_MARKERS&quot;</span><span class="s0">,</span><span class="s1">&quot;find&quot;</span><span class="s0">,</span><span class="s1">&quot;m&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;paramMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;match&quot;</span><span class="s0">,</span><span class="s1">&quot;PARAMETER_PATTERN&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;optional&quot;</span><span class="s0">,</span><span class="s1">&quot;repeat&quot;</span><span class="s0">,</span><span class="s1">&quot;parseMatchedParameter&quot;</span><span class="s0">,</span><span class="s1">&quot;pos&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;escapeStringRegexp&quot;</span><span class="s0">,</span><span class="s1">&quot;s&quot;</span><span class="s0">,</span><span class="s1">&quot;substring&quot;</span><span class="s0">,</span><span class="s1">&quot;parameterizedRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;excludeOptionalTrailingSlash&quot;</span><span class="s0">,</span><span class="s1">&quot;re&quot;</span><span class="s0">,</span><span class="s1">&quot;RegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;buildGetSafeRouteKey&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;routeKey&quot;</span><span class="s0">,</span><span class="s1">&quot;j&quot;</span><span class="s0">,</span><span class="s1">&quot;String&quot;</span><span class="s0">,</span><span class="s1">&quot;fromCharCode&quot;</span><span class="s0">,</span><span class="s1">&quot;Math&quot;</span><span class="s0">,</span><span class="s1">&quot;floor&quot;</span><span class="s0">,</span><span class="s1">&quot;getSafeKeyFromSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;interceptionMarker&quot;</span><span class="s0">,</span><span class="s1">&quot;getSafeRouteKey&quot;</span><span class="s0">,</span><span class="s1">&quot;routeKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;keyPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;backreferenceDuplicateKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;cleanedKey&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;invalidKey&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;isNaN&quot;</span><span class="s0">,</span><span class="s1">&quot;parseInt&quot;</span><span class="s0">,</span><span class="s1">&quot;duplicateKey&quot;</span><span class="s0">,</span><span class="s1">&quot;interceptionPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;pattern&quot;</span><span class="s0">,</span><span class="s1">&quot;getNamedParametrizedRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;prefixRouteKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;hasInterceptionMarker&quot;</span><span class="s0">,</span><span class="s1">&quot;some&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_INTERCEPTION_MARKER_PREFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_QUERY_PARAM_PREFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;namedParameterizedRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;options&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;namedRegex&quot;</span><span class="s0">,</span><span class="s1">&quot;catchAll&quot;</span><span class="s0">,</span><span class="s1">&quot;catchAllRegex&quot;</span><span class="s0">,</span><span class="s1">&quot;catchAllGroupedRegex&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;;IAiWgBA,uBAAuB;eAAvBA;;IA5BAC,kBAAkB;eAAlBA;;IA7LAC,aAAa;eAAbA;;;2BArIT;oCACoC;8BACR;qCACC;iCACqB;AAyEzD,SAASC,qBACPC,KAAa,EACbC,aAAsB,EACtBC,aAAsB;IAEtB,MAAMC,SAAyC,CAAC;IAChD,IAAIC,aAAa;IAEjB,MAAMC,WAAqB,EAAE;IAC7B,KAAK,MAAMC,WAAWC,IAAAA,wCAAmB,EAACP,OAAOQ,KAAK,CAAC,GAAGC,KAAK,CAAC,KAAM;QACpE,MAAMC,cAAcC,8CAA0B,CAACC,IAAI,CAAC,CAACC,IACnDP,QAAQQ,UAAU,CAACD;QAErB,MAAME,eAAeT,QAAQU,KAAK,CAACC,kCAAiB,EAAE,uBAAuB;;QAE7E,IAAIP,eAAeK,gBAAgBA,YAAY,CAAC,EAAE,EAAE;YAClD,MAAM,EAAEG,GAAG,EAAEC,QAAQ,EAAEC,MAAM,EAAE,GAAGC,IAAAA,sCAAqB,EAACN,YAAY,CAAC,EAAE;YACvEZ,MAAM,CAACe,IAAI,GAAG;gBAAEI,KAAKlB;gBAAcgB;gBAAQD;YAAS;YACpDd,SAASkB,IAAI,CAAC,AAAC,MAAGC,IAAAA,gCAAkB,EAACd,eAAa;QACpD,OAAO,IAAIK,gBAAgBA,YAAY,CAAC,EAAE,EAAE;YAC1C,MAAM,EAAEG,GAAG,EAAEE,MAAM,EAAED,QAAQ,EAAE,GAAGE,IAAAA,sCAAqB,EAACN,YAAY,CAAC,EAAE;YACvEZ,MAAM,CAACe,IAAI,GAAG;gBAAEI,KAAKlB;gBAAcgB;gBAAQD;YAAS;YAEpD,IAAIjB,iBAAiBa,YAAY,CAAC,EAAE,EAAE;gBACpCV,SAASkB,IAAI,CAAC,AAAC,MAAGC,IAAAA,gCAAkB,EAACT,YAAY,CAAC,EAAE;YACtD;YAEA,IAAIU,IAAIL,SAAUD,WAAW,gBAAgB,WAAY;YAEzD,8DAA8D;YAC9D,IAAIjB,iBAAiBa,YAAY,CAAC,EAAE,EAAE;gBACpCU,IAAIA,EAAEC,SAAS,CAAC;YAClB;YAEArB,SAASkB,IAAI,CAACE;QAChB,OAAO;YACLpB,SAASkB,IAAI,CAAC,AAAC,MAAGC,IAAAA,gCAAkB,EAAClB;QACvC;QAEA,+DAA+D;QAC/D,IAAIL,iBAAiBc,gBAAgBA,YAAY,CAAC,EAAE,EAAE;YACpDV,SAASkB,IAAI,CAACC,IAAAA,gCAAkB,EAACT,YAAY,CAAC,EAAE;QAClD;IACF;IAEA,OAAO;QACLY,oBAAoBtB,SAASuB,IAAI,CAAC;QAClCzB;IACF;AACF;AAOO,SAASL,cACd+B,eAAuB,EACvB;IAAA,IAAA,EACE5B,gBAAgB,KAAK,EACrBC,gBAAgB,KAAK,EACrB4B,+BAA+B,KAAK,EACf,GAJvB,mBAI0B,CAAC,IAJ3B;IAMA,MAAM,EAAEH,kBAAkB,EAAExB,MAAM,EAAE,GAAGJ,qBACrC8B,iBACA5B,eACAC;IAGF,IAAI6B,KAAKJ;IACT,IAAI,CAACG,8BAA8B;QACjCC,MAAM;IACR;IAEA,OAAO;QACLA,IAAI,IAAIC,OAAO,AAAC,MAAGD,KAAG;QACtB5B,QAAQA;IACV;AACF;AAEA;;;CAGC,GACD,SAAS8B;IACP,IAAIC,IAAI;IAER,OAAO;QACL,IAAIC,WAAW;QACf,IAAIC,IAAI,EAAEF;QACV,MAAOE,IAAI,EAAG;YACZD,YAAYE,OAAOC,YAAY,CAAC,KAAM,AAACF,CAAAA,IAAI,CAAA,IAAK;YAChDA,IAAIG,KAAKC,KAAK,CAAC,AAACJ,CAAAA,IAAI,CAAA,IAAK;QAC3B;QACA,OAAOD;IACT;AACF;AAEA,SAASM,sBAAsB,KAc9B;IAd8B,IAAA,EAC7BC,kBAAkB,EAClBC,eAAe,EACfrC,OAAO,EACPsC,SAAS,EACTC,SAAS,EACTC,0BAA0B,EAQ3B,GAd8B;IAe7B,MAAM,EAAE5B,GAAG,EAAEC,QAAQ,EAAEC,MAAM,EAAE,GAAGC,IAAAA,sCAAqB,EAACf;IAExD,uDAAuD;IACvD,kBAAkB;IAClB,IAAIyC,aAAa7B,IAAI8B,OAAO,CAAC,OAAO;IAEpC,IAAIH,WAAW;QACbE,aAAa,AAAC,KAAEF,YAAYE;IAC9B;IACA,IAAIE,aAAa;IAEjB,kEAAkE;IAClE,WAAW;IACX,IAAIF,WAAWG,MAAM,KAAK,KAAKH,WAAWG,MAAM,GAAG,IAAI;QACrDD,aAAa;IACf;IACA,IAAI,CAACE,MAAMC,SAASL,WAAWvC,KAAK,CAAC,GAAG,MAAM;QAC5CyC,aAAa;IACf;IAEA,IAAIA,YAAY;QACdF,aAAaJ;IACf;IAEA,MAAMU,eAAeN,cAAcH;IAEnC,IAAIC,WAAW;QACbD,SAAS,CAACG,WAAW,GAAG,AAAC,KAAEF,YAAY3B;IACzC,OAAO;QACL0B,SAAS,CAACG,WAAW,GAAG7B;IAC1B;IAEA,wFAAwF;IACxF,0FAA0F;IAC1F,qFAAqF;IACrF,MAAMoC,qBAAqBZ,qBACvBlB,IAAAA,gCAAkB,EAACkB,sBACnB;IAEJ,IAAIa;IACJ,IAAIF,gBAAgBP,4BAA4B;QAC9C,0EAA0E;QAC1E,+BAA+B;QAC/BS,UAAU,AAAC,SAAMR,aAAW;IAC9B,OAAO,IAAI3B,QAAQ;QACjBmC,UAAU,AAAC,QAAKR,aAAW;IAC7B,OAAO;QACLQ,UAAU,AAAC,QAAKR,aAAW;IAC7B;IAEA,OAAO5B,WACH,AAAC,SAAMmC,qBAAqBC,UAAQ,OACpC,AAAC,MAAGD,qBAAqBC;AAC/B;AAEA,SAASC,0BACPxD,KAAa,EACbyD,eAAwB,EACxBxD,aAAsB,EACtBC,aAAsB,EACtB4C,0BAAmC;IAEnC,MAAMH,kBAAkBV;IACxB,MAAMW,YAAyC,CAAC;IAEhD,MAAMvC,WAAqB,EAAE;IAC7B,KAAK,MAAMC,WAAWC,IAAAA,wCAAmB,EAACP,OAAOQ,KAAK,CAAC,GAAGC,KAAK,CAAC,KAAM;QACpE,MAAMiD,wBAAwB/C,8CAA0B,CAACgD,IAAI,CAAC,CAAC9C,IAC7DP,QAAQQ,UAAU,CAACD;QAGrB,MAAME,eAAeT,QAAQU,KAAK,CAACC,kCAAiB,EAAE,uBAAuB;;QAE7E,IAAIyC,yBAAyB3C,gBAAgBA,YAAY,CAAC,EAAE,EAAE;YAC5D,6DAA6D;YAC7DV,SAASkB,IAAI,CACXkB,sBAAsB;gBACpBE;gBACAD,oBAAoB3B,YAAY,CAAC,EAAE;gBACnCT,SAASS,YAAY,CAAC,EAAE;gBACxB6B;gBACAC,WAAWY,kBACPG,0CAA+B,GAC/BC;gBACJf;YACF;QAEJ,OAAO,IAAI/B,gBAAgBA,YAAY,CAAC,EAAE,EAAE;YAC1C,+DAA+D;YAC/D,IAAIb,iBAAiBa,YAAY,CAAC,EAAE,EAAE;gBACpCV,SAASkB,IAAI,CAAC,AAAC,MAAGC,IAAAA,gCAAkB,EAACT,YAAY,CAAC,EAAE;YACtD;YAEA,IAAIU,IAAIgB,sBAAsB;gBAC5BE;gBACArC,SAASS,YAAY,CAAC,EAAE;gBACxB6B;gBACAC,WAAWY,kBAAkBK,kCAAuB,GAAGD;gBACvDf;YACF;YAEA,8DAA8D;YAC9D,IAAI5C,iBAAiBa,YAAY,CAAC,EAAE,EAAE;gBACpCU,IAAIA,EAAEC,SAAS,CAAC;YAClB;YAEArB,SAASkB,IAAI,CAACE;QAChB,OAAO;YACLpB,SAASkB,IAAI,CAAC,AAAC,MAAGC,IAAAA,gCAAkB,EAAClB;QACvC;QAEA,+DAA+D;QAC/D,IAAIL,iBAAiBc,gBAAgBA,YAAY,CAAC,EAAE,EAAE;YACpDV,SAASkB,IAAI,CAACC,IAAAA,gCAAkB,EAACT,YAAY,CAAC,EAAE;QAClD;IACF;IAEA,OAAO;QACLgD,yBAAyB1D,SAASuB,IAAI,CAAC;QACvCgB;IACF;AACF;AAUO,SAAS/C,mBACdgC,eAAuB,EACvBmC,OAAkC;QAKhCA,wBACAA,wBACAA;IALF,MAAMC,SAAST,0BACb3B,iBACAmC,QAAQP,eAAe,EACvBO,CAAAA,yBAAAA,QAAQ/D,aAAa,YAArB+D,yBAAyB,OACzBA,CAAAA,yBAAAA,QAAQ9D,aAAa,YAArB8D,yBAAyB,OACzBA,CAAAA,sCAAAA,QAAQlB,0BAA0B,YAAlCkB,sCAAsC;IAGxC,IAAIE,aAAaD,OAAOF,uBAAuB;IAC/C,IAAI,CAACC,QAAQlC,4BAA4B,EAAE;QACzCoC,cAAc;IAChB;IAEA,OAAO;QACL,GAAGpE,cAAc+B,iBAAiBmC,QAAQ;QAC1CE,YAAY,AAAC,MAAGA,aAAW;QAC3BtB,WAAWqB,OAAOrB,SAAS;IAC7B;AACF;AAMO,SAAShD,wBACdiC,eAAuB,EACvBmC,OAEC;IAED,MAAM,EAAErC,kBAAkB,EAAE,GAAG5B,qBAC7B8B,iBACA,OACA;IAEF,MAAM,EAAEsC,WAAW,IAAI,EAAE,GAAGH;IAC5B,IAAIrC,uBAAuB,KAAK;QAC9B,IAAIyC,gBAAgBD,WAAW,OAAO;QACtC,OAAO;YACLD,YAAY,AAAC,OAAIE,gBAAc;QACjC;IACF;IAEA,MAAM,EAAEL,uBAAuB,EAAE,GAAGP,0BAClC3B,iBACA,OACA,OACA,OACA;IAEF,IAAIwC,uBAAuBF,WAAW,eAAe;IACrD,OAAO;QACLD,YAAY,AAAC,MAAGH,0BAA0BM,uBAAqB;IACjE;AACF&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>