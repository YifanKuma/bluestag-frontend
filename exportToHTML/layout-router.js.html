<html>
<head>
<title>layout-router.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
layout-router.js</font>
</center></td></tr></table>
<pre><span class="s0">'use client'</span><span class="s1">;</span>
<span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s3">/**</span>
 <span class="s3">* OuterLayoutRouter handles the current segment as well as &lt;Offscreen&gt; rendering of other segments.</span>
 <span class="s3">* It can be rendered next to each other with a different `parallelRouterKey`, allowing for Parallel routes.</span>
 <span class="s3">*/ </span><span class="s0">&quot;default&quot;</span><span class="s1">, {</span>
    <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
    <span class="s1">get: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">OuterLayoutRouter;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_interop_require_default = require(</span><span class="s0">&quot;@swc/helpers/_/_interop_require_default&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_interop_require_wildcard = require(</span><span class="s0">&quot;@swc/helpers/_/_interop_require_wildcard&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_jsxruntime = require(</span><span class="s0">&quot;react/jsx-runtime&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_routerreducertypes = require(</span><span class="s0">&quot;./router-reducer/router-reducer-types&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_react = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">_interop_require_wildcard._(require(</span><span class="s0">&quot;react&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_reactdom = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">_interop_require_default._(require(</span><span class="s0">&quot;react-dom&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_approutercontextsharedruntime = require(</span><span class="s0">&quot;../../shared/lib/app-router-context.shared-runtime&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_fetchserverresponse = require(</span><span class="s0">&quot;./router-reducer/fetch-server-response&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_unresolvedthenable = require(</span><span class="s0">&quot;./unresolved-thenable&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_errorboundary = require(</span><span class="s0">&quot;./error-boundary&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_matchsegments = require(</span><span class="s0">&quot;./match-segments&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_disablesmoothscroll = require(</span><span class="s0">&quot;../../shared/lib/router/utils/disable-smooth-scroll&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_redirectboundary = require(</span><span class="s0">&quot;./redirect-boundary&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_errorboundary1 = require(</span><span class="s0">&quot;./http-access-fallback/error-boundary&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_createroutercachekey = require(</span><span class="s0">&quot;./router-reducer/create-router-cache-key&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_hasinterceptionrouteincurrenttree = require(</span><span class="s0">&quot;./router-reducer/reducers/has-interception-route-in-current-tree&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_useactionqueue = require(</span><span class="s0">&quot;./use-action-queue&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_bfcache = require(</span><span class="s0">&quot;./bfcache&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_apppaths = require(</span><span class="s0">&quot;../../shared/lib/router/utils/app-paths&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">Activity = process.env.__NEXT_ROUTER_BF_CACHE ? require(</span><span class="s0">'react'</span><span class="s1">).unstable_Activity : </span><span class="s2">null</span><span class="s1">;</span>
<span class="s3">/**</span>
 <span class="s3">* Add refetch marker to router state at the point of the current layout segment.</span>
 <span class="s3">* This ensures the response returned is not further down than the current layout segment.</span>
 <span class="s3">*/ </span><span class="s2">function </span><span class="s1">walkAddRefetch(segmentPathToWalk, treeToRecreate) {</span>
    <span class="s2">if </span><span class="s1">(segmentPathToWalk) {</span>
        <span class="s2">const </span><span class="s1">[segment, parallelRouteKey] = segmentPathToWalk;</span>
        <span class="s2">const </span><span class="s1">isLast = segmentPathToWalk.length === </span><span class="s4">2</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _matchsegments.matchSegment)(treeToRecreate[</span><span class="s4">0</span><span class="s1">], segment)) {</span>
            <span class="s2">if </span><span class="s1">(treeToRecreate[</span><span class="s4">1</span><span class="s1">].hasOwnProperty(parallelRouteKey)) {</span>
                <span class="s2">if </span><span class="s1">(isLast) {</span>
                    <span class="s2">const </span><span class="s1">subTree = walkAddRefetch(undefined, treeToRecreate[</span><span class="s4">1</span><span class="s1">][parallelRouteKey]);</span>
                    <span class="s2">return </span><span class="s1">[</span>
                        <span class="s1">treeToRecreate[</span><span class="s4">0</span><span class="s1">],</span>
                        <span class="s1">{</span>
                            <span class="s1">...treeToRecreate[</span><span class="s4">1</span><span class="s1">],</span>
                            <span class="s1">[parallelRouteKey]: [</span>
                                <span class="s1">subTree[</span><span class="s4">0</span><span class="s1">],</span>
                                <span class="s1">subTree[</span><span class="s4">1</span><span class="s1">],</span>
                                <span class="s1">subTree[</span><span class="s4">2</span><span class="s1">],</span>
                                <span class="s0">'refetch'</span>
                            <span class="s1">]</span>
                        <span class="s1">}</span>
                    <span class="s1">];</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">[</span>
                    <span class="s1">treeToRecreate[</span><span class="s4">0</span><span class="s1">],</span>
                    <span class="s1">{</span>
                        <span class="s1">...treeToRecreate[</span><span class="s4">1</span><span class="s1">],</span>
                        <span class="s1">[parallelRouteKey]: walkAddRefetch(segmentPathToWalk.slice(</span><span class="s4">2</span><span class="s1">), treeToRecreate[</span><span class="s4">1</span><span class="s1">][parallelRouteKey])</span>
                    <span class="s1">}</span>
                <span class="s1">];</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">treeToRecreate;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = _reactdom.default.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;</span>
<span class="s3">// TODO-APP: Replace with new React API for finding dom nodes without a `ref` when available</span>
<span class="s3">/**</span>
 <span class="s3">* Wraps ReactDOM.findDOMNode with additional logic to hide React Strict Mode warning</span>
 <span class="s3">*/ </span><span class="s2">function </span><span class="s1">findDOMNode(instance) {</span>
    <span class="s3">// Tree-shake for server bundle</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">window === </span><span class="s0">'undefined'</span><span class="s1">) </span><span class="s2">return null</span><span class="s1">;</span>
    <span class="s3">// __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.findDOMNode is null during module init.</span>
    <span class="s3">// We need to lazily reference it.</span>
    <span class="s2">const </span><span class="s1">internal_reactDOMfindDOMNode = __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.findDOMNode;</span>
    <span class="s2">return </span><span class="s1">internal_reactDOMfindDOMNode(instance);</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">rectProperties = [</span>
    <span class="s0">'bottom'</span><span class="s1">,</span>
    <span class="s0">'height'</span><span class="s1">,</span>
    <span class="s0">'left'</span><span class="s1">,</span>
    <span class="s0">'right'</span><span class="s1">,</span>
    <span class="s0">'top'</span><span class="s1">,</span>
    <span class="s0">'width'</span><span class="s1">,</span>
    <span class="s0">'x'</span><span class="s1">,</span>
    <span class="s0">'y'</span>
<span class="s1">];</span>
<span class="s3">/**</span>
 <span class="s3">* Check if a HTMLElement is hidden or fixed/sticky position</span>
 <span class="s3">*/ </span><span class="s2">function </span><span class="s1">shouldSkipElement(element) {</span>
    <span class="s3">// we ignore fixed or sticky positioned elements since they'll likely pass the &quot;in-viewport&quot; check</span>
    <span class="s3">// and will result in a situation we bail on scroll because of something like a fixed nav,</span>
    <span class="s3">// even though the actual page content is offscreen</span>
    <span class="s2">if </span><span class="s1">([</span>
        <span class="s0">'sticky'</span><span class="s1">,</span>
        <span class="s0">'fixed'</span>
    <span class="s1">].includes(getComputedStyle(element).position)) {</span>
        <span class="s2">if </span><span class="s1">(process.env.NODE_ENV === </span><span class="s0">'development'</span><span class="s1">) {</span>
            <span class="s1">console.warn(</span><span class="s0">'Skipping auto-scroll behavior due to `position: sticky` or `position: fixed` on element:'</span><span class="s1">, element);</span>
        <span class="s1">}</span>
        <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">// Uses `getBoundingClientRect` to check if the element is hidden instead of `offsetParent`</span>
    <span class="s3">// because `offsetParent` doesn't consider document/body</span>
    <span class="s2">const </span><span class="s1">rect = element.getBoundingClientRect();</span>
    <span class="s2">return </span><span class="s1">rectProperties.every((item)=&gt;rect[item] === </span><span class="s4">0</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Check if the top corner of the HTMLElement is in the viewport.</span>
 <span class="s3">*/ </span><span class="s2">function </span><span class="s1">topOfElementInViewport(element, viewportHeight) {</span>
    <span class="s2">const </span><span class="s1">rect = element.getBoundingClientRect();</span>
    <span class="s2">return </span><span class="s1">rect.top &gt;= </span><span class="s4">0 </span><span class="s1">&amp;&amp; rect.top &lt;= viewportHeight;</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Find the DOM node for a hash fragment.</span>
 <span class="s3">* If `top` the page has to scroll to the top of the page. This mirrors the browser's behavior.</span>
 <span class="s3">* If the hash fragment is an id, the page has to scroll to the element with that id.</span>
 <span class="s3">* If the hash fragment is a name, the page has to scroll to the first element with that name.</span>
 <span class="s3">*/ </span><span class="s2">function </span><span class="s1">getHashFragmentDomNode(hashFragment) {</span>
    <span class="s3">// If the hash fragment is `top` the page has to scroll to the top of the page.</span>
    <span class="s2">if </span><span class="s1">(hashFragment === </span><span class="s0">'top'</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">document.body;</span>
    <span class="s1">}</span>
    <span class="s2">var </span><span class="s1">_document_getElementById;</span>
    <span class="s3">// If the hash fragment is an id, the page has to scroll to the element with that id.</span>
    <span class="s2">return </span><span class="s1">(_document_getElementById = document.getElementById(hashFragment)) != </span><span class="s2">null </span><span class="s1">? _document_getElementById : </span><span class="s3">// If the hash fragment is a name, the page has to scroll to the first element with that name.</span>
    <span class="s1">document.getElementsByName(hashFragment)[</span><span class="s4">0</span><span class="s1">];</span>
<span class="s1">}</span>
<span class="s2">class </span><span class="s1">InnerScrollAndFocusHandler </span><span class="s2">extends </span><span class="s1">_react.default.Component {</span>
    <span class="s1">componentDidMount() {</span>
        <span class="s2">this</span><span class="s1">.handlePotentialScroll();</span>
    <span class="s1">}</span>
    <span class="s1">componentDidUpdate() {</span>
        <span class="s3">// Because this property is overwritten in handlePotentialScroll it's fine to always run it when true as it'll be set to false for subsequent renders.</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.props.focusAndScrollRef.apply) {</span>
            <span class="s2">this</span><span class="s1">.handlePotentialScroll();</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">render() {</span>
        <span class="s2">return this</span><span class="s1">.props.children;</span>
    <span class="s1">}</span>
    <span class="s1">constructor(...args){</span>
        <span class="s2">super</span><span class="s1">(...args), </span><span class="s2">this</span><span class="s1">.handlePotentialScroll = ()=&gt;{</span>
            <span class="s3">// Handle scroll and focus, it's only applied once in the first useEffect that triggers that changed.</span>
            <span class="s2">const </span><span class="s1">{ focusAndScrollRef, segmentPath } = </span><span class="s2">this</span><span class="s1">.props;</span>
            <span class="s2">if </span><span class="s1">(focusAndScrollRef.apply) {</span>
                <span class="s3">// segmentPaths is an array of segment paths that should be scrolled to</span>
                <span class="s3">// if the current segment path is not in the array, the scroll is not applied</span>
                <span class="s3">// unless the array is empty, in which case the scroll is always applied</span>
                <span class="s2">if </span><span class="s1">(focusAndScrollRef.segmentPaths.length !== </span><span class="s4">0 </span><span class="s1">&amp;&amp; !focusAndScrollRef.segmentPaths.some((scrollRefSegmentPath)=&gt;segmentPath.every((segment, index)=&gt;(</span><span class="s4">0</span><span class="s1">, _matchsegments.matchSegment)(segment, scrollRefSegmentPath[index])))) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">let </span><span class="s1">domNode = </span><span class="s2">null</span><span class="s1">;</span>
                <span class="s2">const </span><span class="s1">hashFragment = focusAndScrollRef.hashFragment;</span>
                <span class="s2">if </span><span class="s1">(hashFragment) {</span>
                    <span class="s1">domNode = getHashFragmentDomNode(hashFragment);</span>
                <span class="s1">}</span>
                <span class="s3">// `findDOMNode` is tricky because it returns just the first child if the component is a fragment.</span>
                <span class="s3">// This already caused a bug where the first child was a &lt;link/&gt; in head.</span>
                <span class="s2">if </span><span class="s1">(!domNode) {</span>
                    <span class="s1">domNode = findDOMNode(</span><span class="s2">this</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s3">// If there is no DOM node this layout-router level is skipped. It'll be handled higher-up in the tree.</span>
                <span class="s2">if </span><span class="s1">(!(domNode </span><span class="s2">instanceof </span><span class="s1">Element)) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">// Verify if the element is a HTMLElement and if we want to consider it for scroll behavior.</span>
                <span class="s3">// If the element is skipped, try to select the next sibling and try again.</span>
                <span class="s2">while</span><span class="s1">(!(domNode </span><span class="s2">instanceof </span><span class="s1">HTMLElement) || shouldSkipElement(domNode)){</span>
                    <span class="s2">if </span><span class="s1">(process.env.NODE_ENV !== </span><span class="s0">'production'</span><span class="s1">) {</span>
                        <span class="s2">var </span><span class="s1">_domNode_parentElement;</span>
                        <span class="s2">if </span><span class="s1">(((_domNode_parentElement = domNode.parentElement) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _domNode_parentElement.localName) === </span><span class="s0">'head'</span><span class="s1">) {</span>
                        <span class="s3">// TODO: We enter this state when metadata was rendered as part of the page or via Next.js.</span>
                        <span class="s3">// This is always a bug in Next.js and caused by React hoisting metadata.</span>
                        <span class="s3">// We need to replace `findDOMNode` in favor of Fragment Refs (when available) so that we can skip over metadata.</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s3">// No siblings found that match the criteria are found, so handle scroll higher up in the tree instead.</span>
                    <span class="s2">if </span><span class="s1">(domNode.nextElementSibling === </span><span class="s2">null</span><span class="s1">) {</span>
                        <span class="s2">return</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s1">domNode = domNode.nextElementSibling;</span>
                <span class="s1">}</span>
                <span class="s3">// State is mutated to ensure that the focus and scroll is applied only once.</span>
                <span class="s1">focusAndScrollRef.apply = </span><span class="s2">false</span><span class="s1">;</span>
                <span class="s1">focusAndScrollRef.hashFragment = </span><span class="s2">null</span><span class="s1">;</span>
                <span class="s1">focusAndScrollRef.segmentPaths = [];</span>
                <span class="s1">(</span><span class="s4">0</span><span class="s1">, _disablesmoothscroll.disableSmoothScrollDuringRouteTransition)(()=&gt;{</span>
                    <span class="s3">// In case of hash scroll, we only need to scroll the element into view</span>
                    <span class="s2">if </span><span class="s1">(hashFragment) {</span>
                        <span class="s1">;</span>
                        <span class="s1">domNode.scrollIntoView();</span>
                        <span class="s2">return</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s3">// Store the current viewport height because reading `clientHeight` causes a reflow,</span>
                    <span class="s3">// and it won't change during this function.</span>
                    <span class="s2">const </span><span class="s1">htmlElement = document.documentElement;</span>
                    <span class="s2">const </span><span class="s1">viewportHeight = htmlElement.clientHeight;</span>
                    <span class="s3">// If the element's top edge is already in the viewport, exit early.</span>
                    <span class="s2">if </span><span class="s1">(topOfElementInViewport(domNode, viewportHeight)) {</span>
                        <span class="s2">return</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s3">// Otherwise, try scrolling go the top of the document to be backward compatible with pages</span>
                    <span class="s3">// scrollIntoView() called on `&lt;html/&gt;` element scrolls horizontally on chrome and firefox (that shouldn't happen)</span>
                    <span class="s3">// We could use it to scroll horizontally following RTL but that also seems to be broken - it will always scroll left</span>
                    <span class="s3">// scrollLeft = 0 also seems to ignore RTL and manually checking for RTL is too much hassle so we will scroll just vertically</span>
                    <span class="s1">htmlElement.scrollTop = </span><span class="s4">0</span><span class="s1">;</span>
                    <span class="s3">// Scroll to domNode if domNode is not in viewport when scrolled to top of document</span>
                    <span class="s2">if </span><span class="s1">(!topOfElementInViewport(domNode, viewportHeight)) {</span>
                        <span class="s3">// Scroll into view doesn't scroll horizontally by default when not needed</span>
                        <span class="s1">;</span>
                        <span class="s1">domNode.scrollIntoView();</span>
                    <span class="s1">}</span>
                <span class="s1">}, {</span>
                    <span class="s3">// We will force layout by querying domNode position</span>
                    <span class="s1">dontForceLayout: </span><span class="s2">true</span><span class="s1">,</span>
                    <span class="s1">onlyHashChange: focusAndScrollRef.onlyHashChange</span>
                <span class="s1">});</span>
                <span class="s3">// Mutate after scrolling so that it can be read by `disableSmoothScrollDuringRouteTransition`</span>
                <span class="s1">focusAndScrollRef.onlyHashChange = </span><span class="s2">false</span><span class="s1">;</span>
                <span class="s3">// Set focus on the element</span>
                <span class="s1">domNode.focus();</span>
            <span class="s1">}</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">ScrollAndFocusHandler(param) {</span>
    <span class="s2">let </span><span class="s1">{ segmentPath, children } = param;</span>
    <span class="s2">const </span><span class="s1">context = (</span><span class="s4">0</span><span class="s1">, _react.useContext)(_approutercontextsharedruntime.GlobalLayoutRouterContext);</span>
    <span class="s2">if </span><span class="s1">(!context) {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'invariant global layout router not mounted'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E473&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(InnerScrollAndFocusHandler, {</span>
        <span class="s1">segmentPath: segmentPath,</span>
        <span class="s1">focusAndScrollRef: context.focusAndScrollRef,</span>
        <span class="s1">children: children</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* InnerLayoutRouter handles rendering the provided segment based on the cache.</span>
 <span class="s3">*/ </span><span class="s2">function </span><span class="s1">InnerLayoutRouter(param) {</span>
    <span class="s2">let </span><span class="s1">{ tree, segmentPath, cacheNode, url } = param;</span>
    <span class="s2">const </span><span class="s1">context = (</span><span class="s4">0</span><span class="s1">, _react.useContext)(_approutercontextsharedruntime.GlobalLayoutRouterContext);</span>
    <span class="s2">if </span><span class="s1">(!context) {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'invariant global layout router not mounted'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E473&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">{ tree: fullTree } = context;</span>
    <span class="s3">// `rsc` represents the renderable node for this segment.</span>
    <span class="s3">// If this segment has a `prefetchRsc`, it's the statically prefetched data.</span>
    <span class="s3">// We should use that on initial render instead of `rsc`. Then we'll switch</span>
    <span class="s3">// to `rsc` when the dynamic response streams in.</span>
    <span class="s3">//</span>
    <span class="s3">// If no prefetch data is available, then we go straight to rendering `rsc`.</span>
    <span class="s2">const </span><span class="s1">resolvedPrefetchRsc = cacheNode.prefetchRsc !== </span><span class="s2">null </span><span class="s1">? cacheNode.prefetchRsc : cacheNode.rsc;</span>
    <span class="s3">// We use `useDeferredValue` to handle switching between the prefetched and</span>
    <span class="s3">// final values. The second argument is returned on initial render, then it</span>
    <span class="s3">// re-renders with the first argument.</span>
    <span class="s2">const </span><span class="s1">rsc = (</span><span class="s4">0</span><span class="s1">, _react.useDeferredValue)(cacheNode.rsc, resolvedPrefetchRsc);</span>
    <span class="s3">// `rsc` is either a React node or a promise for a React node, except we</span>
    <span class="s3">// special case `null` to represent that this segment's data is missing. If</span>
    <span class="s3">// it's a promise, we need to unwrap it so we can determine whether or not the</span>
    <span class="s3">// data is missing.</span>
    <span class="s2">const </span><span class="s1">resolvedRsc = </span><span class="s2">typeof </span><span class="s1">rsc === </span><span class="s0">'object' </span><span class="s1">&amp;&amp; rsc !== </span><span class="s2">null </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">rsc.then === </span><span class="s0">'function' </span><span class="s1">? (</span><span class="s4">0</span><span class="s1">, _react.use)(rsc) : rsc;</span>
    <span class="s2">if </span><span class="s1">(!resolvedRsc) {</span>
        <span class="s3">// The data for this segment is not available, and there's no pending</span>
        <span class="s3">// navigation that will be able to fulfill it. We need to fetch more from</span>
        <span class="s3">// the server and patch the cache.</span>
        <span class="s3">// Check if there's already a pending request.</span>
        <span class="s2">let </span><span class="s1">lazyData = cacheNode.lazyData;</span>
        <span class="s2">if </span><span class="s1">(lazyData === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s3">/**</span>
       <span class="s3">* Router state with refetch marker added</span>
       <span class="s3">*/ // TODO-APP: remove ''</span>
            <span class="s2">const </span><span class="s1">refetchTree = walkAddRefetch([</span>
                <span class="s0">''</span><span class="s1">,</span>
                <span class="s1">...segmentPath</span>
            <span class="s1">], fullTree);</span>
            <span class="s2">const </span><span class="s1">includeNextUrl = (</span><span class="s4">0</span><span class="s1">, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(fullTree);</span>
            <span class="s2">const </span><span class="s1">navigatedAt = Date.now();</span>
            <span class="s1">cacheNode.lazyData = lazyData = (</span><span class="s4">0</span><span class="s1">, _fetchserverresponse.fetchServerResponse)(</span><span class="s2">new </span><span class="s1">URL(url, location.origin), {</span>
                <span class="s1">flightRouterState: refetchTree,</span>
                <span class="s1">nextUrl: includeNextUrl ? context.nextUrl : </span><span class="s2">null</span>
            <span class="s1">}).then((serverResponse)=&gt;{</span>
                <span class="s1">(</span><span class="s4">0</span><span class="s1">, _react.startTransition)(()=&gt;{</span>
                    <span class="s1">(</span><span class="s4">0</span><span class="s1">, _useactionqueue.dispatchAppRouterAction)({</span>
                        <span class="s1">type: _routerreducertypes.ACTION_SERVER_PATCH,</span>
                        <span class="s1">previousTree: fullTree,</span>
                        <span class="s1">serverResponse,</span>
                        <span class="s1">navigatedAt</span>
                    <span class="s1">});</span>
                <span class="s1">});</span>
                <span class="s2">return </span><span class="s1">serverResponse;</span>
            <span class="s1">});</span>
            <span class="s3">// Suspend while waiting for lazyData to resolve</span>
            <span class="s1">(</span><span class="s4">0</span><span class="s1">, _react.use)(lazyData);</span>
        <span class="s1">}</span>
        <span class="s3">// Suspend infinitely as `changeByServerResponse` will cause a different part of the tree to be rendered.</span>
        <span class="s3">// A falsey `resolvedRsc` indicates missing data -- we should not commit that branch, and we need to wait for the data to arrive.</span>
        <span class="s1">(</span><span class="s4">0</span><span class="s1">, _react.use)(_unresolvedthenable.unresolvedThenable);</span>
    <span class="s1">}</span>
    <span class="s3">// If we get to this point, then we know we have something we can render.</span>
    <span class="s2">const </span><span class="s1">subtree = </span><span class="s3">// The layout router context narrows down tree and childNodes at each level.</span>
    <span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(_approutercontextsharedruntime.LayoutRouterContext.Provider, {</span>
        <span class="s1">value: {</span>
            <span class="s1">parentTree: tree,</span>
            <span class="s1">parentCacheNode: cacheNode,</span>
            <span class="s1">parentSegmentPath: segmentPath,</span>
            <span class="s3">// TODO-APP: overriding of url for parallel routes</span>
            <span class="s1">url: url</span>
        <span class="s1">},</span>
        <span class="s1">children: resolvedRsc</span>
    <span class="s1">});</span>
    <span class="s3">// Ensure root layout is not wrapped in a div as the root layout renders `&lt;html&gt;`</span>
    <span class="s2">return </span><span class="s1">subtree;</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Renders suspense boundary with the provided &quot;loading&quot; property as the fallback.</span>
 <span class="s3">* If no loading property is provided it renders the children without a suspense boundary.</span>
 <span class="s3">*/ </span><span class="s2">function </span><span class="s1">LoadingBoundary(param) {</span>
    <span class="s2">let </span><span class="s1">{ loading, children } = param;</span>
    <span class="s3">// If loading is a promise, unwrap it. This happens in cases where we haven't</span>
    <span class="s3">// yet received the loading data from the server — which includes whether or</span>
    <span class="s3">// not this layout has a loading component at all.</span>
    <span class="s3">//</span>
    <span class="s3">// It's OK to suspend here instead of inside the fallback because this</span>
    <span class="s3">// promise will resolve simultaneously with the data for the segment itself.</span>
    <span class="s3">// So it will never suspend for longer than it would have if we didn't use</span>
    <span class="s3">// a Suspense fallback at all.</span>
    <span class="s2">let </span><span class="s1">loadingModuleData;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">loading === </span><span class="s0">'object' </span><span class="s1">&amp;&amp; loading !== </span><span class="s2">null </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">loading.then === </span><span class="s0">'function'</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">promiseForLoading = loading;</span>
        <span class="s1">loadingModuleData = (</span><span class="s4">0</span><span class="s1">, _react.use)(promiseForLoading);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">loadingModuleData = loading;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(loadingModuleData) {</span>
        <span class="s2">const </span><span class="s1">loadingRsc = loadingModuleData[</span><span class="s4">0</span><span class="s1">];</span>
        <span class="s2">const </span><span class="s1">loadingStyles = loadingModuleData[</span><span class="s4">1</span><span class="s1">];</span>
        <span class="s2">const </span><span class="s1">loadingScripts = loadingModuleData[</span><span class="s4">2</span><span class="s1">];</span>
        <span class="s2">return </span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(_react.Suspense, {</span>
            <span class="s1">fallback: </span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsxs)(_jsxruntime.Fragment, {</span>
                <span class="s1">children: [</span>
                    <span class="s1">loadingStyles,</span>
                    <span class="s1">loadingScripts,</span>
                    <span class="s1">loadingRsc</span>
                <span class="s1">]</span>
            <span class="s1">}),</span>
            <span class="s1">children: children</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(_jsxruntime.Fragment, {</span>
        <span class="s1">children: children</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">OuterLayoutRouter(param) {</span>
    <span class="s2">let </span><span class="s1">{ parallelRouterKey, error, errorStyles, errorScripts, templateStyles, templateScripts, template, notFound, forbidden, unauthorized, segmentViewBoundaries } = param;</span>
    <span class="s2">const </span><span class="s1">context = (</span><span class="s4">0</span><span class="s1">, _react.useContext)(_approutercontextsharedruntime.LayoutRouterContext);</span>
    <span class="s2">if </span><span class="s1">(!context) {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'invariant expected layout router to be mounted'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E56&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">{ parentTree, parentCacheNode, parentSegmentPath, url } = context;</span>
    <span class="s3">// Get the CacheNode for this segment by reading it from the parent segment's</span>
    <span class="s3">// child map.</span>
    <span class="s2">const </span><span class="s1">parentParallelRoutes = parentCacheNode.parallelRoutes;</span>
    <span class="s2">let </span><span class="s1">segmentMap = parentParallelRoutes.get(parallelRouterKey);</span>
    <span class="s3">// If the parallel router cache node does not exist yet, create it.</span>
    <span class="s3">// This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.</span>
    <span class="s2">if </span><span class="s1">(!segmentMap) {</span>
        <span class="s1">segmentMap = </span><span class="s2">new </span><span class="s1">Map();</span>
        <span class="s1">parentParallelRoutes.set(parallelRouterKey, segmentMap);</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">parentTreeSegment = parentTree[</span><span class="s4">0</span><span class="s1">];</span>
    <span class="s2">const </span><span class="s1">segmentPath = parentSegmentPath === </span><span class="s2">null </span><span class="s1">? </span><span class="s3">// path. This has led to a bunch of special cases scattered throughout</span>
    <span class="s3">// the code. We should clean this up.</span>
    <span class="s1">[</span>
        <span class="s1">parallelRouterKey</span>
    <span class="s1">] : parentSegmentPath.concat([</span>
        <span class="s1">parentTreeSegment,</span>
        <span class="s1">parallelRouterKey</span>
    <span class="s1">]);</span>
    <span class="s3">// The &quot;state&quot; key of a segment is the one passed to React — it represents the</span>
    <span class="s3">// identity of the UI tree. Whenever the state key changes, the tree is</span>
    <span class="s3">// recreated and the state is reset. In the App Router model, search params do</span>
    <span class="s3">// not cause state to be lost, so two segments with the same segment path but</span>
    <span class="s3">// different search params should have the same state key.</span>
    <span class="s3">//</span>
    <span class="s3">// The &quot;cache&quot; key of a segment, however, *does* include the search params, if</span>
    <span class="s3">// it's possible that the segment accessed the search params on the server.</span>
    <span class="s3">// (This only applies to page segments; layout segments cannot access search</span>
    <span class="s3">// params on the server.)</span>
    <span class="s2">const </span><span class="s1">activeTree = parentTree[</span><span class="s4">1</span><span class="s1">][parallelRouterKey];</span>
    <span class="s2">const </span><span class="s1">activeSegment = activeTree[</span><span class="s4">0</span><span class="s1">];</span>
    <span class="s2">const </span><span class="s1">activeStateKey = (</span><span class="s4">0</span><span class="s1">, _createroutercachekey.createRouterCacheKey)(activeSegment, </span><span class="s2">true</span><span class="s1">) </span><span class="s3">// no search params</span>
    <span class="s1">;</span>
    <span class="s3">// At each level of the route tree, not only do we render the currently</span>
    <span class="s3">// active segment — we also render the last N segments that were active at</span>
    <span class="s3">// this level inside a hidden &lt;Activity&gt; boundary, to preserve their state</span>
    <span class="s3">// if or when the user navigates to them again.</span>
    <span class="s3">//</span>
    <span class="s3">// bfcacheEntry is a linked list of FlightRouterStates.</span>
    <span class="s2">let </span><span class="s1">bfcacheEntry = (</span><span class="s4">0</span><span class="s1">, _bfcache.useRouterBFCache)(activeTree, activeStateKey);</span>
    <span class="s2">let </span><span class="s1">children = [];</span>
    <span class="s2">do </span><span class="s1">{</span>
        <span class="s2">const </span><span class="s1">tree = bfcacheEntry.tree;</span>
        <span class="s2">const </span><span class="s1">stateKey = bfcacheEntry.stateKey;</span>
        <span class="s2">const </span><span class="s1">segment = tree[</span><span class="s4">0</span><span class="s1">];</span>
        <span class="s2">const </span><span class="s1">cacheKey = (</span><span class="s4">0</span><span class="s1">, _createroutercachekey.createRouterCacheKey)(segment);</span>
        <span class="s3">// Read segment path from the parallel router cache node.</span>
        <span class="s2">let </span><span class="s1">cacheNode = segmentMap.get(cacheKey);</span>
        <span class="s2">if </span><span class="s1">(cacheNode === undefined) {</span>
            <span class="s3">// When data is not available during rendering client-side we need to fetch</span>
            <span class="s3">// it from the server.</span>
            <span class="s2">const </span><span class="s1">newLazyCacheNode = {</span>
                <span class="s1">lazyData: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">rsc: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">prefetchRsc: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">head: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">prefetchHead: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">parallelRoutes: </span><span class="s2">new </span><span class="s1">Map(),</span>
                <span class="s1">loading: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">navigatedAt: -</span><span class="s4">1</span>
            <span class="s1">};</span>
            <span class="s3">// Flight data fetch kicked off during render and put into the cache.</span>
            <span class="s1">cacheNode = newLazyCacheNode;</span>
            <span class="s1">segmentMap.set(cacheKey, newLazyCacheNode);</span>
        <span class="s1">}</span>
        <span class="s3">/* 
    - Error boundary 
      - Only renders error boundary if error component is provided. 
      - Rendered for each segment to ensure they have their own error state. 
      - When gracefully degrade for bots, skip rendering error boundary. 
    - Loading boundary 
      - Only renders suspense boundary if loading components is provided. 
      - Rendered for each segment to ensure they have their own loading state. 
      - Passed to the router during rendering to ensure it can be immediately rendered when suspending on a Flight fetch. 
  */ </span><span class="s2">let </span><span class="s1">segmentBoundaryTriggerNode = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s2">let </span><span class="s1">segmentViewStateNode = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(process.env.NODE_ENV !== </span><span class="s0">'production' </span><span class="s1">&amp;&amp; process.env.__NEXT_DEVTOOL_SEGMENT_EXPLORER) {</span>
            <span class="s2">const </span><span class="s1">{ SegmentBoundaryTriggerNode, SegmentViewStateNode } = require(</span><span class="s0">'../../next-devtools/userspace/app/segment-explorer-node'</span><span class="s1">);</span>
            <span class="s2">const </span><span class="s1">pagePrefix = (</span><span class="s4">0</span><span class="s1">, _apppaths.normalizeAppPath)(url);</span>
            <span class="s1">segmentViewStateNode = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(SegmentViewStateNode, {</span>
                <span class="s1">page: pagePrefix</span>
            <span class="s1">}, pagePrefix);</span>
            <span class="s1">segmentBoundaryTriggerNode = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(_jsxruntime.Fragment, {</span>
                <span class="s1">children: </span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(SegmentBoundaryTriggerNode, {})</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s3">// TODO: The loading module data for a segment is stored on the parent, then</span>
        <span class="s3">// applied to each of that parent segment's parallel route slots. In the</span>
        <span class="s3">// simple case where there's only one parallel route (the `children` slot),</span>
        <span class="s3">// this is no different from if the loading module data where stored on the</span>
        <span class="s3">// child directly. But I'm not sure this actually makes sense when there are</span>
        <span class="s3">// multiple parallel routes. It's not a huge issue because you always have</span>
        <span class="s3">// the option to define a narrower loading boundary for a particular slot. But</span>
        <span class="s3">// this sort of smells like an implementation accident to me.</span>
        <span class="s2">const </span><span class="s1">loadingModuleData = parentCacheNode.loading;</span>
        <span class="s2">let </span><span class="s1">child = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsxs)(_approutercontextsharedruntime.TemplateContext.Provider, {</span>
            <span class="s1">value: </span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsxs)(ScrollAndFocusHandler, {</span>
                <span class="s1">segmentPath: segmentPath,</span>
                <span class="s1">children: [</span>
                    <span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(_errorboundary.ErrorBoundary, {</span>
                        <span class="s1">errorComponent: error,</span>
                        <span class="s1">errorStyles: errorStyles,</span>
                        <span class="s1">errorScripts: errorScripts,</span>
                        <span class="s1">children: </span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(LoadingBoundary, {</span>
                            <span class="s1">loading: loadingModuleData,</span>
                            <span class="s1">children: </span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(_errorboundary1.HTTPAccessFallbackBoundary, {</span>
                                <span class="s1">notFound: notFound,</span>
                                <span class="s1">forbidden: forbidden,</span>
                                <span class="s1">unauthorized: unauthorized,</span>
                                <span class="s1">children: </span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsxs)(_redirectboundary.RedirectBoundary, {</span>
                                    <span class="s1">children: [</span>
                                        <span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(InnerLayoutRouter, {</span>
                                            <span class="s1">url: url,</span>
                                            <span class="s1">tree: tree,</span>
                                            <span class="s1">cacheNode: cacheNode,</span>
                                            <span class="s1">segmentPath: segmentPath</span>
                                        <span class="s1">}),</span>
                                        <span class="s1">segmentBoundaryTriggerNode</span>
                                    <span class="s1">]</span>
                                <span class="s1">})</span>
                            <span class="s1">})</span>
                        <span class="s1">})</span>
                    <span class="s1">}),</span>
                    <span class="s1">segmentViewStateNode</span>
                <span class="s1">]</span>
            <span class="s1">}),</span>
            <span class="s1">children: [</span>
                <span class="s1">templateStyles,</span>
                <span class="s1">templateScripts,</span>
                <span class="s1">template</span>
            <span class="s1">]</span>
        <span class="s1">}, stateKey);</span>
        <span class="s2">if </span><span class="s1">(process.env.NODE_ENV !== </span><span class="s0">'production'</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">{ SegmentStateProvider } = require(</span><span class="s0">'../../next-devtools/userspace/app/segment-explorer-node'</span><span class="s1">);</span>
            <span class="s1">child = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsxs)(SegmentStateProvider, {</span>
                <span class="s1">children: [</span>
                    <span class="s1">child,</span>
                    <span class="s1">segmentViewBoundaries</span>
                <span class="s1">]</span>
            <span class="s1">}, stateKey);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(process.env.__NEXT_ROUTER_BF_CACHE) {</span>
            <span class="s1">child = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _jsxruntime.jsx)(Activity, {</span>
                <span class="s1">mode: stateKey === activeStateKey ? </span><span class="s0">'visible' </span><span class="s1">: </span><span class="s0">'hidden'</span><span class="s1">,</span>
                <span class="s1">children: child</span>
            <span class="s1">}, stateKey);</span>
        <span class="s1">}</span>
        <span class="s1">children.push(child);</span>
        <span class="s1">bfcacheEntry = bfcacheEntry.next;</span>
    <span class="s1">}</span><span class="s2">while </span><span class="s1">(bfcacheEntry !== </span><span class="s2">null</span><span class="s1">);</span>
    <span class="s2">return </span><span class="s1">children;</span>
<span class="s1">}</span>

<span class="s2">if </span><span class="s1">((</span><span class="s2">typeof </span><span class="s1">exports.default === </span><span class="s0">'function' </span><span class="s1">|| (</span><span class="s2">typeof </span><span class="s1">exports.default === </span><span class="s0">'object' </span><span class="s1">&amp;&amp; exports.default !== </span><span class="s2">null</span><span class="s1">)) &amp;&amp; </span><span class="s2">typeof </span><span class="s1">exports.default.__esModule === </span><span class="s0">'undefined'</span><span class="s1">) {</span>
  <span class="s1">Object.defineProperty(exports.default, </span><span class="s0">'__esModule'</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
  <span class="s1">Object.assign(exports.default, exports);</span>
  <span class="s1">module.exports = exports.default;</span>
<span class="s1">}</span>

<span class="s3">//# sourceMappingURL=layout-router.js.map</span></pre>
</body>
</html>