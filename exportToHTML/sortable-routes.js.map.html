<html>
<head>
<title>sortable-routes.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
sortable-routes.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../../src/shared/lib/router/utils/sortable-routes.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* A route that can be sorted by specificity.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type SortableRoute = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The source page of the route. This represents the original page that's on</span><span class="s3">\n   </span><span class="s1">* disk. For example, the `app/[lang]/[...rest]/page.tsx` would have a source</span><span class="s3">\n   </span><span class="s1">* page of '/[lang]/[...rest]'.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readonly sourcePage: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The page of the route. This represents the final rendered route. For</span><span class="s3">\n   </span><span class="s1">* example, the `app/[lang]/[...rest]/page.tsx` that was rendered with a lang</span><span class="s3">\n   </span><span class="s1">* value of `en` would have a page of '/en/[...rest]'.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readonly page: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Determines the specificity of a route segment for sorting purposes.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* In Next.js routing, more specific routes should match before less specific ones.</span><span class="s3">\n </span><span class="s1">* This function returns a numeric value where lower numbers indicate higher specificity.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Specificity order (most to least specific):</span><span class="s3">\n </span><span class="s1">* 1. Static segments (e.g., </span><span class="s3">\&quot;</span><span class="s1">about</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">api</span><span class="s3">\&quot;</span><span class="s1">) - return 0</span><span class="s3">\n </span><span class="s1">* 2. Dynamic segments (e.g., </span><span class="s3">\&quot;</span><span class="s1">[id]</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">[slug]</span><span class="s3">\&quot;</span><span class="s1">) - return 1</span><span class="s3">\n </span><span class="s1">* 3. Catch-all segments (e.g., </span><span class="s3">\&quot;</span><span class="s1">[...slug]</span><span class="s3">\&quot;</span><span class="s1">) - return 2</span><span class="s3">\n </span><span class="s1">* 4. Optional catch-all segments (e.g., </span><span class="s3">\&quot;</span><span class="s1">[[...slug]]</span><span class="s3">\&quot;</span><span class="s1">) - return 3</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param segment - A single path segment (e.g., </span><span class="s3">\&quot;</span><span class="s1">api</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">[id]</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">[...slug]</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n </span><span class="s1">* @returns A numeric specificity value (0-3, where 0 is most specific)</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getSegmentSpecificity(segment: string): number {</span><span class="s3">\n  </span><span class="s1">// Static segments are most specific - they match exactly one path</span><span class="s3">\n  </span><span class="s1">if (!segment.includes('[')) {</span><span class="s3">\n    </span><span class="s1">return 0</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Optional catch-all [[...param]] is least specific - matches zero or more segments</span><span class="s3">\n  </span><span class="s1">if (segment.startsWith('[[...') &amp;&amp; segment.endsWith(']]')) {</span><span class="s3">\n    </span><span class="s1">return 3</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Catch-all [...param] is less specific - matches one or more segments</span><span class="s3">\n  </span><span class="s1">if (segment.startsWith('[...') &amp;&amp; segment.endsWith(']')) {</span><span class="s3">\n    </span><span class="s1">return 2</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Regular dynamic [param] is more specific than catch-all - matches exactly one segment</span><span class="s3">\n  </span><span class="s1">if (segment.startsWith('[') &amp;&amp; segment.endsWith(']')) {</span><span class="s3">\n    </span><span class="s1">return 1</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Default to static (fallback case)</span><span class="s3">\n  </span><span class="s1">return 0</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Compares two route paths using a depth-first traversal approach.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This function implements a deterministic comparison that sorts routes by specificity:</span><span class="s3">\n </span><span class="s1">* 1. More specific routes come first (fewer dynamic segments)</span><span class="s3">\n </span><span class="s1">* 2. Shorter routes are more specific than longer ones</span><span class="s3">\n </span><span class="s1">* 3. Routes with same specificity are sorted lexicographically</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The comparison is done segment by segment, left to right, similar to how</span><span class="s3">\n </span><span class="s1">* you would traverse a route tree in depth-first order.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param pathA - First route path to compare (e.g., </span><span class="s3">\&quot;</span><span class="s1">/api/users/[id]</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n </span><span class="s1">* @param pathB - Second route path to compare (e.g., </span><span class="s3">\&quot;</span><span class="s1">/api/[...slug]</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n </span><span class="s1">* @returns Negative if pathA is more specific, positive if pathB is more specific, 0 if equal</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function compareRouteSegments(pathA: string, pathB: string): number {</span><span class="s3">\n  </span><span class="s1">// Split paths into segments, removing empty strings from leading/trailing slashes</span><span class="s3">\n  </span><span class="s1">const segmentsA = pathA.split('/').filter(Boolean)</span><span class="s3">\n  </span><span class="s1">const segmentsB = pathB.split('/').filter(Boolean)</span><span class="s3">\n\n  </span><span class="s1">// Compare segment by segment up to the length of the longer path</span><span class="s3">\n  </span><span class="s1">const maxLength = Math.max(segmentsA.length, segmentsB.length)</span><span class="s3">\n\n  </span><span class="s1">for (let i = 0; i &lt; maxLength; i++) {</span><span class="s3">\n    </span><span class="s1">const segA = segmentsA[i] || ''</span><span class="s3">\n    </span><span class="s1">const segB = segmentsB[i] || ''</span><span class="s3">\n\n    </span><span class="s1">// Handle length differences: shorter routes are MORE specific</span><span class="s3">\n    </span><span class="s1">// Example: </span><span class="s3">\&quot;</span><span class="s1">/api</span><span class="s3">\&quot; </span><span class="s1">is more specific than </span><span class="s3">\&quot;</span><span class="s1">/api/users</span><span class="s3">\&quot;\n    </span><span class="s1">if (!segA &amp;&amp; segB) return -1 // pathA is shorter, so more specific</span><span class="s3">\n    </span><span class="s1">if (segA &amp;&amp; !segB) return 1 // pathB is shorter, so more specific</span><span class="s3">\n    </span><span class="s1">if (!segA &amp;&amp; !segB) return 0 // Both paths ended, they're equal</span><span class="s3">\n\n    </span><span class="s1">// Compare segment specificity using our specificity scoring</span><span class="s3">\n    </span><span class="s1">const specificityA = getSegmentSpecificity(segA)</span><span class="s3">\n    </span><span class="s1">const specificityB = getSegmentSpecificity(segB)</span><span class="s3">\n\n    </span><span class="s1">// Lower specificity number = more specific route</span><span class="s3">\n    </span><span class="s1">// Example: </span><span class="s3">\&quot;</span><span class="s1">api</span><span class="s3">\&quot; </span><span class="s1">(0) vs </span><span class="s3">\&quot;</span><span class="s1">[slug]</span><span class="s3">\&quot; </span><span class="s1">(1) - </span><span class="s3">\&quot;</span><span class="s1">api</span><span class="s3">\&quot; </span><span class="s1">wins</span><span class="s3">\n    </span><span class="s1">if (specificityA !== specificityB) {</span><span class="s3">\n      </span><span class="s1">return specificityA - specificityB</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If segments have same specificity, compare lexicographically for determinism</span><span class="s3">\n    </span><span class="s1">// Example: </span><span class="s3">\&quot;</span><span class="s1">[id]</span><span class="s3">\&quot; </span><span class="s1">vs </span><span class="s3">\&quot;</span><span class="s1">[slug]</span><span class="s3">\&quot; </span><span class="s1">- </span><span class="s3">\&quot;</span><span class="s1">[id]</span><span class="s3">\&quot; </span><span class="s1">comes first alphabetically</span><span class="s3">\n    </span><span class="s1">if (segA !== segB) {</span><span class="s3">\n      </span><span class="s1">return segA.localeCompare(segB)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Segments are identical, continue to next segment</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// All segments compared equally</span><span class="s3">\n  </span><span class="s1">return 0</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Compares two complete routes for sorting purposes.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Routes are compared with a two-tier priority system:</span><span class="s3">\n </span><span class="s1">* 1. Primary: Compare by source path specificity</span><span class="s3">\n </span><span class="s1">* 2. Secondary: If sources are equal, compare by page path specificity</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This ensures that routes are primarily organized by their source patterns,</span><span class="s3">\n </span><span class="s1">* with page-specific variations grouped together.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param a - First route to compare</span><span class="s3">\n </span><span class="s1">* @param b - Second route to compare</span><span class="s3">\n </span><span class="s1">* @returns Negative if route a should come first, positive if route b should come first, 0 if equal</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function compareSortableRoutes(a: SortableRoute, b: SortableRoute): number {</span><span class="s3">\n  </span><span class="s1">// First compare by source specificity - this is the primary sorting criterion</span><span class="s3">\n  </span><span class="s1">// Source represents the original route pattern and takes precedence</span><span class="s3">\n  </span><span class="s1">const sourceResult = compareRouteSegments(a.sourcePage, b.sourcePage)</span><span class="s3">\n  </span><span class="s1">if (sourceResult !== 0) return sourceResult</span><span class="s3">\n\n  </span><span class="s1">// If sources are identical, compare by page specificity as a tiebreaker</span><span class="s3">\n  </span><span class="s1">// Page represents the final rendered route and provides secondary ordering</span><span class="s3">\n  </span><span class="s1">return compareRouteSegments(a.page, b.page)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Sorts an array of routes by specificity using a deterministic depth-first traversal approach.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This function implements Next.js route matching priority where more specific routes</span><span class="s3">\n </span><span class="s1">* should be matched before less specific ones. The sorting is deterministic and stable,</span><span class="s3">\n </span><span class="s1">* meaning identical inputs will always produce identical outputs.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Sorting criteria (in order of priority):</span><span class="s3">\n </span><span class="s1">* 1. Source path specificity (primary)</span><span class="s3">\n </span><span class="s1">* 2. Page path specificity (secondary)</span><span class="s3">\n </span><span class="s1">* 3. Lexicographic ordering (tertiary, for determinism)</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Examples of specificity order:</span><span class="s3">\n </span><span class="s1">* - </span><span class="s3">\&quot;</span><span class="s1">/api/users</span><span class="s3">\&quot; </span><span class="s1">(static) comes before </span><span class="s3">\&quot;</span><span class="s1">/api/[slug]</span><span class="s3">\&quot; </span><span class="s1">(dynamic)</span><span class="s3">\n </span><span class="s1">* - </span><span class="s3">\&quot;</span><span class="s1">/api/[id]</span><span class="s3">\&quot; </span><span class="s1">(dynamic) comes before </span><span class="s3">\&quot;</span><span class="s1">/api/[...slug]</span><span class="s3">\&quot; </span><span class="s1">(catch-all)</span><span class="s3">\n </span><span class="s1">* - </span><span class="s3">\&quot;</span><span class="s1">/api/[...slug]</span><span class="s3">\&quot; </span><span class="s1">(catch-all) comes before </span><span class="s3">\&quot;</span><span class="s1">/api/[[...slug]]</span><span class="s3">\&quot; </span><span class="s1">(optional catch-all)</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param routes - Array of routes to sort</span><span class="s3">\n </span><span class="s1">* @returns New sorted array (does not mutate input)</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function sortSortableRoutes(</span><span class="s3">\n  </span><span class="s1">routes: readonly SortableRoute[]</span><span class="s3">\n</span><span class="s1">): readonly SortableRoute[] {</span><span class="s3">\n  </span><span class="s1">// Because sort is always in-place, we need to create a shallow copy to avoid</span><span class="s3">\n  </span><span class="s1">// mutating the input array.</span><span class="s3">\n  </span><span class="s1">return [...routes].sort(compareSortableRoutes)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Sorts an array of pages by specificity using a deterministic depth-first</span><span class="s3">\n </span><span class="s1">* traversal approach.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param pages - Array of pages to sort</span><span class="s3">\n </span><span class="s1">* @returns New sorted array (does not mutate input)</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function sortPages(pages: readonly string[]): readonly string[] {</span><span class="s3">\n  </span><span class="s1">// Because sort is always in-place, we need to create a shallow copy to avoid</span><span class="s3">\n  </span><span class="s1">// mutating the input array.</span><span class="s3">\n  </span><span class="s1">return [...pages].sort(compareRouteSegments)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Sorts an array of objects by sourcePage and page using a deterministic</span><span class="s3">\n </span><span class="s1">* depth-first traversal approach.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param objects - Array of objects to sort</span><span class="s3">\n </span><span class="s1">* @param getter - Function to get the sourcePage and page from an object</span><span class="s3">\n </span><span class="s1">* @returns New sorted array (does not mutate input)</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function sortSortableRouteObjects&lt;T&gt;(</span><span class="s3">\n  </span><span class="s1">objects: readonly T[],</span><span class="s3">\n  </span><span class="s1">getter: (object: T) =&gt; SortableRoute</span><span class="s3">\n</span><span class="s1">): readonly T[] {</span><span class="s3">\n  </span><span class="s1">// Create a SortableRoute for each object.</span><span class="s3">\n  </span><span class="s1">const routes: Array&lt;SortableRoute &amp; { object: T }&gt; = []</span><span class="s3">\n  </span><span class="s1">for (const object of objects) {</span><span class="s3">\n    </span><span class="s1">const route = getter(object)</span><span class="s3">\n    </span><span class="s1">routes.push({ ...route, object })</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// In-place sort the SortableRoutes.</span><span class="s3">\n  </span><span class="s1">routes.sort(compareSortableRoutes)</span><span class="s3">\n\n  </span><span class="s1">// Map the sorted SortableRoutes back to the original objects.</span><span class="s3">\n  </span><span class="s1">return routes.map(({ object }) =&gt; object)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Sorts an array of objects by page using a deterministic depth-first traversal</span><span class="s3">\n </span><span class="s1">* approach.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param objects - Array of objects to sort</span><span class="s3">\n </span><span class="s1">* @param getter - Function to get the page from an object</span><span class="s3">\n </span><span class="s1">* @returns New sorted array (does not mutate input)</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function sortPageObjects&lt;T&gt;(</span><span class="s3">\n  </span><span class="s1">objects: readonly T[],</span><span class="s3">\n  </span><span class="s1">getter: (object: T) =&gt; string</span><span class="s3">\n</span><span class="s1">): readonly T[] {</span><span class="s3">\n  </span><span class="s1">const indexes: Record&lt;string, number[]&gt; = {}</span><span class="s3">\n  </span><span class="s1">const pages: Set&lt;string&gt; = new Set()</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; objects.length; i++) {</span><span class="s3">\n    </span><span class="s1">const object = objects[i]</span><span class="s3">\n    </span><span class="s1">const page = getter(object)</span><span class="s3">\n    </span><span class="s1">indexes[page]?.push(i) || (indexes[page] = [i])</span><span class="s3">\n    </span><span class="s1">pages.add(page)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Sort the unique pages.</span><span class="s3">\n  </span><span class="s1">const sortedPages = Array.from(pages).sort(compareRouteSegments)</span><span class="s3">\n\n  </span><span class="s1">// Map the sorted pages back to the original objects.</span><span class="s3">\n  </span><span class="s1">return sortedPages.reduce&lt;T[]&gt;((sortedObjects, page) =&gt; {</span><span class="s3">\n    </span><span class="s1">// Add all objects for this page to the sorted array.</span><span class="s3">\n    </span><span class="s1">for (const i of indexes[page]) {</span><span class="s3">\n      </span><span class="s1">sortedObjects.push(objects[i])</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Return the sorted array.</span><span class="s3">\n    </span><span class="s1">return sortedObjects</span><span class="s3">\n  </span><span class="s1">}, [])</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;compareRouteSegments&quot;</span><span class="s0">,</span><span class="s1">&quot;getSegmentSpecificity&quot;</span><span class="s0">,</span><span class="s1">&quot;sortPageObjects&quot;</span><span class="s0">,</span><span class="s1">&quot;sortPages&quot;</span><span class="s0">,</span><span class="s1">&quot;sortSortableRouteObjects&quot;</span><span class="s0">,</span><span class="s1">&quot;sortSortableRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;endsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;pathA&quot;</span><span class="s0">,</span><span class="s1">&quot;pathB&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentsA&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;filter&quot;</span><span class="s0">,</span><span class="s1">&quot;Boolean&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentsB&quot;</span><span class="s0">,</span><span class="s1">&quot;maxLength&quot;</span><span class="s0">,</span><span class="s1">&quot;Math&quot;</span><span class="s0">,</span><span class="s1">&quot;max&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;segA&quot;</span><span class="s0">,</span><span class="s1">&quot;segB&quot;</span><span class="s0">,</span><span class="s1">&quot;specificityA&quot;</span><span class="s0">,</span><span class="s1">&quot;specificityB&quot;</span><span class="s0">,</span><span class="s1">&quot;localeCompare&quot;</span><span class="s0">,</span><span class="s1">&quot;compareSortableRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;a&quot;</span><span class="s0">,</span><span class="s1">&quot;b&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceResult&quot;</span><span class="s0">,</span><span class="s1">&quot;sourcePage&quot;</span><span class="s0">,</span><span class="s1">&quot;page&quot;</span><span class="s0">,</span><span class="s1">&quot;routes&quot;</span><span class="s0">,</span><span class="s1">&quot;sort&quot;</span><span class="s0">,</span><span class="s1">&quot;pages&quot;</span><span class="s0">,</span><span class="s1">&quot;objects&quot;</span><span class="s0">,</span><span class="s1">&quot;getter&quot;</span><span class="s0">,</span><span class="s1">&quot;object&quot;</span><span class="s0">,</span><span class="s1">&quot;route&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;indexes&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;sortedPages&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;from&quot;</span><span class="s0">,</span><span class="s1">&quot;reduce&quot;</span><span class="s0">,</span><span class="s1">&quot;sortedObjects&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>