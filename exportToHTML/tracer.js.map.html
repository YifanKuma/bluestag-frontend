<html>
<head>
<title>tracer.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
tracer.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../src/server/lib/trace/tracer.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { FetchEventResult } from '../../web/types'</span><span class="s3">\n</span><span class="s1">import type { TextMapSetter } from '@opentelemetry/api'</span><span class="s3">\n</span><span class="s1">import type { SpanTypes } from './constants'</span><span class="s3">\n</span><span class="s1">import { LogSpanAllowList, NextVanillaSpanAllowlist } from './constants'</span><span class="s3">\n\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">ContextAPI,</span><span class="s3">\n  </span><span class="s1">Span,</span><span class="s3">\n  </span><span class="s1">SpanOptions,</span><span class="s3">\n  </span><span class="s1">Tracer,</span><span class="s3">\n  </span><span class="s1">AttributeValue,</span><span class="s3">\n  </span><span class="s1">TextMapGetter,</span><span class="s3">\n</span><span class="s1">} from 'next/dist/compiled/@opentelemetry/api'</span><span class="s3">\n</span><span class="s1">import { isThenable } from '../../../shared/lib/is-thenable'</span><span class="s3">\n\n</span><span class="s1">let api: typeof import('next/dist/compiled/@opentelemetry/api')</span><span class="s3">\n\n</span><span class="s1">// we want to allow users to use their own version of @opentelemetry/api if they</span><span class="s3">\n</span><span class="s1">// want to, so we try to require it first, and if it fails we fall back to the</span><span class="s3">\n</span><span class="s1">// version that is bundled with Next.js</span><span class="s3">\n</span><span class="s1">// this is because @opentelemetry/api has to be synced with the version of</span><span class="s3">\n</span><span class="s1">// @opentelemetry/tracing that is used, and we don't want to force users to use</span><span class="s3">\n</span><span class="s1">// the version that is bundled with Next.js.</span><span class="s3">\n</span><span class="s1">// the API is ~stable, so this should be fine</span><span class="s3">\n</span><span class="s1">if (process.env.NEXT_RUNTIME === 'edge') {</span><span class="s3">\n  </span><span class="s1">api = require('@opentelemetry/api') as typeof import('@opentelemetry/api')</span><span class="s3">\n</span><span class="s1">} else {</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">api = require('@opentelemetry/api') as typeof import('@opentelemetry/api')</span><span class="s3">\n  </span><span class="s1">} catch (err) {</span><span class="s3">\n    </span><span class="s1">api =</span><span class="s3">\n      </span><span class="s1">require('next/dist/compiled/@opentelemetry/api') as typeof import('next/dist/compiled/@opentelemetry/api')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const { context, propagation, trace, SpanStatusCode, SpanKind, ROOT_CONTEXT } =</span><span class="s3">\n  </span><span class="s1">api</span><span class="s3">\n\n</span><span class="s1">export class BubbledError extends Error {</span><span class="s3">\n  </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">public readonly bubble?: boolean,</span><span class="s3">\n    </span><span class="s1">public readonly result?: FetchEventResult</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">super()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isBubbledError(error: unknown): error is BubbledError {</span><span class="s3">\n  </span><span class="s1">if (typeof error !== 'object' || error === null) return false</span><span class="s3">\n  </span><span class="s1">return error instanceof BubbledError</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const closeSpanWithError = (span: Span, error?: Error) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (isBubbledError(error) &amp;&amp; error.bubble) {</span><span class="s3">\n    </span><span class="s1">span.setAttribute('next.bubble', true)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">if (error) {</span><span class="s3">\n      </span><span class="s1">span.recordException(error)</span><span class="s3">\n      </span><span class="s1">span.setAttribute('error.type', error.name)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">span.setStatus({ code: SpanStatusCode.ERROR, message: error?.message })</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">span.end()</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type TracerSpanOptions = Omit&lt;SpanOptions, 'attributes'&gt; &amp; {</span><span class="s3">\n  </span><span class="s1">parentSpan?: Span</span><span class="s3">\n  </span><span class="s1">spanName?: string</span><span class="s3">\n  </span><span class="s1">attributes?: Partial&lt;Record&lt;AttributeNames, AttributeValue | undefined&gt;&gt;</span><span class="s3">\n  </span><span class="s1">hideSpan?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface NextTracer {</span><span class="s3">\n  </span><span class="s1">getContext(): ContextAPI</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Instruments a function by automatically creating a span activated on its</span><span class="s3">\n   </span><span class="s1">* scope.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* The span will automatically be finished when one of these conditions is</span><span class="s3">\n   </span><span class="s1">* met:</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* * The function returns a promise, in which case the span will finish when</span><span class="s3">\n   </span><span class="s1">* the promise is resolved or rejected.</span><span class="s3">\n   </span><span class="s1">* * The function takes a callback as its second parameter, in which case the</span><span class="s3">\n   </span><span class="s1">* span will finish when that callback is called.</span><span class="s3">\n   </span><span class="s1">* * The function doesn't accept a callback and doesn't return a promise, in</span><span class="s3">\n   </span><span class="s1">* which case the span will finish at the end of the function execution.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">trace&lt;T&gt;(</span><span class="s3">\n    </span><span class="s1">type: SpanTypes,</span><span class="s3">\n    </span><span class="s1">fn: (span?: Span, done?: (error?: Error) =&gt; any) =&gt; Promise&lt;T&gt;</span><span class="s3">\n  </span><span class="s1">): Promise&lt;T&gt;</span><span class="s3">\n  </span><span class="s1">trace&lt;T&gt;(</span><span class="s3">\n    </span><span class="s1">type: SpanTypes,</span><span class="s3">\n    </span><span class="s1">fn: (span?: Span, done?: (error?: Error) =&gt; any) =&gt; T</span><span class="s3">\n  </span><span class="s1">): T</span><span class="s3">\n  </span><span class="s1">trace&lt;T&gt;(</span><span class="s3">\n    </span><span class="s1">type: SpanTypes,</span><span class="s3">\n    </span><span class="s1">options: TracerSpanOptions,</span><span class="s3">\n    </span><span class="s1">fn: (span?: Span, done?: (error?: Error) =&gt; any) =&gt; Promise&lt;T&gt;</span><span class="s3">\n  </span><span class="s1">): Promise&lt;T&gt;</span><span class="s3">\n  </span><span class="s1">trace&lt;T&gt;(</span><span class="s3">\n    </span><span class="s1">type: SpanTypes,</span><span class="s3">\n    </span><span class="s1">options: TracerSpanOptions,</span><span class="s3">\n    </span><span class="s1">fn: (span?: Span, done?: (error?: Error) =&gt; any) =&gt; T</span><span class="s3">\n  </span><span class="s1">): T</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Wrap a function to automatically create a span activated on its</span><span class="s3">\n   </span><span class="s1">* scope when it's called.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* The span will automatically be finished when one of these conditions is</span><span class="s3">\n   </span><span class="s1">* met:</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* * The function returns a promise, in which case the span will finish when</span><span class="s3">\n   </span><span class="s1">* the promise is resolved or rejected.</span><span class="s3">\n   </span><span class="s1">* * The function takes a callback as its last parameter, in which case the</span><span class="s3">\n   </span><span class="s1">* span will finish when that callback is called.</span><span class="s3">\n   </span><span class="s1">* * The function doesn't accept a callback and doesn't return a promise, in</span><span class="s3">\n   </span><span class="s1">* which case the span will finish at the end of the function execution.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">wrap&lt;T = (...args: Array&lt;any&gt;) =&gt; any&gt;(type: SpanTypes, fn: T): T</span><span class="s3">\n  </span><span class="s1">wrap&lt;T = (...args: Array&lt;any&gt;) =&gt; any&gt;(</span><span class="s3">\n    </span><span class="s1">type: SpanTypes,</span><span class="s3">\n    </span><span class="s1">options: TracerSpanOptions,</span><span class="s3">\n    </span><span class="s1">fn: T</span><span class="s3">\n  </span><span class="s1">): T</span><span class="s3">\n  </span><span class="s1">wrap&lt;T = (...args: Array&lt;any&gt;) =&gt; any&gt;(</span><span class="s3">\n    </span><span class="s1">type: SpanTypes,</span><span class="s3">\n    </span><span class="s1">options: (...args: any[]) =&gt; TracerSpanOptions,</span><span class="s3">\n    </span><span class="s1">fn: T</span><span class="s3">\n  </span><span class="s1">): T</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Starts and returns a new Span representing a logical unit of work.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* This method do NOT modify the current Context by default. In result, any inner span will not</span><span class="s3">\n   </span><span class="s1">* automatically set its parent context to the span created by this method unless manually activate</span><span class="s3">\n   </span><span class="s1">* context via `tracer.getContext().with`. `trace`, or `wrap` is generally recommended as it gracefully</span><span class="s3">\n   </span><span class="s1">* handles context activation. (ref: https://github.com/open-telemetry/opentelemetry-js/issues/1923)</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">startSpan(type: SpanTypes): Span</span><span class="s3">\n  </span><span class="s1">startSpan(type: SpanTypes, options: TracerSpanOptions): Span</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns currently activated span if current context is in the scope of the span.</span><span class="s3">\n   </span><span class="s1">* Returns undefined otherwise.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getActiveScopeSpan(): Span | undefined</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns trace propagation data for the currently active context. The format is equal to data provided</span><span class="s3">\n   </span><span class="s1">* through the OpenTelemetry propagator API.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getTracePropagationData(): ClientTraceDataEntry[]</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type NextAttributeNames =</span><span class="s3">\n  </span><span class="s1">| 'next.route'</span><span class="s3">\n  </span><span class="s1">| 'next.page'</span><span class="s3">\n  </span><span class="s1">| 'next.rsc'</span><span class="s3">\n  </span><span class="s1">| 'next.segment'</span><span class="s3">\n  </span><span class="s1">| 'next.span_name'</span><span class="s3">\n  </span><span class="s1">| 'next.span_type'</span><span class="s3">\n  </span><span class="s1">| 'next.clientComponentLoadCount'</span><span class="s3">\n</span><span class="s1">type OTELAttributeNames = `http.${string}` | `net.${string}`</span><span class="s3">\n</span><span class="s1">type AttributeNames = NextAttributeNames | OTELAttributeNames</span><span class="s3">\n\n</span><span class="s1">/** we use this map to propagate attributes from nested spans to the top span */</span><span class="s3">\n</span><span class="s1">const rootSpanAttributesStore = new Map&lt;</span><span class="s3">\n  </span><span class="s1">number,</span><span class="s3">\n  </span><span class="s1">Map&lt;AttributeNames, AttributeValue | undefined&gt;</span><span class="s3">\n</span><span class="s1">&gt;()</span><span class="s3">\n</span><span class="s1">const rootSpanIdKey = api.createContextKey('next.rootSpanId')</span><span class="s3">\n</span><span class="s1">let lastSpanId = 0</span><span class="s3">\n</span><span class="s1">const getSpanId = () =&gt; lastSpanId++</span><span class="s3">\n\n</span><span class="s1">export interface ClientTraceDataEntry {</span><span class="s3">\n  </span><span class="s1">key: string</span><span class="s3">\n  </span><span class="s1">value: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const clientTraceDataSetter: TextMapSetter&lt;ClientTraceDataEntry[]&gt; = {</span><span class="s3">\n  </span><span class="s1">set(carrier, key, value) {</span><span class="s3">\n    </span><span class="s1">carrier.push({</span><span class="s3">\n      </span><span class="s1">key,</span><span class="s3">\n      </span><span class="s1">value,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">class NextTracerImpl implements NextTracer {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns an instance to the trace with configured name.</span><span class="s3">\n   </span><span class="s1">* Since wrap / trace can be defined in any place prior to actual trace subscriber initialization,</span><span class="s3">\n   </span><span class="s1">* This should be lazily evaluated.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private getTracerInstance(): Tracer {</span><span class="s3">\n    </span><span class="s1">return trace.getTracer('next.js', '0.0.1')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public getContext(): ContextAPI {</span><span class="s3">\n    </span><span class="s1">return context</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public getTracePropagationData(): ClientTraceDataEntry[] {</span><span class="s3">\n    </span><span class="s1">const activeContext = context.active()</span><span class="s3">\n    </span><span class="s1">const entries: ClientTraceDataEntry[] = []</span><span class="s3">\n    </span><span class="s1">propagation.inject(activeContext, entries, clientTraceDataSetter)</span><span class="s3">\n    </span><span class="s1">return entries</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public getActiveScopeSpan(): Span | undefined {</span><span class="s3">\n    </span><span class="s1">return trace.getSpan(context?.active())</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public withPropagatedContext&lt;T, C&gt;(</span><span class="s3">\n    </span><span class="s1">carrier: C,</span><span class="s3">\n    </span><span class="s1">fn: () =&gt; T,</span><span class="s3">\n    </span><span class="s1">getter?: TextMapGetter&lt;C&gt;</span><span class="s3">\n  </span><span class="s1">): T {</span><span class="s3">\n    </span><span class="s1">const activeContext = context.active()</span><span class="s3">\n    </span><span class="s1">if (trace.getSpanContext(activeContext)) {</span><span class="s3">\n      </span><span class="s1">// Active span is already set, too late to propagate.</span><span class="s3">\n      </span><span class="s1">return fn()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const remoteContext = propagation.extract(activeContext, carrier, getter)</span><span class="s3">\n    </span><span class="s1">return context.with(remoteContext, fn)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Trace, wrap implementation is inspired by datadog trace implementation</span><span class="s3">\n  </span><span class="s1">// (https://datadoghq.dev/dd-trace-js/interfaces/tracer.html#trace).</span><span class="s3">\n  </span><span class="s1">public trace&lt;T&gt;(</span><span class="s3">\n    </span><span class="s1">type: SpanTypes,</span><span class="s3">\n    </span><span class="s1">fn: (span?: Span, done?: (error?: Error) =&gt; any) =&gt; Promise&lt;T&gt;</span><span class="s3">\n  </span><span class="s1">): Promise&lt;T&gt;</span><span class="s3">\n  </span><span class="s1">public trace&lt;T&gt;(</span><span class="s3">\n    </span><span class="s1">type: SpanTypes,</span><span class="s3">\n    </span><span class="s1">fn: (span?: Span, done?: (error?: Error) =&gt; any) =&gt; T</span><span class="s3">\n  </span><span class="s1">): T</span><span class="s3">\n  </span><span class="s1">public trace&lt;T&gt;(</span><span class="s3">\n    </span><span class="s1">type: SpanTypes,</span><span class="s3">\n    </span><span class="s1">options: TracerSpanOptions,</span><span class="s3">\n    </span><span class="s1">fn: (span?: Span, done?: (error?: Error) =&gt; any) =&gt; Promise&lt;T&gt;</span><span class="s3">\n  </span><span class="s1">): Promise&lt;T&gt;</span><span class="s3">\n  </span><span class="s1">public trace&lt;T&gt;(</span><span class="s3">\n    </span><span class="s1">type: SpanTypes,</span><span class="s3">\n    </span><span class="s1">options: TracerSpanOptions,</span><span class="s3">\n    </span><span class="s1">fn: (span?: Span, done?: (error?: Error) =&gt; any) =&gt; T</span><span class="s3">\n  </span><span class="s1">): T</span><span class="s3">\n  </span><span class="s1">public trace&lt;T&gt;(...args: Array&lt;any&gt;) {</span><span class="s3">\n    </span><span class="s1">const [type, fnOrOptions, fnOrEmpty] = args</span><span class="s3">\n\n    </span><span class="s1">// coerce options form overload</span><span class="s3">\n    </span><span class="s1">const {</span><span class="s3">\n      </span><span class="s1">fn,</span><span class="s3">\n      </span><span class="s1">options,</span><span class="s3">\n    </span><span class="s1">}: {</span><span class="s3">\n      </span><span class="s1">fn: (span?: Span, done?: (error?: Error) =&gt; any) =&gt; T | Promise&lt;T&gt;</span><span class="s3">\n      </span><span class="s1">options: TracerSpanOptions</span><span class="s3">\n    </span><span class="s1">} =</span><span class="s3">\n      </span><span class="s1">typeof fnOrOptions === 'function'</span><span class="s3">\n        </span><span class="s1">? {</span><span class="s3">\n            </span><span class="s1">fn: fnOrOptions,</span><span class="s3">\n            </span><span class="s1">options: {},</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">: {</span><span class="s3">\n            </span><span class="s1">fn: fnOrEmpty,</span><span class="s3">\n            </span><span class="s1">options: { ...fnOrOptions },</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const spanName = options.spanName ?? type</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">(!NextVanillaSpanAllowlist.includes(type) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">process.env.NEXT_OTEL_VERBOSE !== '1') ||</span><span class="s3">\n      </span><span class="s1">options.hideSpan</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return fn()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Trying to get active scoped span to assign parent. If option specifies parent span manually, will try to use it.</span><span class="s3">\n    </span><span class="s1">let spanContext = this.getSpanContext(</span><span class="s3">\n      </span><span class="s1">options?.parentSpan ?? this.getActiveScopeSpan()</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">let isRootSpan = false</span><span class="s3">\n\n    </span><span class="s1">if (!spanContext) {</span><span class="s3">\n      </span><span class="s1">spanContext = context?.active() ?? ROOT_CONTEXT</span><span class="s3">\n      </span><span class="s1">isRootSpan = true</span><span class="s3">\n    </span><span class="s1">} else if (trace.getSpanContext(spanContext)?.isRemote) {</span><span class="s3">\n      </span><span class="s1">isRootSpan = true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const spanId = getSpanId()</span><span class="s3">\n\n    </span><span class="s1">options.attributes = {</span><span class="s3">\n      </span><span class="s1">'next.span_name': spanName,</span><span class="s3">\n      </span><span class="s1">'next.span_type': type,</span><span class="s3">\n      </span><span class="s1">...options.attributes,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return context.with(spanContext.setValue(rootSpanIdKey, spanId), () =&gt;</span><span class="s3">\n      </span><span class="s1">this.getTracerInstance().startActiveSpan(</span><span class="s3">\n        </span><span class="s1">spanName,</span><span class="s3">\n        </span><span class="s1">options,</span><span class="s3">\n        </span><span class="s1">(span: Span) =&gt; {</span><span class="s3">\n          </span><span class="s1">const startTime =</span><span class="s3">\n            </span><span class="s1">'performance' in globalThis &amp;&amp; 'measure' in performance</span><span class="s3">\n              </span><span class="s1">? globalThis.performance.now()</span><span class="s3">\n              </span><span class="s1">: undefined</span><span class="s3">\n\n          </span><span class="s1">const onCleanup = () =&gt; {</span><span class="s3">\n            </span><span class="s1">rootSpanAttributesStore.delete(spanId)</span><span class="s3">\n            </span><span class="s1">if (</span><span class="s3">\n              </span><span class="s1">startTime &amp;&amp;</span><span class="s3">\n              </span><span class="s1">process.env.NEXT_OTEL_PERFORMANCE_PREFIX &amp;&amp;</span><span class="s3">\n              </span><span class="s1">LogSpanAllowList.includes(type || ('' as any))</span><span class="s3">\n            </span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">performance.measure(</span><span class="s3">\n                </span><span class="s1">`${process.env.NEXT_OTEL_PERFORMANCE_PREFIX}:next-${(</span><span class="s3">\n                  </span><span class="s1">type.split('.').pop() || ''</span><span class="s3">\n                </span><span class="s1">).replace(</span><span class="s3">\n                  </span><span class="s1">/[A-Z]/g,</span><span class="s3">\n                  </span><span class="s1">(match: string) =&gt; '-' + match.toLowerCase()</span><span class="s3">\n                </span><span class="s1">)}`,</span><span class="s3">\n                </span><span class="s1">{</span><span class="s3">\n                  </span><span class="s1">start: startTime,</span><span class="s3">\n                  </span><span class="s1">end: performance.now(),</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">if (isRootSpan) {</span><span class="s3">\n            </span><span class="s1">rootSpanAttributesStore.set(</span><span class="s3">\n              </span><span class="s1">spanId,</span><span class="s3">\n              </span><span class="s1">new Map(</span><span class="s3">\n                </span><span class="s1">Object.entries(options.attributes ?? {}) as [</span><span class="s3">\n                  </span><span class="s1">AttributeNames,</span><span class="s3">\n                  </span><span class="s1">AttributeValue | undefined,</span><span class="s3">\n                </span><span class="s1">][]</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">if (fn.length &gt; 1) {</span><span class="s3">\n              </span><span class="s1">return fn(span, (err) =&gt; closeSpanWithError(span, err))</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">const result = fn(span)</span><span class="s3">\n            </span><span class="s1">if (isThenable(result)) {</span><span class="s3">\n              </span><span class="s1">// If there's error make sure it throws</span><span class="s3">\n              </span><span class="s1">return result</span><span class="s3">\n                </span><span class="s1">.then((res) =&gt; {</span><span class="s3">\n                  </span><span class="s1">span.end()</span><span class="s3">\n                  </span><span class="s1">// Need to pass down the promise result,</span><span class="s3">\n                  </span><span class="s1">// it could be react stream response with error { error, stream }</span><span class="s3">\n                  </span><span class="s1">return res</span><span class="s3">\n                </span><span class="s1">})</span><span class="s3">\n                </span><span class="s1">.catch((err) =&gt; {</span><span class="s3">\n                  </span><span class="s1">closeSpanWithError(span, err)</span><span class="s3">\n                  </span><span class="s1">throw err</span><span class="s3">\n                </span><span class="s1">})</span><span class="s3">\n                </span><span class="s1">.finally(onCleanup)</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">span.end()</span><span class="s3">\n              </span><span class="s1">onCleanup()</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">return result</span><span class="s3">\n          </span><span class="s1">} catch (err: any) {</span><span class="s3">\n            </span><span class="s1">closeSpanWithError(span, err)</span><span class="s3">\n            </span><span class="s1">onCleanup()</span><span class="s3">\n            </span><span class="s1">throw err</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public wrap&lt;T = (...args: Array&lt;any&gt;) =&gt; any&gt;(type: SpanTypes, fn: T): T</span><span class="s3">\n  </span><span class="s1">public wrap&lt;T = (...args: Array&lt;any&gt;) =&gt; any&gt;(</span><span class="s3">\n    </span><span class="s1">type: SpanTypes,</span><span class="s3">\n    </span><span class="s1">options: TracerSpanOptions,</span><span class="s3">\n    </span><span class="s1">fn: T</span><span class="s3">\n  </span><span class="s1">): T</span><span class="s3">\n  </span><span class="s1">public wrap&lt;T = (...args: Array&lt;any&gt;) =&gt; any&gt;(</span><span class="s3">\n    </span><span class="s1">type: SpanTypes,</span><span class="s3">\n    </span><span class="s1">options: (...args: any[]) =&gt; TracerSpanOptions,</span><span class="s3">\n    </span><span class="s1">fn: T</span><span class="s3">\n  </span><span class="s1">): T</span><span class="s3">\n  </span><span class="s1">public wrap(...args: Array&lt;any&gt;) {</span><span class="s3">\n    </span><span class="s1">const tracer = this</span><span class="s3">\n    </span><span class="s1">const [name, options, fn] =</span><span class="s3">\n      </span><span class="s1">args.length === 3 ? args : [args[0], {}, args[1]]</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!NextVanillaSpanAllowlist.includes(name) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">process.env.NEXT_OTEL_VERBOSE !== '1'</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return fn</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return function (this: any) {</span><span class="s3">\n      </span><span class="s1">let optionsObj = options</span><span class="s3">\n      </span><span class="s1">if (typeof optionsObj === 'function' &amp;&amp; typeof fn === 'function') {</span><span class="s3">\n        </span><span class="s1">optionsObj = optionsObj.apply(this, arguments)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const lastArgId = arguments.length - 1</span><span class="s3">\n      </span><span class="s1">const cb = arguments[lastArgId]</span><span class="s3">\n\n      </span><span class="s1">if (typeof cb === 'function') {</span><span class="s3">\n        </span><span class="s1">const scopeBoundCb = tracer.getContext().bind(context.active(), cb)</span><span class="s3">\n        </span><span class="s1">return tracer.trace(name, optionsObj, (_span, done) =&gt; {</span><span class="s3">\n          </span><span class="s1">arguments[lastArgId] = function (err: any) {</span><span class="s3">\n            </span><span class="s1">done?.(err)</span><span class="s3">\n            </span><span class="s1">return scopeBoundCb.apply(this, arguments)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">return fn.apply(this, arguments)</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return tracer.trace(name, optionsObj, () =&gt; fn.apply(this, arguments))</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public startSpan(type: SpanTypes): Span</span><span class="s3">\n  </span><span class="s1">public startSpan(type: SpanTypes, options: TracerSpanOptions): Span</span><span class="s3">\n  </span><span class="s1">public startSpan(...args: Array&lt;any&gt;): Span {</span><span class="s3">\n    </span><span class="s1">const [type, options]: [string, TracerSpanOptions | undefined] = args as any</span><span class="s3">\n\n    </span><span class="s1">const spanContext = this.getSpanContext(</span><span class="s3">\n      </span><span class="s1">options?.parentSpan ?? this.getActiveScopeSpan()</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">return this.getTracerInstance().startSpan(type, options, spanContext)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private getSpanContext(parentSpan?: Span) {</span><span class="s3">\n    </span><span class="s1">const spanContext = parentSpan</span><span class="s3">\n      </span><span class="s1">? trace.setSpan(context.active(), parentSpan)</span><span class="s3">\n      </span><span class="s1">: undefined</span><span class="s3">\n\n    </span><span class="s1">return spanContext</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public getRootSpanAttributes() {</span><span class="s3">\n    </span><span class="s1">const spanId = context.active().getValue(rootSpanIdKey) as number</span><span class="s3">\n    </span><span class="s1">return rootSpanAttributesStore.get(spanId)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public setRootSpanAttribute(key: AttributeNames, value: AttributeValue) {</span><span class="s3">\n    </span><span class="s1">const spanId = context.active().getValue(rootSpanIdKey) as number</span><span class="s3">\n    </span><span class="s1">const attributes = rootSpanAttributesStore.get(spanId)</span><span class="s3">\n    </span><span class="s1">if (attributes) {</span><span class="s3">\n      </span><span class="s1">attributes.set(key, value)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const getTracer = (() =&gt; {</span><span class="s3">\n  </span><span class="s1">const tracer = new NextTracerImpl()</span><span class="s3">\n\n  </span><span class="s1">return () =&gt; tracer</span><span class="s3">\n</span><span class="s1">})()</span><span class="s3">\n\n</span><span class="s1">export { getTracer, SpanStatusCode, SpanKind }</span><span class="s3">\n</span><span class="s1">export type { NextTracer, Span, SpanOptions, ContextAPI, TracerSpanOptions }</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;BubbledError&quot;</span><span class="s0">,</span><span class="s1">&quot;SpanKind&quot;</span><span class="s0">,</span><span class="s1">&quot;SpanStatusCode&quot;</span><span class="s0">,</span><span class="s1">&quot;getTracer&quot;</span><span class="s0">,</span><span class="s1">&quot;isBubbledError&quot;</span><span class="s0">,</span><span class="s1">&quot;api&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_RUNTIME&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;context&quot;</span><span class="s0">,</span><span class="s1">&quot;propagation&quot;</span><span class="s0">,</span><span class="s1">&quot;trace&quot;</span><span class="s0">,</span><span class="s1">&quot;ROOT_CONTEXT&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;bubble&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;closeSpanWithError&quot;</span><span class="s0">,</span><span class="s1">&quot;span&quot;</span><span class="s0">,</span><span class="s1">&quot;setAttribute&quot;</span><span class="s0">,</span><span class="s1">&quot;recordException&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;setStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;code&quot;</span><span class="s0">,</span><span class="s1">&quot;ERROR&quot;</span><span class="s0">,</span><span class="s1">&quot;message&quot;</span><span class="s0">,</span><span class="s1">&quot;end&quot;</span><span class="s0">,</span><span class="s1">&quot;rootSpanAttributesStore&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;rootSpanIdKey&quot;</span><span class="s0">,</span><span class="s1">&quot;createContextKey&quot;</span><span class="s0">,</span><span class="s1">&quot;lastSpanId&quot;</span><span class="s0">,</span><span class="s1">&quot;getSpanId&quot;</span><span class="s0">,</span><span class="s1">&quot;clientTraceDataSetter&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;carrier&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;NextTracerImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;getTracerInstance&quot;</span><span class="s0">,</span><span class="s1">&quot;getContext&quot;</span><span class="s0">,</span><span class="s1">&quot;getTracePropagationData&quot;</span><span class="s0">,</span><span class="s1">&quot;activeContext&quot;</span><span class="s0">,</span><span class="s1">&quot;active&quot;</span><span class="s0">,</span><span class="s1">&quot;entries&quot;</span><span class="s0">,</span><span class="s1">&quot;inject&quot;</span><span class="s0">,</span><span class="s1">&quot;getActiveScopeSpan&quot;</span><span class="s0">,</span><span class="s1">&quot;getSpan&quot;</span><span class="s0">,</span><span class="s1">&quot;withPropagatedContext&quot;</span><span class="s0">,</span><span class="s1">&quot;fn&quot;</span><span class="s0">,</span><span class="s1">&quot;getter&quot;</span><span class="s0">,</span><span class="s1">&quot;getSpanContext&quot;</span><span class="s0">,</span><span class="s1">&quot;remoteContext&quot;</span><span class="s0">,</span><span class="s1">&quot;extract&quot;</span><span class="s0">,</span><span class="s1">&quot;with&quot;</span><span class="s0">,</span><span class="s1">&quot;args&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;fnOrOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;fnOrEmpty&quot;</span><span class="s0">,</span><span class="s1">&quot;options&quot;</span><span class="s0">,</span><span class="s1">&quot;spanName&quot;</span><span class="s0">,</span><span class="s1">&quot;NextVanillaSpanAllowlist&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_OTEL_VERBOSE&quot;</span><span class="s0">,</span><span class="s1">&quot;hideSpan&quot;</span><span class="s0">,</span><span class="s1">&quot;spanContext&quot;</span><span class="s0">,</span><span class="s1">&quot;parentSpan&quot;</span><span class="s0">,</span><span class="s1">&quot;isRootSpan&quot;</span><span class="s0">,</span><span class="s1">&quot;isRemote&quot;</span><span class="s0">,</span><span class="s1">&quot;spanId&quot;</span><span class="s0">,</span><span class="s1">&quot;attributes&quot;</span><span class="s0">,</span><span class="s1">&quot;setValue&quot;</span><span class="s0">,</span><span class="s1">&quot;startActiveSpan&quot;</span><span class="s0">,</span><span class="s1">&quot;startTime&quot;</span><span class="s0">,</span><span class="s1">&quot;globalThis&quot;</span><span class="s0">,</span><span class="s1">&quot;performance&quot;</span><span class="s0">,</span><span class="s1">&quot;now&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;onCleanup&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_OTEL_PERFORMANCE_PREFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;LogSpanAllowList&quot;</span><span class="s0">,</span><span class="s1">&quot;measure&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;pop&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;match&quot;</span><span class="s0">,</span><span class="s1">&quot;toLowerCase&quot;</span><span class="s0">,</span><span class="s1">&quot;start&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;isThenable&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;res&quot;</span><span class="s0">,</span><span class="s1">&quot;catch&quot;</span><span class="s0">,</span><span class="s1">&quot;finally&quot;</span><span class="s0">,</span><span class="s1">&quot;wrap&quot;</span><span class="s0">,</span><span class="s1">&quot;tracer&quot;</span><span class="s0">,</span><span class="s1">&quot;optionsObj&quot;</span><span class="s0">,</span><span class="s1">&quot;apply&quot;</span><span class="s0">,</span><span class="s1">&quot;arguments&quot;</span><span class="s0">,</span><span class="s1">&quot;lastArgId&quot;</span><span class="s0">,</span><span class="s1">&quot;cb&quot;</span><span class="s0">,</span><span class="s1">&quot;scopeBoundCb&quot;</span><span class="s0">,</span><span class="s1">&quot;bind&quot;</span><span class="s0">,</span><span class="s1">&quot;_span&quot;</span><span class="s0">,</span><span class="s1">&quot;done&quot;</span><span class="s0">,</span><span class="s1">&quot;startSpan&quot;</span><span class="s0">,</span><span class="s1">&quot;setSpan&quot;</span><span class="s0">,</span><span class="s1">&quot;getRootSpanAttributes&quot;</span><span class="s0">,</span><span class="s1">&quot;getValue&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;setRootSpanAttribute&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>