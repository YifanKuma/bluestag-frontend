<html>
<head>
<title>checkNumberLength.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
checkNumberLength.js</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">Metadata from </span><span class="s2">'../metadata.js'</span>
<span class="s0">import </span><span class="s1">mergeArrays from </span><span class="s2">'./mergeArrays.js'</span>

<span class="s0">export default function </span><span class="s1">checkNumberLength(nationalNumber, country, metadata) {</span>
	<span class="s0">return </span><span class="s1">checkNumberLengthForType(nationalNumber, country, undefined, metadata)</span>
<span class="s1">}</span>

<span class="s3">// Checks whether a number is possible for a certain `country` based on the number length.</span>
<span class="s3">//</span>
<span class="s3">// This function is not supported by metadata generated with ancient versions of</span>
<span class="s3">// `libphonenumber-js` (before version `1.0.18`) which didn't include &quot;possible lengths&quot;.</span>
<span class="s3">//</span>
<span class="s3">// There was also a known issue with `checkNumberLength()` function:</span>
<span class="s3">// if a number is possible only in a certain `country` among several `countries`</span>
<span class="s3">// that share the same &quot;country calling code&quot;, that function would check</span>
<span class="s3">// the possibility of the phone number only in the &quot;main&quot; `country` for the &quot;country calling code&quot;</span>
<span class="s3">// and would not check if it's actually be possible in the speciifc `country`.</span>
<span class="s3">//</span>
<span class="s3">// For example, &quot;+1310xxxx&quot; numbers are valid in Canada.</span>
<span class="s3">// However, they are not possible in the US due to being too short.</span>
<span class="s3">// Since Canada and the US share the same country calling code — &quot;+1&quot; —</span>
<span class="s3">// `checkNumberLength()` function used to return not &quot;IS_POSSIBLE&quot; for &quot;+1310xxxx&quot; numbers.</span>
<span class="s3">//</span>
<span class="s3">// In such cases, when using &quot;/max&quot; metadata, `isValid()` could output `true`</span>
<span class="s3">// but at the same time `isPossible()` could output `false`, which was contradictory.</span>
<span class="s3">//</span>
<span class="s3">// See https://issuetracker.google.com/issues/335892662 for the discusson in Google's issues.</span>
<span class="s3">//</span>
<span class="s3">// The solution suggested by Google was implemented: an optional `country` argument</span>
<span class="s3">// was added to `checkNumberLength()` function. If present, that `country` will be used</span>
<span class="s3">// to check phone number length for that specific `country` rather than the &quot;main&quot; country</span>
<span class="s3">// for the shared &quot;country calling code&quot;.</span>
<span class="s3">//</span>
<span class="s0">export function </span><span class="s1">checkNumberLengthForType(nationalNumber, country, type, metadata) {</span>
	<span class="s3">// If the exact `country` is specified, it's no necessarily already selected in `metadata`.</span>
	<span class="s3">// Most likely, in cases when there're multiple countries corresponding to the same</span>
	<span class="s3">// &quot;country calling code&quot;, the &quot;main&quot; country for that &quot;country calling code&quot; will be selected.</span>
	<span class="s0">if </span><span class="s1">(country) {</span>
		<span class="s1">metadata = </span><span class="s0">new </span><span class="s1">Metadata(metadata.metadata)</span>
		<span class="s1">metadata.selectNumberingPlan(country)</span>
	<span class="s1">}</span>

	<span class="s0">const </span><span class="s1">type_info = metadata.type(type)</span>

	<span class="s3">// There should always be &quot;&lt;possiblePengths/&gt;&quot; set for every type element.</span>
	<span class="s3">// This is declared in the XML schema.</span>
	<span class="s3">// For size efficiency, where a sub-description (e.g. fixed-line)</span>
	<span class="s3">// has the same &quot;&lt;possiblePengths/&gt;&quot; as the &quot;general description&quot;, this is missing,</span>
	<span class="s3">// so we fall back to the &quot;general description&quot;. Where no numbers of the type</span>
	<span class="s3">// exist at all, there is one possible length (-1) which is guaranteed</span>
	<span class="s3">// not to match the length of any real phone number.</span>
	<span class="s0">let </span><span class="s1">possible_lengths = type_info &amp;&amp; type_info.possibleLengths() || metadata.possibleLengths()</span>
	<span class="s3">// let local_lengths = type_info &amp;&amp; type.possibleLengthsLocal() || metadata.possibleLengthsLocal()</span>

	<span class="s3">// Metadata before version `1.0.18` didn't contain `possible_lengths`.</span>
	<span class="s0">if </span><span class="s1">(!possible_lengths) {</span>
		<span class="s0">return </span><span class="s2">'IS_POSSIBLE'</span>
	<span class="s1">}</span>

	<span class="s0">if </span><span class="s1">(type === </span><span class="s2">'FIXED_LINE_OR_MOBILE'</span><span class="s1">) {</span>
		<span class="s3">// No such country in metadata.</span>
		<span class="s3">/* istanbul ignore next */</span>
		<span class="s0">if </span><span class="s1">(!metadata.type(</span><span class="s2">'FIXED_LINE'</span><span class="s1">)) {</span>
			<span class="s3">// The rare case has been encountered where no fixedLine data is available</span>
			<span class="s3">// (true for some non-geographic entities), so we just check mobile.</span>
			<span class="s0">return </span><span class="s1">checkNumberLengthForType(nationalNumber, country, </span><span class="s2">'MOBILE'</span><span class="s1">, metadata)</span>
		<span class="s1">}</span>

		<span class="s0">const </span><span class="s1">mobile_type = metadata.type(</span><span class="s2">'MOBILE'</span><span class="s1">)</span>
		<span class="s0">if </span><span class="s1">(mobile_type) {</span>
			<span class="s3">// Merge the mobile data in if there was any. &quot;Concat&quot; creates a new</span>
			<span class="s3">// array, it doesn't edit possible_lengths in place, so we don't need a copy.</span>
			<span class="s3">// Note that when adding the possible lengths from mobile, we have</span>
			<span class="s3">// to again check they aren't empty since if they are this indicates</span>
			<span class="s3">// they are the same as the general desc and should be obtained from there.</span>
			<span class="s1">possible_lengths = mergeArrays(possible_lengths, mobile_type.possibleLengths())</span>
			<span class="s3">// The current list is sorted; we need to merge in the new list and</span>
			<span class="s3">// re-sort (duplicates are okay). Sorting isn't so expensive because</span>
			<span class="s3">// the lists are very small.</span>

			<span class="s3">// if (local_lengths) {</span>
			<span class="s3">//  local_lengths = mergeArrays(local_lengths, mobile_type.possibleLengthsLocal())</span>
			<span class="s3">// } else {</span>
			<span class="s3">//  local_lengths = mobile_type.possibleLengthsLocal()</span>
			<span class="s3">// }</span>
		<span class="s1">}</span>
	<span class="s1">}</span>
	<span class="s3">// If the type doesn't exist then return 'INVALID_LENGTH'.</span>
	<span class="s0">else if </span><span class="s1">(type &amp;&amp; !type_info) {</span>
		<span class="s0">return </span><span class="s2">'INVALID_LENGTH'</span>
	<span class="s1">}</span>

	<span class="s0">const </span><span class="s1">actual_length = nationalNumber.length</span>

	<span class="s3">// In `libphonenumber-js` all &quot;local-only&quot; formats are dropped for simplicity.</span>
	<span class="s3">// // This is safe because there is never an overlap beween the possible lengths</span>
	<span class="s3">// // and the local-only lengths; this is checked at build time.</span>
	<span class="s3">// if (local_lengths &amp;&amp; local_lengths.indexOf(nationalNumber.length) &gt;= 0)</span>
	<span class="s3">// {</span>
	<span class="s3">//  return 'IS_POSSIBLE_LOCAL_ONLY'</span>
	<span class="s3">// }</span>

	<span class="s0">const </span><span class="s1">minimum_length = possible_lengths[</span><span class="s4">0</span><span class="s1">]</span>

	<span class="s0">if </span><span class="s1">(minimum_length === actual_length) {</span>
		<span class="s0">return </span><span class="s2">'IS_POSSIBLE'</span>
	<span class="s1">}</span>

	<span class="s0">if </span><span class="s1">(minimum_length &gt; actual_length) {</span>
		<span class="s0">return </span><span class="s2">'TOO_SHORT'</span>
	<span class="s1">}</span>

	<span class="s0">if </span><span class="s1">(possible_lengths[possible_lengths.length - </span><span class="s4">1</span><span class="s1">] &lt; actual_length) {</span>
		<span class="s0">return </span><span class="s2">'TOO_LONG'</span>
	<span class="s1">}</span>

	<span class="s3">// We skip the first element since we've already checked it.</span>
	<span class="s0">return </span><span class="s1">possible_lengths.indexOf(actual_length, </span><span class="s4">1</span><span class="s1">) &gt;= </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">'IS_POSSIBLE' </span><span class="s1">: </span><span class="s2">'INVALID_LENGTH'</span>
<span class="s1">}</span></pre>
</body>
</html>