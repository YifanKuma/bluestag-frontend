<html>
<head>
<title>use-merged-ref.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
use-merged-ref.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/client/use-merged-ref.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { useCallback, useRef, type Ref } from 'react'</span><span class="s3">\n\n</span><span class="s1">// This is a compatibility hook to support React 18 and 19 refs.</span><span class="s3">\n</span><span class="s1">// In 19, a cleanup function from refs may be returned.</span><span class="s3">\n</span><span class="s1">// In 18, returning a cleanup function creates a warning.</span><span class="s3">\n</span><span class="s1">// Since we take userspace refs, we don't know ahead of time if a cleanup function will be returned.</span><span class="s3">\n</span><span class="s1">// This implements cleanup functions with the old behavior in 18.</span><span class="s3">\n</span><span class="s1">// We know refs are always called alternating with `null` and then `T`.</span><span class="s3">\n</span><span class="s1">// So a call with `null` means we need to call the previous cleanup functions.</span><span class="s3">\n</span><span class="s1">export function useMergedRef&lt;TElement&gt;(</span><span class="s3">\n  </span><span class="s1">refA: Ref&lt;TElement&gt;,</span><span class="s3">\n  </span><span class="s1">refB: Ref&lt;TElement&gt;</span><span class="s3">\n</span><span class="s1">): Ref&lt;TElement&gt; {</span><span class="s3">\n  </span><span class="s1">const cleanupA = useRef&lt;(() =&gt; void) | null&gt;(null)</span><span class="s3">\n  </span><span class="s1">const cleanupB = useRef&lt;(() =&gt; void) | null&gt;(null)</span><span class="s3">\n\n  </span><span class="s1">// NOTE: In theory, we could skip the wrapping if only one of the refs is non-null.</span><span class="s3">\n  </span><span class="s1">// (this happens often if the user doesn't pass a ref to Link/Form/Image)</span><span class="s3">\n  </span><span class="s1">// But this can cause us to leak a cleanup-ref into user code (e.g. via `&lt;Link legacyBehavior&gt;`),</span><span class="s3">\n  </span><span class="s1">// and the user might pass that ref into ref-merging library that doesn't support cleanup refs</span><span class="s3">\n  </span><span class="s1">// (because it hasn't been updated for React 19)</span><span class="s3">\n  </span><span class="s1">// which can then cause things to blow up, because a cleanup-returning ref gets called with `null`.</span><span class="s3">\n  </span><span class="s1">// So in practice, it's safer to be defensive and always wrap the ref, even on React 19.</span><span class="s3">\n  </span><span class="s1">return useCallback(</span><span class="s3">\n    </span><span class="s1">(current: TElement | null): void =&gt; {</span><span class="s3">\n      </span><span class="s1">if (current === null) {</span><span class="s3">\n        </span><span class="s1">const cleanupFnA = cleanupA.current</span><span class="s3">\n        </span><span class="s1">if (cleanupFnA) {</span><span class="s3">\n          </span><span class="s1">cleanupA.current = null</span><span class="s3">\n          </span><span class="s1">cleanupFnA()</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const cleanupFnB = cleanupB.current</span><span class="s3">\n        </span><span class="s1">if (cleanupFnB) {</span><span class="s3">\n          </span><span class="s1">cleanupB.current = null</span><span class="s3">\n          </span><span class="s1">cleanupFnB()</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">if (refA) {</span><span class="s3">\n          </span><span class="s1">cleanupA.current = applyRef(refA, current)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (refB) {</span><span class="s3">\n          </span><span class="s1">cleanupB.current = applyRef(refB, current)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">[refA, refB]</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function applyRef&lt;TElement&gt;(</span><span class="s3">\n  </span><span class="s1">refA: NonNullable&lt;Ref&lt;TElement&gt;&gt;,</span><span class="s3">\n  </span><span class="s1">current: TElement</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (typeof refA === 'function') {</span><span class="s3">\n    </span><span class="s1">const cleanup = refA(current)</span><span class="s3">\n    </span><span class="s1">if (typeof cleanup === 'function') {</span><span class="s3">\n      </span><span class="s1">return cleanup</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return () =&gt; refA(null)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">refA.current = current</span><span class="s3">\n    </span><span class="s1">return () =&gt; {</span><span class="s3">\n      </span><span class="s1">refA.current = null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;useMergedRef&quot;</span><span class="s0">,</span><span class="s1">&quot;refA&quot;</span><span class="s0">,</span><span class="s1">&quot;refB&quot;</span><span class="s0">,</span><span class="s1">&quot;cleanupA&quot;</span><span class="s0">,</span><span class="s1">&quot;useRef&quot;</span><span class="s0">,</span><span class="s1">&quot;cleanupB&quot;</span><span class="s0">,</span><span class="s1">&quot;useCallback&quot;</span><span class="s0">,</span><span class="s1">&quot;current&quot;</span><span class="s0">,</span><span class="s1">&quot;cleanupFnA&quot;</span><span class="s0">,</span><span class="s1">&quot;cleanupFnB&quot;</span><span class="s0">,</span><span class="s1">&quot;applyRef&quot;</span><span class="s0">,</span><span class="s1">&quot;cleanup&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;+BASgBA;;;eAAAA;;;uBAT8B;AASvC,SAASA,aACdC,IAAmB,EACnBC,IAAmB;IAEnB,MAAMC,WAAWC,IAAAA,aAAM,EAAsB;IAC7C,MAAMC,WAAWD,IAAAA,aAAM,EAAsB;IAE7C,mFAAmF;IACnF,yEAAyE;IACzE,iGAAiG;IACjG,8FAA8F;IAC9F,gDAAgD;IAChD,mGAAmG;IACnG,wFAAwF;IACxF,OAAOE,IAAAA,kBAAW,EAChB,CAACC;QACC,IAAIA,YAAY,MAAM;YACpB,MAAMC,aAAaL,SAASI,OAAO;YACnC,IAAIC,YAAY;gBACdL,SAASI,OAAO,GAAG;gBACnBC;YACF;YACA,MAAMC,aAAaJ,SAASE,OAAO;YACnC,IAAIE,YAAY;gBACdJ,SAASE,OAAO,GAAG;gBACnBE;YACF;QACF,OAAO;YACL,IAAIR,MAAM;gBACRE,SAASI,OAAO,GAAGG,SAAST,MAAMM;YACpC;YACA,IAAIL,MAAM;gBACRG,SAASE,OAAO,GAAGG,SAASR,MAAMK;YACpC;QACF;IACF,GACA;QAACN;QAAMC;KAAK;AAEhB;AAEA,SAASQ,SACPT,IAAgC,EAChCM,OAAiB;IAEjB,IAAI,OAAON,SAAS,YAAY;QAC9B,MAAMU,UAAUV,KAAKM;QACrB,IAAI,OAAOI,YAAY,YAAY;YACjC,OAAOA;QACT,OAAO;YACL,OAAO,IAAMV,KAAK;QACpB;IACF,OAAO;QACLA,KAAKM,OAAO,GAAGA;QACf,OAAO;YACLN,KAAKM,OAAO,GAAG;QACjB;IACF;AACF&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>