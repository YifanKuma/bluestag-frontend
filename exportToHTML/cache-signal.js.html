<html>
<head>
<title>cache-signal.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #0033b3;}
.s4 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
cache-signal.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* This class is used to detect when all cache reads for a given render are settled.</span>
 <span class="s0">* We do this to allow for cache warming the prerender without having to continue rendering</span>
 <span class="s0">* the remainder of the page. This feature is really only useful when the cacheComponents flag is on</span>
 <span class="s0">* and should only be used in codepaths gated with this feature.</span>
 <span class="s0">*/ </span><span class="s2">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s3">true</span>
<span class="s1">});</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s2">&quot;CacheSignal&quot;</span><span class="s1">, {</span>
    <span class="s1">enumerable: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">get: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">CacheSignal;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s3">const </span><span class="s1">_invarianterror = require(</span><span class="s2">&quot;../../shared/lib/invariant-error&quot;</span><span class="s1">);</span>
<span class="s3">class </span><span class="s1">CacheSignal {</span>
    <span class="s1">constructor(){</span>
        <span class="s3">this</span><span class="s1">.count = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s3">this</span><span class="s1">.earlyListeners = [];</span>
        <span class="s3">this</span><span class="s1">.listeners = [];</span>
        <span class="s3">this</span><span class="s1">.tickPending = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s3">this</span><span class="s1">.taskPending = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s3">this</span><span class="s1">.subscribedSignals = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s1">(process.env.NEXT_RUNTIME === </span><span class="s2">'edge'</span><span class="s1">) {</span>
            <span class="s0">// we rely on `process.nextTick`, which is not supported in edge</span>
            <span class="s3">throw </span><span class="s1">Object.defineProperty(</span><span class="s3">new </span><span class="s1">_invarianterror.InvariantError(</span><span class="s2">'CacheSignal cannot be used in the edge runtime, because `cacheComponents` does not support it.'</span><span class="s1">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                <span class="s1">value: </span><span class="s2">&quot;E685&quot;</span><span class="s1">,</span>
                <span class="s1">enumerable: </span><span class="s3">false</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s3">true</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">noMorePendingCaches() {</span>
        <span class="s3">if </span><span class="s1">(!</span><span class="s3">this</span><span class="s1">.tickPending) {</span>
            <span class="s3">this</span><span class="s1">.tickPending = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">process.nextTick(()=&gt;{</span>
                <span class="s3">this</span><span class="s1">.tickPending = </span><span class="s3">false</span><span class="s1">;</span>
                <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.count === </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s3">for</span><span class="s1">(</span><span class="s3">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; </span><span class="s3">this</span><span class="s1">.earlyListeners.length; i++){</span>
                        <span class="s3">this</span><span class="s1">.earlyListeners[i]();</span>
                    <span class="s1">}</span>
                    <span class="s3">this</span><span class="s1">.earlyListeners.length = </span><span class="s4">0</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(!</span><span class="s3">this</span><span class="s1">.taskPending) {</span>
            <span class="s3">this</span><span class="s1">.taskPending = </span><span class="s3">true</span><span class="s1">;</span>
            <span class="s1">setTimeout(()=&gt;{</span>
                <span class="s3">this</span><span class="s1">.taskPending = </span><span class="s3">false</span><span class="s1">;</span>
                <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.count === </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s3">for</span><span class="s1">(</span><span class="s3">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; </span><span class="s3">this</span><span class="s1">.listeners.length; i++){</span>
                        <span class="s3">this</span><span class="s1">.listeners[i]();</span>
                    <span class="s1">}</span>
                    <span class="s3">this</span><span class="s1">.listeners.length = </span><span class="s4">0</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}, </span><span class="s4">0</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
   <span class="s0">* This promise waits until there are no more in progress cache reads but no later.</span>
   <span class="s0">* This allows for adding more cache reads after to delay cacheReady.</span>
   <span class="s0">*/ </span><span class="s1">inputReady() {</span>
        <span class="s3">return new </span><span class="s1">Promise((resolve)=&gt;{</span>
            <span class="s3">this</span><span class="s1">.earlyListeners.push(resolve);</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.count === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s3">this</span><span class="s1">.noMorePendingCaches();</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s0">/**</span>
   <span class="s0">* If there are inflight cache reads this Promise can resolve in a microtask however</span>
   <span class="s0">* if there are no inflight cache reads then we wait at least one task to allow initial</span>
   <span class="s0">* cache reads to be initiated.</span>
   <span class="s0">*/ </span><span class="s1">cacheReady() {</span>
        <span class="s3">return new </span><span class="s1">Promise((resolve)=&gt;{</span>
            <span class="s3">this</span><span class="s1">.listeners.push(resolve);</span>
            <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.count === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s3">this</span><span class="s1">.noMorePendingCaches();</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">beginRead() {</span>
        <span class="s3">this</span><span class="s1">.count++;</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.subscribedSignals !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">subscriber of </span><span class="s3">this</span><span class="s1">.subscribedSignals){</span>
                <span class="s1">subscriber.beginRead();</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">endRead() {</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.count === </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s3">throw </span><span class="s1">Object.defineProperty(</span><span class="s3">new </span><span class="s1">_invarianterror.InvariantError(</span><span class="s2">'CacheSignal got more endRead() calls than beginRead() calls'</span><span class="s1">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                <span class="s1">value: </span><span class="s2">&quot;E678&quot;</span><span class="s1">,</span>
                <span class="s1">enumerable: </span><span class="s3">false</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s3">true</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s0">// If this is the last read we need to wait a task before we can claim the cache is settled.</span>
        <span class="s0">// The cache read will likely ping a Server Component which can read from the cache again and this</span>
        <span class="s0">// will play out in a microtask so we need to only resolve pending listeners if we're still at 0</span>
        <span class="s0">// after at least one task.</span>
        <span class="s0">// We only want one task scheduled at a time so when we hit count 1 we don't decrement the counter immediately.</span>
        <span class="s0">// If intervening reads happen before the scheduled task runs they will never observe count 1 preventing reentrency</span>
        <span class="s3">this</span><span class="s1">.count--;</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.count === </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s3">this</span><span class="s1">.noMorePendingCaches();</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.subscribedSignals !== </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">subscriber of </span><span class="s3">this</span><span class="s1">.subscribedSignals){</span>
                <span class="s1">subscriber.endRead();</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">trackRead(promise) {</span>
        <span class="s3">this</span><span class="s1">.beginRead();</span>
        <span class="s0">// `promise.finally()` still rejects, so don't use it here to avoid unhandled rejections</span>
        <span class="s3">const </span><span class="s1">onFinally = </span><span class="s3">this</span><span class="s1">.endRead.bind(</span><span class="s3">this</span><span class="s1">);</span>
        <span class="s1">promise.then(onFinally, onFinally);</span>
        <span class="s3">return </span><span class="s1">promise;</span>
    <span class="s1">}</span>
    <span class="s1">subscribeToReads(subscriber) {</span>
        <span class="s3">if </span><span class="s1">(subscriber === </span><span class="s3">this</span><span class="s1">) {</span>
            <span class="s3">throw </span><span class="s1">Object.defineProperty(</span><span class="s3">new </span><span class="s1">_invarianterror.InvariantError(</span><span class="s2">'A CacheSignal cannot subscribe to itself'</span><span class="s1">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                <span class="s1">value: </span><span class="s2">&quot;E679&quot;</span><span class="s1">,</span>
                <span class="s1">enumerable: </span><span class="s3">false</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s3">true</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">this</span><span class="s1">.subscribedSignals === </span><span class="s3">null</span><span class="s1">) {</span>
            <span class="s3">this</span><span class="s1">.subscribedSignals = </span><span class="s3">new </span><span class="s1">Set();</span>
        <span class="s1">}</span>
        <span class="s3">this</span><span class="s1">.subscribedSignals.add(subscriber);</span>
        <span class="s0">// we'll notify the subscriber of each endRead() on this signal,</span>
        <span class="s0">// so we need to give it a corresponding beginRead() for each read we have in flight now.</span>
        <span class="s3">for</span><span class="s1">(</span><span class="s3">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; </span><span class="s3">this</span><span class="s1">.count; i++){</span>
            <span class="s1">subscriber.beginRead();</span>
        <span class="s1">}</span>
        <span class="s3">return this</span><span class="s1">.unsubscribeFromReads.bind(</span><span class="s3">this</span><span class="s1">, subscriber);</span>
    <span class="s1">}</span>
    <span class="s1">unsubscribeFromReads(subscriber) {</span>
        <span class="s3">if </span><span class="s1">(!</span><span class="s3">this</span><span class="s1">.subscribedSignals) {</span>
            <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">this</span><span class="s1">.subscribedSignals.delete(subscriber);</span>
    <span class="s0">// we don't need to set the set back to `null` if it's empty --</span>
    <span class="s0">// if other signals are subscribing to this one, it'll likely get more subscriptions later,</span>
    <span class="s0">// so we'd have to allocate a fresh set again when that happens.</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">//# sourceMappingURL=cache-signal.js.map</span></pre>
</body>
</html>