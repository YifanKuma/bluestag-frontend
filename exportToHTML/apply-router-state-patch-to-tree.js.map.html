<html>
<head>
<title>apply-router-state-patch-to-tree.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
apply-router-state-patch-to-tree.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../src/client/components/router-reducer/apply-router-state-patch-to-tree.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type {</span><span class="s3">\n  </span><span class="s1">FlightRouterState,</span><span class="s3">\n  </span><span class="s1">FlightSegmentPath,</span><span class="s3">\n</span><span class="s1">} from '../../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import { DEFAULT_SEGMENT_KEY } from '../../../shared/lib/segment'</span><span class="s3">\n</span><span class="s1">import { getNextFlightSegmentPath } from '../../flight-data-helpers'</span><span class="s3">\n</span><span class="s1">import { matchSegment } from '../match-segments'</span><span class="s3">\n</span><span class="s1">import { addRefreshMarkerToActiveParallelSegments } from './refetch-inactive-parallel-segments'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Deep merge of the two router states. Parallel route keys are preserved if the patch doesn't have them.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function applyPatch(</span><span class="s3">\n  </span><span class="s1">initialTree: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">patchTree: FlightRouterState</span><span class="s3">\n</span><span class="s1">): FlightRouterState {</span><span class="s3">\n  </span><span class="s1">const [initialSegment, initialParallelRoutes] = initialTree</span><span class="s3">\n  </span><span class="s1">const [patchSegment, patchParallelRoutes] = patchTree</span><span class="s3">\n\n  </span><span class="s1">// if the applied patch segment is __DEFAULT__ then it can be ignored in favor of the initial tree</span><span class="s3">\n  </span><span class="s1">// this is because the __DEFAULT__ segment is used as a placeholder on navigation</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">patchSegment === DEFAULT_SEGMENT_KEY &amp;&amp;</span><span class="s3">\n    </span><span class="s1">initialSegment !== DEFAULT_SEGMENT_KEY</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return initialTree</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (matchSegment(initialSegment, patchSegment)) {</span><span class="s3">\n    </span><span class="s1">const newParallelRoutes: FlightRouterState[1] = {}</span><span class="s3">\n    </span><span class="s1">for (const key in initialParallelRoutes) {</span><span class="s3">\n      </span><span class="s1">const isInPatchTreeParallelRoutes =</span><span class="s3">\n        </span><span class="s1">typeof patchParallelRoutes[key] !== 'undefined'</span><span class="s3">\n      </span><span class="s1">if (isInPatchTreeParallelRoutes) {</span><span class="s3">\n        </span><span class="s1">newParallelRoutes[key] = applyPatch(</span><span class="s3">\n          </span><span class="s1">initialParallelRoutes[key],</span><span class="s3">\n          </span><span class="s1">patchParallelRoutes[key]</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">newParallelRoutes[key] = initialParallelRoutes[key]</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const key in patchParallelRoutes) {</span><span class="s3">\n      </span><span class="s1">if (newParallelRoutes[key]) {</span><span class="s3">\n        </span><span class="s1">continue</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">newParallelRoutes[key] = patchParallelRoutes[key]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const tree: FlightRouterState = [initialSegment, newParallelRoutes]</span><span class="s3">\n\n    </span><span class="s1">// Copy over the existing tree</span><span class="s3">\n    </span><span class="s1">if (initialTree[2]) {</span><span class="s3">\n      </span><span class="s1">tree[2] = initialTree[2]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (initialTree[3]) {</span><span class="s3">\n      </span><span class="s1">tree[3] = initialTree[3]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (initialTree[4]) {</span><span class="s3">\n      </span><span class="s1">tree[4] = initialTree[4]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return tree</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return patchTree</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Apply the router state from the Flight response, but skip patching default segments.</span><span class="s3">\n </span><span class="s1">* Useful for patching the router cache when navigating, where we persist the existing default segment if there isn't a new one.</span><span class="s3">\n </span><span class="s1">* Creates a new router state tree.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function applyRouterStatePatchToTree(</span><span class="s3">\n  </span><span class="s1">flightSegmentPath: FlightSegmentPath,</span><span class="s3">\n  </span><span class="s1">flightRouterState: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">treePatch: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">path: string</span><span class="s3">\n</span><span class="s1">): FlightRouterState | null {</span><span class="s3">\n  </span><span class="s1">const [segment, parallelRoutes, url, refetch, isRootLayout] =</span><span class="s3">\n    </span><span class="s1">flightRouterState</span><span class="s3">\n\n  </span><span class="s1">// Root refresh</span><span class="s3">\n  </span><span class="s1">if (flightSegmentPath.length === 1) {</span><span class="s3">\n    </span><span class="s1">const tree: FlightRouterState = applyPatch(flightRouterState, treePatch)</span><span class="s3">\n\n    </span><span class="s1">addRefreshMarkerToActiveParallelSegments(tree, path)</span><span class="s3">\n\n    </span><span class="s1">return tree</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const [currentSegment, parallelRouteKey] = flightSegmentPath</span><span class="s3">\n\n  </span><span class="s1">// Tree path returned from the server should always match up with the current tree in the browser</span><span class="s3">\n  </span><span class="s1">if (!matchSegment(currentSegment, segment)) {</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const lastSegment = flightSegmentPath.length === 2</span><span class="s3">\n\n  </span><span class="s1">let parallelRoutePatch</span><span class="s3">\n  </span><span class="s1">if (lastSegment) {</span><span class="s3">\n    </span><span class="s1">parallelRoutePatch = applyPatch(parallelRoutes[parallelRouteKey], treePatch)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">parallelRoutePatch = applyRouterStatePatchToTree(</span><span class="s3">\n      </span><span class="s1">getNextFlightSegmentPath(flightSegmentPath),</span><span class="s3">\n      </span><span class="s1">parallelRoutes[parallelRouteKey],</span><span class="s3">\n      </span><span class="s1">treePatch,</span><span class="s3">\n      </span><span class="s1">path</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">if (parallelRoutePatch === null) {</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const tree: FlightRouterState = [</span><span class="s3">\n    </span><span class="s1">flightSegmentPath[0],</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">...parallelRoutes,</span><span class="s3">\n      </span><span class="s1">[parallelRouteKey]: parallelRoutePatch,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">url,</span><span class="s3">\n    </span><span class="s1">refetch,</span><span class="s3">\n  </span><span class="s1">]</span><span class="s3">\n\n  </span><span class="s1">// Current segment is the root layout</span><span class="s3">\n  </span><span class="s1">if (isRootLayout) {</span><span class="s3">\n    </span><span class="s1">tree[4] = true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">addRefreshMarkerToActiveParallelSegments(tree, path)</span><span class="s3">\n\n  </span><span class="s1">return tree</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;applyRouterStatePatchToTree&quot;</span><span class="s0">,</span><span class="s1">&quot;applyPatch&quot;</span><span class="s0">,</span><span class="s1">&quot;initialTree&quot;</span><span class="s0">,</span><span class="s1">&quot;patchTree&quot;</span><span class="s0">,</span><span class="s1">&quot;initialSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;initialParallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;patchSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;patchParallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;DEFAULT_SEGMENT_KEY&quot;</span><span class="s0">,</span><span class="s1">&quot;matchSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;newParallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;isInPatchTreeParallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;flightSegmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;flightRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;treePatch&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;refetch&quot;</span><span class="s0">,</span><span class="s1">&quot;isRootLayout&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;addRefreshMarkerToActiveParallelSegments&quot;</span><span class="s0">,</span><span class="s1">&quot;currentSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRouteKey&quot;</span><span class="s0">,</span><span class="s1">&quot;lastSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutePatch&quot;</span><span class="s0">,</span><span class="s1">&quot;getNextFlightSegmentPath&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;+BA6EgBA;;;eAAAA;;;yBAzEoB;mCACK;+BACZ;iDAC4B;AAEzD;;CAEC,GACD,SAASC,WACPC,WAA8B,EAC9BC,SAA4B;IAE5B,MAAM,CAACC,gBAAgBC,sBAAsB,GAAGH;IAChD,MAAM,CAACI,cAAcC,oBAAoB,GAAGJ;IAE5C,kGAAkG;IAClG,iFAAiF;IACjF,IACEG,iBAAiBE,4BAAmB,IACpCJ,mBAAmBI,4BAAmB,EACtC;QACA,OAAON;IACT;IAEA,IAAIO,IAAAA,2BAAY,EAACL,gBAAgBE,eAAe;QAC9C,MAAMI,oBAA0C,CAAC;QACjD,IAAK,MAAMC,OAAON,sBAAuB;YACvC,MAAMO,8BACJ,OAAOL,mBAAmB,CAACI,IAAI,KAAK;YACtC,IAAIC,6BAA6B;gBAC/BF,iBAAiB,CAACC,IAAI,GAAGV,WACvBI,qBAAqB,CAACM,IAAI,EAC1BJ,mBAAmB,CAACI,IAAI;YAE5B,OAAO;gBACLD,iBAAiB,CAACC,IAAI,GAAGN,qBAAqB,CAACM,IAAI;YACrD;QACF;QAEA,IAAK,MAAMA,OAAOJ,oBAAqB;YACrC,IAAIG,iBAAiB,CAACC,IAAI,EAAE;gBAC1B;YACF;YAEAD,iBAAiB,CAACC,IAAI,GAAGJ,mBAAmB,CAACI,IAAI;QACnD;QAEA,MAAME,OAA0B;YAACT;YAAgBM;SAAkB;QAEnE,8BAA8B;QAC9B,IAAIR,WAAW,CAAC,EAAE,EAAE;YAClBW,IAAI,CAAC,EAAE,GAAGX,WAAW,CAAC,EAAE;QAC1B;QAEA,IAAIA,WAAW,CAAC,EAAE,EAAE;YAClBW,IAAI,CAAC,EAAE,GAAGX,WAAW,CAAC,EAAE;QAC1B;QAEA,IAAIA,WAAW,CAAC,EAAE,EAAE;YAClBW,IAAI,CAAC,EAAE,GAAGX,WAAW,CAAC,EAAE;QAC1B;QAEA,OAAOW;IACT;IAEA,OAAOV;AACT;AAOO,SAASH,4BACdc,iBAAoC,EACpCC,iBAAoC,EACpCC,SAA4B,EAC5BC,IAAY;IAEZ,MAAM,CAACC,SAASC,gBAAgBC,KAAKC,SAASC,aAAa,GACzDP;IAEF,eAAe;IACf,IAAID,kBAAkBS,MAAM,KAAK,GAAG;QAClC,MAAMV,OAA0BZ,WAAWc,mBAAmBC;QAE9DQ,IAAAA,yEAAwC,EAACX,MAAMI;QAE/C,OAAOJ;IACT;IAEA,MAAM,CAACY,gBAAgBC,iBAAiB,GAAGZ;IAE3C,iGAAiG;IACjG,IAAI,CAACL,IAAAA,2BAAY,EAACgB,gBAAgBP,UAAU;QAC1C,OAAO;IACT;IAEA,MAAMS,cAAcb,kBAAkBS,MAAM,KAAK;IAEjD,IAAIK;IACJ,IAAID,aAAa;QACfC,qBAAqB3B,WAAWkB,cAAc,CAACO,iBAAiB,EAAEV;IACpE,OAAO;QACLY,qBAAqB5B,4BACnB6B,IAAAA,2CAAwB,EAACf,oBACzBK,cAAc,CAACO,iBAAiB,EAChCV,WACAC;QAGF,IAAIW,uBAAuB,MAAM;YAC/B,OAAO;QACT;IACF;IAEA,MAAMf,OAA0B;QAC9BC,iBAAiB,CAAC,EAAE;QACpB;YACE,GAAGK,cAAc;YACjB,CAACO,iBAAiB,EAAEE;QACtB;QACAR;QACAC;KACD;IAED,qCAAqC;IACrC,IAAIC,cAAc;QAChBT,IAAI,CAAC,EAAE,GAAG;IACZ;IAEAW,IAAAA,yEAAwC,EAACX,MAAMI;IAE/C,OAAOJ;AACT&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>