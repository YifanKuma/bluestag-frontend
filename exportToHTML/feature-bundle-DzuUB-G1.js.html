<html>
<head>
<title>feature-bundle-DzuUB-G1.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #1750eb;}
.s6 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
feature-bundle-DzuUB-G1.js</font>
</center></td></tr></table>
<pre><span class="s0">'use strict'</span><span class="s1">;</span>

<span class="s2">var </span><span class="s1">React = require(</span><span class="s0">'react'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">motionDom = require(</span><span class="s0">'motion-dom'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">motionUtils = require(</span><span class="s0">'motion-utils'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">jsxRuntime = require(</span><span class="s0">'react/jsx-runtime'</span><span class="s1">);</span>

<span class="s2">const </span><span class="s1">LayoutGroupContext = React.createContext({});</span>

<span class="s3">/**</span>
 <span class="s3">* Creates a constant value over the lifecycle of a component.</span>
 <span class="s3">*</span>
 <span class="s3">* Even if `useMemo` is provided an empty array as its final argument, it doesn't offer</span>
 <span class="s3">* a guarantee that it won't re-run for performance reasons later on. By using `useConstant`</span>
 <span class="s3">* you can ensure that initialisers don't execute twice or more.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">useConstant(init) {</span>
    <span class="s2">const </span><span class="s1">ref = React.useRef(</span><span class="s2">null</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(ref.current === </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">ref.current = init();</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">ref.current;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">isBrowser = </span><span class="s2">typeof </span><span class="s1">window !== </span><span class="s0">&quot;undefined&quot;</span><span class="s1">;</span>

<span class="s2">const </span><span class="s1">useIsomorphicLayoutEffect = isBrowser ? React.useLayoutEffect : React.useEffect;</span>

<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@public</span>
 <span class="s3">*/</span>
<span class="s2">const </span><span class="s1">PresenceContext = </span>
<span class="s3">/* @__PURE__ */ </span><span class="s1">React.createContext(</span><span class="s2">null</span><span class="s1">);</span>

<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@public</span>
 <span class="s3">*/</span>
<span class="s2">const </span><span class="s1">MotionConfigContext = React.createContext({</span>
    <span class="s1">transformPagePoint: (p) =&gt; p,</span>
    <span class="s1">isStatic: </span><span class="s2">false</span><span class="s1">,</span>
    <span class="s1">reducedMotion: </span><span class="s0">&quot;never&quot;</span><span class="s1">,</span>
<span class="s1">});</span>

<span class="s3">/**</span>
 <span class="s3">* When a component is the child of `AnimatePresence`, it can use `usePresence`</span>
 <span class="s3">* to access information about whether it's still present in the React tree.</span>
 <span class="s3">*</span>
 <span class="s3">* ```jsx</span>
 <span class="s3">* import { usePresence } from &quot;framer-motion&quot;</span>
 <span class="s3">*</span>
 <span class="s3">* export const Component = () =&gt; {</span>
 <span class="s3">*   const [isPresent, safeToRemove] = usePresence()</span>
 <span class="s3">*</span>
 <span class="s3">*   useEffect(() =&gt; {</span>
 <span class="s3">*     !isPresent &amp;&amp; setTimeout(safeToRemove, 1000)</span>
 <span class="s3">*   }, [isPresent])</span>
 <span class="s3">*</span>
 <span class="s3">*   return &lt;div /&gt;</span>
 <span class="s3">* }</span>
 <span class="s3">* ```</span>
 <span class="s3">*</span>
 <span class="s3">* If `isPresent` is `false`, it means that a component has been removed the tree, but</span>
 <span class="s3">* `AnimatePresence` won't really remove it until `safeToRemove` has been called.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">@public</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">usePresence(subscribe = </span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s2">const </span><span class="s1">context = React.useContext(PresenceContext);</span>
    <span class="s2">if </span><span class="s1">(context === </span><span class="s2">null</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">[</span><span class="s2">true</span><span class="s1">, </span><span class="s2">null</span><span class="s1">];</span>
    <span class="s2">const </span><span class="s1">{ isPresent, onExitComplete, register } = context;</span>
    <span class="s3">// It's safe to call the following hooks conditionally (after an early return) because the context will always</span>
    <span class="s3">// either be null or non-null for the lifespan of the component.</span>
    <span class="s2">const </span><span class="s1">id = React.useId();</span>
    <span class="s1">React.useEffect(() =&gt; {</span>
        <span class="s2">if </span><span class="s1">(subscribe) {</span>
            <span class="s2">return </span><span class="s1">register(id);</span>
        <span class="s1">}</span>
    <span class="s1">}, [subscribe]);</span>
    <span class="s2">const </span><span class="s1">safeToRemove = React.useCallback(() =&gt; subscribe &amp;&amp; onExitComplete &amp;&amp; onExitComplete(id), [id, onExitComplete, subscribe]);</span>
    <span class="s2">return </span><span class="s1">!isPresent &amp;&amp; onExitComplete ? [</span><span class="s2">false</span><span class="s1">, safeToRemove] : [</span><span class="s2">true</span><span class="s1">];</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Similar to `usePresence`, except `useIsPresent` simply returns whether or not the component is present.</span>
 <span class="s3">* There is no `safeToRemove` function.</span>
 <span class="s3">*</span>
 <span class="s3">* ```jsx</span>
 <span class="s3">* import { useIsPresent } from &quot;framer-motion&quot;</span>
 <span class="s3">*</span>
 <span class="s3">* export const Component = () =&gt; {</span>
 <span class="s3">*   const isPresent = useIsPresent()</span>
 <span class="s3">*</span>
 <span class="s3">*   useEffect(() =&gt; {</span>
 <span class="s3">*     !isPresent &amp;&amp; console.log(&quot;I've been removed!&quot;)</span>
 <span class="s3">*   }, [isPresent])</span>
 <span class="s3">*</span>
 <span class="s3">*   return &lt;div /&gt;</span>
 <span class="s3">* }</span>
 <span class="s3">* ```</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">@public</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">useIsPresent() {</span>
    <span class="s2">return </span><span class="s1">isPresent(React.useContext(PresenceContext));</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isPresent(context) {</span>
    <span class="s2">return </span><span class="s1">context === </span><span class="s2">null </span><span class="s1">? </span><span class="s2">true </span><span class="s1">: context.isPresent;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">SCALE_PRECISION = </span><span class="s5">0.0001</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">SCALE_MIN = </span><span class="s5">1 </span><span class="s1">- SCALE_PRECISION;</span>
<span class="s2">const </span><span class="s1">SCALE_MAX = </span><span class="s5">1 </span><span class="s1">+ SCALE_PRECISION;</span>
<span class="s2">const </span><span class="s1">TRANSLATE_PRECISION = </span><span class="s5">0.01</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">TRANSLATE_MIN = </span><span class="s5">0 </span><span class="s1">- TRANSLATE_PRECISION;</span>
<span class="s2">const </span><span class="s1">TRANSLATE_MAX = </span><span class="s5">0 </span><span class="s1">+ TRANSLATE_PRECISION;</span>
<span class="s2">function </span><span class="s1">calcLength(axis) {</span>
    <span class="s2">return </span><span class="s1">axis.max - axis.min;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isNear(value, target, maxDistance) {</span>
    <span class="s2">return </span><span class="s1">Math.abs(value - target) &lt;= maxDistance;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">calcAxisDelta(delta, source, target, origin = </span><span class="s5">0.5</span><span class="s1">) {</span>
    <span class="s1">delta.origin = origin;</span>
    <span class="s1">delta.originPoint = motionDom.mixNumber(source.min, source.max, delta.origin);</span>
    <span class="s1">delta.scale = calcLength(target) / calcLength(source);</span>
    <span class="s1">delta.translate =</span>
        <span class="s1">motionDom.mixNumber(target.min, target.max, delta.origin) - delta.originPoint;</span>
    <span class="s2">if </span><span class="s1">((delta.scale &gt;= SCALE_MIN &amp;&amp; delta.scale &lt;= SCALE_MAX) ||</span>
        <span class="s1">isNaN(delta.scale)) {</span>
        <span class="s1">delta.scale = </span><span class="s5">1.0</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">((delta.translate &gt;= TRANSLATE_MIN &amp;&amp;</span>
        <span class="s1">delta.translate &lt;= TRANSLATE_MAX) ||</span>
        <span class="s1">isNaN(delta.translate)) {</span>
        <span class="s1">delta.translate = </span><span class="s5">0.0</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">calcBoxDelta(delta, source, target, origin) {</span>
    <span class="s1">calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : undefined);</span>
    <span class="s1">calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : undefined);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">calcRelativeAxis(target, relative, parent) {</span>
    <span class="s1">target.min = parent.min + relative.min;</span>
    <span class="s1">target.max = target.min + calcLength(relative);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">calcRelativeBox(target, relative, parent) {</span>
    <span class="s1">calcRelativeAxis(target.x, relative.x, parent.x);</span>
    <span class="s1">calcRelativeAxis(target.y, relative.y, parent.y);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">calcRelativeAxisPosition(target, layout, parent) {</span>
    <span class="s1">target.min = layout.min - parent.min;</span>
    <span class="s1">target.max = target.min + calcLength(layout);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">calcRelativePosition(target, layout, parent) {</span>
    <span class="s1">calcRelativeAxisPosition(target.x, layout.x, parent.x);</span>
    <span class="s1">calcRelativeAxisPosition(target.y, layout.y, parent.y);</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">isNotNull = (value) =&gt; value !== </span><span class="s2">null</span><span class="s1">;</span>
<span class="s2">function </span><span class="s1">getFinalKeyframe(keyframes, { repeat, repeatType = </span><span class="s0">&quot;loop&quot; </span><span class="s1">}, finalKeyframe) {</span>
    <span class="s2">const </span><span class="s1">resolvedKeyframes = keyframes.filter(isNotNull);</span>
    <span class="s2">const </span><span class="s1">index = repeat &amp;&amp; repeatType !== </span><span class="s0">&quot;loop&quot; </span><span class="s1">&amp;&amp; repeat % </span><span class="s5">2 </span><span class="s1">=== </span><span class="s5">1</span>
        <span class="s1">? </span><span class="s5">0</span>
        <span class="s1">: resolvedKeyframes.length - </span><span class="s5">1</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">!index || finalKeyframe === undefined</span>
        <span class="s1">? resolvedKeyframes[index]</span>
        <span class="s1">: finalKeyframe;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">underDampedSpring = {</span>
    <span class="s1">type: </span><span class="s0">&quot;spring&quot;</span><span class="s1">,</span>
    <span class="s1">stiffness: </span><span class="s5">500</span><span class="s1">,</span>
    <span class="s1">damping: </span><span class="s5">25</span><span class="s1">,</span>
    <span class="s1">restSpeed: </span><span class="s5">10</span><span class="s1">,</span>
<span class="s1">};</span>
<span class="s2">const </span><span class="s1">criticallyDampedSpring = (target) =&gt; ({</span>
    <span class="s1">type: </span><span class="s0">&quot;spring&quot;</span><span class="s1">,</span>
    <span class="s1">stiffness: </span><span class="s5">550</span><span class="s1">,</span>
    <span class="s1">damping: target === </span><span class="s5">0 </span><span class="s1">? </span><span class="s5">2 </span><span class="s1">* Math.sqrt(</span><span class="s5">550</span><span class="s1">) : </span><span class="s5">30</span><span class="s1">,</span>
    <span class="s1">restSpeed: </span><span class="s5">10</span><span class="s1">,</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">keyframesTransition = {</span>
    <span class="s1">type: </span><span class="s0">&quot;keyframes&quot;</span><span class="s1">,</span>
    <span class="s1">duration: </span><span class="s5">0.8</span><span class="s1">,</span>
<span class="s1">};</span>
<span class="s3">/**</span>
 <span class="s3">* Default easing curve is a slightly shallower version of</span>
 <span class="s3">* the default browser easing curve.</span>
 <span class="s3">*/</span>
<span class="s2">const </span><span class="s1">ease = {</span>
    <span class="s1">type: </span><span class="s0">&quot;keyframes&quot;</span><span class="s1">,</span>
    <span class="s1">ease: [</span><span class="s5">0.25</span><span class="s1">, </span><span class="s5">0.1</span><span class="s1">, </span><span class="s5">0.35</span><span class="s1">, </span><span class="s5">1</span><span class="s1">],</span>
    <span class="s1">duration: </span><span class="s5">0.3</span><span class="s1">,</span>
<span class="s1">};</span>
<span class="s2">const </span><span class="s1">getDefaultTransition = (valueKey, { keyframes }) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(keyframes.length &gt; </span><span class="s5">2</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">keyframesTransition;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(motionDom.transformProps.has(valueKey)) {</span>
        <span class="s2">return </span><span class="s1">valueKey.startsWith(</span><span class="s0">&quot;scale&quot;</span><span class="s1">)</span>
            <span class="s1">? criticallyDampedSpring(keyframes[</span><span class="s5">1</span><span class="s1">])</span>
            <span class="s1">: underDampedSpring;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">ease;</span>
<span class="s1">};</span>

<span class="s3">/**</span>
 <span class="s3">* Decide whether a transition is defined on a given Transition.</span>
 <span class="s3">* This filters out orchestration options and returns true</span>
 <span class="s3">* if any options are left.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {</span>
    <span class="s2">return </span><span class="s1">!!Object.keys(transition).length;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">animateMotionValue = (name, value, target, transition = {}, element, isHandoff) =&gt; (onComplete) =&gt; {</span>
    <span class="s2">const </span><span class="s1">valueTransition = motionDom.getValueTransition(transition, name) || {};</span>
    <span class="s3">/**</span>
     <span class="s3">* Most transition values are currently completely overwritten by value-specific</span>
     <span class="s3">* transitions. In the future it'd be nicer to blend these transitions. But for now</span>
     <span class="s3">* delay actually does inherit from the root transition if not value-specific.</span>
     <span class="s3">*/</span>
    <span class="s2">const </span><span class="s1">delay = valueTransition.delay || transition.delay || </span><span class="s5">0</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* Elapsed isn't a public transition option but can be passed through from</span>
     <span class="s3">* optimized appear effects in milliseconds.</span>
     <span class="s3">*/</span>
    <span class="s2">let </span><span class="s1">{ elapsed = </span><span class="s5">0 </span><span class="s1">} = transition;</span>
    <span class="s1">elapsed = elapsed - motionUtils.secondsToMilliseconds(delay);</span>
    <span class="s2">const </span><span class="s1">options = {</span>
        <span class="s1">keyframes: Array.isArray(target) ? target : [</span><span class="s2">null</span><span class="s1">, target],</span>
        <span class="s1">ease: </span><span class="s0">&quot;easeOut&quot;</span><span class="s1">,</span>
        <span class="s1">velocity: value.getVelocity(),</span>
        <span class="s1">...valueTransition,</span>
        <span class="s1">delay: -elapsed,</span>
        <span class="s1">onUpdate: (v) =&gt; {</span>
            <span class="s1">value.set(v);</span>
            <span class="s1">valueTransition.onUpdate &amp;&amp; valueTransition.onUpdate(v);</span>
        <span class="s1">},</span>
        <span class="s1">onComplete: () =&gt; {</span>
            <span class="s1">onComplete();</span>
            <span class="s1">valueTransition.onComplete &amp;&amp; valueTransition.onComplete();</span>
        <span class="s1">},</span>
        <span class="s1">name,</span>
        <span class="s1">motionValue: value,</span>
        <span class="s1">element: isHandoff ? undefined : element,</span>
    <span class="s1">};</span>
    <span class="s3">/**</span>
     <span class="s3">* If there's no transition defined for this value, we can generate</span>
     <span class="s3">* unique transition settings for this value.</span>
     <span class="s3">*/</span>
    <span class="s2">if </span><span class="s1">(!isTransitionDefined(valueTransition)) {</span>
        <span class="s1">Object.assign(options, getDefaultTransition(name, options));</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Both WAAPI and our internal animation functions use durations</span>
     <span class="s3">* as defined by milliseconds, while our external API defines them</span>
     <span class="s3">* as seconds.</span>
     <span class="s3">*/</span>
    <span class="s1">options.duration &amp;&amp; (options.duration = motionUtils.secondsToMilliseconds(options.duration));</span>
    <span class="s1">options.repeatDelay &amp;&amp; (options.repeatDelay = motionUtils.secondsToMilliseconds(options.repeatDelay));</span>
    <span class="s3">/**</span>
     <span class="s3">* Support deprecated way to set initial value. Prefer keyframe syntax.</span>
     <span class="s3">*/</span>
    <span class="s2">if </span><span class="s1">(options.from !== undefined) {</span>
        <span class="s1">options.keyframes[</span><span class="s5">0</span><span class="s1">] = options.from;</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">shouldSkip = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(options.type === </span><span class="s2">false </span><span class="s1">||</span>
        <span class="s1">(options.duration === </span><span class="s5">0 </span><span class="s1">&amp;&amp; !options.repeatDelay)) {</span>
        <span class="s1">motionDom.makeAnimationInstant(options);</span>
        <span class="s2">if </span><span class="s1">(options.delay === </span><span class="s5">0</span><span class="s1">) {</span>
            <span class="s1">shouldSkip = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(motionUtils.MotionGlobalConfig.instantAnimations ||</span>
        <span class="s1">motionUtils.MotionGlobalConfig.skipAnimations) {</span>
        <span class="s1">shouldSkip = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">motionDom.makeAnimationInstant(options);</span>
        <span class="s1">options.delay = </span><span class="s5">0</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* If the transition type or easing has been explicitly set by the user</span>
     <span class="s3">* then we don't want to allow flattening the animation.</span>
     <span class="s3">*/</span>
    <span class="s1">options.allowFlatten = !valueTransition.type &amp;&amp; !valueTransition.ease;</span>
    <span class="s3">/**</span>
     <span class="s3">* If we can or must skip creating the animation, and apply only</span>
     <span class="s3">* the final keyframe, do so. We also check once keyframes are resolved but</span>
     <span class="s3">* this early check prevents the need to create an animation at all.</span>
     <span class="s3">*/</span>
    <span class="s2">if </span><span class="s1">(shouldSkip &amp;&amp; !isHandoff &amp;&amp; value.get() !== undefined) {</span>
        <span class="s2">const </span><span class="s1">finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);</span>
        <span class="s2">if </span><span class="s1">(finalKeyframe !== undefined) {</span>
            <span class="s1">motionDom.frame.update(() =&gt; {</span>
                <span class="s1">options.onUpdate(finalKeyframe);</span>
                <span class="s1">options.onComplete();</span>
            <span class="s1">});</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">valueTransition.isSync</span>
        <span class="s1">? </span><span class="s2">new </span><span class="s1">motionDom.JSAnimation(options)</span>
        <span class="s1">: </span><span class="s2">new </span><span class="s1">motionDom.AsyncMotionValueAnimation(options);</span>
<span class="s1">};</span>

<span class="s2">function </span><span class="s1">animateSingleValue(value, keyframes, options) {</span>
    <span class="s2">const </span><span class="s1">motionValue = motionDom.isMotionValue(value) ? value : motionDom.motionValue(value);</span>
    <span class="s1">motionValue.start(animateMotionValue(</span><span class="s0">&quot;&quot;</span><span class="s1">, motionValue, keyframes, options));</span>
    <span class="s2">return </span><span class="s1">motionValue.animation;</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Convert camelCase to dash-case properties.</span>
 <span class="s3">*/</span>
<span class="s2">const </span><span class="s1">camelToDash = (str) =&gt; str.replace(</span><span class="s6">/([a-z])([A-Z])/gu</span><span class="s1">, </span><span class="s0">&quot;$1-$2&quot;</span><span class="s1">).toLowerCase();</span>

<span class="s2">const </span><span class="s1">optimizedAppearDataId = </span><span class="s0">&quot;framerAppearId&quot;</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">optimizedAppearDataAttribute = </span><span class="s0">&quot;data-&quot; </span><span class="s1">+ camelToDash(optimizedAppearDataId);</span>

<span class="s2">function </span><span class="s1">getOptimisedAppearId(visualElement) {</span>
    <span class="s2">return </span><span class="s1">visualElement.props[optimizedAppearDataAttribute];</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">compareByDepth = (a, b) =&gt; a.depth - b.depth;</span>

<span class="s2">class </span><span class="s1">FlatTree {</span>
    <span class="s1">constructor() {</span>
        <span class="s2">this</span><span class="s1">.children = [];</span>
        <span class="s2">this</span><span class="s1">.isDirty = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">add(child) {</span>
        <span class="s1">motionUtils.addUniqueItem(</span><span class="s2">this</span><span class="s1">.children, child);</span>
        <span class="s2">this</span><span class="s1">.isDirty = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">remove(child) {</span>
        <span class="s1">motionUtils.removeItem(</span><span class="s2">this</span><span class="s1">.children, child);</span>
        <span class="s2">this</span><span class="s1">.isDirty = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">forEach(callback) {</span>
        <span class="s2">this</span><span class="s1">.isDirty &amp;&amp; </span><span class="s2">this</span><span class="s1">.children.sort(compareByDepth);</span>
        <span class="s2">this</span><span class="s1">.isDirty = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.children.forEach(callback);</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Timeout defined in ms</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">delay(callback, timeout) {</span>
    <span class="s2">const </span><span class="s1">start = motionDom.time.now();</span>
    <span class="s2">const </span><span class="s1">checkElapsed = ({ timestamp }) =&gt; {</span>
        <span class="s2">const </span><span class="s1">elapsed = timestamp - start;</span>
        <span class="s2">if </span><span class="s1">(elapsed &gt;= timeout) {</span>
            <span class="s1">motionDom.cancelFrame(checkElapsed);</span>
            <span class="s1">callback(elapsed - timeout);</span>
        <span class="s1">}</span>
    <span class="s1">};</span>
    <span class="s1">motionDom.frame.setup(checkElapsed, </span><span class="s2">true</span><span class="s1">);</span>
    <span class="s2">return </span><span class="s1">() =&gt; motionDom.cancelFrame(checkElapsed);</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself</span>
 <span class="s3">*</span>
 <span class="s3">* TODO: Remove and move to library</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">resolveMotionValue(value) {</span>
    <span class="s2">return </span><span class="s1">motionDom.isMotionValue(value) ? value.get() : value;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">borders = [</span><span class="s0">&quot;TopLeft&quot;</span><span class="s1">, </span><span class="s0">&quot;TopRight&quot;</span><span class="s1">, </span><span class="s0">&quot;BottomLeft&quot;</span><span class="s1">, </span><span class="s0">&quot;BottomRight&quot;</span><span class="s1">];</span>
<span class="s2">const </span><span class="s1">numBorders = borders.length;</span>
<span class="s2">const </span><span class="s1">asNumber = (value) =&gt; </span><span class="s2">typeof </span><span class="s1">value === </span><span class="s0">&quot;string&quot; </span><span class="s1">? parseFloat(value) : value;</span>
<span class="s2">const </span><span class="s1">isPx = (value) =&gt; </span><span class="s2">typeof </span><span class="s1">value === </span><span class="s0">&quot;number&quot; </span><span class="s1">|| motionDom.px.test(value);</span>
<span class="s2">function </span><span class="s1">mixValues(target, follow, lead, progress, shouldCrossfadeOpacity, isOnlyMember) {</span>
    <span class="s2">if </span><span class="s1">(shouldCrossfadeOpacity) {</span>
        <span class="s1">target.opacity = motionDom.mixNumber(</span><span class="s5">0</span><span class="s1">, lead.opacity ?? </span><span class="s5">1</span><span class="s1">, easeCrossfadeIn(progress));</span>
        <span class="s1">target.opacityExit = motionDom.mixNumber(follow.opacity ?? </span><span class="s5">1</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, easeCrossfadeOut(progress));</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(isOnlyMember) {</span>
        <span class="s1">target.opacity = motionDom.mixNumber(follow.opacity ?? </span><span class="s5">1</span><span class="s1">, lead.opacity ?? </span><span class="s5">1</span><span class="s1">, progress);</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Mix border radius</span>
     <span class="s3">*/</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; numBorders; i++) {</span>
        <span class="s2">const </span><span class="s1">borderLabel = </span><span class="s0">`border</span><span class="s1">${borders[i]}</span><span class="s0">Radius`</span><span class="s1">;</span>
        <span class="s2">let </span><span class="s1">followRadius = getRadius(follow, borderLabel);</span>
        <span class="s2">let </span><span class="s1">leadRadius = getRadius(lead, borderLabel);</span>
        <span class="s2">if </span><span class="s1">(followRadius === undefined &amp;&amp; leadRadius === undefined)</span>
            <span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">followRadius || (followRadius = </span><span class="s5">0</span><span class="s1">);</span>
        <span class="s1">leadRadius || (leadRadius = </span><span class="s5">0</span><span class="s1">);</span>
        <span class="s2">const </span><span class="s1">canMix = followRadius === </span><span class="s5">0 </span><span class="s1">||</span>
            <span class="s1">leadRadius === </span><span class="s5">0 </span><span class="s1">||</span>
            <span class="s1">isPx(followRadius) === isPx(leadRadius);</span>
        <span class="s2">if </span><span class="s1">(canMix) {</span>
            <span class="s1">target[borderLabel] = Math.max(motionDom.mixNumber(asNumber(followRadius), asNumber(leadRadius), progress), </span><span class="s5">0</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(motionDom.percent.test(leadRadius) || motionDom.percent.test(followRadius)) {</span>
                <span class="s1">target[borderLabel] += </span><span class="s0">&quot;%&quot;</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">target[borderLabel] = leadRadius;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Mix rotation</span>
     <span class="s3">*/</span>
    <span class="s2">if </span><span class="s1">(follow.rotate || lead.rotate) {</span>
        <span class="s1">target.rotate = motionDom.mixNumber(follow.rotate || </span><span class="s5">0</span><span class="s1">, lead.rotate || </span><span class="s5">0</span><span class="s1">, progress);</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getRadius(values, radiusName) {</span>
    <span class="s2">return </span><span class="s1">values[radiusName] !== undefined</span>
        <span class="s1">? values[radiusName]</span>
        <span class="s1">: values.borderRadius;</span>
<span class="s1">}</span>
<span class="s3">// /**</span>
<span class="s3">//  * We only want to mix the background color if there's a follow element</span>
<span class="s3">//  * that we're not crossfading opacity between. For instance with switch</span>
<span class="s3">//  * AnimateSharedLayout animations, this helps the illusion of a continuous</span>
<span class="s3">//  * element being animated but also cuts down on the number of paints triggered</span>
<span class="s3">//  * for elements where opacity is doing that work for us.</span>
<span class="s3">//  */</span>
<span class="s3">// if (</span>
<span class="s3">//     !hasFollowElement &amp;&amp;</span>
<span class="s3">//     latestLeadValues.backgroundColor &amp;&amp;</span>
<span class="s3">//     latestFollowValues.backgroundColor</span>
<span class="s3">// ) {</span>
<span class="s3">//     /**</span>
<span class="s3">//      * This isn't ideal performance-wise as mixColor is creating a new function every frame.</span>
<span class="s3">//      * We could probably create a mixer that runs at the start of the animation but</span>
<span class="s3">//      * the idea behind the crossfader is that it runs dynamically between two potentially</span>
<span class="s3">//      * changing targets (ie opacity or borderRadius may be animating independently via variants)</span>
<span class="s3">//      */</span>
<span class="s3">//     leadState.backgroundColor = followState.backgroundColor = mixColor(</span>
<span class="s3">//         latestFollowValues.backgroundColor as string,</span>
<span class="s3">//         latestLeadValues.backgroundColor as string</span>
<span class="s3">//     )(p)</span>
<span class="s3">// }</span>
<span class="s2">const </span><span class="s1">easeCrossfadeIn = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">compress(</span><span class="s5">0</span><span class="s1">, </span><span class="s5">0.5</span><span class="s1">, motionUtils.circOut);</span>
<span class="s2">const </span><span class="s1">easeCrossfadeOut = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">compress(</span><span class="s5">0.5</span><span class="s1">, </span><span class="s5">0.95</span><span class="s1">, motionUtils.noop);</span>
<span class="s2">function </span><span class="s1">compress(min, max, easing) {</span>
    <span class="s2">return </span><span class="s1">(p) =&gt; {</span>
        <span class="s3">// Could replace ifs with clamp</span>
        <span class="s2">if </span><span class="s1">(p &lt; min)</span>
            <span class="s2">return </span><span class="s5">0</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(p &gt; max)</span>
            <span class="s2">return </span><span class="s5">1</span><span class="s1">;</span>
        <span class="s2">return </span><span class="s1">easing(motionUtils.progress(min, max, p));</span>
    <span class="s1">};</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Reset an axis to the provided origin box.</span>
 <span class="s3">*</span>
 <span class="s3">* This is a mutative operation.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">copyAxisInto(axis, originAxis) {</span>
    <span class="s1">axis.min = originAxis.min;</span>
    <span class="s1">axis.max = originAxis.max;</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Reset a box to the provided origin box.</span>
 <span class="s3">*</span>
 <span class="s3">* This is a mutative operation.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">copyBoxInto(box, originBox) {</span>
    <span class="s1">copyAxisInto(box.x, originBox.x);</span>
    <span class="s1">copyAxisInto(box.y, originBox.y);</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Reset a delta to the provided origin box.</span>
 <span class="s3">*</span>
 <span class="s3">* This is a mutative operation.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">copyAxisDeltaInto(delta, originDelta) {</span>
    <span class="s1">delta.translate = originDelta.translate;</span>
    <span class="s1">delta.scale = originDelta.scale;</span>
    <span class="s1">delta.originPoint = originDelta.originPoint;</span>
    <span class="s1">delta.origin = originDelta.origin;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">isIdentityScale(scale) {</span>
    <span class="s2">return </span><span class="s1">scale === undefined || scale === </span><span class="s5">1</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">hasScale({ scale, scaleX, scaleY }) {</span>
    <span class="s2">return </span><span class="s1">(!isIdentityScale(scale) ||</span>
        <span class="s1">!isIdentityScale(scaleX) ||</span>
        <span class="s1">!isIdentityScale(scaleY));</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">hasTransform(values) {</span>
    <span class="s2">return </span><span class="s1">(hasScale(values) ||</span>
        <span class="s1">has2DTranslate(values) ||</span>
        <span class="s1">values.z ||</span>
        <span class="s1">values.rotate ||</span>
        <span class="s1">values.rotateX ||</span>
        <span class="s1">values.rotateY ||</span>
        <span class="s1">values.skewX ||</span>
        <span class="s1">values.skewY);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">has2DTranslate(values) {</span>
    <span class="s2">return </span><span class="s1">is2DTranslate(values.x) || is2DTranslate(values.y);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">is2DTranslate(value) {</span>
    <span class="s2">return </span><span class="s1">value &amp;&amp; value !== </span><span class="s0">&quot;0%&quot;</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Scales a point based on a factor and an originPoint</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">scalePoint(point, scale, originPoint) {</span>
    <span class="s2">const </span><span class="s1">distanceFromOrigin = point - originPoint;</span>
    <span class="s2">const </span><span class="s1">scaled = scale * distanceFromOrigin;</span>
    <span class="s2">return </span><span class="s1">originPoint + scaled;</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Applies a translate/scale delta to a point</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">applyPointDelta(point, translate, scale, originPoint, boxScale) {</span>
    <span class="s2">if </span><span class="s1">(boxScale !== undefined) {</span>
        <span class="s1">point = scalePoint(point, boxScale, originPoint);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">scalePoint(point, scale, originPoint) + translate;</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Applies a translate/scale delta to an axis</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">applyAxisDelta(axis, translate = </span><span class="s5">0</span><span class="s1">, scale = </span><span class="s5">1</span><span class="s1">, originPoint, boxScale) {</span>
    <span class="s1">axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);</span>
    <span class="s1">axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Applies a translate/scale delta to a box</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">applyBoxDelta(box, { x, y }) {</span>
    <span class="s1">applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);</span>
    <span class="s1">applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">TREE_SCALE_SNAP_MIN = </span><span class="s5">0.999999999999</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">TREE_SCALE_SNAP_MAX = </span><span class="s5">1.0000000000001</span><span class="s1">;</span>
<span class="s3">/**</span>
 <span class="s3">* Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms</span>
 <span class="s3">* in a tree upon our box before then calculating how to project it into our desired viewport-relative box</span>
 <span class="s3">*</span>
 <span class="s3">* This is the final nested loop within updateLayoutDelta for future refactoring</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">applyTreeDeltas(box, treeScale, treePath, isSharedTransition = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s2">const </span><span class="s1">treeLength = treePath.length;</span>
    <span class="s2">if </span><span class="s1">(!treeLength)</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s3">// Reset the treeScale</span>
    <span class="s1">treeScale.x = treeScale.y = </span><span class="s5">1</span><span class="s1">;</span>
    <span class="s2">let </span><span class="s1">node;</span>
    <span class="s2">let </span><span class="s1">delta;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; treeLength; i++) {</span>
        <span class="s1">node = treePath[i];</span>
        <span class="s1">delta = node.projectionDelta;</span>
        <span class="s3">/**</span>
         <span class="s3">* TODO: Prefer to remove this, but currently we have motion components with</span>
         <span class="s3">* display: contents in Framer.</span>
         <span class="s3">*/</span>
        <span class="s2">const </span><span class="s1">{ visualElement } = node.options;</span>
        <span class="s2">if </span><span class="s1">(visualElement &amp;&amp;</span>
            <span class="s1">visualElement.props.style &amp;&amp;</span>
            <span class="s1">visualElement.props.style.display === </span><span class="s0">&quot;contents&quot;</span><span class="s1">) {</span>
            <span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(isSharedTransition &amp;&amp;</span>
            <span class="s1">node.options.layoutScroll &amp;&amp;</span>
            <span class="s1">node.scroll &amp;&amp;</span>
            <span class="s1">node !== node.root) {</span>
            <span class="s1">transformBox(box, {</span>
                <span class="s1">x: -node.scroll.offset.x,</span>
                <span class="s1">y: -node.scroll.offset.y,</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(delta) {</span>
            <span class="s3">// Incoporate each ancestor's scale into a culmulative treeScale for this component</span>
            <span class="s1">treeScale.x *= delta.x.scale;</span>
            <span class="s1">treeScale.y *= delta.y.scale;</span>
            <span class="s3">// Apply each ancestor's calculated delta into this component's recorded layout box</span>
            <span class="s1">applyBoxDelta(box, delta);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(isSharedTransition &amp;&amp; hasTransform(node.latestValues)) {</span>
            <span class="s1">transformBox(box, node.latestValues);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Snap tree scale back to 1 if it's within a non-perceivable threshold.</span>
     <span class="s3">* This will help reduce useless scales getting rendered.</span>
     <span class="s3">*/</span>
    <span class="s2">if </span><span class="s1">(treeScale.x &lt; TREE_SCALE_SNAP_MAX &amp;&amp;</span>
        <span class="s1">treeScale.x &gt; TREE_SCALE_SNAP_MIN) {</span>
        <span class="s1">treeScale.x = </span><span class="s5">1.0</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(treeScale.y &lt; TREE_SCALE_SNAP_MAX &amp;&amp;</span>
        <span class="s1">treeScale.y &gt; TREE_SCALE_SNAP_MIN) {</span>
        <span class="s1">treeScale.y = </span><span class="s5">1.0</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">translateAxis(axis, distance) {</span>
    <span class="s1">axis.min = axis.min + distance;</span>
    <span class="s1">axis.max = axis.max + distance;</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Apply a transform to an axis from the latest resolved motion values.</span>
 <span class="s3">* This function basically acts as a bridge between a flat motion value map</span>
 <span class="s3">* and applyAxisDelta</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = </span><span class="s5">0.5</span><span class="s1">) {</span>
    <span class="s2">const </span><span class="s1">originPoint = motionDom.mixNumber(axis.min, axis.max, axisOrigin);</span>
    <span class="s3">// Apply the axis delta to the final axis</span>
    <span class="s1">applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Apply a transform to a box from the latest resolved motion values.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">transformBox(box, transform) {</span>
    <span class="s1">transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);</span>
    <span class="s1">transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">removePointDelta(point, translate, scale, originPoint, boxScale) {</span>
    <span class="s1">point -= translate;</span>
    <span class="s1">point = scalePoint(point, </span><span class="s5">1 </span><span class="s1">/ scale, originPoint);</span>
    <span class="s2">if </span><span class="s1">(boxScale !== undefined) {</span>
        <span class="s1">point = scalePoint(point, </span><span class="s5">1 </span><span class="s1">/ boxScale, originPoint);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">point;</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">removeAxisDelta(axis, translate = </span><span class="s5">0</span><span class="s1">, scale = </span><span class="s5">1</span><span class="s1">, origin = </span><span class="s5">0.5</span><span class="s1">, boxScale, originAxis = axis, sourceAxis = axis) {</span>
    <span class="s2">if </span><span class="s1">(motionDom.percent.test(translate)) {</span>
        <span class="s1">translate = parseFloat(translate);</span>
        <span class="s2">const </span><span class="s1">relativeProgress = motionDom.mixNumber(sourceAxis.min, sourceAxis.max, translate / </span><span class="s5">100</span><span class="s1">);</span>
        <span class="s1">translate = relativeProgress - sourceAxis.min;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">translate !== </span><span class="s0">&quot;number&quot;</span><span class="s1">)</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s2">let </span><span class="s1">originPoint = motionDom.mixNumber(originAxis.min, originAxis.max, origin);</span>
    <span class="s2">if </span><span class="s1">(axis === originAxis)</span>
        <span class="s1">originPoint -= translate;</span>
    <span class="s1">axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);</span>
    <span class="s1">axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse</span>
 <span class="s3">* and acts as a bridge between motion values and removeAxisDelta</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {</span>
    <span class="s1">removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* The names of the motion values we want to apply as translation, scale and origin.</span>
 <span class="s3">*/</span>
<span class="s2">const </span><span class="s1">xKeys = [</span><span class="s0">&quot;x&quot;</span><span class="s1">, </span><span class="s0">&quot;scaleX&quot;</span><span class="s1">, </span><span class="s0">&quot;originX&quot;</span><span class="s1">];</span>
<span class="s2">const </span><span class="s1">yKeys = [</span><span class="s0">&quot;y&quot;</span><span class="s1">, </span><span class="s0">&quot;scaleY&quot;</span><span class="s1">, </span><span class="s0">&quot;originY&quot;</span><span class="s1">];</span>
<span class="s3">/**</span>
 <span class="s3">* Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse</span>
 <span class="s3">* and acts as a bridge between motion values and removeAxisDelta</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">removeBoxTransforms(box, transforms, originBox, sourceBox) {</span>
    <span class="s1">removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : undefined, sourceBox ? sourceBox.x : undefined);</span>
    <span class="s1">removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : undefined, sourceBox ? sourceBox.y : undefined);</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">createAxisDelta = () =&gt; ({</span>
    <span class="s1">translate: </span><span class="s5">0</span><span class="s1">,</span>
    <span class="s1">scale: </span><span class="s5">1</span><span class="s1">,</span>
    <span class="s1">origin: </span><span class="s5">0</span><span class="s1">,</span>
    <span class="s1">originPoint: </span><span class="s5">0</span><span class="s1">,</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">createDelta = () =&gt; ({</span>
    <span class="s1">x: createAxisDelta(),</span>
    <span class="s1">y: createAxisDelta(),</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">createAxis = () =&gt; ({ min: </span><span class="s5">0</span><span class="s1">, max: </span><span class="s5">0 </span><span class="s1">});</span>
<span class="s2">const </span><span class="s1">createBox = () =&gt; ({</span>
    <span class="s1">x: createAxis(),</span>
    <span class="s1">y: createAxis(),</span>
<span class="s1">});</span>

<span class="s2">function </span><span class="s1">isAxisDeltaZero(delta) {</span>
    <span class="s2">return </span><span class="s1">delta.translate === </span><span class="s5">0 </span><span class="s1">&amp;&amp; delta.scale === </span><span class="s5">1</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isDeltaZero(delta) {</span>
    <span class="s2">return </span><span class="s1">isAxisDeltaZero(delta.x) &amp;&amp; isAxisDeltaZero(delta.y);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">axisEquals(a, b) {</span>
    <span class="s2">return </span><span class="s1">a.min === b.min &amp;&amp; a.max === b.max;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">boxEquals(a, b) {</span>
    <span class="s2">return </span><span class="s1">axisEquals(a.x, b.x) &amp;&amp; axisEquals(a.y, b.y);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">axisEqualsRounded(a, b) {</span>
    <span class="s2">return </span><span class="s1">(Math.round(a.min) === Math.round(b.min) &amp;&amp;</span>
        <span class="s1">Math.round(a.max) === Math.round(b.max));</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">boxEqualsRounded(a, b) {</span>
    <span class="s2">return </span><span class="s1">axisEqualsRounded(a.x, b.x) &amp;&amp; axisEqualsRounded(a.y, b.y);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">aspectRatio(box) {</span>
    <span class="s2">return </span><span class="s1">calcLength(box.x) / calcLength(box.y);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">axisDeltaEquals(a, b) {</span>
    <span class="s2">return </span><span class="s1">(a.translate === b.translate &amp;&amp;</span>
        <span class="s1">a.scale === b.scale &amp;&amp;</span>
        <span class="s1">a.originPoint === b.originPoint);</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">NodeStack {</span>
    <span class="s1">constructor() {</span>
        <span class="s2">this</span><span class="s1">.members = [];</span>
    <span class="s1">}</span>
    <span class="s1">add(node) {</span>
        <span class="s1">motionUtils.addUniqueItem(</span><span class="s2">this</span><span class="s1">.members, node);</span>
        <span class="s1">node.scheduleRender();</span>
    <span class="s1">}</span>
    <span class="s1">remove(node) {</span>
        <span class="s1">motionUtils.removeItem(</span><span class="s2">this</span><span class="s1">.members, node);</span>
        <span class="s2">if </span><span class="s1">(node === </span><span class="s2">this</span><span class="s1">.prevLead) {</span>
            <span class="s2">this</span><span class="s1">.prevLead = undefined;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(node === </span><span class="s2">this</span><span class="s1">.lead) {</span>
            <span class="s2">const </span><span class="s1">prevLead = </span><span class="s2">this</span><span class="s1">.members[</span><span class="s2">this</span><span class="s1">.members.length - </span><span class="s5">1</span><span class="s1">];</span>
            <span class="s2">if </span><span class="s1">(prevLead) {</span>
                <span class="s2">this</span><span class="s1">.promote(prevLead);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">relegate(node) {</span>
        <span class="s2">const </span><span class="s1">indexOfNode = </span><span class="s2">this</span><span class="s1">.members.findIndex((member) =&gt; node === member);</span>
        <span class="s2">if </span><span class="s1">(indexOfNode === </span><span class="s5">0</span><span class="s1">)</span>
            <span class="s2">return false</span><span class="s1">;</span>
        <span class="s3">/**</span>
         <span class="s3">* Find the next projection node that is present</span>
         <span class="s3">*/</span>
        <span class="s2">let </span><span class="s1">prevLead;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = indexOfNode; i &gt;= </span><span class="s5">0</span><span class="s1">; i--) {</span>
            <span class="s2">const </span><span class="s1">member = </span><span class="s2">this</span><span class="s1">.members[i];</span>
            <span class="s2">if </span><span class="s1">(member.isPresent !== </span><span class="s2">false</span><span class="s1">) {</span>
                <span class="s1">prevLead = member;</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(prevLead) {</span>
            <span class="s2">this</span><span class="s1">.promote(prevLead);</span>
            <span class="s2">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">promote(node, preserveFollowOpacity) {</span>
        <span class="s2">const </span><span class="s1">prevLead = </span><span class="s2">this</span><span class="s1">.lead;</span>
        <span class="s2">if </span><span class="s1">(node === prevLead)</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.prevLead = prevLead;</span>
        <span class="s2">this</span><span class="s1">.lead = node;</span>
        <span class="s1">node.show();</span>
        <span class="s2">if </span><span class="s1">(prevLead) {</span>
            <span class="s1">prevLead.instance &amp;&amp; prevLead.scheduleRender();</span>
            <span class="s1">node.scheduleRender();</span>
            <span class="s1">node.resumeFrom = prevLead;</span>
            <span class="s2">if </span><span class="s1">(preserveFollowOpacity) {</span>
                <span class="s1">node.resumeFrom.preserveOpacity = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(prevLead.snapshot) {</span>
                <span class="s1">node.snapshot = prevLead.snapshot;</span>
                <span class="s1">node.snapshot.latestValues =</span>
                    <span class="s1">prevLead.animationValues || prevLead.latestValues;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(node.root &amp;&amp; node.root.isUpdating) {</span>
                <span class="s1">node.isLayoutDirty = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">{ crossfade } = node.options;</span>
            <span class="s2">if </span><span class="s1">(crossfade === </span><span class="s2">false</span><span class="s1">) {</span>
                <span class="s1">prevLead.hide();</span>
            <span class="s1">}</span>
            <span class="s3">/**</span>
             <span class="s3">* TODO:</span>
             <span class="s3">*   - Test border radius when previous node was deleted</span>
             <span class="s3">*   - boxShadow mixing</span>
             <span class="s3">*   - Shared between element A in scrolled container and element B (scroll stays the same or changes)</span>
             <span class="s3">*   - Shared between element A in transformed container and element B (transform stays the same or changes)</span>
             <span class="s3">*   - Shared between element A in scrolled page and element B (scroll stays the same or changes)</span>
             <span class="s3">* ---</span>
             <span class="s3">*   - Crossfade opacity of root nodes</span>
             <span class="s3">*   - layoutId changes after animation</span>
             <span class="s3">*   - layoutId changes mid animation</span>
             <span class="s3">*/</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">exitAnimationComplete() {</span>
        <span class="s2">this</span><span class="s1">.members.forEach((node) =&gt; {</span>
            <span class="s2">const </span><span class="s1">{ options, resumingFrom } = node;</span>
            <span class="s1">options.onExitComplete &amp;&amp; options.onExitComplete();</span>
            <span class="s2">if </span><span class="s1">(resumingFrom) {</span>
                <span class="s1">resumingFrom.options.onExitComplete &amp;&amp;</span>
                    <span class="s1">resumingFrom.options.onExitComplete();</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">scheduleRender() {</span>
        <span class="s2">this</span><span class="s1">.members.forEach((node) =&gt; {</span>
            <span class="s1">node.instance &amp;&amp; node.scheduleRender(</span><span class="s2">false</span><span class="s1">);</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Clear any leads that have been removed this render to prevent them from being</span>
     <span class="s3">* used in future animations and to prevent memory leaks</span>
     <span class="s3">*/</span>
    <span class="s1">removeLeadSnapshot() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.lead &amp;&amp; </span><span class="s2">this</span><span class="s1">.lead.snapshot) {</span>
            <span class="s2">this</span><span class="s1">.lead.snapshot = undefined;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">scaleCorrectors = {};</span>
<span class="s2">function </span><span class="s1">addScaleCorrector(correctors) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">correctors) {</span>
        <span class="s1">scaleCorrectors[key] = correctors[key];</span>
        <span class="s2">if </span><span class="s1">(motionDom.isCSSVariableName(key)) {</span>
            <span class="s1">scaleCorrectors[key].isCSSVariable = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">buildProjectionTransform(delta, treeScale, latestTransform) {</span>
    <span class="s2">let </span><span class="s1">transform = </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* The translations we use to calculate are always relative to the viewport coordinate space.</span>
     <span class="s3">* But when we apply scales, we also scale the coordinate space of an element and its children.</span>
     <span class="s3">* For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need</span>
     <span class="s3">* to move an element 100 pixels, we actually need to move it 200 in within that scaled space.</span>
     <span class="s3">*/</span>
    <span class="s2">const </span><span class="s1">xTranslate = delta.x.translate / treeScale.x;</span>
    <span class="s2">const </span><span class="s1">yTranslate = delta.y.translate / treeScale.y;</span>
    <span class="s2">const </span><span class="s1">zTranslate = latestTransform?.z || </span><span class="s5">0</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(xTranslate || yTranslate || zTranslate) {</span>
        <span class="s1">transform = </span><span class="s0">`translate3d(</span><span class="s1">${xTranslate}</span><span class="s0">px, </span><span class="s1">${yTranslate}</span><span class="s0">px, </span><span class="s1">${zTranslate}</span><span class="s0">px) `</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Apply scale correction for the tree transform.</span>
     <span class="s3">* This will apply scale to the screen-orientated axes.</span>
     <span class="s3">*/</span>
    <span class="s2">if </span><span class="s1">(treeScale.x !== </span><span class="s5">1 </span><span class="s1">|| treeScale.y !== </span><span class="s5">1</span><span class="s1">) {</span>
        <span class="s1">transform += </span><span class="s0">`scale(</span><span class="s1">${</span><span class="s5">1 </span><span class="s1">/ treeScale.x}</span><span class="s0">, </span><span class="s1">${</span><span class="s5">1 </span><span class="s1">/ treeScale.y}</span><span class="s0">) `</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(latestTransform) {</span>
        <span class="s2">const </span><span class="s1">{ transformPerspective, rotate, rotateX, rotateY, skewX, skewY } = latestTransform;</span>
        <span class="s2">if </span><span class="s1">(transformPerspective)</span>
            <span class="s1">transform = </span><span class="s0">`perspective(</span><span class="s1">${transformPerspective}</span><span class="s0">px) </span><span class="s1">${transform}</span><span class="s0">`</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(rotate)</span>
            <span class="s1">transform += </span><span class="s0">`rotate(</span><span class="s1">${rotate}</span><span class="s0">deg) `</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(rotateX)</span>
            <span class="s1">transform += </span><span class="s0">`rotateX(</span><span class="s1">${rotateX}</span><span class="s0">deg) `</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(rotateY)</span>
            <span class="s1">transform += </span><span class="s0">`rotateY(</span><span class="s1">${rotateY}</span><span class="s0">deg) `</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(skewX)</span>
            <span class="s1">transform += </span><span class="s0">`skewX(</span><span class="s1">${skewX}</span><span class="s0">deg) `</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(skewY)</span>
            <span class="s1">transform += </span><span class="s0">`skewY(</span><span class="s1">${skewY}</span><span class="s0">deg) `</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Apply scale to match the size of the element to the size we want it.</span>
     <span class="s3">* This will apply scale to the element-orientated axes.</span>
     <span class="s3">*/</span>
    <span class="s2">const </span><span class="s1">elementScaleX = delta.x.scale * treeScale.x;</span>
    <span class="s2">const </span><span class="s1">elementScaleY = delta.y.scale * treeScale.y;</span>
    <span class="s2">if </span><span class="s1">(elementScaleX !== </span><span class="s5">1 </span><span class="s1">|| elementScaleY !== </span><span class="s5">1</span><span class="s1">) {</span>
        <span class="s1">transform += </span><span class="s0">`scale(</span><span class="s1">${elementScaleX}</span><span class="s0">, </span><span class="s1">${elementScaleY}</span><span class="s0">)`</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">transform || </span><span class="s0">&quot;none&quot;</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">eachAxis(callback) {</span>
    <span class="s2">return </span><span class="s1">[callback(</span><span class="s0">&quot;x&quot;</span><span class="s1">), callback(</span><span class="s0">&quot;y&quot;</span><span class="s1">)];</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* This should only ever be modified on the client otherwise it'll</span>
 <span class="s3">* persist through server requests. If we need instanced states we</span>
 <span class="s3">* could lazy-init via root.</span>
 <span class="s3">*/</span>
<span class="s2">const </span><span class="s1">globalProjectionState = {</span>
    <span class="s3">/**</span>
     <span class="s3">* Global flag as to whether the tree has animated since the last time</span>
     <span class="s3">* we resized the window</span>
     <span class="s3">*/</span>
    <span class="s1">hasAnimatedSinceResize: </span><span class="s2">true</span><span class="s1">,</span>
    <span class="s3">/**</span>
     <span class="s3">* We set this to true once, on the first update. Any nodes added to the tree beyond that</span>
     <span class="s3">* update will be given a `data-projection-id` attribute.</span>
     <span class="s3">*/</span>
    <span class="s1">hasEverUpdated: </span><span class="s2">false</span><span class="s1">,</span>
<span class="s1">};</span>

<span class="s2">const </span><span class="s1">metrics = {</span>
    <span class="s1">nodes: </span><span class="s5">0</span><span class="s1">,</span>
    <span class="s1">calculatedTargetDeltas: </span><span class="s5">0</span><span class="s1">,</span>
    <span class="s1">calculatedProjections: </span><span class="s5">0</span><span class="s1">,</span>
<span class="s1">};</span>
<span class="s2">const </span><span class="s1">transformAxes = [</span><span class="s0">&quot;&quot;</span><span class="s1">, </span><span class="s0">&quot;X&quot;</span><span class="s1">, </span><span class="s0">&quot;Y&quot;</span><span class="s1">, </span><span class="s0">&quot;Z&quot;</span><span class="s1">];</span>
<span class="s3">/**</span>
 <span class="s3">* We use 1000 as the animation target as 0-1000 maps better to pixels than 0-1</span>
 <span class="s3">* which has a noticeable difference in spring animations</span>
 <span class="s3">*/</span>
<span class="s2">const </span><span class="s1">animationTarget = </span><span class="s5">1000</span><span class="s1">;</span>
<span class="s2">let </span><span class="s1">id$1 = </span><span class="s5">0</span><span class="s1">;</span>
<span class="s2">function </span><span class="s1">resetDistortingTransform(key, visualElement, values, sharedAnimationValues) {</span>
    <span class="s2">const </span><span class="s1">{ latestValues } = visualElement;</span>
    <span class="s3">// Record the distorting transform and then temporarily set it to 0</span>
    <span class="s2">if </span><span class="s1">(latestValues[key]) {</span>
        <span class="s1">values[key] = latestValues[key];</span>
        <span class="s1">visualElement.setStaticValue(key, </span><span class="s5">0</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(sharedAnimationValues) {</span>
            <span class="s1">sharedAnimationValues[key] = </span><span class="s5">0</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">cancelTreeOptimisedTransformAnimations(projectionNode) {</span>
    <span class="s1">projectionNode.hasCheckedOptimisedAppear = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(projectionNode.root === projectionNode)</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">{ visualElement } = projectionNode.options;</span>
    <span class="s2">if </span><span class="s1">(!visualElement)</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">appearId = getOptimisedAppearId(visualElement);</span>
    <span class="s2">if </span><span class="s1">(window.MotionHasOptimisedAnimation(appearId, </span><span class="s0">&quot;transform&quot;</span><span class="s1">)) {</span>
        <span class="s2">const </span><span class="s1">{ layout, layoutId } = projectionNode.options;</span>
        <span class="s1">window.MotionCancelOptimisedAnimation(appearId, </span><span class="s0">&quot;transform&quot;</span><span class="s1">, motionDom.frame, !(layout || layoutId));</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">{ parent } = projectionNode;</span>
    <span class="s2">if </span><span class="s1">(parent &amp;&amp; !parent.hasCheckedOptimisedAppear) {</span>
        <span class="s1">cancelTreeOptimisedTransformAnimations(parent);</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createProjectionNode$1({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform, }) {</span>
    <span class="s2">return class </span><span class="s1">ProjectionNode {</span>
        <span class="s1">constructor(latestValues = {}, parent = defaultParent?.()) {</span>
            <span class="s3">/**</span>
             <span class="s3">* A unique ID generated for every projection node.</span>
             <span class="s3">*/</span>
            <span class="s2">this</span><span class="s1">.id = id$1++;</span>
            <span class="s3">/**</span>
             <span class="s3">* An id that represents a unique session instigated by startUpdate.</span>
             <span class="s3">*/</span>
            <span class="s2">this</span><span class="s1">.animationId = </span><span class="s5">0</span><span class="s1">;</span>
            <span class="s2">this</span><span class="s1">.animationCommitId = </span><span class="s5">0</span><span class="s1">;</span>
            <span class="s3">/**</span>
             <span class="s3">* A Set containing all this component's children. This is used to iterate</span>
             <span class="s3">* through the children.</span>
             <span class="s3">*</span>
             <span class="s3">* TODO: This could be faster to iterate as a flat array stored on the root node.</span>
             <span class="s3">*/</span>
            <span class="s2">this</span><span class="s1">.children = </span><span class="s2">new </span><span class="s1">Set();</span>
            <span class="s3">/**</span>
             <span class="s3">* Options for the node. We use this to configure what kind of layout animations</span>
             <span class="s3">* we should perform (if any).</span>
             <span class="s3">*/</span>
            <span class="s2">this</span><span class="s1">.options = {};</span>
            <span class="s3">/**</span>
             <span class="s3">* We use this to detect when its safe to shut down part of a projection tree.</span>
             <span class="s3">* We have to keep projecting children for scale correction and relative projection</span>
             <span class="s3">* until all their parents stop performing layout animations.</span>
             <span class="s3">*/</span>
            <span class="s2">this</span><span class="s1">.isTreeAnimating = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s2">this</span><span class="s1">.isAnimationBlocked = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s3">/**</span>
             <span class="s3">* Flag to true if we think this layout has been changed. We can't always know this,</span>
             <span class="s3">* currently we set it to true every time a component renders, or if it has a layoutDependency</span>
             <span class="s3">* if that has changed between renders. Additionally, components can be grouped by LayoutGroup</span>
             <span class="s3">* and if one node is dirtied, they all are.</span>
             <span class="s3">*/</span>
            <span class="s2">this</span><span class="s1">.isLayoutDirty = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s3">/**</span>
             <span class="s3">* Flag to true if we think the projection calculations for this node needs</span>
             <span class="s3">* recalculating as a result of an updated transform or layout animation.</span>
             <span class="s3">*/</span>
            <span class="s2">this</span><span class="s1">.isProjectionDirty = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s3">/**</span>
             <span class="s3">* Flag to true if the layout *or* transform has changed. This then gets propagated</span>
             <span class="s3">* throughout the projection tree, forcing any element below to recalculate on the next frame.</span>
             <span class="s3">*/</span>
            <span class="s2">this</span><span class="s1">.isSharedProjectionDirty = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s3">/**</span>
             <span class="s3">* Flag transform dirty. This gets propagated throughout the whole tree but is only</span>
             <span class="s3">* respected by shared nodes.</span>
             <span class="s3">*/</span>
            <span class="s2">this</span><span class="s1">.isTransformDirty = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s3">/**</span>
             <span class="s3">* Block layout updates for instant layout transitions throughout the tree.</span>
             <span class="s3">*/</span>
            <span class="s2">this</span><span class="s1">.updateManuallyBlocked = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s2">this</span><span class="s1">.updateBlockedByResize = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s3">/**</span>
             <span class="s3">* Set to true between the start of the first `willUpdate` call and the end of the `didUpdate`</span>
             <span class="s3">* call.</span>
             <span class="s3">*/</span>
            <span class="s2">this</span><span class="s1">.isUpdating = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s3">/**</span>
             <span class="s3">* If this is an SVG element we currently disable projection transforms</span>
             <span class="s3">*/</span>
            <span class="s2">this</span><span class="s1">.isSVG = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s3">/**</span>
             <span class="s3">* Flag to true (during promotion) if a node doing an instant layout transition needs to reset</span>
             <span class="s3">* its projection styles.</span>
             <span class="s3">*/</span>
            <span class="s2">this</span><span class="s1">.needsReset = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s3">/**</span>
             <span class="s3">* Flags whether this node should have its transform reset prior to measuring.</span>
             <span class="s3">*/</span>
            <span class="s2">this</span><span class="s1">.shouldResetTransform = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s3">/**</span>
             <span class="s3">* Store whether this node has been checked for optimised appear animations. As</span>
             <span class="s3">* effects fire bottom-up, and we want to look up the tree for appear animations,</span>
             <span class="s3">* this makes sure we only check each path once, stopping at nodes that</span>
             <span class="s3">* have already been checked.</span>
             <span class="s3">*/</span>
            <span class="s2">this</span><span class="s1">.hasCheckedOptimisedAppear = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s3">/**</span>
             <span class="s3">* An object representing the calculated contextual/accumulated/tree scale.</span>
             <span class="s3">* This will be used to scale calculcated projection transforms, as these are</span>
             <span class="s3">* calculated in screen-space but need to be scaled for elements to layoutly</span>
             <span class="s3">* make it to their calculated destinations.</span>
             <span class="s3">*</span>
             <span class="s3">* TODO: Lazy-init</span>
             <span class="s3">*/</span>
            <span class="s2">this</span><span class="s1">.treeScale = { x: </span><span class="s5">1</span><span class="s1">, y: </span><span class="s5">1 </span><span class="s1">};</span>
            <span class="s3">/**</span>
             <span class="s3">*</span>
             <span class="s3">*/</span>
            <span class="s2">this</span><span class="s1">.eventHandlers = </span><span class="s2">new </span><span class="s1">Map();</span>
            <span class="s2">this</span><span class="s1">.hasTreeAnimated = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s3">// Note: Currently only running on root node</span>
            <span class="s2">this</span><span class="s1">.updateScheduled = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s2">this</span><span class="s1">.scheduleUpdate = () =&gt; </span><span class="s2">this</span><span class="s1">.update();</span>
            <span class="s2">this</span><span class="s1">.projectionUpdateScheduled = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s2">this</span><span class="s1">.checkUpdateFailed = () =&gt; {</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isUpdating) {</span>
                    <span class="s2">this</span><span class="s1">.isUpdating = </span><span class="s2">false</span><span class="s1">;</span>
                    <span class="s2">this</span><span class="s1">.clearAllSnapshots();</span>
                <span class="s1">}</span>
            <span class="s1">};</span>
            <span class="s3">/**</span>
             <span class="s3">* This is a multi-step process as shared nodes might be of different depths. Nodes</span>
             <span class="s3">* are sorted by depth order, so we need to resolve the entire tree before moving to</span>
             <span class="s3">* the next step.</span>
             <span class="s3">*/</span>
            <span class="s2">this</span><span class="s1">.updateProjection = () =&gt; {</span>
                <span class="s2">this</span><span class="s1">.projectionUpdateScheduled = </span><span class="s2">false</span><span class="s1">;</span>
                <span class="s3">/**</span>
                 <span class="s3">* Reset debug counts. Manually resetting rather than creating a new</span>
                 <span class="s3">* object each frame.</span>
                 <span class="s3">*/</span>
                <span class="s2">if </span><span class="s1">(motionDom.statsBuffer.value) {</span>
                    <span class="s1">metrics.nodes =</span>
                        <span class="s1">metrics.calculatedTargetDeltas =</span>
                            <span class="s1">metrics.calculatedProjections =</span>
                                <span class="s5">0</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">this</span><span class="s1">.nodes.forEach(propagateDirtyNodes);</span>
                <span class="s2">this</span><span class="s1">.nodes.forEach(resolveTargetDelta);</span>
                <span class="s2">this</span><span class="s1">.nodes.forEach(calcProjection);</span>
                <span class="s2">this</span><span class="s1">.nodes.forEach(cleanDirtyNodes);</span>
                <span class="s2">if </span><span class="s1">(motionDom.statsBuffer.addProjectionMetrics) {</span>
                    <span class="s1">motionDom.statsBuffer.addProjectionMetrics(metrics);</span>
                <span class="s1">}</span>
            <span class="s1">};</span>
            <span class="s3">/**</span>
             <span class="s3">* Frame calculations</span>
             <span class="s3">*/</span>
            <span class="s2">this</span><span class="s1">.resolvedRelativeTargetAt = </span><span class="s5">0.0</span><span class="s1">;</span>
            <span class="s2">this</span><span class="s1">.hasProjected = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s2">this</span><span class="s1">.isVisible = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s2">this</span><span class="s1">.animationProgress = </span><span class="s5">0</span><span class="s1">;</span>
            <span class="s3">/**</span>
             <span class="s3">* Shared layout</span>
             <span class="s3">*/</span>
            <span class="s3">// TODO Only running on root node</span>
            <span class="s2">this</span><span class="s1">.sharedNodes = </span><span class="s2">new </span><span class="s1">Map();</span>
            <span class="s2">this</span><span class="s1">.latestValues = latestValues;</span>
            <span class="s2">this</span><span class="s1">.root = parent ? parent.root || parent : </span><span class="s2">this</span><span class="s1">;</span>
            <span class="s2">this</span><span class="s1">.path = parent ? [...parent.path, parent] : [];</span>
            <span class="s2">this</span><span class="s1">.parent = parent;</span>
            <span class="s2">this</span><span class="s1">.depth = parent ? parent.depth + </span><span class="s5">1 </span><span class="s1">: </span><span class="s5">0</span><span class="s1">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; </span><span class="s2">this</span><span class="s1">.path.length; i++) {</span>
                <span class="s2">this</span><span class="s1">.path[i].shouldResetTransform = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.root === </span><span class="s2">this</span><span class="s1">)</span>
                <span class="s2">this</span><span class="s1">.nodes = </span><span class="s2">new </span><span class="s1">FlatTree();</span>
        <span class="s1">}</span>
        <span class="s1">addEventListener(name, handler) {</span>
            <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.eventHandlers.has(name)) {</span>
                <span class="s2">this</span><span class="s1">.eventHandlers.set(name, </span><span class="s2">new </span><span class="s1">motionUtils.SubscriptionManager());</span>
            <span class="s1">}</span>
            <span class="s2">return this</span><span class="s1">.eventHandlers.get(name).add(handler);</span>
        <span class="s1">}</span>
        <span class="s1">notifyListeners(name, ...args) {</span>
            <span class="s2">const </span><span class="s1">subscriptionManager = </span><span class="s2">this</span><span class="s1">.eventHandlers.get(name);</span>
            <span class="s1">subscriptionManager &amp;&amp; subscriptionManager.notify(...args);</span>
        <span class="s1">}</span>
        <span class="s1">hasListeners(name) {</span>
            <span class="s2">return this</span><span class="s1">.eventHandlers.has(name);</span>
        <span class="s1">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Lifecycles</span>
         <span class="s3">*/</span>
        <span class="s1">mount(instance) {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.instance)</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s2">this</span><span class="s1">.isSVG = motionDom.isSVGElement(instance) &amp;&amp; !motionDom.isSVGSVGElement(instance);</span>
            <span class="s2">this</span><span class="s1">.instance = instance;</span>
            <span class="s2">const </span><span class="s1">{ layoutId, layout, visualElement } = </span><span class="s2">this</span><span class="s1">.options;</span>
            <span class="s2">if </span><span class="s1">(visualElement &amp;&amp; !visualElement.current) {</span>
                <span class="s1">visualElement.mount(instance);</span>
            <span class="s1">}</span>
            <span class="s2">this</span><span class="s1">.root.nodes.add(</span><span class="s2">this</span><span class="s1">);</span>
            <span class="s2">this</span><span class="s1">.parent &amp;&amp; </span><span class="s2">this</span><span class="s1">.parent.children.add(</span><span class="s2">this</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.root.hasTreeAnimated &amp;&amp; (layout || layoutId)) {</span>
                <span class="s2">this</span><span class="s1">.isLayoutDirty = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(attachResizeListener) {</span>
                <span class="s2">let </span><span class="s1">cancelDelay;</span>
                <span class="s2">let </span><span class="s1">innerWidth = </span><span class="s5">0</span><span class="s1">;</span>
                <span class="s2">const </span><span class="s1">resizeUnblockUpdate = () =&gt; (</span><span class="s2">this</span><span class="s1">.root.updateBlockedByResize = </span><span class="s2">false</span><span class="s1">);</span>
                <span class="s3">// Set initial innerWidth in a frame.read callback to batch the read</span>
                <span class="s1">motionDom.frame.read(() =&gt; {</span>
                    <span class="s1">innerWidth = window.innerWidth;</span>
                <span class="s1">});</span>
                <span class="s1">attachResizeListener(instance, () =&gt; {</span>
                    <span class="s2">const </span><span class="s1">newInnerWidth = window.innerWidth;</span>
                    <span class="s2">if </span><span class="s1">(newInnerWidth === innerWidth)</span>
                        <span class="s2">return</span><span class="s1">;</span>
                    <span class="s1">innerWidth = newInnerWidth;</span>
                    <span class="s2">this</span><span class="s1">.root.updateBlockedByResize = </span><span class="s2">true</span><span class="s1">;</span>
                    <span class="s1">cancelDelay &amp;&amp; cancelDelay();</span>
                    <span class="s1">cancelDelay = delay(resizeUnblockUpdate, </span><span class="s5">250</span><span class="s1">);</span>
                    <span class="s2">if </span><span class="s1">(globalProjectionState.hasAnimatedSinceResize) {</span>
                        <span class="s1">globalProjectionState.hasAnimatedSinceResize = </span><span class="s2">false</span><span class="s1">;</span>
                        <span class="s2">this</span><span class="s1">.nodes.forEach(finishAnimation);</span>
                    <span class="s1">}</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(layoutId) {</span>
                <span class="s2">this</span><span class="s1">.root.registerSharedNode(layoutId, </span><span class="s2">this</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s3">// Only register the handler if it requires layout animation</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.animate !== </span><span class="s2">false </span><span class="s1">&amp;&amp;</span>
                <span class="s1">visualElement &amp;&amp;</span>
                <span class="s1">(layoutId || layout)) {</span>
                <span class="s2">this</span><span class="s1">.addEventListener(</span><span class="s0">&quot;didUpdate&quot;</span><span class="s1">, ({ delta, hasLayoutChanged, hasRelativeLayoutChanged, layout: newLayout, }) =&gt; {</span>
                    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isTreeAnimationBlocked()) {</span>
                        <span class="s2">this</span><span class="s1">.target = undefined;</span>
                        <span class="s2">this</span><span class="s1">.relativeTarget = undefined;</span>
                        <span class="s2">return</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s3">// TODO: Check here if an animation exists</span>
                    <span class="s2">const </span><span class="s1">layoutTransition = </span><span class="s2">this</span><span class="s1">.options.transition ||</span>
                        <span class="s1">visualElement.getDefaultTransition() ||</span>
                        <span class="s1">defaultLayoutTransition;</span>
                    <span class="s2">const </span><span class="s1">{ onLayoutAnimationStart, onLayoutAnimationComplete, } = visualElement.getProps();</span>
                    <span class="s3">/**</span>
                     <span class="s3">* The target layout of the element might stay the same,</span>
                     <span class="s3">* but its position relative to its parent has changed.</span>
                     <span class="s3">*/</span>
                    <span class="s2">const </span><span class="s1">hasTargetChanged = !</span><span class="s2">this</span><span class="s1">.targetLayout ||</span>
                        <span class="s1">!boxEqualsRounded(</span><span class="s2">this</span><span class="s1">.targetLayout, newLayout);</span>
                    <span class="s3">/* 
                     * Note: Disabled to fix relative animations always triggering new 
                     * layout animations. If this causes further issues, we can try 
                     * a different approach to detecting relative target changes. 
                     */</span>
                    <span class="s3">// || hasRelativeLayoutChanged</span>
                    <span class="s3">/**</span>
                     <span class="s3">* If the layout hasn't seemed to have changed, it might be that the</span>
                     <span class="s3">* element is visually in the same place in the document but its position</span>
                     <span class="s3">* relative to its parent has indeed changed. So here we check for that.</span>
                     <span class="s3">*/</span>
                    <span class="s2">const </span><span class="s1">hasOnlyRelativeTargetChanged = !hasLayoutChanged &amp;&amp; hasRelativeLayoutChanged;</span>
                    <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.layoutRoot ||</span>
                        <span class="s2">this</span><span class="s1">.resumeFrom ||</span>
                        <span class="s1">hasOnlyRelativeTargetChanged ||</span>
                        <span class="s1">(hasLayoutChanged &amp;&amp;</span>
                            <span class="s1">(hasTargetChanged || !</span><span class="s2">this</span><span class="s1">.currentAnimation))) {</span>
                        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.resumeFrom) {</span>
                            <span class="s2">this</span><span class="s1">.resumingFrom = </span><span class="s2">this</span><span class="s1">.resumeFrom;</span>
                            <span class="s2">this</span><span class="s1">.resumingFrom.resumingFrom = undefined;</span>
                        <span class="s1">}</span>
                        <span class="s2">const </span><span class="s1">animationOptions = {</span>
                            <span class="s1">...motionDom.getValueTransition(layoutTransition, </span><span class="s0">&quot;layout&quot;</span><span class="s1">),</span>
                            <span class="s1">onPlay: onLayoutAnimationStart,</span>
                            <span class="s1">onComplete: onLayoutAnimationComplete,</span>
                        <span class="s1">};</span>
                        <span class="s2">if </span><span class="s1">(visualElement.shouldReduceMotion ||</span>
                            <span class="s2">this</span><span class="s1">.options.layoutRoot) {</span>
                            <span class="s1">animationOptions.delay = </span><span class="s5">0</span><span class="s1">;</span>
                            <span class="s1">animationOptions.type = </span><span class="s2">false</span><span class="s1">;</span>
                        <span class="s1">}</span>
                        <span class="s2">this</span><span class="s1">.startAnimation(animationOptions);</span>
                        <span class="s3">/**</span>
                         <span class="s3">* Set animation origin after starting animation to avoid layout jump</span>
                         <span class="s3">* caused by stopping previous layout animation</span>
                         <span class="s3">*/</span>
                        <span class="s2">this</span><span class="s1">.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s3">/**</span>
                         <span class="s3">* If the layout hasn't changed and we have an animation that hasn't started yet,</span>
                         <span class="s3">* finish it immediately. Otherwise it will be animating from a location</span>
                         <span class="s3">* that was probably never commited to screen and look like a jumpy box.</span>
                         <span class="s3">*/</span>
                        <span class="s2">if </span><span class="s1">(!hasLayoutChanged) {</span>
                            <span class="s1">finishAnimation(</span><span class="s2">this</span><span class="s1">);</span>
                        <span class="s1">}</span>
                        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isLead() &amp;&amp; </span><span class="s2">this</span><span class="s1">.options.onExitComplete) {</span>
                            <span class="s2">this</span><span class="s1">.options.onExitComplete();</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s2">this</span><span class="s1">.targetLayout = newLayout;</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">unmount() {</span>
            <span class="s2">this</span><span class="s1">.options.layoutId &amp;&amp; </span><span class="s2">this</span><span class="s1">.willUpdate();</span>
            <span class="s2">this</span><span class="s1">.root.nodes.remove(</span><span class="s2">this</span><span class="s1">);</span>
            <span class="s2">const </span><span class="s1">stack = </span><span class="s2">this</span><span class="s1">.getStack();</span>
            <span class="s1">stack &amp;&amp; stack.remove(</span><span class="s2">this</span><span class="s1">);</span>
            <span class="s2">this</span><span class="s1">.parent &amp;&amp; </span><span class="s2">this</span><span class="s1">.parent.children.delete(</span><span class="s2">this</span><span class="s1">);</span>
            <span class="s2">this</span><span class="s1">.instance = undefined;</span>
            <span class="s2">this</span><span class="s1">.eventHandlers.clear();</span>
            <span class="s1">motionDom.cancelFrame(</span><span class="s2">this</span><span class="s1">.updateProjection);</span>
        <span class="s1">}</span>
        <span class="s3">// only on the root</span>
        <span class="s1">blockUpdate() {</span>
            <span class="s2">this</span><span class="s1">.updateManuallyBlocked = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">unblockUpdate() {</span>
            <span class="s2">this</span><span class="s1">.updateManuallyBlocked = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">isUpdateBlocked() {</span>
            <span class="s2">return this</span><span class="s1">.updateManuallyBlocked || </span><span class="s2">this</span><span class="s1">.updateBlockedByResize;</span>
        <span class="s1">}</span>
        <span class="s1">isTreeAnimationBlocked() {</span>
            <span class="s2">return </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isAnimationBlocked ||</span>
                <span class="s1">(</span><span class="s2">this</span><span class="s1">.parent &amp;&amp; </span><span class="s2">this</span><span class="s1">.parent.isTreeAnimationBlocked()) ||</span>
                <span class="s2">false</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s3">// Note: currently only running on root node</span>
        <span class="s1">startUpdate() {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isUpdateBlocked())</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s2">this</span><span class="s1">.isUpdating = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s2">this</span><span class="s1">.nodes &amp;&amp; </span><span class="s2">this</span><span class="s1">.nodes.forEach(resetSkewAndRotation);</span>
            <span class="s2">this</span><span class="s1">.animationId++;</span>
        <span class="s1">}</span>
        <span class="s1">getTransformTemplate() {</span>
            <span class="s2">const </span><span class="s1">{ visualElement } = </span><span class="s2">this</span><span class="s1">.options;</span>
            <span class="s2">return </span><span class="s1">visualElement &amp;&amp; visualElement.getProps().transformTemplate;</span>
        <span class="s1">}</span>
        <span class="s1">willUpdate(shouldNotifyListeners = </span><span class="s2">true</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.root.hasTreeAnimated = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.root.isUpdateBlocked()) {</span>
                <span class="s2">this</span><span class="s1">.options.onExitComplete &amp;&amp; </span><span class="s2">this</span><span class="s1">.options.onExitComplete();</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">/**</span>
             <span class="s3">* If we're running optimised appear animations then these must be</span>
             <span class="s3">* cancelled before measuring the DOM. This is so we can measure</span>
             <span class="s3">* the true layout of the element rather than the WAAPI animation</span>
             <span class="s3">* which will be unaffected by the resetSkewAndRotate step.</span>
             <span class="s3">*</span>
             <span class="s3">* Note: This is a DOM write. Worst case scenario is this is sandwiched</span>
             <span class="s3">* between other snapshot reads which will cause unnecessary style recalculations.</span>
             <span class="s3">* This has to happen here though, as we don't yet know which nodes will need</span>
             <span class="s3">* snapshots in startUpdate(), but we only want to cancel optimised animations</span>
             <span class="s3">* if a layout animation measurement is actually going to be affected by them.</span>
             <span class="s3">*/</span>
            <span class="s2">if </span><span class="s1">(window.MotionCancelOptimisedAnimation &amp;&amp;</span>
                <span class="s1">!</span><span class="s2">this</span><span class="s1">.hasCheckedOptimisedAppear) {</span>
                <span class="s1">cancelTreeOptimisedTransformAnimations(</span><span class="s2">this</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s1">!</span><span class="s2">this</span><span class="s1">.root.isUpdating &amp;&amp; </span><span class="s2">this</span><span class="s1">.root.startUpdate();</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isLayoutDirty)</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s2">this</span><span class="s1">.isLayoutDirty = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; </span><span class="s2">this</span><span class="s1">.path.length; i++) {</span>
                <span class="s2">const </span><span class="s1">node = </span><span class="s2">this</span><span class="s1">.path[i];</span>
                <span class="s1">node.shouldResetTransform = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">node.updateScroll(</span><span class="s0">&quot;snapshot&quot;</span><span class="s1">);</span>
                <span class="s2">if </span><span class="s1">(node.options.layoutRoot) {</span>
                    <span class="s1">node.willUpdate(</span><span class="s2">false</span><span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">{ layoutId, layout } = </span><span class="s2">this</span><span class="s1">.options;</span>
            <span class="s2">if </span><span class="s1">(layoutId === undefined &amp;&amp; !layout)</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s2">const </span><span class="s1">transformTemplate = </span><span class="s2">this</span><span class="s1">.getTransformTemplate();</span>
            <span class="s2">this</span><span class="s1">.prevTransformTemplateValue = transformTemplate</span>
                <span class="s1">? transformTemplate(</span><span class="s2">this</span><span class="s1">.latestValues, </span><span class="s0">&quot;&quot;</span><span class="s1">)</span>
                <span class="s1">: undefined;</span>
            <span class="s2">this</span><span class="s1">.updateSnapshot();</span>
            <span class="s1">shouldNotifyListeners &amp;&amp; </span><span class="s2">this</span><span class="s1">.notifyListeners(</span><span class="s0">&quot;willUpdate&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s1">update() {</span>
            <span class="s2">this</span><span class="s1">.updateScheduled = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s2">const </span><span class="s1">updateWasBlocked = </span><span class="s2">this</span><span class="s1">.isUpdateBlocked();</span>
            <span class="s3">// When doing an instant transition, we skip the layout update,</span>
            <span class="s3">// but should still clean up the measurements so that the next</span>
            <span class="s3">// snapshot could be taken correctly.</span>
            <span class="s2">if </span><span class="s1">(updateWasBlocked) {</span>
                <span class="s2">this</span><span class="s1">.unblockUpdate();</span>
                <span class="s2">this</span><span class="s1">.clearAllSnapshots();</span>
                <span class="s2">this</span><span class="s1">.nodes.forEach(clearMeasurements);</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">/**</span>
             <span class="s3">* If this is a repeat of didUpdate then ignore the animation.</span>
             <span class="s3">*/</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.animationId &lt;= </span><span class="s2">this</span><span class="s1">.animationCommitId) {</span>
                <span class="s2">this</span><span class="s1">.nodes.forEach(clearIsLayoutDirty);</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">this</span><span class="s1">.animationCommitId = </span><span class="s2">this</span><span class="s1">.animationId;</span>
            <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.isUpdating) {</span>
                <span class="s2">this</span><span class="s1">.nodes.forEach(clearIsLayoutDirty);</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">this</span><span class="s1">.isUpdating = </span><span class="s2">false</span><span class="s1">;</span>
                <span class="s3">/**</span>
                 <span class="s3">* Write</span>
                 <span class="s3">*/</span>
                <span class="s2">this</span><span class="s1">.nodes.forEach(resetTransformStyle);</span>
                <span class="s3">/**</span>
                 <span class="s3">* Read ==================</span>
                 <span class="s3">*/</span>
                <span class="s3">// Update layout measurements of updated children</span>
                <span class="s2">this</span><span class="s1">.nodes.forEach(updateLayout);</span>
                <span class="s3">/**</span>
                 <span class="s3">* Write</span>
                 <span class="s3">*/</span>
                <span class="s3">// Notify listeners that the layout is updated</span>
                <span class="s2">this</span><span class="s1">.nodes.forEach(notifyLayoutUpdate);</span>
            <span class="s1">}</span>
            <span class="s2">this</span><span class="s1">.clearAllSnapshots();</span>
            <span class="s3">/**</span>
             <span class="s3">* Manually flush any pending updates. Ideally</span>
             <span class="s3">* we could leave this to the following requestAnimationFrame but this seems</span>
             <span class="s3">* to leave a flash of incorrectly styled content.</span>
             <span class="s3">*/</span>
            <span class="s2">const </span><span class="s1">now = motionDom.time.now();</span>
            <span class="s1">motionDom.frameData.delta = motionUtils.clamp(</span><span class="s5">0</span><span class="s1">, </span><span class="s5">1000 </span><span class="s1">/ </span><span class="s5">60</span><span class="s1">, now - motionDom.frameData.timestamp);</span>
            <span class="s1">motionDom.frameData.timestamp = now;</span>
            <span class="s1">motionDom.frameData.isProcessing = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">motionDom.frameSteps.update.process(motionDom.frameData);</span>
            <span class="s1">motionDom.frameSteps.preRender.process(motionDom.frameData);</span>
            <span class="s1">motionDom.frameSteps.render.process(motionDom.frameData);</span>
            <span class="s1">motionDom.frameData.isProcessing = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">didUpdate() {</span>
            <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.updateScheduled) {</span>
                <span class="s2">this</span><span class="s1">.updateScheduled = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">motionDom.microtask.read(</span><span class="s2">this</span><span class="s1">.scheduleUpdate);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">clearAllSnapshots() {</span>
            <span class="s2">this</span><span class="s1">.nodes.forEach(clearSnapshot);</span>
            <span class="s2">this</span><span class="s1">.sharedNodes.forEach(removeLeadSnapshots);</span>
        <span class="s1">}</span>
        <span class="s1">scheduleUpdateProjection() {</span>
            <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.projectionUpdateScheduled) {</span>
                <span class="s2">this</span><span class="s1">.projectionUpdateScheduled = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">motionDom.frame.preRender(</span><span class="s2">this</span><span class="s1">.updateProjection, </span><span class="s2">false</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">scheduleCheckAfterUnmount() {</span>
            <span class="s3">/**</span>
             <span class="s3">* If the unmounting node is in a layoutGroup and did trigger a willUpdate,</span>
             <span class="s3">* we manually call didUpdate to give a chance to the siblings to animate.</span>
             <span class="s3">* Otherwise, cleanup all snapshots to prevents future nodes from reusing them.</span>
             <span class="s3">*/</span>
            <span class="s1">motionDom.frame.postRender(() =&gt; {</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isLayoutDirty) {</span>
                    <span class="s2">this</span><span class="s1">.root.didUpdate();</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">this</span><span class="s1">.root.checkUpdateFailed();</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Update measurements</span>
         <span class="s3">*/</span>
        <span class="s1">updateSnapshot() {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.snapshot || !</span><span class="s2">this</span><span class="s1">.instance)</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s2">this</span><span class="s1">.snapshot = </span><span class="s2">this</span><span class="s1">.measure();</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.snapshot &amp;&amp;</span>
                <span class="s1">!calcLength(</span><span class="s2">this</span><span class="s1">.snapshot.measuredBox.x) &amp;&amp;</span>
                <span class="s1">!calcLength(</span><span class="s2">this</span><span class="s1">.snapshot.measuredBox.y)) {</span>
                <span class="s2">this</span><span class="s1">.snapshot = undefined;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">updateLayout() {</span>
            <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.instance)</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s2">this</span><span class="s1">.updateScroll();</span>
            <span class="s2">if </span><span class="s1">(!(</span><span class="s2">this</span><span class="s1">.options.alwaysMeasureLayout &amp;&amp; </span><span class="s2">this</span><span class="s1">.isLead()) &amp;&amp;</span>
                <span class="s1">!</span><span class="s2">this</span><span class="s1">.isLayoutDirty) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">/**</span>
             <span class="s3">* When a node is mounted, it simply resumes from the prevLead's</span>
             <span class="s3">* snapshot instead of taking a new one, but the ancestors scroll</span>
             <span class="s3">* might have updated while the prevLead is unmounted. We need to</span>
             <span class="s3">* update the scroll again to make sure the layout we measure is</span>
             <span class="s3">* up to date.</span>
             <span class="s3">*/</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.resumeFrom &amp;&amp; !</span><span class="s2">this</span><span class="s1">.resumeFrom.instance) {</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; </span><span class="s2">this</span><span class="s1">.path.length; i++) {</span>
                    <span class="s2">const </span><span class="s1">node = </span><span class="s2">this</span><span class="s1">.path[i];</span>
                    <span class="s1">node.updateScroll();</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">prevLayout = </span><span class="s2">this</span><span class="s1">.layout;</span>
            <span class="s2">this</span><span class="s1">.layout = </span><span class="s2">this</span><span class="s1">.measure(</span><span class="s2">false</span><span class="s1">);</span>
            <span class="s2">this</span><span class="s1">.layoutCorrected = createBox();</span>
            <span class="s2">this</span><span class="s1">.isLayoutDirty = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s2">this</span><span class="s1">.projectionDelta = undefined;</span>
            <span class="s2">this</span><span class="s1">.notifyListeners(</span><span class="s0">&quot;measure&quot;</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.layout.layoutBox);</span>
            <span class="s2">const </span><span class="s1">{ visualElement } = </span><span class="s2">this</span><span class="s1">.options;</span>
            <span class="s1">visualElement &amp;&amp;</span>
                <span class="s1">visualElement.notify(</span><span class="s0">&quot;LayoutMeasure&quot;</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.layout.layoutBox, prevLayout ? prevLayout.layoutBox : undefined);</span>
        <span class="s1">}</span>
        <span class="s1">updateScroll(phase = </span><span class="s0">&quot;measure&quot;</span><span class="s1">) {</span>
            <span class="s2">let </span><span class="s1">needsMeasurement = Boolean(</span><span class="s2">this</span><span class="s1">.options.layoutScroll &amp;&amp; </span><span class="s2">this</span><span class="s1">.instance);</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.scroll &amp;&amp;</span>
                <span class="s2">this</span><span class="s1">.scroll.animationId === </span><span class="s2">this</span><span class="s1">.root.animationId &amp;&amp;</span>
                <span class="s2">this</span><span class="s1">.scroll.phase === phase) {</span>
                <span class="s1">needsMeasurement = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(needsMeasurement &amp;&amp; </span><span class="s2">this</span><span class="s1">.instance) {</span>
                <span class="s2">const </span><span class="s1">isRoot = checkIsScrollRoot(</span><span class="s2">this</span><span class="s1">.instance);</span>
                <span class="s2">this</span><span class="s1">.scroll = {</span>
                    <span class="s1">animationId: </span><span class="s2">this</span><span class="s1">.root.animationId,</span>
                    <span class="s1">phase,</span>
                    <span class="s1">isRoot,</span>
                    <span class="s1">offset: measureScroll(</span><span class="s2">this</span><span class="s1">.instance),</span>
                    <span class="s1">wasRoot: </span><span class="s2">this</span><span class="s1">.scroll ? </span><span class="s2">this</span><span class="s1">.scroll.isRoot : isRoot,</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">resetTransform() {</span>
            <span class="s2">if </span><span class="s1">(!resetTransform)</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s2">const </span><span class="s1">isResetRequested = </span><span class="s2">this</span><span class="s1">.isLayoutDirty ||</span>
                <span class="s2">this</span><span class="s1">.shouldResetTransform ||</span>
                <span class="s2">this</span><span class="s1">.options.alwaysMeasureLayout;</span>
            <span class="s2">const </span><span class="s1">hasProjection = </span><span class="s2">this</span><span class="s1">.projectionDelta &amp;&amp; !isDeltaZero(</span><span class="s2">this</span><span class="s1">.projectionDelta);</span>
            <span class="s2">const </span><span class="s1">transformTemplate = </span><span class="s2">this</span><span class="s1">.getTransformTemplate();</span>
            <span class="s2">const </span><span class="s1">transformTemplateValue = transformTemplate</span>
                <span class="s1">? transformTemplate(</span><span class="s2">this</span><span class="s1">.latestValues, </span><span class="s0">&quot;&quot;</span><span class="s1">)</span>
                <span class="s1">: undefined;</span>
            <span class="s2">const </span><span class="s1">transformTemplateHasChanged = transformTemplateValue !== </span><span class="s2">this</span><span class="s1">.prevTransformTemplateValue;</span>
            <span class="s2">if </span><span class="s1">(isResetRequested &amp;&amp;</span>
                <span class="s2">this</span><span class="s1">.instance &amp;&amp;</span>
                <span class="s1">(hasProjection ||</span>
                    <span class="s1">hasTransform(</span><span class="s2">this</span><span class="s1">.latestValues) ||</span>
                    <span class="s1">transformTemplateHasChanged)) {</span>
                <span class="s1">resetTransform(</span><span class="s2">this</span><span class="s1">.instance, transformTemplateValue);</span>
                <span class="s2">this</span><span class="s1">.shouldResetTransform = </span><span class="s2">false</span><span class="s1">;</span>
                <span class="s2">this</span><span class="s1">.scheduleRender();</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">measure(removeTransform = </span><span class="s2">true</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">pageBox = </span><span class="s2">this</span><span class="s1">.measurePageBox();</span>
            <span class="s2">let </span><span class="s1">layoutBox = </span><span class="s2">this</span><span class="s1">.removeElementScroll(pageBox);</span>
            <span class="s3">/**</span>
             <span class="s3">* Measurements taken during the pre-render stage</span>
             <span class="s3">* still have transforms applied so we remove them</span>
             <span class="s3">* via calculation.</span>
             <span class="s3">*/</span>
            <span class="s2">if </span><span class="s1">(removeTransform) {</span>
                <span class="s1">layoutBox = </span><span class="s2">this</span><span class="s1">.removeTransform(layoutBox);</span>
            <span class="s1">}</span>
            <span class="s1">roundBox(layoutBox);</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">animationId: </span><span class="s2">this</span><span class="s1">.root.animationId,</span>
                <span class="s1">measuredBox: pageBox,</span>
                <span class="s1">layoutBox,</span>
                <span class="s1">latestValues: {},</span>
                <span class="s1">source: </span><span class="s2">this</span><span class="s1">.id,</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s1">measurePageBox() {</span>
            <span class="s2">const </span><span class="s1">{ visualElement } = </span><span class="s2">this</span><span class="s1">.options;</span>
            <span class="s2">if </span><span class="s1">(!visualElement)</span>
                <span class="s2">return </span><span class="s1">createBox();</span>
            <span class="s2">const </span><span class="s1">box = visualElement.measureViewportBox();</span>
            <span class="s2">const </span><span class="s1">wasInScrollRoot = </span><span class="s2">this</span><span class="s1">.scroll?.wasRoot || </span><span class="s2">this</span><span class="s1">.path.some(checkNodeWasScrollRoot);</span>
            <span class="s2">if </span><span class="s1">(!wasInScrollRoot) {</span>
                <span class="s3">// Remove viewport scroll to give page-relative coordinates</span>
                <span class="s2">const </span><span class="s1">{ scroll } = </span><span class="s2">this</span><span class="s1">.root;</span>
                <span class="s2">if </span><span class="s1">(scroll) {</span>
                    <span class="s1">translateAxis(box.x, scroll.offset.x);</span>
                    <span class="s1">translateAxis(box.y, scroll.offset.y);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">box;</span>
        <span class="s1">}</span>
        <span class="s1">removeElementScroll(box) {</span>
            <span class="s2">const </span><span class="s1">boxWithoutScroll = createBox();</span>
            <span class="s1">copyBoxInto(boxWithoutScroll, box);</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.scroll?.wasRoot) {</span>
                <span class="s2">return </span><span class="s1">boxWithoutScroll;</span>
            <span class="s1">}</span>
            <span class="s3">/**</span>
             <span class="s3">* Performance TODO: Keep a cumulative scroll offset down the tree</span>
             <span class="s3">* rather than loop back up the path.</span>
             <span class="s3">*/</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; </span><span class="s2">this</span><span class="s1">.path.length; i++) {</span>
                <span class="s2">const </span><span class="s1">node = </span><span class="s2">this</span><span class="s1">.path[i];</span>
                <span class="s2">const </span><span class="s1">{ scroll, options } = node;</span>
                <span class="s2">if </span><span class="s1">(node !== </span><span class="s2">this</span><span class="s1">.root &amp;&amp; scroll &amp;&amp; options.layoutScroll) {</span>
                    <span class="s3">/**</span>
                     <span class="s3">* If this is a new scroll root, we want to remove all previous scrolls</span>
                     <span class="s3">* from the viewport box.</span>
                     <span class="s3">*/</span>
                    <span class="s2">if </span><span class="s1">(scroll.wasRoot) {</span>
                        <span class="s1">copyBoxInto(boxWithoutScroll, box);</span>
                    <span class="s1">}</span>
                    <span class="s1">translateAxis(boxWithoutScroll.x, scroll.offset.x);</span>
                    <span class="s1">translateAxis(boxWithoutScroll.y, scroll.offset.y);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">boxWithoutScroll;</span>
        <span class="s1">}</span>
        <span class="s1">applyTransform(box, transformOnly = </span><span class="s2">false</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">withTransforms = createBox();</span>
            <span class="s1">copyBoxInto(withTransforms, box);</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; </span><span class="s2">this</span><span class="s1">.path.length; i++) {</span>
                <span class="s2">const </span><span class="s1">node = </span><span class="s2">this</span><span class="s1">.path[i];</span>
                <span class="s2">if </span><span class="s1">(!transformOnly &amp;&amp;</span>
                    <span class="s1">node.options.layoutScroll &amp;&amp;</span>
                    <span class="s1">node.scroll &amp;&amp;</span>
                    <span class="s1">node !== node.root) {</span>
                    <span class="s1">transformBox(withTransforms, {</span>
                        <span class="s1">x: -node.scroll.offset.x,</span>
                        <span class="s1">y: -node.scroll.offset.y,</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(!hasTransform(node.latestValues))</span>
                    <span class="s2">continue</span><span class="s1">;</span>
                <span class="s1">transformBox(withTransforms, node.latestValues);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(hasTransform(</span><span class="s2">this</span><span class="s1">.latestValues)) {</span>
                <span class="s1">transformBox(withTransforms, </span><span class="s2">this</span><span class="s1">.latestValues);</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">withTransforms;</span>
        <span class="s1">}</span>
        <span class="s1">removeTransform(box) {</span>
            <span class="s2">const </span><span class="s1">boxWithoutTransform = createBox();</span>
            <span class="s1">copyBoxInto(boxWithoutTransform, box);</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; </span><span class="s2">this</span><span class="s1">.path.length; i++) {</span>
                <span class="s2">const </span><span class="s1">node = </span><span class="s2">this</span><span class="s1">.path[i];</span>
                <span class="s2">if </span><span class="s1">(!node.instance)</span>
                    <span class="s2">continue</span><span class="s1">;</span>
                <span class="s2">if </span><span class="s1">(!hasTransform(node.latestValues))</span>
                    <span class="s2">continue</span><span class="s1">;</span>
                <span class="s1">hasScale(node.latestValues) &amp;&amp; node.updateSnapshot();</span>
                <span class="s2">const </span><span class="s1">sourceBox = createBox();</span>
                <span class="s2">const </span><span class="s1">nodeBox = node.measurePageBox();</span>
                <span class="s1">copyBoxInto(sourceBox, nodeBox);</span>
                <span class="s1">removeBoxTransforms(boxWithoutTransform, node.latestValues, node.snapshot ? node.snapshot.layoutBox : undefined, sourceBox);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(hasTransform(</span><span class="s2">this</span><span class="s1">.latestValues)) {</span>
                <span class="s1">removeBoxTransforms(boxWithoutTransform, </span><span class="s2">this</span><span class="s1">.latestValues);</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">boxWithoutTransform;</span>
        <span class="s1">}</span>
        <span class="s1">setTargetDelta(delta) {</span>
            <span class="s2">this</span><span class="s1">.targetDelta = delta;</span>
            <span class="s2">this</span><span class="s1">.root.scheduleUpdateProjection();</span>
            <span class="s2">this</span><span class="s1">.isProjectionDirty = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">setOptions(options) {</span>
            <span class="s2">this</span><span class="s1">.options = {</span>
                <span class="s1">...</span><span class="s2">this</span><span class="s1">.options,</span>
                <span class="s1">...options,</span>
                <span class="s1">crossfade: options.crossfade !== undefined ? options.crossfade : </span><span class="s2">true</span><span class="s1">,</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s1">clearMeasurements() {</span>
            <span class="s2">this</span><span class="s1">.scroll = undefined;</span>
            <span class="s2">this</span><span class="s1">.layout = undefined;</span>
            <span class="s2">this</span><span class="s1">.snapshot = undefined;</span>
            <span class="s2">this</span><span class="s1">.prevTransformTemplateValue = undefined;</span>
            <span class="s2">this</span><span class="s1">.targetDelta = undefined;</span>
            <span class="s2">this</span><span class="s1">.target = undefined;</span>
            <span class="s2">this</span><span class="s1">.isLayoutDirty = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">forceRelativeParentToResolveTarget() {</span>
            <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.relativeParent)</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s3">/**</span>
             <span class="s3">* If the parent target isn't up-to-date, force it to update.</span>
             <span class="s3">* This is an unfortunate de-optimisation as it means any updating relative</span>
             <span class="s3">* projection will cause all the relative parents to recalculate back</span>
             <span class="s3">* up the tree.</span>
             <span class="s3">*/</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.relativeParent.resolvedRelativeTargetAt !==</span>
                <span class="s1">motionDom.frameData.timestamp) {</span>
                <span class="s2">this</span><span class="s1">.relativeParent.resolveTargetDelta(</span><span class="s2">true</span><span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">resolveTargetDelta(forceRecalculation = </span><span class="s2">false</span><span class="s1">) {</span>
            <span class="s3">/**</span>
             <span class="s3">* Once the dirty status of nodes has been spread through the tree, we also</span>
             <span class="s3">* need to check if we have a shared node of a different depth that has itself</span>
             <span class="s3">* been dirtied.</span>
             <span class="s3">*/</span>
            <span class="s2">const </span><span class="s1">lead = </span><span class="s2">this</span><span class="s1">.getLead();</span>
            <span class="s2">this</span><span class="s1">.isProjectionDirty || (</span><span class="s2">this</span><span class="s1">.isProjectionDirty = lead.isProjectionDirty);</span>
            <span class="s2">this</span><span class="s1">.isTransformDirty || (</span><span class="s2">this</span><span class="s1">.isTransformDirty = lead.isTransformDirty);</span>
            <span class="s2">this</span><span class="s1">.isSharedProjectionDirty || (</span><span class="s2">this</span><span class="s1">.isSharedProjectionDirty = lead.isSharedProjectionDirty);</span>
            <span class="s2">const </span><span class="s1">isShared = Boolean(</span><span class="s2">this</span><span class="s1">.resumingFrom) || </span><span class="s2">this </span><span class="s1">!== lead;</span>
            <span class="s3">/**</span>
             <span class="s3">* We don't use transform for this step of processing so we don't</span>
             <span class="s3">* need to check whether any nodes have changed transform.</span>
             <span class="s3">*/</span>
            <span class="s2">const </span><span class="s1">canSkip = !(forceRecalculation ||</span>
                <span class="s1">(isShared &amp;&amp; </span><span class="s2">this</span><span class="s1">.isSharedProjectionDirty) ||</span>
                <span class="s2">this</span><span class="s1">.isProjectionDirty ||</span>
                <span class="s2">this</span><span class="s1">.parent?.isProjectionDirty ||</span>
                <span class="s2">this</span><span class="s1">.attemptToResolveRelativeTarget ||</span>
                <span class="s2">this</span><span class="s1">.root.updateBlockedByResize);</span>
            <span class="s2">if </span><span class="s1">(canSkip)</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s2">const </span><span class="s1">{ layout, layoutId } = </span><span class="s2">this</span><span class="s1">.options;</span>
            <span class="s3">/**</span>
             <span class="s3">* If we have no layout, we can't perform projection, so early return</span>
             <span class="s3">*/</span>
            <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.layout || !(layout || layoutId))</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s2">this</span><span class="s1">.resolvedRelativeTargetAt = motionDom.frameData.timestamp;</span>
            <span class="s3">/**</span>
             <span class="s3">* If we don't have a targetDelta but do have a layout, we can attempt to resolve</span>
             <span class="s3">* a relativeParent. This will allow a component to perform scale correction</span>
             <span class="s3">* even if no animation has started.</span>
             <span class="s3">*/</span>
            <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.targetDelta &amp;&amp; !</span><span class="s2">this</span><span class="s1">.relativeTarget) {</span>
                <span class="s2">const </span><span class="s1">relativeParent = </span><span class="s2">this</span><span class="s1">.getClosestProjectingParent();</span>
                <span class="s2">if </span><span class="s1">(relativeParent &amp;&amp;</span>
                    <span class="s1">relativeParent.layout &amp;&amp;</span>
                    <span class="s2">this</span><span class="s1">.animationProgress !== </span><span class="s5">1</span><span class="s1">) {</span>
                    <span class="s2">this</span><span class="s1">.relativeParent = relativeParent;</span>
                    <span class="s2">this</span><span class="s1">.forceRelativeParentToResolveTarget();</span>
                    <span class="s2">this</span><span class="s1">.relativeTarget = createBox();</span>
                    <span class="s2">this</span><span class="s1">.relativeTargetOrigin = createBox();</span>
                    <span class="s1">calcRelativePosition(</span><span class="s2">this</span><span class="s1">.relativeTargetOrigin, </span><span class="s2">this</span><span class="s1">.layout.layoutBox, relativeParent.layout.layoutBox);</span>
                    <span class="s1">copyBoxInto(</span><span class="s2">this</span><span class="s1">.relativeTarget, </span><span class="s2">this</span><span class="s1">.relativeTargetOrigin);</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">this</span><span class="s1">.relativeParent = </span><span class="s2">this</span><span class="s1">.relativeTarget = undefined;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">/**</span>
             <span class="s3">* If we have no relative target or no target delta our target isn't valid</span>
             <span class="s3">* for this frame.</span>
             <span class="s3">*/</span>
            <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.relativeTarget &amp;&amp; !</span><span class="s2">this</span><span class="s1">.targetDelta)</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s3">/**</span>
             <span class="s3">* Lazy-init target data structure</span>
             <span class="s3">*/</span>
            <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.target) {</span>
                <span class="s2">this</span><span class="s1">.target = createBox();</span>
                <span class="s2">this</span><span class="s1">.targetWithTransforms = createBox();</span>
            <span class="s1">}</span>
            <span class="s3">/**</span>
             <span class="s3">* If we've got a relative box for this component, resolve it into a target relative to the parent.</span>
             <span class="s3">*/</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.relativeTarget &amp;&amp;</span>
                <span class="s2">this</span><span class="s1">.relativeTargetOrigin &amp;&amp;</span>
                <span class="s2">this</span><span class="s1">.relativeParent &amp;&amp;</span>
                <span class="s2">this</span><span class="s1">.relativeParent.target) {</span>
                <span class="s2">this</span><span class="s1">.forceRelativeParentToResolveTarget();</span>
                <span class="s1">calcRelativeBox(</span><span class="s2">this</span><span class="s1">.target, </span><span class="s2">this</span><span class="s1">.relativeTarget, </span><span class="s2">this</span><span class="s1">.relativeParent.target);</span>
                <span class="s3">/**</span>
                 <span class="s3">* If we've only got a targetDelta, resolve it into a target</span>
                 <span class="s3">*/</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.targetDelta) {</span>
                <span class="s2">if </span><span class="s1">(Boolean(</span><span class="s2">this</span><span class="s1">.resumingFrom)) {</span>
                    <span class="s3">// TODO: This is creating a new object every frame</span>
                    <span class="s2">this</span><span class="s1">.target = </span><span class="s2">this</span><span class="s1">.applyTransform(</span><span class="s2">this</span><span class="s1">.layout.layoutBox);</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">copyBoxInto(</span><span class="s2">this</span><span class="s1">.target, </span><span class="s2">this</span><span class="s1">.layout.layoutBox);</span>
                <span class="s1">}</span>
                <span class="s1">applyBoxDelta(</span><span class="s2">this</span><span class="s1">.target, </span><span class="s2">this</span><span class="s1">.targetDelta);</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s3">/**</span>
                 <span class="s3">* If no target, use own layout as target</span>
                 <span class="s3">*/</span>
                <span class="s1">copyBoxInto(</span><span class="s2">this</span><span class="s1">.target, </span><span class="s2">this</span><span class="s1">.layout.layoutBox);</span>
            <span class="s1">}</span>
            <span class="s3">/**</span>
             <span class="s3">* If we've been told to attempt to resolve a relative target, do so.</span>
             <span class="s3">*/</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.attemptToResolveRelativeTarget) {</span>
                <span class="s2">this</span><span class="s1">.attemptToResolveRelativeTarget = </span><span class="s2">false</span><span class="s1">;</span>
                <span class="s2">const </span><span class="s1">relativeParent = </span><span class="s2">this</span><span class="s1">.getClosestProjectingParent();</span>
                <span class="s2">if </span><span class="s1">(relativeParent &amp;&amp;</span>
                    <span class="s1">Boolean(relativeParent.resumingFrom) ===</span>
                        <span class="s1">Boolean(</span><span class="s2">this</span><span class="s1">.resumingFrom) &amp;&amp;</span>
                    <span class="s1">!relativeParent.options.layoutScroll &amp;&amp;</span>
                    <span class="s1">relativeParent.target &amp;&amp;</span>
                    <span class="s2">this</span><span class="s1">.animationProgress !== </span><span class="s5">1</span><span class="s1">) {</span>
                    <span class="s2">this</span><span class="s1">.relativeParent = relativeParent;</span>
                    <span class="s2">this</span><span class="s1">.forceRelativeParentToResolveTarget();</span>
                    <span class="s2">this</span><span class="s1">.relativeTarget = createBox();</span>
                    <span class="s2">this</span><span class="s1">.relativeTargetOrigin = createBox();</span>
                    <span class="s1">calcRelativePosition(</span><span class="s2">this</span><span class="s1">.relativeTargetOrigin, </span><span class="s2">this</span><span class="s1">.target, relativeParent.target);</span>
                    <span class="s1">copyBoxInto(</span><span class="s2">this</span><span class="s1">.relativeTarget, </span><span class="s2">this</span><span class="s1">.relativeTargetOrigin);</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">this</span><span class="s1">.relativeParent = </span><span class="s2">this</span><span class="s1">.relativeTarget = undefined;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">/**</span>
             <span class="s3">* Increase debug counter for resolved target deltas</span>
             <span class="s3">*/</span>
            <span class="s2">if </span><span class="s1">(motionDom.statsBuffer.value) {</span>
                <span class="s1">metrics.calculatedTargetDeltas++;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">getClosestProjectingParent() {</span>
            <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.parent ||</span>
                <span class="s1">hasScale(</span><span class="s2">this</span><span class="s1">.parent.latestValues) ||</span>
                <span class="s1">has2DTranslate(</span><span class="s2">this</span><span class="s1">.parent.latestValues)) {</span>
                <span class="s2">return </span><span class="s1">undefined;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.parent.isProjecting()) {</span>
                <span class="s2">return this</span><span class="s1">.parent;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">return this</span><span class="s1">.parent.getClosestProjectingParent();</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">isProjecting() {</span>
            <span class="s2">return </span><span class="s1">Boolean((</span><span class="s2">this</span><span class="s1">.relativeTarget ||</span>
                <span class="s2">this</span><span class="s1">.targetDelta ||</span>
                <span class="s2">this</span><span class="s1">.options.layoutRoot) &amp;&amp;</span>
                <span class="s2">this</span><span class="s1">.layout);</span>
        <span class="s1">}</span>
        <span class="s1">calcProjection() {</span>
            <span class="s2">const </span><span class="s1">lead = </span><span class="s2">this</span><span class="s1">.getLead();</span>
            <span class="s2">const </span><span class="s1">isShared = Boolean(</span><span class="s2">this</span><span class="s1">.resumingFrom) || </span><span class="s2">this </span><span class="s1">!== lead;</span>
            <span class="s2">let </span><span class="s1">canSkip = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s3">/**</span>
             <span class="s3">* If this is a normal layout animation and neither this node nor its nearest projecting</span>
             <span class="s3">* is dirty then we can't skip.</span>
             <span class="s3">*/</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isProjectionDirty || </span><span class="s2">this</span><span class="s1">.parent?.isProjectionDirty) {</span>
                <span class="s1">canSkip = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">/**</span>
             <span class="s3">* If this is a shared layout animation and this node's shared projection is dirty then</span>
             <span class="s3">* we can't skip.</span>
             <span class="s3">*/</span>
            <span class="s2">if </span><span class="s1">(isShared &amp;&amp;</span>
                <span class="s1">(</span><span class="s2">this</span><span class="s1">.isSharedProjectionDirty || </span><span class="s2">this</span><span class="s1">.isTransformDirty)) {</span>
                <span class="s1">canSkip = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">/**</span>
             <span class="s3">* If we have resolved the target this frame we must recalculate the</span>
             <span class="s3">* projection to ensure it visually represents the internal calculations.</span>
             <span class="s3">*/</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.resolvedRelativeTargetAt === motionDom.frameData.timestamp) {</span>
                <span class="s1">canSkip = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(canSkip)</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s2">const </span><span class="s1">{ layout, layoutId } = </span><span class="s2">this</span><span class="s1">.options;</span>
            <span class="s3">/**</span>
             <span class="s3">* If this section of the tree isn't animating we can</span>
             <span class="s3">* delete our target sources for the following frame.</span>
             <span class="s3">*/</span>
            <span class="s2">this</span><span class="s1">.isTreeAnimating = Boolean((</span><span class="s2">this</span><span class="s1">.parent &amp;&amp; </span><span class="s2">this</span><span class="s1">.parent.isTreeAnimating) ||</span>
                <span class="s2">this</span><span class="s1">.currentAnimation ||</span>
                <span class="s2">this</span><span class="s1">.pendingAnimation);</span>
            <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.isTreeAnimating) {</span>
                <span class="s2">this</span><span class="s1">.targetDelta = </span><span class="s2">this</span><span class="s1">.relativeTarget = undefined;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.layout || !(layout || layoutId))</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s3">/**</span>
             <span class="s3">* Reset the corrected box with the latest values from box, as we're then going</span>
             <span class="s3">* to perform mutative operations on it.</span>
             <span class="s3">*/</span>
            <span class="s1">copyBoxInto(</span><span class="s2">this</span><span class="s1">.layoutCorrected, </span><span class="s2">this</span><span class="s1">.layout.layoutBox);</span>
            <span class="s3">/**</span>
             <span class="s3">* Record previous tree scales before updating.</span>
             <span class="s3">*/</span>
            <span class="s2">const </span><span class="s1">prevTreeScaleX = </span><span class="s2">this</span><span class="s1">.treeScale.x;</span>
            <span class="s2">const </span><span class="s1">prevTreeScaleY = </span><span class="s2">this</span><span class="s1">.treeScale.y;</span>
            <span class="s3">/**</span>
             <span class="s3">* Apply all the parent deltas to this box to produce the corrected box. This</span>
             <span class="s3">* is the layout box, as it will appear on screen as a result of the transforms of its parents.</span>
             <span class="s3">*/</span>
            <span class="s1">applyTreeDeltas(</span><span class="s2">this</span><span class="s1">.layoutCorrected, </span><span class="s2">this</span><span class="s1">.treeScale, </span><span class="s2">this</span><span class="s1">.path, isShared);</span>
            <span class="s3">/**</span>
             <span class="s3">* If this layer needs to perform scale correction but doesn't have a target,</span>
             <span class="s3">* use the layout as the target.</span>
             <span class="s3">*/</span>
            <span class="s2">if </span><span class="s1">(lead.layout &amp;&amp;</span>
                <span class="s1">!lead.target &amp;&amp;</span>
                <span class="s1">(</span><span class="s2">this</span><span class="s1">.treeScale.x !== </span><span class="s5">1 </span><span class="s1">|| </span><span class="s2">this</span><span class="s1">.treeScale.y !== </span><span class="s5">1</span><span class="s1">)) {</span>
                <span class="s1">lead.target = lead.layout.layoutBox;</span>
                <span class="s1">lead.targetWithTransforms = createBox();</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">{ target } = lead;</span>
            <span class="s2">if </span><span class="s1">(!target) {</span>
                <span class="s3">/**</span>
                 <span class="s3">* If we don't have a target to project into, but we were previously</span>
                 <span class="s3">* projecting, we want to remove the stored transform and schedule</span>
                 <span class="s3">* a render to ensure the elements reflect the removed transform.</span>
                 <span class="s3">*/</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.prevProjectionDelta) {</span>
                    <span class="s2">this</span><span class="s1">.createProjectionDeltas();</span>
                    <span class="s2">this</span><span class="s1">.scheduleRender();</span>
                <span class="s1">}</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.projectionDelta || !</span><span class="s2">this</span><span class="s1">.prevProjectionDelta) {</span>
                <span class="s2">this</span><span class="s1">.createProjectionDeltas();</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">copyAxisDeltaInto(</span><span class="s2">this</span><span class="s1">.prevProjectionDelta.x, </span><span class="s2">this</span><span class="s1">.projectionDelta.x);</span>
                <span class="s1">copyAxisDeltaInto(</span><span class="s2">this</span><span class="s1">.prevProjectionDelta.y, </span><span class="s2">this</span><span class="s1">.projectionDelta.y);</span>
            <span class="s1">}</span>
            <span class="s3">/**</span>
             <span class="s3">* Update the delta between the corrected box and the target box before user-set transforms were applied.</span>
             <span class="s3">* This will allow us to calculate the corrected borderRadius and boxShadow to compensate</span>
             <span class="s3">* for our layout reprojection, but still allow them to be scaled correctly by the user.</span>
             <span class="s3">* It might be that to simplify this we may want to accept that user-set scale is also corrected</span>
             <span class="s3">* and we wouldn't have to keep and calc both deltas, OR we could support a user setting</span>
             <span class="s3">* to allow people to choose whether these styles are corrected based on just the</span>
             <span class="s3">* layout reprojection or the final bounding box.</span>
             <span class="s3">*/</span>
            <span class="s1">calcBoxDelta(</span><span class="s2">this</span><span class="s1">.projectionDelta, </span><span class="s2">this</span><span class="s1">.layoutCorrected, target, </span><span class="s2">this</span><span class="s1">.latestValues);</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.treeScale.x !== prevTreeScaleX ||</span>
                <span class="s2">this</span><span class="s1">.treeScale.y !== prevTreeScaleY ||</span>
                <span class="s1">!axisDeltaEquals(</span><span class="s2">this</span><span class="s1">.projectionDelta.x, </span><span class="s2">this</span><span class="s1">.prevProjectionDelta.x) ||</span>
                <span class="s1">!axisDeltaEquals(</span><span class="s2">this</span><span class="s1">.projectionDelta.y, </span><span class="s2">this</span><span class="s1">.prevProjectionDelta.y)) {</span>
                <span class="s2">this</span><span class="s1">.hasProjected = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s2">this</span><span class="s1">.scheduleRender();</span>
                <span class="s2">this</span><span class="s1">.notifyListeners(</span><span class="s0">&quot;projectionUpdate&quot;</span><span class="s1">, target);</span>
            <span class="s1">}</span>
            <span class="s3">/**</span>
             <span class="s3">* Increase debug counter for recalculated projections</span>
             <span class="s3">*/</span>
            <span class="s2">if </span><span class="s1">(motionDom.statsBuffer.value) {</span>
                <span class="s1">metrics.calculatedProjections++;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">hide() {</span>
            <span class="s2">this</span><span class="s1">.isVisible = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s3">// TODO: Schedule render</span>
        <span class="s1">}</span>
        <span class="s1">show() {</span>
            <span class="s2">this</span><span class="s1">.isVisible = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s3">// TODO: Schedule render</span>
        <span class="s1">}</span>
        <span class="s1">scheduleRender(notifyAll = </span><span class="s2">true</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.options.visualElement?.scheduleRender();</span>
            <span class="s2">if </span><span class="s1">(notifyAll) {</span>
                <span class="s2">const </span><span class="s1">stack = </span><span class="s2">this</span><span class="s1">.getStack();</span>
                <span class="s1">stack &amp;&amp; stack.scheduleRender();</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.resumingFrom &amp;&amp; !</span><span class="s2">this</span><span class="s1">.resumingFrom.instance) {</span>
                <span class="s2">this</span><span class="s1">.resumingFrom = undefined;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">createProjectionDeltas() {</span>
            <span class="s2">this</span><span class="s1">.prevProjectionDelta = createDelta();</span>
            <span class="s2">this</span><span class="s1">.projectionDelta = createDelta();</span>
            <span class="s2">this</span><span class="s1">.projectionDeltaWithTransform = createDelta();</span>
        <span class="s1">}</span>
        <span class="s1">setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = </span><span class="s2">false</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">snapshot = </span><span class="s2">this</span><span class="s1">.snapshot;</span>
            <span class="s2">const </span><span class="s1">snapshotLatestValues = snapshot ? snapshot.latestValues : {};</span>
            <span class="s2">const </span><span class="s1">mixedValues = { ...</span><span class="s2">this</span><span class="s1">.latestValues };</span>
            <span class="s2">const </span><span class="s1">targetDelta = createDelta();</span>
            <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.relativeParent ||</span>
                <span class="s1">!</span><span class="s2">this</span><span class="s1">.relativeParent.options.layoutRoot) {</span>
                <span class="s2">this</span><span class="s1">.relativeTarget = </span><span class="s2">this</span><span class="s1">.relativeTargetOrigin = undefined;</span>
            <span class="s1">}</span>
            <span class="s2">this</span><span class="s1">.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;</span>
            <span class="s2">const </span><span class="s1">relativeLayout = createBox();</span>
            <span class="s2">const </span><span class="s1">snapshotSource = snapshot ? snapshot.source : undefined;</span>
            <span class="s2">const </span><span class="s1">layoutSource = </span><span class="s2">this</span><span class="s1">.layout ? </span><span class="s2">this</span><span class="s1">.layout.source : undefined;</span>
            <span class="s2">const </span><span class="s1">isSharedLayoutAnimation = snapshotSource !== layoutSource;</span>
            <span class="s2">const </span><span class="s1">stack = </span><span class="s2">this</span><span class="s1">.getStack();</span>
            <span class="s2">const </span><span class="s1">isOnlyMember = !stack || stack.members.length &lt;= </span><span class="s5">1</span><span class="s1">;</span>
            <span class="s2">const </span><span class="s1">shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation &amp;&amp;</span>
                <span class="s1">!isOnlyMember &amp;&amp;</span>
                <span class="s2">this</span><span class="s1">.options.crossfade === </span><span class="s2">true </span><span class="s1">&amp;&amp;</span>
                <span class="s1">!</span><span class="s2">this</span><span class="s1">.path.some(hasOpacityCrossfade));</span>
            <span class="s2">this</span><span class="s1">.animationProgress = </span><span class="s5">0</span><span class="s1">;</span>
            <span class="s2">let </span><span class="s1">prevRelativeTarget;</span>
            <span class="s2">this</span><span class="s1">.mixTargetDelta = (latest) =&gt; {</span>
                <span class="s2">const </span><span class="s1">progress = latest / </span><span class="s5">1000</span><span class="s1">;</span>
                <span class="s1">mixAxisDelta(targetDelta.x, delta.x, progress);</span>
                <span class="s1">mixAxisDelta(targetDelta.y, delta.y, progress);</span>
                <span class="s2">this</span><span class="s1">.setTargetDelta(targetDelta);</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.relativeTarget &amp;&amp;</span>
                    <span class="s2">this</span><span class="s1">.relativeTargetOrigin &amp;&amp;</span>
                    <span class="s2">this</span><span class="s1">.layout &amp;&amp;</span>
                    <span class="s2">this</span><span class="s1">.relativeParent &amp;&amp;</span>
                    <span class="s2">this</span><span class="s1">.relativeParent.layout) {</span>
                    <span class="s1">calcRelativePosition(relativeLayout, </span><span class="s2">this</span><span class="s1">.layout.layoutBox, </span><span class="s2">this</span><span class="s1">.relativeParent.layout.layoutBox);</span>
                    <span class="s1">mixBox(</span><span class="s2">this</span><span class="s1">.relativeTarget, </span><span class="s2">this</span><span class="s1">.relativeTargetOrigin, relativeLayout, progress);</span>
                    <span class="s3">/**</span>
                     <span class="s3">* If this is an unchanged relative target we can consider the</span>
                     <span class="s3">* projection not dirty.</span>
                     <span class="s3">*/</span>
                    <span class="s2">if </span><span class="s1">(prevRelativeTarget &amp;&amp;</span>
                        <span class="s1">boxEquals(</span><span class="s2">this</span><span class="s1">.relativeTarget, prevRelativeTarget)) {</span>
                        <span class="s2">this</span><span class="s1">.isProjectionDirty = </span><span class="s2">false</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(!prevRelativeTarget)</span>
                        <span class="s1">prevRelativeTarget = createBox();</span>
                    <span class="s1">copyBoxInto(prevRelativeTarget, </span><span class="s2">this</span><span class="s1">.relativeTarget);</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(isSharedLayoutAnimation) {</span>
                    <span class="s2">this</span><span class="s1">.animationValues = mixedValues;</span>
                    <span class="s1">mixValues(mixedValues, snapshotLatestValues, </span><span class="s2">this</span><span class="s1">.latestValues, progress, shouldCrossfadeOpacity, isOnlyMember);</span>
                <span class="s1">}</span>
                <span class="s2">this</span><span class="s1">.root.scheduleUpdateProjection();</span>
                <span class="s2">this</span><span class="s1">.scheduleRender();</span>
                <span class="s2">this</span><span class="s1">.animationProgress = progress;</span>
            <span class="s1">};</span>
            <span class="s2">this</span><span class="s1">.mixTargetDelta(</span><span class="s2">this</span><span class="s1">.options.layoutRoot ? </span><span class="s5">1000 </span><span class="s1">: </span><span class="s5">0</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s1">startAnimation(options) {</span>
            <span class="s2">this</span><span class="s1">.notifyListeners(</span><span class="s0">&quot;animationStart&quot;</span><span class="s1">);</span>
            <span class="s2">this</span><span class="s1">.currentAnimation?.stop();</span>
            <span class="s2">this</span><span class="s1">.resumingFrom?.currentAnimation?.stop();</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.pendingAnimation) {</span>
                <span class="s1">motionDom.cancelFrame(</span><span class="s2">this</span><span class="s1">.pendingAnimation);</span>
                <span class="s2">this</span><span class="s1">.pendingAnimation = undefined;</span>
            <span class="s1">}</span>
            <span class="s3">/**</span>
             <span class="s3">* Start the animation in the next frame to have a frame with progress 0,</span>
             <span class="s3">* where the target is the same as when the animation started, so we can</span>
             <span class="s3">* calculate the relative positions correctly for instant transitions.</span>
             <span class="s3">*/</span>
            <span class="s2">this</span><span class="s1">.pendingAnimation = motionDom.frame.update(() =&gt; {</span>
                <span class="s1">globalProjectionState.hasAnimatedSinceResize = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">motionDom.activeAnimations.layout++;</span>
                <span class="s2">this</span><span class="s1">.motionValue || (</span><span class="s2">this</span><span class="s1">.motionValue = motionDom.motionValue(</span><span class="s5">0</span><span class="s1">));</span>
                <span class="s2">this</span><span class="s1">.currentAnimation = animateSingleValue(</span><span class="s2">this</span><span class="s1">.motionValue, [</span><span class="s5">0</span><span class="s1">, </span><span class="s5">1000</span><span class="s1">], {</span>
                    <span class="s1">...options,</span>
                    <span class="s1">velocity: </span><span class="s5">0</span><span class="s1">,</span>
                    <span class="s1">isSync: </span><span class="s2">true</span><span class="s1">,</span>
                    <span class="s1">onUpdate: (latest) =&gt; {</span>
                        <span class="s2">this</span><span class="s1">.mixTargetDelta(latest);</span>
                        <span class="s1">options.onUpdate &amp;&amp; options.onUpdate(latest);</span>
                    <span class="s1">},</span>
                    <span class="s1">onStop: () =&gt; {</span>
                        <span class="s1">motionDom.activeAnimations.layout--;</span>
                    <span class="s1">},</span>
                    <span class="s1">onComplete: () =&gt; {</span>
                        <span class="s1">motionDom.activeAnimations.layout--;</span>
                        <span class="s1">options.onComplete &amp;&amp; options.onComplete();</span>
                        <span class="s2">this</span><span class="s1">.completeAnimation();</span>
                    <span class="s1">},</span>
                <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.resumingFrom) {</span>
                    <span class="s2">this</span><span class="s1">.resumingFrom.currentAnimation = </span><span class="s2">this</span><span class="s1">.currentAnimation;</span>
                <span class="s1">}</span>
                <span class="s2">this</span><span class="s1">.pendingAnimation = undefined;</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s1">completeAnimation() {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.resumingFrom) {</span>
                <span class="s2">this</span><span class="s1">.resumingFrom.currentAnimation = undefined;</span>
                <span class="s2">this</span><span class="s1">.resumingFrom.preserveOpacity = undefined;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">stack = </span><span class="s2">this</span><span class="s1">.getStack();</span>
            <span class="s1">stack &amp;&amp; stack.exitAnimationComplete();</span>
            <span class="s2">this</span><span class="s1">.resumingFrom =</span>
                <span class="s2">this</span><span class="s1">.currentAnimation =</span>
                    <span class="s2">this</span><span class="s1">.animationValues =</span>
                        <span class="s1">undefined;</span>
            <span class="s2">this</span><span class="s1">.notifyListeners(</span><span class="s0">&quot;animationComplete&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s1">finishAnimation() {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.currentAnimation) {</span>
                <span class="s2">this</span><span class="s1">.mixTargetDelta &amp;&amp; </span><span class="s2">this</span><span class="s1">.mixTargetDelta(animationTarget);</span>
                <span class="s2">this</span><span class="s1">.currentAnimation.stop();</span>
            <span class="s1">}</span>
            <span class="s2">this</span><span class="s1">.completeAnimation();</span>
        <span class="s1">}</span>
        <span class="s1">applyTransformsToTarget() {</span>
            <span class="s2">const </span><span class="s1">lead = </span><span class="s2">this</span><span class="s1">.getLead();</span>
            <span class="s2">let </span><span class="s1">{ targetWithTransforms, target, layout, latestValues } = lead;</span>
            <span class="s2">if </span><span class="s1">(!targetWithTransforms || !target || !layout)</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s3">/**</span>
             <span class="s3">* If we're only animating position, and this element isn't the lead element,</span>
             <span class="s3">* then instead of projecting into the lead box we instead want to calculate</span>
             <span class="s3">* a new target that aligns the two boxes but maintains the layout shape.</span>
             <span class="s3">*/</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this </span><span class="s1">!== lead &amp;&amp;</span>
                <span class="s2">this</span><span class="s1">.layout &amp;&amp;</span>
                <span class="s1">layout &amp;&amp;</span>
                <span class="s1">shouldAnimatePositionOnly(</span><span class="s2">this</span><span class="s1">.options.animationType, </span><span class="s2">this</span><span class="s1">.layout.layoutBox, layout.layoutBox)) {</span>
                <span class="s1">target = </span><span class="s2">this</span><span class="s1">.target || createBox();</span>
                <span class="s2">const </span><span class="s1">xLength = calcLength(</span><span class="s2">this</span><span class="s1">.layout.layoutBox.x);</span>
                <span class="s1">target.x.min = lead.target.x.min;</span>
                <span class="s1">target.x.max = target.x.min + xLength;</span>
                <span class="s2">const </span><span class="s1">yLength = calcLength(</span><span class="s2">this</span><span class="s1">.layout.layoutBox.y);</span>
                <span class="s1">target.y.min = lead.target.y.min;</span>
                <span class="s1">target.y.max = target.y.min + yLength;</span>
            <span class="s1">}</span>
            <span class="s1">copyBoxInto(targetWithTransforms, target);</span>
            <span class="s3">/**</span>
             <span class="s3">* Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.</span>
             <span class="s3">* This is the final box that we will then project into by calculating a transform delta and</span>
             <span class="s3">* applying it to the corrected box.</span>
             <span class="s3">*/</span>
            <span class="s1">transformBox(targetWithTransforms, latestValues);</span>
            <span class="s3">/**</span>
             <span class="s3">* Update the delta between the corrected box and the final target box, after</span>
             <span class="s3">* user-set transforms are applied to it. This will be used by the renderer to</span>
             <span class="s3">* create a transform style that will reproject the element from its layout layout</span>
             <span class="s3">* into the desired bounding box.</span>
             <span class="s3">*/</span>
            <span class="s1">calcBoxDelta(</span><span class="s2">this</span><span class="s1">.projectionDeltaWithTransform, </span><span class="s2">this</span><span class="s1">.layoutCorrected, targetWithTransforms, latestValues);</span>
        <span class="s1">}</span>
        <span class="s1">registerSharedNode(layoutId, node) {</span>
            <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.sharedNodes.has(layoutId)) {</span>
                <span class="s2">this</span><span class="s1">.sharedNodes.set(layoutId, </span><span class="s2">new </span><span class="s1">NodeStack());</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">stack = </span><span class="s2">this</span><span class="s1">.sharedNodes.get(layoutId);</span>
            <span class="s1">stack.add(node);</span>
            <span class="s2">const </span><span class="s1">config = node.options.initialPromotionConfig;</span>
            <span class="s1">node.promote({</span>
                <span class="s1">transition: config ? config.transition : undefined,</span>
                <span class="s1">preserveFollowOpacity: config &amp;&amp; config.shouldPreserveFollowOpacity</span>
                    <span class="s1">? config.shouldPreserveFollowOpacity(node)</span>
                    <span class="s1">: undefined,</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s1">isLead() {</span>
            <span class="s2">const </span><span class="s1">stack = </span><span class="s2">this</span><span class="s1">.getStack();</span>
            <span class="s2">return </span><span class="s1">stack ? stack.lead === </span><span class="s2">this </span><span class="s1">: </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">getLead() {</span>
            <span class="s2">const </span><span class="s1">{ layoutId } = </span><span class="s2">this</span><span class="s1">.options;</span>
            <span class="s2">return </span><span class="s1">layoutId ? </span><span class="s2">this</span><span class="s1">.getStack()?.lead || </span><span class="s2">this </span><span class="s1">: </span><span class="s2">this</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">getPrevLead() {</span>
            <span class="s2">const </span><span class="s1">{ layoutId } = </span><span class="s2">this</span><span class="s1">.options;</span>
            <span class="s2">return </span><span class="s1">layoutId ? </span><span class="s2">this</span><span class="s1">.getStack()?.prevLead : undefined;</span>
        <span class="s1">}</span>
        <span class="s1">getStack() {</span>
            <span class="s2">const </span><span class="s1">{ layoutId } = </span><span class="s2">this</span><span class="s1">.options;</span>
            <span class="s2">if </span><span class="s1">(layoutId)</span>
                <span class="s2">return this</span><span class="s1">.root.sharedNodes.get(layoutId);</span>
        <span class="s1">}</span>
        <span class="s1">promote({ needsReset, transition, preserveFollowOpacity, } = {}) {</span>
            <span class="s2">const </span><span class="s1">stack = </span><span class="s2">this</span><span class="s1">.getStack();</span>
            <span class="s2">if </span><span class="s1">(stack)</span>
                <span class="s1">stack.promote(</span><span class="s2">this</span><span class="s1">, preserveFollowOpacity);</span>
            <span class="s2">if </span><span class="s1">(needsReset) {</span>
                <span class="s2">this</span><span class="s1">.projectionDelta = undefined;</span>
                <span class="s2">this</span><span class="s1">.needsReset = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(transition)</span>
                <span class="s2">this</span><span class="s1">.setOptions({ transition });</span>
        <span class="s1">}</span>
        <span class="s1">relegate() {</span>
            <span class="s2">const </span><span class="s1">stack = </span><span class="s2">this</span><span class="s1">.getStack();</span>
            <span class="s2">if </span><span class="s1">(stack) {</span>
                <span class="s2">return </span><span class="s1">stack.relegate(</span><span class="s2">this</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">resetSkewAndRotation() {</span>
            <span class="s2">const </span><span class="s1">{ visualElement } = </span><span class="s2">this</span><span class="s1">.options;</span>
            <span class="s2">if </span><span class="s1">(!visualElement)</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s3">// If there's no detected skew or rotation values, we can early return without a forced render.</span>
            <span class="s2">let </span><span class="s1">hasDistortingTransform = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s3">/**</span>
             <span class="s3">* An unrolled check for rotation values. Most elements don't have any rotation and</span>
             <span class="s3">* skipping the nested loop and new object creation is 50% faster.</span>
             <span class="s3">*/</span>
            <span class="s2">const </span><span class="s1">{ latestValues } = visualElement;</span>
            <span class="s2">if </span><span class="s1">(latestValues.z ||</span>
                <span class="s1">latestValues.rotate ||</span>
                <span class="s1">latestValues.rotateX ||</span>
                <span class="s1">latestValues.rotateY ||</span>
                <span class="s1">latestValues.rotateZ ||</span>
                <span class="s1">latestValues.skewX ||</span>
                <span class="s1">latestValues.skewY) {</span>
                <span class="s1">hasDistortingTransform = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">// If there's no distorting values, we don't need to do any more.</span>
            <span class="s2">if </span><span class="s1">(!hasDistortingTransform)</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s2">const </span><span class="s1">resetValues = {};</span>
            <span class="s2">if </span><span class="s1">(latestValues.z) {</span>
                <span class="s1">resetDistortingTransform(</span><span class="s0">&quot;z&quot;</span><span class="s1">, visualElement, resetValues, </span><span class="s2">this</span><span class="s1">.animationValues);</span>
            <span class="s1">}</span>
            <span class="s3">// Check the skew and rotate value of all axes and reset to 0</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; transformAxes.length; i++) {</span>
                <span class="s1">resetDistortingTransform(</span><span class="s0">`rotate</span><span class="s1">${transformAxes[i]}</span><span class="s0">`</span><span class="s1">, visualElement, resetValues, </span><span class="s2">this</span><span class="s1">.animationValues);</span>
                <span class="s1">resetDistortingTransform(</span><span class="s0">`skew</span><span class="s1">${transformAxes[i]}</span><span class="s0">`</span><span class="s1">, visualElement, resetValues, </span><span class="s2">this</span><span class="s1">.animationValues);</span>
            <span class="s1">}</span>
            <span class="s3">// Force a render of this element to apply the transform with all skews and rotations</span>
            <span class="s3">// set to 0.</span>
            <span class="s1">visualElement.render();</span>
            <span class="s3">// Put back all the values we reset</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">resetValues) {</span>
                <span class="s1">visualElement.setStaticValue(key, resetValues[key]);</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.animationValues) {</span>
                    <span class="s2">this</span><span class="s1">.animationValues[key] = resetValues[key];</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">// Schedule a render for the next frame. This ensures we won't visually</span>
            <span class="s3">// see the element with the reset rotate value applied.</span>
            <span class="s1">visualElement.scheduleRender();</span>
        <span class="s1">}</span>
        <span class="s1">applyProjectionStyles(targetStyle, </span><span class="s3">// CSSStyleDeclaration - doesn't allow numbers to be assigned to properties</span>
        <span class="s1">styleProp) {</span>
            <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.instance || </span><span class="s2">this</span><span class="s1">.isSVG)</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.isVisible) {</span>
                <span class="s1">targetStyle.visibility = </span><span class="s0">&quot;hidden&quot;</span><span class="s1">;</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">transformTemplate = </span><span class="s2">this</span><span class="s1">.getTransformTemplate();</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.needsReset) {</span>
                <span class="s2">this</span><span class="s1">.needsReset = </span><span class="s2">false</span><span class="s1">;</span>
                <span class="s1">targetStyle.visibility = </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
                <span class="s1">targetStyle.opacity = </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
                <span class="s1">targetStyle.pointerEvents =</span>
                    <span class="s1">resolveMotionValue(styleProp?.pointerEvents) || </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
                <span class="s1">targetStyle.transform = transformTemplate</span>
                    <span class="s1">? transformTemplate(</span><span class="s2">this</span><span class="s1">.latestValues, </span><span class="s0">&quot;&quot;</span><span class="s1">)</span>
                    <span class="s1">: </span><span class="s0">&quot;none&quot;</span><span class="s1">;</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">lead = </span><span class="s2">this</span><span class="s1">.getLead();</span>
            <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.projectionDelta || !</span><span class="s2">this</span><span class="s1">.layout || !lead.target) {</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.layoutId) {</span>
                    <span class="s1">targetStyle.opacity =</span>
                        <span class="s2">this</span><span class="s1">.latestValues.opacity !== undefined</span>
                            <span class="s1">? </span><span class="s2">this</span><span class="s1">.latestValues.opacity</span>
                            <span class="s1">: </span><span class="s5">1</span><span class="s1">;</span>
                    <span class="s1">targetStyle.pointerEvents =</span>
                        <span class="s1">resolveMotionValue(styleProp?.pointerEvents) || </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.hasProjected &amp;&amp; !hasTransform(</span><span class="s2">this</span><span class="s1">.latestValues)) {</span>
                    <span class="s1">targetStyle.transform = transformTemplate</span>
                        <span class="s1">? transformTemplate({}, </span><span class="s0">&quot;&quot;</span><span class="s1">)</span>
                        <span class="s1">: </span><span class="s0">&quot;none&quot;</span><span class="s1">;</span>
                    <span class="s2">this</span><span class="s1">.hasProjected = </span><span class="s2">false</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">targetStyle.visibility = </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
            <span class="s2">const </span><span class="s1">valuesToRender = lead.animationValues || lead.latestValues;</span>
            <span class="s2">this</span><span class="s1">.applyTransformsToTarget();</span>
            <span class="s2">let </span><span class="s1">transform = buildProjectionTransform(</span><span class="s2">this</span><span class="s1">.projectionDeltaWithTransform, </span><span class="s2">this</span><span class="s1">.treeScale, valuesToRender);</span>
            <span class="s2">if </span><span class="s1">(transformTemplate) {</span>
                <span class="s1">transform = transformTemplate(valuesToRender, transform);</span>
            <span class="s1">}</span>
            <span class="s1">targetStyle.transform = transform;</span>
            <span class="s2">const </span><span class="s1">{ x, y } = </span><span class="s2">this</span><span class="s1">.projectionDelta;</span>
            <span class="s1">targetStyle.transformOrigin = </span><span class="s0">`</span><span class="s1">${x.origin * </span><span class="s5">100</span><span class="s1">}</span><span class="s0">% </span><span class="s1">${y.origin * </span><span class="s5">100</span><span class="s1">}</span><span class="s0">% 0`</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(lead.animationValues) {</span>
                <span class="s3">/**</span>
                 <span class="s3">* If the lead component is animating, assign this either the entering/leaving</span>
                 <span class="s3">* opacity</span>
                 <span class="s3">*/</span>
                <span class="s1">targetStyle.opacity =</span>
                    <span class="s1">lead === </span><span class="s2">this</span>
                        <span class="s1">? valuesToRender.opacity ??</span>
                            <span class="s2">this</span><span class="s1">.latestValues.opacity ??</span>
                            <span class="s5">1</span>
                        <span class="s1">: </span><span class="s2">this</span><span class="s1">.preserveOpacity</span>
                            <span class="s1">? </span><span class="s2">this</span><span class="s1">.latestValues.opacity</span>
                            <span class="s1">: valuesToRender.opacityExit;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s3">/**</span>
                 <span class="s3">* Or we're not animating at all, set the lead component to its layout</span>
                 <span class="s3">* opacity and other components to hidden.</span>
                 <span class="s3">*/</span>
                <span class="s1">targetStyle.opacity =</span>
                    <span class="s1">lead === </span><span class="s2">this</span>
                        <span class="s1">? valuesToRender.opacity !== undefined</span>
                            <span class="s1">? valuesToRender.opacity</span>
                            <span class="s1">: </span><span class="s0">&quot;&quot;</span>
                        <span class="s1">: valuesToRender.opacityExit !== undefined</span>
                            <span class="s1">? valuesToRender.opacityExit</span>
                            <span class="s1">: </span><span class="s5">0</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">/**</span>
             <span class="s3">* Apply scale correction</span>
             <span class="s3">*/</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">scaleCorrectors) {</span>
                <span class="s2">if </span><span class="s1">(valuesToRender[key] === undefined)</span>
                    <span class="s2">continue</span><span class="s1">;</span>
                <span class="s2">const </span><span class="s1">{ correct, applyTo, isCSSVariable } = scaleCorrectors[key];</span>
                <span class="s3">/**</span>
                 <span class="s3">* Only apply scale correction to the value if we have an</span>
                 <span class="s3">* active projection transform. Otherwise these values become</span>
                 <span class="s3">* vulnerable to distortion if the element changes size without</span>
                 <span class="s3">* a corresponding layout animation.</span>
                 <span class="s3">*/</span>
                <span class="s2">const </span><span class="s1">corrected = transform === </span><span class="s0">&quot;none&quot;</span>
                    <span class="s1">? valuesToRender[key]</span>
                    <span class="s1">: correct(valuesToRender[key], lead);</span>
                <span class="s2">if </span><span class="s1">(applyTo) {</span>
                    <span class="s2">const </span><span class="s1">num = applyTo.length;</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; num; i++) {</span>
                        <span class="s1">targetStyle[applyTo[i]] = corrected;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s3">// If this is a CSS variable, set it directly on the instance.</span>
                    <span class="s3">// Replacing this function from creating styles to setting them</span>
                    <span class="s3">// would be a good place to remove per frame object creation</span>
                    <span class="s2">if </span><span class="s1">(isCSSVariable) {</span>
                        <span class="s2">this</span><span class="s1">.options.visualElement.renderState.vars[key] = corrected;</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">targetStyle[key] = corrected;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">/**</span>
             <span class="s3">* Disable pointer events on follow components. This is to ensure</span>
             <span class="s3">* that if a follow component covers a lead component it doesn't block</span>
             <span class="s3">* pointer events on the lead.</span>
             <span class="s3">*/</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.layoutId) {</span>
                <span class="s1">targetStyle.pointerEvents =</span>
                    <span class="s1">lead === </span><span class="s2">this</span>
                        <span class="s1">? resolveMotionValue(styleProp?.pointerEvents) || </span><span class="s0">&quot;&quot;</span>
                        <span class="s1">: </span><span class="s0">&quot;none&quot;</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">clearSnapshot() {</span>
            <span class="s2">this</span><span class="s1">.resumeFrom = </span><span class="s2">this</span><span class="s1">.snapshot = undefined;</span>
        <span class="s1">}</span>
        <span class="s3">// Only run on root</span>
        <span class="s1">resetTree() {</span>
            <span class="s2">this</span><span class="s1">.root.nodes.forEach((node) =&gt; node.currentAnimation?.stop());</span>
            <span class="s2">this</span><span class="s1">.root.nodes.forEach(clearMeasurements);</span>
            <span class="s2">this</span><span class="s1">.root.sharedNodes.clear();</span>
        <span class="s1">}</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">updateLayout(node) {</span>
    <span class="s1">node.updateLayout();</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">notifyLayoutUpdate(node) {</span>
    <span class="s2">const </span><span class="s1">snapshot = node.resumeFrom?.snapshot || node.snapshot;</span>
    <span class="s2">if </span><span class="s1">(node.isLead() &amp;&amp;</span>
        <span class="s1">node.layout &amp;&amp;</span>
        <span class="s1">snapshot &amp;&amp;</span>
        <span class="s1">node.hasListeners(</span><span class="s0">&quot;didUpdate&quot;</span><span class="s1">)) {</span>
        <span class="s2">const </span><span class="s1">{ layoutBox: layout, measuredBox: measuredLayout } = node.layout;</span>
        <span class="s2">const </span><span class="s1">{ animationType } = node.options;</span>
        <span class="s2">const </span><span class="s1">isShared = snapshot.source !== node.layout.source;</span>
        <span class="s3">// TODO Maybe we want to also resize the layout snapshot so we don't trigger</span>
        <span class="s3">// animations for instance if layout=&quot;size&quot; and an element has only changed position</span>
        <span class="s2">if </span><span class="s1">(animationType === </span><span class="s0">&quot;size&quot;</span><span class="s1">) {</span>
            <span class="s1">eachAxis((axis) =&gt; {</span>
                <span class="s2">const </span><span class="s1">axisSnapshot = isShared</span>
                    <span class="s1">? snapshot.measuredBox[axis]</span>
                    <span class="s1">: snapshot.layoutBox[axis];</span>
                <span class="s2">const </span><span class="s1">length = calcLength(axisSnapshot);</span>
                <span class="s1">axisSnapshot.min = layout[axis].min;</span>
                <span class="s1">axisSnapshot.max = axisSnapshot.min + length;</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout)) {</span>
            <span class="s1">eachAxis((axis) =&gt; {</span>
                <span class="s2">const </span><span class="s1">axisSnapshot = isShared</span>
                    <span class="s1">? snapshot.measuredBox[axis]</span>
                    <span class="s1">: snapshot.layoutBox[axis];</span>
                <span class="s2">const </span><span class="s1">length = calcLength(layout[axis]);</span>
                <span class="s1">axisSnapshot.max = axisSnapshot.min + length;</span>
                <span class="s3">/**</span>
                 <span class="s3">* Ensure relative target gets resized and rerendererd</span>
                 <span class="s3">*/</span>
                <span class="s2">if </span><span class="s1">(node.relativeTarget &amp;&amp; !node.currentAnimation) {</span>
                    <span class="s1">node.isProjectionDirty = </span><span class="s2">true</span><span class="s1">;</span>
                    <span class="s1">node.relativeTarget[axis].max =</span>
                        <span class="s1">node.relativeTarget[axis].min + length;</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">layoutDelta = createDelta();</span>
        <span class="s1">calcBoxDelta(layoutDelta, layout, snapshot.layoutBox);</span>
        <span class="s2">const </span><span class="s1">visualDelta = createDelta();</span>
        <span class="s2">if </span><span class="s1">(isShared) {</span>
            <span class="s1">calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, </span><span class="s2">true</span><span class="s1">), snapshot.measuredBox);</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">calcBoxDelta(visualDelta, layout, snapshot.layoutBox);</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">hasLayoutChanged = !isDeltaZero(layoutDelta);</span>
        <span class="s2">let </span><span class="s1">hasRelativeLayoutChanged = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(!node.resumeFrom) {</span>
            <span class="s2">const </span><span class="s1">relativeParent = node.getClosestProjectingParent();</span>
            <span class="s3">/**</span>
             <span class="s3">* If the relativeParent is itself resuming from a different element then</span>
             <span class="s3">* the relative snapshot is not relavent</span>
             <span class="s3">*/</span>
            <span class="s2">if </span><span class="s1">(relativeParent &amp;&amp; !relativeParent.resumeFrom) {</span>
                <span class="s2">const </span><span class="s1">{ snapshot: parentSnapshot, layout: parentLayout } = relativeParent;</span>
                <span class="s2">if </span><span class="s1">(parentSnapshot &amp;&amp; parentLayout) {</span>
                    <span class="s2">const </span><span class="s1">relativeSnapshot = createBox();</span>
                    <span class="s1">calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);</span>
                    <span class="s2">const </span><span class="s1">relativeLayout = createBox();</span>
                    <span class="s1">calcRelativePosition(relativeLayout, layout, parentLayout.layoutBox);</span>
                    <span class="s2">if </span><span class="s1">(!boxEqualsRounded(relativeSnapshot, relativeLayout)) {</span>
                        <span class="s1">hasRelativeLayoutChanged = </span><span class="s2">true</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(relativeParent.options.layoutRoot) {</span>
                        <span class="s1">node.relativeTarget = relativeLayout;</span>
                        <span class="s1">node.relativeTargetOrigin = relativeSnapshot;</span>
                        <span class="s1">node.relativeParent = relativeParent;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">node.notifyListeners(</span><span class="s0">&quot;didUpdate&quot;</span><span class="s1">, {</span>
            <span class="s1">layout,</span>
            <span class="s1">snapshot,</span>
            <span class="s1">delta: visualDelta,</span>
            <span class="s1">layoutDelta,</span>
            <span class="s1">hasLayoutChanged,</span>
            <span class="s1">hasRelativeLayoutChanged,</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(node.isLead()) {</span>
        <span class="s2">const </span><span class="s1">{ onExitComplete } = node.options;</span>
        <span class="s1">onExitComplete &amp;&amp; onExitComplete();</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Clearing transition</span>
     <span class="s3">* TODO: Investigate why this transition is being passed in as {type: false } from Framer</span>
     <span class="s3">* and why we need it at all</span>
     <span class="s3">*/</span>
    <span class="s1">node.options.transition = undefined;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">propagateDirtyNodes(node) {</span>
    <span class="s3">/**</span>
     <span class="s3">* Increase debug counter for nodes encountered this frame</span>
     <span class="s3">*/</span>
    <span class="s2">if </span><span class="s1">(motionDom.statsBuffer.value) {</span>
        <span class="s1">metrics.nodes++;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!node.parent)</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* If this node isn't projecting, propagate isProjectionDirty. It will have</span>
     <span class="s3">* no performance impact but it will allow the next child that *is* projecting</span>
     <span class="s3">* but *isn't* dirty to just check its parent to see if *any* ancestor needs</span>
     <span class="s3">* correcting.</span>
     <span class="s3">*/</span>
    <span class="s2">if </span><span class="s1">(!node.isProjecting()) {</span>
        <span class="s1">node.isProjectionDirty = node.parent.isProjectionDirty;</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Propagate isSharedProjectionDirty and isTransformDirty</span>
     <span class="s3">* throughout the whole tree. A future revision can take another look at</span>
     <span class="s3">* this but for safety we still recalcualte shared nodes.</span>
     <span class="s3">*/</span>
    <span class="s1">node.isSharedProjectionDirty || (node.isSharedProjectionDirty = Boolean(node.isProjectionDirty ||</span>
        <span class="s1">node.parent.isProjectionDirty ||</span>
        <span class="s1">node.parent.isSharedProjectionDirty));</span>
    <span class="s1">node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">cleanDirtyNodes(node) {</span>
    <span class="s1">node.isProjectionDirty =</span>
        <span class="s1">node.isSharedProjectionDirty =</span>
            <span class="s1">node.isTransformDirty =</span>
                <span class="s2">false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">clearSnapshot(node) {</span>
    <span class="s1">node.clearSnapshot();</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">clearMeasurements(node) {</span>
    <span class="s1">node.clearMeasurements();</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">clearIsLayoutDirty(node) {</span>
    <span class="s1">node.isLayoutDirty = </span><span class="s2">false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">resetTransformStyle(node) {</span>
    <span class="s2">const </span><span class="s1">{ visualElement } = node.options;</span>
    <span class="s2">if </span><span class="s1">(visualElement &amp;&amp; visualElement.getProps().onBeforeLayoutMeasure) {</span>
        <span class="s1">visualElement.notify(</span><span class="s0">&quot;BeforeLayoutMeasure&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">node.resetTransform();</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">finishAnimation(node) {</span>
    <span class="s1">node.finishAnimation();</span>
    <span class="s1">node.targetDelta = node.relativeTarget = node.target = undefined;</span>
    <span class="s1">node.isProjectionDirty = </span><span class="s2">true</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">resolveTargetDelta(node) {</span>
    <span class="s1">node.resolveTargetDelta();</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">calcProjection(node) {</span>
    <span class="s1">node.calcProjection();</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">resetSkewAndRotation(node) {</span>
    <span class="s1">node.resetSkewAndRotation();</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">removeLeadSnapshots(stack) {</span>
    <span class="s1">stack.removeLeadSnapshot();</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">mixAxisDelta(output, delta, p) {</span>
    <span class="s1">output.translate = motionDom.mixNumber(delta.translate, </span><span class="s5">0</span><span class="s1">, p);</span>
    <span class="s1">output.scale = motionDom.mixNumber(delta.scale, </span><span class="s5">1</span><span class="s1">, p);</span>
    <span class="s1">output.origin = delta.origin;</span>
    <span class="s1">output.originPoint = delta.originPoint;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">mixAxis(output, from, to, p) {</span>
    <span class="s1">output.min = motionDom.mixNumber(from.min, to.min, p);</span>
    <span class="s1">output.max = motionDom.mixNumber(from.max, to.max, p);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">mixBox(output, from, to, p) {</span>
    <span class="s1">mixAxis(output.x, from.x, to.x, p);</span>
    <span class="s1">mixAxis(output.y, from.y, to.y, p);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">hasOpacityCrossfade(node) {</span>
    <span class="s2">return </span><span class="s1">(node.animationValues &amp;&amp; node.animationValues.opacityExit !== undefined);</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">defaultLayoutTransition = {</span>
    <span class="s1">duration: </span><span class="s5">0.45</span><span class="s1">,</span>
    <span class="s1">ease: [</span><span class="s5">0.4</span><span class="s1">, </span><span class="s5">0</span><span class="s1">, </span><span class="s5">0.1</span><span class="s1">, </span><span class="s5">1</span><span class="s1">],</span>
<span class="s1">};</span>
<span class="s2">const </span><span class="s1">userAgentContains = (string) =&gt; </span><span class="s2">typeof </span><span class="s1">navigator !== </span><span class="s0">&quot;undefined&quot; </span><span class="s1">&amp;&amp;</span>
    <span class="s1">navigator.userAgent &amp;&amp;</span>
    <span class="s1">navigator.userAgent.toLowerCase().includes(string);</span>
<span class="s3">/**</span>
 <span class="s3">* Measured bounding boxes must be rounded in Safari and</span>
 <span class="s3">* left untouched in Chrome, otherwise non-integer layouts within scaled-up elements</span>
 <span class="s3">* can appear to jump.</span>
 <span class="s3">*/</span>
<span class="s2">const </span><span class="s1">roundPoint = userAgentContains(</span><span class="s0">&quot;applewebkit/&quot;</span><span class="s1">) &amp;&amp; !userAgentContains(</span><span class="s0">&quot;chrome/&quot;</span><span class="s1">)</span>
    <span class="s1">? Math.round</span>
    <span class="s1">: motionUtils.noop;</span>
<span class="s2">function </span><span class="s1">roundAxis(axis) {</span>
    <span class="s3">// Round to the nearest .5 pixels to support subpixel layouts</span>
    <span class="s1">axis.min = roundPoint(axis.min);</span>
    <span class="s1">axis.max = roundPoint(axis.max);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">roundBox(box) {</span>
    <span class="s1">roundAxis(box.x);</span>
    <span class="s1">roundAxis(box.y);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">shouldAnimatePositionOnly(animationType, snapshot, layout) {</span>
    <span class="s2">return </span><span class="s1">(animationType === </span><span class="s0">&quot;position&quot; </span><span class="s1">||</span>
        <span class="s1">(animationType === </span><span class="s0">&quot;preserve-aspect&quot; </span><span class="s1">&amp;&amp;</span>
            <span class="s1">!isNear(aspectRatio(snapshot), aspectRatio(layout), </span><span class="s5">0.2</span><span class="s1">)));</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">checkNodeWasScrollRoot(node) {</span>
    <span class="s2">return </span><span class="s1">node !== node.root &amp;&amp; node.scroll?.wasRoot;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">addDomEvent(target, eventName, handler, options = { passive: </span><span class="s2">true </span><span class="s1">}) {</span>
    <span class="s1">target.addEventListener(eventName, handler, options);</span>
    <span class="s2">return </span><span class="s1">() =&gt; target.removeEventListener(eventName, handler);</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">DocumentProjectionNode = createProjectionNode$1({</span>
    <span class="s1">attachResizeListener: (ref, notify) =&gt; addDomEvent(ref, </span><span class="s0">&quot;resize&quot;</span><span class="s1">, notify),</span>
    <span class="s1">measureScroll: () =&gt; ({</span>
        <span class="s1">x: document.documentElement.scrollLeft || document.body.scrollLeft,</span>
        <span class="s1">y: document.documentElement.scrollTop || document.body.scrollTop,</span>
    <span class="s1">}),</span>
    <span class="s1">checkIsScrollRoot: () =&gt; </span><span class="s2">true</span><span class="s1">,</span>
<span class="s1">});</span>

<span class="s2">const </span><span class="s1">rootProjectionNode = {</span>
    <span class="s1">current: undefined,</span>
<span class="s1">};</span>
<span class="s2">const </span><span class="s1">HTMLProjectionNode = createProjectionNode$1({</span>
    <span class="s1">measureScroll: (instance) =&gt; ({</span>
        <span class="s1">x: instance.scrollLeft,</span>
        <span class="s1">y: instance.scrollTop,</span>
    <span class="s1">}),</span>
    <span class="s1">defaultParent: () =&gt; {</span>
        <span class="s2">if </span><span class="s1">(!rootProjectionNode.current) {</span>
            <span class="s2">const </span><span class="s1">documentNode = </span><span class="s2">new </span><span class="s1">DocumentProjectionNode({});</span>
            <span class="s1">documentNode.mount(window);</span>
            <span class="s1">documentNode.setOptions({ layoutScroll: </span><span class="s2">true </span><span class="s1">});</span>
            <span class="s1">rootProjectionNode.current = documentNode;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">rootProjectionNode.current;</span>
    <span class="s1">},</span>
    <span class="s1">resetTransform: (instance, value) =&gt; {</span>
        <span class="s1">instance.style.transform = value !== undefined ? value : </span><span class="s0">&quot;none&quot;</span><span class="s1">;</span>
    <span class="s1">},</span>
    <span class="s1">checkIsScrollRoot: (instance) =&gt; Boolean(window.getComputedStyle(instance).position === </span><span class="s0">&quot;fixed&quot;</span><span class="s1">),</span>
<span class="s1">});</span>

<span class="s2">function </span><span class="s1">pixelsToPercent(pixels, axis) {</span>
    <span class="s2">if </span><span class="s1">(axis.max === axis.min)</span>
        <span class="s2">return </span><span class="s5">0</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">(pixels / (axis.max - axis.min)) * </span><span class="s5">100</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* We always correct borderRadius as a percentage rather than pixels to reduce paints.</span>
 <span class="s3">* For example, if you are projecting a box that is 100px wide with a 10px borderRadius</span>
 <span class="s3">* into a box that is 200px wide with a 20px borderRadius, that is actually a 10%</span>
 <span class="s3">* borderRadius in both states. If we animate between the two in pixels that will trigger</span>
 <span class="s3">* a paint each time. If we animate between the two in percentage we'll avoid a paint.</span>
 <span class="s3">*/</span>
<span class="s2">const </span><span class="s1">correctBorderRadius = {</span>
    <span class="s1">correct: (latest, node) =&gt; {</span>
        <span class="s2">if </span><span class="s1">(!node.target)</span>
            <span class="s2">return </span><span class="s1">latest;</span>
        <span class="s3">/**</span>
         <span class="s3">* If latest is a string, if it's a percentage we can return immediately as it's</span>
         <span class="s3">* going to be stretched appropriately. Otherwise, if it's a pixel, convert it to a number.</span>
         <span class="s3">*/</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">latest === </span><span class="s0">&quot;string&quot;</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(motionDom.px.test(latest)) {</span>
                <span class="s1">latest = parseFloat(latest);</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">return </span><span class="s1">latest;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">/**</span>
         <span class="s3">* If latest is a number, it's a pixel value. We use the current viewportBox to calculate that</span>
         <span class="s3">* pixel value as a percentage of each axis</span>
         <span class="s3">*/</span>
        <span class="s2">const </span><span class="s1">x = pixelsToPercent(latest, node.target.x);</span>
        <span class="s2">const </span><span class="s1">y = pixelsToPercent(latest, node.target.y);</span>
        <span class="s2">return </span><span class="s0">`</span><span class="s1">${x}</span><span class="s0">% </span><span class="s1">${y}</span><span class="s0">%`</span><span class="s1">;</span>
    <span class="s1">},</span>
<span class="s1">};</span>

<span class="s2">const </span><span class="s1">correctBoxShadow = {</span>
    <span class="s1">correct: (latest, { treeScale, projectionDelta }) =&gt; {</span>
        <span class="s2">const </span><span class="s1">original = latest;</span>
        <span class="s2">const </span><span class="s1">shadow = motionDom.complex.parse(latest);</span>
        <span class="s3">// TODO: Doesn't support multiple shadows</span>
        <span class="s2">if </span><span class="s1">(shadow.length &gt; </span><span class="s5">5</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">original;</span>
        <span class="s2">const </span><span class="s1">template = motionDom.complex.createTransformer(latest);</span>
        <span class="s2">const </span><span class="s1">offset = </span><span class="s2">typeof </span><span class="s1">shadow[</span><span class="s5">0</span><span class="s1">] !== </span><span class="s0">&quot;number&quot; </span><span class="s1">? </span><span class="s5">1 </span><span class="s1">: </span><span class="s5">0</span><span class="s1">;</span>
        <span class="s3">// Calculate the overall context scale</span>
        <span class="s2">const </span><span class="s1">xScale = projectionDelta.x.scale * treeScale.x;</span>
        <span class="s2">const </span><span class="s1">yScale = projectionDelta.y.scale * treeScale.y;</span>
        <span class="s1">shadow[</span><span class="s5">0 </span><span class="s1">+ offset] /= xScale;</span>
        <span class="s1">shadow[</span><span class="s5">1 </span><span class="s1">+ offset] /= yScale;</span>
        <span class="s3">/**</span>
         <span class="s3">* Ideally we'd correct x and y scales individually, but because blur and</span>
         <span class="s3">* spread apply to both we have to take a scale average and apply that instead.</span>
         <span class="s3">* We could potentially improve the outcome of this by incorporating the ratio between</span>
         <span class="s3">* the two scales.</span>
         <span class="s3">*/</span>
        <span class="s2">const </span><span class="s1">averageScale = motionDom.mixNumber(xScale, yScale, </span><span class="s5">0.5</span><span class="s1">);</span>
        <span class="s3">// Blur</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">shadow[</span><span class="s5">2 </span><span class="s1">+ offset] === </span><span class="s0">&quot;number&quot;</span><span class="s1">)</span>
            <span class="s1">shadow[</span><span class="s5">2 </span><span class="s1">+ offset] /= averageScale;</span>
        <span class="s3">// Spread</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">shadow[</span><span class="s5">3 </span><span class="s1">+ offset] === </span><span class="s0">&quot;number&quot;</span><span class="s1">)</span>
            <span class="s1">shadow[</span><span class="s5">3 </span><span class="s1">+ offset] /= averageScale;</span>
        <span class="s2">return </span><span class="s1">template(shadow);</span>
    <span class="s1">},</span>
<span class="s1">};</span>

<span class="s3">/**</span>
 <span class="s3">* Bounding boxes tend to be defined as top, left, right, bottom. For various operations</span>
 <span class="s3">* it's easier to consider each axis individually. This function returns a bounding box</span>
 <span class="s3">* as a map of single-axis min/max values.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">convertBoundingBoxToBox({ top, left, right, bottom, }) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">x: { min: left, max: right },</span>
        <span class="s1">y: { min: top, max: bottom },</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">convertBoxToBoundingBox({ x, y }) {</span>
    <span class="s2">return </span><span class="s1">{ top: y.min, right: x.max, bottom: y.max, left: x.min };</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Applies a TransformPoint function to a bounding box. TransformPoint is usually a function</span>
 <span class="s3">* provided by Framer to allow measured points to be corrected for device scaling. This is used</span>
 <span class="s3">* when measuring DOM elements and DOM event points.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">transformBoxPoints(point, transformPoint) {</span>
    <span class="s2">if </span><span class="s1">(!transformPoint)</span>
        <span class="s2">return </span><span class="s1">point;</span>
    <span class="s2">const </span><span class="s1">topLeft = transformPoint({ x: point.left, y: point.top });</span>
    <span class="s2">const </span><span class="s1">bottomRight = transformPoint({ x: point.right, y: point.bottom });</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">top: topLeft.y,</span>
        <span class="s1">left: topLeft.x,</span>
        <span class="s1">bottom: bottomRight.y,</span>
        <span class="s1">right: bottomRight.x,</span>
    <span class="s1">};</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">measureViewportBox(instance, transformPoint) {</span>
    <span class="s2">return </span><span class="s1">convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint));</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">measurePageBox(element, rootProjectionNode, transformPagePoint) {</span>
    <span class="s2">const </span><span class="s1">viewportBox = measureViewportBox(element, transformPagePoint);</span>
    <span class="s2">const </span><span class="s1">{ scroll } = rootProjectionNode;</span>
    <span class="s2">if </span><span class="s1">(scroll) {</span>
        <span class="s1">translateAxis(viewportBox.x, scroll.offset.x);</span>
        <span class="s1">translateAxis(viewportBox.y, scroll.offset.y);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">viewportBox;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">featureProps = {</span>
    <span class="s1">animation: [</span>
        <span class="s0">&quot;animate&quot;</span><span class="s1">,</span>
        <span class="s0">&quot;variants&quot;</span><span class="s1">,</span>
        <span class="s0">&quot;whileHover&quot;</span><span class="s1">,</span>
        <span class="s0">&quot;whileTap&quot;</span><span class="s1">,</span>
        <span class="s0">&quot;exit&quot;</span><span class="s1">,</span>
        <span class="s0">&quot;whileInView&quot;</span><span class="s1">,</span>
        <span class="s0">&quot;whileFocus&quot;</span><span class="s1">,</span>
        <span class="s0">&quot;whileDrag&quot;</span><span class="s1">,</span>
    <span class="s1">],</span>
    <span class="s1">exit: [</span><span class="s0">&quot;exit&quot;</span><span class="s1">],</span>
    <span class="s1">drag: [</span><span class="s0">&quot;drag&quot;</span><span class="s1">, </span><span class="s0">&quot;dragControls&quot;</span><span class="s1">],</span>
    <span class="s1">focus: [</span><span class="s0">&quot;whileFocus&quot;</span><span class="s1">],</span>
    <span class="s1">hover: [</span><span class="s0">&quot;whileHover&quot;</span><span class="s1">, </span><span class="s0">&quot;onHoverStart&quot;</span><span class="s1">, </span><span class="s0">&quot;onHoverEnd&quot;</span><span class="s1">],</span>
    <span class="s1">tap: [</span><span class="s0">&quot;whileTap&quot;</span><span class="s1">, </span><span class="s0">&quot;onTap&quot;</span><span class="s1">, </span><span class="s0">&quot;onTapStart&quot;</span><span class="s1">, </span><span class="s0">&quot;onTapCancel&quot;</span><span class="s1">],</span>
    <span class="s1">pan: [</span><span class="s0">&quot;onPan&quot;</span><span class="s1">, </span><span class="s0">&quot;onPanStart&quot;</span><span class="s1">, </span><span class="s0">&quot;onPanSessionStart&quot;</span><span class="s1">, </span><span class="s0">&quot;onPanEnd&quot;</span><span class="s1">],</span>
    <span class="s1">inView: [</span><span class="s0">&quot;whileInView&quot;</span><span class="s1">, </span><span class="s0">&quot;onViewportEnter&quot;</span><span class="s1">, </span><span class="s0">&quot;onViewportLeave&quot;</span><span class="s1">],</span>
    <span class="s1">layout: [</span><span class="s0">&quot;layout&quot;</span><span class="s1">, </span><span class="s0">&quot;layoutId&quot;</span><span class="s1">],</span>
<span class="s1">};</span>
<span class="s2">const </span><span class="s1">featureDefinitions = {};</span>
<span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">featureProps) {</span>
    <span class="s1">featureDefinitions[key] = {</span>
        <span class="s1">isEnabled: (props) =&gt; featureProps[key].some((name) =&gt; !!props[name]),</span>
    <span class="s1">};</span>
<span class="s1">}</span>

<span class="s3">// Does this device prefer reduced motion? Returns `null` server-side.</span>
<span class="s2">const </span><span class="s1">prefersReducedMotion = { current: </span><span class="s2">null </span><span class="s1">};</span>
<span class="s2">const </span><span class="s1">hasReducedMotionListener = { current: </span><span class="s2">false </span><span class="s1">};</span>

<span class="s2">function </span><span class="s1">initPrefersReducedMotion() {</span>
    <span class="s1">hasReducedMotionListener.current = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(!isBrowser)</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(window.matchMedia) {</span>
        <span class="s2">const </span><span class="s1">motionMediaQuery = window.matchMedia(</span><span class="s0">&quot;(prefers-reduced-motion)&quot;</span><span class="s1">);</span>
        <span class="s2">const </span><span class="s1">setReducedMotionPreferences = () =&gt; (prefersReducedMotion.current = motionMediaQuery.matches);</span>
        <span class="s1">motionMediaQuery.addEventListener(</span><span class="s0">&quot;change&quot;</span><span class="s1">, setReducedMotionPreferences);</span>
        <span class="s1">setReducedMotionPreferences();</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">prefersReducedMotion.current = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">visualElementStore = </span><span class="s2">new </span><span class="s1">WeakMap();</span>

<span class="s2">function </span><span class="s1">isAnimationControls(v) {</span>
    <span class="s2">return </span><span class="s1">(v !== </span><span class="s2">null </span><span class="s1">&amp;&amp;</span>
        <span class="s2">typeof </span><span class="s1">v === </span><span class="s0">&quot;object&quot; </span><span class="s1">&amp;&amp;</span>
        <span class="s2">typeof </span><span class="s1">v.start === </span><span class="s0">&quot;function&quot;</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Decides if the supplied variable is variant label</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">isVariantLabel(v) {</span>
    <span class="s2">return typeof </span><span class="s1">v === </span><span class="s0">&quot;string&quot; </span><span class="s1">|| Array.isArray(v);</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">variantPriorityOrder = [</span>
    <span class="s0">&quot;animate&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;whileInView&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;whileFocus&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;whileHover&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;whileTap&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;whileDrag&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;exit&quot;</span><span class="s1">,</span>
<span class="s1">];</span>
<span class="s2">const </span><span class="s1">variantProps = [</span><span class="s0">&quot;initial&quot;</span><span class="s1">, ...variantPriorityOrder];</span>

<span class="s2">function </span><span class="s1">isControllingVariants(props) {</span>
    <span class="s2">return </span><span class="s1">(isAnimationControls(props.animate) ||</span>
        <span class="s1">variantProps.some((name) =&gt; isVariantLabel(props[name])));</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isVariantNode(props) {</span>
    <span class="s2">return </span><span class="s1">Boolean(isControllingVariants(props) || props.variants);</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">updateMotionValuesFromProps(element, next, prev) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">next) {</span>
        <span class="s2">const </span><span class="s1">nextValue = next[key];</span>
        <span class="s2">const </span><span class="s1">prevValue = prev[key];</span>
        <span class="s2">if </span><span class="s1">(motionDom.isMotionValue(nextValue)) {</span>
            <span class="s3">/**</span>
             <span class="s3">* If this is a motion value found in props or style, we want to add it</span>
             <span class="s3">* to our visual element's motion value map.</span>
             <span class="s3">*/</span>
            <span class="s1">element.addValue(key, nextValue);</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(motionDom.isMotionValue(prevValue)) {</span>
            <span class="s3">/**</span>
             <span class="s3">* If we're swapping from a motion value to a static value,</span>
             <span class="s3">* create a new motion value from that</span>
             <span class="s3">*/</span>
            <span class="s1">element.addValue(key, motionDom.motionValue(nextValue, { owner: element }));</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(prevValue !== nextValue) {</span>
            <span class="s3">/**</span>
             <span class="s3">* If this is a flat value that has changed, update the motion value</span>
             <span class="s3">* or create one if it doesn't exist. We only want to do this if we're</span>
             <span class="s3">* not handling the value with our animation state.</span>
             <span class="s3">*/</span>
            <span class="s2">if </span><span class="s1">(element.hasValue(key)) {</span>
                <span class="s2">const </span><span class="s1">existingValue = element.getValue(key);</span>
                <span class="s2">if </span><span class="s1">(existingValue.liveStyle === </span><span class="s2">true</span><span class="s1">) {</span>
                    <span class="s1">existingValue.jump(nextValue);</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(!existingValue.hasAnimated) {</span>
                    <span class="s1">existingValue.set(nextValue);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">const </span><span class="s1">latestValue = element.getStaticValue(key);</span>
                <span class="s1">element.addValue(key, motionDom.motionValue(latestValue !== undefined ? latestValue : nextValue, { owner: element }));</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">// Handle removed values</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">prev) {</span>
        <span class="s2">if </span><span class="s1">(next[key] === undefined)</span>
            <span class="s1">element.removeValue(key);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">next;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">getValueState(visualElement) {</span>
    <span class="s2">const </span><span class="s1">state = [{}, {}];</span>
    <span class="s1">visualElement?.values.forEach((value, key) =&gt; {</span>
        <span class="s1">state[</span><span class="s5">0</span><span class="s1">][key] = value.get();</span>
        <span class="s1">state[</span><span class="s5">1</span><span class="s1">][key] = value.getVelocity();</span>
    <span class="s1">});</span>
    <span class="s2">return </span><span class="s1">state;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">resolveVariantFromProps(props, definition, custom, visualElement) {</span>
    <span class="s3">/**</span>
     <span class="s3">* If the variant definition is a function, resolve.</span>
     <span class="s3">*/</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">definition === </span><span class="s0">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">[current, velocity] = getValueState(visualElement);</span>
        <span class="s1">definition = definition(custom !== undefined ? custom : props.custom, current, velocity);</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* If the variant definition is a variant label, or</span>
     <span class="s3">* the function returned a variant label, resolve.</span>
     <span class="s3">*/</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">definition === </span><span class="s0">&quot;string&quot;</span><span class="s1">) {</span>
        <span class="s1">definition = props.variants &amp;&amp; props.variants[definition];</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* At this point we've resolved both functions and variant labels,</span>
     <span class="s3">* but the resolved variant label might itself have been a function.</span>
     <span class="s3">* If so, resolve. This can only have returned a valid target object.</span>
     <span class="s3">*/</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">definition === </span><span class="s0">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">[current, velocity] = getValueState(visualElement);</span>
        <span class="s1">definition = definition(custom !== undefined ? custom : props.custom, current, velocity);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">definition;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">propEventHandlers = [</span>
    <span class="s0">&quot;AnimationStart&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;AnimationComplete&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;Update&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;BeforeLayoutMeasure&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;LayoutMeasure&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;LayoutAnimationStart&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;LayoutAnimationComplete&quot;</span><span class="s1">,</span>
<span class="s1">];</span>
<span class="s3">/**</span>
 <span class="s3">* A VisualElement is an imperative abstraction around UI elements such as</span>
 <span class="s3">* HTMLElement, SVGElement, Three.Object3D etc.</span>
 <span class="s3">*/</span>
<span class="s2">class </span><span class="s1">VisualElement {</span>
    <span class="s3">/**</span>
     <span class="s3">* This method takes React props and returns found MotionValues. For example, HTML</span>
     <span class="s3">* MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.</span>
     <span class="s3">*</span>
     <span class="s3">* This isn't an abstract method as it needs calling in the constructor, but it is</span>
     <span class="s3">* intended to be one.</span>
     <span class="s3">*/</span>
    <span class="s1">scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {</span>
        <span class="s2">return </span><span class="s1">{};</span>
    <span class="s1">}</span>
    <span class="s1">constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState, }, options = {}) {</span>
        <span class="s3">/**</span>
         <span class="s3">* A reference to the current underlying Instance, e.g. a HTMLElement</span>
         <span class="s3">* or Three.Mesh etc.</span>
         <span class="s3">*/</span>
        <span class="s2">this</span><span class="s1">.current = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s3">/**</span>
         <span class="s3">* A set containing references to this VisualElement's children.</span>
         <span class="s3">*/</span>
        <span class="s2">this</span><span class="s1">.children = </span><span class="s2">new </span><span class="s1">Set();</span>
        <span class="s3">/**</span>
         <span class="s3">* Determine what role this visual element should take in the variant tree.</span>
         <span class="s3">*/</span>
        <span class="s2">this</span><span class="s1">.isVariantNode = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.isControllingVariants = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s3">/**</span>
         <span class="s3">* Decides whether this VisualElement should animate in reduced motion</span>
         <span class="s3">* mode.</span>
         <span class="s3">*</span>
         <span class="s3">* TODO: This is currently set on every individual VisualElement but feels</span>
         <span class="s3">* like it could be set globally.</span>
         <span class="s3">*/</span>
        <span class="s2">this</span><span class="s1">.shouldReduceMotion = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s3">/**</span>
         <span class="s3">* A map of all motion values attached to this visual element. Motion</span>
         <span class="s3">* values are source of truth for any given animated value. A motion</span>
         <span class="s3">* value might be provided externally by the component via props.</span>
         <span class="s3">*/</span>
        <span class="s2">this</span><span class="s1">.values = </span><span class="s2">new </span><span class="s1">Map();</span>
        <span class="s2">this</span><span class="s1">.KeyframeResolver = motionDom.KeyframeResolver;</span>
        <span class="s3">/**</span>
         <span class="s3">* Cleanup functions for active features (hover/tap/exit etc)</span>
         <span class="s3">*/</span>
        <span class="s2">this</span><span class="s1">.features = {};</span>
        <span class="s3">/**</span>
         <span class="s3">* A map of every subscription that binds the provided or generated</span>
         <span class="s3">* motion values onChange listeners to this visual element.</span>
         <span class="s3">*/</span>
        <span class="s2">this</span><span class="s1">.valueSubscriptions = </span><span class="s2">new </span><span class="s1">Map();</span>
        <span class="s3">/**</span>
         <span class="s3">* A reference to the previously-provided motion values as returned</span>
         <span class="s3">* from scrapeMotionValuesFromProps. We use the keys in here to determine</span>
         <span class="s3">* if any motion values need to be removed after props are updated.</span>
         <span class="s3">*/</span>
        <span class="s2">this</span><span class="s1">.prevMotionValues = {};</span>
        <span class="s3">/**</span>
         <span class="s3">* An object containing a SubscriptionManager for each active event.</span>
         <span class="s3">*/</span>
        <span class="s2">this</span><span class="s1">.events = {};</span>
        <span class="s3">/**</span>
         <span class="s3">* An object containing an unsubscribe function for each prop event subscription.</span>
         <span class="s3">* For example, every &quot;Update&quot; event can have multiple subscribers via</span>
         <span class="s3">* VisualElement.on(), but only one of those can be defined via the onUpdate prop.</span>
         <span class="s3">*/</span>
        <span class="s2">this</span><span class="s1">.propEventSubscriptions = {};</span>
        <span class="s2">this</span><span class="s1">.notifyUpdate = () =&gt; </span><span class="s2">this</span><span class="s1">.notify(</span><span class="s0">&quot;Update&quot;</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.latestValues);</span>
        <span class="s2">this</span><span class="s1">.render = () =&gt; {</span>
            <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.current)</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s2">this</span><span class="s1">.triggerBuild();</span>
            <span class="s2">this</span><span class="s1">.renderInstance(</span><span class="s2">this</span><span class="s1">.current, </span><span class="s2">this</span><span class="s1">.renderState, </span><span class="s2">this</span><span class="s1">.props.style, </span><span class="s2">this</span><span class="s1">.projection);</span>
        <span class="s1">};</span>
        <span class="s2">this</span><span class="s1">.renderScheduledAt = </span><span class="s5">0.0</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.scheduleRender = () =&gt; {</span>
            <span class="s2">const </span><span class="s1">now = motionDom.time.now();</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.renderScheduledAt &lt; now) {</span>
                <span class="s2">this</span><span class="s1">.renderScheduledAt = now;</span>
                <span class="s1">motionDom.frame.render(</span><span class="s2">this</span><span class="s1">.render, </span><span class="s2">false</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">};</span>
        <span class="s2">const </span><span class="s1">{ latestValues, renderState } = visualState;</span>
        <span class="s2">this</span><span class="s1">.latestValues = latestValues;</span>
        <span class="s2">this</span><span class="s1">.baseTarget = { ...latestValues };</span>
        <span class="s2">this</span><span class="s1">.initialValues = props.initial ? { ...latestValues } : {};</span>
        <span class="s2">this</span><span class="s1">.renderState = renderState;</span>
        <span class="s2">this</span><span class="s1">.parent = parent;</span>
        <span class="s2">this</span><span class="s1">.props = props;</span>
        <span class="s2">this</span><span class="s1">.presenceContext = presenceContext;</span>
        <span class="s2">this</span><span class="s1">.depth = parent ? parent.depth + </span><span class="s5">1 </span><span class="s1">: </span><span class="s5">0</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.reducedMotionConfig = reducedMotionConfig;</span>
        <span class="s2">this</span><span class="s1">.options = options;</span>
        <span class="s2">this</span><span class="s1">.blockInitialAnimation = Boolean(blockInitialAnimation);</span>
        <span class="s2">this</span><span class="s1">.isControllingVariants = isControllingVariants(props);</span>
        <span class="s2">this</span><span class="s1">.isVariantNode = isVariantNode(props);</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isVariantNode) {</span>
            <span class="s2">this</span><span class="s1">.variantChildren = </span><span class="s2">new </span><span class="s1">Set();</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.manuallyAnimateOnMount = Boolean(parent &amp;&amp; parent.current);</span>
        <span class="s3">/**</span>
         <span class="s3">* Any motion values that are provided to the element when created</span>
         <span class="s3">* aren't yet bound to the element, as this would technically be impure.</span>
         <span class="s3">* However, we iterate through the motion values and set them to the</span>
         <span class="s3">* initial values for this component.</span>
         <span class="s3">*</span>
         <span class="s3">* TODO: This is impure and we should look at changing this to run on mount.</span>
         <span class="s3">* Doing so will break some tests but this isn't necessarily a breaking change,</span>
         <span class="s3">* more a reflection of the test.</span>
         <span class="s3">*/</span>
        <span class="s2">const </span><span class="s1">{ willChange, ...initialMotionValues } = </span><span class="s2">this</span><span class="s1">.scrapeMotionValuesFromProps(props, {}, </span><span class="s2">this</span><span class="s1">);</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">initialMotionValues) {</span>
            <span class="s2">const </span><span class="s1">value = initialMotionValues[key];</span>
            <span class="s2">if </span><span class="s1">(latestValues[key] !== undefined &amp;&amp; motionDom.isMotionValue(value)) {</span>
                <span class="s1">value.set(latestValues[key]);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">mount(instance) {</span>
        <span class="s2">this</span><span class="s1">.current = instance;</span>
        <span class="s1">visualElementStore.set(instance, </span><span class="s2">this</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.projection &amp;&amp; !</span><span class="s2">this</span><span class="s1">.projection.instance) {</span>
            <span class="s2">this</span><span class="s1">.projection.mount(instance);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.parent &amp;&amp; </span><span class="s2">this</span><span class="s1">.isVariantNode &amp;&amp; !</span><span class="s2">this</span><span class="s1">.isControllingVariants) {</span>
            <span class="s2">this</span><span class="s1">.removeFromVariantTree = </span><span class="s2">this</span><span class="s1">.parent.addVariantChild(</span><span class="s2">this</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.values.forEach((value, key) =&gt; </span><span class="s2">this</span><span class="s1">.bindToMotionValue(key, value));</span>
        <span class="s2">if </span><span class="s1">(!hasReducedMotionListener.current) {</span>
            <span class="s1">initPrefersReducedMotion();</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.shouldReduceMotion =</span>
            <span class="s2">this</span><span class="s1">.reducedMotionConfig === </span><span class="s0">&quot;never&quot;</span>
                <span class="s1">? </span><span class="s2">false</span>
                <span class="s1">: </span><span class="s2">this</span><span class="s1">.reducedMotionConfig === </span><span class="s0">&quot;always&quot;</span>
                    <span class="s1">? </span><span class="s2">true</span>
                    <span class="s1">: prefersReducedMotion.current;</span>
        <span class="s2">if </span><span class="s1">(process.env.NODE_ENV !== </span><span class="s0">&quot;production&quot;</span><span class="s1">) {</span>
            <span class="s1">motionUtils.warnOnce(</span><span class="s2">this</span><span class="s1">.shouldReduceMotion !== </span><span class="s2">true</span><span class="s1">, </span><span class="s0">&quot;You have Reduced Motion enabled on your device. Animations may not appear as expected.&quot;</span><span class="s1">, </span><span class="s0">&quot;reduced-motion-disabled&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.parent?.addChild(</span><span class="s2">this</span><span class="s1">);</span>
        <span class="s2">this</span><span class="s1">.update(</span><span class="s2">this</span><span class="s1">.props, </span><span class="s2">this</span><span class="s1">.presenceContext);</span>
    <span class="s1">}</span>
    <span class="s1">unmount() {</span>
        <span class="s2">this</span><span class="s1">.projection &amp;&amp; </span><span class="s2">this</span><span class="s1">.projection.unmount();</span>
        <span class="s1">motionDom.cancelFrame(</span><span class="s2">this</span><span class="s1">.notifyUpdate);</span>
        <span class="s1">motionDom.cancelFrame(</span><span class="s2">this</span><span class="s1">.render);</span>
        <span class="s2">this</span><span class="s1">.valueSubscriptions.forEach((remove) =&gt; remove());</span>
        <span class="s2">this</span><span class="s1">.valueSubscriptions.clear();</span>
        <span class="s2">this</span><span class="s1">.removeFromVariantTree &amp;&amp; </span><span class="s2">this</span><span class="s1">.removeFromVariantTree();</span>
        <span class="s2">this</span><span class="s1">.parent?.removeChild(</span><span class="s2">this</span><span class="s1">);</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in this</span><span class="s1">.events) {</span>
            <span class="s2">this</span><span class="s1">.events[key].clear();</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in this</span><span class="s1">.features) {</span>
            <span class="s2">const </span><span class="s1">feature = </span><span class="s2">this</span><span class="s1">.features[key];</span>
            <span class="s2">if </span><span class="s1">(feature) {</span>
                <span class="s1">feature.unmount();</span>
                <span class="s1">feature.isMounted = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.current = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">addChild(child) {</span>
        <span class="s2">this</span><span class="s1">.children.add(child);</span>
        <span class="s2">this</span><span class="s1">.enteringChildren ?? (</span><span class="s2">this</span><span class="s1">.enteringChildren = </span><span class="s2">new </span><span class="s1">Set());</span>
        <span class="s2">this</span><span class="s1">.enteringChildren.add(child);</span>
    <span class="s1">}</span>
    <span class="s1">removeChild(child) {</span>
        <span class="s2">this</span><span class="s1">.children.delete(child);</span>
        <span class="s2">this</span><span class="s1">.enteringChildren &amp;&amp; </span><span class="s2">this</span><span class="s1">.enteringChildren.delete(child);</span>
    <span class="s1">}</span>
    <span class="s1">bindToMotionValue(key, value) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.valueSubscriptions.has(key)) {</span>
            <span class="s2">this</span><span class="s1">.valueSubscriptions.get(key)();</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">valueIsTransform = motionDom.transformProps.has(key);</span>
        <span class="s2">if </span><span class="s1">(valueIsTransform &amp;&amp; </span><span class="s2">this</span><span class="s1">.onBindTransform) {</span>
            <span class="s2">this</span><span class="s1">.onBindTransform();</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">removeOnChange = value.on(</span><span class="s0">&quot;change&quot;</span><span class="s1">, (latestValue) =&gt; {</span>
            <span class="s2">this</span><span class="s1">.latestValues[key] = latestValue;</span>
            <span class="s2">this</span><span class="s1">.props.onUpdate &amp;&amp; motionDom.frame.preRender(</span><span class="s2">this</span><span class="s1">.notifyUpdate);</span>
            <span class="s2">if </span><span class="s1">(valueIsTransform &amp;&amp; </span><span class="s2">this</span><span class="s1">.projection) {</span>
                <span class="s2">this</span><span class="s1">.projection.isTransformDirty = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">this</span><span class="s1">.scheduleRender();</span>
        <span class="s1">});</span>
        <span class="s2">let </span><span class="s1">removeSyncCheck;</span>
        <span class="s2">if </span><span class="s1">(window.MotionCheckAppearSync) {</span>
            <span class="s1">removeSyncCheck = window.MotionCheckAppearSync(</span><span class="s2">this</span><span class="s1">, key, value);</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.valueSubscriptions.set(key, () =&gt; {</span>
            <span class="s1">removeOnChange();</span>
            <span class="s2">if </span><span class="s1">(removeSyncCheck)</span>
                <span class="s1">removeSyncCheck();</span>
            <span class="s2">if </span><span class="s1">(value.owner)</span>
                <span class="s1">value.stop();</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">sortNodePosition(other) {</span>
        <span class="s3">/**</span>
         <span class="s3">* If these nodes aren't even of the same type we can't compare their depth.</span>
         <span class="s3">*/</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.current ||</span>
            <span class="s1">!</span><span class="s2">this</span><span class="s1">.sortInstanceNodePosition ||</span>
            <span class="s2">this</span><span class="s1">.type !== other.type) {</span>
            <span class="s2">return </span><span class="s5">0</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.sortInstanceNodePosition(</span><span class="s2">this</span><span class="s1">.current, other.current);</span>
    <span class="s1">}</span>
    <span class="s1">updateFeatures() {</span>
        <span class="s2">let </span><span class="s1">key = </span><span class="s0">&quot;animation&quot;</span><span class="s1">;</span>
        <span class="s2">for </span><span class="s1">(key </span><span class="s2">in </span><span class="s1">featureDefinitions) {</span>
            <span class="s2">const </span><span class="s1">featureDefinition = featureDefinitions[key];</span>
            <span class="s2">if </span><span class="s1">(!featureDefinition)</span>
                <span class="s2">continue</span><span class="s1">;</span>
            <span class="s2">const </span><span class="s1">{ isEnabled, Feature: FeatureConstructor } = featureDefinition;</span>
            <span class="s3">/**</span>
             <span class="s3">* If this feature is enabled but not active, make a new instance.</span>
             <span class="s3">*/</span>
            <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.features[key] &amp;&amp;</span>
                <span class="s1">FeatureConstructor &amp;&amp;</span>
                <span class="s1">isEnabled(</span><span class="s2">this</span><span class="s1">.props)) {</span>
                <span class="s2">this</span><span class="s1">.features[key] = </span><span class="s2">new </span><span class="s1">FeatureConstructor(</span><span class="s2">this</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s3">/**</span>
             <span class="s3">* If we have a feature, mount or update it.</span>
             <span class="s3">*/</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.features[key]) {</span>
                <span class="s2">const </span><span class="s1">feature = </span><span class="s2">this</span><span class="s1">.features[key];</span>
                <span class="s2">if </span><span class="s1">(feature.isMounted) {</span>
                    <span class="s1">feature.update();</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">feature.mount();</span>
                    <span class="s1">feature.isMounted = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">triggerBuild() {</span>
        <span class="s2">this</span><span class="s1">.build(</span><span class="s2">this</span><span class="s1">.renderState, </span><span class="s2">this</span><span class="s1">.latestValues, </span><span class="s2">this</span><span class="s1">.props);</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Measure the current viewport box with or without transforms.</span>
     <span class="s3">* Only measures axis-aligned boxes, rotate and skew must be manually</span>
     <span class="s3">* removed with a re-render to work.</span>
     <span class="s3">*/</span>
    <span class="s1">measureViewportBox() {</span>
        <span class="s2">return this</span><span class="s1">.current</span>
            <span class="s1">? </span><span class="s2">this</span><span class="s1">.measureInstanceViewportBox(</span><span class="s2">this</span><span class="s1">.current, </span><span class="s2">this</span><span class="s1">.props)</span>
            <span class="s1">: createBox();</span>
    <span class="s1">}</span>
    <span class="s1">getStaticValue(key) {</span>
        <span class="s2">return this</span><span class="s1">.latestValues[key];</span>
    <span class="s1">}</span>
    <span class="s1">setStaticValue(key, value) {</span>
        <span class="s2">this</span><span class="s1">.latestValues[key] = value;</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Update the provided props. Ensure any newly-added motion values are</span>
     <span class="s3">* added to our map, old ones removed, and listeners updated.</span>
     <span class="s3">*/</span>
    <span class="s1">update(props, presenceContext) {</span>
        <span class="s2">if </span><span class="s1">(props.transformTemplate || </span><span class="s2">this</span><span class="s1">.props.transformTemplate) {</span>
            <span class="s2">this</span><span class="s1">.scheduleRender();</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.prevProps = </span><span class="s2">this</span><span class="s1">.props;</span>
        <span class="s2">this</span><span class="s1">.props = props;</span>
        <span class="s2">this</span><span class="s1">.prevPresenceContext = </span><span class="s2">this</span><span class="s1">.presenceContext;</span>
        <span class="s2">this</span><span class="s1">.presenceContext = presenceContext;</span>
        <span class="s3">/**</span>
         <span class="s3">* Update prop event handlers ie onAnimationStart, onAnimationComplete</span>
         <span class="s3">*/</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; propEventHandlers.length; i++) {</span>
            <span class="s2">const </span><span class="s1">key = propEventHandlers[i];</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.propEventSubscriptions[key]) {</span>
                <span class="s2">this</span><span class="s1">.propEventSubscriptions[key]();</span>
                <span class="s2">delete this</span><span class="s1">.propEventSubscriptions[key];</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">listenerName = (</span><span class="s0">&quot;on&quot; </span><span class="s1">+ key);</span>
            <span class="s2">const </span><span class="s1">listener = props[listenerName];</span>
            <span class="s2">if </span><span class="s1">(listener) {</span>
                <span class="s2">this</span><span class="s1">.propEventSubscriptions[key] = </span><span class="s2">this</span><span class="s1">.on(key, listener);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.prevMotionValues = updateMotionValuesFromProps(</span><span class="s2">this</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.scrapeMotionValuesFromProps(props, </span><span class="s2">this</span><span class="s1">.prevProps, </span><span class="s2">this</span><span class="s1">), </span><span class="s2">this</span><span class="s1">.prevMotionValues);</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.handleChildMotionValue) {</span>
            <span class="s2">this</span><span class="s1">.handleChildMotionValue();</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">getProps() {</span>
        <span class="s2">return this</span><span class="s1">.props;</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Returns the variant definition with a given name.</span>
     <span class="s3">*/</span>
    <span class="s1">getVariant(name) {</span>
        <span class="s2">return this</span><span class="s1">.props.variants ? </span><span class="s2">this</span><span class="s1">.props.variants[name] : undefined;</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Returns the defined default transition on this component.</span>
     <span class="s3">*/</span>
    <span class="s1">getDefaultTransition() {</span>
        <span class="s2">return this</span><span class="s1">.props.transition;</span>
    <span class="s1">}</span>
    <span class="s1">getTransformPagePoint() {</span>
        <span class="s2">return this</span><span class="s1">.props.transformPagePoint;</span>
    <span class="s1">}</span>
    <span class="s1">getClosestVariantNode() {</span>
        <span class="s2">return this</span><span class="s1">.isVariantNode</span>
            <span class="s1">? </span><span class="s2">this</span>
            <span class="s1">: </span><span class="s2">this</span><span class="s1">.parent</span>
                <span class="s1">? </span><span class="s2">this</span><span class="s1">.parent.getClosestVariantNode()</span>
                <span class="s1">: undefined;</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Add a child visual element to our set of children.</span>
     <span class="s3">*/</span>
    <span class="s1">addVariantChild(child) {</span>
        <span class="s2">const </span><span class="s1">closestVariantNode = </span><span class="s2">this</span><span class="s1">.getClosestVariantNode();</span>
        <span class="s2">if </span><span class="s1">(closestVariantNode) {</span>
            <span class="s1">closestVariantNode.variantChildren &amp;&amp;</span>
                <span class="s1">closestVariantNode.variantChildren.add(child);</span>
            <span class="s2">return </span><span class="s1">() =&gt; closestVariantNode.variantChildren.delete(child);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Add a motion value and bind it to this visual element.</span>
     <span class="s3">*/</span>
    <span class="s1">addValue(key, value) {</span>
        <span class="s3">// Remove existing value if it exists</span>
        <span class="s2">const </span><span class="s1">existingValue = </span><span class="s2">this</span><span class="s1">.values.get(key);</span>
        <span class="s2">if </span><span class="s1">(value !== existingValue) {</span>
            <span class="s2">if </span><span class="s1">(existingValue)</span>
                <span class="s2">this</span><span class="s1">.removeValue(key);</span>
            <span class="s2">this</span><span class="s1">.bindToMotionValue(key, value);</span>
            <span class="s2">this</span><span class="s1">.values.set(key, value);</span>
            <span class="s2">this</span><span class="s1">.latestValues[key] = value.get();</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Remove a motion value and unbind any active subscriptions.</span>
     <span class="s3">*/</span>
    <span class="s1">removeValue(key) {</span>
        <span class="s2">this</span><span class="s1">.values.delete(key);</span>
        <span class="s2">const </span><span class="s1">unsubscribe = </span><span class="s2">this</span><span class="s1">.valueSubscriptions.get(key);</span>
        <span class="s2">if </span><span class="s1">(unsubscribe) {</span>
            <span class="s1">unsubscribe();</span>
            <span class="s2">this</span><span class="s1">.valueSubscriptions.delete(key);</span>
        <span class="s1">}</span>
        <span class="s2">delete this</span><span class="s1">.latestValues[key];</span>
        <span class="s2">this</span><span class="s1">.removeValueFromRenderState(key, </span><span class="s2">this</span><span class="s1">.renderState);</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Check whether we have a motion value for this key</span>
     <span class="s3">*/</span>
    <span class="s1">hasValue(key) {</span>
        <span class="s2">return this</span><span class="s1">.values.has(key);</span>
    <span class="s1">}</span>
    <span class="s1">getValue(key, defaultValue) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.props.values &amp;&amp; </span><span class="s2">this</span><span class="s1">.props.values[key]) {</span>
            <span class="s2">return this</span><span class="s1">.props.values[key];</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">value = </span><span class="s2">this</span><span class="s1">.values.get(key);</span>
        <span class="s2">if </span><span class="s1">(value === undefined &amp;&amp; defaultValue !== undefined) {</span>
            <span class="s1">value = motionDom.motionValue(defaultValue === </span><span class="s2">null </span><span class="s1">? undefined : defaultValue, { owner: </span><span class="s2">this </span><span class="s1">});</span>
            <span class="s2">this</span><span class="s1">.addValue(key, value);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">value;</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* If we're trying to animate to a previously unencountered value,</span>
     <span class="s3">* we need to check for it in our state and as a last resort read it</span>
     <span class="s3">* directly from the instance (which might have performance implications).</span>
     <span class="s3">*/</span>
    <span class="s1">readValue(key, target) {</span>
        <span class="s2">let </span><span class="s1">value = </span><span class="s2">this</span><span class="s1">.latestValues[key] !== undefined || !</span><span class="s2">this</span><span class="s1">.current</span>
            <span class="s1">? </span><span class="s2">this</span><span class="s1">.latestValues[key]</span>
            <span class="s1">: </span><span class="s2">this</span><span class="s1">.getBaseTargetFromProps(</span><span class="s2">this</span><span class="s1">.props, key) ??</span>
                <span class="s2">this</span><span class="s1">.readValueFromInstance(</span><span class="s2">this</span><span class="s1">.current, key, </span><span class="s2">this</span><span class="s1">.options);</span>
        <span class="s2">if </span><span class="s1">(value !== undefined &amp;&amp; value !== </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">value === </span><span class="s0">&quot;string&quot; </span><span class="s1">&amp;&amp;</span>
                <span class="s1">(motionUtils.isNumericalString(value) || motionUtils.isZeroValueString(value))) {</span>
                <span class="s3">// If this is a number read as a string, ie &quot;0&quot; or &quot;200&quot;, convert it to a number</span>
                <span class="s1">value = parseFloat(value);</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(!motionDom.findValueType(value) &amp;&amp; motionDom.complex.test(target)) {</span>
                <span class="s1">value = motionDom.getAnimatableNone(key, target);</span>
            <span class="s1">}</span>
            <span class="s2">this</span><span class="s1">.setBaseTarget(key, motionDom.isMotionValue(value) ? value.get() : value);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">motionDom.isMotionValue(value) ? value.get() : value;</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Set the base target to later animate back to. This is currently</span>
     <span class="s3">* only hydrated on creation and when we first read a value.</span>
     <span class="s3">*/</span>
    <span class="s1">setBaseTarget(key, value) {</span>
        <span class="s2">this</span><span class="s1">.baseTarget[key] = value;</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Find the base target for a value thats been removed from all animation</span>
     <span class="s3">* props.</span>
     <span class="s3">*/</span>
    <span class="s1">getBaseTarget(key) {</span>
        <span class="s2">const </span><span class="s1">{ initial } = </span><span class="s2">this</span><span class="s1">.props;</span>
        <span class="s2">let </span><span class="s1">valueFromInitial;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">initial === </span><span class="s0">&quot;string&quot; </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">initial === </span><span class="s0">&quot;object&quot;</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">variant = resolveVariantFromProps(</span><span class="s2">this</span><span class="s1">.props, initial, </span><span class="s2">this</span><span class="s1">.presenceContext?.custom);</span>
            <span class="s2">if </span><span class="s1">(variant) {</span>
                <span class="s1">valueFromInitial = variant[key];</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">/**</span>
         <span class="s3">* If this value still exists in the current initial variant, read that.</span>
         <span class="s3">*/</span>
        <span class="s2">if </span><span class="s1">(initial &amp;&amp; valueFromInitial !== undefined) {</span>
            <span class="s2">return </span><span class="s1">valueFromInitial;</span>
        <span class="s1">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Alternatively, if this VisualElement config has defined a getBaseTarget</span>
         <span class="s3">* so we can read the value from an alternative source, try that.</span>
         <span class="s3">*/</span>
        <span class="s2">const </span><span class="s1">target = </span><span class="s2">this</span><span class="s1">.getBaseTargetFromProps(</span><span class="s2">this</span><span class="s1">.props, key);</span>
        <span class="s2">if </span><span class="s1">(target !== undefined &amp;&amp; !motionDom.isMotionValue(target))</span>
            <span class="s2">return </span><span class="s1">target;</span>
        <span class="s3">/**</span>
         <span class="s3">* If the value was initially defined on initial, but it doesn't any more,</span>
         <span class="s3">* return undefined. Otherwise return the value as initially read from the DOM.</span>
         <span class="s3">*/</span>
        <span class="s2">return this</span><span class="s1">.initialValues[key] !== undefined &amp;&amp;</span>
            <span class="s1">valueFromInitial === undefined</span>
            <span class="s1">? undefined</span>
            <span class="s1">: </span><span class="s2">this</span><span class="s1">.baseTarget[key];</span>
    <span class="s1">}</span>
    <span class="s1">on(eventName, callback) {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.events[eventName]) {</span>
            <span class="s2">this</span><span class="s1">.events[eventName] = </span><span class="s2">new </span><span class="s1">motionUtils.SubscriptionManager();</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.events[eventName].add(callback);</span>
    <span class="s1">}</span>
    <span class="s1">notify(eventName, ...args) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.events[eventName]) {</span>
            <span class="s2">this</span><span class="s1">.events[eventName].notify(...args);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">scheduleRenderMicrotask() {</span>
        <span class="s1">motionDom.microtask.render(</span><span class="s2">this</span><span class="s1">.render);</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">DOMVisualElement </span><span class="s2">extends </span><span class="s1">VisualElement {</span>
    <span class="s1">constructor() {</span>
        <span class="s2">super</span><span class="s1">(...arguments);</span>
        <span class="s2">this</span><span class="s1">.KeyframeResolver = motionDom.DOMKeyframesResolver;</span>
    <span class="s1">}</span>
    <span class="s1">sortInstanceNodePosition(a, b) {</span>
        <span class="s3">/**</span>
         <span class="s3">* compareDocumentPosition returns a bitmask, by using the bitwise &amp;</span>
         <span class="s3">* we're returning true if 2 in that bitmask is set to true. 2 is set</span>
         <span class="s3">* to true if b preceeds a.</span>
         <span class="s3">*/</span>
        <span class="s2">return </span><span class="s1">a.compareDocumentPosition(b) &amp; </span><span class="s5">2 </span><span class="s1">? </span><span class="s5">1 </span><span class="s1">: -</span><span class="s5">1</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">getBaseTargetFromProps(props, key) {</span>
        <span class="s2">return </span><span class="s1">props.style</span>
            <span class="s1">? props.style[key]</span>
            <span class="s1">: undefined;</span>
    <span class="s1">}</span>
    <span class="s1">removeValueFromRenderState(key, { vars, style }) {</span>
        <span class="s2">delete </span><span class="s1">vars[key];</span>
        <span class="s2">delete </span><span class="s1">style[key];</span>
    <span class="s1">}</span>
    <span class="s1">handleChildMotionValue() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.childSubscription) {</span>
            <span class="s2">this</span><span class="s1">.childSubscription();</span>
            <span class="s2">delete this</span><span class="s1">.childSubscription;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">{ children } = </span><span class="s2">this</span><span class="s1">.props;</span>
        <span class="s2">if </span><span class="s1">(motionDom.isMotionValue(children)) {</span>
            <span class="s2">this</span><span class="s1">.childSubscription = children.on(</span><span class="s0">&quot;change&quot;</span><span class="s1">, (latest) =&gt; {</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.current) {</span>
                    <span class="s2">this</span><span class="s1">.current.textContent = </span><span class="s0">`</span><span class="s1">${latest}</span><span class="s0">`</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">translateAlias = {</span>
    <span class="s1">x: </span><span class="s0">&quot;translateX&quot;</span><span class="s1">,</span>
    <span class="s1">y: </span><span class="s0">&quot;translateY&quot;</span><span class="s1">,</span>
    <span class="s1">z: </span><span class="s0">&quot;translateZ&quot;</span><span class="s1">,</span>
    <span class="s1">transformPerspective: </span><span class="s0">&quot;perspective&quot;</span><span class="s1">,</span>
<span class="s1">};</span>
<span class="s2">const </span><span class="s1">numTransforms = motionDom.transformPropOrder.length;</span>
<span class="s3">/**</span>
 <span class="s3">* Build a CSS transform style from individual x/y/scale etc properties.</span>
 <span class="s3">*</span>
 <span class="s3">* This outputs with a default order of transforms/scales/rotations, this can be customised by</span>
 <span class="s3">* providing a transformTemplate function.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">buildTransform(latestValues, transform, transformTemplate) {</span>
    <span class="s3">// The transform string we're going to build into.</span>
    <span class="s2">let </span><span class="s1">transformString = </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
    <span class="s2">let </span><span class="s1">transformIsDefault = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* Loop over all possible transforms in order, adding the ones that</span>
     <span class="s3">* are present to the transform string.</span>
     <span class="s3">*/</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; numTransforms; i++) {</span>
        <span class="s2">const </span><span class="s1">key = motionDom.transformPropOrder[i];</span>
        <span class="s2">const </span><span class="s1">value = latestValues[key];</span>
        <span class="s2">if </span><span class="s1">(value === undefined)</span>
            <span class="s2">continue</span><span class="s1">;</span>
        <span class="s2">let </span><span class="s1">valueIsDefault = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">value === </span><span class="s0">&quot;number&quot;</span><span class="s1">) {</span>
            <span class="s1">valueIsDefault = value === (key.startsWith(</span><span class="s0">&quot;scale&quot;</span><span class="s1">) ? </span><span class="s5">1 </span><span class="s1">: </span><span class="s5">0</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">valueIsDefault = parseFloat(value) === </span><span class="s5">0</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!valueIsDefault || transformTemplate) {</span>
            <span class="s2">const </span><span class="s1">valueAsType = motionDom.getValueAsType(value, motionDom.numberValueTypes[key]);</span>
            <span class="s2">if </span><span class="s1">(!valueIsDefault) {</span>
                <span class="s1">transformIsDefault = </span><span class="s2">false</span><span class="s1">;</span>
                <span class="s2">const </span><span class="s1">transformName = translateAlias[key] || key;</span>
                <span class="s1">transformString += </span><span class="s0">`</span><span class="s1">${transformName}</span><span class="s0">(</span><span class="s1">${valueAsType}</span><span class="s0">) `</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(transformTemplate) {</span>
                <span class="s1">transform[key] = valueAsType;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">transformString = transformString.trim();</span>
    <span class="s3">// If we have a custom `transform` template, pass our transform values and</span>
    <span class="s3">// generated transformString to that before returning</span>
    <span class="s2">if </span><span class="s1">(transformTemplate) {</span>
        <span class="s1">transformString = transformTemplate(transform, transformIsDefault ? </span><span class="s0">&quot;&quot; </span><span class="s1">: transformString);</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(transformIsDefault) {</span>
        <span class="s1">transformString = </span><span class="s0">&quot;none&quot;</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">transformString;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">buildHTMLStyles(state, latestValues, transformTemplate) {</span>
    <span class="s2">const </span><span class="s1">{ style, vars, transformOrigin } = state;</span>
    <span class="s3">// Track whether we encounter any transform or transformOrigin values.</span>
    <span class="s2">let </span><span class="s1">hasTransform = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">let </span><span class="s1">hasTransformOrigin = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* Loop over all our latest animated values and decide whether to handle them</span>
     <span class="s3">* as a style or CSS variable.</span>
     <span class="s3">*</span>
     <span class="s3">* Transforms and transform origins are kept separately for further processing.</span>
     <span class="s3">*/</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">latestValues) {</span>
        <span class="s2">const </span><span class="s1">value = latestValues[key];</span>
        <span class="s2">if </span><span class="s1">(motionDom.transformProps.has(key)) {</span>
            <span class="s3">// If this is a transform, flag to enable further transform processing</span>
            <span class="s1">hasTransform = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(motionDom.isCSSVariableName(key)) {</span>
            <span class="s1">vars[key] = value;</span>
            <span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s3">// Convert the value to its default value type, ie 0 -&gt; &quot;0px&quot;</span>
            <span class="s2">const </span><span class="s1">valueAsType = motionDom.getValueAsType(value, motionDom.numberValueTypes[key]);</span>
            <span class="s2">if </span><span class="s1">(key.startsWith(</span><span class="s0">&quot;origin&quot;</span><span class="s1">)) {</span>
                <span class="s3">// If this is a transform origin, flag and enable further transform-origin processing</span>
                <span class="s1">hasTransformOrigin = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">transformOrigin[key] =</span>
                    <span class="s1">valueAsType;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">style[key] = valueAsType;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!latestValues.transform) {</span>
        <span class="s2">if </span><span class="s1">(hasTransform || transformTemplate) {</span>
            <span class="s1">style.transform = buildTransform(latestValues, state.transform, transformTemplate);</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(style.transform) {</span>
            <span class="s3">/**</span>
             <span class="s3">* If we have previously created a transform but currently don't have any,</span>
             <span class="s3">* reset transform style to none.</span>
             <span class="s3">*/</span>
            <span class="s1">style.transform = </span><span class="s0">&quot;none&quot;</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Build a transformOrigin style. Uses the same defaults as the browser for</span>
     <span class="s3">* undefined origins.</span>
     <span class="s3">*/</span>
    <span class="s2">if </span><span class="s1">(hasTransformOrigin) {</span>
        <span class="s2">const </span><span class="s1">{ originX = </span><span class="s0">&quot;50%&quot;</span><span class="s1">, originY = </span><span class="s0">&quot;50%&quot;</span><span class="s1">, originZ = </span><span class="s5">0</span><span class="s1">, } = transformOrigin;</span>
        <span class="s1">style.transformOrigin = </span><span class="s0">`</span><span class="s1">${originX} ${originY} ${originZ}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">renderHTML(element, { style, vars }, styleProp, projection) {</span>
    <span class="s2">const </span><span class="s1">elementStyle = element.style;</span>
    <span class="s2">let </span><span class="s1">key;</span>
    <span class="s2">for </span><span class="s1">(key </span><span class="s2">in </span><span class="s1">style) {</span>
        <span class="s3">// CSSStyleDeclaration has [index: number]: string; in the types, so we use that as key type.</span>
        <span class="s1">elementStyle[key] = style[key];</span>
    <span class="s1">}</span>
    <span class="s3">// Write projection styles directly to element style</span>
    <span class="s1">projection?.applyProjectionStyles(elementStyle, styleProp);</span>
    <span class="s2">for </span><span class="s1">(key </span><span class="s2">in </span><span class="s1">vars) {</span>
        <span class="s3">// Loop over any CSS variables and assign those.</span>
        <span class="s3">// They can only be assigned using `setProperty`.</span>
        <span class="s1">elementStyle.setProperty(key, vars[key]);</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">isForcedMotionValue(key, { layout, layoutId }) {</span>
    <span class="s2">return </span><span class="s1">(motionDom.transformProps.has(key) ||</span>
        <span class="s1">key.startsWith(</span><span class="s0">&quot;origin&quot;</span><span class="s1">) ||</span>
        <span class="s1">((layout || layoutId !== undefined) &amp;&amp;</span>
            <span class="s1">(!!scaleCorrectors[key] || key === </span><span class="s0">&quot;opacity&quot;</span><span class="s1">)));</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">scrapeMotionValuesFromProps$1(props, prevProps, visualElement) {</span>
    <span class="s2">const </span><span class="s1">{ style } = props;</span>
    <span class="s2">const </span><span class="s1">newValues = {};</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">style) {</span>
        <span class="s2">if </span><span class="s1">(motionDom.isMotionValue(style[key]) ||</span>
            <span class="s1">(prevProps.style &amp;&amp;</span>
                <span class="s1">motionDom.isMotionValue(prevProps.style[key])) ||</span>
            <span class="s1">isForcedMotionValue(key, props) ||</span>
            <span class="s1">visualElement?.getValue(key)?.liveStyle !== undefined) {</span>
            <span class="s1">newValues[key] = style[key];</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">newValues;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">getComputedStyle(element) {</span>
    <span class="s2">return </span><span class="s1">window.getComputedStyle(element);</span>
<span class="s1">}</span>
<span class="s2">class </span><span class="s1">HTMLVisualElement </span><span class="s2">extends </span><span class="s1">DOMVisualElement {</span>
    <span class="s1">constructor() {</span>
        <span class="s2">super</span><span class="s1">(...arguments);</span>
        <span class="s2">this</span><span class="s1">.type = </span><span class="s0">&quot;html&quot;</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.renderInstance = renderHTML;</span>
    <span class="s1">}</span>
    <span class="s1">readValueFromInstance(instance, key) {</span>
        <span class="s2">if </span><span class="s1">(motionDom.transformProps.has(key)) {</span>
            <span class="s2">return this</span><span class="s1">.projection?.isProjecting</span>
                <span class="s1">? motionDom.defaultTransformValue(key)</span>
                <span class="s1">: motionDom.readTransformValue(instance, key);</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">const </span><span class="s1">computedStyle = getComputedStyle(instance);</span>
            <span class="s2">const </span><span class="s1">value = (motionDom.isCSSVariableName(key)</span>
                <span class="s1">? computedStyle.getPropertyValue(key)</span>
                <span class="s1">: computedStyle[key]) || </span><span class="s5">0</span><span class="s1">;</span>
            <span class="s2">return typeof </span><span class="s1">value === </span><span class="s0">&quot;string&quot; </span><span class="s1">? value.trim() : value;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">measureInstanceViewportBox(instance, { transformPagePoint }) {</span>
        <span class="s2">return </span><span class="s1">measureViewportBox(instance, transformPagePoint);</span>
    <span class="s1">}</span>
    <span class="s1">build(renderState, latestValues, props) {</span>
        <span class="s1">buildHTMLStyles(renderState, latestValues, props.transformTemplate);</span>
    <span class="s1">}</span>
    <span class="s1">scrapeMotionValuesFromProps(props, prevProps, visualElement) {</span>
        <span class="s2">return </span><span class="s1">scrapeMotionValuesFromProps$1(props, prevProps, visualElement);</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">LazyContext = React.createContext({ strict: </span><span class="s2">false </span><span class="s1">});</span>

<span class="s2">function </span><span class="s1">loadFeatures(features) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">features) {</span>
        <span class="s1">featureDefinitions[key] = {</span>
            <span class="s1">...featureDefinitions[key],</span>
            <span class="s1">...features[key],</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* A list of all valid MotionProps.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">@privateRemarks</span>
 <span class="s3">* This doesn't throw if a `MotionProp` name is missing - it should.</span>
 <span class="s3">*/</span>
<span class="s2">const </span><span class="s1">validMotionProps = </span><span class="s2">new </span><span class="s1">Set([</span>
    <span class="s0">&quot;animate&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;exit&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;variants&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;initial&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;style&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;values&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;variants&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;transition&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;transformTemplate&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;custom&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;inherit&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;onBeforeLayoutMeasure&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;onAnimationStart&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;onAnimationComplete&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;onUpdate&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;onDragStart&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;onDrag&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;onDragEnd&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;onMeasureDragConstraints&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;onDirectionLock&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;onDragTransitionEnd&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;_dragX&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;_dragY&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;onHoverStart&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;onHoverEnd&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;onViewportEnter&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;onViewportLeave&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;globalTapTarget&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;ignoreStrict&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;viewport&quot;</span><span class="s1">,</span>
<span class="s1">]);</span>
<span class="s3">/**</span>
 <span class="s3">* Check whether a prop name is a valid `MotionProp` key.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">key - Name of the property to check</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">`true` is key is a valid `MotionProp`.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">@public</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">isValidMotionProp(key) {</span>
    <span class="s2">return </span><span class="s1">(key.startsWith(</span><span class="s0">&quot;while&quot;</span><span class="s1">) ||</span>
        <span class="s1">(key.startsWith(</span><span class="s0">&quot;drag&quot;</span><span class="s1">) &amp;&amp; key !== </span><span class="s0">&quot;draggable&quot;</span><span class="s1">) ||</span>
        <span class="s1">key.startsWith(</span><span class="s0">&quot;layout&quot;</span><span class="s1">) ||</span>
        <span class="s1">key.startsWith(</span><span class="s0">&quot;onTap&quot;</span><span class="s1">) ||</span>
        <span class="s1">key.startsWith(</span><span class="s0">&quot;onPan&quot;</span><span class="s1">) ||</span>
        <span class="s1">key.startsWith(</span><span class="s0">&quot;onLayout&quot;</span><span class="s1">) ||</span>
        <span class="s1">validMotionProps.has(key));</span>
<span class="s1">}</span>

<span class="s2">let </span><span class="s1">shouldForward = (key) =&gt; !isValidMotionProp(key);</span>
<span class="s2">function </span><span class="s1">loadExternalIsValidProp(isValidProp) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">isValidProp !== </span><span class="s0">&quot;function&quot;</span><span class="s1">)</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s3">// Explicitly filter our events</span>
    <span class="s1">shouldForward = (key) =&gt; key.startsWith(</span><span class="s0">&quot;on&quot;</span><span class="s1">) ? !isValidMotionProp(key) : isValidProp(key);</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Emotion and Styled Components both allow users to pass through arbitrary props to their components</span>
 <span class="s3">* to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which</span>
 <span class="s3">* of these should be passed to the underlying DOM node.</span>
 <span class="s3">*</span>
 <span class="s3">* However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props</span>
 <span class="s3">* as it's seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props</span>
 <span class="s3">* passed through the `custom` prop so it doesn't *need* the payload or computational overhead of</span>
 <span class="s3">* `@emotion/is-prop-valid`, however to fix this problem we need to use it.</span>
 <span class="s3">*</span>
 <span class="s3">* By making it an optionalDependency we can offer this functionality only in the situations where it's</span>
 <span class="s3">* actually required.</span>
 <span class="s3">*/</span>
<span class="s2">try </span><span class="s1">{</span>
    <span class="s3">/**</span>
     <span class="s3">* We attempt to import this package but require won't be defined in esm environments, in that case</span>
     <span class="s3">* isPropValid will have to be provided via `MotionContext`. In a 6.0.0 this should probably be removed</span>
     <span class="s3">* in favour of explicit injection.</span>
     <span class="s3">*/</span>
    <span class="s1">loadExternalIsValidProp(require(</span><span class="s0">&quot;@emotion/is-prop-valid&quot;</span><span class="s1">).default);</span>
<span class="s1">}</span>
<span class="s2">catch </span><span class="s1">{</span>
    <span class="s3">// We don't need to actually do anything here - the fallback is the existing `isPropValid`.</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">filterProps(props, isDom, forwardMotionProps) {</span>
    <span class="s2">const </span><span class="s1">filteredProps = {};</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">props) {</span>
        <span class="s3">/**</span>
         <span class="s3">* values is considered a valid prop by Emotion, so if it's present</span>
         <span class="s3">* this will be rendered out to the DOM unless explicitly filtered.</span>
         <span class="s3">*</span>
         <span class="s3">* We check the type as it could be used with the `feColorMatrix`</span>
         <span class="s3">* element, which we support.</span>
         <span class="s3">*/</span>
        <span class="s2">if </span><span class="s1">(key === </span><span class="s0">&quot;values&quot; </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">props.values === </span><span class="s0">&quot;object&quot;</span><span class="s1">)</span>
            <span class="s2">continue</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(shouldForward(key) ||</span>
            <span class="s1">(forwardMotionProps === </span><span class="s2">true </span><span class="s1">&amp;&amp; isValidMotionProp(key)) ||</span>
            <span class="s1">(!isDom &amp;&amp; !isValidMotionProp(key)) ||</span>
            <span class="s3">// If trying to use native HTML drag events, forward drag listeners</span>
            <span class="s1">(props[</span><span class="s0">&quot;draggable&quot;</span><span class="s1">] &amp;&amp;</span>
                <span class="s1">key.startsWith(</span><span class="s0">&quot;onDrag&quot;</span><span class="s1">))) {</span>
            <span class="s1">filteredProps[key] =</span>
                <span class="s1">props[key];</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">filteredProps;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">dashKeys = {</span>
    <span class="s1">offset: </span><span class="s0">&quot;stroke-dashoffset&quot;</span><span class="s1">,</span>
    <span class="s1">array: </span><span class="s0">&quot;stroke-dasharray&quot;</span><span class="s1">,</span>
<span class="s1">};</span>
<span class="s2">const </span><span class="s1">camelKeys = {</span>
    <span class="s1">offset: </span><span class="s0">&quot;strokeDashoffset&quot;</span><span class="s1">,</span>
    <span class="s1">array: </span><span class="s0">&quot;strokeDasharray&quot;</span><span class="s1">,</span>
<span class="s1">};</span>
<span class="s3">/**</span>
 <span class="s3">* Build SVG path properties. Uses the path's measured length to convert</span>
 <span class="s3">* our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset</span>
 <span class="s3">* and stroke-dasharray attributes.</span>
 <span class="s3">*</span>
 <span class="s3">* This function is mutative to reduce per-frame GC.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">buildSVGPath(attrs, length, spacing = </span><span class="s5">1</span><span class="s1">, offset = </span><span class="s5">0</span><span class="s1">, useDashCase = </span><span class="s2">true</span><span class="s1">) {</span>
    <span class="s3">// Normalise path length by setting SVG attribute pathLength to 1</span>
    <span class="s1">attrs.pathLength = </span><span class="s5">1</span><span class="s1">;</span>
    <span class="s3">// We use dash case when setting attributes directly to the DOM node and camel case</span>
    <span class="s3">// when defining props on a React component.</span>
    <span class="s2">const </span><span class="s1">keys = useDashCase ? dashKeys : camelKeys;</span>
    <span class="s3">// Build the dash offset</span>
    <span class="s1">attrs[keys.offset] = motionDom.px.transform(-offset);</span>
    <span class="s3">// Build the dash array</span>
    <span class="s2">const </span><span class="s1">pathLength = motionDom.px.transform(length);</span>
    <span class="s2">const </span><span class="s1">pathSpacing = motionDom.px.transform(spacing);</span>
    <span class="s1">attrs[keys.array] = </span><span class="s0">`</span><span class="s1">${pathLength} ${pathSpacing}</span><span class="s0">`</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Build SVG visual attributes, like cx and style.transform</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">buildSVGAttrs(state, { attrX, attrY, attrScale, pathLength, pathSpacing = </span><span class="s5">1</span><span class="s1">, pathOffset = </span><span class="s5">0</span><span class="s1">, </span>
<span class="s3">// This is object creation, which we try to avoid per-frame.</span>
<span class="s1">...latest }, isSVGTag, transformTemplate, styleProp) {</span>
    <span class="s1">buildHTMLStyles(state, latest, transformTemplate);</span>
    <span class="s3">/**</span>
     <span class="s3">* For svg tags we just want to make sure viewBox is animatable and treat all the styles</span>
     <span class="s3">* as normal HTML tags.</span>
     <span class="s3">*/</span>
    <span class="s2">if </span><span class="s1">(isSVGTag) {</span>
        <span class="s2">if </span><span class="s1">(state.style.viewBox) {</span>
            <span class="s1">state.attrs.viewBox = state.style.viewBox;</span>
        <span class="s1">}</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">state.attrs = state.style;</span>
    <span class="s1">state.style = {};</span>
    <span class="s2">const </span><span class="s1">{ attrs, style } = state;</span>
    <span class="s3">/**</span>
     <span class="s3">* However, we apply transforms as CSS transforms.</span>
     <span class="s3">* So if we detect a transform, transformOrigin we take it from attrs and copy it into style.</span>
     <span class="s3">*/</span>
    <span class="s2">if </span><span class="s1">(attrs.transform) {</span>
        <span class="s1">style.transform = attrs.transform;</span>
        <span class="s2">delete </span><span class="s1">attrs.transform;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(style.transform || attrs.transformOrigin) {</span>
        <span class="s1">style.transformOrigin = attrs.transformOrigin ?? </span><span class="s0">&quot;50% 50%&quot;</span><span class="s1">;</span>
        <span class="s2">delete </span><span class="s1">attrs.transformOrigin;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(style.transform) {</span>
        <span class="s3">/**</span>
         <span class="s3">* SVG's element transform-origin uses its own median as a reference.</span>
         <span class="s3">* Therefore, transformBox becomes a fill-box</span>
         <span class="s3">*/</span>
        <span class="s1">style.transformBox = styleProp?.transformBox ?? </span><span class="s0">&quot;fill-box&quot;</span><span class="s1">;</span>
        <span class="s2">delete </span><span class="s1">attrs.transformBox;</span>
    <span class="s1">}</span>
    <span class="s3">// Render attrX/attrY/attrScale as attributes</span>
    <span class="s2">if </span><span class="s1">(attrX !== undefined)</span>
        <span class="s1">attrs.x = attrX;</span>
    <span class="s2">if </span><span class="s1">(attrY !== undefined)</span>
        <span class="s1">attrs.y = attrY;</span>
    <span class="s2">if </span><span class="s1">(attrScale !== undefined)</span>
        <span class="s1">attrs.scale = attrScale;</span>
    <span class="s3">// Build SVG path if one has been defined</span>
    <span class="s2">if </span><span class="s1">(pathLength !== undefined) {</span>
        <span class="s1">buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, </span><span class="s2">false</span><span class="s1">);</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* A set of attribute names that are always read/written as camel case.</span>
 <span class="s3">*/</span>
<span class="s2">const </span><span class="s1">camelCaseAttributes = </span><span class="s2">new </span><span class="s1">Set([</span>
    <span class="s0">&quot;baseFrequency&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;diffuseConstant&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;kernelMatrix&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;kernelUnitLength&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;keySplines&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;keyTimes&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;limitingConeAngle&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;markerHeight&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;markerWidth&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;numOctaves&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;targetX&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;targetY&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;surfaceScale&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;specularConstant&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;specularExponent&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;stdDeviation&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;tableValues&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;viewBox&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;gradientTransform&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;pathLength&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;startOffset&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;textLength&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;lengthAdjust&quot;</span><span class="s1">,</span>
<span class="s1">]);</span>

<span class="s2">const </span><span class="s1">isSVGTag = (tag) =&gt; </span><span class="s2">typeof </span><span class="s1">tag === </span><span class="s0">&quot;string&quot; </span><span class="s1">&amp;&amp; tag.toLowerCase() === </span><span class="s0">&quot;svg&quot;</span><span class="s1">;</span>

<span class="s2">function </span><span class="s1">renderSVG(element, renderState, _styleProp, projection) {</span>
    <span class="s1">renderHTML(element, renderState, undefined, projection);</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">renderState.attrs) {</span>
        <span class="s1">element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">scrapeMotionValuesFromProps(props, prevProps, visualElement) {</span>
    <span class="s2">const </span><span class="s1">newValues = scrapeMotionValuesFromProps$1(props, prevProps, visualElement);</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">props) {</span>
        <span class="s2">if </span><span class="s1">(motionDom.isMotionValue(props[key]) ||</span>
            <span class="s1">motionDom.isMotionValue(prevProps[key])) {</span>
            <span class="s2">const </span><span class="s1">targetKey = motionDom.transformPropOrder.indexOf(key) !== -</span><span class="s5">1</span>
                <span class="s1">? </span><span class="s0">&quot;attr&quot; </span><span class="s1">+ key.charAt(</span><span class="s5">0</span><span class="s1">).toUpperCase() + key.substring(</span><span class="s5">1</span><span class="s1">)</span>
                <span class="s1">: key;</span>
            <span class="s1">newValues[targetKey] = props[key];</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">newValues;</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">SVGVisualElement </span><span class="s2">extends </span><span class="s1">DOMVisualElement {</span>
    <span class="s1">constructor() {</span>
        <span class="s2">super</span><span class="s1">(...arguments);</span>
        <span class="s2">this</span><span class="s1">.type = </span><span class="s0">&quot;svg&quot;</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.isSVGTag = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.measureInstanceViewportBox = createBox;</span>
    <span class="s1">}</span>
    <span class="s1">getBaseTargetFromProps(props, key) {</span>
        <span class="s2">return </span><span class="s1">props[key];</span>
    <span class="s1">}</span>
    <span class="s1">readValueFromInstance(instance, key) {</span>
        <span class="s2">if </span><span class="s1">(motionDom.transformProps.has(key)) {</span>
            <span class="s2">const </span><span class="s1">defaultType = motionDom.getDefaultValueType(key);</span>
            <span class="s2">return </span><span class="s1">defaultType ? defaultType.default || </span><span class="s5">0 </span><span class="s1">: </span><span class="s5">0</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;</span>
        <span class="s2">return </span><span class="s1">instance.getAttribute(key);</span>
    <span class="s1">}</span>
    <span class="s1">scrapeMotionValuesFromProps(props, prevProps, visualElement) {</span>
        <span class="s2">return </span><span class="s1">scrapeMotionValuesFromProps(props, prevProps, visualElement);</span>
    <span class="s1">}</span>
    <span class="s1">build(renderState, latestValues, props) {</span>
        <span class="s1">buildSVGAttrs(renderState, latestValues, </span><span class="s2">this</span><span class="s1">.isSVGTag, props.transformTemplate, props.style);</span>
    <span class="s1">}</span>
    <span class="s1">renderInstance(instance, renderState, styleProp, projection) {</span>
        <span class="s1">renderSVG(instance, renderState, styleProp, projection);</span>
    <span class="s1">}</span>
    <span class="s1">mount(instance) {</span>
        <span class="s2">this</span><span class="s1">.isSVGTag = isSVGTag(instance.tagName);</span>
        <span class="s2">super</span><span class="s1">.mount(instance);</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* We keep these listed separately as we use the lowercase tag names as part</span>
 <span class="s3">* of the runtime bundle to detect SVG components</span>
 <span class="s3">*/</span>
<span class="s2">const </span><span class="s1">lowercaseSVGElements = [</span>
    <span class="s0">&quot;animate&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;circle&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;defs&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;desc&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;ellipse&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;g&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;image&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;line&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;filter&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;marker&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;mask&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;metadata&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;path&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;pattern&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;polygon&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;polyline&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;rect&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;stop&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;switch&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;symbol&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;svg&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;text&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;tspan&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;use&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;view&quot;</span><span class="s1">,</span>
<span class="s1">];</span>

<span class="s2">function </span><span class="s1">isSVGComponent(Component) {</span>
    <span class="s2">if </span><span class="s1">(</span>
    <span class="s3">/**</span>
     <span class="s3">* If it's not a string, it's a custom React component. Currently we only support</span>
     <span class="s3">* HTML custom React components.</span>
     <span class="s3">*/</span>
    <span class="s2">typeof </span><span class="s1">Component !== </span><span class="s0">&quot;string&quot; </span><span class="s1">||</span>
        <span class="s3">/**</span>
         <span class="s3">* If it contains a dash, the element is a custom HTML webcomponent.</span>
         <span class="s3">*/</span>
        <span class="s1">Component.includes(</span><span class="s0">&quot;-&quot;</span><span class="s1">)) {</span>
        <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(</span>
    <span class="s3">/**</span>
     <span class="s3">* If it's in our list of lowercase SVG tags, it's an SVG component</span>
     <span class="s3">*/</span>
    <span class="s1">lowercaseSVGElements.indexOf(Component) &gt; -</span><span class="s5">1 </span><span class="s1">||</span>
        <span class="s3">/**</span>
         <span class="s3">* If it contains a capital letter, it's an SVG component</span>
         <span class="s3">*/</span>
        <span class="s6">/[A-Z]/u</span><span class="s1">.test(Component)) {</span>
        <span class="s2">return true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return false</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">createDomVisualElement = (Component, options) =&gt; {</span>
    <span class="s2">return </span><span class="s1">isSVGComponent(Component)</span>
        <span class="s1">? </span><span class="s2">new </span><span class="s1">SVGVisualElement(options)</span>
        <span class="s1">: </span><span class="s2">new </span><span class="s1">HTMLVisualElement(options, {</span>
            <span class="s1">allowProjection: Component !== React.Fragment,</span>
        <span class="s1">});</span>
<span class="s1">};</span>

<span class="s2">const </span><span class="s1">MotionContext = </span><span class="s3">/* @__PURE__ */ </span><span class="s1">React.createContext({});</span>

<span class="s2">function </span><span class="s1">getCurrentTreeVariants(props, context) {</span>
    <span class="s2">if </span><span class="s1">(isControllingVariants(props)) {</span>
        <span class="s2">const </span><span class="s1">{ initial, animate } = props;</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">initial: initial === </span><span class="s2">false </span><span class="s1">|| isVariantLabel(initial)</span>
                <span class="s1">? initial</span>
                <span class="s1">: undefined,</span>
            <span class="s1">animate: isVariantLabel(animate) ? animate : undefined,</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">props.inherit !== </span><span class="s2">false </span><span class="s1">? context : {};</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">useCreateMotionContext(props) {</span>
    <span class="s2">const </span><span class="s1">{ initial, animate } = getCurrentTreeVariants(props, React.useContext(MotionContext));</span>
    <span class="s2">return </span><span class="s1">React.useMemo(() =&gt; ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">variantLabelsAsDependency(prop) {</span>
    <span class="s2">return </span><span class="s1">Array.isArray(prop) ? prop.join(</span><span class="s0">&quot; &quot;</span><span class="s1">) : prop;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">createHtmlRenderState = () =&gt; ({</span>
    <span class="s1">style: {},</span>
    <span class="s1">transform: {},</span>
    <span class="s1">transformOrigin: {},</span>
    <span class="s1">vars: {},</span>
<span class="s1">});</span>

<span class="s2">function </span><span class="s1">copyRawValuesOnly(target, source, props) {</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">source) {</span>
        <span class="s2">if </span><span class="s1">(!motionDom.isMotionValue(source[key]) &amp;&amp; !isForcedMotionValue(key, props)) {</span>
            <span class="s1">target[key] = source[key];</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">useInitialMotionValues({ transformTemplate }, visualState) {</span>
    <span class="s2">return </span><span class="s1">React.useMemo(() =&gt; {</span>
        <span class="s2">const </span><span class="s1">state = createHtmlRenderState();</span>
        <span class="s1">buildHTMLStyles(state, visualState, transformTemplate);</span>
        <span class="s2">return </span><span class="s1">Object.assign({}, state.vars, state.style);</span>
    <span class="s1">}, [visualState]);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">useStyle(props, visualState) {</span>
    <span class="s2">const </span><span class="s1">styleProp = props.style || {};</span>
    <span class="s2">const </span><span class="s1">style = {};</span>
    <span class="s3">/**</span>
     <span class="s3">* Copy non-Motion Values straight into style</span>
     <span class="s3">*/</span>
    <span class="s1">copyRawValuesOnly(style, styleProp, props);</span>
    <span class="s1">Object.assign(style, useInitialMotionValues(props, visualState));</span>
    <span class="s2">return </span><span class="s1">style;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">useHTMLProps(props, visualState) {</span>
    <span class="s3">// The `any` isn't ideal but it is the type of createElement props argument</span>
    <span class="s2">const </span><span class="s1">htmlProps = {};</span>
    <span class="s2">const </span><span class="s1">style = useStyle(props, visualState);</span>
    <span class="s2">if </span><span class="s1">(props.drag &amp;&amp; props.dragListener !== </span><span class="s2">false</span><span class="s1">) {</span>
        <span class="s3">// Disable the ghost element when a user drags</span>
        <span class="s1">htmlProps.draggable = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s3">// Disable text selection</span>
        <span class="s1">style.userSelect =</span>
            <span class="s1">style.WebkitUserSelect =</span>
                <span class="s1">style.WebkitTouchCallout =</span>
                    <span class="s0">&quot;none&quot;</span><span class="s1">;</span>
        <span class="s3">// Disable scrolling on the draggable direction</span>
        <span class="s1">style.touchAction =</span>
            <span class="s1">props.drag === </span><span class="s2">true</span>
                <span class="s1">? </span><span class="s0">&quot;none&quot;</span>
                <span class="s1">: </span><span class="s0">`pan-</span><span class="s1">${props.drag === </span><span class="s0">&quot;x&quot; </span><span class="s1">? </span><span class="s0">&quot;y&quot; </span><span class="s1">: </span><span class="s0">&quot;x&quot;</span><span class="s1">}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(props.tabIndex === undefined &amp;&amp;</span>
        <span class="s1">(props.onTap || props.onTapStart || props.whileTap)) {</span>
        <span class="s1">htmlProps.tabIndex = </span><span class="s5">0</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">htmlProps.style = style;</span>
    <span class="s2">return </span><span class="s1">htmlProps;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">createSvgRenderState = () =&gt; ({</span>
    <span class="s1">...createHtmlRenderState(),</span>
    <span class="s1">attrs: {},</span>
<span class="s1">});</span>

<span class="s2">function </span><span class="s1">useSVGProps(props, visualState, _isStatic, Component) {</span>
    <span class="s2">const </span><span class="s1">visualProps = React.useMemo(() =&gt; {</span>
        <span class="s2">const </span><span class="s1">state = createSvgRenderState();</span>
        <span class="s1">buildSVGAttrs(state, visualState, isSVGTag(Component), props.transformTemplate, props.style);</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">...state.attrs,</span>
            <span class="s1">style: { ...state.style },</span>
        <span class="s1">};</span>
    <span class="s1">}, [visualState]);</span>
    <span class="s2">if </span><span class="s1">(props.style) {</span>
        <span class="s2">const </span><span class="s1">rawStyles = {};</span>
        <span class="s1">copyRawValuesOnly(rawStyles, props.style, props);</span>
        <span class="s1">visualProps.style = { ...rawStyles, ...visualProps.style };</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">visualProps;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">useRender(Component, props, ref, { latestValues, }, isStatic, forwardMotionProps = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s2">const </span><span class="s1">useVisualProps = isSVGComponent(Component)</span>
        <span class="s1">? useSVGProps</span>
        <span class="s1">: useHTMLProps;</span>
    <span class="s2">const </span><span class="s1">visualProps = useVisualProps(props, latestValues, isStatic, Component);</span>
    <span class="s2">const </span><span class="s1">filteredProps = filterProps(props, </span><span class="s2">typeof </span><span class="s1">Component === </span><span class="s0">&quot;string&quot;</span><span class="s1">, forwardMotionProps);</span>
    <span class="s2">const </span><span class="s1">elementProps = Component !== React.Fragment ? { ...filteredProps, ...visualProps, ref } : {};</span>
    <span class="s3">/**</span>
     <span class="s3">* If component has been handed a motion value as its child,</span>
     <span class="s3">* memoise its initial value and render that. Subsequent updates</span>
     <span class="s3">* will be handled by the onChange handler</span>
     <span class="s3">*/</span>
    <span class="s2">const </span><span class="s1">{ children } = props;</span>
    <span class="s2">const </span><span class="s1">renderedChildren = React.useMemo(() =&gt; (motionDom.isMotionValue(children) ? children.get() : children), [children]);</span>
    <span class="s2">return </span><span class="s1">React.createElement(Component, {</span>
        <span class="s1">...elementProps,</span>
        <span class="s1">children: renderedChildren,</span>
    <span class="s1">});</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">makeState({ scrapeMotionValuesFromProps, createRenderState, }, props, context, presenceContext) {</span>
    <span class="s2">const </span><span class="s1">state = {</span>
        <span class="s1">latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps),</span>
        <span class="s1">renderState: createRenderState(),</span>
    <span class="s1">};</span>
    <span class="s2">return </span><span class="s1">state;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">makeLatestValues(props, context, presenceContext, scrapeMotionValues) {</span>
    <span class="s2">const </span><span class="s1">values = {};</span>
    <span class="s2">const </span><span class="s1">motionValues = scrapeMotionValues(props, {});</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">motionValues) {</span>
        <span class="s1">values[key] = resolveMotionValue(motionValues[key]);</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">{ initial, animate } = props;</span>
    <span class="s2">const </span><span class="s1">isControllingVariants$1 = isControllingVariants(props);</span>
    <span class="s2">const </span><span class="s1">isVariantNode$1 = isVariantNode(props);</span>
    <span class="s2">if </span><span class="s1">(context &amp;&amp;</span>
        <span class="s1">isVariantNode$1 &amp;&amp;</span>
        <span class="s1">!isControllingVariants$1 &amp;&amp;</span>
        <span class="s1">props.inherit !== </span><span class="s2">false</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(initial === undefined)</span>
            <span class="s1">initial = context.initial;</span>
        <span class="s2">if </span><span class="s1">(animate === undefined)</span>
            <span class="s1">animate = context.animate;</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">isInitialAnimationBlocked = presenceContext</span>
        <span class="s1">? presenceContext.initial === </span><span class="s2">false</span>
        <span class="s1">: </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">isInitialAnimationBlocked = isInitialAnimationBlocked || initial === </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">variantToSet = isInitialAnimationBlocked ? animate : initial;</span>
    <span class="s2">if </span><span class="s1">(variantToSet &amp;&amp;</span>
        <span class="s2">typeof </span><span class="s1">variantToSet !== </span><span class="s0">&quot;boolean&quot; </span><span class="s1">&amp;&amp;</span>
        <span class="s1">!isAnimationControls(variantToSet)) {</span>
        <span class="s2">const </span><span class="s1">list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; list.length; i++) {</span>
            <span class="s2">const </span><span class="s1">resolved = resolveVariantFromProps(props, list[i]);</span>
            <span class="s2">if </span><span class="s1">(resolved) {</span>
                <span class="s2">const </span><span class="s1">{ transitionEnd, transition, ...target } = resolved;</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">target) {</span>
                    <span class="s2">let </span><span class="s1">valueTarget = target[key];</span>
                    <span class="s2">if </span><span class="s1">(Array.isArray(valueTarget)) {</span>
                        <span class="s3">/**</span>
                         <span class="s3">* Take final keyframe if the initial animation is blocked because</span>
                         <span class="s3">* we want to initialise at the end of that blocked animation.</span>
                         <span class="s3">*/</span>
                        <span class="s2">const </span><span class="s1">index = isInitialAnimationBlocked</span>
                            <span class="s1">? valueTarget.length - </span><span class="s5">1</span>
                            <span class="s1">: </span><span class="s5">0</span><span class="s1">;</span>
                        <span class="s1">valueTarget = valueTarget[index];</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(valueTarget !== </span><span class="s2">null</span><span class="s1">) {</span>
                        <span class="s1">values[key] = valueTarget;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">transitionEnd) {</span>
                    <span class="s1">values[key] = transitionEnd[key];</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">values;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">makeUseVisualState = (config) =&gt; (props, isStatic) =&gt; {</span>
    <span class="s2">const </span><span class="s1">context = React.useContext(MotionContext);</span>
    <span class="s2">const </span><span class="s1">presenceContext = React.useContext(PresenceContext);</span>
    <span class="s2">const </span><span class="s1">make = () =&gt; makeState(config, props, context, presenceContext);</span>
    <span class="s2">return </span><span class="s1">isStatic ? make() : useConstant(make);</span>
<span class="s1">};</span>

<span class="s2">const </span><span class="s1">useHTMLVisualState = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">makeUseVisualState({</span>
    <span class="s1">scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,</span>
    <span class="s1">createRenderState: createHtmlRenderState,</span>
<span class="s1">});</span>

<span class="s2">const </span><span class="s1">useSVGVisualState = </span><span class="s3">/*@__PURE__*/ </span><span class="s1">makeUseVisualState({</span>
    <span class="s1">scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,</span>
    <span class="s1">createRenderState: createSvgRenderState,</span>
<span class="s1">});</span>

<span class="s2">const </span><span class="s1">motionComponentSymbol = Symbol.for(</span><span class="s0">&quot;motionComponentSymbol&quot;</span><span class="s1">);</span>

<span class="s2">function </span><span class="s1">isRefObject(ref) {</span>
    <span class="s2">return </span><span class="s1">(ref &amp;&amp;</span>
        <span class="s2">typeof </span><span class="s1">ref === </span><span class="s0">&quot;object&quot; </span><span class="s1">&amp;&amp;</span>
        <span class="s1">Object.prototype.hasOwnProperty.call(ref, </span><span class="s0">&quot;current&quot;</span><span class="s1">));</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Creates a ref function that, when called, hydrates the provided</span>
 <span class="s3">* external ref and VisualElement.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">useMotionRef(visualState, visualElement, externalRef) {</span>
    <span class="s2">return </span><span class="s1">React.useCallback((instance) =&gt; {</span>
        <span class="s2">if </span><span class="s1">(instance) {</span>
            <span class="s1">visualState.onMount &amp;&amp; visualState.onMount(instance);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(visualElement) {</span>
            <span class="s2">if </span><span class="s1">(instance) {</span>
                <span class="s1">visualElement.mount(instance);</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">visualElement.unmount();</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(externalRef) {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">externalRef === </span><span class="s0">&quot;function&quot;</span><span class="s1">) {</span>
                <span class="s1">externalRef(instance);</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(isRefObject(externalRef)) {</span>
                <span class="s1">externalRef.current = instance;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}, </span>
    <span class="s3">/**</span>
     <span class="s3">* Include externalRef in dependencies to ensure the callback updates</span>
     <span class="s3">* when the ref changes, allowing proper ref forwarding.</span>
     <span class="s3">*/</span>
    <span class="s1">[visualElement]);</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Internal, exported only for usage in Framer</span>
 <span class="s3">*/</span>
<span class="s2">const </span><span class="s1">SwitchLayoutGroupContext = React.createContext({});</span>

<span class="s2">function </span><span class="s1">useVisualElement(Component, visualState, props, createVisualElement, ProjectionNodeConstructor) {</span>
    <span class="s2">const </span><span class="s1">{ visualElement: parent } = React.useContext(MotionContext);</span>
    <span class="s2">const </span><span class="s1">lazyContext = React.useContext(LazyContext);</span>
    <span class="s2">const </span><span class="s1">presenceContext = React.useContext(PresenceContext);</span>
    <span class="s2">const </span><span class="s1">reducedMotionConfig = React.useContext(MotionConfigContext).reducedMotion;</span>
    <span class="s2">const </span><span class="s1">visualElementRef = React.useRef(</span><span class="s2">null</span><span class="s1">);</span>
    <span class="s3">/**</span>
     <span class="s3">* If we haven't preloaded a renderer, check to see if we have one lazy-loaded</span>
     <span class="s3">*/</span>
    <span class="s1">createVisualElement =</span>
        <span class="s1">createVisualElement ||</span>
            <span class="s1">lazyContext.renderer;</span>
    <span class="s2">if </span><span class="s1">(!visualElementRef.current &amp;&amp; createVisualElement) {</span>
        <span class="s1">visualElementRef.current = createVisualElement(Component, {</span>
            <span class="s1">visualState,</span>
            <span class="s1">parent,</span>
            <span class="s1">props,</span>
            <span class="s1">presenceContext,</span>
            <span class="s1">blockInitialAnimation: presenceContext</span>
                <span class="s1">? presenceContext.initial === </span><span class="s2">false</span>
                <span class="s1">: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">reducedMotionConfig,</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">visualElement = visualElementRef.current;</span>
    <span class="s3">/**</span>
     <span class="s3">* Load Motion gesture and animation features. These are rendered as renderless</span>
     <span class="s3">* components so each feature can optionally make use of React lifecycle methods.</span>
     <span class="s3">*/</span>
    <span class="s2">const </span><span class="s1">initialLayoutGroupConfig = React.useContext(SwitchLayoutGroupContext);</span>
    <span class="s2">if </span><span class="s1">(visualElement &amp;&amp;</span>
        <span class="s1">!visualElement.projection &amp;&amp;</span>
        <span class="s1">ProjectionNodeConstructor &amp;&amp;</span>
        <span class="s1">(visualElement.type === </span><span class="s0">&quot;html&quot; </span><span class="s1">|| visualElement.type === </span><span class="s0">&quot;svg&quot;</span><span class="s1">)) {</span>
        <span class="s1">createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">isMounted = React.useRef(</span><span class="s2">false</span><span class="s1">);</span>
    <span class="s1">React.useInsertionEffect(() =&gt; {</span>
        <span class="s3">/**</span>
         <span class="s3">* Check the component has already mounted before calling</span>
         <span class="s3">* `update` unnecessarily. This ensures we skip the initial update.</span>
         <span class="s3">*/</span>
        <span class="s2">if </span><span class="s1">(visualElement &amp;&amp; isMounted.current) {</span>
            <span class="s1">visualElement.update(props, presenceContext);</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s3">/**</span>
     <span class="s3">* Cache this value as we want to know whether HandoffAppearAnimations</span>
     <span class="s3">* was present on initial render - it will be deleted after this.</span>
     <span class="s3">*/</span>
    <span class="s2">const </span><span class="s1">optimisedAppearId = props[optimizedAppearDataAttribute];</span>
    <span class="s2">const </span><span class="s1">wantsHandoff = React.useRef(Boolean(optimisedAppearId) &amp;&amp;</span>
        <span class="s1">!window.MotionHandoffIsComplete?.(optimisedAppearId) &amp;&amp;</span>
        <span class="s1">window.MotionHasOptimisedAnimation?.(optimisedAppearId));</span>
    <span class="s1">useIsomorphicLayoutEffect(() =&gt; {</span>
        <span class="s2">if </span><span class="s1">(!visualElement)</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">isMounted.current = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">window.MotionIsMounted = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">visualElement.updateFeatures();</span>
        <span class="s1">visualElement.scheduleRenderMicrotask();</span>
        <span class="s3">/**</span>
         <span class="s3">* Ideally this function would always run in a useEffect.</span>
         <span class="s3">*</span>
         <span class="s3">* However, if we have optimised appear animations to handoff from,</span>
         <span class="s3">* it needs to happen synchronously to ensure there's no flash of</span>
         <span class="s3">* incorrect styles in the event of a hydration error.</span>
         <span class="s3">*</span>
         <span class="s3">* So if we detect a situtation where optimised appear animations</span>
         <span class="s3">* are running, we use useLayoutEffect to trigger animations.</span>
         <span class="s3">*/</span>
        <span class="s2">if </span><span class="s1">(wantsHandoff.current &amp;&amp; visualElement.animationState) {</span>
            <span class="s1">visualElement.animationState.animateChanges();</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s1">React.useEffect(() =&gt; {</span>
        <span class="s2">if </span><span class="s1">(!visualElement)</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(!wantsHandoff.current &amp;&amp; visualElement.animationState) {</span>
            <span class="s1">visualElement.animationState.animateChanges();</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(wantsHandoff.current) {</span>
            <span class="s3">// This ensures all future calls to animateChanges() in this component will run in useEffect</span>
            <span class="s1">queueMicrotask(() =&gt; {</span>
                <span class="s1">window.MotionHandoffMarkAsComplete?.(optimisedAppearId);</span>
            <span class="s1">});</span>
            <span class="s1">wantsHandoff.current = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">/**</span>
         <span class="s3">* Now we've finished triggering animations for this element we</span>
         <span class="s3">* can wipe the enteringChildren set for the next render.</span>
         <span class="s3">*/</span>
        <span class="s1">visualElement.enteringChildren = undefined;</span>
    <span class="s1">});</span>
    <span class="s2">return </span><span class="s1">visualElement;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {</span>
    <span class="s2">const </span><span class="s1">{ layoutId, layout, drag, dragConstraints, layoutScroll, layoutRoot, layoutCrossfade, } = props;</span>
    <span class="s1">visualElement.projection = </span><span class="s2">new </span><span class="s1">ProjectionNodeConstructor(visualElement.latestValues, props[</span><span class="s0">&quot;data-framer-portal-id&quot;</span><span class="s1">]</span>
        <span class="s1">? undefined</span>
        <span class="s1">: getClosestProjectingNode(visualElement.parent));</span>
    <span class="s1">visualElement.projection.setOptions({</span>
        <span class="s1">layoutId,</span>
        <span class="s1">layout,</span>
        <span class="s1">alwaysMeasureLayout: Boolean(drag) || (dragConstraints &amp;&amp; isRefObject(dragConstraints)),</span>
        <span class="s1">visualElement,</span>
        <span class="s3">/**</span>
         <span class="s3">* TODO: Update options in an effect. This could be tricky as it'll be too late</span>
         <span class="s3">* to update by the time layout animations run.</span>
         <span class="s3">* We also need to fix this safeToRemove by linking it up to the one returned by usePresence,</span>
         <span class="s3">* ensuring it gets called if there's no potential layout animations.</span>
         <span class="s3">*</span>
         <span class="s3">*/</span>
        <span class="s1">animationType: </span><span class="s2">typeof </span><span class="s1">layout === </span><span class="s0">&quot;string&quot; </span><span class="s1">? layout : </span><span class="s0">&quot;both&quot;</span><span class="s1">,</span>
        <span class="s1">initialPromotionConfig,</span>
        <span class="s1">crossfade: layoutCrossfade,</span>
        <span class="s1">layoutScroll,</span>
        <span class="s1">layoutRoot,</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getClosestProjectingNode(visualElement) {</span>
    <span class="s2">if </span><span class="s1">(!visualElement)</span>
        <span class="s2">return </span><span class="s1">undefined;</span>
    <span class="s2">return </span><span class="s1">visualElement.options.allowProjection !== </span><span class="s2">false</span>
        <span class="s1">? visualElement.projection</span>
        <span class="s1">: getClosestProjectingNode(visualElement.parent);</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Create a `motion` component.</span>
 <span class="s3">*</span>
 <span class="s3">* This function accepts a Component argument, which can be either a string (ie &quot;div&quot;</span>
 <span class="s3">* for `motion.div`), or an actual React component.</span>
 <span class="s3">*</span>
 <span class="s3">* Alongside this is a config option which provides a way of rendering the provided</span>
 <span class="s3">* component &quot;offline&quot;, or outside the React render cycle.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">createMotionComponent(Component, { forwardMotionProps = </span><span class="s2">false </span><span class="s1">} = {}, preloadedFeatures, createVisualElement) {</span>
    <span class="s1">preloadedFeatures &amp;&amp; loadFeatures(preloadedFeatures);</span>
    <span class="s2">const </span><span class="s1">useVisualState = isSVGComponent(Component)</span>
        <span class="s1">? useSVGVisualState</span>
        <span class="s1">: useHTMLVisualState;</span>
    <span class="s2">function </span><span class="s1">MotionDOMComponent(props, externalRef) {</span>
        <span class="s3">/**</span>
         <span class="s3">* If we need to measure the element we load this functionality in a</span>
         <span class="s3">* separate class component in order to gain access to getSnapshotBeforeUpdate.</span>
         <span class="s3">*/</span>
        <span class="s2">let </span><span class="s1">MeasureLayout;</span>
        <span class="s2">const </span><span class="s1">configAndProps = {</span>
            <span class="s1">...React.useContext(MotionConfigContext),</span>
            <span class="s1">...props,</span>
            <span class="s1">layoutId: useLayoutId(props),</span>
        <span class="s1">};</span>
        <span class="s2">const </span><span class="s1">{ isStatic } = configAndProps;</span>
        <span class="s2">const </span><span class="s1">context = useCreateMotionContext(props);</span>
        <span class="s2">const </span><span class="s1">visualState = useVisualState(props, isStatic);</span>
        <span class="s2">if </span><span class="s1">(!isStatic &amp;&amp; isBrowser) {</span>
            <span class="s1">useStrictMode(configAndProps, preloadedFeatures);</span>
            <span class="s2">const </span><span class="s1">layoutProjection = getProjectionFunctionality(configAndProps);</span>
            <span class="s1">MeasureLayout = layoutProjection.MeasureLayout;</span>
            <span class="s3">/**</span>
             <span class="s3">* Create a VisualElement for this component. A VisualElement provides a common</span>
             <span class="s3">* interface to renderer-specific APIs (ie DOM/Three.js etc) as well as</span>
             <span class="s3">* providing a way of rendering to these APIs outside of the React render loop</span>
             <span class="s3">* for more performant animations and interactions</span>
             <span class="s3">*/</span>
            <span class="s1">context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);</span>
        <span class="s1">}</span>
        <span class="s3">/**</span>
         <span class="s3">* The mount order and hierarchy is specific to ensure our element ref</span>
         <span class="s3">* is hydrated by the time features fire their effects.</span>
         <span class="s3">*/</span>
        <span class="s2">return </span><span class="s1">(jsxRuntime.jsxs(MotionContext.Provider, { value: context, children: [MeasureLayout &amp;&amp; context.visualElement ? (jsxRuntime.jsx(MeasureLayout, { visualElement: context.visualElement, ...configAndProps })) : </span><span class="s2">null</span><span class="s1">, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, forwardMotionProps)] }));</span>
    <span class="s1">}</span>
    <span class="s1">MotionDOMComponent.displayName = </span><span class="s0">`motion.</span><span class="s1">${</span><span class="s2">typeof </span><span class="s1">Component === </span><span class="s0">&quot;string&quot;</span>
        <span class="s1">? Component</span>
        <span class="s1">: </span><span class="s0">`create(</span><span class="s1">${Component.displayName ?? Component.name ?? </span><span class="s0">&quot;&quot;</span><span class="s1">}</span><span class="s0">)`</span><span class="s1">}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">ForwardRefMotionComponent = React.forwardRef(MotionDOMComponent);</span>
    <span class="s1">ForwardRefMotionComponent[motionComponentSymbol] = Component;</span>
    <span class="s2">return </span><span class="s1">ForwardRefMotionComponent;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">useLayoutId({ layoutId }) {</span>
    <span class="s2">const </span><span class="s1">layoutGroupId = React.useContext(LayoutGroupContext).id;</span>
    <span class="s2">return </span><span class="s1">layoutGroupId &amp;&amp; layoutId !== undefined</span>
        <span class="s1">? layoutGroupId + </span><span class="s0">&quot;-&quot; </span><span class="s1">+ layoutId</span>
        <span class="s1">: layoutId;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">useStrictMode(configAndProps, preloadedFeatures) {</span>
    <span class="s2">const </span><span class="s1">isStrict = React.useContext(LazyContext).strict;</span>
    <span class="s3">/**</span>
     <span class="s3">* If we're in development mode, check to make sure we're not rendering a motion component</span>
     <span class="s3">* as a child of LazyMotion, as this will break the file-size benefits of using it.</span>
     <span class="s3">*/</span>
    <span class="s2">if </span><span class="s1">(process.env.NODE_ENV !== </span><span class="s0">&quot;production&quot; </span><span class="s1">&amp;&amp;</span>
        <span class="s1">preloadedFeatures &amp;&amp;</span>
        <span class="s1">isStrict) {</span>
        <span class="s2">const </span><span class="s1">strictMessage = </span><span class="s0">&quot;You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.&quot;</span><span class="s1">;</span>
        <span class="s1">configAndProps.ignoreStrict</span>
            <span class="s1">? motionUtils.warning(</span><span class="s2">false</span><span class="s1">, strictMessage, </span><span class="s0">&quot;lazy-strict-mode&quot;</span><span class="s1">)</span>
            <span class="s1">: motionUtils.invariant(</span><span class="s2">false</span><span class="s1">, strictMessage, </span><span class="s0">&quot;lazy-strict-mode&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getProjectionFunctionality(props) {</span>
    <span class="s2">const </span><span class="s1">{ drag, layout } = featureDefinitions;</span>
    <span class="s2">if </span><span class="s1">(!drag &amp;&amp; !layout)</span>
        <span class="s2">return </span><span class="s1">{};</span>
    <span class="s2">const </span><span class="s1">combined = { ...drag, ...layout };</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">MeasureLayout: drag?.isEnabled(props) || layout?.isEnabled(props)</span>
            <span class="s1">? combined.MeasureLayout</span>
            <span class="s1">: undefined,</span>
        <span class="s1">ProjectionNode: combined.ProjectionNode,</span>
    <span class="s1">};</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">resolveVariant(visualElement, definition, custom) {</span>
    <span class="s2">const </span><span class="s1">props = visualElement.getProps();</span>
    <span class="s2">return </span><span class="s1">resolveVariantFromProps(props, definition, custom !== undefined ? custom : props.custom, visualElement);</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">isKeyframesTarget = (v) =&gt; {</span>
    <span class="s2">return </span><span class="s1">Array.isArray(v);</span>
<span class="s1">};</span>

<span class="s3">/**</span>
 <span class="s3">* Set VisualElement's MotionValue, creating a new MotionValue for it if</span>
 <span class="s3">* it doesn't exist.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">setMotionValue(visualElement, key, value) {</span>
    <span class="s2">if </span><span class="s1">(visualElement.hasValue(key)) {</span>
        <span class="s1">visualElement.getValue(key).set(value);</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s1">visualElement.addValue(key, motionDom.motionValue(value));</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">resolveFinalValueInKeyframes(v) {</span>
    <span class="s3">// TODO maybe throw if v.length - 1 is placeholder token?</span>
    <span class="s2">return </span><span class="s1">isKeyframesTarget(v) ? v[v.length - </span><span class="s5">1</span><span class="s1">] || </span><span class="s5">0 </span><span class="s1">: v;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">setTarget(visualElement, definition) {</span>
    <span class="s2">const </span><span class="s1">resolved = resolveVariant(visualElement, definition);</span>
    <span class="s2">let </span><span class="s1">{ transitionEnd = {}, transition = {}, ...target } = resolved || {};</span>
    <span class="s1">target = { ...target, ...transitionEnd };</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">target) {</span>
        <span class="s2">const </span><span class="s1">value = resolveFinalValueInKeyframes(target[key]);</span>
        <span class="s1">setMotionValue(visualElement, key, value);</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">isWillChangeMotionValue(value) {</span>
    <span class="s2">return </span><span class="s1">Boolean(motionDom.isMotionValue(value) &amp;&amp; value.add);</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">addValueToWillChange(visualElement, key) {</span>
    <span class="s2">const </span><span class="s1">willChange = visualElement.getValue(</span><span class="s0">&quot;willChange&quot;</span><span class="s1">);</span>
    <span class="s3">/**</span>
     <span class="s3">* It could be that a user has set willChange to a regular MotionValue,</span>
     <span class="s3">* in which case we can't add the value to it.</span>
     <span class="s3">*/</span>
    <span class="s2">if </span><span class="s1">(isWillChangeMotionValue(willChange)) {</span>
        <span class="s2">return </span><span class="s1">willChange.add(key);</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(!willChange &amp;&amp; motionUtils.MotionGlobalConfig.WillChange) {</span>
        <span class="s2">const </span><span class="s1">newWillChange = </span><span class="s2">new </span><span class="s1">motionUtils.MotionGlobalConfig.WillChange(</span><span class="s0">&quot;auto&quot;</span><span class="s1">);</span>
        <span class="s1">visualElement.addValue(</span><span class="s0">&quot;willChange&quot;</span><span class="s1">, newWillChange);</span>
        <span class="s1">newWillChange.add(key);</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Decide whether we should block this animation. Previously, we achieved this</span>
 <span class="s3">* just by checking whether the key was listed in protectedKeys, but this</span>
 <span class="s3">* posed problems if an animation was triggered by afterChildren and protectedKeys</span>
 <span class="s3">* had been set to true in the meantime.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {</span>
    <span class="s2">const </span><span class="s1">shouldBlock = protectedKeys.hasOwnProperty(key) &amp;&amp; needsAnimating[key] !== </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">needsAnimating[key] = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">shouldBlock;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">animateTarget(visualElement, targetAndTransition, { delay = </span><span class="s5">0</span><span class="s1">, transitionOverride, type } = {}) {</span>
    <span class="s2">let </span><span class="s1">{ transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;</span>
    <span class="s2">if </span><span class="s1">(transitionOverride)</span>
        <span class="s1">transition = transitionOverride;</span>
    <span class="s2">const </span><span class="s1">animations = [];</span>
    <span class="s2">const </span><span class="s1">animationTypeState = type &amp;&amp;</span>
        <span class="s1">visualElement.animationState &amp;&amp;</span>
        <span class="s1">visualElement.animationState.getState()[type];</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">target) {</span>
        <span class="s2">const </span><span class="s1">value = visualElement.getValue(key, visualElement.latestValues[key] ?? </span><span class="s2">null</span><span class="s1">);</span>
        <span class="s2">const </span><span class="s1">valueTarget = target[key];</span>
        <span class="s2">if </span><span class="s1">(valueTarget === undefined ||</span>
            <span class="s1">(animationTypeState &amp;&amp;</span>
                <span class="s1">shouldBlockAnimation(animationTypeState, key))) {</span>
            <span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">valueTransition = {</span>
            <span class="s1">delay,</span>
            <span class="s1">...motionDom.getValueTransition(transition || {}, key),</span>
        <span class="s1">};</span>
        <span class="s3">/**</span>
         <span class="s3">* If the value is already at the defined target, skip the animation.</span>
         <span class="s3">*/</span>
        <span class="s2">const </span><span class="s1">currentValue = value.get();</span>
        <span class="s2">if </span><span class="s1">(currentValue !== undefined &amp;&amp;</span>
            <span class="s1">!value.isAnimating &amp;&amp;</span>
            <span class="s1">!Array.isArray(valueTarget) &amp;&amp;</span>
            <span class="s1">valueTarget === currentValue &amp;&amp;</span>
            <span class="s1">!valueTransition.velocity) {</span>
            <span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">/**</span>
         <span class="s3">* If this is the first time a value is being animated, check</span>
         <span class="s3">* to see if we're handling off from an existing animation.</span>
         <span class="s3">*/</span>
        <span class="s2">let </span><span class="s1">isHandoff = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(window.MotionHandoffAnimation) {</span>
            <span class="s2">const </span><span class="s1">appearId = getOptimisedAppearId(visualElement);</span>
            <span class="s2">if </span><span class="s1">(appearId) {</span>
                <span class="s2">const </span><span class="s1">startTime = window.MotionHandoffAnimation(appearId, key, motionDom.frame);</span>
                <span class="s2">if </span><span class="s1">(startTime !== </span><span class="s2">null</span><span class="s1">) {</span>
                    <span class="s1">valueTransition.startTime = startTime;</span>
                    <span class="s1">isHandoff = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">addValueToWillChange(visualElement, key);</span>
        <span class="s1">value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion &amp;&amp; motionDom.positionalKeys.has(key)</span>
            <span class="s1">? { type: </span><span class="s2">false </span><span class="s1">}</span>
            <span class="s1">: valueTransition, visualElement, isHandoff));</span>
        <span class="s2">const </span><span class="s1">animation = value.animation;</span>
        <span class="s2">if </span><span class="s1">(animation) {</span>
            <span class="s1">animations.push(animation);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(transitionEnd) {</span>
        <span class="s1">Promise.all(animations).then(() =&gt; {</span>
            <span class="s1">motionDom.frame.update(() =&gt; {</span>
                <span class="s1">transitionEnd &amp;&amp; setTarget(visualElement, transitionEnd);</span>
            <span class="s1">});</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">animations;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">calcChildStagger(children, child, delayChildren, staggerChildren = </span><span class="s5">0</span><span class="s1">, staggerDirection = </span><span class="s5">1</span><span class="s1">) {</span>
    <span class="s2">const </span><span class="s1">index = Array.from(children)</span>
        <span class="s1">.sort((a, b) =&gt; a.sortNodePosition(b))</span>
        <span class="s1">.indexOf(child);</span>
    <span class="s2">const </span><span class="s1">numChildren = children.size;</span>
    <span class="s2">const </span><span class="s1">maxStaggerDuration = (numChildren - </span><span class="s5">1</span><span class="s1">) * staggerChildren;</span>
    <span class="s2">const </span><span class="s1">delayIsFunction = </span><span class="s2">typeof </span><span class="s1">delayChildren === </span><span class="s0">&quot;function&quot;</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">delayIsFunction</span>
        <span class="s1">? delayChildren(index, numChildren)</span>
        <span class="s1">: staggerDirection === </span><span class="s5">1</span>
            <span class="s1">? index * staggerChildren</span>
            <span class="s1">: maxStaggerDuration - index * staggerChildren;</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">animateVariant(visualElement, variant, options = {}) {</span>
    <span class="s2">const </span><span class="s1">resolved = resolveVariant(visualElement, variant, options.type === </span><span class="s0">&quot;exit&quot;</span>
        <span class="s1">? visualElement.presenceContext?.custom</span>
        <span class="s1">: undefined);</span>
    <span class="s2">let </span><span class="s1">{ transition = visualElement.getDefaultTransition() || {} } = resolved || {};</span>
    <span class="s2">if </span><span class="s1">(options.transitionOverride) {</span>
        <span class="s1">transition = options.transitionOverride;</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* If we have a variant, create a callback that runs it as an animation.</span>
     <span class="s3">* Otherwise, we resolve a Promise immediately for a composable no-op.</span>
     <span class="s3">*/</span>
    <span class="s2">const </span><span class="s1">getAnimation = resolved</span>
        <span class="s1">? () =&gt; Promise.all(animateTarget(visualElement, resolved, options))</span>
        <span class="s1">: () =&gt; Promise.resolve();</span>
    <span class="s3">/**</span>
     <span class="s3">* If we have children, create a callback that runs all their animations.</span>
     <span class="s3">* Otherwise, we resolve a Promise immediately for a composable no-op.</span>
     <span class="s3">*/</span>
    <span class="s2">const </span><span class="s1">getChildAnimations = visualElement.variantChildren &amp;&amp; visualElement.variantChildren.size</span>
        <span class="s1">? (forwardDelay = </span><span class="s5">0</span><span class="s1">) =&gt; {</span>
            <span class="s2">const </span><span class="s1">{ delayChildren = </span><span class="s5">0</span><span class="s1">, staggerChildren, staggerDirection, } = transition;</span>
            <span class="s2">return </span><span class="s1">animateChildren(visualElement, variant, forwardDelay, delayChildren, staggerChildren, staggerDirection, options);</span>
        <span class="s1">}</span>
        <span class="s1">: () =&gt; Promise.resolve();</span>
    <span class="s3">/**</span>
     <span class="s3">* If the transition explicitly defines a &quot;when&quot; option, we need to resolve either</span>
     <span class="s3">* this animation or all children animations before playing the other.</span>
     <span class="s3">*/</span>
    <span class="s2">const </span><span class="s1">{ when } = transition;</span>
    <span class="s2">if </span><span class="s1">(when) {</span>
        <span class="s2">const </span><span class="s1">[first, last] = when === </span><span class="s0">&quot;beforeChildren&quot;</span>
            <span class="s1">? [getAnimation, getChildAnimations]</span>
            <span class="s1">: [getChildAnimations, getAnimation];</span>
        <span class="s2">return </span><span class="s1">first().then(() =&gt; last());</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s2">return </span><span class="s1">Promise.all([getAnimation(), getChildAnimations(options.delay)]);</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">animateChildren(visualElement, variant, delay = </span><span class="s5">0</span><span class="s1">, delayChildren = </span><span class="s5">0</span><span class="s1">, staggerChildren = </span><span class="s5">0</span><span class="s1">, staggerDirection = </span><span class="s5">1</span><span class="s1">, options) {</span>
    <span class="s2">const </span><span class="s1">animations = [];</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">child of visualElement.variantChildren) {</span>
        <span class="s1">child.notify(</span><span class="s0">&quot;AnimationStart&quot;</span><span class="s1">, variant);</span>
        <span class="s1">animations.push(animateVariant(child, variant, {</span>
            <span class="s1">...options,</span>
            <span class="s1">delay: delay +</span>
                <span class="s1">(</span><span class="s2">typeof </span><span class="s1">delayChildren === </span><span class="s0">&quot;function&quot; </span><span class="s1">? </span><span class="s5">0 </span><span class="s1">: delayChildren) +</span>
                <span class="s1">calcChildStagger(visualElement.variantChildren, child, delayChildren, staggerChildren, staggerDirection),</span>
        <span class="s1">}).then(() =&gt; child.notify(</span><span class="s0">&quot;AnimationComplete&quot;</span><span class="s1">, variant)));</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">Promise.all(animations);</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">animateVisualElement(visualElement, definition, options = {}) {</span>
    <span class="s1">visualElement.notify(</span><span class="s0">&quot;AnimationStart&quot;</span><span class="s1">, definition);</span>
    <span class="s2">let </span><span class="s1">animation;</span>
    <span class="s2">if </span><span class="s1">(Array.isArray(definition)) {</span>
        <span class="s2">const </span><span class="s1">animations = definition.map((variant) =&gt; animateVariant(visualElement, variant, options));</span>
        <span class="s1">animation = Promise.all(animations);</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">definition === </span><span class="s0">&quot;string&quot;</span><span class="s1">) {</span>
        <span class="s1">animation = animateVariant(visualElement, definition, options);</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s2">const </span><span class="s1">resolvedDefinition = </span><span class="s2">typeof </span><span class="s1">definition === </span><span class="s0">&quot;function&quot;</span>
            <span class="s1">? resolveVariant(visualElement, definition, options.custom)</span>
            <span class="s1">: definition;</span>
        <span class="s1">animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">animation.then(() =&gt; {</span>
        <span class="s1">visualElement.notify(</span><span class="s0">&quot;AnimationComplete&quot;</span><span class="s1">, definition);</span>
    <span class="s1">});</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">shallowCompare(next, prev) {</span>
    <span class="s2">if </span><span class="s1">(!Array.isArray(prev))</span>
        <span class="s2">return false</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">prevLength = prev.length;</span>
    <span class="s2">if </span><span class="s1">(prevLength !== next.length)</span>
        <span class="s2">return false</span><span class="s1">;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; prevLength; i++) {</span>
        <span class="s2">if </span><span class="s1">(prev[i] !== next[i])</span>
            <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return true</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">numVariantProps = variantProps.length;</span>
<span class="s2">function </span><span class="s1">getVariantContext(visualElement) {</span>
    <span class="s2">if </span><span class="s1">(!visualElement)</span>
        <span class="s2">return </span><span class="s1">undefined;</span>
    <span class="s2">if </span><span class="s1">(!visualElement.isControllingVariants) {</span>
        <span class="s2">const </span><span class="s1">context = visualElement.parent</span>
            <span class="s1">? getVariantContext(visualElement.parent) || {}</span>
            <span class="s1">: {};</span>
        <span class="s2">if </span><span class="s1">(visualElement.props.initial !== undefined) {</span>
            <span class="s1">context.initial = visualElement.props.initial;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">context;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">context = {};</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; numVariantProps; i++) {</span>
        <span class="s2">const </span><span class="s1">name = variantProps[i];</span>
        <span class="s2">const </span><span class="s1">prop = visualElement.props[name];</span>
        <span class="s2">if </span><span class="s1">(isVariantLabel(prop) || prop === </span><span class="s2">false</span><span class="s1">) {</span>
            <span class="s1">context[name] = prop;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">context;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">reversePriorityOrder = [...variantPriorityOrder].reverse();</span>
<span class="s2">const </span><span class="s1">numAnimationTypes = variantPriorityOrder.length;</span>
<span class="s2">function </span><span class="s1">animateList(visualElement) {</span>
    <span class="s2">return </span><span class="s1">(animations) =&gt; Promise.all(animations.map(({ animation, options }) =&gt; animateVisualElement(visualElement, animation, options)));</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createAnimationState(visualElement) {</span>
    <span class="s2">let </span><span class="s1">animate = animateList(visualElement);</span>
    <span class="s2">let </span><span class="s1">state = createState();</span>
    <span class="s2">let </span><span class="s1">isInitialRender = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* This function will be used to reduce the animation definitions for</span>
     <span class="s3">* each active animation type into an object of resolved values for it.</span>
     <span class="s3">*/</span>
    <span class="s2">const </span><span class="s1">buildResolvedTypeValues = (type) =&gt; (acc, definition) =&gt; {</span>
        <span class="s2">const </span><span class="s1">resolved = resolveVariant(visualElement, definition, type === </span><span class="s0">&quot;exit&quot;</span>
            <span class="s1">? visualElement.presenceContext?.custom</span>
            <span class="s1">: undefined);</span>
        <span class="s2">if </span><span class="s1">(resolved) {</span>
            <span class="s2">const </span><span class="s1">{ transition, transitionEnd, ...target } = resolved;</span>
            <span class="s1">acc = { ...acc, ...target, ...transitionEnd };</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">acc;</span>
    <span class="s1">};</span>
    <span class="s3">/**</span>
     <span class="s3">* This just allows us to inject mocked animation functions</span>
     <span class="s3">* </span><span class="s4">@internal</span>
     <span class="s3">*/</span>
    <span class="s2">function </span><span class="s1">setAnimateFunction(makeAnimator) {</span>
        <span class="s1">animate = makeAnimator(visualElement);</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* When we receive new props, we need to:</span>
     <span class="s3">* 1. Create a list of protected keys for each type. This is a directory of</span>
     <span class="s3">*    value keys that are currently being &quot;handled&quot; by types of a higher priority</span>
     <span class="s3">*    so that whenever an animation is played of a given type, these values are</span>
     <span class="s3">*    protected from being animated.</span>
     <span class="s3">* 2. Determine if an animation type needs animating.</span>
     <span class="s3">* 3. Determine if any values have been removed from a type and figure out</span>
     <span class="s3">*    what to animate those to.</span>
     <span class="s3">*/</span>
    <span class="s2">function </span><span class="s1">animateChanges(changedActiveType) {</span>
        <span class="s2">const </span><span class="s1">{ props } = visualElement;</span>
        <span class="s2">const </span><span class="s1">context = getVariantContext(visualElement.parent) || {};</span>
        <span class="s3">/**</span>
         <span class="s3">* A list of animations that we'll build into as we iterate through the animation</span>
         <span class="s3">* types. This will get executed at the end of the function.</span>
         <span class="s3">*/</span>
        <span class="s2">const </span><span class="s1">animations = [];</span>
        <span class="s3">/**</span>
         <span class="s3">* Keep track of which values have been removed. Then, as we hit lower priority</span>
         <span class="s3">* animation types, we can check if they contain removed values and animate to that.</span>
         <span class="s3">*/</span>
        <span class="s2">const </span><span class="s1">removedKeys = </span><span class="s2">new </span><span class="s1">Set();</span>
        <span class="s3">/**</span>
         <span class="s3">* A dictionary of all encountered keys. This is an object to let us build into and</span>
         <span class="s3">* copy it without iteration. Each time we hit an animation type we set its protected</span>
         <span class="s3">* keys - the keys its not allowed to animate - to the latest version of this object.</span>
         <span class="s3">*/</span>
        <span class="s2">let </span><span class="s1">encounteredKeys = {};</span>
        <span class="s3">/**</span>
         <span class="s3">* If a variant has been removed at a given index, and this component is controlling</span>
         <span class="s3">* variant animations, we want to ensure lower-priority variants are forced to animate.</span>
         <span class="s3">*/</span>
        <span class="s2">let </span><span class="s1">removedVariantIndex = Infinity;</span>
        <span class="s3">/**</span>
         <span class="s3">* Iterate through all animation types in reverse priority order. For each, we want to</span>
         <span class="s3">* detect which values it's handling and whether or not they've changed (and therefore</span>
         <span class="s3">* need to be animated). If any values have been removed, we want to detect those in</span>
         <span class="s3">* lower priority props and flag for animation.</span>
         <span class="s3">*/</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; numAnimationTypes; i++) {</span>
            <span class="s2">const </span><span class="s1">type = reversePriorityOrder[i];</span>
            <span class="s2">const </span><span class="s1">typeState = state[type];</span>
            <span class="s2">const </span><span class="s1">prop = props[type] !== undefined</span>
                <span class="s1">? props[type]</span>
                <span class="s1">: context[type];</span>
            <span class="s2">const </span><span class="s1">propIsVariant = isVariantLabel(prop);</span>
            <span class="s3">/**</span>
             <span class="s3">* If this type has *just* changed isActive status, set activeDelta</span>
             <span class="s3">* to that status. Otherwise set to null.</span>
             <span class="s3">*/</span>
            <span class="s2">const </span><span class="s1">activeDelta = type === changedActiveType ? typeState.isActive : </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(activeDelta === </span><span class="s2">false</span><span class="s1">)</span>
                <span class="s1">removedVariantIndex = i;</span>
            <span class="s3">/**</span>
             <span class="s3">* If this prop is an inherited variant, rather than been set directly on the</span>
             <span class="s3">* component itself, we want to make sure we allow the parent to trigger animations.</span>
             <span class="s3">*</span>
             <span class="s3">* TODO: Can probably change this to a !isControllingVariants check</span>
             <span class="s3">*/</span>
            <span class="s2">let </span><span class="s1">isInherited = prop === context[type] &amp;&amp;</span>
                <span class="s1">prop !== props[type] &amp;&amp;</span>
                <span class="s1">propIsVariant;</span>
            <span class="s2">if </span><span class="s1">(isInherited &amp;&amp;</span>
                <span class="s1">isInitialRender &amp;&amp;</span>
                <span class="s1">visualElement.manuallyAnimateOnMount) {</span>
                <span class="s1">isInherited = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">/**</span>
             <span class="s3">* Set all encountered keys so far as the protected keys for this type. This will</span>
             <span class="s3">* be any key that has been animated or otherwise handled by active, higher-priortiy types.</span>
             <span class="s3">*/</span>
            <span class="s1">typeState.protectedKeys = { ...encounteredKeys };</span>
            <span class="s3">// Check if we can skip analysing this prop early</span>
            <span class="s2">if </span><span class="s1">(</span>
            <span class="s3">// If it isn't active and hasn't *just* been set as inactive</span>
            <span class="s1">(!typeState.isActive &amp;&amp; activeDelta === </span><span class="s2">null</span><span class="s1">) ||</span>
                <span class="s3">// If we didn't and don't have any defined prop for this animation type</span>
                <span class="s1">(!prop &amp;&amp; !typeState.prevProp) ||</span>
                <span class="s3">// Or if the prop doesn't define an animation</span>
                <span class="s1">isAnimationControls(prop) ||</span>
                <span class="s2">typeof </span><span class="s1">prop === </span><span class="s0">&quot;boolean&quot;</span><span class="s1">) {</span>
                <span class="s2">continue</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">/**</span>
             <span class="s3">* As we go look through the values defined on this type, if we detect</span>
             <span class="s3">* a changed value or a value that was removed in a higher priority, we set</span>
             <span class="s3">* this to true and add this prop to the animation list.</span>
             <span class="s3">*/</span>
            <span class="s2">const </span><span class="s1">variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);</span>
            <span class="s2">let </span><span class="s1">shouldAnimateType = variantDidChange ||</span>
                <span class="s3">// If we're making this variant active, we want to always make it active</span>
                <span class="s1">(type === changedActiveType &amp;&amp;</span>
                    <span class="s1">typeState.isActive &amp;&amp;</span>
                    <span class="s1">!isInherited &amp;&amp;</span>
                    <span class="s1">propIsVariant) ||</span>
                <span class="s3">// If we removed a higher-priority variant (i is in reverse order)</span>
                <span class="s1">(i &gt; removedVariantIndex &amp;&amp; propIsVariant);</span>
            <span class="s2">let </span><span class="s1">handledRemovedValues = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s3">/**</span>
             <span class="s3">* As animations can be set as variant lists, variants or target objects, we</span>
             <span class="s3">* coerce everything to an array if it isn't one already</span>
             <span class="s3">*/</span>
            <span class="s2">const </span><span class="s1">definitionList = Array.isArray(prop) ? prop : [prop];</span>
            <span class="s3">/**</span>
             <span class="s3">* Build an object of all the resolved values. We'll use this in the subsequent</span>
             <span class="s3">* animateChanges calls to determine whether a value has changed.</span>
             <span class="s3">*/</span>
            <span class="s2">let </span><span class="s1">resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});</span>
            <span class="s2">if </span><span class="s1">(activeDelta === </span><span class="s2">false</span><span class="s1">)</span>
                <span class="s1">resolvedValues = {};</span>
            <span class="s3">/**</span>
             <span class="s3">* Now we need to loop through all the keys in the prev prop and this prop,</span>
             <span class="s3">* and decide:</span>
             <span class="s3">* 1. If the value has changed, and needs animating</span>
             <span class="s3">* 2. If it has been removed, and needs adding to the removedKeys set</span>
             <span class="s3">* 3. If it has been removed in a higher priority type and needs animating</span>
             <span class="s3">* 4. If it hasn't been removed in a higher priority but hasn't changed, and</span>
             <span class="s3">*    needs adding to the type's protectedKeys list.</span>
             <span class="s3">*/</span>
            <span class="s2">const </span><span class="s1">{ prevResolvedValues = {} } = typeState;</span>
            <span class="s2">const </span><span class="s1">allKeys = {</span>
                <span class="s1">...prevResolvedValues,</span>
                <span class="s1">...resolvedValues,</span>
            <span class="s1">};</span>
            <span class="s2">const </span><span class="s1">markToAnimate = (key) =&gt; {</span>
                <span class="s1">shouldAnimateType = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s2">if </span><span class="s1">(removedKeys.has(key)) {</span>
                    <span class="s1">handledRemovedValues = </span><span class="s2">true</span><span class="s1">;</span>
                    <span class="s1">removedKeys.delete(key);</span>
                <span class="s1">}</span>
                <span class="s1">typeState.needsAnimating[key] = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s2">const </span><span class="s1">motionValue = visualElement.getValue(key);</span>
                <span class="s2">if </span><span class="s1">(motionValue)</span>
                    <span class="s1">motionValue.liveStyle = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s1">};</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">allKeys) {</span>
                <span class="s2">const </span><span class="s1">next = resolvedValues[key];</span>
                <span class="s2">const </span><span class="s1">prev = prevResolvedValues[key];</span>
                <span class="s3">// If we've already handled this we can just skip ahead</span>
                <span class="s2">if </span><span class="s1">(encounteredKeys.hasOwnProperty(key))</span>
                    <span class="s2">continue</span><span class="s1">;</span>
                <span class="s3">/**</span>
                 <span class="s3">* If the value has changed, we probably want to animate it.</span>
                 <span class="s3">*/</span>
                <span class="s2">let </span><span class="s1">valueHasChanged = </span><span class="s2">false</span><span class="s1">;</span>
                <span class="s2">if </span><span class="s1">(isKeyframesTarget(next) &amp;&amp; isKeyframesTarget(prev)) {</span>
                    <span class="s1">valueHasChanged = !shallowCompare(next, prev);</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">valueHasChanged = next !== prev;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(valueHasChanged) {</span>
                    <span class="s2">if </span><span class="s1">(next !== undefined &amp;&amp; next !== </span><span class="s2">null</span><span class="s1">) {</span>
                        <span class="s3">// If next is defined and doesn't equal prev, it needs animating</span>
                        <span class="s1">markToAnimate(key);</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s3">// If it's undefined, it's been removed.</span>
                        <span class="s1">removedKeys.add(key);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(next !== undefined &amp;&amp; removedKeys.has(key)) {</span>
                    <span class="s3">/**</span>
                     <span class="s3">* If next hasn't changed and it isn't undefined, we want to check if it's</span>
                     <span class="s3">* been removed by a higher priority</span>
                     <span class="s3">*/</span>
                    <span class="s1">markToAnimate(key);</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s3">/**</span>
                     <span class="s3">* If it hasn't changed, we add it to the list of protected values</span>
                     <span class="s3">* to ensure it doesn't get animated.</span>
                     <span class="s3">*/</span>
                    <span class="s1">typeState.protectedKeys[key] = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">/**</span>
             <span class="s3">* Update the typeState so next time animateChanges is called we can compare the</span>
             <span class="s3">* latest prop and resolvedValues to these.</span>
             <span class="s3">*/</span>
            <span class="s1">typeState.prevProp = prop;</span>
            <span class="s1">typeState.prevResolvedValues = resolvedValues;</span>
            <span class="s2">if </span><span class="s1">(typeState.isActive) {</span>
                <span class="s1">encounteredKeys = { ...encounteredKeys, ...resolvedValues };</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(isInitialRender &amp;&amp; visualElement.blockInitialAnimation) {</span>
                <span class="s1">shouldAnimateType = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">/**</span>
             <span class="s3">* If this is an inherited prop we want to skip this animation</span>
             <span class="s3">* unless the inherited variants haven't changed on this render.</span>
             <span class="s3">*/</span>
            <span class="s2">const </span><span class="s1">willAnimateViaParent = isInherited &amp;&amp; variantDidChange;</span>
            <span class="s2">const </span><span class="s1">needsAnimating = !willAnimateViaParent || handledRemovedValues;</span>
            <span class="s2">if </span><span class="s1">(shouldAnimateType &amp;&amp; needsAnimating) {</span>
                <span class="s1">animations.push(...definitionList.map((animation) =&gt; {</span>
                    <span class="s2">const </span><span class="s1">options = { type };</span>
                    <span class="s3">/**</span>
                     <span class="s3">* If we're performing the initial animation, but we're not</span>
                     <span class="s3">* rendering at the same time as the variant-controlling parent,</span>
                     <span class="s3">* we want to use the parent's transition to calculate the stagger.</span>
                     <span class="s3">*/</span>
                    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">animation === </span><span class="s0">&quot;string&quot; </span><span class="s1">&amp;&amp;</span>
                        <span class="s1">isInitialRender &amp;&amp;</span>
                        <span class="s1">!willAnimateViaParent &amp;&amp;</span>
                        <span class="s1">visualElement.manuallyAnimateOnMount &amp;&amp;</span>
                        <span class="s1">visualElement.parent) {</span>
                        <span class="s2">const </span><span class="s1">{ parent } = visualElement;</span>
                        <span class="s2">const </span><span class="s1">parentVariant = resolveVariant(parent, animation);</span>
                        <span class="s2">if </span><span class="s1">(parent.enteringChildren &amp;&amp; parentVariant) {</span>
                            <span class="s2">const </span><span class="s1">{ delayChildren } = parentVariant.transition || {};</span>
                            <span class="s1">options.delay = calcChildStagger(parent.enteringChildren, visualElement, delayChildren);</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                    <span class="s2">return </span><span class="s1">{</span>
                        <span class="s1">animation: animation,</span>
                        <span class="s1">options,</span>
                    <span class="s1">};</span>
                <span class="s1">}));</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">/**</span>
         <span class="s3">* If there are some removed value that haven't been dealt with,</span>
         <span class="s3">* we need to create a new animation that falls back either to the value</span>
         <span class="s3">* defined in the style prop, or the last read value.</span>
         <span class="s3">*/</span>
        <span class="s2">if </span><span class="s1">(removedKeys.size) {</span>
            <span class="s2">const </span><span class="s1">fallbackAnimation = {};</span>
            <span class="s3">/**</span>
             <span class="s3">* If the initial prop contains a transition we can use that, otherwise</span>
             <span class="s3">* allow the animation function to use the visual element's default.</span>
             <span class="s3">*/</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">props.initial !== </span><span class="s0">&quot;boolean&quot;</span><span class="s1">) {</span>
                <span class="s2">const </span><span class="s1">initialTransition = resolveVariant(visualElement, Array.isArray(props.initial)</span>
                    <span class="s1">? props.initial[</span><span class="s5">0</span><span class="s1">]</span>
                    <span class="s1">: props.initial);</span>
                <span class="s2">if </span><span class="s1">(initialTransition &amp;&amp; initialTransition.transition) {</span>
                    <span class="s1">fallbackAnimation.transition = initialTransition.transition;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">removedKeys.forEach((key) =&gt; {</span>
                <span class="s2">const </span><span class="s1">fallbackTarget = visualElement.getBaseTarget(key);</span>
                <span class="s2">const </span><span class="s1">motionValue = visualElement.getValue(key);</span>
                <span class="s2">if </span><span class="s1">(motionValue)</span>
                    <span class="s1">motionValue.liveStyle = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s3">// @ts-expect-error - @mattgperry to figure if we should do something here</span>
                <span class="s1">fallbackAnimation[key] = fallbackTarget ?? </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s1">});</span>
            <span class="s1">animations.push({ animation: fallbackAnimation });</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">shouldAnimate = Boolean(animations.length);</span>
        <span class="s2">if </span><span class="s1">(isInitialRender &amp;&amp;</span>
            <span class="s1">(props.initial === </span><span class="s2">false </span><span class="s1">|| props.initial === props.animate) &amp;&amp;</span>
            <span class="s1">!visualElement.manuallyAnimateOnMount) {</span>
            <span class="s1">shouldAnimate = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">isInitialRender = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">return </span><span class="s1">shouldAnimate ? animate(animations) : Promise.resolve();</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Change whether a certain animation type is active.</span>
     <span class="s3">*/</span>
    <span class="s2">function </span><span class="s1">setActive(type, isActive) {</span>
        <span class="s3">// If the active state hasn't changed, we can safely do nothing here</span>
        <span class="s2">if </span><span class="s1">(state[type].isActive === isActive)</span>
            <span class="s2">return </span><span class="s1">Promise.resolve();</span>
        <span class="s3">// Propagate active change to children</span>
        <span class="s1">visualElement.variantChildren?.forEach((child) =&gt; child.animationState?.setActive(type, isActive));</span>
        <span class="s1">state[type].isActive = isActive;</span>
        <span class="s2">const </span><span class="s1">animations = animateChanges(type);</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">state) {</span>
            <span class="s1">state[key].protectedKeys = {};</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">animations;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">animateChanges,</span>
        <span class="s1">setActive,</span>
        <span class="s1">setAnimateFunction,</span>
        <span class="s1">getState: () =&gt; state,</span>
        <span class="s1">reset: () =&gt; {</span>
            <span class="s1">state = createState();</span>
            <span class="s1">isInitialRender = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">},</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">checkVariantsDidChange(prev, next) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">next === </span><span class="s0">&quot;string&quot;</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">next !== prev;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(Array.isArray(next)) {</span>
        <span class="s2">return </span><span class="s1">!shallowCompare(next, prev);</span>
    <span class="s1">}</span>
    <span class="s2">return false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createTypeState(isActive = </span><span class="s2">false</span><span class="s1">) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">isActive,</span>
        <span class="s1">protectedKeys: {},</span>
        <span class="s1">needsAnimating: {},</span>
        <span class="s1">prevResolvedValues: {},</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createState() {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">animate: createTypeState(</span><span class="s2">true</span><span class="s1">),</span>
        <span class="s1">whileInView: createTypeState(),</span>
        <span class="s1">whileHover: createTypeState(),</span>
        <span class="s1">whileTap: createTypeState(),</span>
        <span class="s1">whileDrag: createTypeState(),</span>
        <span class="s1">whileFocus: createTypeState(),</span>
        <span class="s1">exit: createTypeState(),</span>
    <span class="s1">};</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">Feature {</span>
    <span class="s1">constructor(node) {</span>
        <span class="s2">this</span><span class="s1">.isMounted = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.node = node;</span>
    <span class="s1">}</span>
    <span class="s1">update() { }</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">AnimationFeature </span><span class="s2">extends </span><span class="s1">Feature {</span>
    <span class="s3">/**</span>
     <span class="s3">* We dynamically generate the AnimationState manager as it contains a reference</span>
     <span class="s3">* to the underlying animation library. We only want to load that if we load this,</span>
     <span class="s3">* so people can optionally code split it out using the `m` component.</span>
     <span class="s3">*/</span>
    <span class="s1">constructor(node) {</span>
        <span class="s2">super</span><span class="s1">(node);</span>
        <span class="s1">node.animationState || (node.animationState = createAnimationState(node));</span>
    <span class="s1">}</span>
    <span class="s1">updateAnimationControlsSubscription() {</span>
        <span class="s2">const </span><span class="s1">{ animate } = </span><span class="s2">this</span><span class="s1">.node.getProps();</span>
        <span class="s2">if </span><span class="s1">(isAnimationControls(animate)) {</span>
            <span class="s2">this</span><span class="s1">.unmountControls = animate.subscribe(</span><span class="s2">this</span><span class="s1">.node);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Subscribe any provided AnimationControls to the component's VisualElement</span>
     <span class="s3">*/</span>
    <span class="s1">mount() {</span>
        <span class="s2">this</span><span class="s1">.updateAnimationControlsSubscription();</span>
    <span class="s1">}</span>
    <span class="s1">update() {</span>
        <span class="s2">const </span><span class="s1">{ animate } = </span><span class="s2">this</span><span class="s1">.node.getProps();</span>
        <span class="s2">const </span><span class="s1">{ animate: prevAnimate } = </span><span class="s2">this</span><span class="s1">.node.prevProps || {};</span>
        <span class="s2">if </span><span class="s1">(animate !== prevAnimate) {</span>
            <span class="s2">this</span><span class="s1">.updateAnimationControlsSubscription();</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">unmount() {</span>
        <span class="s2">this</span><span class="s1">.node.animationState.reset();</span>
        <span class="s2">this</span><span class="s1">.unmountControls?.();</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">let </span><span class="s1">id = </span><span class="s5">0</span><span class="s1">;</span>
<span class="s2">class </span><span class="s1">ExitAnimationFeature </span><span class="s2">extends </span><span class="s1">Feature {</span>
    <span class="s1">constructor() {</span>
        <span class="s2">super</span><span class="s1">(...arguments);</span>
        <span class="s2">this</span><span class="s1">.id = id++;</span>
    <span class="s1">}</span>
    <span class="s1">update() {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.node.presenceContext)</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">{ isPresent, onExitComplete } = </span><span class="s2">this</span><span class="s1">.node.presenceContext;</span>
        <span class="s2">const </span><span class="s1">{ isPresent: prevIsPresent } = </span><span class="s2">this</span><span class="s1">.node.prevPresenceContext || {};</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.node.animationState || isPresent === prevIsPresent) {</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">exitAnimation = </span><span class="s2">this</span><span class="s1">.node.animationState.setActive(</span><span class="s0">&quot;exit&quot;</span><span class="s1">, !isPresent);</span>
        <span class="s2">if </span><span class="s1">(onExitComplete &amp;&amp; !isPresent) {</span>
            <span class="s1">exitAnimation.then(() =&gt; {</span>
                <span class="s1">onExitComplete(</span><span class="s2">this</span><span class="s1">.id);</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">mount() {</span>
        <span class="s2">const </span><span class="s1">{ register, onExitComplete } = </span><span class="s2">this</span><span class="s1">.node.presenceContext || {};</span>
        <span class="s2">if </span><span class="s1">(onExitComplete) {</span>
            <span class="s1">onExitComplete(</span><span class="s2">this</span><span class="s1">.id);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(register) {</span>
            <span class="s2">this</span><span class="s1">.unmount = register(</span><span class="s2">this</span><span class="s1">.id);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">unmount() { }</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">animations = {</span>
    <span class="s1">animation: {</span>
        <span class="s1">Feature: AnimationFeature,</span>
    <span class="s1">},</span>
    <span class="s1">exit: {</span>
        <span class="s1">Feature: ExitAnimationFeature,</span>
    <span class="s1">},</span>
<span class="s1">};</span>

<span class="s2">function </span><span class="s1">extractEventInfo(event) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">point: {</span>
            <span class="s1">x: event.pageX,</span>
            <span class="s1">y: event.pageY,</span>
        <span class="s1">},</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">addPointerInfo = (handler) =&gt; {</span>
    <span class="s2">return </span><span class="s1">(event) =&gt; motionDom.isPrimaryPointer(event) &amp;&amp; handler(event, extractEventInfo(event));</span>
<span class="s1">};</span>

<span class="s2">function </span><span class="s1">addPointerEvent(target, eventName, handler, options) {</span>
    <span class="s2">return </span><span class="s1">addDomEvent(target, eventName, addPointerInfo(handler), options);</span>
<span class="s1">}</span>

<span class="s3">// Fixes https://github.com/motiondivision/motion/issues/2270</span>
<span class="s2">const </span><span class="s1">getContextWindow = ({ current }) =&gt; {</span>
    <span class="s2">return </span><span class="s1">current ? current.ownerDocument.defaultView : </span><span class="s2">null</span><span class="s1">;</span>
<span class="s1">};</span>

<span class="s2">const </span><span class="s1">distance = (a, b) =&gt; Math.abs(a - b);</span>
<span class="s2">function </span><span class="s1">distance2D(a, b) {</span>
    <span class="s3">// Multi-dimensional</span>
    <span class="s2">const </span><span class="s1">xDelta = distance(a.x, b.x);</span>
    <span class="s2">const </span><span class="s1">yDelta = distance(a.y, b.y);</span>
    <span class="s2">return </span><span class="s1">Math.sqrt(xDelta ** </span><span class="s5">2 </span><span class="s1">+ yDelta ** </span><span class="s5">2</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@internal</span>
 <span class="s3">*/</span>
<span class="s2">class </span><span class="s1">PanSession {</span>
    <span class="s1">constructor(event, handlers, { transformPagePoint, contextWindow = window, dragSnapToOrigin = </span><span class="s2">false</span><span class="s1">, distanceThreshold = </span><span class="s5">3</span><span class="s1">, } = {}) {</span>
        <span class="s3">/**</span>
         <span class="s3">* </span><span class="s4">@internal</span>
         <span class="s3">*/</span>
        <span class="s2">this</span><span class="s1">.startEvent = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s3">/**</span>
         <span class="s3">* </span><span class="s4">@internal</span>
         <span class="s3">*/</span>
        <span class="s2">this</span><span class="s1">.lastMoveEvent = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s3">/**</span>
         <span class="s3">* </span><span class="s4">@internal</span>
         <span class="s3">*/</span>
        <span class="s2">this</span><span class="s1">.lastMoveEventInfo = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s3">/**</span>
         <span class="s3">* </span><span class="s4">@internal</span>
         <span class="s3">*/</span>
        <span class="s2">this</span><span class="s1">.handlers = {};</span>
        <span class="s3">/**</span>
         <span class="s3">* </span><span class="s4">@internal</span>
         <span class="s3">*/</span>
        <span class="s2">this</span><span class="s1">.contextWindow = window;</span>
        <span class="s2">this</span><span class="s1">.updatePoint = () =&gt; {</span>
            <span class="s2">if </span><span class="s1">(!(</span><span class="s2">this</span><span class="s1">.lastMoveEvent &amp;&amp; </span><span class="s2">this</span><span class="s1">.lastMoveEventInfo))</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s2">const </span><span class="s1">info = getPanInfo(</span><span class="s2">this</span><span class="s1">.lastMoveEventInfo, </span><span class="s2">this</span><span class="s1">.history);</span>
            <span class="s2">const </span><span class="s1">isPanStarted = </span><span class="s2">this</span><span class="s1">.startEvent !== </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s3">// Only start panning if the offset is larger than 3 pixels. If we make it</span>
            <span class="s3">// any larger than this we'll want to reset the pointer history</span>
            <span class="s3">// on the first update to avoid visual snapping to the cursor.</span>
            <span class="s2">const </span><span class="s1">isDistancePastThreshold = distance2D(info.offset, { x: </span><span class="s5">0</span><span class="s1">, y: </span><span class="s5">0 </span><span class="s1">}) &gt;= </span><span class="s2">this</span><span class="s1">.distanceThreshold;</span>
            <span class="s2">if </span><span class="s1">(!isPanStarted &amp;&amp; !isDistancePastThreshold)</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s2">const </span><span class="s1">{ point } = info;</span>
            <span class="s2">const </span><span class="s1">{ timestamp } = motionDom.frameData;</span>
            <span class="s2">this</span><span class="s1">.history.push({ ...point, timestamp });</span>
            <span class="s2">const </span><span class="s1">{ onStart, onMove } = </span><span class="s2">this</span><span class="s1">.handlers;</span>
            <span class="s2">if </span><span class="s1">(!isPanStarted) {</span>
                <span class="s1">onStart &amp;&amp; onStart(</span><span class="s2">this</span><span class="s1">.lastMoveEvent, info);</span>
                <span class="s2">this</span><span class="s1">.startEvent = </span><span class="s2">this</span><span class="s1">.lastMoveEvent;</span>
            <span class="s1">}</span>
            <span class="s1">onMove &amp;&amp; onMove(</span><span class="s2">this</span><span class="s1">.lastMoveEvent, info);</span>
        <span class="s1">};</span>
        <span class="s2">this</span><span class="s1">.handlePointerMove = (event, info) =&gt; {</span>
            <span class="s2">this</span><span class="s1">.lastMoveEvent = event;</span>
            <span class="s2">this</span><span class="s1">.lastMoveEventInfo = transformPoint(info, </span><span class="s2">this</span><span class="s1">.transformPagePoint);</span>
            <span class="s3">// Throttle mouse move event to once per frame</span>
            <span class="s1">motionDom.frame.update(</span><span class="s2">this</span><span class="s1">.updatePoint, </span><span class="s2">true</span><span class="s1">);</span>
        <span class="s1">};</span>
        <span class="s2">this</span><span class="s1">.handlePointerUp = (event, info) =&gt; {</span>
            <span class="s2">this</span><span class="s1">.end();</span>
            <span class="s2">const </span><span class="s1">{ onEnd, onSessionEnd, resumeAnimation } = </span><span class="s2">this</span><span class="s1">.handlers;</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.dragSnapToOrigin)</span>
                <span class="s1">resumeAnimation &amp;&amp; resumeAnimation();</span>
            <span class="s2">if </span><span class="s1">(!(</span><span class="s2">this</span><span class="s1">.lastMoveEvent &amp;&amp; </span><span class="s2">this</span><span class="s1">.lastMoveEventInfo))</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s2">const </span><span class="s1">panInfo = getPanInfo(event.type === </span><span class="s0">&quot;pointercancel&quot;</span>
                <span class="s1">? </span><span class="s2">this</span><span class="s1">.lastMoveEventInfo</span>
                <span class="s1">: transformPoint(info, </span><span class="s2">this</span><span class="s1">.transformPagePoint), </span><span class="s2">this</span><span class="s1">.history);</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.startEvent &amp;&amp; onEnd) {</span>
                <span class="s1">onEnd(event, panInfo);</span>
            <span class="s1">}</span>
            <span class="s1">onSessionEnd &amp;&amp; onSessionEnd(event, panInfo);</span>
        <span class="s1">};</span>
        <span class="s3">// If we have more than one touch, don't start detecting this gesture</span>
        <span class="s2">if </span><span class="s1">(!motionDom.isPrimaryPointer(event))</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.dragSnapToOrigin = dragSnapToOrigin;</span>
        <span class="s2">this</span><span class="s1">.handlers = handlers;</span>
        <span class="s2">this</span><span class="s1">.transformPagePoint = transformPagePoint;</span>
        <span class="s2">this</span><span class="s1">.distanceThreshold = distanceThreshold;</span>
        <span class="s2">this</span><span class="s1">.contextWindow = contextWindow || window;</span>
        <span class="s2">const </span><span class="s1">info = extractEventInfo(event);</span>
        <span class="s2">const </span><span class="s1">initialInfo = transformPoint(info, </span><span class="s2">this</span><span class="s1">.transformPagePoint);</span>
        <span class="s2">const </span><span class="s1">{ point } = initialInfo;</span>
        <span class="s2">const </span><span class="s1">{ timestamp } = motionDom.frameData;</span>
        <span class="s2">this</span><span class="s1">.history = [{ ...point, timestamp }];</span>
        <span class="s2">const </span><span class="s1">{ onSessionStart } = handlers;</span>
        <span class="s1">onSessionStart &amp;&amp;</span>
            <span class="s1">onSessionStart(event, getPanInfo(initialInfo, </span><span class="s2">this</span><span class="s1">.history));</span>
        <span class="s2">this</span><span class="s1">.removeListeners = motionUtils.pipe(addPointerEvent(</span><span class="s2">this</span><span class="s1">.contextWindow, </span><span class="s0">&quot;pointermove&quot;</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.handlePointerMove), addPointerEvent(</span><span class="s2">this</span><span class="s1">.contextWindow, </span><span class="s0">&quot;pointerup&quot;</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.handlePointerUp), addPointerEvent(</span><span class="s2">this</span><span class="s1">.contextWindow, </span><span class="s0">&quot;pointercancel&quot;</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.handlePointerUp));</span>
    <span class="s1">}</span>
    <span class="s1">updateHandlers(handlers) {</span>
        <span class="s2">this</span><span class="s1">.handlers = handlers;</span>
    <span class="s1">}</span>
    <span class="s1">end() {</span>
        <span class="s2">this</span><span class="s1">.removeListeners &amp;&amp; </span><span class="s2">this</span><span class="s1">.removeListeners();</span>
        <span class="s1">motionDom.cancelFrame(</span><span class="s2">this</span><span class="s1">.updatePoint);</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">transformPoint(info, transformPagePoint) {</span>
    <span class="s2">return </span><span class="s1">transformPagePoint ? { point: transformPagePoint(info.point) } : info;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">subtractPoint(a, b) {</span>
    <span class="s2">return </span><span class="s1">{ x: a.x - b.x, y: a.y - b.y };</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getPanInfo({ point }, history) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">point,</span>
        <span class="s1">delta: subtractPoint(point, lastDevicePoint(history)),</span>
        <span class="s1">offset: subtractPoint(point, startDevicePoint(history)),</span>
        <span class="s1">velocity: getVelocity(history, </span><span class="s5">0.1</span><span class="s1">),</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">startDevicePoint(history) {</span>
    <span class="s2">return </span><span class="s1">history[</span><span class="s5">0</span><span class="s1">];</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">lastDevicePoint(history) {</span>
    <span class="s2">return </span><span class="s1">history[history.length - </span><span class="s5">1</span><span class="s1">];</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getVelocity(history, timeDelta) {</span>
    <span class="s2">if </span><span class="s1">(history.length &lt; </span><span class="s5">2</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">{ x: </span><span class="s5">0</span><span class="s1">, y: </span><span class="s5">0 </span><span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">i = history.length - </span><span class="s5">1</span><span class="s1">;</span>
    <span class="s2">let </span><span class="s1">timestampedPoint = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">lastPoint = lastDevicePoint(history);</span>
    <span class="s2">while </span><span class="s1">(i &gt;= </span><span class="s5">0</span><span class="s1">) {</span>
        <span class="s1">timestampedPoint = history[i];</span>
        <span class="s2">if </span><span class="s1">(lastPoint.timestamp - timestampedPoint.timestamp &gt;</span>
            <span class="s1">motionUtils.secondsToMilliseconds(timeDelta)) {</span>
            <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">i--;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(!timestampedPoint) {</span>
        <span class="s2">return </span><span class="s1">{ x: </span><span class="s5">0</span><span class="s1">, y: </span><span class="s5">0 </span><span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">time = motionUtils.millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);</span>
    <span class="s2">if </span><span class="s1">(time === </span><span class="s5">0</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">{ x: </span><span class="s5">0</span><span class="s1">, y: </span><span class="s5">0 </span><span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">currentVelocity = {</span>
        <span class="s1">x: (lastPoint.x - timestampedPoint.x) / time,</span>
        <span class="s1">y: (lastPoint.y - timestampedPoint.y) / time,</span>
    <span class="s1">};</span>
    <span class="s2">if </span><span class="s1">(currentVelocity.x === Infinity) {</span>
        <span class="s1">currentVelocity.x = </span><span class="s5">0</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(currentVelocity.y === Infinity) {</span>
        <span class="s1">currentVelocity.y = </span><span class="s5">0</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">currentVelocity;</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Apply constraints to a point. These constraints are both physical along an</span>
 <span class="s3">* axis, and an elastic factor that determines how much to constrain the point</span>
 <span class="s3">* by if it does lie outside the defined parameters.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">applyConstraints(point, { min, max }, elastic) {</span>
    <span class="s2">if </span><span class="s1">(min !== undefined &amp;&amp; point &lt; min) {</span>
        <span class="s3">// If we have a min point defined, and this is outside of that, constrain</span>
        <span class="s1">point = elastic</span>
            <span class="s1">? motionDom.mixNumber(min, point, elastic.min)</span>
            <span class="s1">: Math.max(point, min);</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(max !== undefined &amp;&amp; point &gt; max) {</span>
        <span class="s3">// If we have a max point defined, and this is outside of that, constrain</span>
        <span class="s1">point = elastic</span>
            <span class="s1">? motionDom.mixNumber(max, point, elastic.max)</span>
            <span class="s1">: Math.min(point, max);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">point;</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Calculate constraints in terms of the viewport when defined relatively to the</span>
 <span class="s3">* measured axis. This is measured from the nearest edge, so a max constraint of 200</span>
 <span class="s3">* on an axis with a max value of 300 would return a constraint of 500 - axis length</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">calcRelativeAxisConstraints(axis, min, max) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">min: min !== undefined ? axis.min + min : undefined,</span>
        <span class="s1">max: max !== undefined</span>
            <span class="s1">? axis.max + max - (axis.max - axis.min)</span>
            <span class="s1">: undefined,</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Calculate constraints in terms of the viewport when</span>
 <span class="s3">* defined relatively to the measured bounding box.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">x: calcRelativeAxisConstraints(layoutBox.x, left, right),</span>
        <span class="s1">y: calcRelativeAxisConstraints(layoutBox.y, top, bottom),</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Calculate viewport constraints when defined as another viewport-relative axis</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">calcViewportAxisConstraints(layoutAxis, constraintsAxis) {</span>
    <span class="s2">let </span><span class="s1">min = constraintsAxis.min - layoutAxis.min;</span>
    <span class="s2">let </span><span class="s1">max = constraintsAxis.max - layoutAxis.max;</span>
    <span class="s3">// If the constraints axis is actually smaller than the layout axis then we can</span>
    <span class="s3">// flip the constraints</span>
    <span class="s2">if </span><span class="s1">(constraintsAxis.max - constraintsAxis.min &lt;</span>
        <span class="s1">layoutAxis.max - layoutAxis.min) {</span>
        <span class="s1">[min, max] = [max, min];</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{ min, max };</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Calculate viewport constraints when defined as another viewport-relative box</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">calcViewportConstraints(layoutBox, constraintsBox) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),</span>
        <span class="s1">y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y),</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Calculate a transform origin relative to the source axis, between 0-1, that results</span>
 <span class="s3">* in an asthetically pleasing scale/transform needed to project from source to target.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">calcOrigin(source, target) {</span>
    <span class="s2">let </span><span class="s1">origin = </span><span class="s5">0.5</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">sourceLength = calcLength(source);</span>
    <span class="s2">const </span><span class="s1">targetLength = calcLength(target);</span>
    <span class="s2">if </span><span class="s1">(targetLength &gt; sourceLength) {</span>
        <span class="s1">origin = motionUtils.progress(target.min, target.max - sourceLength, source.min);</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(sourceLength &gt; targetLength) {</span>
        <span class="s1">origin = motionUtils.progress(source.min, source.max - targetLength, target.min);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">motionUtils.clamp(</span><span class="s5">0</span><span class="s1">, </span><span class="s5">1</span><span class="s1">, origin);</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Rebase the calculated viewport constraints relative to the layout.min point.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">rebaseAxisConstraints(layout, constraints) {</span>
    <span class="s2">const </span><span class="s1">relativeConstraints = {};</span>
    <span class="s2">if </span><span class="s1">(constraints.min !== undefined) {</span>
        <span class="s1">relativeConstraints.min = constraints.min - layout.min;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(constraints.max !== undefined) {</span>
        <span class="s1">relativeConstraints.max = constraints.max - layout.min;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">relativeConstraints;</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">defaultElastic = </span><span class="s5">0.35</span><span class="s1">;</span>
<span class="s3">/**</span>
 <span class="s3">* Accepts a dragElastic prop and returns resolved elastic values for each axis.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">resolveDragElastic(dragElastic = defaultElastic) {</span>
    <span class="s2">if </span><span class="s1">(dragElastic === </span><span class="s2">false</span><span class="s1">) {</span>
        <span class="s1">dragElastic = </span><span class="s5">0</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(dragElastic === </span><span class="s2">true</span><span class="s1">) {</span>
        <span class="s1">dragElastic = defaultElastic;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">x: resolveAxisElastic(dragElastic, </span><span class="s0">&quot;left&quot;</span><span class="s1">, </span><span class="s0">&quot;right&quot;</span><span class="s1">),</span>
        <span class="s1">y: resolveAxisElastic(dragElastic, </span><span class="s0">&quot;top&quot;</span><span class="s1">, </span><span class="s0">&quot;bottom&quot;</span><span class="s1">),</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">resolveAxisElastic(dragElastic, minLabel, maxLabel) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">min: resolvePointElastic(dragElastic, minLabel),</span>
        <span class="s1">max: resolvePointElastic(dragElastic, maxLabel),</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">resolvePointElastic(dragElastic, label) {</span>
    <span class="s2">return typeof </span><span class="s1">dragElastic === </span><span class="s0">&quot;number&quot;</span>
        <span class="s1">? dragElastic</span>
        <span class="s1">: dragElastic[label] || </span><span class="s5">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">elementDragControls = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
<span class="s2">class </span><span class="s1">VisualElementDragControls {</span>
    <span class="s1">constructor(visualElement) {</span>
        <span class="s2">this</span><span class="s1">.openDragLock = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.isDragging = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.currentDirection = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.originPoint = { x: </span><span class="s5">0</span><span class="s1">, y: </span><span class="s5">0 </span><span class="s1">};</span>
        <span class="s3">/**</span>
         <span class="s3">* The permitted boundaries of travel, in pixels.</span>
         <span class="s3">*/</span>
        <span class="s2">this</span><span class="s1">.constraints = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.hasMutatedConstraints = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s3">/**</span>
         <span class="s3">* The per-axis resolved elastic values.</span>
         <span class="s3">*/</span>
        <span class="s2">this</span><span class="s1">.elastic = createBox();</span>
        <span class="s3">/**</span>
         <span class="s3">* The latest pointer event. Used as fallback when the `cancel` and `stop` functions are called without arguments.</span>
         <span class="s3">*/</span>
        <span class="s2">this</span><span class="s1">.latestPointerEvent = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s3">/**</span>
         <span class="s3">* The latest pan info. Used as fallback when the `cancel` and `stop` functions are called without arguments.</span>
         <span class="s3">*/</span>
        <span class="s2">this</span><span class="s1">.latestPanInfo = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.visualElement = visualElement;</span>
    <span class="s1">}</span>
    <span class="s1">start(originEvent, { snapToCursor = </span><span class="s2">false</span><span class="s1">, distanceThreshold } = {}) {</span>
        <span class="s3">/**</span>
         <span class="s3">* Don't start dragging if this component is exiting</span>
         <span class="s3">*/</span>
        <span class="s2">const </span><span class="s1">{ presenceContext } = </span><span class="s2">this</span><span class="s1">.visualElement;</span>
        <span class="s2">if </span><span class="s1">(presenceContext &amp;&amp; presenceContext.isPresent === </span><span class="s2">false</span><span class="s1">)</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">onSessionStart = (event) =&gt; {</span>
            <span class="s2">const </span><span class="s1">{ dragSnapToOrigin } = </span><span class="s2">this</span><span class="s1">.getProps();</span>
            <span class="s3">// Stop or pause any animations on both axis values immediately. This allows the user to throw and catch</span>
            <span class="s3">// the component.</span>
            <span class="s1">dragSnapToOrigin ? </span><span class="s2">this</span><span class="s1">.pauseAnimation() : </span><span class="s2">this</span><span class="s1">.stopAnimation();</span>
            <span class="s2">if </span><span class="s1">(snapToCursor) {</span>
                <span class="s2">this</span><span class="s1">.snapToCursor(extractEventInfo(event).point);</span>
            <span class="s1">}</span>
        <span class="s1">};</span>
        <span class="s2">const </span><span class="s1">onStart = (event, info) =&gt; {</span>
            <span class="s3">// Attempt to grab the global drag gesture lock - maybe make this part of PanSession</span>
            <span class="s2">const </span><span class="s1">{ drag, dragPropagation, onDragStart } = </span><span class="s2">this</span><span class="s1">.getProps();</span>
            <span class="s2">if </span><span class="s1">(drag &amp;&amp; !dragPropagation) {</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.openDragLock)</span>
                    <span class="s2">this</span><span class="s1">.openDragLock();</span>
                <span class="s2">this</span><span class="s1">.openDragLock = motionDom.setDragLock(drag);</span>
                <span class="s3">// If we don 't have the lock, don't start dragging</span>
                <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.openDragLock)</span>
                    <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">this</span><span class="s1">.latestPointerEvent = event;</span>
            <span class="s2">this</span><span class="s1">.latestPanInfo = info;</span>
            <span class="s2">this</span><span class="s1">.isDragging = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s2">this</span><span class="s1">.currentDirection = </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s2">this</span><span class="s1">.resolveConstraints();</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.visualElement.projection) {</span>
                <span class="s2">this</span><span class="s1">.visualElement.projection.isAnimationBlocked = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s2">this</span><span class="s1">.visualElement.projection.target = undefined;</span>
            <span class="s1">}</span>
            <span class="s3">/**</span>
             <span class="s3">* Record gesture origin</span>
             <span class="s3">*/</span>
            <span class="s1">eachAxis((axis) =&gt; {</span>
                <span class="s2">let </span><span class="s1">current = </span><span class="s2">this</span><span class="s1">.getAxisMotionValue(axis).get() || </span><span class="s5">0</span><span class="s1">;</span>
                <span class="s3">/**</span>
                 <span class="s3">* If the MotionValue is a percentage value convert to px</span>
                 <span class="s3">*/</span>
                <span class="s2">if </span><span class="s1">(motionDom.percent.test(current)) {</span>
                    <span class="s2">const </span><span class="s1">{ projection } = </span><span class="s2">this</span><span class="s1">.visualElement;</span>
                    <span class="s2">if </span><span class="s1">(projection &amp;&amp; projection.layout) {</span>
                        <span class="s2">const </span><span class="s1">measuredAxis = projection.layout.layoutBox[axis];</span>
                        <span class="s2">if </span><span class="s1">(measuredAxis) {</span>
                            <span class="s2">const </span><span class="s1">length = calcLength(measuredAxis);</span>
                            <span class="s1">current = length * (parseFloat(current) / </span><span class="s5">100</span><span class="s1">);</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">this</span><span class="s1">.originPoint[axis] = current;</span>
            <span class="s1">});</span>
            <span class="s3">// Fire onDragStart event</span>
            <span class="s2">if </span><span class="s1">(onDragStart) {</span>
                <span class="s1">motionDom.frame.postRender(() =&gt; onDragStart(event, info));</span>
            <span class="s1">}</span>
            <span class="s1">addValueToWillChange(</span><span class="s2">this</span><span class="s1">.visualElement, </span><span class="s0">&quot;transform&quot;</span><span class="s1">);</span>
            <span class="s2">const </span><span class="s1">{ animationState } = </span><span class="s2">this</span><span class="s1">.visualElement;</span>
            <span class="s1">animationState &amp;&amp; animationState.setActive(</span><span class="s0">&quot;whileDrag&quot;</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
        <span class="s1">};</span>
        <span class="s2">const </span><span class="s1">onMove = (event, info) =&gt; {</span>
            <span class="s2">this</span><span class="s1">.latestPointerEvent = event;</span>
            <span class="s2">this</span><span class="s1">.latestPanInfo = info;</span>
            <span class="s2">const </span><span class="s1">{ dragPropagation, dragDirectionLock, onDirectionLock, onDrag, } = </span><span class="s2">this</span><span class="s1">.getProps();</span>
            <span class="s3">// If we didn't successfully receive the gesture lock, early return.</span>
            <span class="s2">if </span><span class="s1">(!dragPropagation &amp;&amp; !</span><span class="s2">this</span><span class="s1">.openDragLock)</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s2">const </span><span class="s1">{ offset } = info;</span>
            <span class="s3">// Attempt to detect drag direction if directionLock is true</span>
            <span class="s2">if </span><span class="s1">(dragDirectionLock &amp;&amp; </span><span class="s2">this</span><span class="s1">.currentDirection === </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s2">this</span><span class="s1">.currentDirection = getCurrentDirection(offset);</span>
                <span class="s3">// If we've successfully set a direction, notify listener</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.currentDirection !== </span><span class="s2">null</span><span class="s1">) {</span>
                    <span class="s1">onDirectionLock &amp;&amp; onDirectionLock(</span><span class="s2">this</span><span class="s1">.currentDirection);</span>
                <span class="s1">}</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">// Update each point with the latest position</span>
            <span class="s2">this</span><span class="s1">.updateAxis(</span><span class="s0">&quot;x&quot;</span><span class="s1">, info.point, offset);</span>
            <span class="s2">this</span><span class="s1">.updateAxis(</span><span class="s0">&quot;y&quot;</span><span class="s1">, info.point, offset);</span>
            <span class="s3">/**</span>
             <span class="s3">* Ideally we would leave the renderer to fire naturally at the end of</span>
             <span class="s3">* this frame but if the element is about to change layout as the result</span>
             <span class="s3">* of a re-render we want to ensure the browser can read the latest</span>
             <span class="s3">* bounding box to ensure the pointer and element don't fall out of sync.</span>
             <span class="s3">*/</span>
            <span class="s2">this</span><span class="s1">.visualElement.render();</span>
            <span class="s3">/**</span>
             <span class="s3">* This must fire after the render call as it might trigger a state</span>
             <span class="s3">* change which itself might trigger a layout update.</span>
             <span class="s3">*/</span>
            <span class="s1">onDrag &amp;&amp; onDrag(event, info);</span>
        <span class="s1">};</span>
        <span class="s2">const </span><span class="s1">onSessionEnd = (event, info) =&gt; {</span>
            <span class="s2">this</span><span class="s1">.latestPointerEvent = event;</span>
            <span class="s2">this</span><span class="s1">.latestPanInfo = info;</span>
            <span class="s2">this</span><span class="s1">.stop(event, info);</span>
            <span class="s2">this</span><span class="s1">.latestPointerEvent = </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s2">this</span><span class="s1">.latestPanInfo = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">};</span>
        <span class="s2">const </span><span class="s1">resumeAnimation = () =&gt; eachAxis((axis) =&gt; </span><span class="s2">this</span><span class="s1">.getAnimationState(axis) === </span><span class="s0">&quot;paused&quot; </span><span class="s1">&amp;&amp;</span>
            <span class="s2">this</span><span class="s1">.getAxisMotionValue(axis).animation?.play());</span>
        <span class="s2">const </span><span class="s1">{ dragSnapToOrigin } = </span><span class="s2">this</span><span class="s1">.getProps();</span>
        <span class="s2">this</span><span class="s1">.panSession = </span><span class="s2">new </span><span class="s1">PanSession(originEvent, {</span>
            <span class="s1">onSessionStart,</span>
            <span class="s1">onStart,</span>
            <span class="s1">onMove,</span>
            <span class="s1">onSessionEnd,</span>
            <span class="s1">resumeAnimation,</span>
        <span class="s1">}, {</span>
            <span class="s1">transformPagePoint: </span><span class="s2">this</span><span class="s1">.visualElement.getTransformPagePoint(),</span>
            <span class="s1">dragSnapToOrigin,</span>
            <span class="s1">distanceThreshold,</span>
            <span class="s1">contextWindow: getContextWindow(</span><span class="s2">this</span><span class="s1">.visualElement),</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* </span><span class="s4">@internal</span>
     <span class="s3">*/</span>
    <span class="s1">stop(event, panInfo) {</span>
        <span class="s2">const </span><span class="s1">finalEvent = event || </span><span class="s2">this</span><span class="s1">.latestPointerEvent;</span>
        <span class="s2">const </span><span class="s1">finalPanInfo = panInfo || </span><span class="s2">this</span><span class="s1">.latestPanInfo;</span>
        <span class="s2">const </span><span class="s1">isDragging = </span><span class="s2">this</span><span class="s1">.isDragging;</span>
        <span class="s2">this</span><span class="s1">.cancel();</span>
        <span class="s2">if </span><span class="s1">(!isDragging || !finalPanInfo || !finalEvent)</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">{ velocity } = finalPanInfo;</span>
        <span class="s2">this</span><span class="s1">.startAnimation(velocity);</span>
        <span class="s2">const </span><span class="s1">{ onDragEnd } = </span><span class="s2">this</span><span class="s1">.getProps();</span>
        <span class="s2">if </span><span class="s1">(onDragEnd) {</span>
            <span class="s1">motionDom.frame.postRender(() =&gt; onDragEnd(finalEvent, finalPanInfo));</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* </span><span class="s4">@internal</span>
     <span class="s3">*/</span>
    <span class="s1">cancel() {</span>
        <span class="s2">this</span><span class="s1">.isDragging = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">{ projection, animationState } = </span><span class="s2">this</span><span class="s1">.visualElement;</span>
        <span class="s2">if </span><span class="s1">(projection) {</span>
            <span class="s1">projection.isAnimationBlocked = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.panSession &amp;&amp; </span><span class="s2">this</span><span class="s1">.panSession.end();</span>
        <span class="s2">this</span><span class="s1">.panSession = undefined;</span>
        <span class="s2">const </span><span class="s1">{ dragPropagation } = </span><span class="s2">this</span><span class="s1">.getProps();</span>
        <span class="s2">if </span><span class="s1">(!dragPropagation &amp;&amp; </span><span class="s2">this</span><span class="s1">.openDragLock) {</span>
            <span class="s2">this</span><span class="s1">.openDragLock();</span>
            <span class="s2">this</span><span class="s1">.openDragLock = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">animationState &amp;&amp; animationState.setActive(</span><span class="s0">&quot;whileDrag&quot;</span><span class="s1">, </span><span class="s2">false</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">updateAxis(axis, _point, offset) {</span>
        <span class="s2">const </span><span class="s1">{ drag } = </span><span class="s2">this</span><span class="s1">.getProps();</span>
        <span class="s3">// If we're not dragging this axis, do an early return.</span>
        <span class="s2">if </span><span class="s1">(!offset || !shouldDrag(axis, drag, </span><span class="s2">this</span><span class="s1">.currentDirection))</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">axisValue = </span><span class="s2">this</span><span class="s1">.getAxisMotionValue(axis);</span>
        <span class="s2">let </span><span class="s1">next = </span><span class="s2">this</span><span class="s1">.originPoint[axis] + offset[axis];</span>
        <span class="s3">// Apply constraints</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.constraints &amp;&amp; </span><span class="s2">this</span><span class="s1">.constraints[axis]) {</span>
            <span class="s1">next = applyConstraints(next, </span><span class="s2">this</span><span class="s1">.constraints[axis], </span><span class="s2">this</span><span class="s1">.elastic[axis]);</span>
        <span class="s1">}</span>
        <span class="s1">axisValue.set(next);</span>
    <span class="s1">}</span>
    <span class="s1">resolveConstraints() {</span>
        <span class="s2">const </span><span class="s1">{ dragConstraints, dragElastic } = </span><span class="s2">this</span><span class="s1">.getProps();</span>
        <span class="s2">const </span><span class="s1">layout = </span><span class="s2">this</span><span class="s1">.visualElement.projection &amp;&amp;</span>
            <span class="s1">!</span><span class="s2">this</span><span class="s1">.visualElement.projection.layout</span>
            <span class="s1">? </span><span class="s2">this</span><span class="s1">.visualElement.projection.measure(</span><span class="s2">false</span><span class="s1">)</span>
            <span class="s1">: </span><span class="s2">this</span><span class="s1">.visualElement.projection?.layout;</span>
        <span class="s2">const </span><span class="s1">prevConstraints = </span><span class="s2">this</span><span class="s1">.constraints;</span>
        <span class="s2">if </span><span class="s1">(dragConstraints &amp;&amp; isRefObject(dragConstraints)) {</span>
            <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.constraints) {</span>
                <span class="s2">this</span><span class="s1">.constraints = </span><span class="s2">this</span><span class="s1">.resolveRefConstraints();</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(dragConstraints &amp;&amp; layout) {</span>
                <span class="s2">this</span><span class="s1">.constraints = calcRelativeConstraints(layout.layoutBox, dragConstraints);</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">this</span><span class="s1">.constraints = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.elastic = resolveDragElastic(dragElastic);</span>
        <span class="s3">/**</span>
         <span class="s3">* If we're outputting to external MotionValues, we want to rebase the measured constraints</span>
         <span class="s3">* from viewport-relative to component-relative.</span>
         <span class="s3">*/</span>
        <span class="s2">if </span><span class="s1">(prevConstraints !== </span><span class="s2">this</span><span class="s1">.constraints &amp;&amp;</span>
            <span class="s1">layout &amp;&amp;</span>
            <span class="s2">this</span><span class="s1">.constraints &amp;&amp;</span>
            <span class="s1">!</span><span class="s2">this</span><span class="s1">.hasMutatedConstraints) {</span>
            <span class="s1">eachAxis((axis) =&gt; {</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.constraints !== </span><span class="s2">false </span><span class="s1">&amp;&amp;</span>
                    <span class="s2">this</span><span class="s1">.getAxisMotionValue(axis)) {</span>
                    <span class="s2">this</span><span class="s1">.constraints[axis] = rebaseAxisConstraints(layout.layoutBox[axis], </span><span class="s2">this</span><span class="s1">.constraints[axis]);</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">resolveRefConstraints() {</span>
        <span class="s2">const </span><span class="s1">{ dragConstraints: constraints, onMeasureDragConstraints } = </span><span class="s2">this</span><span class="s1">.getProps();</span>
        <span class="s2">if </span><span class="s1">(!constraints || !isRefObject(constraints))</span>
            <span class="s2">return false</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">constraintsElement = constraints.current;</span>
        <span class="s1">motionUtils.invariant(constraintsElement !== </span><span class="s2">null</span><span class="s1">, </span><span class="s0">&quot;If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.&quot;</span><span class="s1">, </span><span class="s0">&quot;drag-constraints-ref&quot;</span><span class="s1">);</span>
        <span class="s2">const </span><span class="s1">{ projection } = </span><span class="s2">this</span><span class="s1">.visualElement;</span>
        <span class="s3">// TODO</span>
        <span class="s2">if </span><span class="s1">(!projection || !projection.layout)</span>
            <span class="s2">return false</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">constraintsBox = measurePageBox(constraintsElement, projection.root, </span><span class="s2">this</span><span class="s1">.visualElement.getTransformPagePoint());</span>
        <span class="s2">let </span><span class="s1">measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);</span>
        <span class="s3">/**</span>
         <span class="s3">* If there's an onMeasureDragConstraints listener we call it and</span>
         <span class="s3">* if different constraints are returned, set constraints to that</span>
         <span class="s3">*/</span>
        <span class="s2">if </span><span class="s1">(onMeasureDragConstraints) {</span>
            <span class="s2">const </span><span class="s1">userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));</span>
            <span class="s2">this</span><span class="s1">.hasMutatedConstraints = !!userConstraints;</span>
            <span class="s2">if </span><span class="s1">(userConstraints) {</span>
                <span class="s1">measuredConstraints = convertBoundingBoxToBox(userConstraints);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">measuredConstraints;</span>
    <span class="s1">}</span>
    <span class="s1">startAnimation(velocity) {</span>
        <span class="s2">const </span><span class="s1">{ drag, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd, } = </span><span class="s2">this</span><span class="s1">.getProps();</span>
        <span class="s2">const </span><span class="s1">constraints = </span><span class="s2">this</span><span class="s1">.constraints || {};</span>
        <span class="s2">const </span><span class="s1">momentumAnimations = eachAxis((axis) =&gt; {</span>
            <span class="s2">if </span><span class="s1">(!shouldDrag(axis, drag, </span><span class="s2">this</span><span class="s1">.currentDirection)) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">let </span><span class="s1">transition = (constraints &amp;&amp; constraints[axis]) || {};</span>
            <span class="s2">if </span><span class="s1">(dragSnapToOrigin)</span>
                <span class="s1">transition = { min: </span><span class="s5">0</span><span class="s1">, max: </span><span class="s5">0 </span><span class="s1">};</span>
            <span class="s3">/**</span>
             <span class="s3">* Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame</span>
             <span class="s3">* of spring animations so we should look into adding a disable spring option to `inertia`.</span>
             <span class="s3">* We could do something here where we affect the `bounceStiffness` and `bounceDamping`</span>
             <span class="s3">* using the value of `dragElastic`.</span>
             <span class="s3">*/</span>
            <span class="s2">const </span><span class="s1">bounceStiffness = dragElastic ? </span><span class="s5">200 </span><span class="s1">: </span><span class="s5">1000000</span><span class="s1">;</span>
            <span class="s2">const </span><span class="s1">bounceDamping = dragElastic ? </span><span class="s5">40 </span><span class="s1">: </span><span class="s5">10000000</span><span class="s1">;</span>
            <span class="s2">const </span><span class="s1">inertia = {</span>
                <span class="s1">type: </span><span class="s0">&quot;inertia&quot;</span><span class="s1">,</span>
                <span class="s1">velocity: dragMomentum ? velocity[axis] : </span><span class="s5">0</span><span class="s1">,</span>
                <span class="s1">bounceStiffness,</span>
                <span class="s1">bounceDamping,</span>
                <span class="s1">timeConstant: </span><span class="s5">750</span><span class="s1">,</span>
                <span class="s1">restDelta: </span><span class="s5">1</span><span class="s1">,</span>
                <span class="s1">restSpeed: </span><span class="s5">10</span><span class="s1">,</span>
                <span class="s1">...dragTransition,</span>
                <span class="s1">...transition,</span>
            <span class="s1">};</span>
            <span class="s3">// If we're not animating on an externally-provided `MotionValue` we can use the</span>
            <span class="s3">// component's animation controls which will handle interactions with whileHover (etc),</span>
            <span class="s3">// otherwise we just have to animate the `MotionValue` itself.</span>
            <span class="s2">return this</span><span class="s1">.startAxisValueAnimation(axis, inertia);</span>
        <span class="s1">});</span>
        <span class="s3">// Run all animations and then resolve the new drag constraints.</span>
        <span class="s2">return </span><span class="s1">Promise.all(momentumAnimations).then(onDragTransitionEnd);</span>
    <span class="s1">}</span>
    <span class="s1">startAxisValueAnimation(axis, transition) {</span>
        <span class="s2">const </span><span class="s1">axisValue = </span><span class="s2">this</span><span class="s1">.getAxisMotionValue(axis);</span>
        <span class="s1">addValueToWillChange(</span><span class="s2">this</span><span class="s1">.visualElement, axis);</span>
        <span class="s2">return </span><span class="s1">axisValue.start(animateMotionValue(axis, axisValue, </span><span class="s5">0</span><span class="s1">, transition, </span><span class="s2">this</span><span class="s1">.visualElement, </span><span class="s2">false</span><span class="s1">));</span>
    <span class="s1">}</span>
    <span class="s1">stopAnimation() {</span>
        <span class="s1">eachAxis((axis) =&gt; </span><span class="s2">this</span><span class="s1">.getAxisMotionValue(axis).stop());</span>
    <span class="s1">}</span>
    <span class="s1">pauseAnimation() {</span>
        <span class="s1">eachAxis((axis) =&gt; </span><span class="s2">this</span><span class="s1">.getAxisMotionValue(axis).animation?.pause());</span>
    <span class="s1">}</span>
    <span class="s1">getAnimationState(axis) {</span>
        <span class="s2">return this</span><span class="s1">.getAxisMotionValue(axis).animation?.state;</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Drag works differently depending on which props are provided.</span>
     <span class="s3">*</span>
     <span class="s3">* - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.</span>
     <span class="s3">* - Otherwise, we apply the delta to the x/y motion values.</span>
     <span class="s3">*/</span>
    <span class="s1">getAxisMotionValue(axis) {</span>
        <span class="s2">const </span><span class="s1">dragKey = </span><span class="s0">`_drag</span><span class="s1">${axis.toUpperCase()}</span><span class="s0">`</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">props = </span><span class="s2">this</span><span class="s1">.visualElement.getProps();</span>
        <span class="s2">const </span><span class="s1">externalMotionValue = props[dragKey];</span>
        <span class="s2">return </span><span class="s1">externalMotionValue</span>
            <span class="s1">? externalMotionValue</span>
            <span class="s1">: </span><span class="s2">this</span><span class="s1">.visualElement.getValue(axis, (props.initial</span>
                <span class="s1">? props.initial[axis]</span>
                <span class="s1">: undefined) || </span><span class="s5">0</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">snapToCursor(point) {</span>
        <span class="s1">eachAxis((axis) =&gt; {</span>
            <span class="s2">const </span><span class="s1">{ drag } = </span><span class="s2">this</span><span class="s1">.getProps();</span>
            <span class="s3">// If we're not dragging this axis, do an early return.</span>
            <span class="s2">if </span><span class="s1">(!shouldDrag(axis, drag, </span><span class="s2">this</span><span class="s1">.currentDirection))</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s2">const </span><span class="s1">{ projection } = </span><span class="s2">this</span><span class="s1">.visualElement;</span>
            <span class="s2">const </span><span class="s1">axisValue = </span><span class="s2">this</span><span class="s1">.getAxisMotionValue(axis);</span>
            <span class="s2">if </span><span class="s1">(projection &amp;&amp; projection.layout) {</span>
                <span class="s2">const </span><span class="s1">{ min, max } = projection.layout.layoutBox[axis];</span>
                <span class="s1">axisValue.set(point[axis] - motionDom.mixNumber(min, max, </span><span class="s5">0.5</span><span class="s1">));</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* When the viewport resizes we want to check if the measured constraints</span>
     <span class="s3">* have changed and, if so, reposition the element within those new constraints</span>
     <span class="s3">* relative to where it was before the resize.</span>
     <span class="s3">*/</span>
    <span class="s1">scalePositionWithinConstraints() {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.visualElement.current)</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">{ drag, dragConstraints } = </span><span class="s2">this</span><span class="s1">.getProps();</span>
        <span class="s2">const </span><span class="s1">{ projection } = </span><span class="s2">this</span><span class="s1">.visualElement;</span>
        <span class="s2">if </span><span class="s1">(!isRefObject(dragConstraints) || !projection || !</span><span class="s2">this</span><span class="s1">.constraints)</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s3">/**</span>
         <span class="s3">* Stop current animations as there can be visual glitching if we try to do</span>
         <span class="s3">* this mid-animation</span>
         <span class="s3">*/</span>
        <span class="s2">this</span><span class="s1">.stopAnimation();</span>
        <span class="s3">/**</span>
         <span class="s3">* Record the relative position of the dragged element relative to the</span>
         <span class="s3">* constraints box and save as a progress value.</span>
         <span class="s3">*/</span>
        <span class="s2">const </span><span class="s1">boxProgress = { x: </span><span class="s5">0</span><span class="s1">, y: </span><span class="s5">0 </span><span class="s1">};</span>
        <span class="s1">eachAxis((axis) =&gt; {</span>
            <span class="s2">const </span><span class="s1">axisValue = </span><span class="s2">this</span><span class="s1">.getAxisMotionValue(axis);</span>
            <span class="s2">if </span><span class="s1">(axisValue &amp;&amp; </span><span class="s2">this</span><span class="s1">.constraints !== </span><span class="s2">false</span><span class="s1">) {</span>
                <span class="s2">const </span><span class="s1">latest = axisValue.get();</span>
                <span class="s1">boxProgress[axis] = calcOrigin({ min: latest, max: latest }, </span><span class="s2">this</span><span class="s1">.constraints[axis]);</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s3">/**</span>
         <span class="s3">* Update the layout of this element and resolve the latest drag constraints</span>
         <span class="s3">*/</span>
        <span class="s2">const </span><span class="s1">{ transformTemplate } = </span><span class="s2">this</span><span class="s1">.visualElement.getProps();</span>
        <span class="s2">this</span><span class="s1">.visualElement.current.style.transform = transformTemplate</span>
            <span class="s1">? transformTemplate({}, </span><span class="s0">&quot;&quot;</span><span class="s1">)</span>
            <span class="s1">: </span><span class="s0">&quot;none&quot;</span><span class="s1">;</span>
        <span class="s1">projection.root &amp;&amp; projection.root.updateScroll();</span>
        <span class="s1">projection.updateLayout();</span>
        <span class="s2">this</span><span class="s1">.resolveConstraints();</span>
        <span class="s3">/**</span>
         <span class="s3">* For each axis, calculate the current progress of the layout axis</span>
         <span class="s3">* within the new constraints.</span>
         <span class="s3">*/</span>
        <span class="s1">eachAxis((axis) =&gt; {</span>
            <span class="s2">if </span><span class="s1">(!shouldDrag(axis, drag, </span><span class="s2">null</span><span class="s1">))</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s3">/**</span>
             <span class="s3">* Calculate a new transform based on the previous box progress</span>
             <span class="s3">*/</span>
            <span class="s2">const </span><span class="s1">axisValue = </span><span class="s2">this</span><span class="s1">.getAxisMotionValue(axis);</span>
            <span class="s2">const </span><span class="s1">{ min, max } = </span><span class="s2">this</span><span class="s1">.constraints[axis];</span>
            <span class="s1">axisValue.set(motionDom.mixNumber(min, max, boxProgress[axis]));</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">addListeners() {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.visualElement.current)</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">elementDragControls.set(</span><span class="s2">this</span><span class="s1">.visualElement, </span><span class="s2">this</span><span class="s1">);</span>
        <span class="s2">const </span><span class="s1">element = </span><span class="s2">this</span><span class="s1">.visualElement.current;</span>
        <span class="s3">/**</span>
         <span class="s3">* Attach a pointerdown event listener on this DOM element to initiate drag tracking.</span>
         <span class="s3">*/</span>
        <span class="s2">const </span><span class="s1">stopPointerListener = addPointerEvent(element, </span><span class="s0">&quot;pointerdown&quot;</span><span class="s1">, (event) =&gt; {</span>
            <span class="s2">const </span><span class="s1">{ drag, dragListener = </span><span class="s2">true </span><span class="s1">} = </span><span class="s2">this</span><span class="s1">.getProps();</span>
            <span class="s1">drag &amp;&amp; dragListener &amp;&amp; </span><span class="s2">this</span><span class="s1">.start(event);</span>
        <span class="s1">});</span>
        <span class="s2">const </span><span class="s1">measureDragConstraints = () =&gt; {</span>
            <span class="s2">const </span><span class="s1">{ dragConstraints } = </span><span class="s2">this</span><span class="s1">.getProps();</span>
            <span class="s2">if </span><span class="s1">(isRefObject(dragConstraints) &amp;&amp; dragConstraints.current) {</span>
                <span class="s2">this</span><span class="s1">.constraints = </span><span class="s2">this</span><span class="s1">.resolveRefConstraints();</span>
            <span class="s1">}</span>
        <span class="s1">};</span>
        <span class="s2">const </span><span class="s1">{ projection } = </span><span class="s2">this</span><span class="s1">.visualElement;</span>
        <span class="s2">const </span><span class="s1">stopMeasureLayoutListener = projection.addEventListener(</span><span class="s0">&quot;measure&quot;</span><span class="s1">, measureDragConstraints);</span>
        <span class="s2">if </span><span class="s1">(projection &amp;&amp; !projection.layout) {</span>
            <span class="s1">projection.root &amp;&amp; projection.root.updateScroll();</span>
            <span class="s1">projection.updateLayout();</span>
        <span class="s1">}</span>
        <span class="s1">motionDom.frame.read(measureDragConstraints);</span>
        <span class="s3">/**</span>
         <span class="s3">* Attach a window resize listener to scale the draggable target within its defined</span>
         <span class="s3">* constraints as the window resizes.</span>
         <span class="s3">*/</span>
        <span class="s2">const </span><span class="s1">stopResizeListener = addDomEvent(window, </span><span class="s0">&quot;resize&quot;</span><span class="s1">, () =&gt; </span><span class="s2">this</span><span class="s1">.scalePositionWithinConstraints());</span>
        <span class="s3">/**</span>
         <span class="s3">* If the element's layout changes, calculate the delta and apply that to</span>
         <span class="s3">* the drag gesture's origin point.</span>
         <span class="s3">*/</span>
        <span class="s2">const </span><span class="s1">stopLayoutUpdateListener = projection.addEventListener(</span><span class="s0">&quot;didUpdate&quot;</span><span class="s1">, (({ delta, hasLayoutChanged }) =&gt; {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isDragging &amp;&amp; hasLayoutChanged) {</span>
                <span class="s1">eachAxis((axis) =&gt; {</span>
                    <span class="s2">const </span><span class="s1">motionValue = </span><span class="s2">this</span><span class="s1">.getAxisMotionValue(axis);</span>
                    <span class="s2">if </span><span class="s1">(!motionValue)</span>
                        <span class="s2">return</span><span class="s1">;</span>
                    <span class="s2">this</span><span class="s1">.originPoint[axis] += delta[axis].translate;</span>
                    <span class="s1">motionValue.set(motionValue.get() + delta[axis].translate);</span>
                <span class="s1">});</span>
                <span class="s2">this</span><span class="s1">.visualElement.render();</span>
            <span class="s1">}</span>
        <span class="s1">}));</span>
        <span class="s2">return </span><span class="s1">() =&gt; {</span>
            <span class="s1">stopResizeListener();</span>
            <span class="s1">stopPointerListener();</span>
            <span class="s1">stopMeasureLayoutListener();</span>
            <span class="s1">stopLayoutUpdateListener &amp;&amp; stopLayoutUpdateListener();</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s1">getProps() {</span>
        <span class="s2">const </span><span class="s1">props = </span><span class="s2">this</span><span class="s1">.visualElement.getProps();</span>
        <span class="s2">const </span><span class="s1">{ drag = </span><span class="s2">false</span><span class="s1">, dragDirectionLock = </span><span class="s2">false</span><span class="s1">, dragPropagation = </span><span class="s2">false</span><span class="s1">, dragConstraints = </span><span class="s2">false</span><span class="s1">, dragElastic = defaultElastic, dragMomentum = </span><span class="s2">true</span><span class="s1">, } = props;</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">...props,</span>
            <span class="s1">drag,</span>
            <span class="s1">dragDirectionLock,</span>
            <span class="s1">dragPropagation,</span>
            <span class="s1">dragConstraints,</span>
            <span class="s1">dragElastic,</span>
            <span class="s1">dragMomentum,</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">shouldDrag(direction, drag, currentDirection) {</span>
    <span class="s2">return </span><span class="s1">((drag === </span><span class="s2">true </span><span class="s1">|| drag === direction) &amp;&amp;</span>
        <span class="s1">(currentDirection === </span><span class="s2">null </span><span class="s1">|| currentDirection === direction));</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Based on an x/y offset determine the current drag direction. If both axis' offsets are lower</span>
 <span class="s3">* than the provided threshold, return `null`.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">offset - The x/y offset from origin.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">getCurrentDirection(offset, lockThreshold = </span><span class="s5">10</span><span class="s1">) {</span>
    <span class="s2">let </span><span class="s1">direction = </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(Math.abs(offset.y) &gt; lockThreshold) {</span>
        <span class="s1">direction = </span><span class="s0">&quot;y&quot;</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">else if </span><span class="s1">(Math.abs(offset.x) &gt; lockThreshold) {</span>
        <span class="s1">direction = </span><span class="s0">&quot;x&quot;</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">direction;</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">DragGesture </span><span class="s2">extends </span><span class="s1">Feature {</span>
    <span class="s1">constructor(node) {</span>
        <span class="s2">super</span><span class="s1">(node);</span>
        <span class="s2">this</span><span class="s1">.removeGroupControls = motionUtils.noop;</span>
        <span class="s2">this</span><span class="s1">.removeListeners = motionUtils.noop;</span>
        <span class="s2">this</span><span class="s1">.controls = </span><span class="s2">new </span><span class="s1">VisualElementDragControls(node);</span>
    <span class="s1">}</span>
    <span class="s1">mount() {</span>
        <span class="s3">// If we've been provided a DragControls for manual control over the drag gesture,</span>
        <span class="s3">// subscribe this component to it on mount.</span>
        <span class="s2">const </span><span class="s1">{ dragControls } = </span><span class="s2">this</span><span class="s1">.node.getProps();</span>
        <span class="s2">if </span><span class="s1">(dragControls) {</span>
            <span class="s2">this</span><span class="s1">.removeGroupControls = dragControls.subscribe(</span><span class="s2">this</span><span class="s1">.controls);</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.removeListeners = </span><span class="s2">this</span><span class="s1">.controls.addListeners() || motionUtils.noop;</span>
    <span class="s1">}</span>
    <span class="s1">unmount() {</span>
        <span class="s2">this</span><span class="s1">.removeGroupControls();</span>
        <span class="s2">this</span><span class="s1">.removeListeners();</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">asyncHandler = (handler) =&gt; (event, info) =&gt; {</span>
    <span class="s2">if </span><span class="s1">(handler) {</span>
        <span class="s1">motionDom.frame.postRender(() =&gt; handler(event, info));</span>
    <span class="s1">}</span>
<span class="s1">};</span>
<span class="s2">class </span><span class="s1">PanGesture </span><span class="s2">extends </span><span class="s1">Feature {</span>
    <span class="s1">constructor() {</span>
        <span class="s2">super</span><span class="s1">(...arguments);</span>
        <span class="s2">this</span><span class="s1">.removePointerDownListener = motionUtils.noop;</span>
    <span class="s1">}</span>
    <span class="s1">onPointerDown(pointerDownEvent) {</span>
        <span class="s2">this</span><span class="s1">.session = </span><span class="s2">new </span><span class="s1">PanSession(pointerDownEvent, </span><span class="s2">this</span><span class="s1">.createPanHandlers(), {</span>
            <span class="s1">transformPagePoint: </span><span class="s2">this</span><span class="s1">.node.getTransformPagePoint(),</span>
            <span class="s1">contextWindow: getContextWindow(</span><span class="s2">this</span><span class="s1">.node),</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">createPanHandlers() {</span>
        <span class="s2">const </span><span class="s1">{ onPanSessionStart, onPanStart, onPan, onPanEnd } = </span><span class="s2">this</span><span class="s1">.node.getProps();</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">onSessionStart: asyncHandler(onPanSessionStart),</span>
            <span class="s1">onStart: asyncHandler(onPanStart),</span>
            <span class="s1">onMove: onPan,</span>
            <span class="s1">onEnd: (event, info) =&gt; {</span>
                <span class="s2">delete this</span><span class="s1">.session;</span>
                <span class="s2">if </span><span class="s1">(onPanEnd) {</span>
                    <span class="s1">motionDom.frame.postRender(() =&gt; onPanEnd(event, info));</span>
                <span class="s1">}</span>
            <span class="s1">},</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s1">mount() {</span>
        <span class="s2">this</span><span class="s1">.removePointerDownListener = addPointerEvent(</span><span class="s2">this</span><span class="s1">.node.current, </span><span class="s0">&quot;pointerdown&quot;</span><span class="s1">, (event) =&gt; </span><span class="s2">this</span><span class="s1">.onPointerDown(event));</span>
    <span class="s1">}</span>
    <span class="s1">update() {</span>
        <span class="s2">this</span><span class="s1">.session &amp;&amp; </span><span class="s2">this</span><span class="s1">.session.updateHandlers(</span><span class="s2">this</span><span class="s1">.createPanHandlers());</span>
    <span class="s1">}</span>
    <span class="s1">unmount() {</span>
        <span class="s2">this</span><span class="s1">.removePointerDownListener();</span>
        <span class="s2">this</span><span class="s1">.session &amp;&amp; </span><span class="s2">this</span><span class="s1">.session.end();</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Track whether we've taken any snapshots yet. If not,</span>
 <span class="s3">* we can safely skip notification of didUpdate.</span>
 <span class="s3">*</span>
 <span class="s3">* Difficult to capture in a test but to prevent flickering</span>
 <span class="s3">* we must set this to true either on update or unmount.</span>
 <span class="s3">* Running `next-env/layout-id` in Safari will show this behaviour if broken.</span>
 <span class="s3">*/</span>
<span class="s2">let </span><span class="s1">hasTakenAnySnapshot = </span><span class="s2">false</span><span class="s1">;</span>
<span class="s2">class </span><span class="s1">MeasureLayoutWithContext </span><span class="s2">extends </span><span class="s1">React.Component {</span>
    <span class="s3">/**</span>
     <span class="s3">* This only mounts projection nodes for components that</span>
     <span class="s3">* need measuring, we might want to do it for all components</span>
     <span class="s3">* in order to incorporate transforms</span>
     <span class="s3">*/</span>
    <span class="s1">componentDidMount() {</span>
        <span class="s2">const </span><span class="s1">{ visualElement, layoutGroup, switchLayoutGroup, layoutId } = </span><span class="s2">this</span><span class="s1">.props;</span>
        <span class="s2">const </span><span class="s1">{ projection } = visualElement;</span>
        <span class="s1">addScaleCorrector(defaultScaleCorrectors);</span>
        <span class="s2">if </span><span class="s1">(projection) {</span>
            <span class="s2">if </span><span class="s1">(layoutGroup.group)</span>
                <span class="s1">layoutGroup.group.add(projection);</span>
            <span class="s2">if </span><span class="s1">(switchLayoutGroup &amp;&amp; switchLayoutGroup.register &amp;&amp; layoutId) {</span>
                <span class="s1">switchLayoutGroup.register(projection);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(hasTakenAnySnapshot) {</span>
                <span class="s1">projection.root.didUpdate();</span>
            <span class="s1">}</span>
            <span class="s1">projection.addEventListener(</span><span class="s0">&quot;animationComplete&quot;</span><span class="s1">, () =&gt; {</span>
                <span class="s2">this</span><span class="s1">.safeToRemove();</span>
            <span class="s1">});</span>
            <span class="s1">projection.setOptions({</span>
                <span class="s1">...projection.options,</span>
                <span class="s1">onExitComplete: () =&gt; </span><span class="s2">this</span><span class="s1">.safeToRemove(),</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s1">globalProjectionState.hasEverUpdated = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">getSnapshotBeforeUpdate(prevProps) {</span>
        <span class="s2">const </span><span class="s1">{ layoutDependency, visualElement, drag, isPresent } = </span><span class="s2">this</span><span class="s1">.props;</span>
        <span class="s2">const </span><span class="s1">{ projection } = visualElement;</span>
        <span class="s2">if </span><span class="s1">(!projection)</span>
            <span class="s2">return null</span><span class="s1">;</span>
        <span class="s3">/**</span>
         <span class="s3">* TODO: We use this data in relegate to determine whether to</span>
         <span class="s3">* promote a previous element. There's no guarantee its presence data</span>
         <span class="s3">* will have updated by this point - if a bug like this arises it will</span>
         <span class="s3">* have to be that we markForRelegation and then find a new lead some other way,</span>
         <span class="s3">* perhaps in didUpdate</span>
         <span class="s3">*/</span>
        <span class="s1">projection.isPresent = isPresent;</span>
        <span class="s1">hasTakenAnySnapshot = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(drag ||</span>
            <span class="s1">prevProps.layoutDependency !== layoutDependency ||</span>
            <span class="s1">layoutDependency === undefined ||</span>
            <span class="s1">prevProps.isPresent !== isPresent) {</span>
            <span class="s1">projection.willUpdate();</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">.safeToRemove();</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(prevProps.isPresent !== isPresent) {</span>
            <span class="s2">if </span><span class="s1">(isPresent) {</span>
                <span class="s1">projection.promote();</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(!projection.relegate()) {</span>
                <span class="s3">/**</span>
                 <span class="s3">* If there's another stack member taking over from this one,</span>
                 <span class="s3">* it's in charge of the exit animation and therefore should</span>
                 <span class="s3">* be in charge of the safe to remove. Otherwise we call it here.</span>
                 <span class="s3">*/</span>
                <span class="s1">motionDom.frame.postRender(() =&gt; {</span>
                    <span class="s2">const </span><span class="s1">stack = projection.getStack();</span>
                    <span class="s2">if </span><span class="s1">(!stack || !stack.members.length) {</span>
                        <span class="s2">this</span><span class="s1">.safeToRemove();</span>
                    <span class="s1">}</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">componentDidUpdate() {</span>
        <span class="s2">const </span><span class="s1">{ projection } = </span><span class="s2">this</span><span class="s1">.props.visualElement;</span>
        <span class="s2">if </span><span class="s1">(projection) {</span>
            <span class="s1">projection.root.didUpdate();</span>
            <span class="s1">motionDom.microtask.postRender(() =&gt; {</span>
                <span class="s2">if </span><span class="s1">(!projection.currentAnimation &amp;&amp; projection.isLead()) {</span>
                    <span class="s2">this</span><span class="s1">.safeToRemove();</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">componentWillUnmount() {</span>
        <span class="s2">const </span><span class="s1">{ visualElement, layoutGroup, switchLayoutGroup: promoteContext, } = </span><span class="s2">this</span><span class="s1">.props;</span>
        <span class="s2">const </span><span class="s1">{ projection } = visualElement;</span>
        <span class="s1">hasTakenAnySnapshot = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(projection) {</span>
            <span class="s1">projection.scheduleCheckAfterUnmount();</span>
            <span class="s2">if </span><span class="s1">(layoutGroup &amp;&amp; layoutGroup.group)</span>
                <span class="s1">layoutGroup.group.remove(projection);</span>
            <span class="s2">if </span><span class="s1">(promoteContext &amp;&amp; promoteContext.deregister)</span>
                <span class="s1">promoteContext.deregister(projection);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">safeToRemove() {</span>
        <span class="s2">const </span><span class="s1">{ safeToRemove } = </span><span class="s2">this</span><span class="s1">.props;</span>
        <span class="s1">safeToRemove &amp;&amp; safeToRemove();</span>
    <span class="s1">}</span>
    <span class="s1">render() {</span>
        <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">MeasureLayout(props) {</span>
    <span class="s2">const </span><span class="s1">[isPresent, safeToRemove] = usePresence();</span>
    <span class="s2">const </span><span class="s1">layoutGroup = React.useContext(LayoutGroupContext);</span>
    <span class="s2">return </span><span class="s1">(jsxRuntime.jsx(MeasureLayoutWithContext, { ...props, layoutGroup: layoutGroup, switchLayoutGroup: React.useContext(SwitchLayoutGroupContext), isPresent: isPresent, safeToRemove: safeToRemove }));</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">defaultScaleCorrectors = {</span>
    <span class="s1">borderRadius: {</span>
        <span class="s1">...correctBorderRadius,</span>
        <span class="s1">applyTo: [</span>
            <span class="s0">&quot;borderTopLeftRadius&quot;</span><span class="s1">,</span>
            <span class="s0">&quot;borderTopRightRadius&quot;</span><span class="s1">,</span>
            <span class="s0">&quot;borderBottomLeftRadius&quot;</span><span class="s1">,</span>
            <span class="s0">&quot;borderBottomRightRadius&quot;</span><span class="s1">,</span>
        <span class="s1">],</span>
    <span class="s1">},</span>
    <span class="s1">borderTopLeftRadius: correctBorderRadius,</span>
    <span class="s1">borderTopRightRadius: correctBorderRadius,</span>
    <span class="s1">borderBottomLeftRadius: correctBorderRadius,</span>
    <span class="s1">borderBottomRightRadius: correctBorderRadius,</span>
    <span class="s1">boxShadow: correctBoxShadow,</span>
<span class="s1">};</span>

<span class="s2">const </span><span class="s1">drag = {</span>
    <span class="s1">pan: {</span>
        <span class="s1">Feature: PanGesture,</span>
    <span class="s1">},</span>
    <span class="s1">drag: {</span>
        <span class="s1">Feature: DragGesture,</span>
        <span class="s1">ProjectionNode: HTMLProjectionNode,</span>
        <span class="s1">MeasureLayout,</span>
    <span class="s1">},</span>
<span class="s1">};</span>

<span class="s2">function </span><span class="s1">handleHoverEvent(node, event, lifecycle) {</span>
    <span class="s2">const </span><span class="s1">{ props } = node;</span>
    <span class="s2">if </span><span class="s1">(node.animationState &amp;&amp; props.whileHover) {</span>
        <span class="s1">node.animationState.setActive(</span><span class="s0">&quot;whileHover&quot;</span><span class="s1">, lifecycle === </span><span class="s0">&quot;Start&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">eventName = (</span><span class="s0">&quot;onHover&quot; </span><span class="s1">+ lifecycle);</span>
    <span class="s2">const </span><span class="s1">callback = props[eventName];</span>
    <span class="s2">if </span><span class="s1">(callback) {</span>
        <span class="s1">motionDom.frame.postRender(() =&gt; callback(event, extractEventInfo(event)));</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">class </span><span class="s1">HoverGesture </span><span class="s2">extends </span><span class="s1">Feature {</span>
    <span class="s1">mount() {</span>
        <span class="s2">const </span><span class="s1">{ current } = </span><span class="s2">this</span><span class="s1">.node;</span>
        <span class="s2">if </span><span class="s1">(!current)</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.unmount = motionDom.hover(current, (_element, startEvent) =&gt; {</span>
            <span class="s1">handleHoverEvent(</span><span class="s2">this</span><span class="s1">.node, startEvent, </span><span class="s0">&quot;Start&quot;</span><span class="s1">);</span>
            <span class="s2">return </span><span class="s1">(endEvent) =&gt; handleHoverEvent(</span><span class="s2">this</span><span class="s1">.node, endEvent, </span><span class="s0">&quot;End&quot;</span><span class="s1">);</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">unmount() { }</span>
<span class="s1">}</span>

<span class="s2">class </span><span class="s1">FocusGesture </span><span class="s2">extends </span><span class="s1">Feature {</span>
    <span class="s1">constructor() {</span>
        <span class="s2">super</span><span class="s1">(...arguments);</span>
        <span class="s2">this</span><span class="s1">.isActive = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">onFocus() {</span>
        <span class="s2">let </span><span class="s1">isFocusVisible = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s3">/**</span>
         <span class="s3">* If this element doesn't match focus-visible then don't</span>
         <span class="s3">* apply whileHover. But, if matches throws that focus-visible</span>
         <span class="s3">* is not a valid selector then in that browser outline styles will be applied</span>
         <span class="s3">* to the element by default and we want to match that behaviour with whileFocus.</span>
         <span class="s3">*/</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s1">isFocusVisible = </span><span class="s2">this</span><span class="s1">.node.current.matches(</span><span class="s0">&quot;:focus-visible&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">catch </span><span class="s1">(e) {</span>
            <span class="s1">isFocusVisible = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!isFocusVisible || !</span><span class="s2">this</span><span class="s1">.node.animationState)</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.node.animationState.setActive(</span><span class="s0">&quot;whileFocus&quot;</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
        <span class="s2">this</span><span class="s1">.isActive = </span><span class="s2">true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">onBlur() {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.isActive || !</span><span class="s2">this</span><span class="s1">.node.animationState)</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.node.animationState.setActive(</span><span class="s0">&quot;whileFocus&quot;</span><span class="s1">, </span><span class="s2">false</span><span class="s1">);</span>
        <span class="s2">this</span><span class="s1">.isActive = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">mount() {</span>
        <span class="s2">this</span><span class="s1">.unmount = motionUtils.pipe(addDomEvent(</span><span class="s2">this</span><span class="s1">.node.current, </span><span class="s0">&quot;focus&quot;</span><span class="s1">, () =&gt; </span><span class="s2">this</span><span class="s1">.onFocus()), addDomEvent(</span><span class="s2">this</span><span class="s1">.node.current, </span><span class="s0">&quot;blur&quot;</span><span class="s1">, () =&gt; </span><span class="s2">this</span><span class="s1">.onBlur()));</span>
    <span class="s1">}</span>
    <span class="s1">unmount() { }</span>
<span class="s1">}</span>

<span class="s2">function </span><span class="s1">handlePressEvent(node, event, lifecycle) {</span>
    <span class="s2">const </span><span class="s1">{ props } = node;</span>
    <span class="s2">if </span><span class="s1">(node.current </span><span class="s2">instanceof </span><span class="s1">HTMLButtonElement &amp;&amp; node.current.disabled) {</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(node.animationState &amp;&amp; props.whileTap) {</span>
        <span class="s1">node.animationState.setActive(</span><span class="s0">&quot;whileTap&quot;</span><span class="s1">, lifecycle === </span><span class="s0">&quot;Start&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">eventName = (</span><span class="s0">&quot;onTap&quot; </span><span class="s1">+ (lifecycle === </span><span class="s0">&quot;End&quot; </span><span class="s1">? </span><span class="s0">&quot;&quot; </span><span class="s1">: lifecycle));</span>
    <span class="s2">const </span><span class="s1">callback = props[eventName];</span>
    <span class="s2">if </span><span class="s1">(callback) {</span>
        <span class="s1">motionDom.frame.postRender(() =&gt; callback(event, extractEventInfo(event)));</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">class </span><span class="s1">PressGesture </span><span class="s2">extends </span><span class="s1">Feature {</span>
    <span class="s1">mount() {</span>
        <span class="s2">const </span><span class="s1">{ current } = </span><span class="s2">this</span><span class="s1">.node;</span>
        <span class="s2">if </span><span class="s1">(!current)</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.unmount = motionDom.press(current, (_element, startEvent) =&gt; {</span>
            <span class="s1">handlePressEvent(</span><span class="s2">this</span><span class="s1">.node, startEvent, </span><span class="s0">&quot;Start&quot;</span><span class="s1">);</span>
            <span class="s2">return </span><span class="s1">(endEvent, { success }) =&gt; handlePressEvent(</span><span class="s2">this</span><span class="s1">.node, endEvent, success ? </span><span class="s0">&quot;End&quot; </span><span class="s1">: </span><span class="s0">&quot;Cancel&quot;</span><span class="s1">);</span>
        <span class="s1">}, { useGlobalTarget: </span><span class="s2">this</span><span class="s1">.node.props.globalTapTarget });</span>
    <span class="s1">}</span>
    <span class="s1">unmount() { }</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Map an IntersectionHandler callback to an element. We only ever make one handler for one</span>
 <span class="s3">* element, so even though these handlers might all be triggered by different</span>
 <span class="s3">* observers, we can keep them in the same map.</span>
 <span class="s3">*/</span>
<span class="s2">const </span><span class="s1">observerCallbacks = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
<span class="s3">/**</span>
 <span class="s3">* Multiple observers can be created for multiple element/document roots. Each with</span>
 <span class="s3">* different settings. So here we store dictionaries of observers to each root,</span>
 <span class="s3">* using serialised settings (threshold/margin) as lookup keys.</span>
 <span class="s3">*/</span>
<span class="s2">const </span><span class="s1">observers = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
<span class="s2">const </span><span class="s1">fireObserverCallback = (entry) =&gt; {</span>
    <span class="s2">const </span><span class="s1">callback = observerCallbacks.get(entry.target);</span>
    <span class="s1">callback &amp;&amp; callback(entry);</span>
<span class="s1">};</span>
<span class="s2">const </span><span class="s1">fireAllObserverCallbacks = (entries) =&gt; {</span>
    <span class="s1">entries.forEach(fireObserverCallback);</span>
<span class="s1">};</span>
<span class="s2">function </span><span class="s1">initIntersectionObserver({ root, ...options }) {</span>
    <span class="s2">const </span><span class="s1">lookupRoot = root || document;</span>
    <span class="s3">/**</span>
     <span class="s3">* If we don't have an observer lookup map for this root, create one.</span>
     <span class="s3">*/</span>
    <span class="s2">if </span><span class="s1">(!observers.has(lookupRoot)) {</span>
        <span class="s1">observers.set(lookupRoot, {});</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">rootObservers = observers.get(lookupRoot);</span>
    <span class="s2">const </span><span class="s1">key = JSON.stringify(options);</span>
    <span class="s3">/**</span>
     <span class="s3">* If we don't have an observer for this combination of root and settings,</span>
     <span class="s3">* create one.</span>
     <span class="s3">*/</span>
    <span class="s2">if </span><span class="s1">(!rootObservers[key]) {</span>
        <span class="s1">rootObservers[key] = </span><span class="s2">new </span><span class="s1">IntersectionObserver(fireAllObserverCallbacks, { root, ...options });</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">rootObservers[key];</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">observeIntersection(element, options, callback) {</span>
    <span class="s2">const </span><span class="s1">rootInteresectionObserver = initIntersectionObserver(options);</span>
    <span class="s1">observerCallbacks.set(element, callback);</span>
    <span class="s1">rootInteresectionObserver.observe(element);</span>
    <span class="s2">return </span><span class="s1">() =&gt; {</span>
        <span class="s1">observerCallbacks.delete(element);</span>
        <span class="s1">rootInteresectionObserver.unobserve(element);</span>
    <span class="s1">};</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">thresholdNames = {</span>
    <span class="s1">some: </span><span class="s5">0</span><span class="s1">,</span>
    <span class="s1">all: </span><span class="s5">1</span><span class="s1">,</span>
<span class="s1">};</span>
<span class="s2">class </span><span class="s1">InViewFeature </span><span class="s2">extends </span><span class="s1">Feature {</span>
    <span class="s1">constructor() {</span>
        <span class="s2">super</span><span class="s1">(...arguments);</span>
        <span class="s2">this</span><span class="s1">.hasEnteredView = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.isInView = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">startObserver() {</span>
        <span class="s2">this</span><span class="s1">.unmount();</span>
        <span class="s2">const </span><span class="s1">{ viewport = {} } = </span><span class="s2">this</span><span class="s1">.node.getProps();</span>
        <span class="s2">const </span><span class="s1">{ root, margin: rootMargin, amount = </span><span class="s0">&quot;some&quot;</span><span class="s1">, once } = viewport;</span>
        <span class="s2">const </span><span class="s1">options = {</span>
            <span class="s1">root: root ? root.current : undefined,</span>
            <span class="s1">rootMargin,</span>
            <span class="s1">threshold: </span><span class="s2">typeof </span><span class="s1">amount === </span><span class="s0">&quot;number&quot; </span><span class="s1">? amount : thresholdNames[amount],</span>
        <span class="s1">};</span>
        <span class="s2">const </span><span class="s1">onIntersectionUpdate = (entry) =&gt; {</span>
            <span class="s2">const </span><span class="s1">{ isIntersecting } = entry;</span>
            <span class="s3">/**</span>
             <span class="s3">* If there's been no change in the viewport state, early return.</span>
             <span class="s3">*/</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.isInView === isIntersecting)</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s2">this</span><span class="s1">.isInView = isIntersecting;</span>
            <span class="s3">/**</span>
             <span class="s3">* Handle hasEnteredView. If this is only meant to run once, and</span>
             <span class="s3">* element isn't visible, early return. Otherwise set hasEnteredView to true.</span>
             <span class="s3">*/</span>
            <span class="s2">if </span><span class="s1">(once &amp;&amp; !isIntersecting &amp;&amp; </span><span class="s2">this</span><span class="s1">.hasEnteredView) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(isIntersecting) {</span>
                <span class="s2">this</span><span class="s1">.hasEnteredView = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.node.animationState) {</span>
                <span class="s2">this</span><span class="s1">.node.animationState.setActive(</span><span class="s0">&quot;whileInView&quot;</span><span class="s1">, isIntersecting);</span>
            <span class="s1">}</span>
            <span class="s3">/**</span>
             <span class="s3">* Use the latest committed props rather than the ones in scope</span>
             <span class="s3">* when this observer is created</span>
             <span class="s3">*/</span>
            <span class="s2">const </span><span class="s1">{ onViewportEnter, onViewportLeave } = </span><span class="s2">this</span><span class="s1">.node.getProps();</span>
            <span class="s2">const </span><span class="s1">callback = isIntersecting ? onViewportEnter : onViewportLeave;</span>
            <span class="s1">callback &amp;&amp; callback(entry);</span>
        <span class="s1">};</span>
        <span class="s2">return </span><span class="s1">observeIntersection(</span><span class="s2">this</span><span class="s1">.node.current, options, onIntersectionUpdate);</span>
    <span class="s1">}</span>
    <span class="s1">mount() {</span>
        <span class="s2">this</span><span class="s1">.startObserver();</span>
    <span class="s1">}</span>
    <span class="s1">update() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">IntersectionObserver === </span><span class="s0">&quot;undefined&quot;</span><span class="s1">)</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">{ props, prevProps } = </span><span class="s2">this</span><span class="s1">.node;</span>
        <span class="s2">const </span><span class="s1">hasOptionsChanged = [</span><span class="s0">&quot;amount&quot;</span><span class="s1">, </span><span class="s0">&quot;margin&quot;</span><span class="s1">, </span><span class="s0">&quot;root&quot;</span><span class="s1">].some(hasViewportOptionChanged(props, prevProps));</span>
        <span class="s2">if </span><span class="s1">(hasOptionsChanged) {</span>
            <span class="s2">this</span><span class="s1">.startObserver();</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">unmount() { }</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {</span>
    <span class="s2">return </span><span class="s1">(name) =&gt; viewport[name] !== prevViewport[name];</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">gestureAnimations = {</span>
    <span class="s1">inView: {</span>
        <span class="s1">Feature: InViewFeature,</span>
    <span class="s1">},</span>
    <span class="s1">tap: {</span>
        <span class="s1">Feature: PressGesture,</span>
    <span class="s1">},</span>
    <span class="s1">focus: {</span>
        <span class="s1">Feature: FocusGesture,</span>
    <span class="s1">},</span>
    <span class="s1">hover: {</span>
        <span class="s1">Feature: HoverGesture,</span>
    <span class="s1">},</span>
<span class="s1">};</span>

<span class="s2">const </span><span class="s1">layout = {</span>
    <span class="s1">layout: {</span>
        <span class="s1">ProjectionNode: HTMLProjectionNode,</span>
        <span class="s1">MeasureLayout,</span>
    <span class="s1">},</span>
<span class="s1">};</span>

<span class="s2">const </span><span class="s1">featureBundle = {</span>
    <span class="s1">...animations,</span>
    <span class="s1">...gestureAnimations,</span>
    <span class="s1">...drag,</span>
    <span class="s1">...layout,</span>
<span class="s1">};</span>

<span class="s1">exports.HTMLVisualElement = HTMLVisualElement;</span>
<span class="s1">exports.LayoutGroupContext = LayoutGroupContext;</span>
<span class="s1">exports.LazyContext = LazyContext;</span>
<span class="s1">exports.MotionConfigContext = MotionConfigContext;</span>
<span class="s1">exports.MotionContext = MotionContext;</span>
<span class="s1">exports.PresenceContext = PresenceContext;</span>
<span class="s1">exports.SVGVisualElement = SVGVisualElement;</span>
<span class="s1">exports.SwitchLayoutGroupContext = SwitchLayoutGroupContext;</span>
<span class="s1">exports.VisualElement = VisualElement;</span>
<span class="s1">exports.addDomEvent = addDomEvent;</span>
<span class="s1">exports.addPointerEvent = addPointerEvent;</span>
<span class="s1">exports.addPointerInfo = addPointerInfo;</span>
<span class="s1">exports.addScaleCorrector = addScaleCorrector;</span>
<span class="s1">exports.animateSingleValue = animateSingleValue;</span>
<span class="s1">exports.animateTarget = animateTarget;</span>
<span class="s1">exports.animateVisualElement = animateVisualElement;</span>
<span class="s1">exports.animations = animations;</span>
<span class="s1">exports.buildTransform = buildTransform;</span>
<span class="s1">exports.calcLength = calcLength;</span>
<span class="s1">exports.createBox = createBox;</span>
<span class="s1">exports.createDomVisualElement = createDomVisualElement;</span>
<span class="s1">exports.createMotionComponent = createMotionComponent;</span>
<span class="s1">exports.delay = delay;</span>
<span class="s1">exports.distance = distance;</span>
<span class="s1">exports.distance2D = distance2D;</span>
<span class="s1">exports.drag = drag;</span>
<span class="s1">exports.featureBundle = featureBundle;</span>
<span class="s1">exports.filterProps = filterProps;</span>
<span class="s1">exports.gestureAnimations = gestureAnimations;</span>
<span class="s1">exports.getOptimisedAppearId = getOptimisedAppearId;</span>
<span class="s1">exports.hasReducedMotionListener = hasReducedMotionListener;</span>
<span class="s1">exports.initPrefersReducedMotion = initPrefersReducedMotion;</span>
<span class="s1">exports.isBrowser = isBrowser;</span>
<span class="s1">exports.isValidMotionProp = isValidMotionProp;</span>
<span class="s1">exports.layout = layout;</span>
<span class="s1">exports.loadExternalIsValidProp = loadExternalIsValidProp;</span>
<span class="s1">exports.loadFeatures = loadFeatures;</span>
<span class="s1">exports.makeUseVisualState = makeUseVisualState;</span>
<span class="s1">exports.motionComponentSymbol = motionComponentSymbol;</span>
<span class="s1">exports.optimizedAppearDataAttribute = optimizedAppearDataAttribute;</span>
<span class="s1">exports.optimizedAppearDataId = optimizedAppearDataId;</span>
<span class="s1">exports.prefersReducedMotion = prefersReducedMotion;</span>
<span class="s1">exports.resolveMotionValue = resolveMotionValue;</span>
<span class="s1">exports.rootProjectionNode = rootProjectionNode;</span>
<span class="s1">exports.setTarget = setTarget;</span>
<span class="s1">exports.useConstant = useConstant;</span>
<span class="s1">exports.useIsPresent = useIsPresent;</span>
<span class="s1">exports.useIsomorphicLayoutEffect = useIsomorphicLayoutEffect;</span>
<span class="s1">exports.usePresence = usePresence;</span>
<span class="s1">exports.visualElementStore = visualElementStore;</span>
</pre>
</body>
</html>