<html>
<head>
<title>eslintrc.cjs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #1750eb;}
.s6 { color: #264eff;}
.s7 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
eslintrc.cjs</font>
</center></td></tr></table>
<pre><span class="s0">'use strict'</span><span class="s1">;</span>

<span class="s1">Object.defineProperty(exports, </span><span class="s0">'__esModule'</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>

<span class="s2">var </span><span class="s1">debugOrig = require(</span><span class="s0">'debug'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">fs = require(</span><span class="s0">'node:fs'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">importFresh = require(</span><span class="s0">'import-fresh'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">Module = require(</span><span class="s0">'node:module'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">path = require(</span><span class="s0">'node:path'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">stripComments = require(</span><span class="s0">'strip-json-comments'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">assert = require(</span><span class="s0">'node:assert'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">ignore = require(</span><span class="s0">'ignore'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">util = require(</span><span class="s0">'node:util'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">minimatch = require(</span><span class="s0">'minimatch'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">Ajv = require(</span><span class="s0">'ajv'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">globals = require(</span><span class="s0">'globals'</span><span class="s1">);</span>
<span class="s2">var </span><span class="s1">os = require(</span><span class="s0">'node:os'</span><span class="s1">);</span>

<span class="s2">function </span><span class="s1">_interopDefaultLegacy (e) { </span><span class="s2">return </span><span class="s1">e &amp;&amp; </span><span class="s2">typeof </span><span class="s1">e === </span><span class="s0">'object' </span><span class="s1">&amp;&amp; </span><span class="s0">'default' </span><span class="s2">in </span><span class="s1">e ? e : { </span><span class="s0">'default'</span><span class="s1">: e }; }</span>

<span class="s2">var </span><span class="s1">debugOrig__default = </span><span class="s3">/*#__PURE__*/</span><span class="s1">_interopDefaultLegacy(debugOrig);</span>
<span class="s2">var </span><span class="s1">fs__default = </span><span class="s3">/*#__PURE__*/</span><span class="s1">_interopDefaultLegacy(fs);</span>
<span class="s2">var </span><span class="s1">importFresh__default = </span><span class="s3">/*#__PURE__*/</span><span class="s1">_interopDefaultLegacy(importFresh);</span>
<span class="s2">var </span><span class="s1">Module__default = </span><span class="s3">/*#__PURE__*/</span><span class="s1">_interopDefaultLegacy(Module);</span>
<span class="s2">var </span><span class="s1">path__default = </span><span class="s3">/*#__PURE__*/</span><span class="s1">_interopDefaultLegacy(path);</span>
<span class="s2">var </span><span class="s1">stripComments__default = </span><span class="s3">/*#__PURE__*/</span><span class="s1">_interopDefaultLegacy(stripComments);</span>
<span class="s2">var </span><span class="s1">assert__default = </span><span class="s3">/*#__PURE__*/</span><span class="s1">_interopDefaultLegacy(assert);</span>
<span class="s2">var </span><span class="s1">ignore__default = </span><span class="s3">/*#__PURE__*/</span><span class="s1">_interopDefaultLegacy(ignore);</span>
<span class="s2">var </span><span class="s1">util__default = </span><span class="s3">/*#__PURE__*/</span><span class="s1">_interopDefaultLegacy(util);</span>
<span class="s2">var </span><span class="s1">minimatch__default = </span><span class="s3">/*#__PURE__*/</span><span class="s1">_interopDefaultLegacy(minimatch);</span>
<span class="s2">var </span><span class="s1">Ajv__default = </span><span class="s3">/*#__PURE__*/</span><span class="s1">_interopDefaultLegacy(Ajv);</span>
<span class="s2">var </span><span class="s1">globals__default = </span><span class="s3">/*#__PURE__*/</span><span class="s1">_interopDefaultLegacy(globals);</span>
<span class="s2">var </span><span class="s1">os__default = </span><span class="s3">/*#__PURE__*/</span><span class="s1">_interopDefaultLegacy(os);</span>

<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@fileoverview </span><span class="s3">`IgnorePattern` class.</span>
 <span class="s3">*</span>
 <span class="s3">* `IgnorePattern` class has the set of glob patterns and the base path.</span>
 <span class="s3">*</span>
 <span class="s3">* It provides two static methods.</span>
 <span class="s3">*</span>
 <span class="s3">* - `IgnorePattern.createDefaultIgnore(cwd)`</span>
 <span class="s3">*      Create the default predicate function.</span>
 <span class="s3">* - `IgnorePattern.createIgnore(ignorePatterns)`</span>
 <span class="s3">*      Create the predicate function from multiple `IgnorePattern` objects.</span>
 <span class="s3">*</span>
 <span class="s3">* It provides two properties and a method.</span>
 <span class="s3">*</span>
 <span class="s3">* - `patterns`</span>
 <span class="s3">*      The glob patterns that ignore to lint.</span>
 <span class="s3">* - `basePath`</span>
 <span class="s3">*      The base path of the glob patterns. If absolute paths existed in the</span>
 <span class="s3">*      glob patterns, those are handled as relative paths to the base path.</span>
 <span class="s3">* - `getPatternsRelativeTo(basePath)`</span>
 <span class="s3">*      Get `patterns` as modified for a given base path. It modifies the</span>
 <span class="s3">*      absolute paths in the patterns as prepending the difference of two base</span>
 <span class="s3">*      paths.</span>
 <span class="s3">*</span>
 <span class="s3">* `ConfigArrayFactory` creates `IgnorePattern` objects when it processes</span>
 <span class="s3">* `ignorePatterns` properties.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">@author </span><span class="s3">Toru Nagashima &lt;https://github.com/mysticatea&gt;</span>
 <span class="s3">*/</span>

<span class="s2">const </span><span class="s1">debug$3 = debugOrig__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">](</span><span class="s0">&quot;eslintrc:ignore-pattern&quot;</span><span class="s1">);</span>

<span class="s3">/** </span><span class="s4">@typedef </span><span class="s3">{ReturnType&lt;import(&quot;ignore&quot;).default&gt;} Ignore */</span>

<span class="s3">//------------------------------------------------------------------------------</span>
<span class="s3">// Helpers</span>
<span class="s3">//------------------------------------------------------------------------------</span>

<span class="s3">/**</span>
 <span class="s3">* Get the path to the common ancestor directory of given paths.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string[]} sourcePaths The paths to calculate the common ancestor.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{string} The path to the common ancestor directory.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">getCommonAncestorPath(sourcePaths) {</span>
    <span class="s2">let </span><span class="s1">result = sourcePaths[</span><span class="s5">0</span><span class="s1">];</span>

    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s5">1</span><span class="s1">; i &lt; sourcePaths.length; ++i) {</span>
        <span class="s2">const </span><span class="s1">a = result;</span>
        <span class="s2">const </span><span class="s1">b = sourcePaths[i];</span>

        <span class="s3">// Set the shorter one (it's the common ancestor if one includes the other).</span>
        <span class="s1">result = a.length &lt; b.length ? a : b;</span>

        <span class="s3">// Set the common ancestor.</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">j = </span><span class="s5">0</span><span class="s1">, lastSepPos = </span><span class="s5">0</span><span class="s1">; j &lt; a.length &amp;&amp; j &lt; b.length; ++j) {</span>
            <span class="s2">if </span><span class="s1">(a[j] !== b[j]) {</span>
                <span class="s1">result = a.slice(</span><span class="s5">0</span><span class="s1">, lastSepPos);</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(a[j] === path__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].sep) {</span>
                <span class="s1">lastSepPos = j;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">let </span><span class="s1">resolvedResult = result || path__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].sep;</span>

    <span class="s3">// if Windows common ancestor is root of drive must have trailing slash to be absolute.</span>
    <span class="s2">if </span><span class="s1">(resolvedResult &amp;&amp; resolvedResult.endsWith(</span><span class="s0">&quot;:&quot;</span><span class="s1">) &amp;&amp; process.platform === </span><span class="s0">&quot;win32&quot;</span><span class="s1">) {</span>
        <span class="s1">resolvedResult += path__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].sep;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">resolvedResult;</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Make relative path.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} from The source path to get relative path.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} to The destination path to get relative path.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{string} The relative path.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">relative(from, to) {</span>
    <span class="s2">const </span><span class="s1">relPath = path__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].relative(from, to);</span>

    <span class="s2">if </span><span class="s1">(path__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].sep === </span><span class="s0">&quot;/&quot;</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">relPath;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">relPath.split(path__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].sep).join(</span><span class="s0">&quot;/&quot;</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Get the trailing slash if existed.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} filePath The path to check.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{string} The trailing slash if existed.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">dirSuffix(filePath) {</span>
    <span class="s2">const </span><span class="s1">isDir = (</span>
        <span class="s1">filePath.endsWith(path__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].sep) ||</span>
        <span class="s1">(process.platform === </span><span class="s0">&quot;win32&quot; </span><span class="s1">&amp;&amp; filePath.endsWith(</span><span class="s0">&quot;/&quot;</span><span class="s1">))</span>
    <span class="s1">);</span>

    <span class="s2">return </span><span class="s1">isDir ? </span><span class="s0">&quot;/&quot; </span><span class="s1">: </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">DefaultPatterns = Object.freeze([</span><span class="s0">&quot;/**/node_modules/*&quot;</span><span class="s1">]);</span>
<span class="s2">const </span><span class="s1">DotPatterns = Object.freeze([</span><span class="s0">&quot;.*&quot;</span><span class="s1">, </span><span class="s0">&quot;!.eslintrc.*&quot;</span><span class="s1">, </span><span class="s0">&quot;!../&quot;</span><span class="s1">]);</span>

<span class="s3">//------------------------------------------------------------------------------</span>
<span class="s3">// Public</span>
<span class="s3">//------------------------------------------------------------------------------</span>

<span class="s3">/**</span>
 <span class="s3">* Represents a set of glob patterns to ignore against a base path.</span>
 <span class="s3">*/</span>
<span class="s2">class </span><span class="s1">IgnorePattern {</span>

    <span class="s3">/**</span>
     <span class="s3">* The default patterns.</span>
     <span class="s3">* </span><span class="s4">@type </span><span class="s3">{string[]}</span>
     <span class="s3">*/</span>
    <span class="s2">static </span><span class="s1">get DefaultPatterns() {</span>
        <span class="s2">return </span><span class="s1">DefaultPatterns;</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Create the default predicate function.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} cwd The current working directory.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{((filePath:string, dot:boolean) =&gt; boolean) &amp; {basePath:string; patterns:string[]}}</span>
     <span class="s3">* The preficate function.</span>
     <span class="s3">* The first argument is an absolute path that is checked.</span>
     <span class="s3">* The second argument is the flag to not ignore dotfiles.</span>
     <span class="s3">* If the predicate function returned `true`, it means the path should be ignored.</span>
     <span class="s3">*/</span>
    <span class="s2">static </span><span class="s1">createDefaultIgnore(cwd) {</span>
        <span class="s2">return this</span><span class="s1">.createIgnore([</span><span class="s2">new </span><span class="s1">IgnorePattern(DefaultPatterns, cwd)]);</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Create the predicate function from multiple `IgnorePattern` objects.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{IgnorePattern[]} ignorePatterns The list of ignore patterns.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{((filePath:string, dot?:boolean) =&gt; boolean) &amp; {basePath:string; patterns:string[]}}</span>
     <span class="s3">* The preficate function.</span>
     <span class="s3">* The first argument is an absolute path that is checked.</span>
     <span class="s3">* The second argument is the flag to not ignore dotfiles.</span>
     <span class="s3">* If the predicate function returned `true`, it means the path should be ignored.</span>
     <span class="s3">*/</span>
    <span class="s2">static </span><span class="s1">createIgnore(ignorePatterns) {</span>
        <span class="s1">debug$3(</span><span class="s0">&quot;Create with: %o&quot;</span><span class="s1">, ignorePatterns);</span>

        <span class="s2">const </span><span class="s1">basePath = getCommonAncestorPath(ignorePatterns.map(p =&gt; p.basePath));</span>
        <span class="s2">const </span><span class="s1">patterns = ignorePatterns.flatMap(p =&gt; p.getPatternsRelativeTo(basePath));</span>
        <span class="s2">const </span><span class="s1">ig = ignore__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">]({ allowRelativePaths: </span><span class="s2">true </span><span class="s1">}).add([...DotPatterns, ...patterns]);</span>
        <span class="s2">const </span><span class="s1">dotIg = ignore__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">]({ allowRelativePaths: </span><span class="s2">true </span><span class="s1">}).add(patterns);</span>

        <span class="s1">debug$3(</span><span class="s0">&quot;  processed: %o&quot;</span><span class="s1">, { basePath, patterns });</span>

        <span class="s2">return </span><span class="s1">Object.assign(</span>
            <span class="s1">(filePath, dot = </span><span class="s2">false</span><span class="s1">) =&gt; {</span>
                <span class="s1">assert__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">](path__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].isAbsolute(filePath), </span><span class="s0">&quot;'filePath' should be an absolute path.&quot;</span><span class="s1">);</span>
                <span class="s2">const </span><span class="s1">relPathRaw = relative(basePath, filePath);</span>
                <span class="s2">const </span><span class="s1">relPath = relPathRaw &amp;&amp; (relPathRaw + dirSuffix(filePath));</span>
                <span class="s2">const </span><span class="s1">adoptedIg = dot ? dotIg : ig;</span>
                <span class="s2">const </span><span class="s1">result = relPath !== </span><span class="s0">&quot;&quot; </span><span class="s1">&amp;&amp; adoptedIg.ignores(relPath);</span>

                <span class="s1">debug$3(</span><span class="s0">&quot;Check&quot;</span><span class="s1">, { filePath, dot, relativePath: relPath, result });</span>
                <span class="s2">return </span><span class="s1">result;</span>
            <span class="s1">},</span>
            <span class="s1">{ basePath, patterns }</span>
        <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Initialize a new `IgnorePattern` instance.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string[]} patterns The glob patterns that ignore to lint.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} basePath The base path of `patterns`.</span>
     <span class="s3">*/</span>
    <span class="s1">constructor(patterns, basePath) {</span>
        <span class="s1">assert__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">](path__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].isAbsolute(basePath), </span><span class="s0">&quot;'basePath' should be an absolute path.&quot;</span><span class="s1">);</span>

        <span class="s3">/**</span>
         <span class="s3">* The glob patterns that ignore to lint.</span>
         <span class="s3">* </span><span class="s4">@type </span><span class="s3">{string[]}</span>
         <span class="s3">*/</span>
        <span class="s2">this</span><span class="s1">.patterns = patterns;</span>

        <span class="s3">/**</span>
         <span class="s3">* The base path of `patterns`.</span>
         <span class="s3">* </span><span class="s4">@type </span><span class="s3">{string}</span>
         <span class="s3">*/</span>
        <span class="s2">this</span><span class="s1">.basePath = basePath;</span>

        <span class="s3">/**</span>
         <span class="s3">* If `true` then patterns which don't start with `/` will match the paths to the outside of `basePath`. Defaults to `false`.</span>
         <span class="s3">*</span>
         <span class="s3">* It's set `true` for `.eslintignore`, `package.json`, and `--ignore-path` for backward compatibility.</span>
         <span class="s3">* It's `false` as-is for `ignorePatterns` property in config files.</span>
         <span class="s3">* </span><span class="s4">@type </span><span class="s3">{boolean}</span>
         <span class="s3">*/</span>
        <span class="s2">this</span><span class="s1">.loose = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Get `patterns` as modified for a given base path. It modifies the</span>
     <span class="s3">* absolute paths in the patterns as prepending the difference of two base</span>
     <span class="s3">* paths.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} newBasePath The base path.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{string[]} Modifired patterns.</span>
     <span class="s3">*/</span>
    <span class="s1">getPatternsRelativeTo(newBasePath) {</span>
        <span class="s1">assert__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">](path__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].isAbsolute(newBasePath), </span><span class="s0">&quot;'newBasePath' should be an absolute path.&quot;</span><span class="s1">);</span>
        <span class="s2">const </span><span class="s1">{ basePath, loose, patterns } = </span><span class="s2">this</span><span class="s1">;</span>

        <span class="s2">if </span><span class="s1">(newBasePath === basePath) {</span>
            <span class="s2">return </span><span class="s1">patterns;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">prefix = </span><span class="s0">`/</span><span class="s1">${relative(newBasePath, basePath)}</span><span class="s0">`</span><span class="s1">;</span>

        <span class="s2">return </span><span class="s1">patterns.map(pattern =&gt; {</span>
            <span class="s2">const </span><span class="s1">negative = pattern.startsWith(</span><span class="s0">&quot;!&quot;</span><span class="s1">);</span>
            <span class="s2">const </span><span class="s1">head = negative ? </span><span class="s0">&quot;!&quot; </span><span class="s1">: </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
            <span class="s2">const </span><span class="s1">body = negative ? pattern.slice(</span><span class="s5">1</span><span class="s1">) : pattern;</span>

            <span class="s2">if </span><span class="s1">(body.startsWith(</span><span class="s0">&quot;/&quot;</span><span class="s1">) || body.startsWith(</span><span class="s0">&quot;../&quot;</span><span class="s1">)) {</span>
                <span class="s2">return </span><span class="s0">`</span><span class="s1">${head}${prefix}${body}</span><span class="s0">`</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">loose ? pattern : </span><span class="s0">`</span><span class="s1">${head}${prefix}</span><span class="s0">/**/</span><span class="s1">${body}</span><span class="s0">`</span><span class="s1">;</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@fileoverview </span><span class="s3">`ExtractedConfig` class.</span>
 <span class="s3">*</span>
 <span class="s3">* `ExtractedConfig` class expresses a final configuration for a specific file.</span>
 <span class="s3">*</span>
 <span class="s3">* It provides one method.</span>
 <span class="s3">*</span>
 <span class="s3">* - `toCompatibleObjectAsConfigFileContent()`</span>
 <span class="s3">*      Convert this configuration to the compatible object as the content of</span>
 <span class="s3">*      config files. It converts the loaded parser and plugins to strings.</span>
 <span class="s3">*      `CLIEngine#getConfigForFile(filePath)` method uses this method.</span>
 <span class="s3">*</span>
 <span class="s3">* `ConfigArray#extractConfig(filePath)` creates a `ExtractedConfig` instance.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">@author </span><span class="s3">Toru Nagashima &lt;https://github.com/mysticatea&gt;</span>
 <span class="s3">*/</span>

<span class="s3">// For VSCode intellisense</span>
<span class="s3">/** </span><span class="s4">@typedef </span><span class="s3">{import(&quot;../../shared/types&quot;).ConfigData} ConfigData */</span>
<span class="s3">/** </span><span class="s4">@typedef </span><span class="s3">{import(&quot;../../shared/types&quot;).GlobalConf} GlobalConf */</span>
<span class="s3">/** </span><span class="s4">@typedef </span><span class="s3">{import(&quot;../../shared/types&quot;).SeverityConf} SeverityConf */</span>
<span class="s3">/** </span><span class="s4">@typedef </span><span class="s3">{import(&quot;./config-dependency&quot;).DependentParser} DependentParser */</span>
<span class="s3">/** </span><span class="s4">@typedef </span><span class="s3">{import(&quot;./config-dependency&quot;).DependentPlugin} DependentPlugin */</span>

<span class="s3">/**</span>
 <span class="s3">* Check if `xs` starts with `ys`.</span>
 <span class="s3">* </span><span class="s4">@template </span><span class="s3">T</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{T[]} xs The array to check.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{T[]} ys The array that may be the first part of `xs`.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{boolean} `true` if `xs` starts with `ys`.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">startsWith(xs, ys) {</span>
    <span class="s2">return </span><span class="s1">xs.length &gt;= ys.length &amp;&amp; ys.every((y, i) =&gt; y === xs[i]);</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* The class for extracted config data.</span>
 <span class="s3">*/</span>
<span class="s2">class </span><span class="s1">ExtractedConfig {</span>
    <span class="s1">constructor() {</span>

        <span class="s3">/**</span>
         <span class="s3">* The config name what `noInlineConfig` setting came from.</span>
         <span class="s3">* </span><span class="s4">@type </span><span class="s3">{string}</span>
         <span class="s3">*/</span>
        <span class="s2">this</span><span class="s1">.configNameOfNoInlineConfig = </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>

        <span class="s3">/**</span>
         <span class="s3">* Environments.</span>
         <span class="s3">* </span><span class="s4">@type </span><span class="s3">{Record&lt;string, boolean&gt;}</span>
         <span class="s3">*/</span>
        <span class="s2">this</span><span class="s1">.env = {};</span>

        <span class="s3">/**</span>
         <span class="s3">* Global variables.</span>
         <span class="s3">* </span><span class="s4">@type </span><span class="s3">{Record&lt;string, GlobalConf&gt;}</span>
         <span class="s3">*/</span>
        <span class="s2">this</span><span class="s1">.globals = {};</span>

        <span class="s3">/**</span>
         <span class="s3">* The glob patterns that ignore to lint.</span>
         <span class="s3">* </span><span class="s4">@type </span><span class="s3">{(((filePath:string, dot?:boolean) =&gt; boolean) &amp; { basePath:string; patterns:string[] }) | undefined}</span>
         <span class="s3">*/</span>
        <span class="s2">this</span><span class="s1">.ignores = </span><span class="s2">void </span><span class="s5">0</span><span class="s1">;</span>

        <span class="s3">/**</span>
         <span class="s3">* The flag that disables directive comments.</span>
         <span class="s3">* </span><span class="s4">@type </span><span class="s3">{boolean|undefined}</span>
         <span class="s3">*/</span>
        <span class="s2">this</span><span class="s1">.noInlineConfig = </span><span class="s2">void </span><span class="s5">0</span><span class="s1">;</span>

        <span class="s3">/**</span>
         <span class="s3">* Parser definition.</span>
         <span class="s3">* </span><span class="s4">@type </span><span class="s3">{DependentParser|null}</span>
         <span class="s3">*/</span>
        <span class="s2">this</span><span class="s1">.parser = </span><span class="s2">null</span><span class="s1">;</span>

        <span class="s3">/**</span>
         <span class="s3">* Options for the parser.</span>
         <span class="s3">* </span><span class="s4">@type </span><span class="s3">{Object}</span>
         <span class="s3">*/</span>
        <span class="s2">this</span><span class="s1">.parserOptions = {};</span>

        <span class="s3">/**</span>
         <span class="s3">* Plugin definitions.</span>
         <span class="s3">* </span><span class="s4">@type </span><span class="s3">{Record&lt;string, DependentPlugin&gt;}</span>
         <span class="s3">*/</span>
        <span class="s2">this</span><span class="s1">.plugins = {};</span>

        <span class="s3">/**</span>
         <span class="s3">* Processor ID.</span>
         <span class="s3">* </span><span class="s4">@type </span><span class="s3">{string|null}</span>
         <span class="s3">*/</span>
        <span class="s2">this</span><span class="s1">.processor = </span><span class="s2">null</span><span class="s1">;</span>

        <span class="s3">/**</span>
         <span class="s3">* The flag that reports unused `eslint-disable` directive comments.</span>
         <span class="s3">* </span><span class="s4">@type </span><span class="s3">{boolean|undefined}</span>
         <span class="s3">*/</span>
        <span class="s2">this</span><span class="s1">.reportUnusedDisableDirectives = </span><span class="s2">void </span><span class="s5">0</span><span class="s1">;</span>

        <span class="s3">/**</span>
         <span class="s3">* Rule settings.</span>
         <span class="s3">* </span><span class="s4">@type </span><span class="s3">{Record&lt;string, [SeverityConf, ...any[]]&gt;}</span>
         <span class="s3">*/</span>
        <span class="s2">this</span><span class="s1">.rules = {};</span>

        <span class="s3">/**</span>
         <span class="s3">* Shared settings.</span>
         <span class="s3">* </span><span class="s4">@type </span><span class="s3">{Object}</span>
         <span class="s3">*/</span>
        <span class="s2">this</span><span class="s1">.settings = {};</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Convert this config to the compatible object as a config file content.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{ConfigData} The converted object.</span>
     <span class="s3">*/</span>
    <span class="s1">toCompatibleObjectAsConfigFileContent() {</span>
        <span class="s2">const </span><span class="s1">{</span>
            <span class="s3">/* eslint-disable no-unused-vars -- needed to make `config` correct */</span>
            <span class="s1">configNameOfNoInlineConfig: _ignore1,</span>
            <span class="s1">processor: _ignore2,</span>
            <span class="s3">/* eslint-enable no-unused-vars -- needed to make `config` correct */</span>
            <span class="s1">ignores,</span>
            <span class="s1">...config</span>
        <span class="s1">} = </span><span class="s2">this</span><span class="s1">;</span>

        <span class="s1">config.parser = config.parser &amp;&amp; config.parser.filePath;</span>
        <span class="s1">config.plugins = Object.keys(config.plugins).filter(Boolean).reverse();</span>
        <span class="s1">config.ignorePatterns = ignores ? ignores.patterns : [];</span>

        <span class="s3">// Strip the default patterns from `ignorePatterns`.</span>
        <span class="s2">if </span><span class="s1">(startsWith(config.ignorePatterns, IgnorePattern.DefaultPatterns)) {</span>
            <span class="s1">config.ignorePatterns =</span>
                <span class="s1">config.ignorePatterns.slice(IgnorePattern.DefaultPatterns.length);</span>
        <span class="s1">}</span>

        <span class="s2">return </span><span class="s1">config;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@fileoverview </span><span class="s3">`ConfigArray` class.</span>
 <span class="s3">*</span>
 <span class="s3">* `ConfigArray` class expresses the full of a configuration. It has the entry</span>
 <span class="s3">* config file, base config files that were extended, loaded parsers, and loaded</span>
 <span class="s3">* plugins.</span>
 <span class="s3">*</span>
 <span class="s3">* `ConfigArray` class provides three properties and two methods.</span>
 <span class="s3">*</span>
 <span class="s3">* - `pluginEnvironments`</span>
 <span class="s3">* - `pluginProcessors`</span>
 <span class="s3">* - `pluginRules`</span>
 <span class="s3">*      The `Map` objects that contain the members of all plugins that this</span>
 <span class="s3">*      config array contains. Those map objects don't have mutation methods.</span>
 <span class="s3">*      Those keys are the member ID such as `pluginId/memberName`.</span>
 <span class="s3">* - `isRoot()`</span>
 <span class="s3">*      If `true` then this configuration has `root:true` property.</span>
 <span class="s3">* - `extractConfig(filePath)`</span>
 <span class="s3">*      Extract the final configuration for a given file. This means merging</span>
 <span class="s3">*      every config array element which that `criteria` property matched. The</span>
 <span class="s3">*      `filePath` argument must be an absolute path.</span>
 <span class="s3">*</span>
 <span class="s3">* `ConfigArrayFactory` provides the loading logic of config files.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">@author </span><span class="s3">Toru Nagashima &lt;https://github.com/mysticatea&gt;</span>
 <span class="s3">*/</span>

<span class="s3">//------------------------------------------------------------------------------</span>
<span class="s3">// Helpers</span>
<span class="s3">//------------------------------------------------------------------------------</span>

<span class="s3">// Define types for VSCode IntelliSense.</span>
<span class="s3">/** </span><span class="s4">@typedef </span><span class="s3">{import(&quot;../../shared/types&quot;).Environment} Environment */</span>
<span class="s3">/** </span><span class="s4">@typedef </span><span class="s3">{import(&quot;../../shared/types&quot;).GlobalConf} GlobalConf */</span>
<span class="s3">/** </span><span class="s4">@typedef </span><span class="s3">{import(&quot;../../shared/types&quot;).RuleConf} RuleConf */</span>
<span class="s3">/** </span><span class="s4">@typedef </span><span class="s3">{import(&quot;../../shared/types&quot;).Rule} Rule */</span>
<span class="s3">/** </span><span class="s4">@typedef </span><span class="s3">{import(&quot;../../shared/types&quot;).Plugin} Plugin */</span>
<span class="s3">/** </span><span class="s4">@typedef </span><span class="s3">{import(&quot;../../shared/types&quot;).Processor} Processor */</span>
<span class="s3">/** </span><span class="s4">@typedef </span><span class="s3">{import(&quot;./config-dependency&quot;).DependentParser} DependentParser */</span>
<span class="s3">/** </span><span class="s4">@typedef </span><span class="s3">{import(&quot;./config-dependency&quot;).DependentPlugin} DependentPlugin */</span>
<span class="s3">/** </span><span class="s4">@typedef </span><span class="s3">{import(&quot;./override-tester&quot;)[&quot;OverrideTester&quot;]} OverrideTester */</span>

<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@typedef </span><span class="s3">{Object} ConfigArrayElement</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{string} name The name of this config element.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{string} filePath The path to the source file of this config element.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{InstanceType&lt;OverrideTester&gt;|null} criteria The tester for the `files` and `excludedFiles` of this config element.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{Record&lt;string, boolean&gt;|undefined} env The environment settings.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{Record&lt;string, GlobalConf&gt;|undefined} globals The global variable settings.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{IgnorePattern|undefined} ignorePattern The ignore patterns.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{boolean|undefined} noInlineConfig The flag that disables directive comments.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{DependentParser|undefined} parser The parser loader.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{Object|undefined} parserOptions The parser options.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{Record&lt;string, DependentPlugin&gt;|undefined} plugins The plugin loaders.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{string|undefined} processor The processor name to refer plugin's processor.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{boolean|undefined} reportUnusedDisableDirectives The flag to report unused `eslint-disable` comments.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{boolean|undefined} root The flag to express root.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{Record&lt;string, RuleConf&gt;|undefined} rules The rule settings</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{Object|undefined} settings The shared settings.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{&quot;config&quot; | &quot;ignore&quot; | &quot;implicit-processor&quot;} type The element type.</span>
 <span class="s3">*/</span>

<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@typedef </span><span class="s3">{Object} ConfigArrayInternalSlots</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{Map&lt;string, ExtractedConfig&gt;} cache The cache to extract configs.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{ReadonlyMap&lt;string, Environment&gt;|null} envMap The map from environment ID to environment definition.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{ReadonlyMap&lt;string, Processor&gt;|null} processorMap The map from processor ID to environment definition.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{ReadonlyMap&lt;string, Rule&gt;|null} ruleMap The map from rule ID to rule definition.</span>
 <span class="s3">*/</span>

<span class="s3">/** </span><span class="s4">@type </span><span class="s3">{WeakMap&lt;ConfigArray, ConfigArrayInternalSlots&gt;} */</span>
<span class="s2">const </span><span class="s1">internalSlotsMap$2 = </span><span class="s2">new class extends </span><span class="s1">WeakMap {</span>
    <span class="s1">get(key) {</span>
        <span class="s2">let </span><span class="s1">value = </span><span class="s2">super</span><span class="s1">.get(key);</span>

        <span class="s2">if </span><span class="s1">(!value) {</span>
            <span class="s1">value = {</span>
                <span class="s1">cache: </span><span class="s2">new </span><span class="s1">Map(),</span>
                <span class="s1">envMap: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">processorMap: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">ruleMap: </span><span class="s2">null</span>
            <span class="s1">};</span>
            <span class="s2">super</span><span class="s1">.set(key, value);</span>
        <span class="s1">}</span>

        <span class="s2">return </span><span class="s1">value;</span>
    <span class="s1">}</span>
<span class="s1">}();</span>

<span class="s3">/**</span>
 <span class="s3">* Get the indices which are matched to a given file.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{ConfigArrayElement[]} elements The elements.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} filePath The path to a target file.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{number[]} The indices.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">getMatchedIndices(elements, filePath) {</span>
    <span class="s2">const </span><span class="s1">indices = [];</span>

    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = elements.length - </span><span class="s5">1</span><span class="s1">; i &gt;= </span><span class="s5">0</span><span class="s1">; --i) {</span>
        <span class="s2">const </span><span class="s1">element = elements[i];</span>

        <span class="s2">if </span><span class="s1">(!element.criteria || (filePath &amp;&amp; element.criteria.test(filePath))) {</span>
            <span class="s1">indices.push(i);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">indices;</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Check if a value is a non-null object.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{any} x The value to check.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{boolean} `true` if the value is a non-null object.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">isNonNullObject(x) {</span>
    <span class="s2">return typeof </span><span class="s1">x === </span><span class="s0">&quot;object&quot; </span><span class="s1">&amp;&amp; x !== </span><span class="s2">null</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Merge two objects.</span>
 <span class="s3">*</span>
 <span class="s3">* Assign every property values of `y` to `x` if `x` doesn't have the property.</span>
 <span class="s3">* If `x`'s property value is an object, it does recursive.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} target The destination to merge</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object|undefined} source The source to merge.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{void}</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">mergeWithoutOverwrite(target, source) {</span>
    <span class="s2">if </span><span class="s1">(!isNonNullObject(source)) {</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key of Object.keys(source)) {</span>
        <span class="s2">if </span><span class="s1">(key === </span><span class="s0">&quot;__proto__&quot;</span><span class="s1">) {</span>
            <span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(isNonNullObject(target[key])) {</span>
            <span class="s1">mergeWithoutOverwrite(target[key], source[key]);</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(target[key] === </span><span class="s2">void </span><span class="s5">0</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(isNonNullObject(source[key])) {</span>
                <span class="s1">target[key] = Array.isArray(source[key]) ? [] : {};</span>
                <span class="s1">mergeWithoutOverwrite(target[key], source[key]);</span>
            <span class="s1">} </span><span class="s2">else if </span><span class="s1">(source[key] !== </span><span class="s2">void </span><span class="s5">0</span><span class="s1">) {</span>
                <span class="s1">target[key] = source[key];</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* The error for plugin conflicts.</span>
 <span class="s3">*/</span>
<span class="s2">class </span><span class="s1">PluginConflictError </span><span class="s2">extends </span><span class="s1">Error {</span>

    <span class="s3">/**</span>
     <span class="s3">* Initialize this error object.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} pluginId The plugin ID.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{{filePath:string, importerName:string}[]} plugins The resolved plugins.</span>
     <span class="s3">*/</span>
    <span class="s1">constructor(pluginId, plugins) {</span>
        <span class="s2">super</span><span class="s1">(</span><span class="s0">`Plugin &quot;</span><span class="s1">${pluginId}</span><span class="s0">&quot; was conflicted between </span><span class="s1">${plugins.map(p =&gt; </span><span class="s0">`&quot;</span><span class="s1">${p.importerName}</span><span class="s0">&quot;`</span><span class="s1">).join(</span><span class="s0">&quot; and &quot;</span><span class="s1">)}</span><span class="s0">.`</span><span class="s1">);</span>
        <span class="s2">this</span><span class="s1">.messageTemplate = </span><span class="s0">&quot;plugin-conflict&quot;</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.messageData = { pluginId, plugins };</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Merge plugins.</span>
 <span class="s3">* `target`'s definition is prior to `source`'s.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Record&lt;string, DependentPlugin&gt;} target The destination to merge</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Record&lt;string, DependentPlugin&gt;|undefined} source The source to merge.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{void}</span>
 <span class="s3">* </span><span class="s4">@throws </span><span class="s3">{PluginConflictError} When a plugin was conflicted.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">mergePlugins(target, source) {</span>
    <span class="s2">if </span><span class="s1">(!isNonNullObject(source)) {</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key of Object.keys(source)) {</span>
        <span class="s2">if </span><span class="s1">(key === </span><span class="s0">&quot;__proto__&quot;</span><span class="s1">) {</span>
            <span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">targetValue = target[key];</span>
        <span class="s2">const </span><span class="s1">sourceValue = source[key];</span>

        <span class="s3">// Adopt the plugin which was found at first.</span>
        <span class="s2">if </span><span class="s1">(targetValue === </span><span class="s2">void </span><span class="s5">0</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(sourceValue.error) {</span>
                <span class="s2">throw </span><span class="s1">sourceValue.error;</span>
            <span class="s1">}</span>
            <span class="s1">target[key] = sourceValue;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(sourceValue.filePath !== targetValue.filePath) {</span>
            <span class="s2">throw new </span><span class="s1">PluginConflictError(key, [</span>
                <span class="s1">{</span>
                    <span class="s1">filePath: targetValue.filePath,</span>
                    <span class="s1">importerName: targetValue.importerName</span>
                <span class="s1">},</span>
                <span class="s1">{</span>
                    <span class="s1">filePath: sourceValue.filePath,</span>
                    <span class="s1">importerName: sourceValue.importerName</span>
                <span class="s1">}</span>
            <span class="s1">]);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Merge rule configs.</span>
 <span class="s3">* `target`'s definition is prior to `source`'s.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Record&lt;string, Array&gt;} target The destination to merge</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Record&lt;string, RuleConf&gt;|undefined} source The source to merge.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{void}</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">mergeRuleConfigs(target, source) {</span>
    <span class="s2">if </span><span class="s1">(!isNonNullObject(source)) {</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key of Object.keys(source)) {</span>
        <span class="s2">if </span><span class="s1">(key === </span><span class="s0">&quot;__proto__&quot;</span><span class="s1">) {</span>
            <span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">targetDef = target[key];</span>
        <span class="s2">const </span><span class="s1">sourceDef = source[key];</span>

        <span class="s3">// Adopt the rule config which was found at first.</span>
        <span class="s2">if </span><span class="s1">(targetDef === </span><span class="s2">void </span><span class="s5">0</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(Array.isArray(sourceDef)) {</span>
                <span class="s1">target[key] = [...sourceDef];</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">target[key] = [sourceDef];</span>
            <span class="s1">}</span>

        <span class="s3">/* 
         * If the first found rule config is severity only and the current rule 
         * config has options, merge the severity and the options. 
         */</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span>
            <span class="s1">targetDef.length === </span><span class="s5">1 </span><span class="s1">&amp;&amp;</span>
            <span class="s1">Array.isArray(sourceDef) &amp;&amp;</span>
            <span class="s1">sourceDef.length &gt;= </span><span class="s5">2</span>
        <span class="s1">) {</span>
            <span class="s1">targetDef.push(...sourceDef.slice(</span><span class="s5">1</span><span class="s1">));</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Create the extracted config.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{ConfigArray} instance The config elements.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{number[]} indices The indices to use.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{ExtractedConfig} The extracted config.</span>
 <span class="s3">* </span><span class="s4">@throws </span><span class="s3">{Error} When a plugin is conflicted.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">createConfig(instance, indices) {</span>
    <span class="s2">const </span><span class="s1">config = </span><span class="s2">new </span><span class="s1">ExtractedConfig();</span>
    <span class="s2">const </span><span class="s1">ignorePatterns = [];</span>

    <span class="s3">// Merge elements.</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">index of indices) {</span>
        <span class="s2">const </span><span class="s1">element = instance[index];</span>

        <span class="s3">// Adopt the parser which was found at first.</span>
        <span class="s2">if </span><span class="s1">(!config.parser &amp;&amp; element.parser) {</span>
            <span class="s2">if </span><span class="s1">(element.parser.error) {</span>
                <span class="s2">throw </span><span class="s1">element.parser.error;</span>
            <span class="s1">}</span>
            <span class="s1">config.parser = element.parser;</span>
        <span class="s1">}</span>

        <span class="s3">// Adopt the processor which was found at first.</span>
        <span class="s2">if </span><span class="s1">(!config.processor &amp;&amp; element.processor) {</span>
            <span class="s1">config.processor = element.processor;</span>
        <span class="s1">}</span>

        <span class="s3">// Adopt the noInlineConfig which was found at first.</span>
        <span class="s2">if </span><span class="s1">(config.noInlineConfig === </span><span class="s2">void </span><span class="s5">0 </span><span class="s1">&amp;&amp; element.noInlineConfig !== </span><span class="s2">void </span><span class="s5">0</span><span class="s1">) {</span>
            <span class="s1">config.noInlineConfig = element.noInlineConfig;</span>
            <span class="s1">config.configNameOfNoInlineConfig = element.name;</span>
        <span class="s1">}</span>

        <span class="s3">// Adopt the reportUnusedDisableDirectives which was found at first.</span>
        <span class="s2">if </span><span class="s1">(config.reportUnusedDisableDirectives === </span><span class="s2">void </span><span class="s5">0 </span><span class="s1">&amp;&amp; element.reportUnusedDisableDirectives !== </span><span class="s2">void </span><span class="s5">0</span><span class="s1">) {</span>
            <span class="s1">config.reportUnusedDisableDirectives = element.reportUnusedDisableDirectives;</span>
        <span class="s1">}</span>

        <span class="s3">// Collect ignorePatterns</span>
        <span class="s2">if </span><span class="s1">(element.ignorePattern) {</span>
            <span class="s1">ignorePatterns.push(element.ignorePattern);</span>
        <span class="s1">}</span>

        <span class="s3">// Merge others.</span>
        <span class="s1">mergeWithoutOverwrite(config.env, element.env);</span>
        <span class="s1">mergeWithoutOverwrite(config.globals, element.globals);</span>
        <span class="s1">mergeWithoutOverwrite(config.parserOptions, element.parserOptions);</span>
        <span class="s1">mergeWithoutOverwrite(config.settings, element.settings);</span>
        <span class="s1">mergePlugins(config.plugins, element.plugins);</span>
        <span class="s1">mergeRuleConfigs(config.rules, element.rules);</span>
    <span class="s1">}</span>

    <span class="s3">// Create the predicate function for ignore patterns.</span>
    <span class="s2">if </span><span class="s1">(ignorePatterns.length &gt; </span><span class="s5">0</span><span class="s1">) {</span>
        <span class="s1">config.ignores = IgnorePattern.createIgnore(ignorePatterns.reverse());</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">config;</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Collect definitions.</span>
 <span class="s3">* </span><span class="s4">@template </span><span class="s3">T, U</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} pluginId The plugin ID for prefix.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Record&lt;string,T&gt;} defs The definitions to collect.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Map&lt;string, U&gt;} map The map to output.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{void}</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">collect(pluginId, defs, map) {</span>
    <span class="s2">if </span><span class="s1">(defs) {</span>
        <span class="s2">const </span><span class="s1">prefix = pluginId &amp;&amp; </span><span class="s0">`</span><span class="s1">${pluginId}</span><span class="s0">/`</span><span class="s1">;</span>

        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[key, value] of Object.entries(defs)) {</span>
            <span class="s1">map.set(</span><span class="s0">`</span><span class="s1">${prefix}${key}</span><span class="s0">`</span><span class="s1">, value);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Delete the mutation methods from a given map.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Map&lt;any, any&gt;} map The map object to delete.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{void}</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">deleteMutationMethods(map) {</span>
    <span class="s1">Object.defineProperties(map, {</span>
        <span class="s1">clear: { configurable: </span><span class="s2">true</span><span class="s1">, value: </span><span class="s2">void </span><span class="s5">0 </span><span class="s1">},</span>
        <span class="s2">delete</span><span class="s1">: { configurable: </span><span class="s2">true</span><span class="s1">, value: </span><span class="s2">void </span><span class="s5">0 </span><span class="s1">},</span>
        <span class="s1">set: { configurable: </span><span class="s2">true</span><span class="s1">, value: </span><span class="s2">void </span><span class="s5">0 </span><span class="s1">}</span>
    <span class="s1">});</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Create `envMap`, `processorMap`, `ruleMap` with the plugins in the config array.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{ConfigArrayElement[]} elements The config elements.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{ConfigArrayInternalSlots} slots The internal slots.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{void}</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">initPluginMemberMaps(elements, slots) {</span>
    <span class="s2">const </span><span class="s1">processed = </span><span class="s2">new </span><span class="s1">Set();</span>

    <span class="s1">slots.envMap = </span><span class="s2">new </span><span class="s1">Map();</span>
    <span class="s1">slots.processorMap = </span><span class="s2">new </span><span class="s1">Map();</span>
    <span class="s1">slots.ruleMap = </span><span class="s2">new </span><span class="s1">Map();</span>

    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">element of elements) {</span>
        <span class="s2">if </span><span class="s1">(!element.plugins) {</span>
            <span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[pluginId, value] of Object.entries(element.plugins)) {</span>
            <span class="s2">const </span><span class="s1">plugin = value.definition;</span>

            <span class="s2">if </span><span class="s1">(!plugin || processed.has(pluginId)) {</span>
                <span class="s2">continue</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">processed.add(pluginId);</span>

            <span class="s1">collect(pluginId, plugin.environments, slots.envMap);</span>
            <span class="s1">collect(pluginId, plugin.processors, slots.processorMap);</span>
            <span class="s1">collect(pluginId, plugin.rules, slots.ruleMap);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">deleteMutationMethods(slots.envMap);</span>
    <span class="s1">deleteMutationMethods(slots.processorMap);</span>
    <span class="s1">deleteMutationMethods(slots.ruleMap);</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Create `envMap`, `processorMap`, `ruleMap` with the plugins in the config array.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{ConfigArray} instance The config elements.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{ConfigArrayInternalSlots} The extracted config.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">ensurePluginMemberMaps(instance) {</span>
    <span class="s2">const </span><span class="s1">slots = internalSlotsMap$2.get(instance);</span>

    <span class="s2">if </span><span class="s1">(!slots.ruleMap) {</span>
        <span class="s1">initPluginMemberMaps(instance, slots);</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">slots;</span>
<span class="s1">}</span>

<span class="s3">//------------------------------------------------------------------------------</span>
<span class="s3">// Public Interface</span>
<span class="s3">//------------------------------------------------------------------------------</span>

<span class="s3">/**</span>
 <span class="s3">* The Config Array.</span>
 <span class="s3">*</span>
 <span class="s3">* `ConfigArray` instance contains all settings, parsers, and plugins.</span>
 <span class="s3">* You need to call `ConfigArray#extractConfig(filePath)` method in order to</span>
 <span class="s3">* extract, merge and get only the config data which is related to an arbitrary</span>
 <span class="s3">* file.</span>
 <span class="s3">* </span><span class="s4">@extends </span><span class="s3">{Array&lt;ConfigArrayElement&gt;}</span>
 <span class="s3">*/</span>
<span class="s2">class </span><span class="s1">ConfigArray </span><span class="s2">extends </span><span class="s1">Array {</span>

    <span class="s3">/**</span>
     <span class="s3">* Get the plugin environments.</span>
     <span class="s3">* The returned map cannot be mutated.</span>
     <span class="s3">* </span><span class="s4">@type </span><span class="s3">{ReadonlyMap&lt;string, Environment&gt;} The plugin environments.</span>
     <span class="s3">*/</span>
    <span class="s1">get pluginEnvironments() {</span>
        <span class="s2">return </span><span class="s1">ensurePluginMemberMaps(</span><span class="s2">this</span><span class="s1">).envMap;</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Get the plugin processors.</span>
     <span class="s3">* The returned map cannot be mutated.</span>
     <span class="s3">* </span><span class="s4">@type </span><span class="s3">{ReadonlyMap&lt;string, Processor&gt;} The plugin processors.</span>
     <span class="s3">*/</span>
    <span class="s1">get pluginProcessors() {</span>
        <span class="s2">return </span><span class="s1">ensurePluginMemberMaps(</span><span class="s2">this</span><span class="s1">).processorMap;</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Get the plugin rules.</span>
     <span class="s3">* The returned map cannot be mutated.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{ReadonlyMap&lt;string, Rule&gt;} The plugin rules.</span>
     <span class="s3">*/</span>
    <span class="s1">get pluginRules() {</span>
        <span class="s2">return </span><span class="s1">ensurePluginMemberMaps(</span><span class="s2">this</span><span class="s1">).ruleMap;</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Check if this config has `root` flag.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{boolean} `true` if this config array is root.</span>
     <span class="s3">*/</span>
    <span class="s1">isRoot() {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s2">this</span><span class="s1">.length - </span><span class="s5">1</span><span class="s1">; i &gt;= </span><span class="s5">0</span><span class="s1">; --i) {</span>
            <span class="s2">const </span><span class="s1">root = </span><span class="s2">this</span><span class="s1">[i].root;</span>

            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">root === </span><span class="s0">&quot;boolean&quot;</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s1">root;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Extract the config data which is related to a given file.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} filePath The absolute path to the target file.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{ExtractedConfig} The extracted config data.</span>
     <span class="s3">*/</span>
    <span class="s1">extractConfig(filePath) {</span>
        <span class="s2">const </span><span class="s1">{ cache } = internalSlotsMap$2.get(</span><span class="s2">this</span><span class="s1">);</span>
        <span class="s2">const </span><span class="s1">indices = getMatchedIndices(</span><span class="s2">this</span><span class="s1">, filePath);</span>
        <span class="s2">const </span><span class="s1">cacheKey = indices.join(</span><span class="s0">&quot;,&quot;</span><span class="s1">);</span>

        <span class="s2">if </span><span class="s1">(!cache.has(cacheKey)) {</span>
            <span class="s1">cache.set(cacheKey, createConfig(</span><span class="s2">this</span><span class="s1">, indices));</span>
        <span class="s1">}</span>

        <span class="s2">return </span><span class="s1">cache.get(cacheKey);</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Check if a given path is an additional lint target.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} filePath The absolute path to the target file.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{boolean} `true` if the file is an additional lint target.</span>
     <span class="s3">*/</span>
    <span class="s1">isAdditionalTargetPath(filePath) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ criteria, type } of </span><span class="s2">this</span><span class="s1">) {</span>
            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">type === </span><span class="s0">&quot;config&quot; </span><span class="s1">&amp;&amp;</span>
                <span class="s1">criteria &amp;&amp;</span>
                <span class="s1">!criteria.endsWithWildcard &amp;&amp;</span>
                <span class="s1">criteria.test(filePath)</span>
            <span class="s1">) {</span>
                <span class="s2">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Get the used extracted configs.</span>
 <span class="s3">* CLIEngine will use this method to collect used deprecated rules.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{ConfigArray} instance The config array object to get.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{ExtractedConfig[]} The used extracted configs.</span>
 <span class="s3">* </span><span class="s4">@private</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">getUsedExtractedConfigs(instance) {</span>
    <span class="s2">const </span><span class="s1">{ cache } = internalSlotsMap$2.get(instance);</span>

    <span class="s2">return </span><span class="s1">Array.from(cache.values());</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@fileoverview </span><span class="s3">`ConfigDependency` class.</span>
 <span class="s3">*</span>
 <span class="s3">* `ConfigDependency` class expresses a loaded parser or plugin.</span>
 <span class="s3">*</span>
 <span class="s3">* If the parser or plugin was loaded successfully, it has `definition` property</span>
 <span class="s3">* and `filePath` property. Otherwise, it has `error` property.</span>
 <span class="s3">*</span>
 <span class="s3">* When `JSON.stringify()` converted a `ConfigDependency` object to a JSON, it</span>
 <span class="s3">* omits `definition` property.</span>
 <span class="s3">*</span>
 <span class="s3">* `ConfigArrayFactory` creates `ConfigDependency` objects when it loads parsers</span>
 <span class="s3">* or plugins.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">@author </span><span class="s3">Toru Nagashima &lt;https://github.com/mysticatea&gt;</span>
 <span class="s3">*/</span>

<span class="s3">/**</span>
 <span class="s3">* The class is to store parsers or plugins.</span>
 <span class="s3">* This class hides the loaded object from `JSON.stringify()` and `console.log`.</span>
 <span class="s3">* </span><span class="s4">@template </span><span class="s3">T</span>
 <span class="s3">*/</span>
<span class="s2">class </span><span class="s1">ConfigDependency {</span>

    <span class="s3">/**</span>
     <span class="s3">* Initialize this instance.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} data The dependency data.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{T} [data.definition] The dependency if the loading succeeded.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{T} [data.original] The original, non-normalized dependency if the loading succeeded.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Error} [data.error] The error object if the loading failed.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} [data.filePath] The actual path to the dependency if the loading succeeded.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} data.id The ID of this dependency.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} data.importerName The name of the config file which loads this dependency.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} data.importerPath The path to the config file which loads this dependency.</span>
     <span class="s3">*/</span>
    <span class="s1">constructor({</span>
        <span class="s1">definition = </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">original = </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">error = </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">filePath = </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">id,</span>
        <span class="s1">importerName,</span>
        <span class="s1">importerPath</span>
    <span class="s1">}) {</span>

        <span class="s3">/**</span>
         <span class="s3">* The loaded dependency if the loading succeeded.</span>
         <span class="s3">* </span><span class="s4">@type </span><span class="s3">{T|null}</span>
         <span class="s3">*/</span>
        <span class="s2">this</span><span class="s1">.definition = definition;</span>

        <span class="s3">/**</span>
         <span class="s3">* The original dependency as loaded directly from disk if the loading succeeded.</span>
         <span class="s3">* </span><span class="s4">@type </span><span class="s3">{T|null}</span>
         <span class="s3">*/</span>
        <span class="s2">this</span><span class="s1">.original = original;</span>

        <span class="s3">/**</span>
         <span class="s3">* The error object if the loading failed.</span>
         <span class="s3">* </span><span class="s4">@type </span><span class="s3">{Error|null}</span>
         <span class="s3">*/</span>
        <span class="s2">this</span><span class="s1">.error = error;</span>

        <span class="s3">/**</span>
         <span class="s3">* The loaded dependency if the loading succeeded.</span>
         <span class="s3">* </span><span class="s4">@type </span><span class="s3">{string|null}</span>
         <span class="s3">*/</span>
        <span class="s2">this</span><span class="s1">.filePath = filePath;</span>

        <span class="s3">/**</span>
         <span class="s3">* The ID of this dependency.</span>
         <span class="s3">* </span><span class="s4">@type </span><span class="s3">{string}</span>
         <span class="s3">*/</span>
        <span class="s2">this</span><span class="s1">.id = id;</span>

        <span class="s3">/**</span>
         <span class="s3">* The name of the config file which loads this dependency.</span>
         <span class="s3">* </span><span class="s4">@type </span><span class="s3">{string}</span>
         <span class="s3">*/</span>
        <span class="s2">this</span><span class="s1">.importerName = importerName;</span>

        <span class="s3">/**</span>
         <span class="s3">* The path to the config file which loads this dependency.</span>
         <span class="s3">* </span><span class="s4">@type </span><span class="s3">{string}</span>
         <span class="s3">*/</span>
        <span class="s2">this</span><span class="s1">.importerPath = importerPath;</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Converts this instance to a JSON compatible object.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{Object} a JSON compatible object.</span>
     <span class="s3">*/</span>
    <span class="s1">toJSON() {</span>
        <span class="s2">const </span><span class="s1">obj = </span><span class="s2">this</span><span class="s1">[util__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].inspect.custom]();</span>

        <span class="s3">// Display `error.message` (`Error#message` is unenumerable).</span>
        <span class="s2">if </span><span class="s1">(obj.error </span><span class="s2">instanceof </span><span class="s1">Error) {</span>
            <span class="s1">obj.error = { ...obj.error, message: obj.error.message };</span>
        <span class="s1">}</span>

        <span class="s2">return </span><span class="s1">obj;</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Custom inspect method for Node.js `console.log()`.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{Object} an object to display by `console.log()`.</span>
     <span class="s3">*/</span>
    <span class="s1">[util__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].inspect.custom]() {</span>
        <span class="s2">const </span><span class="s1">{</span>
            <span class="s1">definition: _ignore1, </span><span class="s3">// eslint-disable-line no-unused-vars -- needed to make `obj` correct</span>
            <span class="s1">original: _ignore2, </span><span class="s3">// eslint-disable-line no-unused-vars -- needed to make `obj` correct</span>
            <span class="s1">...obj</span>
        <span class="s1">} = </span><span class="s2">this</span><span class="s1">;</span>

        <span class="s2">return </span><span class="s1">obj;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@fileoverview </span><span class="s3">`OverrideTester` class.</span>
 <span class="s3">*</span>
 <span class="s3">* `OverrideTester` class handles `files` property and `excludedFiles` property</span>
 <span class="s3">* of `overrides` config.</span>
 <span class="s3">*</span>
 <span class="s3">* It provides one method.</span>
 <span class="s3">*</span>
 <span class="s3">* - `test(filePath)`</span>
 <span class="s3">*      Test if a file path matches the pair of `files` property and</span>
 <span class="s3">*      `excludedFiles` property. The `filePath` argument must be an absolute</span>
 <span class="s3">*      path.</span>
 <span class="s3">*</span>
 <span class="s3">* `ConfigArrayFactory` creates `OverrideTester` objects when it processes</span>
 <span class="s3">* `overrides` properties.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">@author </span><span class="s3">Toru Nagashima &lt;https://github.com/mysticatea&gt;</span>
 <span class="s3">*/</span>

<span class="s2">const </span><span class="s1">{ Minimatch } = minimatch__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">];</span>

<span class="s2">const </span><span class="s1">minimatchOpts = { dot: </span><span class="s2">true</span><span class="s1">, matchBase: </span><span class="s2">true </span><span class="s1">};</span>

<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@typedef </span><span class="s3">{Object} Pattern</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{InstanceType&lt;Minimatch&gt;[] | null} includes The positive matchers.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{InstanceType&lt;Minimatch&gt;[] | null} excludes The negative matchers.</span>
 <span class="s3">*/</span>

<span class="s3">/**</span>
 <span class="s3">* Normalize a given pattern to an array.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string|string[]|undefined} patterns A glob pattern or an array of glob patterns.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{string[]|null} Normalized patterns.</span>
 <span class="s3">* </span><span class="s4">@private</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">normalizePatterns(patterns) {</span>
    <span class="s2">if </span><span class="s1">(Array.isArray(patterns)) {</span>
        <span class="s2">return </span><span class="s1">patterns.filter(Boolean);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">patterns === </span><span class="s0">&quot;string&quot; </span><span class="s1">&amp;&amp; patterns) {</span>
        <span class="s2">return </span><span class="s1">[patterns];</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">[];</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Create the matchers of given patterns.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string[]} patterns The patterns.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{InstanceType&lt;Minimatch&gt;[] | null} The matchers.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">toMatcher(patterns) {</span>
    <span class="s2">if </span><span class="s1">(patterns.length === </span><span class="s5">0</span><span class="s1">) {</span>
        <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">patterns.map(pattern =&gt; {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s6">/^\.[/\\]/u</span><span class="s1">.test(pattern)) {</span>
            <span class="s2">return new </span><span class="s1">Minimatch(</span>
                <span class="s1">pattern.slice(</span><span class="s5">2</span><span class="s1">),</span>

                <span class="s3">// `./*.js` should not match with `subdir/foo.js`</span>
                <span class="s1">{ ...minimatchOpts, matchBase: </span><span class="s2">false </span><span class="s1">}</span>
            <span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">return new </span><span class="s1">Minimatch(pattern, minimatchOpts);</span>
    <span class="s1">});</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Convert a given matcher to string.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Pattern} matchers The matchers.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{string} The string expression of the matcher.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">patternToJson({ includes, excludes }) {</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">includes: includes &amp;&amp; includes.map(m =&gt; m.pattern),</span>
        <span class="s1">excludes: excludes &amp;&amp; excludes.map(m =&gt; m.pattern)</span>
    <span class="s1">};</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* The class to test given paths are matched by the patterns.</span>
 <span class="s3">*/</span>
<span class="s2">class </span><span class="s1">OverrideTester {</span>

    <span class="s3">/**</span>
     <span class="s3">* Create a tester with given criteria.</span>
     <span class="s3">* If there are no criteria, returns `null`.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string|string[]} files The glob patterns for included files.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string|string[]} excludedFiles The glob patterns for excluded files.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} basePath The path to the base directory to test paths.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{OverrideTester|null} The created instance or `null`.</span>
     <span class="s3">* </span><span class="s4">@throws </span><span class="s3">{Error} When invalid patterns are given.</span>
     <span class="s3">*/</span>
    <span class="s2">static </span><span class="s1">create(files, excludedFiles, basePath) {</span>
        <span class="s2">const </span><span class="s1">includePatterns = normalizePatterns(files);</span>
        <span class="s2">const </span><span class="s1">excludePatterns = normalizePatterns(excludedFiles);</span>
        <span class="s2">let </span><span class="s1">endsWithWildcard = </span><span class="s2">false</span><span class="s1">;</span>

        <span class="s2">if </span><span class="s1">(includePatterns.length === </span><span class="s5">0</span><span class="s1">) {</span>
            <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s3">// Rejects absolute paths or relative paths to parents.</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">pattern of includePatterns) {</span>
            <span class="s2">if </span><span class="s1">(path__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].isAbsolute(pattern) || pattern.includes(</span><span class="s0">&quot;..&quot;</span><span class="s1">)) {</span>
                <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">`Invalid override pattern (expected relative path not containing '..'): </span><span class="s1">${pattern}</span><span class="s0">`</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(pattern.endsWith(</span><span class="s0">&quot;*&quot;</span><span class="s1">)) {</span>
                <span class="s1">endsWithWildcard = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">pattern of excludePatterns) {</span>
            <span class="s2">if </span><span class="s1">(path__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].isAbsolute(pattern) || pattern.includes(</span><span class="s0">&quot;..&quot;</span><span class="s1">)) {</span>
                <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">`Invalid override pattern (expected relative path not containing '..'): </span><span class="s1">${pattern}</span><span class="s0">`</span><span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s2">const </span><span class="s1">includes = toMatcher(includePatterns);</span>
        <span class="s2">const </span><span class="s1">excludes = toMatcher(excludePatterns);</span>

        <span class="s2">return new </span><span class="s1">OverrideTester(</span>
            <span class="s1">[{ includes, excludes }],</span>
            <span class="s1">basePath,</span>
            <span class="s1">endsWithWildcard</span>
        <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Combine two testers by logical and.</span>
     <span class="s3">* If either of the testers was `null`, returns the other tester.</span>
     <span class="s3">* The `basePath` property of the two must be the same value.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{OverrideTester|null} a A tester.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{OverrideTester|null} b Another tester.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{OverrideTester|null} Combined tester.</span>
     <span class="s3">*/</span>
    <span class="s2">static </span><span class="s1">and(a, b) {</span>
        <span class="s2">if </span><span class="s1">(!b) {</span>
            <span class="s2">return </span><span class="s1">a &amp;&amp; </span><span class="s2">new </span><span class="s1">OverrideTester(</span>
                <span class="s1">a.patterns,</span>
                <span class="s1">a.basePath,</span>
                <span class="s1">a.endsWithWildcard</span>
            <span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!a) {</span>
            <span class="s2">return new </span><span class="s1">OverrideTester(</span>
                <span class="s1">b.patterns,</span>
                <span class="s1">b.basePath,</span>
                <span class="s1">b.endsWithWildcard</span>
            <span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s1">assert__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].strictEqual(a.basePath, b.basePath);</span>
        <span class="s2">return new </span><span class="s1">OverrideTester(</span>
            <span class="s1">a.patterns.concat(b.patterns),</span>
            <span class="s1">a.basePath,</span>
            <span class="s1">a.endsWithWildcard || b.endsWithWildcard</span>
        <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Initialize this instance.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Pattern[]} patterns The matchers.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} basePath The base path.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{boolean} endsWithWildcard If `true` then a pattern ends with `*`.</span>
     <span class="s3">*/</span>
    <span class="s1">constructor(patterns, basePath, endsWithWildcard = </span><span class="s2">false</span><span class="s1">) {</span>

        <span class="s3">/** </span><span class="s4">@type </span><span class="s3">{Pattern[]} */</span>
        <span class="s2">this</span><span class="s1">.patterns = patterns;</span>

        <span class="s3">/** </span><span class="s4">@type </span><span class="s3">{string} */</span>
        <span class="s2">this</span><span class="s1">.basePath = basePath;</span>

        <span class="s3">/** </span><span class="s4">@type </span><span class="s3">{boolean} */</span>
        <span class="s2">this</span><span class="s1">.endsWithWildcard = endsWithWildcard;</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Test if a given path is matched or not.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} filePath The absolute path to the target file.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{boolean} `true` if the path was matched.</span>
     <span class="s3">* </span><span class="s4">@throws </span><span class="s3">{Error} When invalid `filePath` is given.</span>
     <span class="s3">*/</span>
    <span class="s1">test(filePath) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">filePath !== </span><span class="s0">&quot;string&quot; </span><span class="s1">|| !path__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].isAbsolute(filePath)) {</span>
            <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">`'filePath' should be an absolute path, but got </span><span class="s1">${filePath}</span><span class="s0">.`</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">relativePath = path__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].relative(</span><span class="s2">this</span><span class="s1">.basePath, filePath);</span>

        <span class="s2">return this</span><span class="s1">.patterns.every(({ includes, excludes }) =&gt; (</span>
            <span class="s1">(!includes || includes.some(m =&gt; m.match(relativePath))) &amp;&amp;</span>
            <span class="s1">(!excludes || !excludes.some(m =&gt; m.match(relativePath)))</span>
        <span class="s1">));</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Converts this instance to a JSON compatible object.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{Object} a JSON compatible object.</span>
     <span class="s3">*/</span>
    <span class="s1">toJSON() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.patterns.length === </span><span class="s5">1</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">...patternToJson(</span><span class="s2">this</span><span class="s1">.patterns[</span><span class="s5">0</span><span class="s1">]),</span>
                <span class="s1">basePath: </span><span class="s2">this</span><span class="s1">.basePath</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">AND: </span><span class="s2">this</span><span class="s1">.patterns.map(patternToJson),</span>
            <span class="s1">basePath: </span><span class="s2">this</span><span class="s1">.basePath</span>
        <span class="s1">};</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Custom inspect method for Node.js `console.log()`.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{Object} an object to display by `console.log()`.</span>
     <span class="s3">*/</span>
    <span class="s1">[util__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].inspect.custom]() {</span>
        <span class="s2">return this</span><span class="s1">.toJSON();</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@fileoverview </span><span class="s3">`ConfigArray` class.</span>
 <span class="s3">* </span><span class="s4">@author </span><span class="s3">Toru Nagashima &lt;https://github.com/mysticatea&gt;</span>
 <span class="s3">*/</span>

<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@fileoverview </span><span class="s3">Config file operations. This file must be usable in the browser,</span>
 <span class="s3">* so no Node-specific code can be here.</span>
 <span class="s3">* </span><span class="s4">@author </span><span class="s3">Nicholas C. Zakas</span>
 <span class="s3">*/</span>

<span class="s3">//------------------------------------------------------------------------------</span>
<span class="s3">// Private</span>
<span class="s3">//------------------------------------------------------------------------------</span>

<span class="s2">const </span><span class="s1">RULE_SEVERITY_STRINGS = [</span><span class="s0">&quot;off&quot;</span><span class="s1">, </span><span class="s0">&quot;warn&quot;</span><span class="s1">, </span><span class="s0">&quot;error&quot;</span><span class="s1">],</span>
    <span class="s1">RULE_SEVERITY = RULE_SEVERITY_STRINGS.reduce((map, value, index) =&gt; {</span>
        <span class="s1">map[value] = index;</span>
        <span class="s2">return </span><span class="s1">map;</span>
    <span class="s1">}, {}),</span>
    <span class="s1">VALID_SEVERITIES = </span><span class="s2">new </span><span class="s1">Set([</span><span class="s5">0</span><span class="s1">, </span><span class="s5">1</span><span class="s1">, </span><span class="s5">2</span><span class="s1">, </span><span class="s0">&quot;off&quot;</span><span class="s1">, </span><span class="s0">&quot;warn&quot;</span><span class="s1">, </span><span class="s0">&quot;error&quot;</span><span class="s1">]);</span>

<span class="s3">//------------------------------------------------------------------------------</span>
<span class="s3">// Public Interface</span>
<span class="s3">//------------------------------------------------------------------------------</span>

<span class="s3">/**</span>
 <span class="s3">* Normalizes the severity value of a rule's configuration to a number</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{(number|string|[number, ...*]|[string, ...*])} ruleConfig A rule's configuration value, generally</span>
 <span class="s3">* received from the user. A valid config value is either 0, 1, 2, the string &quot;off&quot; (treated the same as 0),</span>
 <span class="s3">* the string &quot;warn&quot; (treated the same as 1), the string &quot;error&quot; (treated the same as 2), or an array</span>
 <span class="s3">* whose first element is one of the above values. Strings are matched case-insensitively.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{(0|1|2)} The numeric severity value if the config value was valid, otherwise 0.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">getRuleSeverity(ruleConfig) {</span>
    <span class="s2">const </span><span class="s1">severityValue = Array.isArray(ruleConfig) ? ruleConfig[</span><span class="s5">0</span><span class="s1">] : ruleConfig;</span>

    <span class="s2">if </span><span class="s1">(severityValue === </span><span class="s5">0 </span><span class="s1">|| severityValue === </span><span class="s5">1 </span><span class="s1">|| severityValue === </span><span class="s5">2</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">severityValue;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">severityValue === </span><span class="s0">&quot;string&quot;</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">RULE_SEVERITY[severityValue.toLowerCase()] || </span><span class="s5">0</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s5">0</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Converts old-style severity settings (0, 1, 2) into new-style</span>
 <span class="s3">* severity settings (off, warn, error) for all rules. Assumption is that severity</span>
 <span class="s3">* values have already been validated as correct.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} config The config object to normalize.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{void}</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">normalizeToStrings(config) {</span>

    <span class="s2">if </span><span class="s1">(config.rules) {</span>
        <span class="s1">Object.keys(config.rules).forEach(ruleId =&gt; {</span>
            <span class="s2">const </span><span class="s1">ruleConfig = config.rules[ruleId];</span>

            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">ruleConfig === </span><span class="s0">&quot;number&quot;</span><span class="s1">) {</span>
                <span class="s1">config.rules[ruleId] = RULE_SEVERITY_STRINGS[ruleConfig] || RULE_SEVERITY_STRINGS[</span><span class="s5">0</span><span class="s1">];</span>
            <span class="s1">} </span><span class="s2">else if </span><span class="s1">(Array.isArray(ruleConfig) &amp;&amp; </span><span class="s2">typeof </span><span class="s1">ruleConfig[</span><span class="s5">0</span><span class="s1">] === </span><span class="s0">&quot;number&quot;</span><span class="s1">) {</span>
                <span class="s1">ruleConfig[</span><span class="s5">0</span><span class="s1">] = RULE_SEVERITY_STRINGS[ruleConfig[</span><span class="s5">0</span><span class="s1">]] || RULE_SEVERITY_STRINGS[</span><span class="s5">0</span><span class="s1">];</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Determines if the severity for the given rule configuration represents an error.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{int|string|Array} ruleConfig The configuration for an individual rule.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{boolean} True if the rule represents an error, false if not.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">isErrorSeverity(ruleConfig) {</span>
    <span class="s2">return </span><span class="s1">getRuleSeverity(ruleConfig) === </span><span class="s5">2</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Checks whether a given config has valid severity or not.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{number|string|Array} ruleConfig The configuration for an individual rule.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{boolean} `true` if the configuration has valid severity.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">isValidSeverity(ruleConfig) {</span>
    <span class="s2">let </span><span class="s1">severity = Array.isArray(ruleConfig) ? ruleConfig[</span><span class="s5">0</span><span class="s1">] : ruleConfig;</span>

    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">severity === </span><span class="s0">&quot;string&quot;</span><span class="s1">) {</span>
        <span class="s1">severity = severity.toLowerCase();</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">VALID_SEVERITIES.has(severity);</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Checks whether every rule of a given config has valid severity or not.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} config The configuration for rules.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{boolean} `true` if the configuration has valid severity.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">isEverySeverityValid(config) {</span>
    <span class="s2">return </span><span class="s1">Object.keys(config).every(ruleId =&gt; isValidSeverity(config[ruleId]));</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Normalizes a value for a global in a config</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{(boolean|string|null)} configuredValue The value given for a global in configuration or in</span>
 <span class="s3">* a global directive comment</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{(&quot;readable&quot;|&quot;writeable&quot;|&quot;off&quot;)} The value normalized as a string</span>
 <span class="s3">* </span><span class="s4">@throws </span><span class="s3">Error if global value is invalid</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">normalizeConfigGlobal(configuredValue) {</span>
    <span class="s2">switch </span><span class="s1">(configuredValue) {</span>
        <span class="s2">case </span><span class="s0">&quot;off&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s0">&quot;off&quot;</span><span class="s1">;</span>

        <span class="s2">case true</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;true&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;writeable&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;writable&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s0">&quot;writable&quot;</span><span class="s1">;</span>

        <span class="s2">case null</span><span class="s1">:</span>
        <span class="s2">case false</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;false&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;readable&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;readonly&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s0">&quot;readonly&quot;</span><span class="s1">;</span>

        <span class="s2">default</span><span class="s1">:</span>
            <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">`'</span><span class="s1">${configuredValue}</span><span class="s0">' is not a valid configuration for a global (use 'readonly', 'writable', or 'off')`</span><span class="s1">);</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">var </span><span class="s1">ConfigOps = {</span>
    <span class="s1">__proto__: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">getRuleSeverity: getRuleSeverity,</span>
    <span class="s1">normalizeToStrings: normalizeToStrings,</span>
    <span class="s1">isErrorSeverity: isErrorSeverity,</span>
    <span class="s1">isValidSeverity: isValidSeverity,</span>
    <span class="s1">isEverySeverityValid: isEverySeverityValid,</span>
    <span class="s1">normalizeConfigGlobal: normalizeConfigGlobal</span>
<span class="s1">};</span>

<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@fileoverview </span><span class="s3">Provide the function that emits deprecation warnings.</span>
 <span class="s3">* </span><span class="s4">@author </span><span class="s3">Toru Nagashima &lt;http://github.com/mysticatea&gt;</span>
 <span class="s3">*/</span>

<span class="s3">//------------------------------------------------------------------------------</span>
<span class="s3">// Private</span>
<span class="s3">//------------------------------------------------------------------------------</span>

<span class="s3">// Defitions for deprecation warnings.</span>
<span class="s2">const </span><span class="s1">deprecationWarningMessages = {</span>
    <span class="s1">ESLINT_LEGACY_ECMAFEATURES:</span>
        <span class="s0">&quot;The 'ecmaFeatures' config file property is deprecated and has no effect.&quot;</span><span class="s1">,</span>
    <span class="s1">ESLINT_PERSONAL_CONFIG_LOAD:</span>
        <span class="s0">&quot;'~/.eslintrc.*' config files have been deprecated. &quot; </span><span class="s1">+</span>
        <span class="s0">&quot;Please use a config file per project or the '--config' option.&quot;</span><span class="s1">,</span>
    <span class="s1">ESLINT_PERSONAL_CONFIG_SUPPRESS:</span>
        <span class="s0">&quot;'~/.eslintrc.*' config files have been deprecated. &quot; </span><span class="s1">+</span>
        <span class="s0">&quot;Please remove it or add 'root:true' to the config files in your &quot; </span><span class="s1">+</span>
        <span class="s0">&quot;projects in order to avoid loading '~/.eslintrc.*' accidentally.&quot;</span>
<span class="s1">};</span>

<span class="s2">const </span><span class="s1">sourceFileErrorCache = </span><span class="s2">new </span><span class="s1">Set();</span>

<span class="s3">/**</span>
 <span class="s3">* Emits a deprecation warning containing a given filepath. A new deprecation warning is emitted</span>
 <span class="s3">* for each unique file path, but repeated invocations with the same file path have no effect.</span>
 <span class="s3">* No warnings are emitted if the `--no-deprecation` or `--no-warnings` Node runtime flags are active.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} source The name of the configuration source to report the warning for.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} errorCode The warning message to show.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{void}</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">emitDeprecationWarning(source, errorCode) {</span>
    <span class="s2">const </span><span class="s1">cacheKey = JSON.stringify({ source, errorCode });</span>

    <span class="s2">if </span><span class="s1">(sourceFileErrorCache.has(cacheKey)) {</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">sourceFileErrorCache.add(cacheKey);</span>

    <span class="s2">const </span><span class="s1">rel = path__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].relative(process.cwd(), source);</span>
    <span class="s2">const </span><span class="s1">message = deprecationWarningMessages[errorCode];</span>

    <span class="s1">process.emitWarning(</span>
        <span class="s0">`</span><span class="s1">${message} </span><span class="s0">(found in &quot;</span><span class="s1">${rel}</span><span class="s0">&quot;)`</span><span class="s1">,</span>
        <span class="s0">&quot;DeprecationWarning&quot;</span><span class="s1">,</span>
        <span class="s1">errorCode</span>
    <span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@fileoverview </span><span class="s3">The instance of Ajv validator.</span>
 <span class="s3">* </span><span class="s4">@author </span><span class="s3">Evgeny Poberezkin</span>
 <span class="s3">*/</span>

<span class="s3">//-----------------------------------------------------------------------------</span>
<span class="s3">// Helpers</span>
<span class="s3">//-----------------------------------------------------------------------------</span>

<span class="s3">/* 
 * Copied from ajv/lib/refs/json-schema-draft-04.json 
 * The MIT License (MIT) 
 * Copyright (c) 2015-2017 Evgeny Poberezkin 
 */</span>
<span class="s2">const </span><span class="s1">metaSchema = {</span>
    <span class="s1">id: </span><span class="s0">&quot;http://json-schema.org/draft-04/schema#&quot;</span><span class="s1">,</span>
    <span class="s1">$schema: </span><span class="s0">&quot;http://json-schema.org/draft-04/schema#&quot;</span><span class="s1">,</span>
    <span class="s1">description: </span><span class="s0">&quot;Core schema meta-schema&quot;</span><span class="s1">,</span>
    <span class="s1">definitions: {</span>
        <span class="s1">schemaArray: {</span>
            <span class="s1">type: </span><span class="s0">&quot;array&quot;</span><span class="s1">,</span>
            <span class="s1">minItems: </span><span class="s5">1</span><span class="s1">,</span>
            <span class="s1">items: { $ref: </span><span class="s0">&quot;#&quot; </span><span class="s1">}</span>
        <span class="s1">},</span>
        <span class="s1">positiveInteger: {</span>
            <span class="s1">type: </span><span class="s0">&quot;integer&quot;</span><span class="s1">,</span>
            <span class="s1">minimum: </span><span class="s5">0</span>
        <span class="s1">},</span>
        <span class="s1">positiveIntegerDefault0: {</span>
            <span class="s1">allOf: [{ $ref: </span><span class="s0">&quot;#/definitions/positiveInteger&quot; </span><span class="s1">}, { </span><span class="s2">default</span><span class="s1">: </span><span class="s5">0 </span><span class="s1">}]</span>
        <span class="s1">},</span>
        <span class="s1">simpleTypes: {</span>
            <span class="s2">enum</span><span class="s1">: [</span><span class="s0">&quot;array&quot;</span><span class="s1">, </span><span class="s0">&quot;boolean&quot;</span><span class="s1">, </span><span class="s0">&quot;integer&quot;</span><span class="s1">, </span><span class="s0">&quot;null&quot;</span><span class="s1">, </span><span class="s0">&quot;number&quot;</span><span class="s1">, </span><span class="s0">&quot;object&quot;</span><span class="s1">, </span><span class="s0">&quot;string&quot;</span><span class="s1">]</span>
        <span class="s1">},</span>
        <span class="s1">stringArray: {</span>
            <span class="s1">type: </span><span class="s0">&quot;array&quot;</span><span class="s1">,</span>
            <span class="s1">items: { type: </span><span class="s0">&quot;string&quot; </span><span class="s1">},</span>
            <span class="s1">minItems: </span><span class="s5">1</span><span class="s1">,</span>
            <span class="s1">uniqueItems: </span><span class="s2">true</span>
        <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">type: </span><span class="s0">&quot;object&quot;</span><span class="s1">,</span>
    <span class="s1">properties: {</span>
        <span class="s1">id: {</span>
            <span class="s1">type: </span><span class="s0">&quot;string&quot;</span>
        <span class="s1">},</span>
        <span class="s1">$schema: {</span>
            <span class="s1">type: </span><span class="s0">&quot;string&quot;</span>
        <span class="s1">},</span>
        <span class="s1">title: {</span>
            <span class="s1">type: </span><span class="s0">&quot;string&quot;</span>
        <span class="s1">},</span>
        <span class="s1">description: {</span>
            <span class="s1">type: </span><span class="s0">&quot;string&quot;</span>
        <span class="s1">},</span>
        <span class="s2">default</span><span class="s1">: { },</span>
        <span class="s1">multipleOf: {</span>
            <span class="s1">type: </span><span class="s0">&quot;number&quot;</span><span class="s1">,</span>
            <span class="s1">minimum: </span><span class="s5">0</span><span class="s1">,</span>
            <span class="s1">exclusiveMinimum: </span><span class="s2">true</span>
        <span class="s1">},</span>
        <span class="s1">maximum: {</span>
            <span class="s1">type: </span><span class="s0">&quot;number&quot;</span>
        <span class="s1">},</span>
        <span class="s1">exclusiveMaximum: {</span>
            <span class="s1">type: </span><span class="s0">&quot;boolean&quot;</span><span class="s1">,</span>
            <span class="s2">default</span><span class="s1">: </span><span class="s2">false</span>
        <span class="s1">},</span>
        <span class="s1">minimum: {</span>
            <span class="s1">type: </span><span class="s0">&quot;number&quot;</span>
        <span class="s1">},</span>
        <span class="s1">exclusiveMinimum: {</span>
            <span class="s1">type: </span><span class="s0">&quot;boolean&quot;</span><span class="s1">,</span>
            <span class="s2">default</span><span class="s1">: </span><span class="s2">false</span>
        <span class="s1">},</span>
        <span class="s1">maxLength: { $ref: </span><span class="s0">&quot;#/definitions/positiveInteger&quot; </span><span class="s1">},</span>
        <span class="s1">minLength: { $ref: </span><span class="s0">&quot;#/definitions/positiveIntegerDefault0&quot; </span><span class="s1">},</span>
        <span class="s1">pattern: {</span>
            <span class="s1">type: </span><span class="s0">&quot;string&quot;</span><span class="s1">,</span>
            <span class="s1">format: </span><span class="s0">&quot;regex&quot;</span>
        <span class="s1">},</span>
        <span class="s1">additionalItems: {</span>
            <span class="s1">anyOf: [</span>
                <span class="s1">{ type: </span><span class="s0">&quot;boolean&quot; </span><span class="s1">},</span>
                <span class="s1">{ $ref: </span><span class="s0">&quot;#&quot; </span><span class="s1">}</span>
            <span class="s1">],</span>
            <span class="s2">default</span><span class="s1">: { }</span>
        <span class="s1">},</span>
        <span class="s1">items: {</span>
            <span class="s1">anyOf: [</span>
                <span class="s1">{ $ref: </span><span class="s0">&quot;#&quot; </span><span class="s1">},</span>
                <span class="s1">{ $ref: </span><span class="s0">&quot;#/definitions/schemaArray&quot; </span><span class="s1">}</span>
            <span class="s1">],</span>
            <span class="s2">default</span><span class="s1">: { }</span>
        <span class="s1">},</span>
        <span class="s1">maxItems: { $ref: </span><span class="s0">&quot;#/definitions/positiveInteger&quot; </span><span class="s1">},</span>
        <span class="s1">minItems: { $ref: </span><span class="s0">&quot;#/definitions/positiveIntegerDefault0&quot; </span><span class="s1">},</span>
        <span class="s1">uniqueItems: {</span>
            <span class="s1">type: </span><span class="s0">&quot;boolean&quot;</span><span class="s1">,</span>
            <span class="s2">default</span><span class="s1">: </span><span class="s2">false</span>
        <span class="s1">},</span>
        <span class="s1">maxProperties: { $ref: </span><span class="s0">&quot;#/definitions/positiveInteger&quot; </span><span class="s1">},</span>
        <span class="s1">minProperties: { $ref: </span><span class="s0">&quot;#/definitions/positiveIntegerDefault0&quot; </span><span class="s1">},</span>
        <span class="s1">required: { $ref: </span><span class="s0">&quot;#/definitions/stringArray&quot; </span><span class="s1">},</span>
        <span class="s1">additionalProperties: {</span>
            <span class="s1">anyOf: [</span>
                <span class="s1">{ type: </span><span class="s0">&quot;boolean&quot; </span><span class="s1">},</span>
                <span class="s1">{ $ref: </span><span class="s0">&quot;#&quot; </span><span class="s1">}</span>
            <span class="s1">],</span>
            <span class="s2">default</span><span class="s1">: { }</span>
        <span class="s1">},</span>
        <span class="s1">definitions: {</span>
            <span class="s1">type: </span><span class="s0">&quot;object&quot;</span><span class="s1">,</span>
            <span class="s1">additionalProperties: { $ref: </span><span class="s0">&quot;#&quot; </span><span class="s1">},</span>
            <span class="s2">default</span><span class="s1">: { }</span>
        <span class="s1">},</span>
        <span class="s1">properties: {</span>
            <span class="s1">type: </span><span class="s0">&quot;object&quot;</span><span class="s1">,</span>
            <span class="s1">additionalProperties: { $ref: </span><span class="s0">&quot;#&quot; </span><span class="s1">},</span>
            <span class="s2">default</span><span class="s1">: { }</span>
        <span class="s1">},</span>
        <span class="s1">patternProperties: {</span>
            <span class="s1">type: </span><span class="s0">&quot;object&quot;</span><span class="s1">,</span>
            <span class="s1">additionalProperties: { $ref: </span><span class="s0">&quot;#&quot; </span><span class="s1">},</span>
            <span class="s2">default</span><span class="s1">: { }</span>
        <span class="s1">},</span>
        <span class="s1">dependencies: {</span>
            <span class="s1">type: </span><span class="s0">&quot;object&quot;</span><span class="s1">,</span>
            <span class="s1">additionalProperties: {</span>
                <span class="s1">anyOf: [</span>
                    <span class="s1">{ $ref: </span><span class="s0">&quot;#&quot; </span><span class="s1">},</span>
                    <span class="s1">{ $ref: </span><span class="s0">&quot;#/definitions/stringArray&quot; </span><span class="s1">}</span>
                <span class="s1">]</span>
            <span class="s1">}</span>
        <span class="s1">},</span>
        <span class="s2">enum</span><span class="s1">: {</span>
            <span class="s1">type: </span><span class="s0">&quot;array&quot;</span><span class="s1">,</span>
            <span class="s1">minItems: </span><span class="s5">1</span><span class="s1">,</span>
            <span class="s1">uniqueItems: </span><span class="s2">true</span>
        <span class="s1">},</span>
        <span class="s1">type: {</span>
            <span class="s1">anyOf: [</span>
                <span class="s1">{ $ref: </span><span class="s0">&quot;#/definitions/simpleTypes&quot; </span><span class="s1">},</span>
                <span class="s1">{</span>
                    <span class="s1">type: </span><span class="s0">&quot;array&quot;</span><span class="s1">,</span>
                    <span class="s1">items: { $ref: </span><span class="s0">&quot;#/definitions/simpleTypes&quot; </span><span class="s1">},</span>
                    <span class="s1">minItems: </span><span class="s5">1</span><span class="s1">,</span>
                    <span class="s1">uniqueItems: </span><span class="s2">true</span>
                <span class="s1">}</span>
            <span class="s1">]</span>
        <span class="s1">},</span>
        <span class="s1">format: { type: </span><span class="s0">&quot;string&quot; </span><span class="s1">},</span>
        <span class="s1">allOf: { $ref: </span><span class="s0">&quot;#/definitions/schemaArray&quot; </span><span class="s1">},</span>
        <span class="s1">anyOf: { $ref: </span><span class="s0">&quot;#/definitions/schemaArray&quot; </span><span class="s1">},</span>
        <span class="s1">oneOf: { $ref: </span><span class="s0">&quot;#/definitions/schemaArray&quot; </span><span class="s1">},</span>
        <span class="s1">not: { $ref: </span><span class="s0">&quot;#&quot; </span><span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">dependencies: {</span>
        <span class="s1">exclusiveMaximum: [</span><span class="s0">&quot;maximum&quot;</span><span class="s1">],</span>
        <span class="s1">exclusiveMinimum: [</span><span class="s0">&quot;minimum&quot;</span><span class="s1">]</span>
    <span class="s1">},</span>
    <span class="s2">default</span><span class="s1">: { }</span>
<span class="s1">};</span>

<span class="s3">//------------------------------------------------------------------------------</span>
<span class="s3">// Public Interface</span>
<span class="s3">//------------------------------------------------------------------------------</span>

<span class="s2">var </span><span class="s1">ajvOrig = (additionalOptions = {}) =&gt; {</span>
    <span class="s2">const </span><span class="s1">ajv = </span><span class="s2">new </span><span class="s1">Ajv__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">]({</span>
        <span class="s1">meta: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">useDefaults: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">validateSchema: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">missingRefs: </span><span class="s0">&quot;ignore&quot;</span><span class="s1">,</span>
        <span class="s1">verbose: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">schemaId: </span><span class="s0">&quot;auto&quot;</span><span class="s1">,</span>
        <span class="s1">...additionalOptions</span>
    <span class="s1">});</span>

    <span class="s1">ajv.addMetaSchema(metaSchema);</span>
    <span class="s3">// eslint-disable-next-line no-underscore-dangle -- part of the API</span>
    <span class="s1">ajv._opts.defaultMeta = metaSchema.id;</span>

    <span class="s2">return </span><span class="s1">ajv;</span>
<span class="s1">};</span>

<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@fileoverview </span><span class="s3">Applies default rule options</span>
 <span class="s3">* </span><span class="s4">@author </span><span class="s3">JoshuaKGoldberg</span>
 <span class="s3">*/</span>

<span class="s3">/**</span>
 <span class="s3">* Check if the variable contains an object strictly rejecting arrays</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{unknown} value an object</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{boolean} Whether value is an object</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">isObjectNotArray(value) {</span>
    <span class="s2">return typeof </span><span class="s1">value === </span><span class="s0">&quot;object&quot; </span><span class="s1">&amp;&amp; value !== </span><span class="s2">null </span><span class="s1">&amp;&amp; !Array.isArray(value);</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Deeply merges second on top of first, creating a new {} object if needed.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{T} first Base, default value.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{U} second User-specified value.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{T | U | (T &amp; U)} Merged equivalent of second on top of first.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">deepMergeObjects(first, second) {</span>
    <span class="s2">if </span><span class="s1">(second === </span><span class="s2">void </span><span class="s5">0</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">first;</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(!isObjectNotArray(first) || !isObjectNotArray(second)) {</span>
        <span class="s2">return </span><span class="s1">second;</span>
    <span class="s1">}</span>

    <span class="s2">const </span><span class="s1">result = { ...first, ...second };</span>

    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key of Object.keys(second)) {</span>
        <span class="s2">if </span><span class="s1">(Object.prototype.propertyIsEnumerable.call(first, key)) {</span>
            <span class="s1">result[key] = deepMergeObjects(first[key], second[key]);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Deeply merges second on top of first, creating a new [] array if needed.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{T[] | undefined} first Base, default values.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{U[] | undefined} second User-specified values.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{(T | U | (T &amp; U))[]} Merged equivalent of second on top of first.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">deepMergeArrays(first, second) {</span>
    <span class="s2">if </span><span class="s1">(!first || !second) {</span>
        <span class="s2">return </span><span class="s1">second || first || [];</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">[</span>
        <span class="s1">...first.map((value, i) =&gt; deepMergeObjects(value, second[i])),</span>
        <span class="s1">...second.slice(first.length)</span>
    <span class="s1">];</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@fileoverview </span><span class="s3">Defines a schema for configs.</span>
 <span class="s3">* </span><span class="s4">@author </span><span class="s3">Sylvan Mably</span>
 <span class="s3">*/</span>

<span class="s2">const </span><span class="s1">baseConfigProperties = {</span>
    <span class="s1">$schema: { type: </span><span class="s0">&quot;string&quot; </span><span class="s1">},</span>
    <span class="s1">env: { type: </span><span class="s0">&quot;object&quot; </span><span class="s1">},</span>
    <span class="s2">extends</span><span class="s1">: { $ref: </span><span class="s0">&quot;#/definitions/stringOrStrings&quot; </span><span class="s1">},</span>
    <span class="s1">globals: { type: </span><span class="s0">&quot;object&quot; </span><span class="s1">},</span>
    <span class="s1">overrides: {</span>
        <span class="s1">type: </span><span class="s0">&quot;array&quot;</span><span class="s1">,</span>
        <span class="s1">items: { $ref: </span><span class="s0">&quot;#/definitions/overrideConfig&quot; </span><span class="s1">},</span>
        <span class="s1">additionalItems: </span><span class="s2">false</span>
    <span class="s1">},</span>
    <span class="s1">parser: { type: [</span><span class="s0">&quot;string&quot;</span><span class="s1">, </span><span class="s0">&quot;null&quot;</span><span class="s1">] },</span>
    <span class="s1">parserOptions: { type: </span><span class="s0">&quot;object&quot; </span><span class="s1">},</span>
    <span class="s1">plugins: { type: </span><span class="s0">&quot;array&quot; </span><span class="s1">},</span>
    <span class="s1">processor: { type: </span><span class="s0">&quot;string&quot; </span><span class="s1">},</span>
    <span class="s1">rules: { type: </span><span class="s0">&quot;object&quot; </span><span class="s1">},</span>
    <span class="s1">settings: { type: </span><span class="s0">&quot;object&quot; </span><span class="s1">},</span>
    <span class="s1">noInlineConfig: { type: </span><span class="s0">&quot;boolean&quot; </span><span class="s1">},</span>
    <span class="s1">reportUnusedDisableDirectives: { type: </span><span class="s0">&quot;boolean&quot; </span><span class="s1">},</span>

    <span class="s1">ecmaFeatures: { type: </span><span class="s0">&quot;object&quot; </span><span class="s1">} </span><span class="s3">// deprecated; logs a warning when used</span>
<span class="s1">};</span>

<span class="s2">const </span><span class="s1">configSchema = {</span>
    <span class="s1">definitions: {</span>
        <span class="s1">stringOrStrings: {</span>
            <span class="s1">oneOf: [</span>
                <span class="s1">{ type: </span><span class="s0">&quot;string&quot; </span><span class="s1">},</span>
                <span class="s1">{</span>
                    <span class="s1">type: </span><span class="s0">&quot;array&quot;</span><span class="s1">,</span>
                    <span class="s1">items: { type: </span><span class="s0">&quot;string&quot; </span><span class="s1">},</span>
                    <span class="s1">additionalItems: </span><span class="s2">false</span>
                <span class="s1">}</span>
            <span class="s1">]</span>
        <span class="s1">},</span>
        <span class="s1">stringOrStringsRequired: {</span>
            <span class="s1">oneOf: [</span>
                <span class="s1">{ type: </span><span class="s0">&quot;string&quot; </span><span class="s1">},</span>
                <span class="s1">{</span>
                    <span class="s1">type: </span><span class="s0">&quot;array&quot;</span><span class="s1">,</span>
                    <span class="s1">items: { type: </span><span class="s0">&quot;string&quot; </span><span class="s1">},</span>
                    <span class="s1">additionalItems: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">minItems: </span><span class="s5">1</span>
                <span class="s1">}</span>
            <span class="s1">]</span>
        <span class="s1">},</span>

        <span class="s3">// Config at top-level.</span>
        <span class="s1">objectConfig: {</span>
            <span class="s1">type: </span><span class="s0">&quot;object&quot;</span><span class="s1">,</span>
            <span class="s1">properties: {</span>
                <span class="s1">root: { type: </span><span class="s0">&quot;boolean&quot; </span><span class="s1">},</span>
                <span class="s1">ignorePatterns: { $ref: </span><span class="s0">&quot;#/definitions/stringOrStrings&quot; </span><span class="s1">},</span>
                <span class="s1">...baseConfigProperties</span>
            <span class="s1">},</span>
            <span class="s1">additionalProperties: </span><span class="s2">false</span>
        <span class="s1">},</span>

        <span class="s3">// Config in `overrides`.</span>
        <span class="s1">overrideConfig: {</span>
            <span class="s1">type: </span><span class="s0">&quot;object&quot;</span><span class="s1">,</span>
            <span class="s1">properties: {</span>
                <span class="s1">excludedFiles: { $ref: </span><span class="s0">&quot;#/definitions/stringOrStrings&quot; </span><span class="s1">},</span>
                <span class="s1">files: { $ref: </span><span class="s0">&quot;#/definitions/stringOrStringsRequired&quot; </span><span class="s1">},</span>
                <span class="s1">...baseConfigProperties</span>
            <span class="s1">},</span>
            <span class="s1">required: [</span><span class="s0">&quot;files&quot;</span><span class="s1">],</span>
            <span class="s1">additionalProperties: </span><span class="s2">false</span>
        <span class="s1">}</span>
    <span class="s1">},</span>

    <span class="s1">$ref: </span><span class="s0">&quot;#/definitions/objectConfig&quot;</span>
<span class="s1">};</span>

<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@fileoverview </span><span class="s3">Defines environment settings and globals.</span>
 <span class="s3">* </span><span class="s4">@author </span><span class="s3">Elan Shanker</span>
 <span class="s3">*/</span>

<span class="s3">//------------------------------------------------------------------------------</span>
<span class="s3">// Helpers</span>
<span class="s3">//------------------------------------------------------------------------------</span>

<span class="s3">/**</span>
 <span class="s3">* Get the object that has difference.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Record&lt;string,boolean&gt;} current The newer object.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Record&lt;string,boolean&gt;} prev The older object.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{Record&lt;string,boolean&gt;} The difference object.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">getDiff(current, prev) {</span>
    <span class="s2">const </span><span class="s1">retv = {};</span>

    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[key, value] of Object.entries(current)) {</span>
        <span class="s2">if </span><span class="s1">(!Object.hasOwn(prev, key)) {</span>
            <span class="s1">retv[key] = value;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">retv;</span>
<span class="s1">}</span>

<span class="s2">const </span><span class="s1">newGlobals2015 = getDiff(globals__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].es2015, globals__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].es5); </span><span class="s3">// 19 variables such as Promise, Map, ...</span>
<span class="s2">const </span><span class="s1">newGlobals2017 = {</span>
    <span class="s1">Atomics: </span><span class="s2">false</span><span class="s1">,</span>
    <span class="s1">SharedArrayBuffer: </span><span class="s2">false</span>
<span class="s1">};</span>
<span class="s2">const </span><span class="s1">newGlobals2020 = {</span>
    <span class="s1">BigInt: </span><span class="s2">false</span><span class="s1">,</span>
    <span class="s1">BigInt64Array: </span><span class="s2">false</span><span class="s1">,</span>
    <span class="s1">BigUint64Array: </span><span class="s2">false</span><span class="s1">,</span>
    <span class="s1">globalThis: </span><span class="s2">false</span>
<span class="s1">};</span>

<span class="s2">const </span><span class="s1">newGlobals2021 = {</span>
    <span class="s1">AggregateError: </span><span class="s2">false</span><span class="s1">,</span>
    <span class="s1">FinalizationRegistry: </span><span class="s2">false</span><span class="s1">,</span>
    <span class="s1">WeakRef: </span><span class="s2">false</span>
<span class="s1">};</span>

<span class="s3">//------------------------------------------------------------------------------</span>
<span class="s3">// Public Interface</span>
<span class="s3">//------------------------------------------------------------------------------</span>

<span class="s3">/** </span><span class="s4">@type </span><span class="s3">{Map&lt;string, import(&quot;../lib/shared/types&quot;).Environment&gt;} */</span>
<span class="s2">var </span><span class="s1">environments = </span><span class="s2">new </span><span class="s1">Map(Object.entries({</span>

    <span class="s3">// Language</span>
    <span class="s1">builtin: {</span>
        <span class="s1">globals: globals__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].es5</span>
    <span class="s1">},</span>
    <span class="s1">es6: {</span>
        <span class="s1">globals: newGlobals2015,</span>
        <span class="s1">parserOptions: {</span>
            <span class="s1">ecmaVersion: </span><span class="s5">6</span>
        <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">es2015: {</span>
        <span class="s1">globals: newGlobals2015,</span>
        <span class="s1">parserOptions: {</span>
            <span class="s1">ecmaVersion: </span><span class="s5">6</span>
        <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">es2016: {</span>
        <span class="s1">globals: newGlobals2015,</span>
        <span class="s1">parserOptions: {</span>
            <span class="s1">ecmaVersion: </span><span class="s5">7</span>
        <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">es2017: {</span>
        <span class="s1">globals: { ...newGlobals2015, ...newGlobals2017 },</span>
        <span class="s1">parserOptions: {</span>
            <span class="s1">ecmaVersion: </span><span class="s5">8</span>
        <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">es2018: {</span>
        <span class="s1">globals: { ...newGlobals2015, ...newGlobals2017 },</span>
        <span class="s1">parserOptions: {</span>
            <span class="s1">ecmaVersion: </span><span class="s5">9</span>
        <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">es2019: {</span>
        <span class="s1">globals: { ...newGlobals2015, ...newGlobals2017 },</span>
        <span class="s1">parserOptions: {</span>
            <span class="s1">ecmaVersion: </span><span class="s5">10</span>
        <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">es2020: {</span>
        <span class="s1">globals: { ...newGlobals2015, ...newGlobals2017, ...newGlobals2020 },</span>
        <span class="s1">parserOptions: {</span>
            <span class="s1">ecmaVersion: </span><span class="s5">11</span>
        <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">es2021: {</span>
        <span class="s1">globals: { ...newGlobals2015, ...newGlobals2017, ...newGlobals2020, ...newGlobals2021 },</span>
        <span class="s1">parserOptions: {</span>
            <span class="s1">ecmaVersion: </span><span class="s5">12</span>
        <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">es2022: {</span>
        <span class="s1">globals: { ...newGlobals2015, ...newGlobals2017, ...newGlobals2020, ...newGlobals2021 },</span>
        <span class="s1">parserOptions: {</span>
            <span class="s1">ecmaVersion: </span><span class="s5">13</span>
        <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">es2023: {</span>
        <span class="s1">globals: { ...newGlobals2015, ...newGlobals2017, ...newGlobals2020, ...newGlobals2021 },</span>
        <span class="s1">parserOptions: {</span>
            <span class="s1">ecmaVersion: </span><span class="s5">14</span>
        <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">es2024: {</span>
        <span class="s1">globals: { ...newGlobals2015, ...newGlobals2017, ...newGlobals2020, ...newGlobals2021 },</span>
        <span class="s1">parserOptions: {</span>
            <span class="s1">ecmaVersion: </span><span class="s5">15</span>
        <span class="s1">}</span>
    <span class="s1">},</span>

    <span class="s3">// Platforms</span>
    <span class="s1">browser: {</span>
        <span class="s1">globals: globals__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].browser</span>
    <span class="s1">},</span>
    <span class="s1">node: {</span>
        <span class="s1">globals: globals__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].node,</span>
        <span class="s1">parserOptions: {</span>
            <span class="s1">ecmaFeatures: {</span>
                <span class="s1">globalReturn: </span><span class="s2">true</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s0">&quot;shared-node-browser&quot;</span><span class="s1">: {</span>
        <span class="s1">globals: globals__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">][</span><span class="s0">&quot;shared-node-browser&quot;</span><span class="s1">]</span>
    <span class="s1">},</span>
    <span class="s1">worker: {</span>
        <span class="s1">globals: globals__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].worker</span>
    <span class="s1">},</span>
    <span class="s1">serviceworker: {</span>
        <span class="s1">globals: globals__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].serviceworker</span>
    <span class="s1">},</span>

    <span class="s3">// Frameworks</span>
    <span class="s1">commonjs: {</span>
        <span class="s1">globals: globals__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].commonjs,</span>
        <span class="s1">parserOptions: {</span>
            <span class="s1">ecmaFeatures: {</span>
                <span class="s1">globalReturn: </span><span class="s2">true</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">},</span>
    <span class="s1">amd: {</span>
        <span class="s1">globals: globals__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].amd</span>
    <span class="s1">},</span>
    <span class="s1">mocha: {</span>
        <span class="s1">globals: globals__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].mocha</span>
    <span class="s1">},</span>
    <span class="s1">jasmine: {</span>
        <span class="s1">globals: globals__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].jasmine</span>
    <span class="s1">},</span>
    <span class="s1">jest: {</span>
        <span class="s1">globals: globals__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].jest</span>
    <span class="s1">},</span>
    <span class="s1">phantomjs: {</span>
        <span class="s1">globals: globals__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].phantomjs</span>
    <span class="s1">},</span>
    <span class="s1">jquery: {</span>
        <span class="s1">globals: globals__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].jquery</span>
    <span class="s1">},</span>
    <span class="s1">qunit: {</span>
        <span class="s1">globals: globals__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].qunit</span>
    <span class="s1">},</span>
    <span class="s1">prototypejs: {</span>
        <span class="s1">globals: globals__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].prototypejs</span>
    <span class="s1">},</span>
    <span class="s1">shelljs: {</span>
        <span class="s1">globals: globals__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].shelljs</span>
    <span class="s1">},</span>
    <span class="s1">meteor: {</span>
        <span class="s1">globals: globals__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].meteor</span>
    <span class="s1">},</span>
    <span class="s1">mongo: {</span>
        <span class="s1">globals: globals__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].mongo</span>
    <span class="s1">},</span>
    <span class="s1">protractor: {</span>
        <span class="s1">globals: globals__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].protractor</span>
    <span class="s1">},</span>
    <span class="s1">applescript: {</span>
        <span class="s1">globals: globals__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].applescript</span>
    <span class="s1">},</span>
    <span class="s1">nashorn: {</span>
        <span class="s1">globals: globals__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].nashorn</span>
    <span class="s1">},</span>
    <span class="s1">atomtest: {</span>
        <span class="s1">globals: globals__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].atomtest</span>
    <span class="s1">},</span>
    <span class="s1">embertest: {</span>
        <span class="s1">globals: globals__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].embertest</span>
    <span class="s1">},</span>
    <span class="s1">webextensions: {</span>
        <span class="s1">globals: globals__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].webextensions</span>
    <span class="s1">},</span>
    <span class="s1">greasemonkey: {</span>
        <span class="s1">globals: globals__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].greasemonkey</span>
    <span class="s1">}</span>
<span class="s1">}));</span>

<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@fileoverview </span><span class="s3">Validates configs.</span>
 <span class="s3">* </span><span class="s4">@author </span><span class="s3">Brandon Mills</span>
 <span class="s3">*/</span>

<span class="s2">const </span><span class="s1">ajv = ajvOrig();</span>

<span class="s2">const </span><span class="s1">ruleValidators = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
<span class="s2">const </span><span class="s1">noop = Function.prototype;</span>

<span class="s3">//------------------------------------------------------------------------------</span>
<span class="s3">// Private</span>
<span class="s3">//------------------------------------------------------------------------------</span>
<span class="s2">let </span><span class="s1">validateSchema;</span>
<span class="s2">const </span><span class="s1">severityMap = {</span>
    <span class="s1">error: </span><span class="s5">2</span><span class="s1">,</span>
    <span class="s1">warn: </span><span class="s5">1</span><span class="s1">,</span>
    <span class="s1">off: </span><span class="s5">0</span>
<span class="s1">};</span>

<span class="s2">const </span><span class="s1">validated = </span><span class="s2">new </span><span class="s1">WeakSet();</span>

<span class="s3">// JSON schema that disallows passing any options</span>
<span class="s2">const </span><span class="s1">noOptionsSchema = Object.freeze({</span>
    <span class="s1">type: </span><span class="s0">&quot;array&quot;</span><span class="s1">,</span>
    <span class="s1">minItems: </span><span class="s5">0</span><span class="s1">,</span>
    <span class="s1">maxItems: </span><span class="s5">0</span>
<span class="s1">});</span>

<span class="s3">//-----------------------------------------------------------------------------</span>
<span class="s3">// Exports</span>
<span class="s3">//-----------------------------------------------------------------------------</span>

<span class="s3">/**</span>
 <span class="s3">* Validator for configuration objects.</span>
 <span class="s3">*/</span>
<span class="s2">class </span><span class="s1">ConfigValidator {</span>
    <span class="s1">constructor({ builtInRules = </span><span class="s2">new </span><span class="s1">Map() } = {}) {</span>
        <span class="s2">this</span><span class="s1">.builtInRules = builtInRules;</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Gets a complete options schema for a rule.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Rule} rule A rule object</span>
     <span class="s3">* </span><span class="s4">@throws </span><span class="s3">{TypeError} If `meta.schema` is specified but is not an array, object or `false`.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{Object|null} JSON Schema for the rule's options.</span>
     <span class="s3">*      `null` if rule wasn't passed or its `meta.schema` is `false`.</span>
     <span class="s3">*/</span>
    <span class="s1">getRuleOptionsSchema(rule) {</span>
        <span class="s2">if </span><span class="s1">(!rule) {</span>
            <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(!rule.meta) {</span>
            <span class="s2">return </span><span class="s1">{ ...noOptionsSchema }; </span><span class="s3">// default if `meta.schema` is not specified</span>
        <span class="s1">}</span>

        <span class="s2">const </span><span class="s1">schema = rule.meta.schema;</span>

        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">schema === </span><span class="s0">&quot;undefined&quot;</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">{ ...noOptionsSchema }; </span><span class="s3">// default if `meta.schema` is not specified</span>
        <span class="s1">}</span>

        <span class="s3">// `schema:false` is an allowed explicit opt-out of options validation for the rule</span>
        <span class="s2">if </span><span class="s1">(schema === </span><span class="s2">false</span><span class="s1">) {</span>
            <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">schema !== </span><span class="s0">&quot;object&quot; </span><span class="s1">|| schema === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">&quot;Rule's `meta.schema` must be an array or object&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s3">// ESLint-specific array form needs to be converted into a valid JSON Schema definition</span>
        <span class="s2">if </span><span class="s1">(Array.isArray(schema)) {</span>
            <span class="s2">if </span><span class="s1">(schema.length) {</span>
                <span class="s2">return </span><span class="s1">{</span>
                    <span class="s1">type: </span><span class="s0">&quot;array&quot;</span><span class="s1">,</span>
                    <span class="s1">items: schema,</span>
                    <span class="s1">minItems: </span><span class="s5">0</span><span class="s1">,</span>
                    <span class="s1">maxItems: schema.length</span>
                <span class="s1">};</span>
            <span class="s1">}</span>

            <span class="s3">// `schema:[]` is an explicit way to specify that the rule does not accept any options</span>
            <span class="s2">return </span><span class="s1">{ ...noOptionsSchema };</span>
        <span class="s1">}</span>

        <span class="s3">// `schema:&lt;object&gt;` is assumed to be a valid JSON Schema definition</span>
        <span class="s2">return </span><span class="s1">schema;</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Validates a rule's severity and returns the severity value. Throws an error if the severity is invalid.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{options} options The given options for the rule.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{number|string} The rule's severity value</span>
     <span class="s3">* </span><span class="s4">@throws </span><span class="s3">{Error} If the severity is invalid.</span>
     <span class="s3">*/</span>
    <span class="s1">validateRuleSeverity(options) {</span>
        <span class="s2">const </span><span class="s1">severity = Array.isArray(options) ? options[</span><span class="s5">0</span><span class="s1">] : options;</span>
        <span class="s2">const </span><span class="s1">normSeverity = </span><span class="s2">typeof </span><span class="s1">severity === </span><span class="s0">&quot;string&quot; </span><span class="s1">? severityMap[severity.toLowerCase()] : severity;</span>

        <span class="s2">if </span><span class="s1">(normSeverity === </span><span class="s5">0 </span><span class="s1">|| normSeverity === </span><span class="s5">1 </span><span class="s1">|| normSeverity === </span><span class="s5">2</span><span class="s1">) {</span>
            <span class="s2">return </span><span class="s1">normSeverity;</span>
        <span class="s1">}</span>

        <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">`</span><span class="s7">\t</span><span class="s0">Severity should be one of the following: 0 = off, 1 = warn, 2 = error (you passed '</span><span class="s1">${util__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].inspect(severity).replace(</span><span class="s6">/'/gu</span><span class="s1">, </span><span class="s0">&quot;</span><span class="s7">\&quot;</span><span class="s0">&quot;</span><span class="s1">).replace(</span><span class="s6">/\n/gu</span><span class="s1">, </span><span class="s0">&quot;&quot;</span><span class="s1">)}</span><span class="s0">').</span><span class="s7">\n</span><span class="s0">`</span><span class="s1">);</span>

    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Validates the non-severity options passed to a rule, based on its schema.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{{create: Function}} rule The rule to validate</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Array} localOptions The options for the rule, excluding severity</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{void}</span>
     <span class="s3">* </span><span class="s4">@throws </span><span class="s3">{Error} If the options are invalid.</span>
     <span class="s3">*/</span>
    <span class="s1">validateRuleSchema(rule, localOptions) {</span>
        <span class="s2">if </span><span class="s1">(!ruleValidators.has(rule)) {</span>
            <span class="s2">try </span><span class="s1">{</span>
                <span class="s2">const </span><span class="s1">schema = </span><span class="s2">this</span><span class="s1">.getRuleOptionsSchema(rule);</span>

                <span class="s2">if </span><span class="s1">(schema) {</span>
                    <span class="s1">ruleValidators.set(rule, ajv.compile(schema));</span>
                <span class="s1">}</span>
            <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
                <span class="s2">const </span><span class="s1">errorWithCode = </span><span class="s2">new </span><span class="s1">Error(err.message, { cause: err });</span>

                <span class="s1">errorWithCode.code = </span><span class="s0">&quot;ESLINT_INVALID_RULE_OPTIONS_SCHEMA&quot;</span><span class="s1">;</span>

                <span class="s2">throw </span><span class="s1">errorWithCode;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s2">const </span><span class="s1">validateRule = ruleValidators.get(rule);</span>

        <span class="s2">if </span><span class="s1">(validateRule) {</span>
            <span class="s2">const </span><span class="s1">mergedOptions = deepMergeArrays(rule.meta?.defaultOptions, localOptions);</span>

            <span class="s1">validateRule(mergedOptions);</span>

            <span class="s2">if </span><span class="s1">(validateRule.errors) {</span>
                <span class="s2">throw new </span><span class="s1">Error(validateRule.errors.map(</span>
                    <span class="s1">error =&gt; </span><span class="s0">`</span><span class="s7">\t</span><span class="s0">Value </span><span class="s1">${JSON.stringify(error.data)} ${error.message}</span><span class="s0">.</span><span class="s7">\n</span><span class="s0">`</span>
                <span class="s1">).join(</span><span class="s0">&quot;&quot;</span><span class="s1">));</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Validates a rule's options against its schema.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{{create: Function}|null} rule The rule that the config is being validated for</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} ruleId The rule's unique name.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Array|number} options The given options for the rule.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string|null} source The name of the configuration source to report in any errors. If null or undefined,</span>
     <span class="s3">* no source is prepended to the message.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{void}</span>
     <span class="s3">* </span><span class="s4">@throws </span><span class="s3">{Error} If the options are invalid.</span>
     <span class="s3">*/</span>
    <span class="s1">validateRuleOptions(rule, ruleId, options, source = </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s2">const </span><span class="s1">severity = </span><span class="s2">this</span><span class="s1">.validateRuleSeverity(options);</span>

            <span class="s2">if </span><span class="s1">(severity !== </span><span class="s5">0</span><span class="s1">) {</span>
                <span class="s2">this</span><span class="s1">.validateRuleSchema(rule, Array.isArray(options) ? options.slice(</span><span class="s5">1</span><span class="s1">) : []);</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
            <span class="s2">let </span><span class="s1">enhancedMessage = err.code === </span><span class="s0">&quot;ESLINT_INVALID_RULE_OPTIONS_SCHEMA&quot;</span>
                <span class="s1">? </span><span class="s0">`Error while processing options validation schema of rule '</span><span class="s1">${ruleId}</span><span class="s0">': </span><span class="s1">${err.message}</span><span class="s0">`</span>
                <span class="s1">: </span><span class="s0">`Configuration for rule &quot;</span><span class="s1">${ruleId}</span><span class="s0">&quot; is invalid:</span><span class="s7">\n</span><span class="s1">${err.message}</span><span class="s0">`</span><span class="s1">;</span>

            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">source === </span><span class="s0">&quot;string&quot;</span><span class="s1">) {</span>
                <span class="s1">enhancedMessage = </span><span class="s0">`</span><span class="s1">${source}</span><span class="s0">:</span><span class="s7">\n\t</span><span class="s1">${enhancedMessage}</span><span class="s0">`</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s2">const </span><span class="s1">enhancedError = </span><span class="s2">new </span><span class="s1">Error(enhancedMessage, { cause: err });</span>

            <span class="s2">if </span><span class="s1">(err.code) {</span>
                <span class="s1">enhancedError.code = err.code;</span>
            <span class="s1">}</span>

            <span class="s2">throw </span><span class="s1">enhancedError;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Validates an environment object</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} environment The environment config object to validate.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} source The name of the configuration source to report in any errors.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{(envId:string) =&gt; Object} [getAdditionalEnv] A map from strings to loaded environments.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{void}</span>
     <span class="s3">* </span><span class="s4">@throws </span><span class="s3">{Error} If the environment is invalid.</span>
     <span class="s3">*/</span>
    <span class="s1">validateEnvironment(</span>
        <span class="s1">environment,</span>
        <span class="s1">source,</span>
        <span class="s1">getAdditionalEnv = noop</span>
    <span class="s1">) {</span>

        <span class="s3">// not having an environment is ok</span>
        <span class="s2">if </span><span class="s1">(!environment) {</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">Object.keys(environment).forEach(id =&gt; {</span>
            <span class="s2">const </span><span class="s1">env = getAdditionalEnv(id) || environments.get(id) || </span><span class="s2">null</span><span class="s1">;</span>

            <span class="s2">if </span><span class="s1">(!env) {</span>
                <span class="s2">const </span><span class="s1">message = </span><span class="s0">`</span><span class="s1">${source}</span><span class="s0">:</span><span class="s7">\n\t</span><span class="s0">Environment key &quot;</span><span class="s1">${id}</span><span class="s0">&quot; is unknown</span><span class="s7">\n</span><span class="s0">`</span><span class="s1">;</span>

                <span class="s2">throw new </span><span class="s1">Error(message);</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Validates a rules config object</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} rulesConfig The rules config object to validate.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} source The name of the configuration source to report in any errors.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{(ruleId:string) =&gt; Object} getAdditionalRule A map from strings to loaded rules</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{void}</span>
     <span class="s3">*/</span>
    <span class="s1">validateRules(</span>
        <span class="s1">rulesConfig,</span>
        <span class="s1">source,</span>
        <span class="s1">getAdditionalRule = noop</span>
    <span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(!rulesConfig) {</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">Object.keys(rulesConfig).forEach(id =&gt; {</span>
            <span class="s2">const </span><span class="s1">rule = getAdditionalRule(id) || </span><span class="s2">this</span><span class="s1">.builtInRules.get(id) || </span><span class="s2">null</span><span class="s1">;</span>

            <span class="s2">this</span><span class="s1">.validateRuleOptions(rule, id, rulesConfig[id], source);</span>
        <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Validates a `globals` section of a config file</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} globalsConfig The `globals` section</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string|null} source The name of the configuration source to report in the event of an error.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{void}</span>
     <span class="s3">*/</span>
    <span class="s1">validateGlobals(globalsConfig, source = </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(!globalsConfig) {</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s1">Object.entries(globalsConfig)</span>
            <span class="s1">.forEach(([configuredGlobal, configuredValue]) =&gt; {</span>
                <span class="s2">try </span><span class="s1">{</span>
                    <span class="s1">normalizeConfigGlobal(configuredValue);</span>
                <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
                    <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">`ESLint configuration of global '</span><span class="s1">${configuredGlobal}</span><span class="s0">' in </span><span class="s1">${source} </span><span class="s0">is invalid:</span><span class="s7">\n</span><span class="s1">${err.message}</span><span class="s0">`</span><span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Validate `processor` configuration.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string|undefined} processorName The processor name.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} source The name of config file.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{(id:string) =&gt; Processor} getProcessor The getter of defined processors.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{void}</span>
     <span class="s3">* </span><span class="s4">@throws </span><span class="s3">{Error} If the processor is invalid.</span>
     <span class="s3">*/</span>
    <span class="s1">validateProcessor(processorName, source, getProcessor) {</span>
        <span class="s2">if </span><span class="s1">(processorName &amp;&amp; !getProcessor(processorName)) {</span>
            <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">`ESLint configuration of processor in '</span><span class="s1">${source}</span><span class="s0">' is invalid: '</span><span class="s1">${processorName}</span><span class="s0">' was not found.`</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Formats an array of schema validation errors.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Array} errors An array of error messages to format.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{string} Formatted error message</span>
     <span class="s3">*/</span>
    <span class="s1">formatErrors(errors) {</span>
        <span class="s2">return </span><span class="s1">errors.map(error =&gt; {</span>
            <span class="s2">if </span><span class="s1">(error.keyword === </span><span class="s0">&quot;additionalProperties&quot;</span><span class="s1">) {</span>
                <span class="s2">const </span><span class="s1">formattedPropertyPath = error.dataPath.length ? </span><span class="s0">`</span><span class="s1">${error.dataPath.slice(</span><span class="s5">1</span><span class="s1">)}</span><span class="s0">.</span><span class="s1">${error.params.additionalProperty}</span><span class="s0">` </span><span class="s1">: error.params.additionalProperty;</span>

                <span class="s2">return </span><span class="s0">`Unexpected top-level property &quot;</span><span class="s1">${formattedPropertyPath}</span><span class="s0">&quot;`</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(error.keyword === </span><span class="s0">&quot;type&quot;</span><span class="s1">) {</span>
                <span class="s2">const </span><span class="s1">formattedField = error.dataPath.slice(</span><span class="s5">1</span><span class="s1">);</span>
                <span class="s2">const </span><span class="s1">formattedExpectedType = Array.isArray(error.schema) ? error.schema.join(</span><span class="s0">&quot;/&quot;</span><span class="s1">) : error.schema;</span>
                <span class="s2">const </span><span class="s1">formattedValue = JSON.stringify(error.data);</span>

                <span class="s2">return </span><span class="s0">`Property &quot;</span><span class="s1">${formattedField}</span><span class="s0">&quot; is the wrong type (expected </span><span class="s1">${formattedExpectedType} </span><span class="s0">but got </span><span class="s7">\`</span><span class="s1">${formattedValue}</span><span class="s7">\`</span><span class="s0">)`</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s2">const </span><span class="s1">field = error.dataPath[</span><span class="s5">0</span><span class="s1">] === </span><span class="s0">&quot;.&quot; </span><span class="s1">? error.dataPath.slice(</span><span class="s5">1</span><span class="s1">) : error.dataPath;</span>

            <span class="s2">return </span><span class="s0">`&quot;</span><span class="s1">${field}</span><span class="s0">&quot; </span><span class="s1">${error.message}</span><span class="s0">. Value: </span><span class="s1">${JSON.stringify(error.data)}</span><span class="s0">`</span><span class="s1">;</span>
        <span class="s1">}).map(message =&gt; </span><span class="s0">`</span><span class="s7">\t</span><span class="s0">- </span><span class="s1">${message}</span><span class="s0">.</span><span class="s7">\n</span><span class="s0">`</span><span class="s1">).join(</span><span class="s0">&quot;&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Validates the top level properties of the config object.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} config The config object to validate.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} source The name of the configuration source to report in any errors.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{void}</span>
     <span class="s3">* </span><span class="s4">@throws </span><span class="s3">{Error} If the config is invalid.</span>
     <span class="s3">*/</span>
    <span class="s1">validateConfigSchema(config, source = </span><span class="s2">null</span><span class="s1">) {</span>
        <span class="s1">validateSchema = validateSchema || ajv.compile(configSchema);</span>

        <span class="s2">if </span><span class="s1">(!validateSchema(config)) {</span>
            <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">`ESLint configuration in </span><span class="s1">${source} </span><span class="s0">is invalid:</span><span class="s7">\n</span><span class="s1">${</span><span class="s2">this</span><span class="s1">.formatErrors(validateSchema.errors)}</span><span class="s0">`</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(Object.hasOwn(config, </span><span class="s0">&quot;ecmaFeatures&quot;</span><span class="s1">)) {</span>
            <span class="s1">emitDeprecationWarning(source, </span><span class="s0">&quot;ESLINT_LEGACY_ECMAFEATURES&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Validates an entire config object.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} config The config object to validate.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} source The name of the configuration source to report in any errors.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{(ruleId:string) =&gt; Object} [getAdditionalRule] A map from strings to loaded rules.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{(envId:string) =&gt; Object} [getAdditionalEnv] A map from strings to loaded envs.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{void}</span>
     <span class="s3">*/</span>
    <span class="s1">validate(config, source, getAdditionalRule, getAdditionalEnv) {</span>
        <span class="s2">this</span><span class="s1">.validateConfigSchema(config, source);</span>
        <span class="s2">this</span><span class="s1">.validateRules(config.rules, source, getAdditionalRule);</span>
        <span class="s2">this</span><span class="s1">.validateEnvironment(config.env, source, getAdditionalEnv);</span>
        <span class="s2">this</span><span class="s1">.validateGlobals(config.globals, source);</span>

        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">override of config.overrides || []) {</span>
            <span class="s2">this</span><span class="s1">.validateRules(override.rules, source, getAdditionalRule);</span>
            <span class="s2">this</span><span class="s1">.validateEnvironment(override.env, source, getAdditionalEnv);</span>
            <span class="s2">this</span><span class="s1">.validateGlobals(config.globals, source);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Validate config array object.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{ConfigArray} configArray The config array to validate.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{void}</span>
     <span class="s3">*/</span>
    <span class="s1">validateConfigArray(configArray) {</span>
        <span class="s2">const </span><span class="s1">getPluginEnv = Map.prototype.get.bind(configArray.pluginEnvironments);</span>
        <span class="s2">const </span><span class="s1">getPluginProcessor = Map.prototype.get.bind(configArray.pluginProcessors);</span>
        <span class="s2">const </span><span class="s1">getPluginRule = Map.prototype.get.bind(configArray.pluginRules);</span>

        <span class="s3">// Validate.</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">element of configArray) {</span>
            <span class="s2">if </span><span class="s1">(validated.has(element)) {</span>
                <span class="s2">continue</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">validated.add(element);</span>

            <span class="s2">this</span><span class="s1">.validateEnvironment(element.env, element.name, getPluginEnv);</span>
            <span class="s2">this</span><span class="s1">.validateGlobals(element.globals, element.name);</span>
            <span class="s2">this</span><span class="s1">.validateProcessor(element.processor, element.name, getPluginProcessor);</span>
            <span class="s2">this</span><span class="s1">.validateRules(element.rules, element.name, getPluginRule);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@fileoverview </span><span class="s3">Common helpers for naming of plugins, formatters and configs</span>
 <span class="s3">*/</span>

<span class="s2">const </span><span class="s1">NAMESPACE_REGEX = </span><span class="s6">/^@.*\//iu</span><span class="s1">;</span>

<span class="s3">/**</span>
 <span class="s3">* Brings package name to correct format based on prefix</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} name The name of the package.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} prefix Can be either &quot;eslint-plugin&quot;, &quot;eslint-config&quot; or &quot;eslint-formatter&quot;</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{string} Normalized name of the package</span>
 <span class="s3">* </span><span class="s4">@private</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">normalizePackageName(name, prefix) {</span>
    <span class="s2">let </span><span class="s1">normalizedName = name;</span>

    <span class="s3">/**</span>
     <span class="s3">* On Windows, name can come in with Windows slashes instead of Unix slashes.</span>
     <span class="s3">* Normalize to Unix first to avoid errors later on.</span>
     <span class="s3">* https://github.com/eslint/eslint/issues/5644</span>
     <span class="s3">*/</span>
    <span class="s2">if </span><span class="s1">(normalizedName.includes(</span><span class="s0">&quot;</span><span class="s7">\\</span><span class="s0">&quot;</span><span class="s1">)) {</span>
        <span class="s1">normalizedName = normalizedName.replace(</span><span class="s6">/\\/gu</span><span class="s1">, </span><span class="s0">&quot;/&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(normalizedName.charAt(</span><span class="s5">0</span><span class="s1">) === </span><span class="s0">&quot;@&quot;</span><span class="s1">) {</span>

        <span class="s3">/**</span>
         <span class="s3">* it's a scoped package</span>
         <span class="s3">* package name is the prefix, or just a username</span>
         <span class="s3">*/</span>
        <span class="s2">const </span><span class="s1">scopedPackageShortcutRegex = </span><span class="s2">new </span><span class="s1">RegExp(</span><span class="s0">`^(@[^/]+)(?:/(?:</span><span class="s1">${prefix}</span><span class="s0">)?)?$`</span><span class="s1">, </span><span class="s0">&quot;u&quot;</span><span class="s1">),</span>
            <span class="s1">scopedPackageNameRegex = </span><span class="s2">new </span><span class="s1">RegExp(</span><span class="s0">`^</span><span class="s1">${prefix}</span><span class="s0">(-|$)`</span><span class="s1">, </span><span class="s0">&quot;u&quot;</span><span class="s1">);</span>

        <span class="s2">if </span><span class="s1">(scopedPackageShortcutRegex.test(normalizedName)) {</span>
            <span class="s1">normalizedName = normalizedName.replace(scopedPackageShortcutRegex, </span><span class="s0">`$1/</span><span class="s1">${prefix}</span><span class="s0">`</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!scopedPackageNameRegex.test(normalizedName.split(</span><span class="s0">&quot;/&quot;</span><span class="s1">)[</span><span class="s5">1</span><span class="s1">])) {</span>

            <span class="s3">/**</span>
             <span class="s3">* for scoped packages, insert the prefix after the first / unless</span>
             <span class="s3">* the path is already @scope/eslint or @scope/eslint-xxx-yyy</span>
             <span class="s3">*/</span>
            <span class="s1">normalizedName = normalizedName.replace(</span><span class="s6">/^@([^/]+)\/(.*)$/u</span><span class="s1">, </span><span class="s0">`@$1/</span><span class="s1">${prefix}</span><span class="s0">-$2`</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(!normalizedName.startsWith(</span><span class="s0">`</span><span class="s1">${prefix}</span><span class="s0">-`</span><span class="s1">)) {</span>
        <span class="s1">normalizedName = </span><span class="s0">`</span><span class="s1">${prefix}</span><span class="s0">-</span><span class="s1">${normalizedName}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">normalizedName;</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Removes the prefix from a fullname.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} fullname The term which may have the prefix.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} prefix The prefix to remove.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{string} The term without prefix.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">getShorthandName(fullname, prefix) {</span>
    <span class="s2">if </span><span class="s1">(fullname[</span><span class="s5">0</span><span class="s1">] === </span><span class="s0">&quot;@&quot;</span><span class="s1">) {</span>
        <span class="s2">let </span><span class="s1">matchResult = </span><span class="s2">new </span><span class="s1">RegExp(</span><span class="s0">`^(@[^/]+)/</span><span class="s1">${prefix}</span><span class="s0">$`</span><span class="s1">, </span><span class="s0">&quot;u&quot;</span><span class="s1">).exec(fullname);</span>

        <span class="s2">if </span><span class="s1">(matchResult) {</span>
            <span class="s2">return </span><span class="s1">matchResult[</span><span class="s5">1</span><span class="s1">];</span>
        <span class="s1">}</span>

        <span class="s1">matchResult = </span><span class="s2">new </span><span class="s1">RegExp(</span><span class="s0">`^(@[^/]+)/</span><span class="s1">${prefix}</span><span class="s0">-(.+)$`</span><span class="s1">, </span><span class="s0">&quot;u&quot;</span><span class="s1">).exec(fullname);</span>
        <span class="s2">if </span><span class="s1">(matchResult) {</span>
            <span class="s2">return </span><span class="s0">`</span><span class="s1">${matchResult[</span><span class="s5">1</span><span class="s1">]}</span><span class="s0">/</span><span class="s1">${matchResult[</span><span class="s5">2</span><span class="s1">]}</span><span class="s0">`</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(fullname.startsWith(</span><span class="s0">`</span><span class="s1">${prefix}</span><span class="s0">-`</span><span class="s1">)) {</span>
        <span class="s2">return </span><span class="s1">fullname.slice(prefix.length + </span><span class="s5">1</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">fullname;</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Gets the scope (namespace) of a term.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} term The term which may have the namespace.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{string} The namespace of the term if it has one.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">getNamespaceFromTerm(term) {</span>
    <span class="s2">const </span><span class="s1">match = term.match(NAMESPACE_REGEX);</span>

    <span class="s2">return </span><span class="s1">match ? match[</span><span class="s5">0</span><span class="s1">] : </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s2">var </span><span class="s1">naming = {</span>
    <span class="s1">__proto__: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">normalizePackageName: normalizePackageName,</span>
    <span class="s1">getShorthandName: getShorthandName,</span>
    <span class="s1">getNamespaceFromTerm: getNamespaceFromTerm</span>
<span class="s1">};</span>

<span class="s3">/**</span>
 <span class="s3">* Utility for resolving a module relative to another module</span>
 <span class="s3">* </span><span class="s4">@author </span><span class="s3">Teddy Katz</span>
 <span class="s3">*/</span>

<span class="s3">/* 
 * `Module.createRequire` is added in v12.2.0. It supports URL as well. 
 * We only support the case where the argument is a filepath, not a URL. 
 */</span>
<span class="s2">const </span><span class="s1">createRequire = Module__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].createRequire;</span>

<span class="s3">/**</span>
 <span class="s3">* Resolves a Node module relative to another module</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} moduleName The name of a Node module, or a path to a Node module.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} relativeToPath An absolute path indicating the module that `moduleName` should be resolved relative to. This must be</span>
 <span class="s3">* a file rather than a directory, but the file need not actually exist.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{string} The absolute path that would result from calling `require.resolve(moduleName)` in a file located at `relativeToPath`</span>
 <span class="s3">* </span><span class="s4">@throws </span><span class="s3">{Error} When the module cannot be resolved.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">resolve(moduleName, relativeToPath) {</span>
    <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">return </span><span class="s1">createRequire(relativeToPath).resolve(moduleName);</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>

        <span class="s3">// This `if` block is for older Node.js than 12.0.0. We can remove this block in the future.</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s2">typeof </span><span class="s1">error === </span><span class="s0">&quot;object&quot; </span><span class="s1">&amp;&amp;</span>
            <span class="s1">error !== </span><span class="s2">null </span><span class="s1">&amp;&amp;</span>
            <span class="s1">error.code === </span><span class="s0">&quot;MODULE_NOT_FOUND&quot; </span><span class="s1">&amp;&amp;</span>
            <span class="s1">!error.requireStack &amp;&amp;</span>
            <span class="s1">error.message.includes(moduleName)</span>
        <span class="s1">) {</span>
            <span class="s1">error.message += </span><span class="s0">`</span><span class="s7">\n</span><span class="s0">Require stack:</span><span class="s7">\n</span><span class="s0">- </span><span class="s1">${relativeToPath}</span><span class="s0">`</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">throw </span><span class="s1">error;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">var </span><span class="s1">ModuleResolver = {</span>
    <span class="s1">__proto__: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">resolve: resolve</span>
<span class="s1">};</span>

<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@fileoverview </span><span class="s3">The factory of `ConfigArray` objects.</span>
 <span class="s3">*</span>
 <span class="s3">* This class provides methods to create `ConfigArray` instance.</span>
 <span class="s3">*</span>
 <span class="s3">* - `create(configData, options)`</span>
 <span class="s3">*     Create a `ConfigArray` instance from a config data. This is to handle CLI</span>
 <span class="s3">*     options except `--config`.</span>
 <span class="s3">* - `loadFile(filePath, options)`</span>
 <span class="s3">*     Create a `ConfigArray` instance from a config file. This is to handle</span>
 <span class="s3">*     `--config` option. If the file was not found, throws the following error:</span>
 <span class="s3">*      - If the filename was `*.js`, a `MODULE_NOT_FOUND` error.</span>
 <span class="s3">*      - If the filename was `package.json`, an IO error or an</span>
 <span class="s3">*        `ESLINT_CONFIG_FIELD_NOT_FOUND` error.</span>
 <span class="s3">*      - Otherwise, an IO error such as `ENOENT`.</span>
 <span class="s3">* - `loadInDirectory(directoryPath, options)`</span>
 <span class="s3">*     Create a `ConfigArray` instance from a config file which is on a given</span>
 <span class="s3">*     directory. This tries to load `.eslintrc.*` or `package.json`. If not</span>
 <span class="s3">*     found, returns an empty `ConfigArray`.</span>
 <span class="s3">* - `loadESLintIgnore(filePath)`</span>
 <span class="s3">*     Create a `ConfigArray` instance from a config file that is `.eslintignore`</span>
 <span class="s3">*     format. This is to handle `--ignore-path` option.</span>
 <span class="s3">* - `loadDefaultESLintIgnore()`</span>
 <span class="s3">*     Create a `ConfigArray` instance from `.eslintignore` or `package.json` in</span>
 <span class="s3">*     the current working directory.</span>
 <span class="s3">*</span>
 <span class="s3">* `ConfigArrayFactory` class has the responsibility that loads configuration</span>
 <span class="s3">* files, including loading `extends`, `parser`, and `plugins`. The created</span>
 <span class="s3">* `ConfigArray` instance has the loaded `extends`, `parser`, and `plugins`.</span>
 <span class="s3">*</span>
 <span class="s3">* But this class doesn't handle cascading. `CascadingConfigArrayFactory` class</span>
 <span class="s3">* handles cascading and hierarchy.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">@author </span><span class="s3">Toru Nagashima &lt;https://github.com/mysticatea&gt;</span>
 <span class="s3">*/</span>

<span class="s2">const </span><span class="s1">require$1 = Module.createRequire(require(</span><span class="s0">'url'</span><span class="s1">).pathToFileURL(__filename).toString());</span>

<span class="s2">const </span><span class="s1">debug$2 = debugOrig__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">](</span><span class="s0">&quot;eslintrc:config-array-factory&quot;</span><span class="s1">);</span>

<span class="s3">//------------------------------------------------------------------------------</span>
<span class="s3">// Helpers</span>
<span class="s3">//------------------------------------------------------------------------------</span>

<span class="s2">const </span><span class="s1">configFilenames = [</span>
    <span class="s0">&quot;.eslintrc.js&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;.eslintrc.cjs&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;.eslintrc.yaml&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;.eslintrc.yml&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;.eslintrc.json&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;.eslintrc&quot;</span><span class="s1">,</span>
    <span class="s0">&quot;package.json&quot;</span>
<span class="s1">];</span>

<span class="s3">// Define types for VSCode IntelliSense.</span>
<span class="s3">/** </span><span class="s4">@typedef </span><span class="s3">{import(&quot;./shared/types&quot;).ConfigData} ConfigData */</span>
<span class="s3">/** </span><span class="s4">@typedef </span><span class="s3">{import(&quot;./shared/types&quot;).OverrideConfigData} OverrideConfigData */</span>
<span class="s3">/** </span><span class="s4">@typedef </span><span class="s3">{import(&quot;./shared/types&quot;).Parser} Parser */</span>
<span class="s3">/** </span><span class="s4">@typedef </span><span class="s3">{import(&quot;./shared/types&quot;).Plugin} Plugin */</span>
<span class="s3">/** </span><span class="s4">@typedef </span><span class="s3">{import(&quot;./shared/types&quot;).Rule} Rule */</span>
<span class="s3">/** </span><span class="s4">@typedef </span><span class="s3">{import(&quot;./config-array/config-dependency&quot;).DependentParser} DependentParser */</span>
<span class="s3">/** </span><span class="s4">@typedef </span><span class="s3">{import(&quot;./config-array/config-dependency&quot;).DependentPlugin} DependentPlugin */</span>
<span class="s3">/** </span><span class="s4">@typedef </span><span class="s3">{ConfigArray[0]} ConfigArrayElement */</span>

<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@typedef </span><span class="s3">{Object} ConfigArrayFactoryOptions</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{Map&lt;string,Plugin&gt;} [additionalPluginPool] The map for additional plugins.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{string} [cwd] The path to the current working directory.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{string} [resolvePluginsRelativeTo] A path to the directory that plugins should be resolved from. Defaults to `cwd`.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{Map&lt;string,Rule&gt;} builtInRules The rules that are built in to ESLint.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{Object} [resolver=ModuleResolver] The module resolver object.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{string} eslintAllPath The path to the definitions for eslint:all.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{Function} getEslintAllConfig Returns the config data for eslint:all.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{string} eslintRecommendedPath The path to the definitions for eslint:recommended.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{Function} getEslintRecommendedConfig Returns the config data for eslint:recommended.</span>
 <span class="s3">*/</span>

<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@typedef </span><span class="s3">{Object} ConfigArrayFactoryInternalSlots</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{Map&lt;string,Plugin&gt;} additionalPluginPool The map for additional plugins.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{string} cwd The path to the current working directory.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{string | undefined} resolvePluginsRelativeTo An absolute path the the directory that plugins should be resolved from.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{Map&lt;string,Rule&gt;} builtInRules The rules that are built in to ESLint.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{Object} [resolver=ModuleResolver] The module resolver object.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{string} eslintAllPath The path to the definitions for eslint:all.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{Function} getEslintAllConfig Returns the config data for eslint:all.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{string} eslintRecommendedPath The path to the definitions for eslint:recommended.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{Function} getEslintRecommendedConfig Returns the config data for eslint:recommended.</span>
 <span class="s3">*/</span>

<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@typedef </span><span class="s3">{Object} ConfigArrayFactoryLoadingContext</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{string} filePath The path to the current configuration.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{string} matchBasePath The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{string} name The name of the current configuration.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{string} pluginBasePath The base path to resolve plugins.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{&quot;config&quot; | &quot;ignore&quot; | &quot;implicit-processor&quot;} type The type of the current configuration. This is `&quot;config&quot;` in normal. This is `&quot;ignore&quot;` if it came from `.eslintignore`. This is `&quot;implicit-processor&quot;` if it came from legacy file-extension processors.</span>
 <span class="s3">*/</span>

<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@typedef </span><span class="s3">{Object} ConfigArrayFactoryLoadingContext</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{string} filePath The path to the current configuration.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{string} matchBasePath The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{string} name The name of the current configuration.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{&quot;config&quot; | &quot;ignore&quot; | &quot;implicit-processor&quot;} type The type of the current configuration. This is `&quot;config&quot;` in normal. This is `&quot;ignore&quot;` if it came from `.eslintignore`. This is `&quot;implicit-processor&quot;` if it came from legacy file-extension processors.</span>
 <span class="s3">*/</span>

<span class="s3">/** </span><span class="s4">@type </span><span class="s3">{WeakMap&lt;ConfigArrayFactory, ConfigArrayFactoryInternalSlots&gt;} */</span>
<span class="s2">const </span><span class="s1">internalSlotsMap$1 = </span><span class="s2">new </span><span class="s1">WeakMap();</span>

<span class="s3">/** </span><span class="s4">@type </span><span class="s3">{WeakMap&lt;object, Plugin&gt;} */</span>
<span class="s2">const </span><span class="s1">normalizedPlugins = </span><span class="s2">new </span><span class="s1">WeakMap();</span>

<span class="s3">/**</span>
 <span class="s3">* Check if a given string is a file path.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} nameOrPath A module name or file path.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{boolean} `true` if the `nameOrPath` is a file path.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">isFilePath(nameOrPath) {</span>
    <span class="s2">return </span><span class="s1">(</span>
        <span class="s6">/^\.{1,2}[/\\]/u</span><span class="s1">.test(nameOrPath) ||</span>
        <span class="s1">path__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].isAbsolute(nameOrPath)</span>
    <span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Convenience wrapper for synchronously reading file contents.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} filePath The filename to read.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{string} The file contents, with the BOM removed.</span>
 <span class="s3">* </span><span class="s4">@private</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">readFile(filePath) {</span>
    <span class="s2">return </span><span class="s1">fs__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].readFileSync(filePath, </span><span class="s0">&quot;utf8&quot;</span><span class="s1">).replace(</span><span class="s6">/^\ufeff/u</span><span class="s1">, </span><span class="s0">&quot;&quot;</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Loads a YAML configuration from a file.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} filePath The filename to load.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{ConfigData} The configuration object from the file.</span>
 <span class="s3">* </span><span class="s4">@throws </span><span class="s3">{Error} If the file cannot be read.</span>
 <span class="s3">* </span><span class="s4">@private</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">loadYAMLConfigFile(filePath) {</span>
    <span class="s1">debug$2(</span><span class="s0">`Loading YAML config file: </span><span class="s1">${filePath}</span><span class="s0">`</span><span class="s1">);</span>

    <span class="s3">// lazy load YAML to improve performance when not used</span>
    <span class="s2">const </span><span class="s1">yaml = require$1(</span><span class="s0">&quot;js-yaml&quot;</span><span class="s1">);</span>

    <span class="s2">try </span><span class="s1">{</span>

        <span class="s3">// empty YAML file can be null, so always use</span>
        <span class="s2">return </span><span class="s1">yaml.load(readFile(filePath)) || {};</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {</span>
        <span class="s1">debug$2(</span><span class="s0">`Error reading YAML file: </span><span class="s1">${filePath}</span><span class="s0">`</span><span class="s1">);</span>
        <span class="s1">e.message = </span><span class="s0">`Cannot read config file: </span><span class="s1">${filePath}</span><span class="s7">\n</span><span class="s0">Error: </span><span class="s1">${e.message}</span><span class="s0">`</span><span class="s1">;</span>
        <span class="s2">throw </span><span class="s1">e;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Loads a JSON configuration from a file.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} filePath The filename to load.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{ConfigData} The configuration object from the file.</span>
 <span class="s3">* </span><span class="s4">@throws </span><span class="s3">{Error} If the file cannot be read.</span>
 <span class="s3">* </span><span class="s4">@private</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">loadJSONConfigFile(filePath) {</span>
    <span class="s1">debug$2(</span><span class="s0">`Loading JSON config file: </span><span class="s1">${filePath}</span><span class="s0">`</span><span class="s1">);</span>

    <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">return </span><span class="s1">JSON.parse(stripComments__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">](readFile(filePath)));</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {</span>
        <span class="s1">debug$2(</span><span class="s0">`Error reading JSON file: </span><span class="s1">${filePath}</span><span class="s0">`</span><span class="s1">);</span>
        <span class="s1">e.message = </span><span class="s0">`Cannot read config file: </span><span class="s1">${filePath}</span><span class="s7">\n</span><span class="s0">Error: </span><span class="s1">${e.message}</span><span class="s0">`</span><span class="s1">;</span>
        <span class="s1">e.messageTemplate = </span><span class="s0">&quot;failed-to-read-json&quot;</span><span class="s1">;</span>
        <span class="s1">e.messageData = {</span>
            <span class="s1">path: filePath,</span>
            <span class="s1">message: e.message</span>
        <span class="s1">};</span>
        <span class="s2">throw </span><span class="s1">e;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Loads a legacy (.eslintrc) configuration from a file.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} filePath The filename to load.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{ConfigData} The configuration object from the file.</span>
 <span class="s3">* </span><span class="s4">@throws </span><span class="s3">{Error} If the file cannot be read.</span>
 <span class="s3">* </span><span class="s4">@private</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">loadLegacyConfigFile(filePath) {</span>
    <span class="s1">debug$2(</span><span class="s0">`Loading legacy config file: </span><span class="s1">${filePath}</span><span class="s0">`</span><span class="s1">);</span>

    <span class="s3">// lazy load YAML to improve performance when not used</span>
    <span class="s2">const </span><span class="s1">yaml = require$1(</span><span class="s0">&quot;js-yaml&quot;</span><span class="s1">);</span>

    <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">return </span><span class="s1">yaml.load(stripComments__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">](readFile(filePath))) || </span><span class="s3">/* istanbul ignore next */ </span><span class="s1">{};</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {</span>
        <span class="s1">debug$2(</span><span class="s0">&quot;Error reading YAML file: %s</span><span class="s7">\n</span><span class="s0">%o&quot;</span><span class="s1">, filePath, e);</span>
        <span class="s1">e.message = </span><span class="s0">`Cannot read config file: </span><span class="s1">${filePath}</span><span class="s7">\n</span><span class="s0">Error: </span><span class="s1">${e.message}</span><span class="s0">`</span><span class="s1">;</span>
        <span class="s2">throw </span><span class="s1">e;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Loads a JavaScript configuration from a file.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} filePath The filename to load.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{ConfigData} The configuration object from the file.</span>
 <span class="s3">* </span><span class="s4">@throws </span><span class="s3">{Error} If the file cannot be read.</span>
 <span class="s3">* </span><span class="s4">@private</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">loadJSConfigFile(filePath) {</span>
    <span class="s1">debug$2(</span><span class="s0">`Loading JS config file: </span><span class="s1">${filePath}</span><span class="s0">`</span><span class="s1">);</span>
    <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">return </span><span class="s1">importFresh__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">](filePath);</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {</span>
        <span class="s1">debug$2(</span><span class="s0">`Error reading JavaScript file: </span><span class="s1">${filePath}</span><span class="s0">`</span><span class="s1">);</span>
        <span class="s1">e.message = </span><span class="s0">`Cannot read config file: </span><span class="s1">${filePath}</span><span class="s7">\n</span><span class="s0">Error: </span><span class="s1">${e.message}</span><span class="s0">`</span><span class="s1">;</span>
        <span class="s2">throw </span><span class="s1">e;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Loads a configuration from a package.json file.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} filePath The filename to load.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{ConfigData} The configuration object from the file.</span>
 <span class="s3">* </span><span class="s4">@throws </span><span class="s3">{Error} If the file cannot be read.</span>
 <span class="s3">* </span><span class="s4">@private</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">loadPackageJSONConfigFile(filePath) {</span>
    <span class="s1">debug$2(</span><span class="s0">`Loading package.json config file: </span><span class="s1">${filePath}</span><span class="s0">`</span><span class="s1">);</span>
    <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">const </span><span class="s1">packageData = loadJSONConfigFile(filePath);</span>

        <span class="s2">if </span><span class="s1">(!Object.hasOwn(packageData, </span><span class="s0">&quot;eslintConfig&quot;</span><span class="s1">)) {</span>
            <span class="s2">throw </span><span class="s1">Object.assign(</span>
                <span class="s2">new </span><span class="s1">Error(</span><span class="s0">&quot;package.json file doesn't have 'eslintConfig' field.&quot;</span><span class="s1">),</span>
                <span class="s1">{ code: </span><span class="s0">&quot;ESLINT_CONFIG_FIELD_NOT_FOUND&quot; </span><span class="s1">}</span>
            <span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s2">return </span><span class="s1">packageData.eslintConfig;</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {</span>
        <span class="s1">debug$2(</span><span class="s0">`Error reading package.json file: </span><span class="s1">${filePath}</span><span class="s0">`</span><span class="s1">);</span>
        <span class="s1">e.message = </span><span class="s0">`Cannot read config file: </span><span class="s1">${filePath}</span><span class="s7">\n</span><span class="s0">Error: </span><span class="s1">${e.message}</span><span class="s0">`</span><span class="s1">;</span>
        <span class="s2">throw </span><span class="s1">e;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Loads a `.eslintignore` from a file.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} filePath The filename to load.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{string[]} The ignore patterns from the file.</span>
 <span class="s3">* </span><span class="s4">@throws </span><span class="s3">{Error} If the file cannot be read.</span>
 <span class="s3">* </span><span class="s4">@private</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">loadESLintIgnoreFile(filePath) {</span>
    <span class="s1">debug$2(</span><span class="s0">`Loading .eslintignore file: </span><span class="s1">${filePath}</span><span class="s0">`</span><span class="s1">);</span>

    <span class="s2">try </span><span class="s1">{</span>
        <span class="s2">return </span><span class="s1">readFile(filePath)</span>
            <span class="s1">.split(</span><span class="s6">/\r?\n/gu</span><span class="s1">)</span>
            <span class="s1">.filter(line =&gt; line.trim() !== </span><span class="s0">&quot;&quot; </span><span class="s1">&amp;&amp; !line.startsWith(</span><span class="s0">&quot;#&quot;</span><span class="s1">));</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(e) {</span>
        <span class="s1">debug$2(</span><span class="s0">`Error reading .eslintignore file: </span><span class="s1">${filePath}</span><span class="s0">`</span><span class="s1">);</span>
        <span class="s1">e.message = </span><span class="s0">`Cannot read .eslintignore file: </span><span class="s1">${filePath}</span><span class="s7">\n</span><span class="s0">Error: </span><span class="s1">${e.message}</span><span class="s0">`</span><span class="s1">;</span>
        <span class="s2">throw </span><span class="s1">e;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Creates an error to notify about a missing config to extend from.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} configName The name of the missing config.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} importerName The name of the config that imported the missing config</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} messageTemplate The text template to source error strings from.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{Error} The error object to throw</span>
 <span class="s3">* </span><span class="s4">@private</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">configInvalidError(configName, importerName, messageTemplate) {</span>
    <span class="s2">return </span><span class="s1">Object.assign(</span>
        <span class="s2">new </span><span class="s1">Error(</span><span class="s0">`Failed to load config &quot;</span><span class="s1">${configName}</span><span class="s0">&quot; to extend from.`</span><span class="s1">),</span>
        <span class="s1">{</span>
            <span class="s1">messageTemplate,</span>
            <span class="s1">messageData: { configName, importerName }</span>
        <span class="s1">}</span>
    <span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Loads a configuration file regardless of the source. Inspects the file path</span>
 <span class="s3">* to determine the correctly way to load the config file.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} filePath The path to the configuration.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{ConfigData|null} The configuration information.</span>
 <span class="s3">* </span><span class="s4">@private</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">loadConfigFile(filePath) {</span>
    <span class="s2">switch </span><span class="s1">(path__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].extname(filePath)) {</span>
        <span class="s2">case </span><span class="s0">&quot;.js&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;.cjs&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">loadJSConfigFile(filePath);</span>

        <span class="s2">case </span><span class="s0">&quot;.json&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">(path__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].basename(filePath) === </span><span class="s0">&quot;package.json&quot;</span><span class="s1">) {</span>
                <span class="s2">return </span><span class="s1">loadPackageJSONConfigFile(filePath);</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">loadJSONConfigFile(filePath);</span>

        <span class="s2">case </span><span class="s0">&quot;.yaml&quot;</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">&quot;.yml&quot;</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">loadYAMLConfigFile(filePath);</span>

        <span class="s2">default</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">loadLegacyConfigFile(filePath);</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Write debug log.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} request The requested module name.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} relativeTo The file path to resolve the request relative to.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} filePath The resolved file path.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{void}</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">writeDebugLogForLoading(request, relativeTo, filePath) {</span>
    <span class="s3">/* istanbul ignore next */</span>
    <span class="s2">if </span><span class="s1">(debug$2.enabled) {</span>
        <span class="s2">let </span><span class="s1">nameAndVersion = </span><span class="s2">null</span><span class="s1">; </span><span class="s3">// eslint-disable-line no-useless-assignment -- known bug in the rule</span>

        <span class="s2">try </span><span class="s1">{</span>
            <span class="s2">const </span><span class="s1">packageJsonPath = resolve(</span>
                <span class="s0">`</span><span class="s1">${request}</span><span class="s0">/package.json`</span><span class="s1">,</span>
                <span class="s1">relativeTo</span>
            <span class="s1">);</span>
            <span class="s2">const </span><span class="s1">{ version = </span><span class="s0">&quot;unknown&quot; </span><span class="s1">} = require$1(packageJsonPath);</span>

            <span class="s1">nameAndVersion = </span><span class="s0">`</span><span class="s1">${request}</span><span class="s0">@</span><span class="s1">${version}</span><span class="s0">`</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
            <span class="s1">debug$2(</span><span class="s0">&quot;package.json was not found:&quot;</span><span class="s1">, error.message);</span>
            <span class="s1">nameAndVersion = request;</span>
        <span class="s1">}</span>

        <span class="s1">debug$2(</span><span class="s0">&quot;Loaded: %s (%s)&quot;</span><span class="s1">, nameAndVersion, filePath);</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Create a new context with default values.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{ConfigArrayFactoryInternalSlots} slots The internal slots.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{&quot;config&quot; | &quot;ignore&quot; | &quot;implicit-processor&quot; | undefined} providedType The type of the current configuration. Default is `&quot;config&quot;`.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string | undefined} providedName The name of the current configuration. Default is the relative path from `cwd` to `filePath`.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string | undefined} providedFilePath The path to the current configuration. Default is empty string.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string | undefined} providedMatchBasePath The type of the current configuration. Default is the directory of `filePath` or `cwd`.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{ConfigArrayFactoryLoadingContext} The created context.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">createContext(</span>
    <span class="s1">{ cwd, resolvePluginsRelativeTo },</span>
    <span class="s1">providedType,</span>
    <span class="s1">providedName,</span>
    <span class="s1">providedFilePath,</span>
    <span class="s1">providedMatchBasePath</span>
<span class="s1">) {</span>
    <span class="s2">const </span><span class="s1">filePath = providedFilePath</span>
        <span class="s1">? path__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].resolve(cwd, providedFilePath)</span>
        <span class="s1">: </span><span class="s0">&quot;&quot;</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">matchBasePath =</span>
        <span class="s1">(providedMatchBasePath &amp;&amp; path__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].resolve(cwd, providedMatchBasePath)) ||</span>
        <span class="s1">(filePath &amp;&amp; path__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].dirname(filePath)) ||</span>
        <span class="s1">cwd;</span>
    <span class="s2">const </span><span class="s1">name =</span>
        <span class="s1">providedName ||</span>
        <span class="s1">(filePath &amp;&amp; path__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].relative(cwd, filePath)) ||</span>
        <span class="s0">&quot;&quot;</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">pluginBasePath =</span>
        <span class="s1">resolvePluginsRelativeTo ||</span>
        <span class="s1">(filePath &amp;&amp; path__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].dirname(filePath)) ||</span>
        <span class="s1">cwd;</span>
    <span class="s2">const </span><span class="s1">type = providedType || </span><span class="s0">&quot;config&quot;</span><span class="s1">;</span>

    <span class="s2">return </span><span class="s1">{ filePath, matchBasePath, name, pluginBasePath, type };</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Normalize a given plugin.</span>
 <span class="s3">* - Ensure the object to have four properties: configs, environments, processors, and rules.</span>
 <span class="s3">* - Ensure the object to not have other properties.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Plugin} plugin The plugin to normalize.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{Plugin} The normalized plugin.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">normalizePlugin(plugin) {</span>

    <span class="s3">// first check the cache</span>
    <span class="s2">let </span><span class="s1">normalizedPlugin = normalizedPlugins.get(plugin);</span>

    <span class="s2">if </span><span class="s1">(normalizedPlugin) {</span>
        <span class="s2">return </span><span class="s1">normalizedPlugin;</span>
    <span class="s1">}</span>

    <span class="s1">normalizedPlugin = {</span>
        <span class="s1">configs: plugin.configs || {},</span>
        <span class="s1">environments: plugin.environments || {},</span>
        <span class="s1">processors: plugin.processors || {},</span>
        <span class="s1">rules: plugin.rules || {}</span>
    <span class="s1">};</span>

    <span class="s3">// save the reference for later</span>
    <span class="s1">normalizedPlugins.set(plugin, normalizedPlugin);</span>

    <span class="s2">return </span><span class="s1">normalizedPlugin;</span>
<span class="s1">}</span>

<span class="s3">//------------------------------------------------------------------------------</span>
<span class="s3">// Public Interface</span>
<span class="s3">//------------------------------------------------------------------------------</span>

<span class="s3">/**</span>
 <span class="s3">* The factory of `ConfigArray` objects.</span>
 <span class="s3">*/</span>
<span class="s2">class </span><span class="s1">ConfigArrayFactory {</span>

    <span class="s3">/**</span>
     <span class="s3">* Initialize this instance.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{ConfigArrayFactoryOptions} [options] The map for additional plugins.</span>
     <span class="s3">*/</span>
    <span class="s1">constructor({</span>
        <span class="s1">additionalPluginPool = </span><span class="s2">new </span><span class="s1">Map(),</span>
        <span class="s1">cwd = process.cwd(),</span>
        <span class="s1">resolvePluginsRelativeTo,</span>
        <span class="s1">builtInRules,</span>
        <span class="s1">resolver = ModuleResolver,</span>
        <span class="s1">eslintAllPath,</span>
        <span class="s1">getEslintAllConfig,</span>
        <span class="s1">eslintRecommendedPath,</span>
        <span class="s1">getEslintRecommendedConfig</span>
    <span class="s1">} = {}) {</span>
        <span class="s1">internalSlotsMap$1.set(</span><span class="s2">this</span><span class="s1">, {</span>
            <span class="s1">additionalPluginPool,</span>
            <span class="s1">cwd,</span>
            <span class="s1">resolvePluginsRelativeTo:</span>
                <span class="s1">resolvePluginsRelativeTo &amp;&amp;</span>
                <span class="s1">path__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].resolve(cwd, resolvePluginsRelativeTo),</span>
            <span class="s1">builtInRules,</span>
            <span class="s1">resolver,</span>
            <span class="s1">eslintAllPath,</span>
            <span class="s1">getEslintAllConfig,</span>
            <span class="s1">eslintRecommendedPath,</span>
            <span class="s1">getEslintRecommendedConfig</span>
        <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Create `ConfigArray` instance from a config data.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{ConfigData|null} configData The config data to create.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} [options] The options.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} [options.basePath] The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} [options.filePath] The path to this config data.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} [options.name] The config name.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{ConfigArray} Loaded config.</span>
     <span class="s3">*/</span>
    <span class="s1">create(configData, { basePath, filePath, name } = {}) {</span>
        <span class="s2">if </span><span class="s1">(!configData) {</span>
            <span class="s2">return new </span><span class="s1">ConfigArray();</span>
        <span class="s1">}</span>

        <span class="s2">const </span><span class="s1">slots = internalSlotsMap$1.get(</span><span class="s2">this</span><span class="s1">);</span>
        <span class="s2">const </span><span class="s1">ctx = createContext(slots, </span><span class="s0">&quot;config&quot;</span><span class="s1">, name, filePath, basePath);</span>
        <span class="s2">const </span><span class="s1">elements = </span><span class="s2">this</span><span class="s1">._normalizeConfigData(configData, ctx);</span>

        <span class="s2">return new </span><span class="s1">ConfigArray(...elements);</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Load a config file.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} filePath The path to a config file.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} [options] The options.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} [options.basePath] The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} [options.name] The config name.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{ConfigArray} Loaded config.</span>
     <span class="s3">*/</span>
    <span class="s1">loadFile(filePath, { basePath, name } = {}) {</span>
        <span class="s2">const </span><span class="s1">slots = internalSlotsMap$1.get(</span><span class="s2">this</span><span class="s1">);</span>
        <span class="s2">const </span><span class="s1">ctx = createContext(slots, </span><span class="s0">&quot;config&quot;</span><span class="s1">, name, filePath, basePath);</span>

        <span class="s2">return new </span><span class="s1">ConfigArray(...</span><span class="s2">this</span><span class="s1">._loadConfigData(ctx));</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Load the config file on a given directory if exists.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} directoryPath The path to a directory.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} [options] The options.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} [options.basePath] The base path to resolve relative paths in `overrides[].files`, `overrides[].excludedFiles`, and `ignorePatterns`.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} [options.name] The config name.</span>
     <span class="s3">* </span><span class="s4">@throws </span><span class="s3">{Error} If the config file is invalid.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.</span>
     <span class="s3">*/</span>
    <span class="s1">loadInDirectory(directoryPath, { basePath, name } = {}) {</span>
        <span class="s2">const </span><span class="s1">slots = internalSlotsMap$1.get(</span><span class="s2">this</span><span class="s1">);</span>

        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">filename of configFilenames) {</span>
            <span class="s2">const </span><span class="s1">ctx = createContext(</span>
                <span class="s1">slots,</span>
                <span class="s0">&quot;config&quot;</span><span class="s1">,</span>
                <span class="s1">name,</span>
                <span class="s1">path__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].join(directoryPath, filename),</span>
                <span class="s1">basePath</span>
            <span class="s1">);</span>

            <span class="s2">if </span><span class="s1">(fs__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].existsSync(ctx.filePath) &amp;&amp; fs__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].statSync(ctx.filePath).isFile()) {</span>
                <span class="s2">let </span><span class="s1">configData;</span>

                <span class="s2">try </span><span class="s1">{</span>
                    <span class="s1">configData = loadConfigFile(ctx.filePath);</span>
                <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
                    <span class="s2">if </span><span class="s1">(!error || error.code !== </span><span class="s0">&quot;ESLINT_CONFIG_FIELD_NOT_FOUND&quot;</span><span class="s1">) {</span>
                        <span class="s2">throw </span><span class="s1">error;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>

                <span class="s2">if </span><span class="s1">(configData) {</span>
                    <span class="s1">debug$2(</span><span class="s0">`Config file found: </span><span class="s1">${ctx.filePath}</span><span class="s0">`</span><span class="s1">);</span>
                    <span class="s2">return new </span><span class="s1">ConfigArray(</span>
                        <span class="s1">...</span><span class="s2">this</span><span class="s1">._normalizeConfigData(configData, ctx)</span>
                    <span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">debug$2(</span><span class="s0">`Config file not found on </span><span class="s1">${directoryPath}</span><span class="s0">`</span><span class="s1">);</span>
        <span class="s2">return new </span><span class="s1">ConfigArray();</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Check if a config file on a given directory exists or not.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} directoryPath The path to a directory.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{string | null} The path to the found config file. If not found then null.</span>
     <span class="s3">*/</span>
    <span class="s2">static </span><span class="s1">getPathToConfigFileInDirectory(directoryPath) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">filename of configFilenames) {</span>
            <span class="s2">const </span><span class="s1">filePath = path__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].join(directoryPath, filename);</span>

            <span class="s2">if </span><span class="s1">(fs__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].existsSync(filePath)) {</span>
                <span class="s2">if </span><span class="s1">(filename === </span><span class="s0">&quot;package.json&quot;</span><span class="s1">) {</span>
                    <span class="s2">try </span><span class="s1">{</span>
                        <span class="s1">loadPackageJSONConfigFile(filePath);</span>
                        <span class="s2">return </span><span class="s1">filePath;</span>
                    <span class="s1">} </span><span class="s2">catch </span><span class="s1">{ </span><span class="s3">/* ignore */ </span><span class="s1">}</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">return </span><span class="s1">filePath;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Load `.eslintignore` file.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} filePath The path to a `.eslintignore` file to load.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.</span>
     <span class="s3">*/</span>
    <span class="s1">loadESLintIgnore(filePath) {</span>
        <span class="s2">const </span><span class="s1">slots = internalSlotsMap$1.get(</span><span class="s2">this</span><span class="s1">);</span>
        <span class="s2">const </span><span class="s1">ctx = createContext(</span>
            <span class="s1">slots,</span>
            <span class="s0">&quot;ignore&quot;</span><span class="s1">,</span>
            <span class="s2">void </span><span class="s5">0</span><span class="s1">,</span>
            <span class="s1">filePath,</span>
            <span class="s1">slots.cwd</span>
        <span class="s1">);</span>
        <span class="s2">const </span><span class="s1">ignorePatterns = loadESLintIgnoreFile(ctx.filePath);</span>

        <span class="s2">return new </span><span class="s1">ConfigArray(</span>
            <span class="s1">...</span><span class="s2">this</span><span class="s1">._normalizeESLintIgnoreData(ignorePatterns, ctx)</span>
        <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Load `.eslintignore` file in the current working directory.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{ConfigArray} Loaded config. An empty `ConfigArray` if any config doesn't exist.</span>
     <span class="s3">* </span><span class="s4">@throws </span><span class="s3">{Error} If the ignore file is invalid.</span>
     <span class="s3">*/</span>
    <span class="s1">loadDefaultESLintIgnore() {</span>
        <span class="s2">const </span><span class="s1">slots = internalSlotsMap$1.get(</span><span class="s2">this</span><span class="s1">);</span>
        <span class="s2">const </span><span class="s1">eslintIgnorePath = path__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].resolve(slots.cwd, </span><span class="s0">&quot;.eslintignore&quot;</span><span class="s1">);</span>
        <span class="s2">const </span><span class="s1">packageJsonPath = path__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].resolve(slots.cwd, </span><span class="s0">&quot;package.json&quot;</span><span class="s1">);</span>

        <span class="s2">if </span><span class="s1">(fs__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].existsSync(eslintIgnorePath)) {</span>
            <span class="s2">return this</span><span class="s1">.loadESLintIgnore(eslintIgnorePath);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(fs__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].existsSync(packageJsonPath)) {</span>
            <span class="s2">const </span><span class="s1">data = loadJSONConfigFile(packageJsonPath);</span>

            <span class="s2">if </span><span class="s1">(Object.hasOwn(data, </span><span class="s0">&quot;eslintIgnore&quot;</span><span class="s1">)) {</span>
                <span class="s2">if </span><span class="s1">(!Array.isArray(data.eslintIgnore)) {</span>
                    <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">&quot;Package.json eslintIgnore property requires an array of paths&quot;</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">ctx = createContext(</span>
                    <span class="s1">slots,</span>
                    <span class="s0">&quot;ignore&quot;</span><span class="s1">,</span>
                    <span class="s0">&quot;eslintIgnore in package.json&quot;</span><span class="s1">,</span>
                    <span class="s1">packageJsonPath,</span>
                    <span class="s1">slots.cwd</span>
                <span class="s1">);</span>

                <span class="s2">return new </span><span class="s1">ConfigArray(</span>
                    <span class="s1">...</span><span class="s2">this</span><span class="s1">._normalizeESLintIgnoreData(data.eslintIgnore, ctx)</span>
                <span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s2">return new </span><span class="s1">ConfigArray();</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Load a given config file.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{ConfigArrayFactoryLoadingContext} ctx The loading context.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{IterableIterator&lt;ConfigArrayElement&gt;} Loaded config.</span>
     <span class="s3">* </span><span class="s4">@private</span>
     <span class="s3">*/</span>
    <span class="s1">_loadConfigData(ctx) {</span>
        <span class="s2">return this</span><span class="s1">._normalizeConfigData(loadConfigFile(ctx.filePath), ctx);</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Normalize a given `.eslintignore` data to config array elements.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string[]} ignorePatterns The patterns to ignore files.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{ConfigArrayFactoryLoadingContext} ctx The loading context.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{IterableIterator&lt;ConfigArrayElement&gt;} The normalized config.</span>
     <span class="s3">* </span><span class="s4">@private</span>
     <span class="s3">*/</span>
    <span class="s1">*_normalizeESLintIgnoreData(ignorePatterns, ctx) {</span>
        <span class="s2">const </span><span class="s1">elements = </span><span class="s2">this</span><span class="s1">._normalizeObjectConfigData(</span>
            <span class="s1">{ ignorePatterns },</span>
            <span class="s1">ctx</span>
        <span class="s1">);</span>

        <span class="s3">// Set `ignorePattern.loose` flag for backward compatibility.</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">element of elements) {</span>
            <span class="s2">if </span><span class="s1">(element.ignorePattern) {</span>
                <span class="s1">element.ignorePattern.loose = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">yield </span><span class="s1">element;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Normalize a given config to an array.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{ConfigData} configData The config data to normalize.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{ConfigArrayFactoryLoadingContext} ctx The loading context.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{IterableIterator&lt;ConfigArrayElement&gt;} The normalized config.</span>
     <span class="s3">* </span><span class="s4">@private</span>
     <span class="s3">*/</span>
    <span class="s1">_normalizeConfigData(configData, ctx) {</span>
        <span class="s2">const </span><span class="s1">validator = </span><span class="s2">new </span><span class="s1">ConfigValidator();</span>

        <span class="s1">validator.validateConfigSchema(configData, ctx.name || ctx.filePath);</span>
        <span class="s2">return this</span><span class="s1">._normalizeObjectConfigData(configData, ctx);</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Normalize a given config to an array.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{ConfigData|OverrideConfigData} configData The config data to normalize.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{ConfigArrayFactoryLoadingContext} ctx The loading context.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{IterableIterator&lt;ConfigArrayElement&gt;} The normalized config.</span>
     <span class="s3">* </span><span class="s4">@private</span>
     <span class="s3">*/</span>
    <span class="s1">*_normalizeObjectConfigData(configData, ctx) {</span>
        <span class="s2">const </span><span class="s1">{ files, excludedFiles, ...configBody } = configData;</span>
        <span class="s2">const </span><span class="s1">criteria = OverrideTester.create(</span>
            <span class="s1">files,</span>
            <span class="s1">excludedFiles,</span>
            <span class="s1">ctx.matchBasePath</span>
        <span class="s1">);</span>
        <span class="s2">const </span><span class="s1">elements = </span><span class="s2">this</span><span class="s1">._normalizeObjectConfigDataBody(configBody, ctx);</span>

        <span class="s3">// Apply the criteria to every element.</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">element of elements) {</span>

            <span class="s3">/* 
             * Merge the criteria. 
             * This is for the `overrides` entries that came from the 
             * configurations of `overrides[].extends`. 
             */</span>
            <span class="s1">element.criteria = OverrideTester.and(criteria, element.criteria);</span>

            <span class="s3">/* 
             * Remove `root` property to ignore `root` settings which came from 
             * `extends` in `overrides`. 
             */</span>
            <span class="s2">if </span><span class="s1">(element.criteria) {</span>
                <span class="s1">element.root = </span><span class="s2">void </span><span class="s5">0</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s2">yield </span><span class="s1">element;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Normalize a given config to an array.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{ConfigData} configData The config data to normalize.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{ConfigArrayFactoryLoadingContext} ctx The loading context.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{IterableIterator&lt;ConfigArrayElement&gt;} The normalized config.</span>
     <span class="s3">* </span><span class="s4">@private</span>
     <span class="s3">*/</span>
    <span class="s1">*_normalizeObjectConfigDataBody(</span>
        <span class="s1">{</span>
            <span class="s1">env,</span>
            <span class="s2">extends</span><span class="s1">: extend,</span>
            <span class="s1">globals,</span>
            <span class="s1">ignorePatterns,</span>
            <span class="s1">noInlineConfig,</span>
            <span class="s1">parser: parserName,</span>
            <span class="s1">parserOptions,</span>
            <span class="s1">plugins: pluginList,</span>
            <span class="s1">processor,</span>
            <span class="s1">reportUnusedDisableDirectives,</span>
            <span class="s1">root,</span>
            <span class="s1">rules,</span>
            <span class="s1">settings,</span>
            <span class="s1">overrides: overrideList = []</span>
        <span class="s1">},</span>
        <span class="s1">ctx</span>
    <span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">extendList = Array.isArray(extend) ? extend : [extend];</span>
        <span class="s2">const </span><span class="s1">ignorePattern = ignorePatterns &amp;&amp; </span><span class="s2">new </span><span class="s1">IgnorePattern(</span>
            <span class="s1">Array.isArray(ignorePatterns) ? ignorePatterns : [ignorePatterns],</span>
            <span class="s1">ctx.matchBasePath</span>
        <span class="s1">);</span>

        <span class="s3">// Flatten `extends`.</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">extendName of extendList.filter(Boolean)) {</span>
            <span class="s2">yield</span><span class="s1">* </span><span class="s2">this</span><span class="s1">._loadExtends(extendName, ctx);</span>
        <span class="s1">}</span>

        <span class="s3">// Load parser &amp; plugins.</span>
        <span class="s2">const </span><span class="s1">parser = parserName &amp;&amp; </span><span class="s2">this</span><span class="s1">._loadParser(parserName, ctx);</span>
        <span class="s2">const </span><span class="s1">plugins = pluginList &amp;&amp; </span><span class="s2">this</span><span class="s1">._loadPlugins(pluginList, ctx);</span>

        <span class="s3">// Yield pseudo config data for file extension processors.</span>
        <span class="s2">if </span><span class="s1">(plugins) {</span>
            <span class="s2">yield</span><span class="s1">* </span><span class="s2">this</span><span class="s1">._takeFileExtensionProcessors(plugins, ctx);</span>
        <span class="s1">}</span>

        <span class="s3">// Yield the config data except `extends` and `overrides`.</span>
        <span class="s2">yield </span><span class="s1">{</span>

            <span class="s3">// Debug information.</span>
            <span class="s1">type: ctx.type,</span>
            <span class="s1">name: ctx.name,</span>
            <span class="s1">filePath: ctx.filePath,</span>

            <span class="s3">// Config data.</span>
            <span class="s1">criteria: </span><span class="s2">null</span><span class="s1">,</span>
            <span class="s1">env,</span>
            <span class="s1">globals,</span>
            <span class="s1">ignorePattern,</span>
            <span class="s1">noInlineConfig,</span>
            <span class="s1">parser,</span>
            <span class="s1">parserOptions,</span>
            <span class="s1">plugins,</span>
            <span class="s1">processor,</span>
            <span class="s1">reportUnusedDisableDirectives,</span>
            <span class="s1">root,</span>
            <span class="s1">rules,</span>
            <span class="s1">settings</span>
        <span class="s1">};</span>

        <span class="s3">// Flatten `overries`.</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; overrideList.length; ++i) {</span>
            <span class="s2">yield</span><span class="s1">* </span><span class="s2">this</span><span class="s1">._normalizeObjectConfigData(</span>
                <span class="s1">overrideList[i],</span>
                <span class="s1">{ ...ctx, name: </span><span class="s0">`</span><span class="s1">${ctx.name}</span><span class="s0">#overrides[</span><span class="s1">${i}</span><span class="s0">]` </span><span class="s1">}</span>
            <span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Load configs of an element in `extends`.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} extendName The name of a base config.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{ConfigArrayFactoryLoadingContext} ctx The loading context.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{IterableIterator&lt;ConfigArrayElement&gt;} The normalized config.</span>
     <span class="s3">* </span><span class="s4">@throws </span><span class="s3">{Error} If the extended config file can't be loaded.</span>
     <span class="s3">* </span><span class="s4">@private</span>
     <span class="s3">*/</span>
    <span class="s1">_loadExtends(extendName, ctx) {</span>
        <span class="s1">debug$2(</span><span class="s0">&quot;Loading {extends:%j} relative to %s&quot;</span><span class="s1">, extendName, ctx.filePath);</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(extendName.startsWith(</span><span class="s0">&quot;eslint:&quot;</span><span class="s1">)) {</span>
                <span class="s2">return this</span><span class="s1">._loadExtendedBuiltInConfig(extendName, ctx);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(extendName.startsWith(</span><span class="s0">&quot;plugin:&quot;</span><span class="s1">)) {</span>
                <span class="s2">return this</span><span class="s1">._loadExtendedPluginConfig(extendName, ctx);</span>
            <span class="s1">}</span>
            <span class="s2">return this</span><span class="s1">._loadExtendedShareableConfig(extendName, ctx);</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
            <span class="s1">error.message += </span><span class="s0">`</span><span class="s7">\n</span><span class="s0">Referenced from: </span><span class="s1">${ctx.filePath || ctx.name}</span><span class="s0">`</span><span class="s1">;</span>
            <span class="s2">throw </span><span class="s1">error;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Load configs of an element in `extends`.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} extendName The name of a base config.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{ConfigArrayFactoryLoadingContext} ctx The loading context.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{IterableIterator&lt;ConfigArrayElement&gt;} The normalized config.</span>
     <span class="s3">* </span><span class="s4">@throws </span><span class="s3">{Error} If the extended config file can't be loaded.</span>
     <span class="s3">* </span><span class="s4">@private</span>
     <span class="s3">*/</span>
    <span class="s1">_loadExtendedBuiltInConfig(extendName, ctx) {</span>
        <span class="s2">const </span><span class="s1">{</span>
            <span class="s1">eslintAllPath,</span>
            <span class="s1">getEslintAllConfig,</span>
            <span class="s1">eslintRecommendedPath,</span>
            <span class="s1">getEslintRecommendedConfig</span>
        <span class="s1">} = internalSlotsMap$1.get(</span><span class="s2">this</span><span class="s1">);</span>

        <span class="s2">if </span><span class="s1">(extendName === </span><span class="s0">&quot;eslint:recommended&quot;</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">name = </span><span class="s0">`</span><span class="s1">${ctx.name} </span><span class="s0"> </span><span class="s1">${extendName}</span><span class="s0">`</span><span class="s1">;</span>

            <span class="s2">if </span><span class="s1">(getEslintRecommendedConfig) {</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">getEslintRecommendedConfig !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) {</span>
                    <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">`getEslintRecommendedConfig must be a function instead of '</span><span class="s1">${getEslintRecommendedConfig}</span><span class="s0">'`</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">return this</span><span class="s1">._normalizeConfigData(getEslintRecommendedConfig(), { ...ctx, name, filePath: </span><span class="s0">&quot;&quot; </span><span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">return this</span><span class="s1">._loadConfigData({</span>
                <span class="s1">...ctx,</span>
                <span class="s1">name,</span>
                <span class="s1">filePath: eslintRecommendedPath</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(extendName === </span><span class="s0">&quot;eslint:all&quot;</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">name = </span><span class="s0">`</span><span class="s1">${ctx.name} </span><span class="s0"> </span><span class="s1">${extendName}</span><span class="s0">`</span><span class="s1">;</span>

            <span class="s2">if </span><span class="s1">(getEslintAllConfig) {</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">getEslintAllConfig !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) {</span>
                    <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">`getEslintAllConfig must be a function instead of '</span><span class="s1">${getEslintAllConfig}</span><span class="s0">'`</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">return this</span><span class="s1">._normalizeConfigData(getEslintAllConfig(), { ...ctx, name, filePath: </span><span class="s0">&quot;&quot; </span><span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">return this</span><span class="s1">._loadConfigData({</span>
                <span class="s1">...ctx,</span>
                <span class="s1">name,</span>
                <span class="s1">filePath: eslintAllPath</span>
            <span class="s1">});</span>
        <span class="s1">}</span>

        <span class="s2">throw </span><span class="s1">configInvalidError(extendName, ctx.name, </span><span class="s0">&quot;extend-config-missing&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Load configs of an element in `extends`.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} extendName The name of a base config.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{ConfigArrayFactoryLoadingContext} ctx The loading context.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{IterableIterator&lt;ConfigArrayElement&gt;} The normalized config.</span>
     <span class="s3">* </span><span class="s4">@throws </span><span class="s3">{Error} If the extended config file can't be loaded.</span>
     <span class="s3">* </span><span class="s4">@private</span>
     <span class="s3">*/</span>
    <span class="s1">_loadExtendedPluginConfig(extendName, ctx) {</span>
        <span class="s2">const </span><span class="s1">slashIndex = extendName.lastIndexOf(</span><span class="s0">&quot;/&quot;</span><span class="s1">);</span>

        <span class="s2">if </span><span class="s1">(slashIndex === -</span><span class="s5">1</span><span class="s1">) {</span>
            <span class="s2">throw </span><span class="s1">configInvalidError(extendName, ctx.filePath, </span><span class="s0">&quot;plugin-invalid&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s2">const </span><span class="s1">pluginName = extendName.slice(</span><span class="s0">&quot;plugin:&quot;</span><span class="s1">.length, slashIndex);</span>
        <span class="s2">const </span><span class="s1">configName = extendName.slice(slashIndex + </span><span class="s5">1</span><span class="s1">);</span>

        <span class="s2">if </span><span class="s1">(isFilePath(pluginName)) {</span>
            <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">&quot;'extends' cannot use a file path for plugins.&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s2">const </span><span class="s1">plugin = </span><span class="s2">this</span><span class="s1">._loadPlugin(pluginName, ctx);</span>
        <span class="s2">const </span><span class="s1">configData =</span>
            <span class="s1">plugin.definition &amp;&amp;</span>
            <span class="s1">plugin.definition.configs[configName];</span>

        <span class="s2">if </span><span class="s1">(configData) {</span>
            <span class="s2">return this</span><span class="s1">._normalizeConfigData(configData, {</span>
                <span class="s1">...ctx,</span>
                <span class="s1">filePath: plugin.filePath || ctx.filePath,</span>
                <span class="s1">name: </span><span class="s0">`</span><span class="s1">${ctx.name} </span><span class="s0"> plugin:</span><span class="s1">${plugin.id}</span><span class="s0">/</span><span class="s1">${configName}</span><span class="s0">`</span>
            <span class="s1">});</span>
        <span class="s1">}</span>

        <span class="s2">throw </span><span class="s1">plugin.error || configInvalidError(extendName, ctx.filePath, </span><span class="s0">&quot;extend-config-missing&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Load configs of an element in `extends`.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} extendName The name of a base config.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{ConfigArrayFactoryLoadingContext} ctx The loading context.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{IterableIterator&lt;ConfigArrayElement&gt;} The normalized config.</span>
     <span class="s3">* </span><span class="s4">@throws </span><span class="s3">{Error} If the extended config file can't be loaded.</span>
     <span class="s3">* </span><span class="s4">@private</span>
     <span class="s3">*/</span>
    <span class="s1">_loadExtendedShareableConfig(extendName, ctx) {</span>
        <span class="s2">const </span><span class="s1">{ cwd, resolver } = internalSlotsMap$1.get(</span><span class="s2">this</span><span class="s1">);</span>
        <span class="s2">const </span><span class="s1">relativeTo = ctx.filePath || path__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].join(cwd, </span><span class="s0">&quot;__placeholder__.js&quot;</span><span class="s1">);</span>
        <span class="s2">let </span><span class="s1">request;</span>

        <span class="s2">if </span><span class="s1">(isFilePath(extendName)) {</span>
            <span class="s1">request = extendName;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(extendName.startsWith(</span><span class="s0">&quot;.&quot;</span><span class="s1">)) {</span>
            <span class="s1">request = </span><span class="s0">`./</span><span class="s1">${extendName}</span><span class="s0">`</span><span class="s1">; </span><span class="s3">// For backward compatibility. A ton of tests depended on this behavior.</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">request = normalizePackageName(</span>
                <span class="s1">extendName,</span>
                <span class="s0">&quot;eslint-config&quot;</span>
            <span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s2">let </span><span class="s1">filePath;</span>

        <span class="s2">try </span><span class="s1">{</span>
            <span class="s1">filePath = resolver.resolve(request, relativeTo);</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
            <span class="s3">/* istanbul ignore else */</span>
            <span class="s2">if </span><span class="s1">(error &amp;&amp; error.code === </span><span class="s0">&quot;MODULE_NOT_FOUND&quot;</span><span class="s1">) {</span>
                <span class="s2">throw </span><span class="s1">configInvalidError(extendName, ctx.filePath, </span><span class="s0">&quot;extend-config-missing&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">throw </span><span class="s1">error;</span>
        <span class="s1">}</span>

        <span class="s1">writeDebugLogForLoading(request, relativeTo, filePath);</span>
        <span class="s2">return this</span><span class="s1">._loadConfigData({</span>
            <span class="s1">...ctx,</span>
            <span class="s1">filePath,</span>
            <span class="s1">name: </span><span class="s0">`</span><span class="s1">${ctx.name} </span><span class="s0"> </span><span class="s1">${request}</span><span class="s0">`</span>
        <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Load given plugins.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string[]} names The plugin names to load.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{ConfigArrayFactoryLoadingContext} ctx The loading context.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{Record&lt;string,DependentPlugin&gt;} The loaded parser.</span>
     <span class="s3">* </span><span class="s4">@private</span>
     <span class="s3">*/</span>
    <span class="s1">_loadPlugins(names, ctx) {</span>
        <span class="s2">return </span><span class="s1">names.reduce((map, name) =&gt; {</span>
            <span class="s2">if </span><span class="s1">(isFilePath(name)) {</span>
                <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">&quot;Plugins array cannot includes file paths.&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">plugin = </span><span class="s2">this</span><span class="s1">._loadPlugin(name, ctx);</span>

            <span class="s1">map[plugin.id] = plugin;</span>

            <span class="s2">return </span><span class="s1">map;</span>
        <span class="s1">}, {});</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Load a given parser.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} nameOrPath The package name or the path to a parser file.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{ConfigArrayFactoryLoadingContext} ctx The loading context.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{DependentParser} The loaded parser.</span>
     <span class="s3">*/</span>
    <span class="s1">_loadParser(nameOrPath, ctx) {</span>
        <span class="s1">debug$2(</span><span class="s0">&quot;Loading parser %j from %s&quot;</span><span class="s1">, nameOrPath, ctx.filePath);</span>

        <span class="s2">const </span><span class="s1">{ cwd, resolver } = internalSlotsMap$1.get(</span><span class="s2">this</span><span class="s1">);</span>
        <span class="s2">const </span><span class="s1">relativeTo = ctx.filePath || path__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].join(cwd, </span><span class="s0">&quot;__placeholder__.js&quot;</span><span class="s1">);</span>

        <span class="s2">try </span><span class="s1">{</span>
            <span class="s2">const </span><span class="s1">filePath = resolver.resolve(nameOrPath, relativeTo);</span>

            <span class="s1">writeDebugLogForLoading(nameOrPath, relativeTo, filePath);</span>

            <span class="s2">return new </span><span class="s1">ConfigDependency({</span>
                <span class="s1">definition: require$1(filePath),</span>
                <span class="s1">filePath,</span>
                <span class="s1">id: nameOrPath,</span>
                <span class="s1">importerName: ctx.name,</span>
                <span class="s1">importerPath: ctx.filePath</span>
            <span class="s1">});</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>

            <span class="s3">// If the parser name is &quot;espree&quot;, load the espree of ESLint.</span>
            <span class="s2">if </span><span class="s1">(nameOrPath === </span><span class="s0">&quot;espree&quot;</span><span class="s1">) {</span>
                <span class="s1">debug$2(</span><span class="s0">&quot;Fallback espree.&quot;</span><span class="s1">);</span>
                <span class="s2">return new </span><span class="s1">ConfigDependency({</span>
                    <span class="s1">definition: require$1(</span><span class="s0">&quot;espree&quot;</span><span class="s1">),</span>
                    <span class="s1">filePath: require$1.resolve(</span><span class="s0">&quot;espree&quot;</span><span class="s1">),</span>
                    <span class="s1">id: nameOrPath,</span>
                    <span class="s1">importerName: ctx.name,</span>
                    <span class="s1">importerPath: ctx.filePath</span>
                <span class="s1">});</span>
            <span class="s1">}</span>

            <span class="s1">debug$2(</span><span class="s0">&quot;Failed to load parser '%s' declared in '%s'.&quot;</span><span class="s1">, nameOrPath, ctx.name);</span>
            <span class="s1">error.message = </span><span class="s0">`Failed to load parser '</span><span class="s1">${nameOrPath}</span><span class="s0">' declared in '</span><span class="s1">${ctx.name}</span><span class="s0">': </span><span class="s1">${error.message}</span><span class="s0">`</span><span class="s1">;</span>

            <span class="s2">return new </span><span class="s1">ConfigDependency({</span>
                <span class="s1">error,</span>
                <span class="s1">id: nameOrPath,</span>
                <span class="s1">importerName: ctx.name,</span>
                <span class="s1">importerPath: ctx.filePath</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Load a given plugin.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} name The plugin name to load.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{ConfigArrayFactoryLoadingContext} ctx The loading context.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{DependentPlugin} The loaded plugin.</span>
     <span class="s3">* </span><span class="s4">@private</span>
     <span class="s3">*/</span>
    <span class="s1">_loadPlugin(name, ctx) {</span>
        <span class="s1">debug$2(</span><span class="s0">&quot;Loading plugin %j from %s&quot;</span><span class="s1">, name, ctx.filePath);</span>

        <span class="s2">const </span><span class="s1">{ additionalPluginPool, resolver } = internalSlotsMap$1.get(</span><span class="s2">this</span><span class="s1">);</span>
        <span class="s2">const </span><span class="s1">request = normalizePackageName(name, </span><span class="s0">&quot;eslint-plugin&quot;</span><span class="s1">);</span>
        <span class="s2">const </span><span class="s1">id = getShorthandName(request, </span><span class="s0">&quot;eslint-plugin&quot;</span><span class="s1">);</span>
        <span class="s2">const </span><span class="s1">relativeTo = path__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].join(ctx.pluginBasePath, </span><span class="s0">&quot;__placeholder__.js&quot;</span><span class="s1">);</span>

        <span class="s2">if </span><span class="s1">(name.match(</span><span class="s6">/\s+/u</span><span class="s1">)) {</span>
            <span class="s2">const </span><span class="s1">error = Object.assign(</span>
                <span class="s2">new </span><span class="s1">Error(</span><span class="s0">`Whitespace found in plugin name '</span><span class="s1">${name}</span><span class="s0">'`</span><span class="s1">),</span>
                <span class="s1">{</span>
                    <span class="s1">messageTemplate: </span><span class="s0">&quot;whitespace-found&quot;</span><span class="s1">,</span>
                    <span class="s1">messageData: { pluginName: request }</span>
                <span class="s1">}</span>
            <span class="s1">);</span>

            <span class="s2">return new </span><span class="s1">ConfigDependency({</span>
                <span class="s1">error,</span>
                <span class="s1">id,</span>
                <span class="s1">importerName: ctx.name,</span>
                <span class="s1">importerPath: ctx.filePath</span>
            <span class="s1">});</span>
        <span class="s1">}</span>

        <span class="s3">// Check for additional pool.</span>
        <span class="s2">const </span><span class="s1">plugin =</span>
            <span class="s1">additionalPluginPool.get(request) ||</span>
            <span class="s1">additionalPluginPool.get(id);</span>

        <span class="s2">if </span><span class="s1">(plugin) {</span>
            <span class="s2">return new </span><span class="s1">ConfigDependency({</span>
                <span class="s1">definition: normalizePlugin(plugin),</span>
                <span class="s1">original: plugin,</span>
                <span class="s1">filePath: </span><span class="s0">&quot;&quot;</span><span class="s1">, </span><span class="s3">// It's unknown where the plugin came from.</span>
                <span class="s1">id,</span>
                <span class="s1">importerName: ctx.name,</span>
                <span class="s1">importerPath: ctx.filePath</span>
            <span class="s1">});</span>
        <span class="s1">}</span>

        <span class="s2">let </span><span class="s1">filePath;</span>
        <span class="s2">let </span><span class="s1">error;</span>

        <span class="s2">try </span><span class="s1">{</span>
            <span class="s1">filePath = resolver.resolve(request, relativeTo);</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(resolveError) {</span>
            <span class="s1">error = resolveError;</span>
            <span class="s3">/* istanbul ignore else */</span>
            <span class="s2">if </span><span class="s1">(error &amp;&amp; error.code === </span><span class="s0">&quot;MODULE_NOT_FOUND&quot;</span><span class="s1">) {</span>
                <span class="s1">error.messageTemplate = </span><span class="s0">&quot;plugin-missing&quot;</span><span class="s1">;</span>
                <span class="s1">error.messageData = {</span>
                    <span class="s1">pluginName: request,</span>
                    <span class="s1">resolvePluginsRelativeTo: ctx.pluginBasePath,</span>
                    <span class="s1">importerName: ctx.name</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(filePath) {</span>
            <span class="s2">try </span><span class="s1">{</span>
                <span class="s1">writeDebugLogForLoading(request, relativeTo, filePath);</span>

                <span class="s2">const </span><span class="s1">startTime = Date.now();</span>
                <span class="s2">const </span><span class="s1">pluginDefinition = require$1(filePath);</span>

                <span class="s1">debug$2(</span><span class="s0">`Plugin </span><span class="s1">${filePath} </span><span class="s0">loaded in: </span><span class="s1">${Date.now() - startTime}</span><span class="s0">ms`</span><span class="s1">);</span>

                <span class="s2">return new </span><span class="s1">ConfigDependency({</span>
                    <span class="s1">definition: normalizePlugin(pluginDefinition),</span>
                    <span class="s1">original: pluginDefinition,</span>
                    <span class="s1">filePath,</span>
                    <span class="s1">id,</span>
                    <span class="s1">importerName: ctx.name,</span>
                    <span class="s1">importerPath: ctx.filePath</span>
                <span class="s1">});</span>
            <span class="s1">} </span><span class="s2">catch </span><span class="s1">(loadError) {</span>
                <span class="s1">error = loadError;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s1">debug$2(</span><span class="s0">&quot;Failed to load plugin '%s' declared in '%s'.&quot;</span><span class="s1">, name, ctx.name);</span>
        <span class="s1">error.message = </span><span class="s0">`Failed to load plugin '</span><span class="s1">${name}</span><span class="s0">' declared in '</span><span class="s1">${ctx.name}</span><span class="s0">': </span><span class="s1">${error.message}</span><span class="s0">`</span><span class="s1">;</span>
        <span class="s2">return new </span><span class="s1">ConfigDependency({</span>
            <span class="s1">error,</span>
            <span class="s1">id,</span>
            <span class="s1">importerName: ctx.name,</span>
            <span class="s1">importerPath: ctx.filePath</span>
        <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Take file expression processors as config array elements.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Record&lt;string,DependentPlugin&gt;} plugins The plugin definitions.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{ConfigArrayFactoryLoadingContext} ctx The loading context.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{IterableIterator&lt;ConfigArrayElement&gt;} The config array elements of file expression processors.</span>
     <span class="s3">* </span><span class="s4">@private</span>
     <span class="s3">*/</span>
    <span class="s1">*_takeFileExtensionProcessors(plugins, ctx) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">pluginId of Object.keys(plugins)) {</span>
            <span class="s2">const </span><span class="s1">processors =</span>
                <span class="s1">plugins[pluginId] &amp;&amp;</span>
                <span class="s1">plugins[pluginId].definition &amp;&amp;</span>
                <span class="s1">plugins[pluginId].definition.processors;</span>

            <span class="s2">if </span><span class="s1">(!processors) {</span>
                <span class="s2">continue</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">processorId of Object.keys(processors)) {</span>
                <span class="s2">if </span><span class="s1">(processorId.startsWith(</span><span class="s0">&quot;.&quot;</span><span class="s1">)) {</span>
                    <span class="s2">yield</span><span class="s1">* </span><span class="s2">this</span><span class="s1">._normalizeObjectConfigData(</span>
                        <span class="s1">{</span>
                            <span class="s1">files: [</span><span class="s0">`*</span><span class="s1">${processorId}</span><span class="s0">`</span><span class="s1">],</span>
                            <span class="s1">processor: </span><span class="s0">`</span><span class="s1">${pluginId}</span><span class="s0">/</span><span class="s1">${processorId}</span><span class="s0">`</span>
                        <span class="s1">},</span>
                        <span class="s1">{</span>
                            <span class="s1">...ctx,</span>
                            <span class="s1">type: </span><span class="s0">&quot;implicit-processor&quot;</span><span class="s1">,</span>
                            <span class="s1">name: </span><span class="s0">`</span><span class="s1">${ctx.name}</span><span class="s0">#processors[&quot;</span><span class="s1">${pluginId}</span><span class="s0">/</span><span class="s1">${processorId}</span><span class="s0">&quot;]`</span>
                        <span class="s1">}</span>
                    <span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@fileoverview </span><span class="s3">`CascadingConfigArrayFactory` class.</span>
 <span class="s3">*</span>
 <span class="s3">* `CascadingConfigArrayFactory` class has a responsibility:</span>
 <span class="s3">*</span>
 <span class="s3">* 1. Handles cascading of config files.</span>
 <span class="s3">*</span>
 <span class="s3">* It provides two methods:</span>
 <span class="s3">*</span>
 <span class="s3">* - `getConfigArrayForFile(filePath)`</span>
 <span class="s3">*     Get the corresponded configuration of a given file. This method doesn't</span>
 <span class="s3">*     throw even if the given file didn't exist.</span>
 <span class="s3">* - `clearCache()`</span>
 <span class="s3">*     Clear the internal cache. You have to call this method when</span>
 <span class="s3">*     `additionalPluginPool` was updated if `baseConfig` or `cliConfig` depends</span>
 <span class="s3">*     on the additional plugins. (`CLIEngine#addPlugin()` method calls this.)</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s4">@author </span><span class="s3">Toru Nagashima &lt;https://github.com/mysticatea&gt;</span>
 <span class="s3">*/</span>

<span class="s2">const </span><span class="s1">debug$1 = debugOrig__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">](</span><span class="s0">&quot;eslintrc:cascading-config-array-factory&quot;</span><span class="s1">);</span>

<span class="s3">//------------------------------------------------------------------------------</span>
<span class="s3">// Helpers</span>
<span class="s3">//------------------------------------------------------------------------------</span>

<span class="s3">// Define types for VSCode IntelliSense.</span>
<span class="s3">/** </span><span class="s4">@typedef </span><span class="s3">{import(&quot;./shared/types&quot;).ConfigData} ConfigData */</span>
<span class="s3">/** </span><span class="s4">@typedef </span><span class="s3">{import(&quot;./shared/types&quot;).Parser} Parser */</span>
<span class="s3">/** </span><span class="s4">@typedef </span><span class="s3">{import(&quot;./shared/types&quot;).Plugin} Plugin */</span>
<span class="s3">/** </span><span class="s4">@typedef </span><span class="s3">{import(&quot;./shared/types&quot;).Rule} Rule */</span>
<span class="s3">/** </span><span class="s4">@typedef </span><span class="s3">{ReturnType&lt;ConfigArrayFactory[&quot;create&quot;]&gt;} ConfigArray */</span>

<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@typedef </span><span class="s3">{Object} CascadingConfigArrayFactoryOptions</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{Map&lt;string,Plugin&gt;} [additionalPluginPool] The map for additional plugins.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{ConfigData} [baseConfig] The config by `baseConfig` option.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{ConfigData} [cliConfig] The config by CLI options (`--env`, `--global`, `--ignore-pattern`, `--parser`, `--parser-options`, `--plugin`, and `--rule`). CLI options overwrite the setting in config files.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{string} [cwd] The base directory to start lookup.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{string} [ignorePath] The path to the alternative file of `.eslintignore`.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{string[]} [rulePaths] The value of `--rulesdir` option.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{string} [specificConfigPath] The value of `--config` option.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{boolean} [useEslintrc] if `false` then it doesn't load config files.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{Function} loadRules The function to use to load rules.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{Map&lt;string,Rule&gt;} builtInRules The rules that are built in to ESLint.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{Object} [resolver=ModuleResolver] The module resolver object.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{string} eslintAllPath The path to the definitions for eslint:all.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{Function} getEslintAllConfig Returns the config data for eslint:all.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{string} eslintRecommendedPath The path to the definitions for eslint:recommended.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{Function} getEslintRecommendedConfig Returns the config data for eslint:recommended.</span>
 <span class="s3">*/</span>

<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@typedef </span><span class="s3">{Object} CascadingConfigArrayFactoryInternalSlots</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{ConfigArray} baseConfigArray The config array of `baseConfig` option.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{ConfigData} baseConfigData The config data of `baseConfig` option. This is used to reset `baseConfigArray`.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{ConfigArray} cliConfigArray The config array of CLI options.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{ConfigData} cliConfigData The config data of CLI options. This is used to reset `cliConfigArray`.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{ConfigArrayFactory} configArrayFactory The factory for config arrays.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{Map&lt;string, ConfigArray&gt;} configCache The cache from directory paths to config arrays.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{string} cwd The base directory to start lookup.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{WeakMap&lt;ConfigArray, ConfigArray&gt;} finalizeCache The cache from config arrays to finalized config arrays.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{string} [ignorePath] The path to the alternative file of `.eslintignore`.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{string[]|null} rulePaths The value of `--rulesdir` option. This is used to reset `baseConfigArray`.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{string|null} specificConfigPath The value of `--config` option. This is used to reset `cliConfigArray`.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{boolean} useEslintrc if `false` then it doesn't load config files.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{Function} loadRules The function to use to load rules.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{Map&lt;string,Rule&gt;} builtInRules The rules that are built in to ESLint.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{Object} [resolver=ModuleResolver] The module resolver object.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{string} eslintAllPath The path to the definitions for eslint:all.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{Function} getEslintAllConfig Returns the config data for eslint:all.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{string} eslintRecommendedPath The path to the definitions for eslint:recommended.</span>
 <span class="s3">* </span><span class="s4">@property </span><span class="s3">{Function} getEslintRecommendedConfig Returns the config data for eslint:recommended.</span>
 <span class="s3">*/</span>

<span class="s3">/** </span><span class="s4">@type </span><span class="s3">{WeakMap&lt;CascadingConfigArrayFactory, CascadingConfigArrayFactoryInternalSlots&gt;} */</span>
<span class="s2">const </span><span class="s1">internalSlotsMap = </span><span class="s2">new </span><span class="s1">WeakMap();</span>

<span class="s3">/**</span>
 <span class="s3">* Create the config array from `baseConfig` and `rulePaths`.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{CascadingConfigArrayFactoryInternalSlots} slots The slots.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{ConfigArray} The config array of the base configs.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">createBaseConfigArray({</span>
    <span class="s1">configArrayFactory,</span>
    <span class="s1">baseConfigData,</span>
    <span class="s1">rulePaths,</span>
    <span class="s1">cwd,</span>
    <span class="s1">loadRules</span>
<span class="s1">}) {</span>
    <span class="s2">const </span><span class="s1">baseConfigArray = configArrayFactory.create(</span>
        <span class="s1">baseConfigData,</span>
        <span class="s1">{ name: </span><span class="s0">&quot;BaseConfig&quot; </span><span class="s1">}</span>
    <span class="s1">);</span>

    <span class="s3">/* 
     * Create the config array element for the default ignore patterns. 
     * This element has `ignorePattern` property that ignores the default 
     * patterns in the current working directory. 
     */</span>
    <span class="s1">baseConfigArray.unshift(configArrayFactory.create(</span>
        <span class="s1">{ ignorePatterns: IgnorePattern.DefaultPatterns },</span>
        <span class="s1">{ name: </span><span class="s0">&quot;DefaultIgnorePattern&quot; </span><span class="s1">}</span>
    <span class="s1">)[</span><span class="s5">0</span><span class="s1">]);</span>

    <span class="s3">/* 
     * Load rules `--rulesdir` option as a pseudo plugin. 
     * Use a pseudo plugin to define rules of `--rulesdir`, so we can validate 
     * the rule's options with only information in the config array. 
     */</span>
    <span class="s2">if </span><span class="s1">(rulePaths &amp;&amp; rulePaths.length &gt; </span><span class="s5">0</span><span class="s1">) {</span>
        <span class="s1">baseConfigArray.push({</span>
            <span class="s1">type: </span><span class="s0">&quot;config&quot;</span><span class="s1">,</span>
            <span class="s1">name: </span><span class="s0">&quot;--rulesdir&quot;</span><span class="s1">,</span>
            <span class="s1">filePath: </span><span class="s0">&quot;&quot;</span><span class="s1">,</span>
            <span class="s1">plugins: {</span>
                <span class="s0">&quot;&quot;</span><span class="s1">: </span><span class="s2">new </span><span class="s1">ConfigDependency({</span>
                    <span class="s1">definition: {</span>
                        <span class="s1">rules: rulePaths.reduce(</span>
                            <span class="s1">(map, rulesPath) =&gt; Object.assign(</span>
                                <span class="s1">map,</span>
                                <span class="s1">loadRules(rulesPath, cwd)</span>
                            <span class="s1">),</span>
                            <span class="s1">{}</span>
                        <span class="s1">)</span>
                    <span class="s1">},</span>
                    <span class="s1">filePath: </span><span class="s0">&quot;&quot;</span><span class="s1">,</span>
                    <span class="s1">id: </span><span class="s0">&quot;&quot;</span><span class="s1">,</span>
                    <span class="s1">importerName: </span><span class="s0">&quot;--rulesdir&quot;</span><span class="s1">,</span>
                    <span class="s1">importerPath: </span><span class="s0">&quot;&quot;</span>
                <span class="s1">})</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">baseConfigArray;</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Create the config array from CLI options.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{CascadingConfigArrayFactoryInternalSlots} slots The slots.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{ConfigArray} The config array of the base configs.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">createCLIConfigArray({</span>
    <span class="s1">cliConfigData,</span>
    <span class="s1">configArrayFactory,</span>
    <span class="s1">cwd,</span>
    <span class="s1">ignorePath,</span>
    <span class="s1">specificConfigPath</span>
<span class="s1">}) {</span>
    <span class="s2">const </span><span class="s1">cliConfigArray = configArrayFactory.create(</span>
        <span class="s1">cliConfigData,</span>
        <span class="s1">{ name: </span><span class="s0">&quot;CLIOptions&quot; </span><span class="s1">}</span>
    <span class="s1">);</span>

    <span class="s1">cliConfigArray.unshift(</span>
        <span class="s1">...(ignorePath</span>
            <span class="s1">? configArrayFactory.loadESLintIgnore(ignorePath)</span>
            <span class="s1">: configArrayFactory.loadDefaultESLintIgnore())</span>
    <span class="s1">);</span>

    <span class="s2">if </span><span class="s1">(specificConfigPath) {</span>
        <span class="s1">cliConfigArray.unshift(</span>
            <span class="s1">...configArrayFactory.loadFile(</span>
                <span class="s1">specificConfigPath,</span>
                <span class="s1">{ name: </span><span class="s0">&quot;--config&quot;</span><span class="s1">, basePath: cwd }</span>
            <span class="s1">)</span>
        <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">cliConfigArray;</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* The error type when there are files matched by a glob, but all of them have been ignored.</span>
 <span class="s3">*/</span>
<span class="s2">class </span><span class="s1">ConfigurationNotFoundError </span><span class="s2">extends </span><span class="s1">Error {</span>


    <span class="s3">/**</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} directoryPath The directory path.</span>
     <span class="s3">*/</span>
    <span class="s1">constructor(directoryPath) {</span>
        <span class="s2">super</span><span class="s1">(</span><span class="s0">`No ESLint configuration found in </span><span class="s1">${directoryPath}</span><span class="s0">.`</span><span class="s1">);</span>
        <span class="s2">this</span><span class="s1">.messageTemplate = </span><span class="s0">&quot;no-config-found&quot;</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.messageData = { directoryPath };</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* This class provides the functionality that enumerates every file which is</span>
 <span class="s3">* matched by given glob patterns and that configuration.</span>
 <span class="s3">*/</span>
<span class="s2">class </span><span class="s1">CascadingConfigArrayFactory {</span>

    <span class="s3">/**</span>
     <span class="s3">* Initialize this enumerator.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{CascadingConfigArrayFactoryOptions} options The options.</span>
     <span class="s3">*/</span>
    <span class="s1">constructor({</span>
        <span class="s1">additionalPluginPool = </span><span class="s2">new </span><span class="s1">Map(),</span>
        <span class="s1">baseConfig: baseConfigData = </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">cliConfig: cliConfigData = </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">cwd = process.cwd(),</span>
        <span class="s1">ignorePath,</span>
        <span class="s1">resolvePluginsRelativeTo,</span>
        <span class="s1">rulePaths = [],</span>
        <span class="s1">specificConfigPath = </span><span class="s2">null</span><span class="s1">,</span>
        <span class="s1">useEslintrc = </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">builtInRules = </span><span class="s2">new </span><span class="s1">Map(),</span>
        <span class="s1">loadRules,</span>
        <span class="s1">resolver,</span>
        <span class="s1">eslintRecommendedPath,</span>
        <span class="s1">getEslintRecommendedConfig,</span>
        <span class="s1">eslintAllPath,</span>
        <span class="s1">getEslintAllConfig</span>
    <span class="s1">} = {}) {</span>
        <span class="s2">const </span><span class="s1">configArrayFactory = </span><span class="s2">new </span><span class="s1">ConfigArrayFactory({</span>
            <span class="s1">additionalPluginPool,</span>
            <span class="s1">cwd,</span>
            <span class="s1">resolvePluginsRelativeTo,</span>
            <span class="s1">builtInRules,</span>
            <span class="s1">resolver,</span>
            <span class="s1">eslintRecommendedPath,</span>
            <span class="s1">getEslintRecommendedConfig,</span>
            <span class="s1">eslintAllPath,</span>
            <span class="s1">getEslintAllConfig</span>
        <span class="s1">});</span>

        <span class="s1">internalSlotsMap.set(</span><span class="s2">this</span><span class="s1">, {</span>
            <span class="s1">baseConfigArray: createBaseConfigArray({</span>
                <span class="s1">baseConfigData,</span>
                <span class="s1">configArrayFactory,</span>
                <span class="s1">cwd,</span>
                <span class="s1">rulePaths,</span>
                <span class="s1">loadRules</span>
            <span class="s1">}),</span>
            <span class="s1">baseConfigData,</span>
            <span class="s1">cliConfigArray: createCLIConfigArray({</span>
                <span class="s1">cliConfigData,</span>
                <span class="s1">configArrayFactory,</span>
                <span class="s1">cwd,</span>
                <span class="s1">ignorePath,</span>
                <span class="s1">specificConfigPath</span>
            <span class="s1">}),</span>
            <span class="s1">cliConfigData,</span>
            <span class="s1">configArrayFactory,</span>
            <span class="s1">configCache: </span><span class="s2">new </span><span class="s1">Map(),</span>
            <span class="s1">cwd,</span>
            <span class="s1">finalizeCache: </span><span class="s2">new </span><span class="s1">WeakMap(),</span>
            <span class="s1">ignorePath,</span>
            <span class="s1">rulePaths,</span>
            <span class="s1">specificConfigPath,</span>
            <span class="s1">useEslintrc,</span>
            <span class="s1">builtInRules,</span>
            <span class="s1">loadRules</span>
        <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* The path to the current working directory.</span>
     <span class="s3">* This is used by tests.</span>
     <span class="s3">* </span><span class="s4">@type </span><span class="s3">{string}</span>
     <span class="s3">*/</span>
    <span class="s1">get cwd() {</span>
        <span class="s2">const </span><span class="s1">{ cwd } = internalSlotsMap.get(</span><span class="s2">this</span><span class="s1">);</span>

        <span class="s2">return </span><span class="s1">cwd;</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Get the config array of a given file.</span>
     <span class="s3">* If `filePath` was not given, it returns the config which contains only</span>
     <span class="s3">* `baseConfigData` and `cliConfigData`.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} [filePath] The file path to a file.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} [options] The options.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{boolean} [options.ignoreNotFoundError] If `true` then it doesn't throw `ConfigurationNotFoundError`.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{ConfigArray} The config array of the file.</span>
     <span class="s3">*/</span>
    <span class="s1">getConfigArrayForFile(filePath, { ignoreNotFoundError = </span><span class="s2">false </span><span class="s1">} = {}) {</span>
        <span class="s2">const </span><span class="s1">{</span>
            <span class="s1">baseConfigArray,</span>
            <span class="s1">cliConfigArray,</span>
            <span class="s1">cwd</span>
        <span class="s1">} = internalSlotsMap.get(</span><span class="s2">this</span><span class="s1">);</span>

        <span class="s2">if </span><span class="s1">(!filePath) {</span>
            <span class="s2">return new </span><span class="s1">ConfigArray(...baseConfigArray, ...cliConfigArray);</span>
        <span class="s1">}</span>

        <span class="s2">const </span><span class="s1">directoryPath = path__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].dirname(path__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].resolve(cwd, filePath));</span>

        <span class="s1">debug$1(</span><span class="s0">`Load config files for </span><span class="s1">${directoryPath}</span><span class="s0">.`</span><span class="s1">);</span>

        <span class="s2">return this</span><span class="s1">._finalizeConfigArray(</span>
            <span class="s2">this</span><span class="s1">._loadConfigInAncestors(directoryPath),</span>
            <span class="s1">directoryPath,</span>
            <span class="s1">ignoreNotFoundError</span>
        <span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Set the config data to override all configs.</span>
     <span class="s3">* Require to call `clearCache()` method after this method is called.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{ConfigData} configData The config data to override all configs.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{void}</span>
     <span class="s3">*/</span>
    <span class="s1">setOverrideConfig(configData) {</span>
        <span class="s2">const </span><span class="s1">slots = internalSlotsMap.get(</span><span class="s2">this</span><span class="s1">);</span>

        <span class="s1">slots.cliConfigData = configData;</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Clear config cache.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{void}</span>
     <span class="s3">*/</span>
    <span class="s1">clearCache() {</span>
        <span class="s2">const </span><span class="s1">slots = internalSlotsMap.get(</span><span class="s2">this</span><span class="s1">);</span>

        <span class="s1">slots.baseConfigArray = createBaseConfigArray(slots);</span>
        <span class="s1">slots.cliConfigArray = createCLIConfigArray(slots);</span>
        <span class="s1">slots.configCache.clear();</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Load and normalize config files from the ancestor directories.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} directoryPath The path to a leaf directory.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{boolean} configsExistInSubdirs `true` if configurations exist in subdirectories.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{ConfigArray} The loaded config.</span>
     <span class="s3">* </span><span class="s4">@throws </span><span class="s3">{Error} If a config file is invalid.</span>
     <span class="s3">* </span><span class="s4">@private</span>
     <span class="s3">*/</span>
    <span class="s1">_loadConfigInAncestors(directoryPath, configsExistInSubdirs = </span><span class="s2">false</span><span class="s1">) {</span>
        <span class="s2">const </span><span class="s1">{</span>
            <span class="s1">baseConfigArray,</span>
            <span class="s1">configArrayFactory,</span>
            <span class="s1">configCache,</span>
            <span class="s1">cwd,</span>
            <span class="s1">useEslintrc</span>
        <span class="s1">} = internalSlotsMap.get(</span><span class="s2">this</span><span class="s1">);</span>

        <span class="s2">if </span><span class="s1">(!useEslintrc) {</span>
            <span class="s2">return </span><span class="s1">baseConfigArray;</span>
        <span class="s1">}</span>

        <span class="s2">let </span><span class="s1">configArray = configCache.get(directoryPath);</span>

        <span class="s3">// Hit cache.</span>
        <span class="s2">if </span><span class="s1">(configArray) {</span>
            <span class="s1">debug$1(</span><span class="s0">`Cache hit: </span><span class="s1">${directoryPath}</span><span class="s0">.`</span><span class="s1">);</span>
            <span class="s2">return </span><span class="s1">configArray;</span>
        <span class="s1">}</span>
        <span class="s1">debug$1(</span><span class="s0">`No cache found: </span><span class="s1">${directoryPath}</span><span class="s0">.`</span><span class="s1">);</span>

        <span class="s2">const </span><span class="s1">homePath = os__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].homedir();</span>

        <span class="s3">// Consider this is root.</span>
        <span class="s2">if </span><span class="s1">(directoryPath === homePath &amp;&amp; cwd !== homePath) {</span>
            <span class="s1">debug$1(</span><span class="s0">&quot;Stop traversing because of considered root.&quot;</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(configsExistInSubdirs) {</span>
                <span class="s2">const </span><span class="s1">filePath = ConfigArrayFactory.getPathToConfigFileInDirectory(directoryPath);</span>

                <span class="s2">if </span><span class="s1">(filePath) {</span>
                    <span class="s1">emitDeprecationWarning(</span>
                        <span class="s1">filePath,</span>
                        <span class="s0">&quot;ESLINT_PERSONAL_CONFIG_SUPPRESS&quot;</span>
                    <span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">return this</span><span class="s1">._cacheConfig(directoryPath, baseConfigArray);</span>
        <span class="s1">}</span>

        <span class="s3">// Load the config on this directory.</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s1">configArray = configArrayFactory.loadInDirectory(directoryPath);</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
            <span class="s3">/* istanbul ignore next */</span>
            <span class="s2">if </span><span class="s1">(error.code === </span><span class="s0">&quot;EACCES&quot;</span><span class="s1">) {</span>
                <span class="s1">debug$1(</span><span class="s0">&quot;Stop traversing because of 'EACCES' error.&quot;</span><span class="s1">);</span>
                <span class="s2">return this</span><span class="s1">._cacheConfig(directoryPath, baseConfigArray);</span>
            <span class="s1">}</span>
            <span class="s2">throw </span><span class="s1">error;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(configArray.length &gt; </span><span class="s5">0 </span><span class="s1">&amp;&amp; configArray.isRoot()) {</span>
            <span class="s1">debug$1(</span><span class="s0">&quot;Stop traversing because of 'root:true'.&quot;</span><span class="s1">);</span>
            <span class="s1">configArray.unshift(...baseConfigArray);</span>
            <span class="s2">return this</span><span class="s1">._cacheConfig(directoryPath, configArray);</span>
        <span class="s1">}</span>

        <span class="s3">// Load from the ancestors and merge it.</span>
        <span class="s2">const </span><span class="s1">parentPath = path__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].dirname(directoryPath);</span>
        <span class="s2">const </span><span class="s1">parentConfigArray = parentPath &amp;&amp; parentPath !== directoryPath</span>
            <span class="s1">? </span><span class="s2">this</span><span class="s1">._loadConfigInAncestors(</span>
                <span class="s1">parentPath,</span>
                <span class="s1">configsExistInSubdirs || configArray.length &gt; </span><span class="s5">0</span>
            <span class="s1">)</span>
            <span class="s1">: baseConfigArray;</span>

        <span class="s2">if </span><span class="s1">(configArray.length &gt; </span><span class="s5">0</span><span class="s1">) {</span>
            <span class="s1">configArray.unshift(...parentConfigArray);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">configArray = parentConfigArray;</span>
        <span class="s1">}</span>

        <span class="s3">// Cache and return.</span>
        <span class="s2">return this</span><span class="s1">._cacheConfig(directoryPath, configArray);</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Freeze and cache a given config.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} directoryPath The path to a directory as a cache key.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{ConfigArray} configArray The config array as a cache value.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{ConfigArray} The `configArray` (frozen).</span>
     <span class="s3">*/</span>
    <span class="s1">_cacheConfig(directoryPath, configArray) {</span>
        <span class="s2">const </span><span class="s1">{ configCache } = internalSlotsMap.get(</span><span class="s2">this</span><span class="s1">);</span>

        <span class="s1">Object.freeze(configArray);</span>
        <span class="s1">configCache.set(directoryPath, configArray);</span>

        <span class="s2">return </span><span class="s1">configArray;</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Finalize a given config array.</span>
     <span class="s3">* Concatenate `--config` and other CLI options.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{ConfigArray} configArray The parent config array.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} directoryPath The path to the leaf directory to find config files.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{boolean} ignoreNotFoundError If `true` then it doesn't throw `ConfigurationNotFoundError`.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{ConfigArray} The loaded config.</span>
     <span class="s3">* </span><span class="s4">@throws </span><span class="s3">{Error} If a config file is invalid.</span>
     <span class="s3">* </span><span class="s4">@private</span>
     <span class="s3">*/</span>
    <span class="s1">_finalizeConfigArray(configArray, directoryPath, ignoreNotFoundError) {</span>
        <span class="s2">const </span><span class="s1">{</span>
            <span class="s1">cliConfigArray,</span>
            <span class="s1">configArrayFactory,</span>
            <span class="s1">finalizeCache,</span>
            <span class="s1">useEslintrc,</span>
            <span class="s1">builtInRules</span>
        <span class="s1">} = internalSlotsMap.get(</span><span class="s2">this</span><span class="s1">);</span>

        <span class="s2">let </span><span class="s1">finalConfigArray = finalizeCache.get(configArray);</span>

        <span class="s2">if </span><span class="s1">(!finalConfigArray) {</span>
            <span class="s1">finalConfigArray = configArray;</span>

            <span class="s3">// Load the personal config if there are no regular config files.</span>
            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">useEslintrc &amp;&amp;</span>
                <span class="s1">configArray.every(c =&gt; !c.filePath) &amp;&amp;</span>
                <span class="s1">cliConfigArray.every(c =&gt; !c.filePath) </span><span class="s3">// `--config` option can be a file.</span>
            <span class="s1">) {</span>
                <span class="s2">const </span><span class="s1">homePath = os__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].homedir();</span>

                <span class="s1">debug$1(</span><span class="s0">&quot;Loading the config file of the home directory:&quot;</span><span class="s1">, homePath);</span>

                <span class="s2">const </span><span class="s1">personalConfigArray = configArrayFactory.loadInDirectory(</span>
                    <span class="s1">homePath,</span>
                    <span class="s1">{ name: </span><span class="s0">&quot;PersonalConfig&quot; </span><span class="s1">}</span>
                <span class="s1">);</span>

                <span class="s2">if </span><span class="s1">(</span>
                    <span class="s1">personalConfigArray.length &gt; </span><span class="s5">0 </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">!directoryPath.startsWith(homePath)</span>
                <span class="s1">) {</span>
                    <span class="s2">const </span><span class="s1">lastElement =</span>
                        <span class="s1">personalConfigArray.at(-</span><span class="s5">1</span><span class="s1">);</span>

                    <span class="s1">emitDeprecationWarning(</span>
                        <span class="s1">lastElement.filePath,</span>
                        <span class="s0">&quot;ESLINT_PERSONAL_CONFIG_LOAD&quot;</span>
                    <span class="s1">);</span>
                <span class="s1">}</span>

                <span class="s1">finalConfigArray = finalConfigArray.concat(personalConfigArray);</span>
            <span class="s1">}</span>

            <span class="s3">// Apply CLI options.</span>
            <span class="s2">if </span><span class="s1">(cliConfigArray.length &gt; </span><span class="s5">0</span><span class="s1">) {</span>
                <span class="s1">finalConfigArray = finalConfigArray.concat(cliConfigArray);</span>
            <span class="s1">}</span>

            <span class="s3">// Validate rule settings and environments.</span>
            <span class="s2">const </span><span class="s1">validator = </span><span class="s2">new </span><span class="s1">ConfigValidator({</span>
                <span class="s1">builtInRules</span>
            <span class="s1">});</span>

            <span class="s1">validator.validateConfigArray(finalConfigArray);</span>

            <span class="s3">// Cache it.</span>
            <span class="s1">Object.freeze(finalConfigArray);</span>
            <span class="s1">finalizeCache.set(configArray, finalConfigArray);</span>

            <span class="s1">debug$1(</span>
                <span class="s0">&quot;Configuration was determined: %o on %s&quot;</span><span class="s1">,</span>
                <span class="s1">finalConfigArray,</span>
                <span class="s1">directoryPath</span>
            <span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s3">// At least one element (the default ignore patterns) exists.</span>
        <span class="s2">if </span><span class="s1">(!ignoreNotFoundError &amp;&amp; useEslintrc &amp;&amp; finalConfigArray.length &lt;= </span><span class="s5">1</span><span class="s1">) {</span>
            <span class="s2">throw new </span><span class="s1">ConfigurationNotFoundError(directoryPath);</span>
        <span class="s1">}</span>

        <span class="s2">return </span><span class="s1">finalConfigArray;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@fileoverview </span><span class="s3">Compatibility class for flat config.</span>
 <span class="s3">* </span><span class="s4">@author </span><span class="s3">Nicholas C. Zakas</span>
 <span class="s3">*/</span>

<span class="s3">//-----------------------------------------------------------------------------</span>
<span class="s3">// Helpers</span>
<span class="s3">//-----------------------------------------------------------------------------</span>

<span class="s3">/** </span><span class="s4">@typedef </span><span class="s3">{import(&quot;../../shared/types&quot;).Environment} Environment */</span>
<span class="s3">/** </span><span class="s4">@typedef </span><span class="s3">{import(&quot;../../shared/types&quot;).Processor} Processor */</span>

<span class="s2">const </span><span class="s1">debug = debugOrig__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">](</span><span class="s0">&quot;eslintrc:flat-compat&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">cafactory = Symbol(</span><span class="s0">&quot;cafactory&quot;</span><span class="s1">);</span>

<span class="s3">/**</span>
 <span class="s3">* Translates an ESLintRC-style config object into a flag-config-style config</span>
 <span class="s3">* object.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} eslintrcConfig An ESLintRC-style config object.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} options Options to help translate the config.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} options.resolveConfigRelativeTo To the directory to resolve</span>
 <span class="s3">*      configs from.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{string} options.resolvePluginsRelativeTo The directory to resolve</span>
 <span class="s3">*      plugins from.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{ReadOnlyMap&lt;string,Environment&gt;} options.pluginEnvironments A map of plugin environment</span>
 <span class="s3">*      names to objects.</span>
 <span class="s3">* </span><span class="s4">@param </span><span class="s3">{ReadOnlyMap&lt;string,Processor&gt;} options.pluginProcessors A map of plugin processor</span>
 <span class="s3">*      names to objects.</span>
 <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{Object} A flag-config-style config object.</span>
 <span class="s3">* </span><span class="s4">@throws </span><span class="s3">{Error} If a plugin or environment cannot be resolved.</span>
 <span class="s3">*/</span>
<span class="s2">function </span><span class="s1">translateESLintRC(eslintrcConfig, {</span>
    <span class="s1">resolveConfigRelativeTo,</span>
    <span class="s1">resolvePluginsRelativeTo,</span>
    <span class="s1">pluginEnvironments,</span>
    <span class="s1">pluginProcessors</span>
<span class="s1">}) {</span>

    <span class="s2">const </span><span class="s1">flatConfig = {};</span>
    <span class="s2">const </span><span class="s1">configs = [];</span>
    <span class="s2">const </span><span class="s1">languageOptions = {};</span>
    <span class="s2">const </span><span class="s1">linterOptions = {};</span>
    <span class="s2">const </span><span class="s1">keysToCopy = [</span><span class="s0">&quot;settings&quot;</span><span class="s1">, </span><span class="s0">&quot;rules&quot;</span><span class="s1">, </span><span class="s0">&quot;processor&quot;</span><span class="s1">];</span>
    <span class="s2">const </span><span class="s1">languageOptionsKeysToCopy = [</span><span class="s0">&quot;globals&quot;</span><span class="s1">, </span><span class="s0">&quot;parser&quot;</span><span class="s1">, </span><span class="s0">&quot;parserOptions&quot;</span><span class="s1">];</span>
    <span class="s2">const </span><span class="s1">linterOptionsKeysToCopy = [</span><span class="s0">&quot;noInlineConfig&quot;</span><span class="s1">, </span><span class="s0">&quot;reportUnusedDisableDirectives&quot;</span><span class="s1">];</span>

    <span class="s3">// copy over simple translations</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key of keysToCopy) {</span>
        <span class="s2">if </span><span class="s1">(key </span><span class="s2">in </span><span class="s1">eslintrcConfig &amp;&amp; </span><span class="s2">typeof </span><span class="s1">eslintrcConfig[key] !== </span><span class="s0">&quot;undefined&quot;</span><span class="s1">) {</span>
            <span class="s1">flatConfig[key] = eslintrcConfig[key];</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">// copy over languageOptions</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key of languageOptionsKeysToCopy) {</span>
        <span class="s2">if </span><span class="s1">(key </span><span class="s2">in </span><span class="s1">eslintrcConfig &amp;&amp; </span><span class="s2">typeof </span><span class="s1">eslintrcConfig[key] !== </span><span class="s0">&quot;undefined&quot;</span><span class="s1">) {</span>

            <span class="s3">// create the languageOptions key in the flat config</span>
            <span class="s1">flatConfig.languageOptions = languageOptions;</span>

            <span class="s2">if </span><span class="s1">(key === </span><span class="s0">&quot;parser&quot;</span><span class="s1">) {</span>
                <span class="s1">debug(</span><span class="s0">`Resolving parser '</span><span class="s1">${languageOptions[key]}</span><span class="s0">' relative to </span><span class="s1">${resolveConfigRelativeTo}</span><span class="s0">`</span><span class="s1">);</span>

                <span class="s2">if </span><span class="s1">(eslintrcConfig[key].error) {</span>
                    <span class="s2">throw </span><span class="s1">eslintrcConfig[key].error;</span>
                <span class="s1">}</span>

                <span class="s1">languageOptions[key] = eslintrcConfig[key].definition;</span>
                <span class="s2">continue</span><span class="s1">;</span>
            <span class="s1">}</span>

            <span class="s3">// clone any object values that are in the eslintrc config</span>
            <span class="s2">if </span><span class="s1">(eslintrcConfig[key] &amp;&amp; </span><span class="s2">typeof </span><span class="s1">eslintrcConfig[key] === </span><span class="s0">&quot;object&quot;</span><span class="s1">) {</span>
                <span class="s1">languageOptions[key] = {</span>
                    <span class="s1">...eslintrcConfig[key]</span>
                <span class="s1">};</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">languageOptions[key] = eslintrcConfig[key];</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">// copy over linterOptions</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key of linterOptionsKeysToCopy) {</span>
        <span class="s2">if </span><span class="s1">(key </span><span class="s2">in </span><span class="s1">eslintrcConfig &amp;&amp; </span><span class="s2">typeof </span><span class="s1">eslintrcConfig[key] !== </span><span class="s0">&quot;undefined&quot;</span><span class="s1">) {</span>
            <span class="s1">flatConfig.linterOptions = linterOptions;</span>
            <span class="s1">linterOptions[key] = eslintrcConfig[key];</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">// move ecmaVersion a level up</span>
    <span class="s2">if </span><span class="s1">(languageOptions.parserOptions) {</span>

        <span class="s2">if </span><span class="s1">(</span><span class="s0">&quot;ecmaVersion&quot; </span><span class="s2">in </span><span class="s1">languageOptions.parserOptions) {</span>
            <span class="s1">languageOptions.ecmaVersion = languageOptions.parserOptions.ecmaVersion;</span>
            <span class="s2">delete </span><span class="s1">languageOptions.parserOptions.ecmaVersion;</span>
        <span class="s1">}</span>

        <span class="s2">if </span><span class="s1">(</span><span class="s0">&quot;sourceType&quot; </span><span class="s2">in </span><span class="s1">languageOptions.parserOptions) {</span>
            <span class="s1">languageOptions.sourceType = languageOptions.parserOptions.sourceType;</span>
            <span class="s2">delete </span><span class="s1">languageOptions.parserOptions.sourceType;</span>
        <span class="s1">}</span>

        <span class="s3">// check to see if we even need parserOptions anymore and remove it if not</span>
        <span class="s2">if </span><span class="s1">(Object.keys(languageOptions.parserOptions).length === </span><span class="s5">0</span><span class="s1">) {</span>
            <span class="s2">delete </span><span class="s1">languageOptions.parserOptions;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">// overrides</span>
    <span class="s2">if </span><span class="s1">(eslintrcConfig.criteria) {</span>
        <span class="s1">flatConfig.files = [absoluteFilePath =&gt; eslintrcConfig.criteria.test(absoluteFilePath)];</span>
    <span class="s1">}</span>

    <span class="s3">// translate plugins</span>
    <span class="s2">if </span><span class="s1">(eslintrcConfig.plugins &amp;&amp; </span><span class="s2">typeof </span><span class="s1">eslintrcConfig.plugins === </span><span class="s0">&quot;object&quot;</span><span class="s1">) {</span>
        <span class="s1">debug(</span><span class="s0">`Translating plugins: </span><span class="s1">${eslintrcConfig.plugins}</span><span class="s0">`</span><span class="s1">);</span>

        <span class="s1">flatConfig.plugins = {};</span>

        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">pluginName of Object.keys(eslintrcConfig.plugins)) {</span>

            <span class="s1">debug(</span><span class="s0">`Translating plugin: </span><span class="s1">${pluginName}</span><span class="s0">`</span><span class="s1">);</span>
            <span class="s1">debug(</span><span class="s0">`Resolving plugin '</span><span class="s1">${pluginName} </span><span class="s0">relative to </span><span class="s1">${resolvePluginsRelativeTo}</span><span class="s0">`</span><span class="s1">);</span>

            <span class="s2">const </span><span class="s1">{ original: plugin, error } = eslintrcConfig.plugins[pluginName];</span>

            <span class="s2">if </span><span class="s1">(error) {</span>
                <span class="s2">throw </span><span class="s1">error;</span>
            <span class="s1">}</span>

            <span class="s1">flatConfig.plugins[pluginName] = plugin;</span>

            <span class="s3">// create a config for any processors</span>
            <span class="s2">if </span><span class="s1">(plugin.processors) {</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">processorName of Object.keys(plugin.processors)) {</span>
                    <span class="s2">if </span><span class="s1">(processorName.startsWith(</span><span class="s0">&quot;.&quot;</span><span class="s1">)) {</span>
                        <span class="s1">debug(</span><span class="s0">`Assigning processor: </span><span class="s1">${pluginName}</span><span class="s0">/</span><span class="s1">${processorName}</span><span class="s0">`</span><span class="s1">);</span>

                        <span class="s1">configs.unshift({</span>
                            <span class="s1">files: [</span><span class="s0">`**/*</span><span class="s1">${processorName}</span><span class="s0">`</span><span class="s1">],</span>
                            <span class="s1">processor: pluginProcessors.get(</span><span class="s0">`</span><span class="s1">${pluginName}</span><span class="s0">/</span><span class="s1">${processorName}</span><span class="s0">`</span><span class="s1">)</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>

                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">// translate env - must come after plugins</span>
    <span class="s2">if </span><span class="s1">(eslintrcConfig.env &amp;&amp; </span><span class="s2">typeof </span><span class="s1">eslintrcConfig.env === </span><span class="s0">&quot;object&quot;</span><span class="s1">) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">envName of Object.keys(eslintrcConfig.env)) {</span>

            <span class="s3">// only add environments that are true</span>
            <span class="s2">if </span><span class="s1">(eslintrcConfig.env[envName]) {</span>
                <span class="s1">debug(</span><span class="s0">`Translating environment: </span><span class="s1">${envName}</span><span class="s0">`</span><span class="s1">);</span>

                <span class="s2">if </span><span class="s1">(environments.has(envName)) {</span>

                    <span class="s3">// built-in environments should be defined first</span>
                    <span class="s1">configs.unshift(...translateESLintRC({</span>
                        <span class="s1">criteria: eslintrcConfig.criteria,</span>
                        <span class="s1">...environments.get(envName)</span>
                    <span class="s1">}, {</span>
                        <span class="s1">resolveConfigRelativeTo,</span>
                        <span class="s1">resolvePluginsRelativeTo</span>
                    <span class="s1">}));</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(pluginEnvironments.has(envName)) {</span>

                    <span class="s3">// if the environment comes from a plugin, it should come after the plugin config</span>
                    <span class="s1">configs.push(...translateESLintRC({</span>
                        <span class="s1">criteria: eslintrcConfig.criteria,</span>
                        <span class="s1">...pluginEnvironments.get(envName)</span>
                    <span class="s1">}, {</span>
                        <span class="s1">resolveConfigRelativeTo,</span>
                        <span class="s1">resolvePluginsRelativeTo</span>
                    <span class="s1">}));</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s3">// only add if there are actually keys in the config</span>
    <span class="s2">if </span><span class="s1">(Object.keys(flatConfig).length &gt; </span><span class="s5">0</span><span class="s1">) {</span>
        <span class="s1">configs.push(flatConfig);</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">configs;</span>
<span class="s1">}</span>


<span class="s3">//-----------------------------------------------------------------------------</span>
<span class="s3">// Exports</span>
<span class="s3">//-----------------------------------------------------------------------------</span>

<span class="s3">/**</span>
 <span class="s3">* A compatibility class for working with configs.</span>
 <span class="s3">*/</span>
<span class="s2">class </span><span class="s1">FlatCompat {</span>

    <span class="s1">constructor({</span>
        <span class="s1">baseDirectory = process.cwd(),</span>
        <span class="s1">resolvePluginsRelativeTo = baseDirectory,</span>
        <span class="s1">recommendedConfig,</span>
        <span class="s1">allConfig</span>
    <span class="s1">} = {}) {</span>
        <span class="s2">this</span><span class="s1">.baseDirectory = baseDirectory;</span>
        <span class="s2">this</span><span class="s1">.resolvePluginsRelativeTo = resolvePluginsRelativeTo;</span>
        <span class="s2">this</span><span class="s1">[cafactory] = </span><span class="s2">new </span><span class="s1">ConfigArrayFactory({</span>
            <span class="s1">cwd: baseDirectory,</span>
            <span class="s1">resolvePluginsRelativeTo,</span>
            <span class="s1">getEslintAllConfig() {</span>

                <span class="s2">if </span><span class="s1">(!allConfig) {</span>
                    <span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">&quot;Missing parameter 'allConfig' in FlatCompat constructor.&quot;</span><span class="s1">);</span>
                <span class="s1">}</span>

                <span class="s2">return </span><span class="s1">allConfig;</span>
            <span class="s1">},</span>
            <span class="s1">getEslintRecommendedConfig() {</span>

                <span class="s2">if </span><span class="s1">(!recommendedConfig) {</span>
                    <span class="s2">throw new </span><span class="s1">TypeError(</span><span class="s0">&quot;Missing parameter 'recommendedConfig' in FlatCompat constructor.&quot;</span><span class="s1">);</span>
                <span class="s1">}</span>

                <span class="s2">return </span><span class="s1">recommendedConfig;</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Translates an ESLintRC-style config into a flag-config-style config.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} eslintrcConfig The ESLintRC-style config object.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{Object} A flag-config-style config object.</span>
     <span class="s3">*/</span>
    <span class="s1">config(eslintrcConfig) {</span>
        <span class="s2">const </span><span class="s1">eslintrcArray = </span><span class="s2">this</span><span class="s1">[cafactory].create(eslintrcConfig, {</span>
            <span class="s1">basePath: </span><span class="s2">this</span><span class="s1">.baseDirectory</span>
        <span class="s1">});</span>

        <span class="s2">const </span><span class="s1">flatArray = [];</span>
        <span class="s2">let </span><span class="s1">hasIgnorePatterns = </span><span class="s2">false</span><span class="s1">;</span>

        <span class="s1">eslintrcArray.forEach(configData =&gt; {</span>
            <span class="s2">if </span><span class="s1">(configData.type === </span><span class="s0">&quot;config&quot;</span><span class="s1">) {</span>
                <span class="s1">hasIgnorePatterns = hasIgnorePatterns || configData.ignorePattern;</span>
                <span class="s1">flatArray.push(...translateESLintRC(configData, {</span>
                    <span class="s1">resolveConfigRelativeTo: path__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].join(</span><span class="s2">this</span><span class="s1">.baseDirectory, </span><span class="s0">&quot;__placeholder.js&quot;</span><span class="s1">),</span>
                    <span class="s1">resolvePluginsRelativeTo: path__default[</span><span class="s0">&quot;default&quot;</span><span class="s1">].join(</span><span class="s2">this</span><span class="s1">.resolvePluginsRelativeTo, </span><span class="s0">&quot;__placeholder.js&quot;</span><span class="s1">),</span>
                    <span class="s1">pluginEnvironments: eslintrcArray.pluginEnvironments,</span>
                    <span class="s1">pluginProcessors: eslintrcArray.pluginProcessors</span>
                <span class="s1">}));</span>
            <span class="s1">}</span>
        <span class="s1">});</span>

        <span class="s3">// combine ignorePatterns to emulate ESLintRC behavior better</span>
        <span class="s2">if </span><span class="s1">(hasIgnorePatterns) {</span>
            <span class="s1">flatArray.unshift({</span>
                <span class="s1">ignores: [filePath =&gt; {</span>

                    <span class="s3">// Compute the final config for this file.</span>
                    <span class="s3">// This filters config array elements by `files`/`excludedFiles` then merges the elements.</span>
                    <span class="s2">const </span><span class="s1">finalConfig = eslintrcArray.extractConfig(filePath);</span>

                    <span class="s3">// Test the `ignorePattern` properties of the final config.</span>
                    <span class="s2">return </span><span class="s1">Boolean(finalConfig.ignores) &amp;&amp; finalConfig.ignores(filePath);</span>
                <span class="s1">}]</span>
            <span class="s1">});</span>
        <span class="s1">}</span>

        <span class="s2">return </span><span class="s1">flatArray;</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Translates the `env` section of an ESLintRC-style config.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{Object} envConfig The `env` section of an ESLintRC config.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{Object[]} An array of flag-config objects representing the environments.</span>
     <span class="s3">*/</span>
    <span class="s1">env(envConfig) {</span>
        <span class="s2">return this</span><span class="s1">.config({</span>
            <span class="s1">env: envConfig</span>
        <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Translates the `extends` section of an ESLintRC-style config.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{...string} configsToExtend The names of the configs to load.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{Object[]} An array of flag-config objects representing the config.</span>
     <span class="s3">*/</span>
    <span class="s2">extends</span><span class="s1">(...configsToExtend) {</span>
        <span class="s2">return this</span><span class="s1">.config({</span>
            <span class="s2">extends</span><span class="s1">: configsToExtend</span>
        <span class="s1">});</span>
    <span class="s1">}</span>

    <span class="s3">/**</span>
     <span class="s3">* Translates the `plugins` section of an ESLintRC-style config.</span>
     <span class="s3">* </span><span class="s4">@param </span><span class="s3">{...string} plugins The names of the plugins to load.</span>
     <span class="s3">* </span><span class="s4">@returns </span><span class="s3">{Object[]} An array of flag-config objects representing the plugins.</span>
     <span class="s3">*/</span>
    <span class="s1">plugins(...plugins) {</span>
        <span class="s2">return this</span><span class="s1">.config({</span>
            <span class="s1">plugins</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* </span><span class="s4">@fileoverview </span><span class="s3">Package exports for @eslint/eslintrc</span>
 <span class="s3">* </span><span class="s4">@author </span><span class="s3">Nicholas C. Zakas</span>
 <span class="s3">*/</span>

<span class="s3">//-----------------------------------------------------------------------------</span>
<span class="s3">// Exports</span>
<span class="s3">//-----------------------------------------------------------------------------</span>

<span class="s2">const </span><span class="s1">Legacy = {</span>
    <span class="s1">ConfigArray,</span>
    <span class="s1">createConfigArrayFactoryContext: createContext,</span>
    <span class="s1">CascadingConfigArrayFactory,</span>
    <span class="s1">ConfigArrayFactory,</span>
    <span class="s1">ConfigDependency,</span>
    <span class="s1">ExtractedConfig,</span>
    <span class="s1">IgnorePattern,</span>
    <span class="s1">OverrideTester,</span>
    <span class="s1">getUsedExtractedConfigs,</span>
    <span class="s1">environments,</span>
    <span class="s1">loadConfigFile,</span>

    <span class="s3">// shared</span>
    <span class="s1">ConfigOps,</span>
    <span class="s1">ConfigValidator,</span>
    <span class="s1">ModuleResolver,</span>
    <span class="s1">naming</span>
<span class="s1">};</span>

<span class="s1">exports.FlatCompat = FlatCompat;</span>
<span class="s1">exports.Legacy = Legacy;</span>
<span class="s3">//# sourceMappingURL=eslintrc.cjs.map</span>
</pre>
</body>
</html>