<html>
<head>
<title>useProgramFromProjectService.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #0037a6;}
.s5 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
useProgramFromProjectService.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">__createBinding = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__createBinding) || (Object.create ? (</span><span class="s2">function</span><span class="s1">(o, m, k, k2) {</span>
    <span class="s2">if </span><span class="s1">(k2 === undefined) k2 = k;</span>
    <span class="s2">var </span><span class="s1">desc = Object.getOwnPropertyDescriptor(m, k);</span>
    <span class="s2">if </span><span class="s1">(!desc || (</span><span class="s0">&quot;get&quot; </span><span class="s2">in </span><span class="s1">desc ? !m.__esModule : desc.writable || desc.configurable)) {</span>
      <span class="s1">desc = { enumerable: </span><span class="s2">true</span><span class="s1">, get: </span><span class="s2">function</span><span class="s1">() { </span><span class="s2">return </span><span class="s1">m[k]; } };</span>
    <span class="s1">}</span>
    <span class="s1">Object.defineProperty(o, k2, desc);</span>
<span class="s1">}) : (</span><span class="s2">function</span><span class="s1">(o, m, k, k2) {</span>
    <span class="s2">if </span><span class="s1">(k2 === undefined) k2 = k;</span>
    <span class="s1">o[k2] = m[k];</span>
<span class="s1">}));</span>
<span class="s2">var </span><span class="s1">__setModuleDefault = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__setModuleDefault) || (Object.create ? (</span><span class="s2">function</span><span class="s1">(o, v) {</span>
    <span class="s1">Object.defineProperty(o, </span><span class="s0">&quot;default&quot;</span><span class="s1">, { enumerable: </span><span class="s2">true</span><span class="s1">, value: v });</span>
<span class="s1">}) : </span><span class="s2">function</span><span class="s1">(o, v) {</span>
    <span class="s1">o[</span><span class="s0">&quot;default&quot;</span><span class="s1">] = v;</span>
<span class="s1">});</span>
<span class="s2">var </span><span class="s1">__importStar = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__importStar) || (</span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">var </span><span class="s1">ownKeys = </span><span class="s2">function</span><span class="s1">(o) {</span>
        <span class="s1">ownKeys = Object.getOwnPropertyNames || </span><span class="s2">function </span><span class="s1">(o) {</span>
            <span class="s2">var </span><span class="s1">ar = [];</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">k </span><span class="s2">in </span><span class="s1">o) </span><span class="s2">if </span><span class="s1">(Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;</span>
            <span class="s2">return </span><span class="s1">ar;</span>
        <span class="s1">};</span>
        <span class="s2">return </span><span class="s1">ownKeys(o);</span>
    <span class="s1">};</span>
    <span class="s2">return function </span><span class="s1">(mod) {</span>
        <span class="s2">if </span><span class="s1">(mod &amp;&amp; mod.__esModule) </span><span class="s2">return </span><span class="s1">mod;</span>
        <span class="s2">var </span><span class="s1">result = {};</span>
        <span class="s2">if </span><span class="s1">(mod != </span><span class="s2">null</span><span class="s1">) </span><span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">k = ownKeys(mod), i = </span><span class="s3">0</span><span class="s1">; i &lt; k.length; i++) </span><span class="s2">if </span><span class="s1">(k[i] !== </span><span class="s0">&quot;default&quot;</span><span class="s1">) __createBinding(result, mod, k[i]);</span>
        <span class="s1">__setModuleDefault(result, mod);</span>
        <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">};</span>
<span class="s1">})();</span>
<span class="s2">var </span><span class="s1">__importDefault = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__importDefault) || </span><span class="s2">function </span><span class="s1">(mod) {</span>
    <span class="s2">return </span><span class="s1">(mod &amp;&amp; mod.__esModule) ? mod : { </span><span class="s0">&quot;default&quot;</span><span class="s1">: mod };</span>
<span class="s1">};</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
<span class="s1">exports.useProgramFromProjectService = useProgramFromProjectService;</span>
<span class="s2">const </span><span class="s1">debug_1 = __importDefault(require(</span><span class="s0">&quot;debug&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">minimatch_1 = require(</span><span class="s0">&quot;minimatch&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">node_path_1 = __importDefault(require(</span><span class="s0">&quot;node:path&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">node_util_1 = __importDefault(require(</span><span class="s0">&quot;node:util&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">ts = __importStar(require(</span><span class="s0">&quot;typescript&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">createProjectProgram_1 = require(</span><span class="s0">&quot;./create-program/createProjectProgram&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">createSourceFile_1 = require(</span><span class="s0">&quot;./create-program/createSourceFile&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">shared_1 = require(</span><span class="s0">&quot;./create-program/shared&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">validateDefaultProjectForFilesGlob_1 = require(</span><span class="s0">&quot;./create-program/validateDefaultProjectForFilesGlob&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">RELOAD_THROTTLE_MS = </span><span class="s3">250</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">log = (</span><span class="s3">0</span><span class="s1">, debug_1.default)(</span><span class="s0">'typescript-eslint:typescript-estree:useProgramFromProjectService'</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">serviceFileExtensions = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
<span class="s2">const </span><span class="s1">updateExtraFileExtensions = (service, extraFileExtensions) =&gt; {</span>
    <span class="s2">const </span><span class="s1">currentServiceFileExtensions = serviceFileExtensions.get(service) ?? [];</span>
    <span class="s2">if </span><span class="s1">(!node_util_1.default.isDeepStrictEqual(currentServiceFileExtensions, extraFileExtensions)) {</span>
        <span class="s1">log(</span><span class="s0">'Updating extra file extensions: before=%s: after=%s'</span><span class="s1">, currentServiceFileExtensions, extraFileExtensions);</span>
        <span class="s1">service.setHostConfiguration({</span>
            <span class="s1">extraFileExtensions: extraFileExtensions.map(extension =&gt; ({</span>
                <span class="s1">extension,</span>
                <span class="s1">isMixedContent: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">scriptKind: ts.ScriptKind.Deferred,</span>
            <span class="s1">})),</span>
        <span class="s1">});</span>
        <span class="s1">serviceFileExtensions.set(service, extraFileExtensions);</span>
        <span class="s1">log(</span><span class="s0">'Extra file extensions updated: %o'</span><span class="s1">, extraFileExtensions);</span>
    <span class="s1">}</span>
<span class="s1">};</span>
<span class="s2">function </span><span class="s1">openClientFileFromProjectService(defaultProjectMatchedFiles, isDefaultProjectAllowed, filePathAbsolute, parseSettings, serviceAndSettings) {</span>
    <span class="s2">const </span><span class="s1">opened = openClientFileAndMaybeReload();</span>
    <span class="s1">log(</span><span class="s0">'Result from attempting to open client file: %o'</span><span class="s1">, opened);</span>
    <span class="s1">log(</span><span class="s0">'Default project allowed path: %s, based on config file: %s'</span><span class="s1">, isDefaultProjectAllowed, opened.configFileName);</span>
    <span class="s2">if </span><span class="s1">(opened.configFileName) {</span>
        <span class="s2">if </span><span class="s1">(isDefaultProjectAllowed) {</span>
            <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">`</span><span class="s1">${parseSettings.filePath} </span><span class="s0">was included by allowDefaultProject but also was found in the project service. Consider removing it from allowDefaultProject.`</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">else </span><span class="s1">{</span>
        <span class="s2">const </span><span class="s1">wasNotFound = </span><span class="s0">`</span><span class="s1">${parseSettings.filePath} </span><span class="s0">was not found by the project service`</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">fileExtension = node_path_1.default.extname(parseSettings.filePath);</span>
        <span class="s2">const </span><span class="s1">extraFileExtensions = parseSettings.extraFileExtensions;</span>
        <span class="s2">if </span><span class="s1">(!shared_1.DEFAULT_EXTRA_FILE_EXTENSIONS.has(fileExtension) &amp;&amp;</span>
            <span class="s1">!extraFileExtensions.includes(fileExtension)) {</span>
            <span class="s2">const </span><span class="s1">nonStandardExt = </span><span class="s0">`</span><span class="s1">${wasNotFound} </span><span class="s0">because the extension for the file (</span><span class="s4">\`</span><span class="s1">${fileExtension}</span><span class="s4">\`</span><span class="s0">) is non-standard`</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(extraFileExtensions.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
                <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">`</span><span class="s1">${nonStandardExt}</span><span class="s0">. It should be added to your existing </span><span class="s4">\`</span><span class="s0">parserOptions.extraFileExtensions</span><span class="s4">\`</span><span class="s0">.`</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">`</span><span class="s1">${nonStandardExt}</span><span class="s0">. You should add </span><span class="s4">\`</span><span class="s0">parserOptions.extraFileExtensions</span><span class="s4">\` </span><span class="s0">to your config.`</span><span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!isDefaultProjectAllowed) {</span>
            <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">`</span><span class="s1">${wasNotFound}</span><span class="s0">. Consider either including it in the tsconfig.json or including it in allowDefaultProject.`</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s5">// No a configFileName indicates this file wasn't included in a TSConfig.</span>
    <span class="s5">// That means it must get its type information from the default project.</span>
    <span class="s2">if </span><span class="s1">(!opened.configFileName) {</span>
        <span class="s1">defaultProjectMatchedFiles.add(filePathAbsolute);</span>
        <span class="s2">if </span><span class="s1">(defaultProjectMatchedFiles.size &gt;</span>
            <span class="s1">serviceAndSettings.maximumDefaultProjectFileMatchCount) {</span>
            <span class="s2">const </span><span class="s1">filePrintLimit = </span><span class="s3">20</span><span class="s1">;</span>
            <span class="s2">const </span><span class="s1">filesToPrint = [...defaultProjectMatchedFiles].slice(</span><span class="s3">0</span><span class="s1">, filePrintLimit);</span>
            <span class="s2">const </span><span class="s1">truncatedFileCount = defaultProjectMatchedFiles.size - filesToPrint.length;</span>
            <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">`Too many files (&gt;</span><span class="s1">${serviceAndSettings.maximumDefaultProjectFileMatchCount}</span><span class="s0">) have matched the default project.</span><span class="s1">${validateDefaultProjectForFilesGlob_1.DEFAULT_PROJECT_FILES_ERROR_EXPLANATION}</span>
<span class="s0">Matching files: 
</span><span class="s1">${filesToPrint.map(file =&gt; </span><span class="s0">`- </span><span class="s1">${file}</span><span class="s0">`</span><span class="s1">).join(</span><span class="s0">'</span><span class="s4">\n</span><span class="s0">'</span><span class="s1">)}</span>
<span class="s1">${truncatedFileCount ? </span><span class="s0">`...and </span><span class="s1">${truncatedFileCount} </span><span class="s0">more files</span><span class="s4">\n</span><span class="s0">` </span><span class="s1">: </span><span class="s0">''</span><span class="s1">}</span>
<span class="s0">If you absolutely need more files included, set parserOptions.projectService.maximumDefaultProjectFileMatchCount_THIS_WILL_SLOW_DOWN_LINTING to a larger value. 
`</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">opened;</span>
    <span class="s2">function </span><span class="s1">openClientFile() {</span>
        <span class="s2">return </span><span class="s1">serviceAndSettings.service.openClientFile(filePathAbsolute, parseSettings.codeFullText, </span>
        <span class="s5">/* scriptKind */ </span><span class="s1">undefined, parseSettings.tsconfigRootDir);</span>
    <span class="s1">}</span>
    <span class="s2">function </span><span class="s1">openClientFileAndMaybeReload() {</span>
        <span class="s1">log(</span><span class="s0">'Opening project service client file at path: %s'</span><span class="s1">, filePathAbsolute);</span>
        <span class="s2">let </span><span class="s1">opened = openClientFile();</span>
        <span class="s5">// If no project included the file and we're not in single-run mode,</span>
        <span class="s5">// we might be running in an editor with outdated file info.</span>
        <span class="s5">// We can try refreshing the project service - debounced for performance.</span>
        <span class="s2">if </span><span class="s1">(!opened.configFileErrors &amp;&amp;</span>
            <span class="s1">!opened.configFileName &amp;&amp;</span>
            <span class="s1">!parseSettings.singleRun &amp;&amp;</span>
            <span class="s1">!isDefaultProjectAllowed &amp;&amp;</span>
            <span class="s1">performance.now() - serviceAndSettings.lastReloadTimestamp &gt;</span>
                <span class="s1">RELOAD_THROTTLE_MS) {</span>
            <span class="s1">log(</span><span class="s0">'No config file found; reloading project service and retrying.'</span><span class="s1">);</span>
            <span class="s1">serviceAndSettings.service.reloadProjects();</span>
            <span class="s1">opened = openClientFile();</span>
            <span class="s1">serviceAndSettings.lastReloadTimestamp = performance.now();</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">opened;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createNoProgramWithProjectService(filePathAbsolute, parseSettings, service) {</span>
    <span class="s1">log(</span><span class="s0">'No project service information available. Creating no program.'</span><span class="s1">);</span>
    <span class="s5">// If the project service knows about this file, this informs if of changes.</span>
    <span class="s5">// Doing so ensures that:</span>
    <span class="s5">// - if the file is not part of a project, we don't waste time creating a program (fast non-type-aware linting)</span>
    <span class="s5">// - otherwise, we refresh the file in the project service (moderately fast, since the project is already loaded)</span>
    <span class="s2">if </span><span class="s1">(service.getScriptInfo(filePathAbsolute)) {</span>
        <span class="s1">log(</span><span class="s0">'Script info available. Opening client file in project service.'</span><span class="s1">);</span>
        <span class="s1">service.openClientFile(filePathAbsolute, parseSettings.codeFullText, </span>
        <span class="s5">/* scriptKind */ </span><span class="s1">undefined, parseSettings.tsconfigRootDir);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, createSourceFile_1.createNoProgram)(parseSettings);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">retrieveASTAndProgramFor(filePathAbsolute, parseSettings, serviceAndSettings) {</span>
    <span class="s1">log(</span><span class="s0">'Retrieving script info and then program for: %s'</span><span class="s1">, filePathAbsolute);</span>
    <span class="s2">const </span><span class="s1">scriptInfo = serviceAndSettings.service.getScriptInfo(filePathAbsolute);</span>
    <span class="s5">/* eslint-disable @typescript-eslint/no-non-null-assertion */</span>
    <span class="s2">const </span><span class="s1">program = serviceAndSettings.service</span>
        <span class="s1">.getDefaultProjectForFile(scriptInfo.fileName, </span><span class="s2">true</span><span class="s1">)</span>
        <span class="s1">.getLanguageService(</span><span class="s5">/*ensureSynchronized*/ </span><span class="s2">true</span><span class="s1">)</span>
        <span class="s1">.getProgram();</span>
    <span class="s5">/* eslint-enable @typescript-eslint/no-non-null-assertion */</span>
    <span class="s2">if </span><span class="s1">(!program) {</span>
        <span class="s1">log(</span><span class="s0">'Could not find project service program for: %s'</span><span class="s1">, filePathAbsolute);</span>
        <span class="s2">return </span><span class="s1">undefined;</span>
    <span class="s1">}</span>
    <span class="s1">log(</span><span class="s0">'Found project service program for: %s'</span><span class="s1">, filePathAbsolute);</span>
    <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, createProjectProgram_1.createProjectProgram)(parseSettings, [program]);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">useProgramFromProjectService(serviceAndSettings, parseSettings, hasFullTypeInformation, defaultProjectMatchedFiles) {</span>
    <span class="s5">// NOTE: triggers a full project reload when changes are detected</span>
    <span class="s1">updateExtraFileExtensions(serviceAndSettings.service, parseSettings.extraFileExtensions);</span>
    <span class="s5">// We don't canonicalize the filename because it caused a performance regression.</span>
    <span class="s5">// See https://github.com/typescript-eslint/typescript-eslint/issues/8519</span>
    <span class="s2">const </span><span class="s1">filePathAbsolute = absolutify(parseSettings.filePath, serviceAndSettings);</span>
    <span class="s1">log(</span><span class="s0">'Opening project service file for: %s at absolute path %s'</span><span class="s1">, parseSettings.filePath, filePathAbsolute);</span>
    <span class="s2">const </span><span class="s1">filePathRelative = node_path_1.default.relative(parseSettings.tsconfigRootDir, filePathAbsolute);</span>
    <span class="s2">const </span><span class="s1">isDefaultProjectAllowed = filePathMatchedBy(filePathRelative, serviceAndSettings.allowDefaultProject);</span>
    <span class="s5">// Type-aware linting is disabled for this file.</span>
    <span class="s5">// However, type-aware lint rules might still rely on its contents.</span>
    <span class="s2">if </span><span class="s1">(!hasFullTypeInformation &amp;&amp; !isDefaultProjectAllowed) {</span>
        <span class="s2">return </span><span class="s1">createNoProgramWithProjectService(filePathAbsolute, parseSettings, serviceAndSettings.service);</span>
    <span class="s1">}</span>
    <span class="s5">// If type info was requested, we attempt to open it in the project service.</span>
    <span class="s5">// By now, the file is known to be one of:</span>
    <span class="s5">// - in the project service (valid configuration)</span>
    <span class="s5">// - allowlisted in the default project (valid configuration)</span>
    <span class="s5">// - neither, which openClientFileFromProjectService will throw an error for</span>
    <span class="s2">const </span><span class="s1">opened = hasFullTypeInformation &amp;&amp;</span>
        <span class="s1">openClientFileFromProjectService(defaultProjectMatchedFiles, isDefaultProjectAllowed, filePathAbsolute, parseSettings, serviceAndSettings);</span>
    <span class="s1">log(</span><span class="s0">'Opened project service file: %o'</span><span class="s1">, opened);</span>
    <span class="s2">return </span><span class="s1">retrieveASTAndProgramFor(filePathAbsolute, parseSettings, serviceAndSettings);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">absolutify(filePath, serviceAndSettings) {</span>
    <span class="s2">return </span><span class="s1">node_path_1.default.isAbsolute(filePath)</span>
        <span class="s1">? filePath</span>
        <span class="s1">: node_path_1.default.join(serviceAndSettings.service.host.getCurrentDirectory(), filePath);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">filePathMatchedBy(filePath, allowDefaultProject) {</span>
    <span class="s2">return </span><span class="s1">!!allowDefaultProject?.some(pattern =&gt; (</span><span class="s3">0</span><span class="s1">, minimatch_1.minimatch)(filePath, pattern, { dot: </span><span class="s2">true </span><span class="s1">}));</span>
<span class="s1">}</span>
</pre>
</body>
</html>