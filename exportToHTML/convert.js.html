<html>
<head>
<title>convert.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
convert.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">__createBinding = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__createBinding) || (Object.create ? (</span><span class="s2">function</span><span class="s1">(o, m, k, k2) {</span>
    <span class="s2">if </span><span class="s1">(k2 === undefined) k2 = k;</span>
    <span class="s2">var </span><span class="s1">desc = Object.getOwnPropertyDescriptor(m, k);</span>
    <span class="s2">if </span><span class="s1">(!desc || (</span><span class="s0">&quot;get&quot; </span><span class="s2">in </span><span class="s1">desc ? !m.__esModule : desc.writable || desc.configurable)) {</span>
      <span class="s1">desc = { enumerable: </span><span class="s2">true</span><span class="s1">, get: </span><span class="s2">function</span><span class="s1">() { </span><span class="s2">return </span><span class="s1">m[k]; } };</span>
    <span class="s1">}</span>
    <span class="s1">Object.defineProperty(o, k2, desc);</span>
<span class="s1">}) : (</span><span class="s2">function</span><span class="s1">(o, m, k, k2) {</span>
    <span class="s2">if </span><span class="s1">(k2 === undefined) k2 = k;</span>
    <span class="s1">o[k2] = m[k];</span>
<span class="s1">}));</span>
<span class="s2">var </span><span class="s1">__setModuleDefault = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__setModuleDefault) || (Object.create ? (</span><span class="s2">function</span><span class="s1">(o, v) {</span>
    <span class="s1">Object.defineProperty(o, </span><span class="s0">&quot;default&quot;</span><span class="s1">, { enumerable: </span><span class="s2">true</span><span class="s1">, value: v });</span>
<span class="s1">}) : </span><span class="s2">function</span><span class="s1">(o, v) {</span>
    <span class="s1">o[</span><span class="s0">&quot;default&quot;</span><span class="s1">] = v;</span>
<span class="s1">});</span>
<span class="s2">var </span><span class="s1">__importStar = (</span><span class="s2">this </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.__importStar) || (</span><span class="s2">function </span><span class="s1">() {</span>
    <span class="s2">var </span><span class="s1">ownKeys = </span><span class="s2">function</span><span class="s1">(o) {</span>
        <span class="s1">ownKeys = Object.getOwnPropertyNames || </span><span class="s2">function </span><span class="s1">(o) {</span>
            <span class="s2">var </span><span class="s1">ar = [];</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">k </span><span class="s2">in </span><span class="s1">o) </span><span class="s2">if </span><span class="s1">(Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;</span>
            <span class="s2">return </span><span class="s1">ar;</span>
        <span class="s1">};</span>
        <span class="s2">return </span><span class="s1">ownKeys(o);</span>
    <span class="s1">};</span>
    <span class="s2">return function </span><span class="s1">(mod) {</span>
        <span class="s2">if </span><span class="s1">(mod &amp;&amp; mod.__esModule) </span><span class="s2">return </span><span class="s1">mod;</span>
        <span class="s2">var </span><span class="s1">result = {};</span>
        <span class="s2">if </span><span class="s1">(mod != </span><span class="s2">null</span><span class="s1">) </span><span class="s2">for </span><span class="s1">(</span><span class="s2">var </span><span class="s1">k = ownKeys(mod), i = </span><span class="s3">0</span><span class="s1">; i &lt; k.length; i++) </span><span class="s2">if </span><span class="s1">(k[i] !== </span><span class="s0">&quot;default&quot;</span><span class="s1">) __createBinding(result, mod, k[i]);</span>
        <span class="s1">__setModuleDefault(result, mod);</span>
        <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">};</span>
<span class="s1">})();</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
<span class="s1">exports.Converter = </span><span class="s2">void </span><span class="s3">0</span><span class="s1">;</span>
<span class="s1">exports.convertError = convertError;</span>
<span class="s4">// There's lots of funny stuff due to the typing of ts.Node</span>
<span class="s4">/* eslint-disable @typescript-eslint/no-non-null-assertion, @typescript-eslint/no-unnecessary-condition, @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access */</span>
<span class="s2">const </span><span class="s1">ts = __importStar(require(</span><span class="s0">&quot;typescript&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">getModifiers_1 = require(</span><span class="s0">&quot;./getModifiers&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">node_utils_1 = require(</span><span class="s0">&quot;./node-utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">ts_estree_1 = require(</span><span class="s0">&quot;./ts-estree&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">SyntaxKind = ts.SyntaxKind;</span>
<span class="s4">/**</span>
 <span class="s4">* Extends and formats a given error object</span>
 <span class="s4">* </span><span class="s5">@param </span><span class="s4">error the error object</span>
 <span class="s4">* </span><span class="s5">@returns </span><span class="s4">converted error object</span>
 <span class="s4">*/</span>
<span class="s2">function </span><span class="s1">convertError(error) {</span>
    <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, node_utils_1.createError)((</span><span class="s0">'message' </span><span class="s2">in </span><span class="s1">error &amp;&amp; error.message) || error.messageText, error.file, error.start);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isPropertyAccessEntityNameExpression(node) {</span>
    <span class="s2">return </span><span class="s1">(ts.isPropertyAccessExpression(node) &amp;&amp;</span>
        <span class="s1">ts.isIdentifier(node.name) &amp;&amp;</span>
        <span class="s1">isEntityNameExpression(node.expression));</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isEntityNameExpression(node) {</span>
    <span class="s2">return </span><span class="s1">(node.kind === SyntaxKind.Identifier ||</span>
        <span class="s1">isPropertyAccessEntityNameExpression(node));</span>
<span class="s1">}</span>
<span class="s2">class </span><span class="s1">Converter {</span>
    <span class="s1">allowPattern = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">ast;</span>
    <span class="s1">esTreeNodeToTSNodeMap = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
    <span class="s1">options;</span>
    <span class="s1">tsNodeToESTreeNodeMap = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
    <span class="s4">/**</span>
     <span class="s4">* Converts a TypeScript node into an ESTree node</span>
     <span class="s4">* </span><span class="s5">@param </span><span class="s4">ast the full TypeScript AST</span>
     <span class="s4">* </span><span class="s5">@param </span><span class="s4">options additional options for the conversion</span>
     <span class="s4">* </span><span class="s5">@returns </span><span class="s4">the converted ESTreeNode</span>
     <span class="s4">*/</span>
    <span class="s1">constructor(ast, options) {</span>
        <span class="s2">this</span><span class="s1">.ast = ast;</span>
        <span class="s2">this</span><span class="s1">.options = { ...options };</span>
    <span class="s1">}</span>
    <span class="s1">#checkForStatementDeclaration(initializer, kind) {</span>
        <span class="s2">const </span><span class="s1">loop = kind === ts.SyntaxKind.ForInStatement ? </span><span class="s0">'for...in' </span><span class="s1">: </span><span class="s0">'for...of'</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(ts.isVariableDeclarationList(initializer)) {</span>
            <span class="s2">if </span><span class="s1">(initializer.declarations.length !== </span><span class="s3">1</span><span class="s1">) {</span>
                <span class="s2">this</span><span class="s1">.#throwError(initializer, </span><span class="s0">`Only a single variable declaration is allowed in a '</span><span class="s1">${loop}</span><span class="s0">' statement.`</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">declaration = initializer.declarations[</span><span class="s3">0</span><span class="s1">];</span>
            <span class="s2">if </span><span class="s1">(declaration.initializer) {</span>
                <span class="s2">this</span><span class="s1">.#throwError(declaration, </span><span class="s0">`The variable declaration of a '</span><span class="s1">${loop}</span><span class="s0">' statement cannot have an initializer.`</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(declaration.type) {</span>
                <span class="s2">this</span><span class="s1">.#throwError(declaration, </span><span class="s0">`The variable declaration of a '</span><span class="s1">${loop}</span><span class="s0">' statement cannot have a type annotation.`</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(kind === ts.SyntaxKind.ForInStatement &amp;&amp;</span>
                <span class="s1">initializer.flags &amp; ts.NodeFlags.Using) {</span>
                <span class="s2">this</span><span class="s1">.#throwError(initializer, </span><span class="s0">&quot;The left-hand side of a 'for...in' statement cannot be a 'using' declaration.&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(!(</span><span class="s3">0</span><span class="s1">, node_utils_1.isValidAssignmentTarget)(initializer) &amp;&amp;</span>
            <span class="s1">initializer.kind !== ts.SyntaxKind.ObjectLiteralExpression &amp;&amp;</span>
            <span class="s1">initializer.kind !== ts.SyntaxKind.ArrayLiteralExpression) {</span>
            <span class="s2">this</span><span class="s1">.#throwError(initializer, </span><span class="s0">`The left-hand side of a '</span><span class="s1">${loop}</span><span class="s0">' statement must be a variable or a property access.`</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">#checkModifiers(node) {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.allowInvalidAST) {</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s4">// typescript&lt;5.0.0</span>
        <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, node_utils_1.nodeHasIllegalDecorators)(node)) {</span>
            <span class="s2">this</span><span class="s1">.#throwError(node.illegalDecorators[</span><span class="s3">0</span><span class="s1">], </span><span class="s0">'Decorators are not valid here.'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">decorator of (</span><span class="s3">0</span><span class="s1">, getModifiers_1.getDecorators)(node, </span>
        <span class="s4">/* includeIllegalDecorators */ </span><span class="s2">true</span><span class="s1">) ?? []) {</span>
            <span class="s4">// `checkGrammarModifiers` function in typescript</span>
            <span class="s2">if </span><span class="s1">(!(</span><span class="s3">0</span><span class="s1">, node_utils_1.nodeCanBeDecorated)(node)) {</span>
                <span class="s2">if </span><span class="s1">(ts.isMethodDeclaration(node) &amp;&amp; !(</span><span class="s3">0</span><span class="s1">, node_utils_1.nodeIsPresent)(node.body)) {</span>
                    <span class="s2">this</span><span class="s1">.#throwError(decorator, </span><span class="s0">'A decorator can only decorate a method implementation, not an overload.'</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">this</span><span class="s1">.#throwError(decorator, </span><span class="s0">'Decorators are not valid here.'</span><span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">modifier of (</span><span class="s3">0</span><span class="s1">, getModifiers_1.getModifiers)(node, </span>
        <span class="s4">/* includeIllegalModifiers */ </span><span class="s2">true</span><span class="s1">) ?? []) {</span>
            <span class="s2">if </span><span class="s1">(modifier.kind !== SyntaxKind.ReadonlyKeyword) {</span>
                <span class="s2">if </span><span class="s1">(node.kind === SyntaxKind.PropertySignature ||</span>
                    <span class="s1">node.kind === SyntaxKind.MethodSignature) {</span>
                    <span class="s2">this</span><span class="s1">.#throwError(modifier, </span><span class="s0">`'</span><span class="s1">${ts.tokenToString(modifier.kind)}</span><span class="s0">' modifier cannot appear on a type member`</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(node.kind === SyntaxKind.IndexSignature &amp;&amp;</span>
                    <span class="s1">(modifier.kind !== SyntaxKind.StaticKeyword ||</span>
                        <span class="s1">!ts.isClassLike(node.parent))) {</span>
                    <span class="s2">this</span><span class="s1">.#throwError(modifier, </span><span class="s0">`'</span><span class="s1">${ts.tokenToString(modifier.kind)}</span><span class="s0">' modifier cannot appear on an index signature`</span><span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(modifier.kind !== SyntaxKind.InKeyword &amp;&amp;</span>
                <span class="s1">modifier.kind !== SyntaxKind.OutKeyword &amp;&amp;</span>
                <span class="s1">modifier.kind !== SyntaxKind.ConstKeyword &amp;&amp;</span>
                <span class="s1">node.kind === SyntaxKind.TypeParameter) {</span>
                <span class="s2">this</span><span class="s1">.#throwError(modifier, </span><span class="s0">`'</span><span class="s1">${ts.tokenToString(modifier.kind)}</span><span class="s0">' modifier cannot appear on a type parameter`</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">((modifier.kind === SyntaxKind.InKeyword ||</span>
                <span class="s1">modifier.kind === SyntaxKind.OutKeyword) &amp;&amp;</span>
                <span class="s1">(node.kind !== SyntaxKind.TypeParameter ||</span>
                    <span class="s1">!(ts.isInterfaceDeclaration(node.parent) ||</span>
                        <span class="s1">ts.isClassLike(node.parent) ||</span>
                        <span class="s1">ts.isTypeAliasDeclaration(node.parent)))) {</span>
                <span class="s2">this</span><span class="s1">.#throwError(modifier, </span><span class="s0">`'</span><span class="s1">${ts.tokenToString(modifier.kind)}</span><span class="s0">' modifier can only appear on a type parameter of a class, interface or type alias`</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(modifier.kind === SyntaxKind.ReadonlyKeyword &amp;&amp;</span>
                <span class="s1">node.kind !== SyntaxKind.PropertyDeclaration &amp;&amp;</span>
                <span class="s1">node.kind !== SyntaxKind.PropertySignature &amp;&amp;</span>
                <span class="s1">node.kind !== SyntaxKind.IndexSignature &amp;&amp;</span>
                <span class="s1">node.kind !== SyntaxKind.Parameter) {</span>
                <span class="s2">this</span><span class="s1">.#throwError(modifier, </span><span class="s0">&quot;'readonly' modifier can only appear on a property declaration or index signature.&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(modifier.kind === SyntaxKind.DeclareKeyword &amp;&amp;</span>
                <span class="s1">ts.isClassLike(node.parent) &amp;&amp;</span>
                <span class="s1">!ts.isPropertyDeclaration(node)) {</span>
                <span class="s2">this</span><span class="s1">.#throwError(modifier, </span><span class="s0">`'</span><span class="s1">${ts.tokenToString(modifier.kind)}</span><span class="s0">' modifier cannot appear on class elements of this kind.`</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(modifier.kind === SyntaxKind.DeclareKeyword &amp;&amp;</span>
                <span class="s1">ts.isVariableStatement(node)) {</span>
                <span class="s2">const </span><span class="s1">declarationKind = (</span><span class="s3">0</span><span class="s1">, node_utils_1.getDeclarationKind)(node.declarationList);</span>
                <span class="s2">if </span><span class="s1">(declarationKind === </span><span class="s0">'using' </span><span class="s1">|| declarationKind === </span><span class="s0">'await using'</span><span class="s1">) {</span>
                    <span class="s2">this</span><span class="s1">.#throwError(modifier, </span><span class="s0">`'declare' modifier cannot appear on a '</span><span class="s1">${declarationKind}</span><span class="s0">' declaration.`</span><span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(modifier.kind === SyntaxKind.AbstractKeyword &amp;&amp;</span>
                <span class="s1">node.kind !== SyntaxKind.ClassDeclaration &amp;&amp;</span>
                <span class="s1">node.kind !== SyntaxKind.ConstructorType &amp;&amp;</span>
                <span class="s1">node.kind !== SyntaxKind.MethodDeclaration &amp;&amp;</span>
                <span class="s1">node.kind !== SyntaxKind.PropertyDeclaration &amp;&amp;</span>
                <span class="s1">node.kind !== SyntaxKind.GetAccessor &amp;&amp;</span>
                <span class="s1">node.kind !== SyntaxKind.SetAccessor) {</span>
                <span class="s2">this</span><span class="s1">.#throwError(modifier, </span><span class="s0">`'</span><span class="s1">${ts.tokenToString(modifier.kind)}</span><span class="s0">' modifier can only appear on a class, method, or property declaration.`</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">((modifier.kind === SyntaxKind.StaticKeyword ||</span>
                <span class="s1">modifier.kind === SyntaxKind.PublicKeyword ||</span>
                <span class="s1">modifier.kind === SyntaxKind.ProtectedKeyword ||</span>
                <span class="s1">modifier.kind === SyntaxKind.PrivateKeyword) &amp;&amp;</span>
                <span class="s1">(node.parent.kind === SyntaxKind.ModuleBlock ||</span>
                    <span class="s1">node.parent.kind === SyntaxKind.SourceFile)) {</span>
                <span class="s2">this</span><span class="s1">.#throwError(modifier, </span><span class="s0">`'</span><span class="s1">${ts.tokenToString(modifier.kind)}</span><span class="s0">' modifier cannot appear on a module or namespace element.`</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(modifier.kind === SyntaxKind.AccessorKeyword &amp;&amp;</span>
                <span class="s1">node.kind !== SyntaxKind.PropertyDeclaration) {</span>
                <span class="s2">this</span><span class="s1">.#throwError(modifier, </span><span class="s0">&quot;'accessor' modifier can only appear on a property declaration.&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s4">// `checkGrammarAsyncModifier` function in `typescript`</span>
            <span class="s2">if </span><span class="s1">(modifier.kind === SyntaxKind.AsyncKeyword &amp;&amp;</span>
                <span class="s1">node.kind !== SyntaxKind.MethodDeclaration &amp;&amp;</span>
                <span class="s1">node.kind !== SyntaxKind.FunctionDeclaration &amp;&amp;</span>
                <span class="s1">node.kind !== SyntaxKind.FunctionExpression &amp;&amp;</span>
                <span class="s1">node.kind !== SyntaxKind.ArrowFunction) {</span>
                <span class="s2">this</span><span class="s1">.#throwError(modifier, </span><span class="s0">&quot;'async' modifier cannot be used here.&quot;</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s4">// `checkGrammarModifiers` function in `typescript`</span>
            <span class="s2">if </span><span class="s1">(node.kind === SyntaxKind.Parameter &amp;&amp;</span>
                <span class="s1">(modifier.kind === SyntaxKind.StaticKeyword ||</span>
                    <span class="s1">modifier.kind === SyntaxKind.ExportKeyword ||</span>
                    <span class="s1">modifier.kind === SyntaxKind.DeclareKeyword ||</span>
                    <span class="s1">modifier.kind === SyntaxKind.AsyncKeyword)) {</span>
                <span class="s2">this</span><span class="s1">.#throwError(modifier, </span><span class="s0">`'</span><span class="s1">${ts.tokenToString(modifier.kind)}</span><span class="s0">' modifier cannot appear on a parameter.`</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s4">// `checkGrammarModifiers` function in `typescript`</span>
            <span class="s2">if </span><span class="s1">(modifier.kind === SyntaxKind.PublicKeyword ||</span>
                <span class="s1">modifier.kind === SyntaxKind.ProtectedKeyword ||</span>
                <span class="s1">modifier.kind === SyntaxKind.PrivateKeyword) {</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">anotherModifier of (</span><span class="s3">0</span><span class="s1">, getModifiers_1.getModifiers)(node) ?? []) {</span>
                    <span class="s2">if </span><span class="s1">(anotherModifier !== modifier &amp;&amp;</span>
                        <span class="s1">(anotherModifier.kind === SyntaxKind.PublicKeyword ||</span>
                            <span class="s1">anotherModifier.kind === SyntaxKind.ProtectedKeyword ||</span>
                            <span class="s1">anotherModifier.kind === SyntaxKind.PrivateKeyword)) {</span>
                        <span class="s2">this</span><span class="s1">.#throwError(anotherModifier, </span><span class="s0">`Accessibility modifier already seen.`</span><span class="s1">);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s4">// `checkParameter` function in `typescript`</span>
            <span class="s2">if </span><span class="s1">(node.kind === SyntaxKind.Parameter &amp;&amp;</span>
                <span class="s4">// In `typescript` package, it's `ts.hasSyntacticModifier(node, ts.ModifierFlags.ParameterPropertyModifier)`</span>
                <span class="s4">// https://github.com/typescript-eslint/typescript-eslint/pull/6615#discussion_r1136489935</span>
                <span class="s1">(modifier.kind === SyntaxKind.PublicKeyword ||</span>
                    <span class="s1">modifier.kind === SyntaxKind.PrivateKeyword ||</span>
                    <span class="s1">modifier.kind === SyntaxKind.ProtectedKeyword ||</span>
                    <span class="s1">modifier.kind === SyntaxKind.ReadonlyKeyword ||</span>
                    <span class="s1">modifier.kind === SyntaxKind.OverrideKeyword)) {</span>
                <span class="s2">const </span><span class="s1">func = (</span><span class="s3">0</span><span class="s1">, node_utils_1.getContainingFunction)(node);</span>
                <span class="s2">if </span><span class="s1">(!(func.kind === SyntaxKind.Constructor &amp;&amp; (</span><span class="s3">0</span><span class="s1">, node_utils_1.nodeIsPresent)(func.body))) {</span>
                    <span class="s2">this</span><span class="s1">.#throwError(modifier, </span><span class="s0">'A parameter property is only allowed in a constructor implementation.'</span><span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">#throwError(node, message) {</span>
        <span class="s2">let </span><span class="s1">start;</span>
        <span class="s2">let </span><span class="s1">end;</span>
        <span class="s2">if </span><span class="s1">(Array.isArray(node)) {</span>
            <span class="s1">[start, end] = node;</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">node === </span><span class="s0">'number'</span><span class="s1">) {</span>
            <span class="s1">start = end = node;</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">start = node.getStart(</span><span class="s2">this</span><span class="s1">.ast);</span>
            <span class="s1">end = node.getEnd();</span>
        <span class="s1">}</span>
        <span class="s2">throw </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, node_utils_1.createError)(message, </span><span class="s2">this</span><span class="s1">.ast, start, end);</span>
    <span class="s1">}</span>
    <span class="s1">#throwUnlessAllowInvalidAST(node, message) {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.options.allowInvalidAST) {</span>
            <span class="s2">this</span><span class="s1">.#throwError(node, message);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s4">/**</span>
     <span class="s4">* Creates a getter for a property under aliasKey that returns the value under</span>
     <span class="s4">* valueKey. If suppressDeprecatedPropertyWarnings is not enabled, the</span>
     <span class="s4">* getter also console warns about the deprecation.</span>
     <span class="s4">*</span>
     <span class="s4">* </span><span class="s5">@see </span><span class="s4">https://github.com/typescript-eslint/typescript-eslint/issues/6469</span>
     <span class="s4">*/</span>
    <span class="s1">#withDeprecatedAliasGetter(node, aliasKey, valueKey, suppressWarnings = </span><span class="s2">false</span><span class="s1">) {</span>
        <span class="s2">let </span><span class="s1">warned = suppressWarnings;</span>
        <span class="s1">Object.defineProperty(node, aliasKey, {</span>
            <span class="s1">configurable: </span><span class="s2">true</span><span class="s1">,</span>
            <span class="s1">get: </span><span class="s2">this</span><span class="s1">.options.suppressDeprecatedPropertyWarnings</span>
                <span class="s1">? () =&gt; node[valueKey]</span>
                <span class="s1">: () =&gt; {</span>
                    <span class="s2">if </span><span class="s1">(!warned) {</span>
                        <span class="s1">process.emitWarning(</span><span class="s0">`The '</span><span class="s1">${aliasKey}</span><span class="s0">' property is deprecated on </span><span class="s1">${node.type} </span><span class="s0">nodes. Use '</span><span class="s1">${valueKey}</span><span class="s0">' instead. See https://typescript-eslint.io/troubleshooting/faqs/general#the-key-property-is-deprecated-on-type-nodes-use-key-instead-warnings.`</span><span class="s1">, </span><span class="s0">'DeprecationWarning'</span><span class="s1">);</span>
                        <span class="s1">warned = </span><span class="s2">true</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s2">return </span><span class="s1">node[valueKey];</span>
                <span class="s1">},</span>
            <span class="s1">set(value) {</span>
                <span class="s1">Object.defineProperty(node, aliasKey, {</span>
                    <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
                    <span class="s1">value,</span>
                    <span class="s1">writable: </span><span class="s2">true</span><span class="s1">,</span>
                <span class="s1">});</span>
            <span class="s1">},</span>
        <span class="s1">});</span>
        <span class="s2">return </span><span class="s1">node;</span>
    <span class="s1">}</span>
    <span class="s1">#withDeprecatedGetter(node, deprecatedKey, preferredKey, value) {</span>
        <span class="s2">let </span><span class="s1">warned = </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s1">Object.defineProperty(node, deprecatedKey, {</span>
            <span class="s1">configurable: </span><span class="s2">true</span><span class="s1">,</span>
            <span class="s1">get: </span><span class="s2">this</span><span class="s1">.options.suppressDeprecatedPropertyWarnings</span>
                <span class="s1">? () =&gt; value</span>
                <span class="s1">: () =&gt; {</span>
                    <span class="s2">if </span><span class="s1">(!warned) {</span>
                        <span class="s2">let </span><span class="s1">message = </span><span class="s0">`The '</span><span class="s1">${deprecatedKey}</span><span class="s0">' property is deprecated on </span><span class="s1">${node.type} </span><span class="s0">nodes.`</span><span class="s1">;</span>
                        <span class="s2">if </span><span class="s1">(preferredKey) {</span>
                            <span class="s1">message += </span><span class="s0">` Use </span><span class="s1">${preferredKey} </span><span class="s0">instead.`</span><span class="s1">;</span>
                        <span class="s1">}</span>
                        <span class="s1">message +=</span>
                            <span class="s0">' See https://typescript-eslint.io/troubleshooting/faqs/general#the-key-property-is-deprecated-on-type-nodes-use-key-instead-warnings.'</span><span class="s1">;</span>
                        <span class="s1">process.emitWarning(message, </span><span class="s0">'DeprecationWarning'</span><span class="s1">);</span>
                        <span class="s1">warned = </span><span class="s2">true</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s2">return </span><span class="s1">value;</span>
                <span class="s1">},</span>
            <span class="s1">set(value) {</span>
                <span class="s1">Object.defineProperty(node, deprecatedKey, {</span>
                    <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
                    <span class="s1">value,</span>
                    <span class="s1">writable: </span><span class="s2">true</span><span class="s1">,</span>
                <span class="s1">});</span>
            <span class="s1">},</span>
        <span class="s1">});</span>
        <span class="s2">return </span><span class="s1">node;</span>
    <span class="s1">}</span>
    <span class="s1">assertModuleSpecifier(node, allowNull) {</span>
        <span class="s2">if </span><span class="s1">(!allowNull &amp;&amp; node.moduleSpecifier == </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.#throwUnlessAllowInvalidAST(node, </span><span class="s0">'Module specifier must be a string literal.'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(node.moduleSpecifier &amp;&amp;</span>
            <span class="s1">node.moduleSpecifier?.kind !== SyntaxKind.StringLiteral) {</span>
            <span class="s2">this</span><span class="s1">.#throwUnlessAllowInvalidAST(node.moduleSpecifier, </span><span class="s0">'Module specifier must be a string literal.'</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">convertBindingNameWithTypeAnnotation(name, tsType, parent) {</span>
        <span class="s2">const </span><span class="s1">id = </span><span class="s2">this</span><span class="s1">.convertPattern(name);</span>
        <span class="s2">if </span><span class="s1">(tsType) {</span>
            <span class="s1">id.typeAnnotation = </span><span class="s2">this</span><span class="s1">.convertTypeAnnotation(tsType, parent);</span>
            <span class="s2">this</span><span class="s1">.fixParentLocation(id, id.typeAnnotation.range);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">id;</span>
    <span class="s1">}</span>
    <span class="s4">/**</span>
     <span class="s4">* Coverts body Nodes and add a directive field to StringLiterals</span>
     <span class="s4">* </span><span class="s5">@param </span><span class="s4">nodes of ts.Node</span>
     <span class="s4">* </span><span class="s5">@param </span><span class="s4">parent parentNode</span>
     <span class="s4">* </span><span class="s5">@returns </span><span class="s4">Array of body statements</span>
     <span class="s4">*/</span>
    <span class="s1">convertBodyExpressions(nodes, parent) {</span>
        <span class="s2">let </span><span class="s1">allowDirectives = (</span><span class="s3">0</span><span class="s1">, node_utils_1.canContainDirective)(parent);</span>
        <span class="s2">return </span><span class="s1">(nodes</span>
            <span class="s1">.map(statement =&gt; {</span>
            <span class="s2">const </span><span class="s1">child = </span><span class="s2">this</span><span class="s1">.convertChild(statement);</span>
            <span class="s2">if </span><span class="s1">(allowDirectives) {</span>
                <span class="s2">if </span><span class="s1">(child?.expression &amp;&amp;</span>
                    <span class="s1">ts.isExpressionStatement(statement) &amp;&amp;</span>
                    <span class="s1">ts.isStringLiteral(statement.expression)) {</span>
                    <span class="s2">const </span><span class="s1">raw = child.expression.raw;</span>
                    <span class="s1">child.directive = raw.slice(</span><span class="s3">1</span><span class="s1">, -</span><span class="s3">1</span><span class="s1">);</span>
                    <span class="s2">return </span><span class="s1">child; </span><span class="s4">// child can be null, but it's filtered below</span>
                <span class="s1">}</span>
                <span class="s1">allowDirectives = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">child; </span><span class="s4">// child can be null, but it's filtered below</span>
        <span class="s1">})</span>
            <span class="s4">// filter out unknown nodes for now</span>
            <span class="s1">.filter(statement =&gt; statement));</span>
    <span class="s1">}</span>
    <span class="s1">convertChainExpression(node, tsNode) {</span>
        <span class="s2">const </span><span class="s1">{ child, isOptional } = (() =&gt; {</span>
            <span class="s2">if </span><span class="s1">(node.type === ts_estree_1.AST_NODE_TYPES.MemberExpression) {</span>
                <span class="s2">return </span><span class="s1">{ child: node.object, isOptional: node.optional };</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(node.type === ts_estree_1.AST_NODE_TYPES.CallExpression) {</span>
                <span class="s2">return </span><span class="s1">{ child: node.callee, isOptional: node.optional };</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">{ child: node.expression, isOptional: </span><span class="s2">false </span><span class="s1">};</span>
        <span class="s1">})();</span>
        <span class="s2">const </span><span class="s1">isChildUnwrappable = (</span><span class="s3">0</span><span class="s1">, node_utils_1.isChildUnwrappableOptionalChain)(tsNode, child);</span>
        <span class="s2">if </span><span class="s1">(!isChildUnwrappable &amp;&amp; !isOptional) {</span>
            <span class="s2">return </span><span class="s1">node;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(isChildUnwrappable &amp;&amp; (</span><span class="s3">0</span><span class="s1">, node_utils_1.isChainExpression)(child)) {</span>
            <span class="s4">// unwrap the chain expression child</span>
            <span class="s2">const </span><span class="s1">newChild = child.expression;</span>
            <span class="s2">if </span><span class="s1">(node.type === ts_estree_1.AST_NODE_TYPES.MemberExpression) {</span>
                <span class="s1">node.object = newChild;</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(node.type === ts_estree_1.AST_NODE_TYPES.CallExpression) {</span>
                <span class="s1">node.callee = newChild;</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">node.expression = newChild;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.createNode(tsNode, {</span>
            <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ChainExpression,</span>
            <span class="s1">expression: node,</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s4">/**</span>
     <span class="s4">* Converts a TypeScript node into an ESTree node.</span>
     <span class="s4">* </span><span class="s5">@param </span><span class="s4">child the child ts.Node</span>
     <span class="s4">* </span><span class="s5">@param </span><span class="s4">parent parentNode</span>
     <span class="s4">* </span><span class="s5">@returns </span><span class="s4">the converted ESTree node</span>
     <span class="s4">*/</span>
    <span class="s1">convertChild(child, parent) {</span>
        <span class="s2">return this</span><span class="s1">.converter(child, parent, </span><span class="s2">false</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s4">/**</span>
     <span class="s4">* Converts TypeScript node array into an ESTree node list.</span>
     <span class="s4">* </span><span class="s5">@param </span><span class="s4">children the child `ts.NodeArray` or `ts.Node[]`</span>
     <span class="s4">* </span><span class="s5">@param </span><span class="s4">parent parentNode</span>
     <span class="s4">* </span><span class="s5">@returns </span><span class="s4">the converted ESTree node list</span>
     <span class="s4">*/</span>
    <span class="s1">convertChildren(children, parent) {</span>
        <span class="s2">return </span><span class="s1">children.map(child =&gt; </span><span class="s2">this</span><span class="s1">.converter(child, parent, </span><span class="s2">false</span><span class="s1">));</span>
    <span class="s1">}</span>
    <span class="s4">/**</span>
     <span class="s4">* Converts a TypeScript node into an ESTree node.</span>
     <span class="s4">* </span><span class="s5">@param </span><span class="s4">child the child ts.Node</span>
     <span class="s4">* </span><span class="s5">@param </span><span class="s4">parent parentNode</span>
     <span class="s4">* </span><span class="s5">@returns </span><span class="s4">the converted ESTree node</span>
     <span class="s4">*/</span>
    <span class="s1">convertPattern(child, parent) {</span>
        <span class="s2">return this</span><span class="s1">.converter(child, parent, </span><span class="s2">true</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s4">/**</span>
     <span class="s4">* Converts a child into a type annotation. This creates an intermediary</span>
     <span class="s4">* TypeAnnotation node to match what Flow does.</span>
     <span class="s4">* </span><span class="s5">@param </span><span class="s4">child The TypeScript AST node to convert.</span>
     <span class="s4">* </span><span class="s5">@param </span><span class="s4">parent parentNode</span>
     <span class="s4">* </span><span class="s5">@returns </span><span class="s4">The type annotation node.</span>
     <span class="s4">*/</span>
    <span class="s1">convertTypeAnnotation(child, parent) {</span>
        <span class="s4">// in FunctionType and ConstructorType typeAnnotation has 2 characters `=&gt;` and in other places is just colon</span>
        <span class="s2">const </span><span class="s1">offset = parent?.kind === SyntaxKind.FunctionType ||</span>
            <span class="s1">parent?.kind === SyntaxKind.ConstructorType</span>
            <span class="s1">? </span><span class="s3">2</span>
            <span class="s1">: </span><span class="s3">1</span><span class="s1">;</span>
        <span class="s2">const </span><span class="s1">annotationStartCol = child.getFullStart() - offset;</span>
        <span class="s2">const </span><span class="s1">range = [annotationStartCol, child.end];</span>
        <span class="s2">const </span><span class="s1">loc = (</span><span class="s3">0</span><span class="s1">, node_utils_1.getLocFor)(range, </span><span class="s2">this</span><span class="s1">.ast);</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSTypeAnnotation,</span>
            <span class="s1">loc,</span>
            <span class="s1">range,</span>
            <span class="s1">typeAnnotation: </span><span class="s2">this</span><span class="s1">.convertChild(child),</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s4">/**</span>
     <span class="s4">* Converts a ts.Node's typeArguments to TSTypeParameterInstantiation node</span>
     <span class="s4">* </span><span class="s5">@param </span><span class="s4">typeArguments ts.NodeArray typeArguments</span>
     <span class="s4">* </span><span class="s5">@param </span><span class="s4">node parent used to create this node</span>
     <span class="s4">* </span><span class="s5">@returns </span><span class="s4">TypeParameterInstantiation node</span>
     <span class="s4">*/</span>
    <span class="s1">convertTypeArgumentsToTypeParameterInstantiation(typeArguments, node) {</span>
        <span class="s2">const </span><span class="s1">greaterThanToken = (</span><span class="s3">0</span><span class="s1">, node_utils_1.findNextToken)(typeArguments, </span><span class="s2">this</span><span class="s1">.ast, </span><span class="s2">this</span><span class="s1">.ast);</span>
        <span class="s2">const </span><span class="s1">range = [typeArguments.pos - </span><span class="s3">1</span><span class="s1">, greaterThanToken.end];</span>
        <span class="s2">if </span><span class="s1">(typeArguments.length === </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.#throwError(range, </span><span class="s0">'Type argument list cannot be empty.'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
            <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSTypeParameterInstantiation,</span>
            <span class="s1">range,</span>
            <span class="s1">params: </span><span class="s2">this</span><span class="s1">.convertChildren(typeArguments),</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s4">/**</span>
     <span class="s4">* Converts a ts.Node's typeParameters to TSTypeParameterDeclaration node</span>
     <span class="s4">* </span><span class="s5">@param </span><span class="s4">typeParameters ts.Node typeParameters</span>
     <span class="s4">* </span><span class="s5">@returns </span><span class="s4">TypeParameterDeclaration node</span>
     <span class="s4">*/</span>
    <span class="s1">convertTSTypeParametersToTypeParametersDeclaration(typeParameters) {</span>
        <span class="s2">const </span><span class="s1">greaterThanToken = (</span><span class="s3">0</span><span class="s1">, node_utils_1.findNextToken)(typeParameters, </span><span class="s2">this</span><span class="s1">.ast, </span><span class="s2">this</span><span class="s1">.ast);</span>
        <span class="s2">const </span><span class="s1">range = [</span>
            <span class="s1">typeParameters.pos - </span><span class="s3">1</span><span class="s1">,</span>
            <span class="s1">greaterThanToken.end,</span>
        <span class="s1">];</span>
        <span class="s2">if </span><span class="s1">(typeParameters.length === </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.#throwError(range, </span><span class="s0">'Type parameter list cannot be empty.'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSTypeParameterDeclaration,</span>
            <span class="s1">loc: (</span><span class="s3">0</span><span class="s1">, node_utils_1.getLocFor)(range, </span><span class="s2">this</span><span class="s1">.ast),</span>
            <span class="s1">range,</span>
            <span class="s1">params: </span><span class="s2">this</span><span class="s1">.convertChildren(typeParameters),</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s4">/**</span>
     <span class="s4">* Converts an array of ts.Node parameters into an array of ESTreeNode params</span>
     <span class="s4">* </span><span class="s5">@param </span><span class="s4">parameters An array of ts.Node params to be converted</span>
     <span class="s4">* </span><span class="s5">@returns </span><span class="s4">an array of converted ESTreeNode params</span>
     <span class="s4">*/</span>
    <span class="s1">convertParameters(parameters) {</span>
        <span class="s2">if </span><span class="s1">(!parameters?.length) {</span>
            <span class="s2">return </span><span class="s1">[];</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">parameters.map(param =&gt; {</span>
            <span class="s2">const </span><span class="s1">convertedParam = </span><span class="s2">this</span><span class="s1">.convertChild(param);</span>
            <span class="s1">convertedParam.decorators = </span><span class="s2">this</span><span class="s1">.convertChildren((</span><span class="s3">0</span><span class="s1">, getModifiers_1.getDecorators)(param) ?? []);</span>
            <span class="s2">return </span><span class="s1">convertedParam;</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s4">/**</span>
     <span class="s4">* Converts a TypeScript node into an ESTree node.</span>
     <span class="s4">* </span><span class="s5">@param </span><span class="s4">node the child ts.Node</span>
     <span class="s4">* </span><span class="s5">@param </span><span class="s4">parent parentNode</span>
     <span class="s4">* </span><span class="s5">@param </span><span class="s4">allowPattern flag to determine if patterns are allowed</span>
     <span class="s4">* </span><span class="s5">@returns </span><span class="s4">the converted ESTree node</span>
     <span class="s4">*/</span>
    <span class="s1">converter(node, parent, allowPattern) {</span>
        <span class="s4">/**</span>
         <span class="s4">* Exit early for null and undefined</span>
         <span class="s4">*/</span>
        <span class="s2">if </span><span class="s1">(!node) {</span>
            <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.#checkModifiers(node);</span>
        <span class="s2">const </span><span class="s1">pattern = </span><span class="s2">this</span><span class="s1">.allowPattern;</span>
        <span class="s2">if </span><span class="s1">(allowPattern != </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.allowPattern = allowPattern;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">result = </span><span class="s2">this</span><span class="s1">.convertNode(node, (parent ?? node.parent));</span>
        <span class="s2">this</span><span class="s1">.registerTSNodeInNodeMap(node, result);</span>
        <span class="s2">this</span><span class="s1">.allowPattern = pattern;</span>
        <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>
    <span class="s1">convertImportAttributes(node) {</span>
        <span class="s4">// eslint-disable-next-line @typescript-eslint/no-deprecated</span>
        <span class="s2">const </span><span class="s1">attributes = node.attributes ?? node.assertClause;</span>
        <span class="s2">return this</span><span class="s1">.convertChildren(attributes?.elements ?? []);</span>
    <span class="s1">}</span>
    <span class="s1">convertJSXIdentifier(node) {</span>
        <span class="s2">const </span><span class="s1">result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
            <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXIdentifier,</span>
            <span class="s1">name: node.getText(),</span>
        <span class="s1">});</span>
        <span class="s2">this</span><span class="s1">.registerTSNodeInNodeMap(node, result);</span>
        <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>
    <span class="s1">convertJSXNamespaceOrIdentifier(node) {</span>
        <span class="s4">// TypeScript@5.1 added in ts.JsxNamespacedName directly</span>
        <span class="s4">// We prefer using that if it's relevant for this node type</span>
        <span class="s2">if </span><span class="s1">(node.kind === ts.SyntaxKind.JsxNamespacedName) {</span>
            <span class="s2">const </span><span class="s1">result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXNamespacedName,</span>
                <span class="s1">name: </span><span class="s2">this</span><span class="s1">.createNode(node.name, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXIdentifier,</span>
                    <span class="s1">name: node.name.text,</span>
                <span class="s1">}),</span>
                <span class="s1">namespace: </span><span class="s2">this</span><span class="s1">.createNode(node.namespace, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXIdentifier,</span>
                    <span class="s1">name: node.namespace.text,</span>
                <span class="s1">}),</span>
            <span class="s1">});</span>
            <span class="s2">this</span><span class="s1">.registerTSNodeInNodeMap(node, result);</span>
            <span class="s2">return </span><span class="s1">result;</span>
        <span class="s1">}</span>
        <span class="s4">// TypeScript@&lt;5.1 has to manually parse the JSX attributes</span>
        <span class="s2">const </span><span class="s1">text = node.getText();</span>
        <span class="s2">const </span><span class="s1">colonIndex = text.indexOf(</span><span class="s0">':'</span><span class="s1">);</span>
        <span class="s4">// this is intentional we can ignore conversion if `:` is in first character</span>
        <span class="s2">if </span><span class="s1">(colonIndex &gt; </span><span class="s3">0</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">range = (</span><span class="s3">0</span><span class="s1">, node_utils_1.getRange)(node, </span><span class="s2">this</span><span class="s1">.ast);</span>
            <span class="s2">const </span><span class="s1">result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXNamespacedName,</span>
                <span class="s1">range,</span>
                <span class="s1">name: </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXIdentifier,</span>
                    <span class="s1">range: [range[</span><span class="s3">0</span><span class="s1">] + colonIndex + </span><span class="s3">1</span><span class="s1">, range[</span><span class="s3">1</span><span class="s1">]],</span>
                    <span class="s1">name: text.slice(colonIndex + </span><span class="s3">1</span><span class="s1">),</span>
                <span class="s1">}),</span>
                <span class="s1">namespace: </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXIdentifier,</span>
                    <span class="s1">range: [range[</span><span class="s3">0</span><span class="s1">], range[</span><span class="s3">0</span><span class="s1">] + colonIndex],</span>
                    <span class="s1">name: text.slice(</span><span class="s3">0</span><span class="s1">, colonIndex),</span>
                <span class="s1">}),</span>
            <span class="s1">});</span>
            <span class="s2">this</span><span class="s1">.registerTSNodeInNodeMap(node, result);</span>
            <span class="s2">return </span><span class="s1">result;</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.convertJSXIdentifier(node);</span>
    <span class="s1">}</span>
    <span class="s4">/**</span>
     <span class="s4">* Converts a TypeScript JSX node.tagName into an ESTree node.name</span>
     <span class="s4">* </span><span class="s5">@param </span><span class="s4">node the tagName object from a JSX ts.Node</span>
     <span class="s4">* </span><span class="s5">@returns </span><span class="s4">the converted ESTree name object</span>
     <span class="s4">*/</span>
    <span class="s1">convertJSXTagName(node, parent) {</span>
        <span class="s2">let </span><span class="s1">result;</span>
        <span class="s2">switch </span><span class="s1">(node.kind) {</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.PropertyAccessExpression:</span>
                <span class="s2">if </span><span class="s1">(node.name.kind === SyntaxKind.PrivateIdentifier) {</span>
                    <span class="s4">// This is one of the few times where TS explicitly errors, and doesn't even gracefully handle the syntax.</span>
                    <span class="s4">// So we shouldn't ever get into this state to begin with.</span>
                    <span class="s2">this</span><span class="s1">.#throwError(node.name, </span><span class="s0">'Non-private identifier expected.'</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s1">result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXMemberExpression,</span>
                    <span class="s1">object: </span><span class="s2">this</span><span class="s1">.convertJSXTagName(node.expression, parent),</span>
                    <span class="s1">property: </span><span class="s2">this</span><span class="s1">.convertJSXIdentifier(node.name),</span>
                <span class="s1">});</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ThisKeyword:</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.Identifier:</span>
            <span class="s2">default</span><span class="s1">:</span>
                <span class="s2">return this</span><span class="s1">.convertJSXNamespaceOrIdentifier(node);</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.registerTSNodeInNodeMap(node, result);</span>
        <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>
    <span class="s1">convertMethodSignature(node) {</span>
        <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
            <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSMethodSignature,</span>
            <span class="s1">accessibility: (</span><span class="s3">0</span><span class="s1">, node_utils_1.getTSNodeAccessibility)(node),</span>
            <span class="s1">computed: (</span><span class="s3">0</span><span class="s1">, node_utils_1.isComputedProperty)(node.name),</span>
            <span class="s1">key: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
            <span class="s1">kind: (() =&gt; {</span>
                <span class="s2">switch </span><span class="s1">(node.kind) {</span>
                    <span class="s2">case </span><span class="s1">SyntaxKind.GetAccessor:</span>
                        <span class="s2">return </span><span class="s0">'get'</span><span class="s1">;</span>
                    <span class="s2">case </span><span class="s1">SyntaxKind.SetAccessor:</span>
                        <span class="s2">return </span><span class="s0">'set'</span><span class="s1">;</span>
                    <span class="s2">case </span><span class="s1">SyntaxKind.MethodSignature:</span>
                        <span class="s2">return </span><span class="s0">'method'</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">})(),</span>
            <span class="s1">optional: (</span><span class="s3">0</span><span class="s1">, node_utils_1.isOptional)(node),</span>
            <span class="s1">params: </span><span class="s2">this</span><span class="s1">.convertParameters(node.parameters),</span>
            <span class="s1">readonly: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.ReadonlyKeyword, node),</span>
            <span class="s1">returnType: node.type &amp;&amp; </span><span class="s2">this</span><span class="s1">.convertTypeAnnotation(node.type, node),</span>
            <span class="s2">static</span><span class="s1">: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node),</span>
            <span class="s1">typeParameters: node.typeParameters &amp;&amp;</span>
                <span class="s2">this</span><span class="s1">.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters),</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s4">/**</span>
     <span class="s4">* Uses the provided range location to adjust the location data of the given Node</span>
     <span class="s4">* </span><span class="s5">@param </span><span class="s4">result The node that will have its location data mutated</span>
     <span class="s4">* </span><span class="s5">@param </span><span class="s4">childRange The child node range used to expand location</span>
     <span class="s4">*/</span>
    <span class="s1">fixParentLocation(result, childRange) {</span>
        <span class="s2">if </span><span class="s1">(childRange[</span><span class="s3">0</span><span class="s1">] &lt; result.range[</span><span class="s3">0</span><span class="s1">]) {</span>
            <span class="s1">result.range[</span><span class="s3">0</span><span class="s1">] = childRange[</span><span class="s3">0</span><span class="s1">];</span>
            <span class="s1">result.loc.start = (</span><span class="s3">0</span><span class="s1">, node_utils_1.getLineAndCharacterFor)(result.range[</span><span class="s3">0</span><span class="s1">], </span><span class="s2">this</span><span class="s1">.ast);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(childRange[</span><span class="s3">1</span><span class="s1">] &gt; result.range[</span><span class="s3">1</span><span class="s1">]) {</span>
            <span class="s1">result.range[</span><span class="s3">1</span><span class="s1">] = childRange[</span><span class="s3">1</span><span class="s1">];</span>
            <span class="s1">result.loc.end = (</span><span class="s3">0</span><span class="s1">, node_utils_1.getLineAndCharacterFor)(result.range[</span><span class="s3">1</span><span class="s1">], </span><span class="s2">this</span><span class="s1">.ast);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s4">/**</span>
     <span class="s4">* Converts a TypeScript node into an ESTree node.</span>
     <span class="s4">* The core of the conversion logic:</span>
     <span class="s4">* Identify and convert each relevant TypeScript SyntaxKind</span>
     <span class="s4">* </span><span class="s5">@returns </span><span class="s4">the converted ESTree node</span>
     <span class="s4">*/</span>
    <span class="s1">convertNode(node, parent) {</span>
        <span class="s2">switch </span><span class="s1">(node.kind) {</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.SourceFile: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.Program,</span>
                    <span class="s1">range: [node.getStart(</span><span class="s2">this</span><span class="s1">.ast), node.endOfFileToken.end],</span>
                    <span class="s1">body: </span><span class="s2">this</span><span class="s1">.convertBodyExpressions(node.statements, node),</span>
                    <span class="s1">comments: undefined,</span>
                    <span class="s1">sourceType: node.externalModuleIndicator ? </span><span class="s0">'module' </span><span class="s1">: </span><span class="s0">'script'</span><span class="s1">,</span>
                    <span class="s1">tokens: undefined,</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.Block: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.BlockStatement,</span>
                    <span class="s1">body: </span><span class="s2">this</span><span class="s1">.convertBodyExpressions(node.statements, node),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.Identifier: {</span>
                <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, node_utils_1.isThisInTypeQuery)(node)) {</span>
                    <span class="s4">// special case for `typeof this.foo` - TS emits an Identifier for `this`</span>
                    <span class="s4">// but we want to treat it as a ThisExpression for consistency</span>
                    <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ThisExpression,</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.Identifier,</span>
                    <span class="s1">decorators: [],</span>
                    <span class="s1">name: node.text,</span>
                    <span class="s1">optional: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">typeAnnotation: undefined,</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.PrivateIdentifier: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.PrivateIdentifier,</span>
                    <span class="s4">// typescript includes the `#` in the text</span>
                    <span class="s1">name: node.text.slice(</span><span class="s3">1</span><span class="s1">),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.WithStatement:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.WithStatement,</span>
                    <span class="s1">body: </span><span class="s2">this</span><span class="s1">.convertChild(node.statement),</span>
                    <span class="s1">object: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                <span class="s1">});</span>
            <span class="s4">// Control Flow</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ReturnStatement:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ReturnStatement,</span>
                    <span class="s1">argument: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.LabeledStatement:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.LabeledStatement,</span>
                    <span class="s1">body: </span><span class="s2">this</span><span class="s1">.convertChild(node.statement),</span>
                    <span class="s1">label: </span><span class="s2">this</span><span class="s1">.convertChild(node.label),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ContinueStatement:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ContinueStatement,</span>
                    <span class="s1">label: </span><span class="s2">this</span><span class="s1">.convertChild(node.label),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.BreakStatement:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.BreakStatement,</span>
                    <span class="s1">label: </span><span class="s2">this</span><span class="s1">.convertChild(node.label),</span>
                <span class="s1">});</span>
            <span class="s4">// Choice</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.IfStatement:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.IfStatement,</span>
                    <span class="s1">alternate: </span><span class="s2">this</span><span class="s1">.convertChild(node.elseStatement),</span>
                    <span class="s1">consequent: </span><span class="s2">this</span><span class="s1">.convertChild(node.thenStatement),</span>
                    <span class="s1">test: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.SwitchStatement:</span>
                <span class="s2">if </span><span class="s1">(node.caseBlock.clauses.filter(switchCase =&gt; switchCase.kind === SyntaxKind.DefaultClause).length &gt; </span><span class="s3">1</span><span class="s1">) {</span>
                    <span class="s2">this</span><span class="s1">.#throwError(node, </span><span class="s0">&quot;A 'default' clause cannot appear more than once in a 'switch' statement.&quot;</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.SwitchStatement,</span>
                    <span class="s1">cases: </span><span class="s2">this</span><span class="s1">.convertChildren(node.caseBlock.clauses),</span>
                    <span class="s1">discriminant: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.CaseClause:</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.DefaultClause:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.SwitchCase,</span>
                    <span class="s4">// expression is present in case only</span>
                    <span class="s1">consequent: </span><span class="s2">this</span><span class="s1">.convertChildren(node.statements),</span>
                    <span class="s1">test: node.kind === SyntaxKind.CaseClause</span>
                        <span class="s1">? </span><span class="s2">this</span><span class="s1">.convertChild(node.expression)</span>
                        <span class="s1">: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">});</span>
            <span class="s4">// Exceptions</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ThrowStatement:</span>
                <span class="s2">if </span><span class="s1">(node.expression.end === node.expression.pos) {</span>
                    <span class="s2">this</span><span class="s1">.#throwUnlessAllowInvalidAST(node, </span><span class="s0">'A throw statement must throw an expression.'</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ThrowStatement,</span>
                    <span class="s1">argument: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.TryStatement:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TryStatement,</span>
                    <span class="s1">block: </span><span class="s2">this</span><span class="s1">.convertChild(node.tryBlock),</span>
                    <span class="s1">finalizer: </span><span class="s2">this</span><span class="s1">.convertChild(node.finallyBlock),</span>
                    <span class="s1">handler: </span><span class="s2">this</span><span class="s1">.convertChild(node.catchClause),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.CatchClause:</span>
                <span class="s2">if </span><span class="s1">(node.variableDeclaration?.initializer) {</span>
                    <span class="s2">this</span><span class="s1">.#throwError(node.variableDeclaration.initializer, </span><span class="s0">'Catch clause variable cannot have an initializer.'</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.CatchClause,</span>
                    <span class="s1">body: </span><span class="s2">this</span><span class="s1">.convertChild(node.block),</span>
                    <span class="s1">param: node.variableDeclaration</span>
                        <span class="s1">? </span><span class="s2">this</span><span class="s1">.convertBindingNameWithTypeAnnotation(node.variableDeclaration.name, node.variableDeclaration.type)</span>
                        <span class="s1">: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">});</span>
            <span class="s4">// Loops</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.WhileStatement:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.WhileStatement,</span>
                    <span class="s1">body: </span><span class="s2">this</span><span class="s1">.convertChild(node.statement),</span>
                    <span class="s1">test: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                <span class="s1">});</span>
            <span class="s4">/**</span>
             <span class="s4">* Unlike other parsers, TypeScript calls a &quot;DoWhileStatement&quot;</span>
             <span class="s4">* a &quot;DoStatement&quot;</span>
             <span class="s4">*/</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.DoStatement:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.DoWhileStatement,</span>
                    <span class="s1">body: </span><span class="s2">this</span><span class="s1">.convertChild(node.statement),</span>
                    <span class="s1">test: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ForStatement:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ForStatement,</span>
                    <span class="s1">body: </span><span class="s2">this</span><span class="s1">.convertChild(node.statement),</span>
                    <span class="s1">init: </span><span class="s2">this</span><span class="s1">.convertChild(node.initializer),</span>
                    <span class="s1">test: </span><span class="s2">this</span><span class="s1">.convertChild(node.condition),</span>
                    <span class="s1">update: </span><span class="s2">this</span><span class="s1">.convertChild(node.incrementor),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ForInStatement:</span>
                <span class="s2">this</span><span class="s1">.#checkForStatementDeclaration(node.initializer, node.kind);</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ForInStatement,</span>
                    <span class="s1">body: </span><span class="s2">this</span><span class="s1">.convertChild(node.statement),</span>
                    <span class="s1">left: </span><span class="s2">this</span><span class="s1">.convertPattern(node.initializer),</span>
                    <span class="s1">right: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ForOfStatement: {</span>
                <span class="s2">this</span><span class="s1">.#checkForStatementDeclaration(node.initializer, node.kind);</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ForOfStatement,</span>
                    <span class="s2">await</span><span class="s1">: Boolean(node.awaitModifier &amp;&amp;</span>
                        <span class="s1">node.awaitModifier.kind === SyntaxKind.AwaitKeyword),</span>
                    <span class="s1">body: </span><span class="s2">this</span><span class="s1">.convertChild(node.statement),</span>
                    <span class="s1">left: </span><span class="s2">this</span><span class="s1">.convertPattern(node.initializer),</span>
                    <span class="s1">right: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s4">// Declarations</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.FunctionDeclaration: {</span>
                <span class="s2">const </span><span class="s1">isDeclare = (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node);</span>
                <span class="s2">const </span><span class="s1">isAsync = (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.AsyncKeyword, node);</span>
                <span class="s2">const </span><span class="s1">isGenerator = !!node.asteriskToken;</span>
                <span class="s2">if </span><span class="s1">(isDeclare) {</span>
                    <span class="s2">if </span><span class="s1">(node.body) {</span>
                        <span class="s2">this</span><span class="s1">.#throwError(node, </span><span class="s0">'An implementation cannot be declared in ambient contexts.'</span><span class="s1">);</span>
                    <span class="s1">}</span>
                    <span class="s2">else if </span><span class="s1">(isAsync) {</span>
                        <span class="s2">this</span><span class="s1">.#throwError(node, </span><span class="s0">&quot;'async' modifier cannot be used in an ambient context.&quot;</span><span class="s1">);</span>
                    <span class="s1">}</span>
                    <span class="s2">else if </span><span class="s1">(isGenerator) {</span>
                        <span class="s2">this</span><span class="s1">.#throwError(node, </span><span class="s0">'Generators are not allowed in an ambient context.'</span><span class="s1">);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(!node.body &amp;&amp; isGenerator) {</span>
                    <span class="s2">this</span><span class="s1">.#throwError(node, </span><span class="s0">'A function signature cannot be declared as a generator.'</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s4">// declare implies no body due to the invariant above</span>
                    <span class="s1">type: !node.body</span>
                        <span class="s1">? ts_estree_1.AST_NODE_TYPES.TSDeclareFunction</span>
                        <span class="s1">: ts_estree_1.AST_NODE_TYPES.FunctionDeclaration,</span>
                    <span class="s1">async: isAsync,</span>
                    <span class="s1">body: </span><span class="s2">this</span><span class="s1">.convertChild(node.body) || undefined,</span>
                    <span class="s1">declare: isDeclare,</span>
                    <span class="s1">expression: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">generator: isGenerator,</span>
                    <span class="s1">id: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                    <span class="s1">params: </span><span class="s2">this</span><span class="s1">.convertParameters(node.parameters),</span>
                    <span class="s1">returnType: node.type &amp;&amp; </span><span class="s2">this</span><span class="s1">.convertTypeAnnotation(node.type, node),</span>
                    <span class="s1">typeParameters: node.typeParameters &amp;&amp;</span>
                        <span class="s2">this</span><span class="s1">.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters),</span>
                <span class="s1">});</span>
                <span class="s2">return this</span><span class="s1">.fixExports(node, result);</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.VariableDeclaration: {</span>
                <span class="s2">const </span><span class="s1">definite = !!node.exclamationToken;</span>
                <span class="s2">const </span><span class="s1">init = </span><span class="s2">this</span><span class="s1">.convertChild(node.initializer);</span>
                <span class="s2">const </span><span class="s1">id = </span><span class="s2">this</span><span class="s1">.convertBindingNameWithTypeAnnotation(node.name, node.type, node);</span>
                <span class="s2">if </span><span class="s1">(definite) {</span>
                    <span class="s2">if </span><span class="s1">(init) {</span>
                        <span class="s2">this</span><span class="s1">.#throwError(node, </span><span class="s0">'Declarations with initializers cannot also have definite assignment assertions.'</span><span class="s1">);</span>
                    <span class="s1">}</span>
                    <span class="s2">else if </span><span class="s1">(id.type !== ts_estree_1.AST_NODE_TYPES.Identifier ||</span>
                        <span class="s1">!id.typeAnnotation) {</span>
                        <span class="s2">this</span><span class="s1">.#throwError(node, </span><span class="s0">'Declarations with definite assignment assertions must also have type annotations.'</span><span class="s1">);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.VariableDeclarator,</span>
                    <span class="s1">definite,</span>
                    <span class="s1">id,</span>
                    <span class="s1">init,</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.VariableStatement: {</span>
                <span class="s2">const </span><span class="s1">result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.VariableDeclaration,</span>
                    <span class="s1">declarations: </span><span class="s2">this</span><span class="s1">.convertChildren(node.declarationList.declarations),</span>
                    <span class="s1">declare: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node),</span>
                    <span class="s1">kind: (</span><span class="s3">0</span><span class="s1">, node_utils_1.getDeclarationKind)(node.declarationList),</span>
                <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">(!result.declarations.length) {</span>
                    <span class="s2">this</span><span class="s1">.#throwUnlessAllowInvalidAST(node, </span><span class="s0">'A variable declaration list must have at least one variable declarator.'</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(result.kind === </span><span class="s0">'using' </span><span class="s1">|| result.kind === </span><span class="s0">'await using'</span><span class="s1">) {</span>
                    <span class="s1">node.declarationList.declarations.forEach((declaration, i) =&gt; {</span>
                        <span class="s2">if </span><span class="s1">(result.declarations[i].init == </span><span class="s2">null</span><span class="s1">) {</span>
                            <span class="s2">this</span><span class="s1">.#throwError(declaration, </span><span class="s0">`'</span><span class="s1">${result.kind}</span><span class="s0">' declarations must be initialized.`</span><span class="s1">);</span>
                        <span class="s1">}</span>
                        <span class="s2">if </span><span class="s1">(result.declarations[i].id.type !== ts_estree_1.AST_NODE_TYPES.Identifier) {</span>
                            <span class="s2">this</span><span class="s1">.#throwError(declaration.name, </span><span class="s0">`'</span><span class="s1">${result.kind}</span><span class="s0">' declarations may not have binding patterns.`</span><span class="s1">);</span>
                        <span class="s1">}</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s4">// Definite assignment only allowed for non-declare let and var</span>
                <span class="s2">if </span><span class="s1">(result.declare ||</span>
                    <span class="s1">[</span><span class="s0">'await using'</span><span class="s1">, </span><span class="s0">'const'</span><span class="s1">, </span><span class="s0">'using'</span><span class="s1">].includes(result.kind)) {</span>
                    <span class="s1">node.declarationList.declarations.forEach((declaration, i) =&gt; {</span>
                        <span class="s2">if </span><span class="s1">(result.declarations[i].definite) {</span>
                            <span class="s2">this</span><span class="s1">.#throwError(declaration, </span><span class="s0">`A definite assignment assertion '!' is not permitted in this context.`</span><span class="s1">);</span>
                        <span class="s1">}</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(result.declare) {</span>
                    <span class="s1">node.declarationList.declarations.forEach((declaration, i) =&gt; {</span>
                        <span class="s2">if </span><span class="s1">(result.declarations[i].init &amp;&amp;</span>
                            <span class="s1">([</span><span class="s0">'let'</span><span class="s1">, </span><span class="s0">'var'</span><span class="s1">].includes(result.kind) ||</span>
                                <span class="s1">result.declarations[i].id.typeAnnotation)) {</span>
                            <span class="s2">this</span><span class="s1">.#throwError(declaration, </span><span class="s0">`Initializers are not permitted in ambient contexts.`</span><span class="s1">);</span>
                        <span class="s1">}</span>
                    <span class="s1">});</span>
                    <span class="s4">// Theoretically, only certain initializers are allowed for declare const,</span>
                    <span class="s4">// (TS1254: A 'const' initializer in an ambient context must be a string</span>
                    <span class="s4">// or numeric literal or literal enum reference.) but we just allow</span>
                    <span class="s4">// all expressions</span>
                <span class="s1">}</span>
                <span class="s4">// Note! No-declare does not mean the variable is not ambient, because</span>
                <span class="s4">// it can be further nested in other declare contexts. Therefore we cannot</span>
                <span class="s4">// check for const initializers.</span>
                <span class="s4">/**</span>
                 <span class="s4">* Semantically, decorators are not allowed on variable declarations,</span>
                 <span class="s4">* Pre 4.8 TS would include them in the AST, so we did as well.</span>
                 <span class="s4">* However as of 4.8 TS no longer includes it (as it is, well, invalid).</span>
                 <span class="s4">*</span>
                 <span class="s4">* So for consistency across versions, we no longer include it either.</span>
                 <span class="s4">*/</span>
                <span class="s2">return this</span><span class="s1">.fixExports(node, result);</span>
            <span class="s1">}</span>
            <span class="s4">// mostly for for-of, for-in</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.VariableDeclarationList: {</span>
                <span class="s2">const </span><span class="s1">result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.VariableDeclaration,</span>
                    <span class="s1">declarations: </span><span class="s2">this</span><span class="s1">.convertChildren(node.declarations),</span>
                    <span class="s1">declare: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">kind: (</span><span class="s3">0</span><span class="s1">, node_utils_1.getDeclarationKind)(node),</span>
                <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">(result.kind === </span><span class="s0">'using' </span><span class="s1">|| result.kind === </span><span class="s0">'await using'</span><span class="s1">) {</span>
                    <span class="s1">node.declarations.forEach((declaration, i) =&gt; {</span>
                        <span class="s2">if </span><span class="s1">(result.declarations[i].init != </span><span class="s2">null</span><span class="s1">) {</span>
                            <span class="s2">this</span><span class="s1">.#throwError(declaration, </span><span class="s0">`'</span><span class="s1">${result.kind}</span><span class="s0">' declarations may not be initialized in for statement.`</span><span class="s1">);</span>
                        <span class="s1">}</span>
                        <span class="s2">if </span><span class="s1">(result.declarations[i].id.type !== ts_estree_1.AST_NODE_TYPES.Identifier) {</span>
                            <span class="s2">this</span><span class="s1">.#throwError(declaration.name, </span><span class="s0">`'</span><span class="s1">${result.kind}</span><span class="s0">' declarations may not have binding patterns.`</span><span class="s1">);</span>
                        <span class="s1">}</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">result;</span>
            <span class="s1">}</span>
            <span class="s4">// Expressions</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ExpressionStatement:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ExpressionStatement,</span>
                    <span class="s1">directive: undefined,</span>
                    <span class="s1">expression: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ThisKeyword:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ThisExpression,</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ArrayLiteralExpression: {</span>
                <span class="s4">// TypeScript uses ArrayLiteralExpression in destructuring assignment, too</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.allowPattern) {</span>
                    <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ArrayPattern,</span>
                        <span class="s1">decorators: [],</span>
                        <span class="s1">elements: node.elements.map(el =&gt; </span><span class="s2">this</span><span class="s1">.convertPattern(el)),</span>
                        <span class="s1">optional: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">typeAnnotation: undefined,</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ArrayExpression,</span>
                    <span class="s1">elements: </span><span class="s2">this</span><span class="s1">.convertChildren(node.elements),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ObjectLiteralExpression: {</span>
                <span class="s4">// TypeScript uses ObjectLiteralExpression in destructuring assignment, too</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.allowPattern) {</span>
                    <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ObjectPattern,</span>
                        <span class="s1">decorators: [],</span>
                        <span class="s1">optional: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">properties: node.properties.map(el =&gt; </span><span class="s2">this</span><span class="s1">.convertPattern(el)),</span>
                        <span class="s1">typeAnnotation: undefined,</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">properties = [];</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">property of node.properties) {</span>
                    <span class="s2">if </span><span class="s1">((property.kind === SyntaxKind.GetAccessor ||</span>
                        <span class="s1">property.kind === SyntaxKind.SetAccessor ||</span>
                        <span class="s1">property.kind === SyntaxKind.MethodDeclaration) &amp;&amp;</span>
                        <span class="s1">!property.body) {</span>
                        <span class="s2">this</span><span class="s1">.#throwUnlessAllowInvalidAST(property.end - </span><span class="s3">1</span><span class="s1">, </span><span class="s0">&quot;'{' expected.&quot;</span><span class="s1">);</span>
                    <span class="s1">}</span>
                    <span class="s1">properties.push(</span><span class="s2">this</span><span class="s1">.convertChild(property));</span>
                <span class="s1">}</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ObjectExpression,</span>
                    <span class="s1">properties,</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.PropertyAssignment: {</span>
                <span class="s4">// eslint-disable-next-line @typescript-eslint/no-deprecated</span>
                <span class="s2">const </span><span class="s1">{ exclamationToken, questionToken } = node;</span>
                <span class="s2">if </span><span class="s1">(questionToken) {</span>
                    <span class="s2">this</span><span class="s1">.#throwError(questionToken, </span><span class="s0">'A property assignment cannot have a question token.'</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(exclamationToken) {</span>
                    <span class="s2">this</span><span class="s1">.#throwError(exclamationToken, </span><span class="s0">'A property assignment cannot have an exclamation token.'</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.Property,</span>
                    <span class="s1">computed: (</span><span class="s3">0</span><span class="s1">, node_utils_1.isComputedProperty)(node.name),</span>
                    <span class="s1">key: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                    <span class="s1">kind: </span><span class="s0">'init'</span><span class="s1">,</span>
                    <span class="s1">method: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">optional: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">shorthand: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">value: </span><span class="s2">this</span><span class="s1">.converter(node.initializer, node, </span><span class="s2">this</span><span class="s1">.allowPattern),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ShorthandPropertyAssignment: {</span>
                <span class="s4">// eslint-disable-next-line @typescript-eslint/no-deprecated</span>
                <span class="s2">const </span><span class="s1">{ exclamationToken, modifiers, questionToken } = node;</span>
                <span class="s2">if </span><span class="s1">(modifiers) {</span>
                    <span class="s2">this</span><span class="s1">.#throwError(modifiers[</span><span class="s3">0</span><span class="s1">], </span><span class="s0">'A shorthand property assignment cannot have modifiers.'</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(questionToken) {</span>
                    <span class="s2">this</span><span class="s1">.#throwError(questionToken, </span><span class="s0">'A shorthand property assignment cannot have a question token.'</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(exclamationToken) {</span>
                    <span class="s2">this</span><span class="s1">.#throwError(exclamationToken, </span><span class="s0">'A shorthand property assignment cannot have an exclamation token.'</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(node.objectAssignmentInitializer) {</span>
                    <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.Property,</span>
                        <span class="s1">computed: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">key: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                        <span class="s1">kind: </span><span class="s0">'init'</span><span class="s1">,</span>
                        <span class="s1">method: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">optional: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">shorthand: </span><span class="s2">true</span><span class="s1">,</span>
                        <span class="s1">value: </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                            <span class="s1">type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,</span>
                            <span class="s1">decorators: [],</span>
                            <span class="s1">left: </span><span class="s2">this</span><span class="s1">.convertPattern(node.name),</span>
                            <span class="s1">optional: </span><span class="s2">false</span><span class="s1">,</span>
                            <span class="s1">right: </span><span class="s2">this</span><span class="s1">.convertChild(node.objectAssignmentInitializer),</span>
                            <span class="s1">typeAnnotation: undefined,</span>
                        <span class="s1">}),</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.Property,</span>
                    <span class="s1">computed: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">key: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                    <span class="s1">kind: </span><span class="s0">'init'</span><span class="s1">,</span>
                    <span class="s1">method: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">optional: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">shorthand: </span><span class="s2">true</span><span class="s1">,</span>
                    <span class="s1">value: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ComputedPropertyName:</span>
                <span class="s2">return this</span><span class="s1">.convertChild(node.expression);</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.PropertyDeclaration: {</span>
                <span class="s2">const </span><span class="s1">isAbstract = (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.AbstractKeyword, node);</span>
                <span class="s2">if </span><span class="s1">(isAbstract &amp;&amp; node.initializer) {</span>
                    <span class="s2">this</span><span class="s1">.#throwError(node.initializer, </span><span class="s0">`Abstract property cannot have an initializer.`</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(node.name.kind === SyntaxKind.StringLiteral &amp;&amp;</span>
                    <span class="s1">node.name.text === </span><span class="s0">'constructor'</span><span class="s1">) {</span>
                    <span class="s2">this</span><span class="s1">.#throwError(node.name, </span><span class="s0">&quot;Classes may not have a field named 'constructor'.&quot;</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">isAccessor = (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.AccessorKeyword, node);</span>
                <span class="s2">const </span><span class="s1">type = (() =&gt; {</span>
                    <span class="s2">if </span><span class="s1">(isAccessor) {</span>
                        <span class="s2">if </span><span class="s1">(isAbstract) {</span>
                            <span class="s2">return </span><span class="s1">ts_estree_1.AST_NODE_TYPES.TSAbstractAccessorProperty;</span>
                        <span class="s1">}</span>
                        <span class="s2">return </span><span class="s1">ts_estree_1.AST_NODE_TYPES.AccessorProperty;</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(isAbstract) {</span>
                        <span class="s2">return </span><span class="s1">ts_estree_1.AST_NODE_TYPES.TSAbstractPropertyDefinition;</span>
                    <span class="s1">}</span>
                    <span class="s2">return </span><span class="s1">ts_estree_1.AST_NODE_TYPES.PropertyDefinition;</span>
                <span class="s1">})();</span>
                <span class="s2">const </span><span class="s1">key = </span><span class="s2">this</span><span class="s1">.convertChild(node.name);</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type,</span>
                    <span class="s1">accessibility: (</span><span class="s3">0</span><span class="s1">, node_utils_1.getTSNodeAccessibility)(node),</span>
                    <span class="s1">computed: (</span><span class="s3">0</span><span class="s1">, node_utils_1.isComputedProperty)(node.name),</span>
                    <span class="s1">declare: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node),</span>
                    <span class="s1">decorators: </span><span class="s2">this</span><span class="s1">.convertChildren((</span><span class="s3">0</span><span class="s1">, getModifiers_1.getDecorators)(node) ?? []),</span>
                    <span class="s1">definite: !!node.exclamationToken,</span>
                    <span class="s1">key,</span>
                    <span class="s1">optional: (key.type === ts_estree_1.AST_NODE_TYPES.Literal ||</span>
                        <span class="s1">node.name.kind === SyntaxKind.Identifier ||</span>
                        <span class="s1">node.name.kind === SyntaxKind.ComputedPropertyName ||</span>
                        <span class="s1">node.name.kind === SyntaxKind.PrivateIdentifier) &amp;&amp;</span>
                        <span class="s1">!!node.questionToken,</span>
                    <span class="s1">override: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.OverrideKeyword, node),</span>
                    <span class="s1">readonly: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.ReadonlyKeyword, node),</span>
                    <span class="s2">static</span><span class="s1">: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node),</span>
                    <span class="s1">typeAnnotation: node.type &amp;&amp; </span><span class="s2">this</span><span class="s1">.convertTypeAnnotation(node.type, node),</span>
                    <span class="s1">value: isAbstract ? </span><span class="s2">null </span><span class="s1">: </span><span class="s2">this</span><span class="s1">.convertChild(node.initializer),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.GetAccessor:</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.SetAccessor: {</span>
                <span class="s2">if </span><span class="s1">(node.parent.kind === SyntaxKind.InterfaceDeclaration ||</span>
                    <span class="s1">node.parent.kind === SyntaxKind.TypeLiteral) {</span>
                    <span class="s2">return this</span><span class="s1">.convertMethodSignature(node);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s4">// otherwise, it is a non-type accessor - intentional fallthrough</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.MethodDeclaration: {</span>
                <span class="s2">const </span><span class="s1">method = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: !node.body</span>
                        <span class="s1">? ts_estree_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression</span>
                        <span class="s1">: ts_estree_1.AST_NODE_TYPES.FunctionExpression,</span>
                    <span class="s1">range: [node.parameters.pos - </span><span class="s3">1</span><span class="s1">, node.end],</span>
                    <span class="s1">async: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.AsyncKeyword, node),</span>
                    <span class="s1">body: </span><span class="s2">this</span><span class="s1">.convertChild(node.body),</span>
                    <span class="s1">declare: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">expression: </span><span class="s2">false</span><span class="s1">, </span><span class="s4">// ESTreeNode as ESTreeNode here</span>
                    <span class="s1">generator: !!node.asteriskToken,</span>
                    <span class="s1">id: </span><span class="s2">null</span><span class="s1">,</span>
                    <span class="s1">params: [],</span>
                    <span class="s1">returnType: node.type &amp;&amp; </span><span class="s2">this</span><span class="s1">.convertTypeAnnotation(node.type, node),</span>
                    <span class="s1">typeParameters: node.typeParameters &amp;&amp;</span>
                        <span class="s2">this</span><span class="s1">.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters),</span>
                <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">(method.typeParameters) {</span>
                    <span class="s2">this</span><span class="s1">.fixParentLocation(method, method.typeParameters.range);</span>
                <span class="s1">}</span>
                <span class="s2">let </span><span class="s1">result;</span>
                <span class="s2">if </span><span class="s1">(parent.kind === SyntaxKind.ObjectLiteralExpression) {</span>
                    <span class="s1">method.params = </span><span class="s2">this</span><span class="s1">.convertChildren(node.parameters);</span>
                    <span class="s1">result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.Property,</span>
                        <span class="s1">computed: (</span><span class="s3">0</span><span class="s1">, node_utils_1.isComputedProperty)(node.name),</span>
                        <span class="s1">key: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                        <span class="s1">kind: </span><span class="s0">'init'</span><span class="s1">,</span>
                        <span class="s1">method: node.kind === SyntaxKind.MethodDeclaration,</span>
                        <span class="s1">optional: !!node.questionToken,</span>
                        <span class="s1">shorthand: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">value: method,</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s4">// class</span>
                    <span class="s4">/**</span>
                     <span class="s4">* Unlike in object literal methods, class method params can have decorators</span>
                     <span class="s4">*/</span>
                    <span class="s1">method.params = </span><span class="s2">this</span><span class="s1">.convertParameters(node.parameters);</span>
                    <span class="s4">/**</span>
                     <span class="s4">* TypeScript class methods can be defined as &quot;abstract&quot;</span>
                     <span class="s4">*/</span>
                    <span class="s2">const </span><span class="s1">methodDefinitionType = (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.AbstractKeyword, node)</span>
                        <span class="s1">? ts_estree_1.AST_NODE_TYPES.TSAbstractMethodDefinition</span>
                        <span class="s1">: ts_estree_1.AST_NODE_TYPES.MethodDefinition;</span>
                    <span class="s1">result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: methodDefinitionType,</span>
                        <span class="s1">accessibility: (</span><span class="s3">0</span><span class="s1">, node_utils_1.getTSNodeAccessibility)(node),</span>
                        <span class="s1">computed: (</span><span class="s3">0</span><span class="s1">, node_utils_1.isComputedProperty)(node.name),</span>
                        <span class="s1">decorators: </span><span class="s2">this</span><span class="s1">.convertChildren((</span><span class="s3">0</span><span class="s1">, getModifiers_1.getDecorators)(node) ?? []),</span>
                        <span class="s1">key: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                        <span class="s1">kind: </span><span class="s0">'method'</span><span class="s1">,</span>
                        <span class="s1">optional: !!node.questionToken,</span>
                        <span class="s1">override: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.OverrideKeyword, node),</span>
                        <span class="s2">static</span><span class="s1">: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node),</span>
                        <span class="s1">value: method,</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(node.kind === SyntaxKind.GetAccessor) {</span>
                    <span class="s1">result.kind = </span><span class="s0">'get'</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(node.kind === SyntaxKind.SetAccessor) {</span>
                    <span class="s1">result.kind = </span><span class="s0">'set'</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(!result.static &amp;&amp;</span>
                    <span class="s1">node.name.kind === SyntaxKind.StringLiteral &amp;&amp;</span>
                    <span class="s1">node.name.text === </span><span class="s0">'constructor' </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">result.type !== ts_estree_1.AST_NODE_TYPES.Property) {</span>
                    <span class="s1">result.kind = </span><span class="s0">'constructor'</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">result;</span>
            <span class="s1">}</span>
            <span class="s4">// TypeScript uses this even for static methods named &quot;constructor&quot;</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.Constructor: {</span>
                <span class="s2">const </span><span class="s1">lastModifier = (</span><span class="s3">0</span><span class="s1">, node_utils_1.getLastModifier)(node);</span>
                <span class="s2">const </span><span class="s1">constructorToken = (lastModifier &amp;&amp; (</span><span class="s3">0</span><span class="s1">, node_utils_1.findNextToken)(lastModifier, node, </span><span class="s2">this</span><span class="s1">.ast)) ??</span>
                    <span class="s1">node.getFirstToken();</span>
                <span class="s2">const </span><span class="s1">constructor = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: !node.body</span>
                        <span class="s1">? ts_estree_1.AST_NODE_TYPES.TSEmptyBodyFunctionExpression</span>
                        <span class="s1">: ts_estree_1.AST_NODE_TYPES.FunctionExpression,</span>
                    <span class="s1">range: [node.parameters.pos - </span><span class="s3">1</span><span class="s1">, node.end],</span>
                    <span class="s1">async: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">body: </span><span class="s2">this</span><span class="s1">.convertChild(node.body),</span>
                    <span class="s1">declare: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">expression: </span><span class="s2">false</span><span class="s1">, </span><span class="s4">// is not present in ESTreeNode</span>
                    <span class="s1">generator: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">id: </span><span class="s2">null</span><span class="s1">,</span>
                    <span class="s1">params: </span><span class="s2">this</span><span class="s1">.convertParameters(node.parameters),</span>
                    <span class="s1">returnType: node.type &amp;&amp; </span><span class="s2">this</span><span class="s1">.convertTypeAnnotation(node.type, node),</span>
                    <span class="s1">typeParameters: node.typeParameters &amp;&amp;</span>
                        <span class="s2">this</span><span class="s1">.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters),</span>
                <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">(constructor.typeParameters) {</span>
                    <span class="s2">this</span><span class="s1">.fixParentLocation(constructor, constructor.typeParameters.range);</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">constructorKey = constructorToken.kind === SyntaxKind.StringLiteral</span>
                    <span class="s1">? </span><span class="s2">this</span><span class="s1">.createNode(constructorToken, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.Literal,</span>
                        <span class="s1">raw: constructorToken.getText(),</span>
                        <span class="s1">value: </span><span class="s0">'constructor'</span><span class="s1">,</span>
                    <span class="s1">})</span>
                    <span class="s1">: </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.Identifier,</span>
                        <span class="s1">range: [</span>
                            <span class="s1">constructorToken.getStart(</span><span class="s2">this</span><span class="s1">.ast),</span>
                            <span class="s1">constructorToken.end,</span>
                        <span class="s1">],</span>
                        <span class="s1">decorators: [],</span>
                        <span class="s1">name: </span><span class="s0">'constructor'</span><span class="s1">,</span>
                        <span class="s1">optional: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">typeAnnotation: undefined,</span>
                    <span class="s1">});</span>
                <span class="s2">const </span><span class="s1">isStatic = (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node);</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.AbstractKeyword, node)</span>
                        <span class="s1">? ts_estree_1.AST_NODE_TYPES.TSAbstractMethodDefinition</span>
                        <span class="s1">: ts_estree_1.AST_NODE_TYPES.MethodDefinition,</span>
                    <span class="s1">accessibility: (</span><span class="s3">0</span><span class="s1">, node_utils_1.getTSNodeAccessibility)(node),</span>
                    <span class="s1">computed: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">decorators: [],</span>
                    <span class="s1">key: constructorKey,</span>
                    <span class="s1">kind: isStatic ? </span><span class="s0">'method' </span><span class="s1">: </span><span class="s0">'constructor'</span><span class="s1">,</span>
                    <span class="s1">optional: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">override: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s2">static</span><span class="s1">: isStatic,</span>
                    <span class="s1">value: constructor,</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.FunctionExpression: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.FunctionExpression,</span>
                    <span class="s1">async: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.AsyncKeyword, node),</span>
                    <span class="s1">body: </span><span class="s2">this</span><span class="s1">.convertChild(node.body),</span>
                    <span class="s1">declare: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">expression: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">generator: !!node.asteriskToken,</span>
                    <span class="s1">id: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                    <span class="s1">params: </span><span class="s2">this</span><span class="s1">.convertParameters(node.parameters),</span>
                    <span class="s1">returnType: node.type &amp;&amp; </span><span class="s2">this</span><span class="s1">.convertTypeAnnotation(node.type, node),</span>
                    <span class="s1">typeParameters: node.typeParameters &amp;&amp;</span>
                        <span class="s2">this</span><span class="s1">.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.SuperKeyword:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.Super,</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ArrayBindingPattern:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ArrayPattern,</span>
                    <span class="s1">decorators: [],</span>
                    <span class="s1">elements: node.elements.map(el =&gt; </span><span class="s2">this</span><span class="s1">.convertPattern(el)),</span>
                    <span class="s1">optional: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">typeAnnotation: undefined,</span>
                <span class="s1">});</span>
            <span class="s4">// occurs with missing array elements like [,]</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.OmittedExpression:</span>
                <span class="s2">return null</span><span class="s1">;</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ObjectBindingPattern:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ObjectPattern,</span>
                    <span class="s1">decorators: [],</span>
                    <span class="s1">optional: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">properties: node.elements.map(el =&gt; </span><span class="s2">this</span><span class="s1">.convertPattern(el)),</span>
                    <span class="s1">typeAnnotation: undefined,</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.BindingElement: {</span>
                <span class="s2">if </span><span class="s1">(parent.kind === SyntaxKind.ArrayBindingPattern) {</span>
                    <span class="s2">const </span><span class="s1">arrayItem = </span><span class="s2">this</span><span class="s1">.convertChild(node.name, parent);</span>
                    <span class="s2">if </span><span class="s1">(node.initializer) {</span>
                        <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                            <span class="s1">type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,</span>
                            <span class="s1">decorators: [],</span>
                            <span class="s1">left: arrayItem,</span>
                            <span class="s1">optional: </span><span class="s2">false</span><span class="s1">,</span>
                            <span class="s1">right: </span><span class="s2">this</span><span class="s1">.convertChild(node.initializer),</span>
                            <span class="s1">typeAnnotation: undefined,</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(node.dotDotDotToken) {</span>
                        <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                            <span class="s1">type: ts_estree_1.AST_NODE_TYPES.RestElement,</span>
                            <span class="s1">argument: arrayItem,</span>
                            <span class="s1">decorators: [],</span>
                            <span class="s1">optional: </span><span class="s2">false</span><span class="s1">,</span>
                            <span class="s1">typeAnnotation: undefined,</span>
                            <span class="s1">value: undefined,</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s2">return </span><span class="s1">arrayItem;</span>
                <span class="s1">}</span>
                <span class="s2">let </span><span class="s1">result;</span>
                <span class="s2">if </span><span class="s1">(node.dotDotDotToken) {</span>
                    <span class="s1">result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.RestElement,</span>
                        <span class="s1">argument: </span><span class="s2">this</span><span class="s1">.convertChild(node.propertyName ?? node.name),</span>
                        <span class="s1">decorators: [],</span>
                        <span class="s1">optional: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">typeAnnotation: undefined,</span>
                        <span class="s1">value: undefined,</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.Property,</span>
                        <span class="s1">computed: Boolean(node.propertyName &amp;&amp;</span>
                            <span class="s1">node.propertyName.kind === SyntaxKind.ComputedPropertyName),</span>
                        <span class="s1">key: </span><span class="s2">this</span><span class="s1">.convertChild(node.propertyName ?? node.name),</span>
                        <span class="s1">kind: </span><span class="s0">'init'</span><span class="s1">,</span>
                        <span class="s1">method: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">optional: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">shorthand: !node.propertyName,</span>
                        <span class="s1">value: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(node.initializer) {</span>
                    <span class="s1">result.value = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,</span>
                        <span class="s1">range: [node.name.getStart(</span><span class="s2">this</span><span class="s1">.ast), node.initializer.end],</span>
                        <span class="s1">decorators: [],</span>
                        <span class="s1">left: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                        <span class="s1">optional: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">right: </span><span class="s2">this</span><span class="s1">.convertChild(node.initializer),</span>
                        <span class="s1">typeAnnotation: undefined,</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">result;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ArrowFunction: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ArrowFunctionExpression,</span>
                    <span class="s1">async: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.AsyncKeyword, node),</span>
                    <span class="s1">body: </span><span class="s2">this</span><span class="s1">.convertChild(node.body),</span>
                    <span class="s1">expression: node.body.kind !== SyntaxKind.Block,</span>
                    <span class="s1">generator: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">id: </span><span class="s2">null</span><span class="s1">,</span>
                    <span class="s1">params: </span><span class="s2">this</span><span class="s1">.convertParameters(node.parameters),</span>
                    <span class="s1">returnType: node.type &amp;&amp; </span><span class="s2">this</span><span class="s1">.convertTypeAnnotation(node.type, node),</span>
                    <span class="s1">typeParameters: node.typeParameters &amp;&amp;</span>
                        <span class="s2">this</span><span class="s1">.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.YieldExpression:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.YieldExpression,</span>
                    <span class="s1">argument: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                    <span class="s1">delegate: !!node.asteriskToken,</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.AwaitExpression:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.AwaitExpression,</span>
                    <span class="s1">argument: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                <span class="s1">});</span>
            <span class="s4">// Template Literals</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.NoSubstitutionTemplateLiteral:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TemplateLiteral,</span>
                    <span class="s1">expressions: [],</span>
                    <span class="s1">quasis: [</span>
                        <span class="s2">this</span><span class="s1">.createNode(node, {</span>
                            <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TemplateElement,</span>
                            <span class="s1">tail: </span><span class="s2">true</span><span class="s1">,</span>
                            <span class="s1">value: {</span>
                                <span class="s1">cooked: node.text,</span>
                                <span class="s1">raw: </span><span class="s2">this</span><span class="s1">.ast.text.slice(node.getStart(</span><span class="s2">this</span><span class="s1">.ast) + </span><span class="s3">1</span><span class="s1">, node.end - </span><span class="s3">1</span><span class="s1">),</span>
                            <span class="s1">},</span>
                        <span class="s1">}),</span>
                    <span class="s1">],</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.TemplateExpression: {</span>
                <span class="s2">const </span><span class="s1">result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TemplateLiteral,</span>
                    <span class="s1">expressions: [],</span>
                    <span class="s1">quasis: [</span><span class="s2">this</span><span class="s1">.convertChild(node.head)],</span>
                <span class="s1">});</span>
                <span class="s1">node.templateSpans.forEach(templateSpan =&gt; {</span>
                    <span class="s1">result.expressions.push(</span><span class="s2">this</span><span class="s1">.convertChild(templateSpan.expression));</span>
                    <span class="s1">result.quasis.push(</span><span class="s2">this</span><span class="s1">.convertChild(templateSpan.literal));</span>
                <span class="s1">});</span>
                <span class="s2">return </span><span class="s1">result;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.TaggedTemplateExpression: {</span>
                <span class="s2">if </span><span class="s1">(node.tag.flags &amp; ts.NodeFlags.OptionalChain) {</span>
                    <span class="s2">this</span><span class="s1">.#throwError(node, </span><span class="s0">'Tagged template expressions are not permitted in an optional chain.'</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TaggedTemplateExpression,</span>
                    <span class="s1">quasi: </span><span class="s2">this</span><span class="s1">.convertChild(node.template),</span>
                    <span class="s1">tag: </span><span class="s2">this</span><span class="s1">.convertChild(node.tag),</span>
                    <span class="s1">typeArguments: node.typeArguments &amp;&amp;</span>
                        <span class="s2">this</span><span class="s1">.convertTypeArgumentsToTypeParameterInstantiation(node.typeArguments, node),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.TemplateHead:</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.TemplateMiddle:</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.TemplateTail: {</span>
                <span class="s2">const </span><span class="s1">tail = node.kind === SyntaxKind.TemplateTail;</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TemplateElement,</span>
                    <span class="s1">tail,</span>
                    <span class="s1">value: {</span>
                        <span class="s1">cooked: node.text,</span>
                        <span class="s1">raw: </span><span class="s2">this</span><span class="s1">.ast.text.slice(node.getStart(</span><span class="s2">this</span><span class="s1">.ast) + </span><span class="s3">1</span><span class="s1">, node.end - (tail ? </span><span class="s3">1 </span><span class="s1">: </span><span class="s3">2</span><span class="s1">)),</span>
                    <span class="s1">},</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s4">// Patterns</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.SpreadAssignment:</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.SpreadElement: {</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.allowPattern) {</span>
                    <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.RestElement,</span>
                        <span class="s1">argument: </span><span class="s2">this</span><span class="s1">.convertPattern(node.expression),</span>
                        <span class="s1">decorators: [],</span>
                        <span class="s1">optional: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">typeAnnotation: undefined,</span>
                        <span class="s1">value: undefined,</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.SpreadElement,</span>
                    <span class="s1">argument: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.Parameter: {</span>
                <span class="s2">let </span><span class="s1">parameter;</span>
                <span class="s2">let </span><span class="s1">result;</span>
                <span class="s2">if </span><span class="s1">(node.dotDotDotToken) {</span>
                    <span class="s1">parameter = result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.RestElement,</span>
                        <span class="s1">argument: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                        <span class="s1">decorators: [],</span>
                        <span class="s1">optional: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">typeAnnotation: undefined,</span>
                        <span class="s1">value: undefined,</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(node.initializer) {</span>
                    <span class="s1">parameter = </span><span class="s2">this</span><span class="s1">.convertChild(node.name);</span>
                    <span class="s1">result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,</span>
                        <span class="s1">range: [node.name.getStart(</span><span class="s2">this</span><span class="s1">.ast), node.initializer.end],</span>
                        <span class="s1">decorators: [],</span>
                        <span class="s1">left: parameter,</span>
                        <span class="s1">optional: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">right: </span><span class="s2">this</span><span class="s1">.convertChild(node.initializer),</span>
                        <span class="s1">typeAnnotation: undefined,</span>
                    <span class="s1">});</span>
                    <span class="s2">const </span><span class="s1">modifiers = (</span><span class="s3">0</span><span class="s1">, getModifiers_1.getModifiers)(node);</span>
                    <span class="s2">if </span><span class="s1">(modifiers) {</span>
                        <span class="s4">// AssignmentPattern should not contain modifiers in range</span>
                        <span class="s1">result.range[</span><span class="s3">0</span><span class="s1">] = parameter.range[</span><span class="s3">0</span><span class="s1">];</span>
                        <span class="s1">result.loc = (</span><span class="s3">0</span><span class="s1">, node_utils_1.getLocFor)(result.range, </span><span class="s2">this</span><span class="s1">.ast);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">parameter = result = </span><span class="s2">this</span><span class="s1">.convertChild(node.name, parent);</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(node.type) {</span>
                    <span class="s1">parameter.typeAnnotation = </span><span class="s2">this</span><span class="s1">.convertTypeAnnotation(node.type, node);</span>
                    <span class="s2">this</span><span class="s1">.fixParentLocation(parameter, parameter.typeAnnotation.range);</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(node.questionToken) {</span>
                    <span class="s2">if </span><span class="s1">(node.questionToken.end &gt; parameter.range[</span><span class="s3">1</span><span class="s1">]) {</span>
                        <span class="s1">parameter.range[</span><span class="s3">1</span><span class="s1">] = node.questionToken.end;</span>
                        <span class="s1">parameter.loc.end = (</span><span class="s3">0</span><span class="s1">, node_utils_1.getLineAndCharacterFor)(parameter.range[</span><span class="s3">1</span><span class="s1">], </span><span class="s2">this</span><span class="s1">.ast);</span>
                    <span class="s1">}</span>
                    <span class="s1">parameter.optional = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">modifiers = (</span><span class="s3">0</span><span class="s1">, getModifiers_1.getModifiers)(node);</span>
                <span class="s2">if </span><span class="s1">(modifiers) {</span>
                    <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSParameterProperty,</span>
                        <span class="s1">accessibility: (</span><span class="s3">0</span><span class="s1">, node_utils_1.getTSNodeAccessibility)(node),</span>
                        <span class="s1">decorators: [],</span>
                        <span class="s1">override: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.OverrideKeyword, node),</span>
                        <span class="s1">parameter: result,</span>
                        <span class="s1">readonly: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.ReadonlyKeyword, node),</span>
                        <span class="s2">static</span><span class="s1">: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node),</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">result;</span>
            <span class="s1">}</span>
            <span class="s4">// Classes</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ClassDeclaration:</span>
                <span class="s2">if </span><span class="s1">(!node.name &amp;&amp;</span>
                    <span class="s1">(!(</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(ts.SyntaxKind.ExportKeyword, node) ||</span>
                        <span class="s1">!(</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(ts.SyntaxKind.DefaultKeyword, node))) {</span>
                    <span class="s2">this</span><span class="s1">.#throwUnlessAllowInvalidAST(node, </span><span class="s0">&quot;A class declaration without the 'default' modifier must have a name.&quot;</span><span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s4">/* intentional fallthrough */</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ClassExpression: {</span>
                <span class="s2">const </span><span class="s1">heritageClauses = node.heritageClauses ?? [];</span>
                <span class="s2">const </span><span class="s1">classNodeType = node.kind === SyntaxKind.ClassDeclaration</span>
                    <span class="s1">? ts_estree_1.AST_NODE_TYPES.ClassDeclaration</span>
                    <span class="s1">: ts_estree_1.AST_NODE_TYPES.ClassExpression;</span>
                <span class="s2">let </span><span class="s1">extendsClause;</span>
                <span class="s2">let </span><span class="s1">implementsClause;</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">heritageClause of heritageClauses) {</span>
                    <span class="s2">const </span><span class="s1">{ token, types } = heritageClause;</span>
                    <span class="s2">if </span><span class="s1">(types.length === </span><span class="s3">0</span><span class="s1">) {</span>
                        <span class="s2">this</span><span class="s1">.#throwUnlessAllowInvalidAST(heritageClause, </span><span class="s0">`'</span><span class="s1">${ts.tokenToString(token)}</span><span class="s0">' list cannot be empty.`</span><span class="s1">);</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(token === SyntaxKind.ExtendsKeyword) {</span>
                        <span class="s2">if </span><span class="s1">(extendsClause) {</span>
                            <span class="s2">this</span><span class="s1">.#throwUnlessAllowInvalidAST(heritageClause, </span><span class="s0">&quot;'extends' clause already seen.&quot;</span><span class="s1">);</span>
                        <span class="s1">}</span>
                        <span class="s2">if </span><span class="s1">(implementsClause) {</span>
                            <span class="s2">this</span><span class="s1">.#throwUnlessAllowInvalidAST(heritageClause, </span><span class="s0">&quot;'extends' clause must precede 'implements' clause.&quot;</span><span class="s1">);</span>
                        <span class="s1">}</span>
                        <span class="s2">if </span><span class="s1">(types.length &gt; </span><span class="s3">1</span><span class="s1">) {</span>
                            <span class="s2">this</span><span class="s1">.#throwUnlessAllowInvalidAST(types[</span><span class="s3">1</span><span class="s1">], </span><span class="s0">'Classes can only extend a single class.'</span><span class="s1">);</span>
                        <span class="s1">}</span>
                        <span class="s1">extendsClause ??= heritageClause;</span>
                    <span class="s1">}</span>
                    <span class="s2">else if </span><span class="s1">(token === SyntaxKind.ImplementsKeyword) {</span>
                        <span class="s2">if </span><span class="s1">(implementsClause) {</span>
                            <span class="s2">this</span><span class="s1">.#throwUnlessAllowInvalidAST(heritageClause, </span><span class="s0">&quot;'implements' clause already seen.&quot;</span><span class="s1">);</span>
                        <span class="s1">}</span>
                        <span class="s1">implementsClause ??= heritageClause;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: classNodeType,</span>
                    <span class="s1">abstract: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.AbstractKeyword, node),</span>
                    <span class="s1">body: </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ClassBody,</span>
                        <span class="s1">range: [node.members.pos - </span><span class="s3">1</span><span class="s1">, node.end],</span>
                        <span class="s1">body: </span><span class="s2">this</span><span class="s1">.convertChildren(node.members.filter(node_utils_1.isESTreeClassMember)),</span>
                    <span class="s1">}),</span>
                    <span class="s1">declare: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node),</span>
                    <span class="s1">decorators: </span><span class="s2">this</span><span class="s1">.convertChildren((</span><span class="s3">0</span><span class="s1">, getModifiers_1.getDecorators)(node) ?? []),</span>
                    <span class="s1">id: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                    <span class="s2">implements</span><span class="s1">: </span><span class="s2">this</span><span class="s1">.convertChildren(implementsClause?.types ?? []),</span>
                    <span class="s1">superClass: extendsClause?.types[</span><span class="s3">0</span><span class="s1">]</span>
                        <span class="s1">? </span><span class="s2">this</span><span class="s1">.convertChild(extendsClause.types[</span><span class="s3">0</span><span class="s1">].expression)</span>
                        <span class="s1">: </span><span class="s2">null</span><span class="s1">,</span>
                    <span class="s1">superTypeArguments: undefined,</span>
                    <span class="s1">typeParameters: node.typeParameters &amp;&amp;</span>
                        <span class="s2">this</span><span class="s1">.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters),</span>
                <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">(extendsClause?.types[</span><span class="s3">0</span><span class="s1">]?.typeArguments) {</span>
                    <span class="s1">result.superTypeArguments =</span>
                        <span class="s2">this</span><span class="s1">.convertTypeArgumentsToTypeParameterInstantiation(extendsClause.types[</span><span class="s3">0</span><span class="s1">].typeArguments, extendsClause.types[</span><span class="s3">0</span><span class="s1">]);</span>
                <span class="s1">}</span>
                <span class="s2">return this</span><span class="s1">.fixExports(node, result);</span>
            <span class="s1">}</span>
            <span class="s4">// Modules</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ModuleBlock:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSModuleBlock,</span>
                    <span class="s1">body: </span><span class="s2">this</span><span class="s1">.convertBodyExpressions(node.statements, node),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ImportDeclaration: {</span>
                <span class="s2">this</span><span class="s1">.assertModuleSpecifier(node, </span><span class="s2">false</span><span class="s1">);</span>
                <span class="s2">const </span><span class="s1">result = </span><span class="s2">this</span><span class="s1">.createNode(node, </span><span class="s2">this</span><span class="s1">.#withDeprecatedAliasGetter({</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ImportDeclaration,</span>
                    <span class="s1">attributes: </span><span class="s2">this</span><span class="s1">.convertImportAttributes(node),</span>
                    <span class="s1">importKind: </span><span class="s0">'value'</span><span class="s1">,</span>
                    <span class="s1">source: </span><span class="s2">this</span><span class="s1">.convertChild(node.moduleSpecifier),</span>
                    <span class="s1">specifiers: [],</span>
                <span class="s1">}, </span><span class="s0">'assertions'</span><span class="s1">, </span><span class="s0">'attributes'</span><span class="s1">, </span><span class="s2">true</span><span class="s1">));</span>
                <span class="s2">if </span><span class="s1">(node.importClause) {</span>
                    <span class="s4">// TODO(bradzacher) swap to `phaseModifier` once we add support for `import defer`</span>
                    <span class="s4">// https://github.com/estree/estree/issues/328</span>
                    <span class="s4">// eslint-disable-next-line @typescript-eslint/no-deprecated</span>
                    <span class="s2">if </span><span class="s1">(node.importClause.isTypeOnly) {</span>
                        <span class="s1">result.importKind = </span><span class="s0">'type'</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(node.importClause.name) {</span>
                        <span class="s1">result.specifiers.push(</span><span class="s2">this</span><span class="s1">.convertChild(node.importClause));</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(node.importClause.namedBindings) {</span>
                        <span class="s2">switch </span><span class="s1">(node.importClause.namedBindings.kind) {</span>
                            <span class="s2">case </span><span class="s1">SyntaxKind.NamespaceImport:</span>
                                <span class="s1">result.specifiers.push(</span><span class="s2">this</span><span class="s1">.convertChild(node.importClause.namedBindings));</span>
                                <span class="s2">break</span><span class="s1">;</span>
                            <span class="s2">case </span><span class="s1">SyntaxKind.NamedImports:</span>
                                <span class="s1">result.specifiers.push(...</span><span class="s2">this</span><span class="s1">.convertChildren(node.importClause.namedBindings.elements));</span>
                                <span class="s2">break</span><span class="s1">;</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">result;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.NamespaceImport:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ImportNamespaceSpecifier,</span>
                    <span class="s1">local: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ImportSpecifier:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ImportSpecifier,</span>
                    <span class="s1">imported: </span><span class="s2">this</span><span class="s1">.convertChild(node.propertyName ?? node.name),</span>
                    <span class="s1">importKind: node.isTypeOnly ? </span><span class="s0">'type' </span><span class="s1">: </span><span class="s0">'value'</span><span class="s1">,</span>
                    <span class="s1">local: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ImportClause: {</span>
                <span class="s2">const </span><span class="s1">local = </span><span class="s2">this</span><span class="s1">.convertChild(node.name);</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ImportDefaultSpecifier,</span>
                    <span class="s1">range: local.range,</span>
                    <span class="s1">local,</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ExportDeclaration: {</span>
                <span class="s2">if </span><span class="s1">(node.exportClause?.kind === SyntaxKind.NamedExports) {</span>
                    <span class="s2">this</span><span class="s1">.assertModuleSpecifier(node, </span><span class="s2">true</span><span class="s1">);</span>
                    <span class="s2">return this</span><span class="s1">.createNode(node, </span><span class="s2">this</span><span class="s1">.#withDeprecatedAliasGetter({</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ExportNamedDeclaration,</span>
                        <span class="s1">attributes: </span><span class="s2">this</span><span class="s1">.convertImportAttributes(node),</span>
                        <span class="s1">declaration: </span><span class="s2">null</span><span class="s1">,</span>
                        <span class="s1">exportKind: node.isTypeOnly ? </span><span class="s0">'type' </span><span class="s1">: </span><span class="s0">'value'</span><span class="s1">,</span>
                        <span class="s1">source: </span><span class="s2">this</span><span class="s1">.convertChild(node.moduleSpecifier),</span>
                        <span class="s1">specifiers: </span><span class="s2">this</span><span class="s1">.convertChildren(node.exportClause.elements, node),</span>
                    <span class="s1">}, </span><span class="s0">'assertions'</span><span class="s1">, </span><span class="s0">'attributes'</span><span class="s1">, </span><span class="s2">true</span><span class="s1">));</span>
                <span class="s1">}</span>
                <span class="s2">this</span><span class="s1">.assertModuleSpecifier(node, </span><span class="s2">false</span><span class="s1">);</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, </span><span class="s2">this</span><span class="s1">.#withDeprecatedAliasGetter({</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ExportAllDeclaration,</span>
                    <span class="s1">attributes: </span><span class="s2">this</span><span class="s1">.convertImportAttributes(node),</span>
                    <span class="s1">exported: node.exportClause?.kind === SyntaxKind.NamespaceExport</span>
                        <span class="s1">? </span><span class="s2">this</span><span class="s1">.convertChild(node.exportClause.name)</span>
                        <span class="s1">: </span><span class="s2">null</span><span class="s1">,</span>
                    <span class="s1">exportKind: node.isTypeOnly ? </span><span class="s0">'type' </span><span class="s1">: </span><span class="s0">'value'</span><span class="s1">,</span>
                    <span class="s1">source: </span><span class="s2">this</span><span class="s1">.convertChild(node.moduleSpecifier),</span>
                <span class="s1">}, </span><span class="s0">'assertions'</span><span class="s1">, </span><span class="s0">'attributes'</span><span class="s1">, </span><span class="s2">true</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ExportSpecifier: {</span>
                <span class="s2">const </span><span class="s1">local = node.propertyName ?? node.name;</span>
                <span class="s2">if </span><span class="s1">(local.kind === SyntaxKind.StringLiteral &amp;&amp;</span>
                    <span class="s1">parent.kind === SyntaxKind.ExportDeclaration &amp;&amp;</span>
                    <span class="s1">parent.moduleSpecifier?.kind !== SyntaxKind.StringLiteral) {</span>
                    <span class="s2">this</span><span class="s1">.#throwError(local, </span><span class="s0">'A string literal cannot be used as a local exported binding without `from`.'</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ExportSpecifier,</span>
                    <span class="s1">exported: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                    <span class="s1">exportKind: node.isTypeOnly ? </span><span class="s0">'type' </span><span class="s1">: </span><span class="s0">'value'</span><span class="s1">,</span>
                    <span class="s1">local: </span><span class="s2">this</span><span class="s1">.convertChild(local),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ExportAssignment:</span>
                <span class="s2">if </span><span class="s1">(node.isExportEquals) {</span>
                    <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSExportAssignment,</span>
                        <span class="s1">expression: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ExportDefaultDeclaration,</span>
                    <span class="s1">declaration: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                    <span class="s1">exportKind: </span><span class="s0">'value'</span><span class="s1">,</span>
                <span class="s1">});</span>
            <span class="s4">// Unary Operations</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.PrefixUnaryExpression:</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.PostfixUnaryExpression: {</span>
                <span class="s2">const </span><span class="s1">operator = (</span><span class="s3">0</span><span class="s1">, node_utils_1.getTextForTokenKind)(node.operator);</span>
                <span class="s4">/**</span>
                 <span class="s4">* ESTree uses UpdateExpression for ++/--</span>
                 <span class="s4">*/</span>
                <span class="s2">if </span><span class="s1">(operator === </span><span class="s0">'++' </span><span class="s1">|| operator === </span><span class="s0">'--'</span><span class="s1">) {</span>
                    <span class="s2">if </span><span class="s1">(!(</span><span class="s3">0</span><span class="s1">, node_utils_1.isValidAssignmentTarget)(node.operand)) {</span>
                        <span class="s2">this</span><span class="s1">.#throwUnlessAllowInvalidAST(node.operand, </span><span class="s0">'Invalid left-hand side expression in unary operation'</span><span class="s1">);</span>
                    <span class="s1">}</span>
                    <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.UpdateExpression,</span>
                        <span class="s1">argument: </span><span class="s2">this</span><span class="s1">.convertChild(node.operand),</span>
                        <span class="s1">operator,</span>
                        <span class="s1">prefix: node.kind === SyntaxKind.PrefixUnaryExpression,</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.UnaryExpression,</span>
                    <span class="s1">argument: </span><span class="s2">this</span><span class="s1">.convertChild(node.operand),</span>
                    <span class="s1">operator,</span>
                    <span class="s1">prefix: node.kind === SyntaxKind.PrefixUnaryExpression,</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.DeleteExpression:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.UnaryExpression,</span>
                    <span class="s1">argument: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                    <span class="s1">operator: </span><span class="s0">'delete'</span><span class="s1">,</span>
                    <span class="s1">prefix: </span><span class="s2">true</span><span class="s1">,</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.VoidExpression:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.UnaryExpression,</span>
                    <span class="s1">argument: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                    <span class="s1">operator: </span><span class="s0">'void'</span><span class="s1">,</span>
                    <span class="s1">prefix: </span><span class="s2">true</span><span class="s1">,</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.TypeOfExpression:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.UnaryExpression,</span>
                    <span class="s1">argument: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                    <span class="s1">operator: </span><span class="s0">'typeof'</span><span class="s1">,</span>
                    <span class="s1">prefix: </span><span class="s2">true</span><span class="s1">,</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.TypeOperator:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSTypeOperator,</span>
                    <span class="s1">operator: (</span><span class="s3">0</span><span class="s1">, node_utils_1.getTextForTokenKind)(node.operator),</span>
                    <span class="s1">typeAnnotation: </span><span class="s2">this</span><span class="s1">.convertChild(node.type),</span>
                <span class="s1">});</span>
            <span class="s4">// Binary Operations</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.BinaryExpression: {</span>
                <span class="s4">// TypeScript uses BinaryExpression for sequences as well</span>
                <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, node_utils_1.isComma)(node.operatorToken)) {</span>
                    <span class="s2">const </span><span class="s1">result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.SequenceExpression,</span>
                        <span class="s1">expressions: [],</span>
                    <span class="s1">});</span>
                    <span class="s2">const </span><span class="s1">left = </span><span class="s2">this</span><span class="s1">.convertChild(node.left);</span>
                    <span class="s2">if </span><span class="s1">(left.type === ts_estree_1.AST_NODE_TYPES.SequenceExpression &amp;&amp;</span>
                        <span class="s1">node.left.kind !== SyntaxKind.ParenthesizedExpression) {</span>
                        <span class="s1">result.expressions.push(...left.expressions);</span>
                    <span class="s1">}</span>
                    <span class="s2">else </span><span class="s1">{</span>
                        <span class="s1">result.expressions.push(left);</span>
                    <span class="s1">}</span>
                    <span class="s1">result.expressions.push(</span><span class="s2">this</span><span class="s1">.convertChild(node.right));</span>
                    <span class="s2">return </span><span class="s1">result;</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">expressionType = (</span><span class="s3">0</span><span class="s1">, node_utils_1.getBinaryExpressionType)(node.operatorToken);</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.allowPattern &amp;&amp;</span>
                    <span class="s1">expressionType.type === ts_estree_1.AST_NODE_TYPES.AssignmentExpression) {</span>
                    <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.AssignmentPattern,</span>
                        <span class="s1">decorators: [],</span>
                        <span class="s1">left: </span><span class="s2">this</span><span class="s1">.convertPattern(node.left, node),</span>
                        <span class="s1">optional: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">right: </span><span class="s2">this</span><span class="s1">.convertChild(node.right),</span>
                        <span class="s1">typeAnnotation: undefined,</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">...expressionType,</span>
                    <span class="s1">left: </span><span class="s2">this</span><span class="s1">.converter(node.left, node, expressionType.type === ts_estree_1.AST_NODE_TYPES.AssignmentExpression),</span>
                    <span class="s1">right: </span><span class="s2">this</span><span class="s1">.convertChild(node.right),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.PropertyAccessExpression: {</span>
                <span class="s2">const </span><span class="s1">object = </span><span class="s2">this</span><span class="s1">.convertChild(node.expression);</span>
                <span class="s2">const </span><span class="s1">property = </span><span class="s2">this</span><span class="s1">.convertChild(node.name);</span>
                <span class="s2">const </span><span class="s1">computed = </span><span class="s2">false</span><span class="s1">;</span>
                <span class="s2">const </span><span class="s1">result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.MemberExpression,</span>
                    <span class="s1">computed,</span>
                    <span class="s1">object,</span>
                    <span class="s1">optional: node.questionDotToken != </span><span class="s2">null</span><span class="s1">,</span>
                    <span class="s1">property,</span>
                <span class="s1">});</span>
                <span class="s2">return this</span><span class="s1">.convertChainExpression(result, node);</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ElementAccessExpression: {</span>
                <span class="s2">const </span><span class="s1">object = </span><span class="s2">this</span><span class="s1">.convertChild(node.expression);</span>
                <span class="s2">const </span><span class="s1">property = </span><span class="s2">this</span><span class="s1">.convertChild(node.argumentExpression);</span>
                <span class="s2">const </span><span class="s1">computed = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s2">const </span><span class="s1">result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.MemberExpression,</span>
                    <span class="s1">computed,</span>
                    <span class="s1">object,</span>
                    <span class="s1">optional: node.questionDotToken != </span><span class="s2">null</span><span class="s1">,</span>
                    <span class="s1">property,</span>
                <span class="s1">});</span>
                <span class="s2">return this</span><span class="s1">.convertChainExpression(result, node);</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.CallExpression: {</span>
                <span class="s2">if </span><span class="s1">(node.expression.kind === SyntaxKind.ImportKeyword) {</span>
                    <span class="s2">if </span><span class="s1">(node.arguments.length !== </span><span class="s3">1 </span><span class="s1">&amp;&amp; node.arguments.length !== </span><span class="s3">2</span><span class="s1">) {</span>
                        <span class="s2">this</span><span class="s1">.#throwUnlessAllowInvalidAST(node.arguments[</span><span class="s3">2</span><span class="s1">] ?? node, </span><span class="s0">'Dynamic import requires exactly one or two arguments.'</span><span class="s1">);</span>
                    <span class="s1">}</span>
                    <span class="s2">return this</span><span class="s1">.createNode(node, </span><span class="s2">this</span><span class="s1">.#withDeprecatedAliasGetter({</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ImportExpression,</span>
                        <span class="s1">options: node.arguments[</span><span class="s3">1</span><span class="s1">]</span>
                            <span class="s1">? </span><span class="s2">this</span><span class="s1">.convertChild(node.arguments[</span><span class="s3">1</span><span class="s1">])</span>
                            <span class="s1">: </span><span class="s2">null</span><span class="s1">,</span>
                        <span class="s1">source: </span><span class="s2">this</span><span class="s1">.convertChild(node.arguments[</span><span class="s3">0</span><span class="s1">]),</span>
                    <span class="s1">}, </span><span class="s0">'attributes'</span><span class="s1">, </span><span class="s0">'options'</span><span class="s1">, </span><span class="s2">true</span><span class="s1">));</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">callee = </span><span class="s2">this</span><span class="s1">.convertChild(node.expression);</span>
                <span class="s2">const </span><span class="s1">args = </span><span class="s2">this</span><span class="s1">.convertChildren(node.arguments);</span>
                <span class="s2">const </span><span class="s1">typeArguments = node.typeArguments &amp;&amp;</span>
                    <span class="s2">this</span><span class="s1">.convertTypeArgumentsToTypeParameterInstantiation(node.typeArguments, node);</span>
                <span class="s2">const </span><span class="s1">result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.CallExpression,</span>
                    <span class="s1">arguments: args,</span>
                    <span class="s1">callee,</span>
                    <span class="s1">optional: node.questionDotToken != </span><span class="s2">null</span><span class="s1">,</span>
                    <span class="s1">typeArguments,</span>
                <span class="s1">});</span>
                <span class="s2">return this</span><span class="s1">.convertChainExpression(result, node);</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.NewExpression: {</span>
                <span class="s2">const </span><span class="s1">typeArguments = node.typeArguments &amp;&amp;</span>
                    <span class="s2">this</span><span class="s1">.convertTypeArgumentsToTypeParameterInstantiation(node.typeArguments, node);</span>
                <span class="s4">// NOTE - NewExpression cannot have an optional chain in it</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.NewExpression,</span>
                    <span class="s1">arguments: </span><span class="s2">this</span><span class="s1">.convertChildren(node.arguments ?? []),</span>
                    <span class="s1">callee: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                    <span class="s1">typeArguments,</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ConditionalExpression:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ConditionalExpression,</span>
                    <span class="s1">alternate: </span><span class="s2">this</span><span class="s1">.convertChild(node.whenFalse),</span>
                    <span class="s1">consequent: </span><span class="s2">this</span><span class="s1">.convertChild(node.whenTrue),</span>
                    <span class="s1">test: </span><span class="s2">this</span><span class="s1">.convertChild(node.condition),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.MetaProperty: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.MetaProperty,</span>
                    <span class="s1">meta: </span><span class="s2">this</span><span class="s1">.createNode(</span>
                    <span class="s4">// TODO: do we really want to convert it to Token?</span>
                    <span class="s1">node.getFirstToken(), {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.Identifier,</span>
                        <span class="s1">decorators: [],</span>
                        <span class="s1">name: (</span><span class="s3">0</span><span class="s1">, node_utils_1.getTextForTokenKind)(node.keywordToken),</span>
                        <span class="s1">optional: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">typeAnnotation: undefined,</span>
                    <span class="s1">}),</span>
                    <span class="s1">property: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.Decorator: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.Decorator,</span>
                    <span class="s1">expression: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s4">// Literals</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.StringLiteral: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.Literal,</span>
                    <span class="s1">raw: node.getText(),</span>
                    <span class="s1">value: parent.kind === SyntaxKind.JsxAttribute</span>
                        <span class="s1">? (</span><span class="s3">0</span><span class="s1">, node_utils_1.unescapeStringLiteralText)(node.text)</span>
                        <span class="s1">: node.text,</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.NumericLiteral: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.Literal,</span>
                    <span class="s1">raw: node.getText(),</span>
                    <span class="s1">value: Number(node.text),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.BigIntLiteral: {</span>
                <span class="s2">const </span><span class="s1">range = (</span><span class="s3">0</span><span class="s1">, node_utils_1.getRange)(node, </span><span class="s2">this</span><span class="s1">.ast);</span>
                <span class="s2">const </span><span class="s1">rawValue = </span><span class="s2">this</span><span class="s1">.ast.text.slice(range[</span><span class="s3">0</span><span class="s1">], range[</span><span class="s3">1</span><span class="s1">]);</span>
                <span class="s2">const </span><span class="s1">bigint = rawValue</span>
                    <span class="s4">// remove suffix `n`</span>
                    <span class="s1">.slice(</span><span class="s3">0</span><span class="s1">, -</span><span class="s3">1</span><span class="s1">)</span>
                    <span class="s4">// `BigInt` doesn't accept numeric separator</span>
                    <span class="s4">// and `bigint` property should not include numeric separator</span>
                    <span class="s1">.replaceAll(</span><span class="s0">'_'</span><span class="s1">, </span><span class="s0">''</span><span class="s1">);</span>
                <span class="s2">const </span><span class="s1">value = </span><span class="s2">typeof </span><span class="s1">BigInt !== </span><span class="s0">'undefined' </span><span class="s1">? BigInt(bigint) : </span><span class="s2">null</span><span class="s1">;</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.Literal,</span>
                    <span class="s1">range,</span>
                    <span class="s1">bigint: value == </span><span class="s2">null </span><span class="s1">? bigint : String(value),</span>
                    <span class="s1">raw: rawValue,</span>
                    <span class="s1">value,</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.RegularExpressionLiteral: {</span>
                <span class="s2">const </span><span class="s1">pattern = node.text.slice(</span><span class="s3">1</span><span class="s1">, node.text.lastIndexOf(</span><span class="s0">'/'</span><span class="s1">));</span>
                <span class="s2">const </span><span class="s1">flags = node.text.slice(node.text.lastIndexOf(</span><span class="s0">'/'</span><span class="s1">) + </span><span class="s3">1</span><span class="s1">);</span>
                <span class="s2">let </span><span class="s1">regex = </span><span class="s2">null</span><span class="s1">;</span>
                <span class="s2">try </span><span class="s1">{</span>
                    <span class="s1">regex = </span><span class="s2">new </span><span class="s1">RegExp(pattern, flags);</span>
                <span class="s1">}</span>
                <span class="s2">catch </span><span class="s1">{</span>
                    <span class="s4">// Intentionally blank, so regex stays null</span>
                <span class="s1">}</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.Literal,</span>
                    <span class="s1">raw: node.text,</span>
                    <span class="s1">regex: {</span>
                        <span class="s1">flags,</span>
                        <span class="s1">pattern,</span>
                    <span class="s1">},</span>
                    <span class="s1">value: regex,</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.TrueKeyword:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.Literal,</span>
                    <span class="s1">raw: </span><span class="s0">'true'</span><span class="s1">,</span>
                    <span class="s1">value: </span><span class="s2">true</span><span class="s1">,</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.FalseKeyword:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.Literal,</span>
                    <span class="s1">raw: </span><span class="s0">'false'</span><span class="s1">,</span>
                    <span class="s1">value: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.NullKeyword: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.Literal,</span>
                    <span class="s1">raw: </span><span class="s0">'null'</span><span class="s1">,</span>
                    <span class="s1">value: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.EmptyStatement:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.EmptyStatement,</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.DebuggerStatement:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.DebuggerStatement,</span>
                <span class="s1">});</span>
            <span class="s4">// JSX</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.JsxElement:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXElement,</span>
                    <span class="s1">children: </span><span class="s2">this</span><span class="s1">.convertChildren(node.children),</span>
                    <span class="s1">closingElement: </span><span class="s2">this</span><span class="s1">.convertChild(node.closingElement),</span>
                    <span class="s1">openingElement: </span><span class="s2">this</span><span class="s1">.convertChild(node.openingElement),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.JsxFragment:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXFragment,</span>
                    <span class="s1">children: </span><span class="s2">this</span><span class="s1">.convertChildren(node.children),</span>
                    <span class="s1">closingFragment: </span><span class="s2">this</span><span class="s1">.convertChild(node.closingFragment),</span>
                    <span class="s1">openingFragment: </span><span class="s2">this</span><span class="s1">.convertChild(node.openingFragment),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.JsxSelfClosingElement: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXElement,</span>
                    <span class="s4">/**</span>
                     <span class="s4">* Convert SyntaxKind.JsxSelfClosingElement to SyntaxKind.JsxOpeningElement,</span>
                     <span class="s4">* TypeScript does not seem to have the idea of openingElement when tag is self-closing</span>
                     <span class="s4">*/</span>
                    <span class="s1">children: [],</span>
                    <span class="s1">closingElement: </span><span class="s2">null</span><span class="s1">,</span>
                    <span class="s1">openingElement: </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXOpeningElement,</span>
                        <span class="s1">range: (</span><span class="s3">0</span><span class="s1">, node_utils_1.getRange)(node, </span><span class="s2">this</span><span class="s1">.ast),</span>
                        <span class="s1">attributes: </span><span class="s2">this</span><span class="s1">.convertChildren(node.attributes.properties),</span>
                        <span class="s1">name: </span><span class="s2">this</span><span class="s1">.convertJSXTagName(node.tagName, node),</span>
                        <span class="s1">selfClosing: </span><span class="s2">true</span><span class="s1">,</span>
                        <span class="s1">typeArguments: node.typeArguments</span>
                            <span class="s1">? </span><span class="s2">this</span><span class="s1">.convertTypeArgumentsToTypeParameterInstantiation(node.typeArguments, node)</span>
                            <span class="s1">: undefined,</span>
                    <span class="s1">}),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.JsxOpeningElement: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXOpeningElement,</span>
                    <span class="s1">attributes: </span><span class="s2">this</span><span class="s1">.convertChildren(node.attributes.properties),</span>
                    <span class="s1">name: </span><span class="s2">this</span><span class="s1">.convertJSXTagName(node.tagName, node),</span>
                    <span class="s1">selfClosing: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">typeArguments: node.typeArguments &amp;&amp;</span>
                        <span class="s2">this</span><span class="s1">.convertTypeArgumentsToTypeParameterInstantiation(node.typeArguments, node),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.JsxClosingElement:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXClosingElement,</span>
                    <span class="s1">name: </span><span class="s2">this</span><span class="s1">.convertJSXTagName(node.tagName, node),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.JsxOpeningFragment:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXOpeningFragment,</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.JsxClosingFragment:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXClosingFragment,</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.JsxExpression: {</span>
                <span class="s2">const </span><span class="s1">expression = node.expression</span>
                    <span class="s1">? </span><span class="s2">this</span><span class="s1">.convertChild(node.expression)</span>
                    <span class="s1">: </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXEmptyExpression,</span>
                        <span class="s1">range: [node.getStart(</span><span class="s2">this</span><span class="s1">.ast) + </span><span class="s3">1</span><span class="s1">, node.getEnd() - </span><span class="s3">1</span><span class="s1">],</span>
                    <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">(node.dotDotDotToken) {</span>
                    <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXSpreadChild,</span>
                        <span class="s1">expression,</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXExpressionContainer,</span>
                    <span class="s1">expression,</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.JsxAttribute: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXAttribute,</span>
                    <span class="s1">name: </span><span class="s2">this</span><span class="s1">.convertJSXNamespaceOrIdentifier(node.name),</span>
                    <span class="s1">value: </span><span class="s2">this</span><span class="s1">.convertChild(node.initializer),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.JsxText: {</span>
                <span class="s2">const </span><span class="s1">start = node.getFullStart();</span>
                <span class="s2">const </span><span class="s1">end = node.getEnd();</span>
                <span class="s2">const </span><span class="s1">text = </span><span class="s2">this</span><span class="s1">.ast.text.slice(start, end);</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXText,</span>
                    <span class="s1">range: [start, end],</span>
                    <span class="s1">raw: text,</span>
                    <span class="s1">value: (</span><span class="s3">0</span><span class="s1">, node_utils_1.unescapeStringLiteralText)(text),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.JsxSpreadAttribute:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.JSXSpreadAttribute,</span>
                    <span class="s1">argument: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.QualifiedName: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSQualifiedName,</span>
                    <span class="s1">left: </span><span class="s2">this</span><span class="s1">.convertChild(node.left),</span>
                    <span class="s1">right: </span><span class="s2">this</span><span class="s1">.convertChild(node.right),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s4">// TypeScript specific</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.TypeReference:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSTypeReference,</span>
                    <span class="s1">typeArguments: node.typeArguments &amp;&amp;</span>
                        <span class="s2">this</span><span class="s1">.convertTypeArgumentsToTypeParameterInstantiation(node.typeArguments, node),</span>
                    <span class="s1">typeName: </span><span class="s2">this</span><span class="s1">.convertChild(node.typeName),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.TypeParameter: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSTypeParameter,</span>
                    <span class="s2">const</span><span class="s1">: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.ConstKeyword, node),</span>
                    <span class="s1">constraint: node.constraint &amp;&amp; </span><span class="s2">this</span><span class="s1">.convertChild(node.constraint),</span>
                    <span class="s2">default</span><span class="s1">: node.default ? </span><span class="s2">this</span><span class="s1">.convertChild(node.default) : undefined,</span>
                    <span class="s2">in</span><span class="s1">: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.InKeyword, node),</span>
                    <span class="s1">name: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                    <span class="s1">out: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.OutKeyword, node),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ThisType:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSThisType,</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.AnyKeyword:</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.BigIntKeyword:</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.BooleanKeyword:</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.NeverKeyword:</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.NumberKeyword:</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ObjectKeyword:</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.StringKeyword:</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.SymbolKeyword:</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.UnknownKeyword:</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.VoidKeyword:</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.UndefinedKeyword:</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.IntrinsicKeyword: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES[</span><span class="s0">`TS</span><span class="s1">${SyntaxKind[node.kind]}</span><span class="s0">`</span><span class="s1">],</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.NonNullExpression: {</span>
                <span class="s2">const </span><span class="s1">nnExpr = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSNonNullExpression,</span>
                    <span class="s1">expression: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                <span class="s1">});</span>
                <span class="s2">return this</span><span class="s1">.convertChainExpression(nnExpr, node);</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.TypeLiteral: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSTypeLiteral,</span>
                    <span class="s1">members: </span><span class="s2">this</span><span class="s1">.convertChildren(node.members),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ArrayType: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSArrayType,</span>
                    <span class="s1">elementType: </span><span class="s2">this</span><span class="s1">.convertChild(node.elementType),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.IndexedAccessType: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSIndexedAccessType,</span>
                    <span class="s1">indexType: </span><span class="s2">this</span><span class="s1">.convertChild(node.indexType),</span>
                    <span class="s1">objectType: </span><span class="s2">this</span><span class="s1">.convertChild(node.objectType),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ConditionalType: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSConditionalType,</span>
                    <span class="s1">checkType: </span><span class="s2">this</span><span class="s1">.convertChild(node.checkType),</span>
                    <span class="s1">extendsType: </span><span class="s2">this</span><span class="s1">.convertChild(node.extendsType),</span>
                    <span class="s1">falseType: </span><span class="s2">this</span><span class="s1">.convertChild(node.falseType),</span>
                    <span class="s1">trueType: </span><span class="s2">this</span><span class="s1">.convertChild(node.trueType),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.TypeQuery:</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSTypeQuery,</span>
                    <span class="s1">exprName: </span><span class="s2">this</span><span class="s1">.convertChild(node.exprName),</span>
                    <span class="s1">typeArguments: node.typeArguments &amp;&amp;</span>
                        <span class="s2">this</span><span class="s1">.convertTypeArgumentsToTypeParameterInstantiation(node.typeArguments, node),</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.MappedType: {</span>
                <span class="s2">if </span><span class="s1">(node.members &amp;&amp; node.members.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
                    <span class="s2">this</span><span class="s1">.#throwUnlessAllowInvalidAST(node.members[</span><span class="s3">0</span><span class="s1">], </span><span class="s0">'A mapped type may not declare properties or methods.'</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, </span><span class="s2">this</span><span class="s1">.#withDeprecatedGetter({</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSMappedType,</span>
                    <span class="s1">constraint: </span><span class="s2">this</span><span class="s1">.convertChild(node.typeParameter.constraint),</span>
                    <span class="s1">key: </span><span class="s2">this</span><span class="s1">.convertChild(node.typeParameter.name),</span>
                    <span class="s1">nameType: </span><span class="s2">this</span><span class="s1">.convertChild(node.nameType) ?? </span><span class="s2">null</span><span class="s1">,</span>
                    <span class="s1">optional: node.questionToken</span>
                        <span class="s1">? node.questionToken.kind === SyntaxKind.QuestionToken ||</span>
                            <span class="s1">(</span><span class="s3">0</span><span class="s1">, node_utils_1.getTextForTokenKind)(node.questionToken.kind)</span>
                        <span class="s1">: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">readonly: node.readonlyToken</span>
                        <span class="s1">? node.readonlyToken.kind === SyntaxKind.ReadonlyKeyword ||</span>
                            <span class="s1">(</span><span class="s3">0</span><span class="s1">, node_utils_1.getTextForTokenKind)(node.readonlyToken.kind)</span>
                        <span class="s1">: undefined,</span>
                    <span class="s1">typeAnnotation: node.type &amp;&amp; </span><span class="s2">this</span><span class="s1">.convertChild(node.type),</span>
                <span class="s1">}, </span><span class="s0">'typeParameter'</span><span class="s1">, </span><span class="s0">&quot;'constraint' and 'key'&quot;</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.convertChild(node.typeParameter)));</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ParenthesizedExpression:</span>
                <span class="s2">return this</span><span class="s1">.convertChild(node.expression, parent);</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.TypeAliasDeclaration: {</span>
                <span class="s2">const </span><span class="s1">result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSTypeAliasDeclaration,</span>
                    <span class="s1">declare: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node),</span>
                    <span class="s1">id: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                    <span class="s1">typeAnnotation: </span><span class="s2">this</span><span class="s1">.convertChild(node.type),</span>
                    <span class="s1">typeParameters: node.typeParameters &amp;&amp;</span>
                        <span class="s2">this</span><span class="s1">.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters),</span>
                <span class="s1">});</span>
                <span class="s2">return this</span><span class="s1">.fixExports(node, result);</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.MethodSignature: {</span>
                <span class="s2">return this</span><span class="s1">.convertMethodSignature(node);</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.PropertySignature: {</span>
                <span class="s4">// eslint-disable-next-line @typescript-eslint/no-deprecated</span>
                <span class="s2">const </span><span class="s1">{ initializer } = node;</span>
                <span class="s2">if </span><span class="s1">(initializer) {</span>
                    <span class="s2">this</span><span class="s1">.#throwError(initializer, </span><span class="s0">'A property signature cannot have an initializer.'</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSPropertySignature,</span>
                    <span class="s1">accessibility: (</span><span class="s3">0</span><span class="s1">, node_utils_1.getTSNodeAccessibility)(node),</span>
                    <span class="s1">computed: (</span><span class="s3">0</span><span class="s1">, node_utils_1.isComputedProperty)(node.name),</span>
                    <span class="s1">key: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                    <span class="s1">optional: (</span><span class="s3">0</span><span class="s1">, node_utils_1.isOptional)(node),</span>
                    <span class="s1">readonly: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.ReadonlyKeyword, node),</span>
                    <span class="s2">static</span><span class="s1">: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node),</span>
                    <span class="s1">typeAnnotation: node.type &amp;&amp; </span><span class="s2">this</span><span class="s1">.convertTypeAnnotation(node.type, node),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.IndexSignature: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSIndexSignature,</span>
                    <span class="s1">accessibility: (</span><span class="s3">0</span><span class="s1">, node_utils_1.getTSNodeAccessibility)(node),</span>
                    <span class="s1">parameters: </span><span class="s2">this</span><span class="s1">.convertChildren(node.parameters),</span>
                    <span class="s1">readonly: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.ReadonlyKeyword, node),</span>
                    <span class="s2">static</span><span class="s1">: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.StaticKeyword, node),</span>
                    <span class="s1">typeAnnotation: node.type &amp;&amp; </span><span class="s2">this</span><span class="s1">.convertTypeAnnotation(node.type, node),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ConstructorType: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSConstructorType,</span>
                    <span class="s1">abstract: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.AbstractKeyword, node),</span>
                    <span class="s1">params: </span><span class="s2">this</span><span class="s1">.convertParameters(node.parameters),</span>
                    <span class="s1">returnType: node.type &amp;&amp; </span><span class="s2">this</span><span class="s1">.convertTypeAnnotation(node.type, node),</span>
                    <span class="s1">typeParameters: node.typeParameters &amp;&amp;</span>
                        <span class="s2">this</span><span class="s1">.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.FunctionType: {</span>
                <span class="s4">// eslint-disable-next-line @typescript-eslint/no-deprecated</span>
                <span class="s2">const </span><span class="s1">{ modifiers } = node;</span>
                <span class="s2">if </span><span class="s1">(modifiers) {</span>
                    <span class="s2">this</span><span class="s1">.#throwError(modifiers[</span><span class="s3">0</span><span class="s1">], </span><span class="s0">'A function type cannot have modifiers.'</span><span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s4">// intentional fallthrough</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ConstructSignature:</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.CallSignature: {</span>
                <span class="s2">const </span><span class="s1">type = node.kind === SyntaxKind.ConstructSignature</span>
                    <span class="s1">? ts_estree_1.AST_NODE_TYPES.TSConstructSignatureDeclaration</span>
                    <span class="s1">: node.kind === SyntaxKind.CallSignature</span>
                        <span class="s1">? ts_estree_1.AST_NODE_TYPES.TSCallSignatureDeclaration</span>
                        <span class="s1">: ts_estree_1.AST_NODE_TYPES.TSFunctionType;</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type,</span>
                    <span class="s1">params: </span><span class="s2">this</span><span class="s1">.convertParameters(node.parameters),</span>
                    <span class="s1">returnType: node.type &amp;&amp; </span><span class="s2">this</span><span class="s1">.convertTypeAnnotation(node.type, node),</span>
                    <span class="s1">typeParameters: node.typeParameters &amp;&amp;</span>
                        <span class="s2">this</span><span class="s1">.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ExpressionWithTypeArguments: {</span>
                <span class="s2">const </span><span class="s1">parentKind = parent.kind;</span>
                <span class="s2">const </span><span class="s1">type = parentKind === SyntaxKind.InterfaceDeclaration</span>
                    <span class="s1">? ts_estree_1.AST_NODE_TYPES.TSInterfaceHeritage</span>
                    <span class="s1">: parentKind === SyntaxKind.HeritageClause</span>
                        <span class="s1">? ts_estree_1.AST_NODE_TYPES.TSClassImplements</span>
                        <span class="s1">: ts_estree_1.AST_NODE_TYPES.TSInstantiationExpression;</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type,</span>
                    <span class="s1">expression: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                    <span class="s1">typeArguments: node.typeArguments &amp;&amp;</span>
                        <span class="s2">this</span><span class="s1">.convertTypeArgumentsToTypeParameterInstantiation(node.typeArguments, node),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.InterfaceDeclaration: {</span>
                <span class="s2">const </span><span class="s1">interfaceHeritageClauses = node.heritageClauses ?? [];</span>
                <span class="s2">const </span><span class="s1">interfaceExtends = [];</span>
                <span class="s2">let </span><span class="s1">seenExtendsClause = </span><span class="s2">false</span><span class="s1">;</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">heritageClause of interfaceHeritageClauses) {</span>
                    <span class="s2">if </span><span class="s1">(heritageClause.token !== SyntaxKind.ExtendsKeyword) {</span>
                        <span class="s2">this</span><span class="s1">.#throwError(heritageClause, heritageClause.token === SyntaxKind.ImplementsKeyword</span>
                            <span class="s1">? </span><span class="s0">&quot;Interface declaration cannot have 'implements' clause.&quot;</span>
                            <span class="s1">: </span><span class="s0">'Unexpected token.'</span><span class="s1">);</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(seenExtendsClause) {</span>
                        <span class="s2">this</span><span class="s1">.#throwError(heritageClause, </span><span class="s0">&quot;'extends' clause already seen.&quot;</span><span class="s1">);</span>
                    <span class="s1">}</span>
                    <span class="s1">seenExtendsClause = </span><span class="s2">true</span><span class="s1">;</span>
                    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">heritageType of heritageClause.types) {</span>
                        <span class="s2">if </span><span class="s1">(!isEntityNameExpression(heritageType.expression) ||</span>
                            <span class="s1">ts.isOptionalChain(heritageType.expression)) {</span>
                            <span class="s2">this</span><span class="s1">.#throwError(heritageType, </span><span class="s0">'Interface declaration can only extend an identifier/qualified name with optional type arguments.'</span><span class="s1">);</span>
                        <span class="s1">}</span>
                        <span class="s1">interfaceExtends.push(</span><span class="s2">this</span><span class="s1">.convertChild(heritageType, node));</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSInterfaceDeclaration,</span>
                    <span class="s1">body: </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSInterfaceBody,</span>
                        <span class="s1">range: [node.members.pos - </span><span class="s3">1</span><span class="s1">, node.end],</span>
                        <span class="s1">body: </span><span class="s2">this</span><span class="s1">.convertChildren(node.members),</span>
                    <span class="s1">}),</span>
                    <span class="s1">declare: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node),</span>
                    <span class="s2">extends</span><span class="s1">: interfaceExtends,</span>
                    <span class="s1">id: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                    <span class="s1">typeParameters: node.typeParameters &amp;&amp;</span>
                        <span class="s2">this</span><span class="s1">.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters),</span>
                <span class="s1">});</span>
                <span class="s2">return this</span><span class="s1">.fixExports(node, result);</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.TypePredicate: {</span>
                <span class="s2">const </span><span class="s1">result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSTypePredicate,</span>
                    <span class="s1">asserts: node.assertsModifier != </span><span class="s2">null</span><span class="s1">,</span>
                    <span class="s1">parameterName: </span><span class="s2">this</span><span class="s1">.convertChild(node.parameterName),</span>
                    <span class="s1">typeAnnotation: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">});</span>
                <span class="s4">/**</span>
                 <span class="s4">* Specific fix for type-guard location data</span>
                 <span class="s4">*/</span>
                <span class="s2">if </span><span class="s1">(node.type) {</span>
                    <span class="s1">result.typeAnnotation = </span><span class="s2">this</span><span class="s1">.convertTypeAnnotation(node.type, node);</span>
                    <span class="s1">result.typeAnnotation.loc = result.typeAnnotation.typeAnnotation.loc;</span>
                    <span class="s1">result.typeAnnotation.range =</span>
                        <span class="s1">result.typeAnnotation.typeAnnotation.range;</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">result;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ImportType: {</span>
                <span class="s2">const </span><span class="s1">range = (</span><span class="s3">0</span><span class="s1">, node_utils_1.getRange)(node, </span><span class="s2">this</span><span class="s1">.ast);</span>
                <span class="s2">if </span><span class="s1">(node.isTypeOf) {</span>
                    <span class="s2">const </span><span class="s1">token = (</span><span class="s3">0</span><span class="s1">, node_utils_1.findNextToken)(node.getFirstToken(), node, </span><span class="s2">this</span><span class="s1">.ast);</span>
                    <span class="s1">range[</span><span class="s3">0</span><span class="s1">] = token.getStart(</span><span class="s2">this</span><span class="s1">.ast);</span>
                <span class="s1">}</span>
                <span class="s2">let </span><span class="s1">options = </span><span class="s2">null</span><span class="s1">;</span>
                <span class="s2">if </span><span class="s1">(node.attributes) {</span>
                    <span class="s2">const </span><span class="s1">value = </span><span class="s2">this</span><span class="s1">.createNode(node.attributes, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ObjectExpression,</span>
                        <span class="s1">properties: node.attributes.elements.map(importAttribute =&gt; </span><span class="s2">this</span><span class="s1">.createNode(importAttribute, {</span>
                            <span class="s1">type: ts_estree_1.AST_NODE_TYPES.Property,</span>
                            <span class="s1">computed: </span><span class="s2">false</span><span class="s1">,</span>
                            <span class="s1">key: </span><span class="s2">this</span><span class="s1">.convertChild(importAttribute.name),</span>
                            <span class="s1">kind: </span><span class="s0">'init'</span><span class="s1">,</span>
                            <span class="s1">method: </span><span class="s2">false</span><span class="s1">,</span>
                            <span class="s1">optional: </span><span class="s2">false</span><span class="s1">,</span>
                            <span class="s1">shorthand: </span><span class="s2">false</span><span class="s1">,</span>
                            <span class="s1">value: </span><span class="s2">this</span><span class="s1">.convertChild(importAttribute.value),</span>
                        <span class="s1">})),</span>
                    <span class="s1">});</span>
                    <span class="s2">const </span><span class="s1">commaToken = (</span><span class="s3">0</span><span class="s1">, node_utils_1.findNextToken)(node.argument, node, </span><span class="s2">this</span><span class="s1">.ast);</span>
                    <span class="s2">const </span><span class="s1">openBraceToken = (</span><span class="s3">0</span><span class="s1">, node_utils_1.findNextToken)(commaToken, node, </span><span class="s2">this</span><span class="s1">.ast);</span>
                    <span class="s2">const </span><span class="s1">tokenAfterAttributes = (</span><span class="s3">0</span><span class="s1">, node_utils_1.findNextToken)(node.attributes, node, </span><span class="s2">this</span><span class="s1">.ast);</span>
                    <span class="s4">// Since TS 5.9, there could be a trailing comma, i.e. `{ with: { ... }, }`</span>
                    <span class="s2">const </span><span class="s1">closeBraceToken = tokenAfterAttributes.kind === ts.SyntaxKind.CommaToken</span>
                        <span class="s1">? (</span><span class="s3">0</span><span class="s1">, node_utils_1.findNextToken)(tokenAfterAttributes, node, </span><span class="s2">this</span><span class="s1">.ast)</span>
                        <span class="s1">: tokenAfterAttributes;</span>
                    <span class="s2">const </span><span class="s1">withOrAssertToken = (</span><span class="s3">0</span><span class="s1">, node_utils_1.findNextToken)(openBraceToken, node, </span><span class="s2">this</span><span class="s1">.ast);</span>
                    <span class="s2">const </span><span class="s1">withOrAssertTokenRange = (</span><span class="s3">0</span><span class="s1">, node_utils_1.getRange)(withOrAssertToken, </span><span class="s2">this</span><span class="s1">.ast);</span>
                    <span class="s2">const </span><span class="s1">withOrAssertName = withOrAssertToken.kind === ts.SyntaxKind.AssertKeyword</span>
                        <span class="s1">? </span><span class="s0">'assert'</span>
                        <span class="s1">: </span><span class="s0">'with'</span><span class="s1">;</span>
                    <span class="s1">options = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ObjectExpression,</span>
                        <span class="s1">range: [openBraceToken.getStart(</span><span class="s2">this</span><span class="s1">.ast), closeBraceToken.end],</span>
                        <span class="s1">properties: [</span>
                            <span class="s2">this</span><span class="s1">.createNode(node, {</span>
                                <span class="s1">type: ts_estree_1.AST_NODE_TYPES.Property,</span>
                                <span class="s1">range: [withOrAssertTokenRange[</span><span class="s3">0</span><span class="s1">], node.attributes.end],</span>
                                <span class="s1">computed: </span><span class="s2">false</span><span class="s1">,</span>
                                <span class="s1">key: </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.Identifier,</span>
                                    <span class="s1">range: withOrAssertTokenRange,</span>
                                    <span class="s1">decorators: [],</span>
                                    <span class="s1">name: withOrAssertName,</span>
                                    <span class="s1">optional: </span><span class="s2">false</span><span class="s1">,</span>
                                    <span class="s1">typeAnnotation: undefined,</span>
                                <span class="s1">}),</span>
                                <span class="s1">kind: </span><span class="s0">'init'</span><span class="s1">,</span>
                                <span class="s1">method: </span><span class="s2">false</span><span class="s1">,</span>
                                <span class="s1">optional: </span><span class="s2">false</span><span class="s1">,</span>
                                <span class="s1">shorthand: </span><span class="s2">false</span><span class="s1">,</span>
                                <span class="s1">value,</span>
                            <span class="s1">}),</span>
                        <span class="s1">],</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSImportType,</span>
                    <span class="s1">range,</span>
                    <span class="s1">argument: </span><span class="s2">this</span><span class="s1">.convertChild(node.argument),</span>
                    <span class="s1">options,</span>
                    <span class="s1">qualifier: </span><span class="s2">this</span><span class="s1">.convertChild(node.qualifier),</span>
                    <span class="s1">typeArguments: node.typeArguments</span>
                        <span class="s1">? </span><span class="s2">this</span><span class="s1">.convertTypeArgumentsToTypeParameterInstantiation(node.typeArguments, node)</span>
                        <span class="s1">: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">(node.isTypeOf) {</span>
                    <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSTypeQuery,</span>
                        <span class="s1">exprName: result,</span>
                        <span class="s1">typeArguments: undefined,</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">result;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.EnumDeclaration: {</span>
                <span class="s2">const </span><span class="s1">members = </span><span class="s2">this</span><span class="s1">.convertChildren(node.members);</span>
                <span class="s2">const </span><span class="s1">result = </span><span class="s2">this</span><span class="s1">.createNode(node, </span><span class="s2">this</span><span class="s1">.#withDeprecatedGetter({</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSEnumDeclaration,</span>
                    <span class="s1">body: </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSEnumBody,</span>
                        <span class="s1">range: [node.members.pos - </span><span class="s3">1</span><span class="s1">, node.end],</span>
                        <span class="s1">members,</span>
                    <span class="s1">}),</span>
                    <span class="s2">const</span><span class="s1">: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.ConstKeyword, node),</span>
                    <span class="s1">declare: (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node),</span>
                    <span class="s1">id: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                <span class="s1">}, </span><span class="s0">'members'</span><span class="s1">, </span><span class="s0">`'body.members'`</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.convertChildren(node.members)));</span>
                <span class="s2">return this</span><span class="s1">.fixExports(node, result);</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.EnumMember: {</span>
                <span class="s2">const </span><span class="s1">computed = node.name.kind === ts.SyntaxKind.ComputedPropertyName;</span>
                <span class="s2">if </span><span class="s1">(computed) {</span>
                    <span class="s2">this</span><span class="s1">.#throwUnlessAllowInvalidAST(node.name, </span><span class="s0">'Computed property names are not allowed in enums.'</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(node.name.kind === SyntaxKind.NumericLiteral ||</span>
                    <span class="s1">node.name.kind === SyntaxKind.BigIntLiteral) {</span>
                    <span class="s2">this</span><span class="s1">.#throwUnlessAllowInvalidAST(node.name, </span><span class="s0">'An enum member cannot have a numeric name.'</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, </span><span class="s2">this</span><span class="s1">.#withDeprecatedGetter({</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSEnumMember,</span>
                    <span class="s1">id: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                    <span class="s1">initializer: node.initializer &amp;&amp; </span><span class="s2">this</span><span class="s1">.convertChild(node.initializer),</span>
                <span class="s1">}, </span><span class="s0">'computed'</span><span class="s1">, undefined, computed));</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ModuleDeclaration: {</span>
                <span class="s2">let </span><span class="s1">isDeclare = (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node);</span>
                <span class="s2">const </span><span class="s1">result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSModuleDeclaration,</span>
                    <span class="s1">...(() =&gt; {</span>
                        <span class="s4">// the constraints checked by this function are syntactically enforced by TS</span>
                        <span class="s4">// the checks mostly exist for type's sake</span>
                        <span class="s2">if </span><span class="s1">(node.flags &amp; ts.NodeFlags.GlobalAugmentation) {</span>
                            <span class="s2">const </span><span class="s1">id = </span><span class="s2">this</span><span class="s1">.convertChild(node.name);</span>
                            <span class="s2">const </span><span class="s1">body = </span><span class="s2">this</span><span class="s1">.convertChild(node.body);</span>
                            <span class="s2">if </span><span class="s1">(body == </span><span class="s2">null </span><span class="s1">||</span>
                                <span class="s1">body.type === ts_estree_1.AST_NODE_TYPES.TSModuleDeclaration) {</span>
                                <span class="s2">this</span><span class="s1">.#throwUnlessAllowInvalidAST(node.body ?? node, </span><span class="s0">'Expected a valid module body'</span><span class="s1">);</span>
                            <span class="s1">}</span>
                            <span class="s2">if </span><span class="s1">(id.type !== ts_estree_1.AST_NODE_TYPES.Identifier) {</span>
                                <span class="s2">this</span><span class="s1">.#throwUnlessAllowInvalidAST(node.name, </span><span class="s0">'global module augmentation must have an Identifier id'</span><span class="s1">);</span>
                            <span class="s1">}</span>
                            <span class="s2">return </span><span class="s1">{</span>
                                <span class="s1">body: body,</span>
                                <span class="s1">declare: </span><span class="s2">false</span><span class="s1">,</span>
                                <span class="s1">global: </span><span class="s2">false</span><span class="s1">,</span>
                                <span class="s1">id,</span>
                                <span class="s1">kind: </span><span class="s0">'global'</span><span class="s1">,</span>
                            <span class="s1">};</span>
                        <span class="s1">}</span>
                        <span class="s2">if </span><span class="s1">(ts.isStringLiteral(node.name)) {</span>
                            <span class="s2">const </span><span class="s1">body = </span><span class="s2">this</span><span class="s1">.convertChild(node.body);</span>
                            <span class="s2">return </span><span class="s1">{</span>
                                <span class="s1">kind: </span><span class="s0">'module'</span><span class="s1">,</span>
                                <span class="s1">...(body != </span><span class="s2">null </span><span class="s1">? { body } : {}),</span>
                                <span class="s1">declare: </span><span class="s2">false</span><span class="s1">,</span>
                                <span class="s1">global: </span><span class="s2">false</span><span class="s1">,</span>
                                <span class="s1">id: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                            <span class="s1">};</span>
                        <span class="s1">}</span>
                        <span class="s4">// Nested module declarations are stored in TypeScript as nested tree nodes.</span>
                        <span class="s4">// We &quot;unravel&quot; them here by making our own nested TSQualifiedName,</span>
                        <span class="s4">// with the innermost node's body as the actual node body.</span>
                        <span class="s2">if </span><span class="s1">(node.body == </span><span class="s2">null</span><span class="s1">) {</span>
                            <span class="s2">this</span><span class="s1">.#throwUnlessAllowInvalidAST(node, </span><span class="s0">'Expected a module body'</span><span class="s1">);</span>
                        <span class="s1">}</span>
                        <span class="s2">if </span><span class="s1">(node.name.kind !== ts.SyntaxKind.Identifier) {</span>
                            <span class="s2">this</span><span class="s1">.#throwUnlessAllowInvalidAST(node.name, </span><span class="s0">'`namespace`s must have an Identifier id'</span><span class="s1">);</span>
                        <span class="s1">}</span>
                        <span class="s2">let </span><span class="s1">name = </span><span class="s2">this</span><span class="s1">.createNode(node.name, {</span>
                            <span class="s1">type: ts_estree_1.AST_NODE_TYPES.Identifier,</span>
                            <span class="s1">range: [node.name.getStart(</span><span class="s2">this</span><span class="s1">.ast), node.name.getEnd()],</span>
                            <span class="s1">decorators: [],</span>
                            <span class="s1">name: node.name.text,</span>
                            <span class="s1">optional: </span><span class="s2">false</span><span class="s1">,</span>
                            <span class="s1">typeAnnotation: undefined,</span>
                        <span class="s1">});</span>
                        <span class="s2">while </span><span class="s1">(node.body &amp;&amp;</span>
                            <span class="s1">ts.isModuleDeclaration(node.body) &amp;&amp;</span>
                            <span class="s1">node.body.name) {</span>
                            <span class="s1">node = node.body;</span>
                            <span class="s1">isDeclare ||= (</span><span class="s3">0</span><span class="s1">, node_utils_1.hasModifier)(SyntaxKind.DeclareKeyword, node);</span>
                            <span class="s2">const </span><span class="s1">nextName = node.name;</span>
                            <span class="s2">const </span><span class="s1">right = </span><span class="s2">this</span><span class="s1">.createNode(nextName, {</span>
                                <span class="s1">type: ts_estree_1.AST_NODE_TYPES.Identifier,</span>
                                <span class="s1">range: [nextName.getStart(</span><span class="s2">this</span><span class="s1">.ast), nextName.getEnd()],</span>
                                <span class="s1">decorators: [],</span>
                                <span class="s1">name: nextName.text,</span>
                                <span class="s1">optional: </span><span class="s2">false</span><span class="s1">,</span>
                                <span class="s1">typeAnnotation: undefined,</span>
                            <span class="s1">});</span>
                            <span class="s1">name = </span><span class="s2">this</span><span class="s1">.createNode(nextName, {</span>
                                <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSQualifiedName,</span>
                                <span class="s1">range: [name.range[</span><span class="s3">0</span><span class="s1">], right.range[</span><span class="s3">1</span><span class="s1">]],</span>
                                <span class="s1">left: name,</span>
                                <span class="s1">right,</span>
                            <span class="s1">});</span>
                        <span class="s1">}</span>
                        <span class="s2">return </span><span class="s1">{</span>
                            <span class="s1">body: </span><span class="s2">this</span><span class="s1">.convertChild(node.body),</span>
                            <span class="s1">declare: </span><span class="s2">false</span><span class="s1">,</span>
                            <span class="s1">global: </span><span class="s2">false</span><span class="s1">,</span>
                            <span class="s1">id: name,</span>
                            <span class="s1">kind: node.flags &amp; ts.NodeFlags.Namespace ? </span><span class="s0">'namespace' </span><span class="s1">: </span><span class="s0">'module'</span><span class="s1">,</span>
                        <span class="s1">};</span>
                    <span class="s1">})(),</span>
                <span class="s1">});</span>
                <span class="s1">result.declare = isDeclare;</span>
                <span class="s2">if </span><span class="s1">(node.flags &amp; ts.NodeFlags.GlobalAugmentation) {</span>
                    <span class="s4">// eslint-disable-next-line @typescript-eslint/no-deprecated</span>
                    <span class="s1">result.global = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">return this</span><span class="s1">.fixExports(node, result);</span>
            <span class="s1">}</span>
            <span class="s4">// TypeScript specific types</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ParenthesizedType: {</span>
                <span class="s2">return this</span><span class="s1">.convertChild(node.type);</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.UnionType: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSUnionType,</span>
                    <span class="s1">types: </span><span class="s2">this</span><span class="s1">.convertChildren(node.types),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.IntersectionType: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSIntersectionType,</span>
                    <span class="s1">types: </span><span class="s2">this</span><span class="s1">.convertChildren(node.types),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.AsExpression: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSAsExpression,</span>
                    <span class="s1">expression: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                    <span class="s1">typeAnnotation: </span><span class="s2">this</span><span class="s1">.convertChild(node.type),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.InferType: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSInferType,</span>
                    <span class="s1">typeParameter: </span><span class="s2">this</span><span class="s1">.convertChild(node.typeParameter),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.LiteralType: {</span>
                <span class="s2">if </span><span class="s1">(node.literal.kind === SyntaxKind.NullKeyword) {</span>
                    <span class="s4">// 4.0 started nesting null types inside a LiteralType node</span>
                    <span class="s4">// but our AST is designed around the old way of null being a keyword</span>
                    <span class="s2">return this</span><span class="s1">.createNode(node.literal, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSNullKeyword,</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSLiteralType,</span>
                    <span class="s1">literal: </span><span class="s2">this</span><span class="s1">.convertChild(node.literal),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.TypeAssertionExpression: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSTypeAssertion,</span>
                    <span class="s1">expression: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                    <span class="s1">typeAnnotation: </span><span class="s2">this</span><span class="s1">.convertChild(node.type),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ImportEqualsDeclaration: {</span>
                <span class="s2">return this</span><span class="s1">.fixExports(node, </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSImportEqualsDeclaration,</span>
                    <span class="s1">id: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                    <span class="s1">importKind: node.isTypeOnly ? </span><span class="s0">'type' </span><span class="s1">: </span><span class="s0">'value'</span><span class="s1">,</span>
                    <span class="s1">moduleReference: </span><span class="s2">this</span><span class="s1">.convertChild(node.moduleReference),</span>
                <span class="s1">}));</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ExternalModuleReference: {</span>
                <span class="s2">if </span><span class="s1">(node.expression.kind !== SyntaxKind.StringLiteral) {</span>
                    <span class="s2">this</span><span class="s1">.#throwError(node.expression, </span><span class="s0">'String literal expected.'</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSExternalModuleReference,</span>
                    <span class="s1">expression: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.NamespaceExportDeclaration: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSNamespaceExportDeclaration,</span>
                    <span class="s1">id: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.AbstractKeyword: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSAbstractKeyword,</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s4">// Tuple</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.TupleType: {</span>
                <span class="s2">const </span><span class="s1">elementTypes = </span><span class="s2">this</span><span class="s1">.convertChildren(node.elements);</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSTupleType,</span>
                    <span class="s1">elementTypes,</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.NamedTupleMember: {</span>
                <span class="s2">const </span><span class="s1">member = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSNamedTupleMember,</span>
                    <span class="s1">elementType: </span><span class="s2">this</span><span class="s1">.convertChild(node.type, node),</span>
                    <span class="s1">label: </span><span class="s2">this</span><span class="s1">.convertChild(node.name, node),</span>
                    <span class="s1">optional: node.questionToken != </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">});</span>
                <span class="s2">if </span><span class="s1">(node.dotDotDotToken) {</span>
                    <span class="s4">// adjust the start to account for the &quot;...&quot;</span>
                    <span class="s1">member.range[</span><span class="s3">0</span><span class="s1">] = member.label.range[</span><span class="s3">0</span><span class="s1">];</span>
                    <span class="s1">member.loc.start = member.label.loc.start;</span>
                    <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                        <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSRestType,</span>
                        <span class="s1">typeAnnotation: member,</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">return </span><span class="s1">member;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.OptionalType: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSOptionalType,</span>
                    <span class="s1">typeAnnotation: </span><span class="s2">this</span><span class="s1">.convertChild(node.type),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.RestType: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSRestType,</span>
                    <span class="s1">typeAnnotation: </span><span class="s2">this</span><span class="s1">.convertChild(node.type),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s4">// Template Literal Types</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.TemplateLiteralType: {</span>
                <span class="s2">const </span><span class="s1">result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSTemplateLiteralType,</span>
                    <span class="s1">quasis: [</span><span class="s2">this</span><span class="s1">.convertChild(node.head)],</span>
                    <span class="s1">types: [],</span>
                <span class="s1">});</span>
                <span class="s1">node.templateSpans.forEach(templateSpan =&gt; {</span>
                    <span class="s1">result.types.push(</span><span class="s2">this</span><span class="s1">.convertChild(templateSpan.type));</span>
                    <span class="s1">result.quasis.push(</span><span class="s2">this</span><span class="s1">.convertChild(templateSpan.literal));</span>
                <span class="s1">});</span>
                <span class="s2">return </span><span class="s1">result;</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ClassStaticBlockDeclaration: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.StaticBlock,</span>
                    <span class="s1">body: </span><span class="s2">this</span><span class="s1">.convertBodyExpressions(node.body.statements, node),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s4">// eslint-disable-next-line @typescript-eslint/no-deprecated</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.AssertEntry:</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.ImportAttribute: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ImportAttribute,</span>
                    <span class="s1">key: </span><span class="s2">this</span><span class="s1">.convertChild(node.name),</span>
                    <span class="s1">value: </span><span class="s2">this</span><span class="s1">.convertChild(node.value),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">case </span><span class="s1">SyntaxKind.SatisfiesExpression: {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.TSSatisfiesExpression,</span>
                    <span class="s1">expression: </span><span class="s2">this</span><span class="s1">.convertChild(node.expression),</span>
                    <span class="s1">typeAnnotation: </span><span class="s2">this</span><span class="s1">.convertChild(node.type),</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">default</span><span class="s1">:</span>
                <span class="s2">return this</span><span class="s1">.deeplyCopy(node);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">createNode(node, data) {</span>
        <span class="s2">const </span><span class="s1">result = data;</span>
        <span class="s1">result.range ??= (</span><span class="s3">0</span><span class="s1">, node_utils_1.getRange)(node, </span><span class="s2">this</span><span class="s1">.ast);</span>
        <span class="s1">result.loc ??= (</span><span class="s3">0</span><span class="s1">, node_utils_1.getLocFor)(result.range, </span><span class="s2">this</span><span class="s1">.ast);</span>
        <span class="s2">if </span><span class="s1">(result &amp;&amp; </span><span class="s2">this</span><span class="s1">.options.shouldPreserveNodeMaps) {</span>
            <span class="s2">this</span><span class="s1">.esTreeNodeToTSNodeMap.set(result, node);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>
    <span class="s1">convertProgram() {</span>
        <span class="s2">return this</span><span class="s1">.converter(</span><span class="s2">this</span><span class="s1">.ast);</span>
    <span class="s1">}</span>
    <span class="s4">/**</span>
     <span class="s4">* For nodes that are copied directly from the TypeScript AST into</span>
     <span class="s4">* ESTree mostly as-is. The only difference is the addition of a type</span>
     <span class="s4">* property instead of a kind property. Recursively copies all children.</span>
     <span class="s4">*/</span>
    <span class="s1">deeplyCopy(node) {</span>
        <span class="s2">if </span><span class="s1">(node.kind === ts.SyntaxKind.JSDocFunctionType) {</span>
            <span class="s2">this</span><span class="s1">.#throwError(node, </span><span class="s0">'JSDoc types can only be used inside documentation comments.'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">customType = </span><span class="s0">`TS</span><span class="s1">${SyntaxKind[node.kind]}</span><span class="s0">`</span><span class="s1">;</span>
        <span class="s4">/**</span>
         <span class="s4">* If the &quot;errorOnUnknownASTType&quot; option is set to true, throw an error,</span>
         <span class="s4">* otherwise fallback to just including the unknown type as-is.</span>
         <span class="s4">*/</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.options.errorOnUnknownASTType &amp;&amp; !ts_estree_1.AST_NODE_TYPES[customType]) {</span>
            <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">`Unknown AST_NODE_TYPE: &quot;</span><span class="s1">${customType}</span><span class="s0">&quot;`</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">result = </span><span class="s2">this</span><span class="s1">.createNode(node, {</span>
            <span class="s1">type: customType,</span>
        <span class="s1">});</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s0">'type' </span><span class="s2">in </span><span class="s1">node) {</span>
            <span class="s1">result.typeAnnotation =</span>
                <span class="s1">node.type &amp;&amp; </span><span class="s0">'kind' </span><span class="s2">in </span><span class="s1">node.type &amp;&amp; ts.isTypeNode(node.type)</span>
                    <span class="s1">? </span><span class="s2">this</span><span class="s1">.convertTypeAnnotation(node.type, node)</span>
                    <span class="s1">: </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s0">'typeArguments' </span><span class="s2">in </span><span class="s1">node) {</span>
            <span class="s1">result.typeArguments =</span>
                <span class="s1">node.typeArguments &amp;&amp; </span><span class="s0">'pos' </span><span class="s2">in </span><span class="s1">node.typeArguments</span>
                    <span class="s1">? </span><span class="s2">this</span><span class="s1">.convertTypeArgumentsToTypeParameterInstantiation(node.typeArguments, node)</span>
                    <span class="s1">: </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s0">'typeParameters' </span><span class="s2">in </span><span class="s1">node) {</span>
            <span class="s1">result.typeParameters =</span>
                <span class="s1">node.typeParameters &amp;&amp; </span><span class="s0">'pos' </span><span class="s2">in </span><span class="s1">node.typeParameters</span>
                    <span class="s1">? </span><span class="s2">this</span><span class="s1">.convertTSTypeParametersToTypeParametersDeclaration(node.typeParameters)</span>
                    <span class="s1">: </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">decorators = (</span><span class="s3">0</span><span class="s1">, getModifiers_1.getDecorators)(node);</span>
        <span class="s2">if </span><span class="s1">(decorators?.length) {</span>
            <span class="s1">result.decorators = </span><span class="s2">this</span><span class="s1">.convertChildren(decorators);</span>
        <span class="s1">}</span>
        <span class="s4">// keys we never want to clone from the base typescript node as they</span>
        <span class="s4">// introduce garbage into our AST</span>
        <span class="s2">const </span><span class="s1">KEYS_TO_NOT_COPY = </span><span class="s2">new </span><span class="s1">Set([</span>
            <span class="s0">'_children'</span><span class="s1">,</span>
            <span class="s0">'decorators'</span><span class="s1">,</span>
            <span class="s0">'end'</span><span class="s1">,</span>
            <span class="s0">'flags'</span><span class="s1">,</span>
            <span class="s0">'heritageClauses'</span><span class="s1">,</span>
            <span class="s0">'illegalDecorators'</span><span class="s1">,</span>
            <span class="s0">'jsDoc'</span><span class="s1">,</span>
            <span class="s0">'kind'</span><span class="s1">,</span>
            <span class="s0">'locals'</span><span class="s1">,</span>
            <span class="s0">'localSymbol'</span><span class="s1">,</span>
            <span class="s0">'modifierFlagsCache'</span><span class="s1">,</span>
            <span class="s0">'modifiers'</span><span class="s1">,</span>
            <span class="s0">'nextContainer'</span><span class="s1">,</span>
            <span class="s0">'parent'</span><span class="s1">,</span>
            <span class="s0">'pos'</span><span class="s1">,</span>
            <span class="s0">'symbol'</span><span class="s1">,</span>
            <span class="s0">'transformFlags'</span><span class="s1">,</span>
            <span class="s0">'type'</span><span class="s1">,</span>
            <span class="s0">'typeArguments'</span><span class="s1">,</span>
            <span class="s0">'typeParameters'</span><span class="s1">,</span>
        <span class="s1">]);</span>
        <span class="s1">Object.entries(node)</span>
            <span class="s1">.filter(([key]) =&gt; !KEYS_TO_NOT_COPY.has(key))</span>
            <span class="s1">.forEach(([key, value]) =&gt; {</span>
            <span class="s2">if </span><span class="s1">(Array.isArray(value)) {</span>
                <span class="s1">result[key] = </span><span class="s2">this</span><span class="s1">.convertChildren(value);</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(value &amp;&amp; </span><span class="s2">typeof </span><span class="s1">value === </span><span class="s0">'object' </span><span class="s1">&amp;&amp; value.kind) {</span>
                <span class="s4">// need to check node[key].kind to ensure we don't try to convert a symbol</span>
                <span class="s1">result[key] = </span><span class="s2">this</span><span class="s1">.convertChild(value);</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">result[key] = value;</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>
    <span class="s4">/**</span>
     <span class="s4">* Fixes the exports of the given ts.Node</span>
     <span class="s4">* </span><span class="s5">@returns </span><span class="s4">the ESTreeNode with fixed exports</span>
     <span class="s4">*/</span>
    <span class="s1">fixExports(node, result) {</span>
        <span class="s2">const </span><span class="s1">isNamespaceNode = ts.isModuleDeclaration(node) &amp;&amp; !ts.isStringLiteral(node.name);</span>
        <span class="s2">const </span><span class="s1">modifiers = isNamespaceNode</span>
            <span class="s1">? (</span><span class="s3">0</span><span class="s1">, node_utils_1.getNamespaceModifiers)(node)</span>
            <span class="s1">: (</span><span class="s3">0</span><span class="s1">, getModifiers_1.getModifiers)(node);</span>
        <span class="s2">if </span><span class="s1">(modifiers?.[</span><span class="s3">0</span><span class="s1">].kind === SyntaxKind.ExportKeyword) {</span>
            <span class="s4">/**</span>
             <span class="s4">* Make sure that original node is registered instead of export</span>
             <span class="s4">*/</span>
            <span class="s2">this</span><span class="s1">.registerTSNodeInNodeMap(node, result);</span>
            <span class="s2">const </span><span class="s1">exportKeyword = modifiers[</span><span class="s3">0</span><span class="s1">];</span>
            <span class="s2">const </span><span class="s1">nextModifier = modifiers[</span><span class="s3">1</span><span class="s1">];</span>
            <span class="s2">const </span><span class="s1">declarationIsDefault = nextModifier?.kind === SyntaxKind.DefaultKeyword;</span>
            <span class="s2">const </span><span class="s1">varToken = declarationIsDefault</span>
                <span class="s1">? (</span><span class="s3">0</span><span class="s1">, node_utils_1.findNextToken)(nextModifier, </span><span class="s2">this</span><span class="s1">.ast, </span><span class="s2">this</span><span class="s1">.ast)</span>
                <span class="s1">: (</span><span class="s3">0</span><span class="s1">, node_utils_1.findNextToken)(exportKeyword, </span><span class="s2">this</span><span class="s1">.ast, </span><span class="s2">this</span><span class="s1">.ast);</span>
            <span class="s1">result.range[</span><span class="s3">0</span><span class="s1">] = varToken.getStart(</span><span class="s2">this</span><span class="s1">.ast);</span>
            <span class="s1">result.loc = (</span><span class="s3">0</span><span class="s1">, node_utils_1.getLocFor)(result.range, </span><span class="s2">this</span><span class="s1">.ast);</span>
            <span class="s2">if </span><span class="s1">(declarationIsDefault) {</span>
                <span class="s2">return this</span><span class="s1">.createNode(node, {</span>
                    <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ExportDefaultDeclaration,</span>
                    <span class="s1">range: [exportKeyword.getStart(</span><span class="s2">this</span><span class="s1">.ast), result.range[</span><span class="s3">1</span><span class="s1">]],</span>
                    <span class="s1">declaration: result,</span>
                    <span class="s1">exportKind: </span><span class="s0">'value'</span><span class="s1">,</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">isType = result.type === ts_estree_1.AST_NODE_TYPES.TSInterfaceDeclaration ||</span>
                <span class="s1">result.type === ts_estree_1.AST_NODE_TYPES.TSTypeAliasDeclaration;</span>
            <span class="s2">const </span><span class="s1">isDeclare = </span><span class="s0">'declare' </span><span class="s2">in </span><span class="s1">result &amp;&amp; result.declare;</span>
            <span class="s2">return this</span><span class="s1">.createNode(node, </span>
            <span class="s4">// @ts-expect-error - TODO, narrow the types here</span>
            <span class="s2">this</span><span class="s1">.#withDeprecatedAliasGetter({</span>
                <span class="s1">type: ts_estree_1.AST_NODE_TYPES.ExportNamedDeclaration,</span>
                <span class="s1">range: [exportKeyword.getStart(</span><span class="s2">this</span><span class="s1">.ast), result.range[</span><span class="s3">1</span><span class="s1">]],</span>
                <span class="s1">attributes: [],</span>
                <span class="s1">declaration: result,</span>
                <span class="s1">exportKind: isType || isDeclare ? </span><span class="s0">'type' </span><span class="s1">: </span><span class="s0">'value'</span><span class="s1">,</span>
                <span class="s1">source: </span><span class="s2">null</span><span class="s1">,</span>
                <span class="s1">specifiers: [],</span>
            <span class="s1">}, </span><span class="s0">'assertions'</span><span class="s1">, </span><span class="s0">'attributes'</span><span class="s1">, </span><span class="s2">true</span><span class="s1">));</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>
    <span class="s1">getASTMaps() {</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">esTreeNodeToTSNodeMap: </span><span class="s2">this</span><span class="s1">.esTreeNodeToTSNodeMap,</span>
            <span class="s1">tsNodeToESTreeNodeMap: </span><span class="s2">this</span><span class="s1">.tsNodeToESTreeNodeMap,</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s4">/**</span>
     <span class="s4">* Register specific TypeScript node into map with first ESTree node provided</span>
     <span class="s4">*/</span>
    <span class="s1">registerTSNodeInNodeMap(node, result) {</span>
        <span class="s2">if </span><span class="s1">(result &amp;&amp;</span>
            <span class="s2">this</span><span class="s1">.options.shouldPreserveNodeMaps &amp;&amp;</span>
            <span class="s1">!</span><span class="s2">this</span><span class="s1">.tsNodeToESTreeNodeMap.has(node)) {</span>
            <span class="s2">this</span><span class="s1">.tsNodeToESTreeNodeMap.set(node, result);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">exports.Converter = Converter;</span>
</pre>
</body>
</html>