<html>
<head>
<title>unpack.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
unpack.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;unpack.js&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/unpack.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// the PEND/UNPEND stuff tracks whether we're ready to emit end/close yet.</span><span class="s3">\n</span><span class="s1">// but the path reservations are required to avoid race conditions where</span><span class="s3">\n</span><span class="s1">// parallelized unpack ops may mess with one another, due to dependencies</span><span class="s3">\n</span><span class="s1">// (like a Link depending on its target) or destructive operations (like</span><span class="s3">\n</span><span class="s1">// clobbering an fs object to create one of a different type.)</span><span class="s3">\n\n</span><span class="s1">import * as fsm from '@isaacs/fs-minipass'</span><span class="s3">\n</span><span class="s1">import assert from 'node:assert'</span><span class="s3">\n</span><span class="s1">import { randomBytes } from 'node:crypto'</span><span class="s3">\n</span><span class="s1">import fs, { type Stats } from 'node:fs'</span><span class="s3">\n</span><span class="s1">import path from 'node:path'</span><span class="s3">\n</span><span class="s1">import { getWriteFlag } from './get-write-flag.js'</span><span class="s3">\n</span><span class="s1">import { mkdir, MkdirError, mkdirSync } from './mkdir.js'</span><span class="s3">\n</span><span class="s1">import { normalizeWindowsPath } from './normalize-windows-path.js'</span><span class="s3">\n</span><span class="s1">import { Parser } from './parse.js'</span><span class="s3">\n</span><span class="s1">import { stripAbsolutePath } from './strip-absolute-path.js'</span><span class="s3">\n</span><span class="s1">import * as wc from './winchars.js'</span><span class="s3">\n\n</span><span class="s1">import { TarOptions } from './options.js'</span><span class="s3">\n</span><span class="s1">import { PathReservations } from './path-reservations.js'</span><span class="s3">\n</span><span class="s1">import { ReadEntry } from './read-entry.js'</span><span class="s3">\n</span><span class="s1">import { WarnData } from './warn-method.js'</span><span class="s3">\n\n</span><span class="s1">const ONENTRY = Symbol('onEntry')</span><span class="s3">\n</span><span class="s1">const CHECKFS = Symbol('checkFs')</span><span class="s3">\n</span><span class="s1">const CHECKFS2 = Symbol('checkFs2')</span><span class="s3">\n</span><span class="s1">const ISREUSABLE = Symbol('isReusable')</span><span class="s3">\n</span><span class="s1">const MAKEFS = Symbol('makeFs')</span><span class="s3">\n</span><span class="s1">const FILE = Symbol('file')</span><span class="s3">\n</span><span class="s1">const DIRECTORY = Symbol('directory')</span><span class="s3">\n</span><span class="s1">const LINK = Symbol('link')</span><span class="s3">\n</span><span class="s1">const SYMLINK = Symbol('symlink')</span><span class="s3">\n</span><span class="s1">const HARDLINK = Symbol('hardlink')</span><span class="s3">\n</span><span class="s1">const UNSUPPORTED = Symbol('unsupported')</span><span class="s3">\n</span><span class="s1">const CHECKPATH = Symbol('checkPath')</span><span class="s3">\n</span><span class="s1">const MKDIR = Symbol('mkdir')</span><span class="s3">\n</span><span class="s1">const ONERROR = Symbol('onError')</span><span class="s3">\n</span><span class="s1">const PENDING = Symbol('pending')</span><span class="s3">\n</span><span class="s1">const PEND = Symbol('pend')</span><span class="s3">\n</span><span class="s1">const UNPEND = Symbol('unpend')</span><span class="s3">\n</span><span class="s1">const ENDED = Symbol('ended')</span><span class="s3">\n</span><span class="s1">const MAYBECLOSE = Symbol('maybeClose')</span><span class="s3">\n</span><span class="s1">const SKIP = Symbol('skip')</span><span class="s3">\n</span><span class="s1">const DOCHOWN = Symbol('doChown')</span><span class="s3">\n</span><span class="s1">const UID = Symbol('uid')</span><span class="s3">\n</span><span class="s1">const GID = Symbol('gid')</span><span class="s3">\n</span><span class="s1">const CHECKED_CWD = Symbol('checkedCwd')</span><span class="s3">\n</span><span class="s1">const platform =</span><span class="s3">\n  </span><span class="s1">process.env.TESTING_TAR_FAKE_PLATFORM || process.platform</span><span class="s3">\n</span><span class="s1">const isWindows = platform === 'win32'</span><span class="s3">\n</span><span class="s1">const DEFAULT_MAX_DEPTH = 1024</span><span class="s3">\n\n</span><span class="s1">// Unlinks on Windows are not atomic.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// This means that if you have a file entry, followed by another</span><span class="s3">\n</span><span class="s1">// file entry with an identical name, and you cannot re-use the file</span><span class="s3">\n</span><span class="s1">// (because it's a hardlink, or because unlink:true is set, or it's</span><span class="s3">\n</span><span class="s1">// Windows, which does not have useful nlink values), then the unlink</span><span class="s3">\n</span><span class="s1">// will be committed to the disk AFTER the new file has been written</span><span class="s3">\n</span><span class="s1">// over the old one, deleting the new file.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// To work around this, on Windows systems, we rename the file and then</span><span class="s3">\n</span><span class="s1">// delete the renamed file.  It's a sloppy kludge, but frankly, I do not</span><span class="s3">\n</span><span class="s1">// know of a better way to do this, given windows' non-atomic unlink</span><span class="s3">\n</span><span class="s1">// semantics.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// See: https://github.com/npm/node-tar/issues/183</span><span class="s3">\n</span><span class="s1">/* c8 ignore start */</span><span class="s3">\n</span><span class="s1">const unlinkFile = (</span><span class="s3">\n  </span><span class="s1">path: string,</span><span class="s3">\n  </span><span class="s1">cb: (er?: Error | null) =&gt; void,</span><span class="s3">\n</span><span class="s1">) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (!isWindows) {</span><span class="s3">\n    </span><span class="s1">return fs.unlink(path, cb)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const name = path + '.DELETE.' + randomBytes(16).toString('hex')</span><span class="s3">\n  </span><span class="s1">fs.rename(path, name, er =&gt; {</span><span class="s3">\n    </span><span class="s1">if (er) {</span><span class="s3">\n      </span><span class="s1">return cb(er)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">fs.unlink(name, cb)</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n\n</span><span class="s1">/* c8 ignore start */</span><span class="s3">\n</span><span class="s1">const unlinkFileSync = (path: string) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (!isWindows) {</span><span class="s3">\n    </span><span class="s1">return fs.unlinkSync(path)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const name = path + '.DELETE.' + randomBytes(16).toString('hex')</span><span class="s3">\n  </span><span class="s1">fs.renameSync(path, name)</span><span class="s3">\n  </span><span class="s1">fs.unlinkSync(name)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n\n</span><span class="s1">// this.gid, entry.gid, this.processUid</span><span class="s3">\n</span><span class="s1">const uint32 = (</span><span class="s3">\n  </span><span class="s1">a: number | undefined,</span><span class="s3">\n  </span><span class="s1">b: number | undefined,</span><span class="s3">\n  </span><span class="s1">c: number | undefined,</span><span class="s3">\n</span><span class="s1">) =&gt;</span><span class="s3">\n  </span><span class="s1">a !== undefined &amp;&amp; a === a &gt;&gt;&gt; 0 ? a</span><span class="s3">\n  </span><span class="s1">: b !== undefined &amp;&amp; b === b &gt;&gt;&gt; 0 ? b</span><span class="s3">\n  </span><span class="s1">: c</span><span class="s3">\n\n</span><span class="s1">export class Unpack extends Parser {</span><span class="s3">\n  </span><span class="s1">[ENDED]: boolean = false;</span><span class="s3">\n  </span><span class="s1">[CHECKED_CWD]: boolean = false;</span><span class="s3">\n  </span><span class="s1">[PENDING]: number = 0</span><span class="s3">\n\n  </span><span class="s1">reservations: PathReservations = new PathReservations()</span><span class="s3">\n  </span><span class="s1">transform?: TarOptions['transform']</span><span class="s3">\n  </span><span class="s1">writable: true = true</span><span class="s3">\n  </span><span class="s1">readable: false = false</span><span class="s3">\n  </span><span class="s1">uid?: number</span><span class="s3">\n  </span><span class="s1">gid?: number</span><span class="s3">\n  </span><span class="s1">setOwner: boolean</span><span class="s3">\n  </span><span class="s1">preserveOwner: boolean</span><span class="s3">\n  </span><span class="s1">processGid?: number</span><span class="s3">\n  </span><span class="s1">processUid?: number</span><span class="s3">\n  </span><span class="s1">maxDepth: number</span><span class="s3">\n  </span><span class="s1">forceChown: boolean</span><span class="s3">\n  </span><span class="s1">win32: boolean</span><span class="s3">\n  </span><span class="s1">newer: boolean</span><span class="s3">\n  </span><span class="s1">keep: boolean</span><span class="s3">\n  </span><span class="s1">noMtime: boolean</span><span class="s3">\n  </span><span class="s1">preservePaths: boolean</span><span class="s3">\n  </span><span class="s1">unlink: boolean</span><span class="s3">\n  </span><span class="s1">cwd: string</span><span class="s3">\n  </span><span class="s1">strip: number</span><span class="s3">\n  </span><span class="s1">processUmask: number</span><span class="s3">\n  </span><span class="s1">umask: number</span><span class="s3">\n  </span><span class="s1">dmode: number</span><span class="s3">\n  </span><span class="s1">fmode: number</span><span class="s3">\n  </span><span class="s1">chmod: boolean</span><span class="s3">\n\n  </span><span class="s1">constructor(opt: TarOptions = {}) {</span><span class="s3">\n    </span><span class="s1">opt.ondone = () =&gt; {</span><span class="s3">\n      </span><span class="s1">this[ENDED] = true</span><span class="s3">\n      </span><span class="s1">this[MAYBECLOSE]()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">super(opt)</span><span class="s3">\n\n    </span><span class="s1">this.transform = opt.transform</span><span class="s3">\n\n    </span><span class="s1">this.chmod = !!opt.chmod</span><span class="s3">\n\n    </span><span class="s1">if (typeof opt.uid === 'number' || typeof opt.gid === 'number') {</span><span class="s3">\n      </span><span class="s1">// need both or neither</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">typeof opt.uid !== 'number' ||</span><span class="s3">\n        </span><span class="s1">typeof opt.gid !== 'number'</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">throw new TypeError(</span><span class="s3">\n          </span><span class="s1">'cannot set owner without number uid and gid',</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (opt.preserveOwner) {</span><span class="s3">\n        </span><span class="s1">throw new TypeError(</span><span class="s3">\n          </span><span class="s1">'cannot preserve owner in archive and also set owner explicitly',</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">this.uid = opt.uid</span><span class="s3">\n      </span><span class="s1">this.gid = opt.gid</span><span class="s3">\n      </span><span class="s1">this.setOwner = true</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this.uid = undefined</span><span class="s3">\n      </span><span class="s1">this.gid = undefined</span><span class="s3">\n      </span><span class="s1">this.setOwner = false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// default true for root</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">opt.preserveOwner === undefined &amp;&amp;</span><span class="s3">\n      </span><span class="s1">typeof opt.uid !== 'number'</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">this.preserveOwner = !!(</span><span class="s3">\n        </span><span class="s1">process.getuid &amp;&amp; process.getuid() === 0</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this.preserveOwner = !!opt.preserveOwner</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.processUid =</span><span class="s3">\n      </span><span class="s1">(this.preserveOwner || this.setOwner) &amp;&amp; process.getuid ?</span><span class="s3">\n        </span><span class="s1">process.getuid()</span><span class="s3">\n      </span><span class="s1">: undefined</span><span class="s3">\n    </span><span class="s1">this.processGid =</span><span class="s3">\n      </span><span class="s1">(this.preserveOwner || this.setOwner) &amp;&amp; process.getgid ?</span><span class="s3">\n        </span><span class="s1">process.getgid()</span><span class="s3">\n      </span><span class="s1">: undefined</span><span class="s3">\n\n    </span><span class="s1">// prevent excessively deep nesting of subfolders</span><span class="s3">\n    </span><span class="s1">// set to `Infinity` to remove this restriction</span><span class="s3">\n    </span><span class="s1">this.maxDepth =</span><span class="s3">\n      </span><span class="s1">typeof opt.maxDepth === 'number' ?</span><span class="s3">\n        </span><span class="s1">opt.maxDepth</span><span class="s3">\n      </span><span class="s1">: DEFAULT_MAX_DEPTH</span><span class="s3">\n\n    </span><span class="s1">// mostly just for testing, but useful in some cases.</span><span class="s3">\n    </span><span class="s1">// Forcibly trigger a chown on every entry, no matter what</span><span class="s3">\n    </span><span class="s1">this.forceChown = opt.forceChown === true</span><span class="s3">\n\n    </span><span class="s1">// turn &gt;&lt;?| in filenames into 0xf000-higher encoded forms</span><span class="s3">\n    </span><span class="s1">this.win32 = !!opt.win32 || isWindows</span><span class="s3">\n\n    </span><span class="s1">// do not unpack over files that are newer than what's in the archive</span><span class="s3">\n    </span><span class="s1">this.newer = !!opt.newer</span><span class="s3">\n\n    </span><span class="s1">// do not unpack over ANY files</span><span class="s3">\n    </span><span class="s1">this.keep = !!opt.keep</span><span class="s3">\n\n    </span><span class="s1">// do not set mtime/atime of extracted entries</span><span class="s3">\n    </span><span class="s1">this.noMtime = !!opt.noMtime</span><span class="s3">\n\n    </span><span class="s1">// allow .., absolute path entries, and unpacking through symlinks</span><span class="s3">\n    </span><span class="s1">// without this, warn and skip .., relativize absolutes, and error</span><span class="s3">\n    </span><span class="s1">// on symlinks in extraction path</span><span class="s3">\n    </span><span class="s1">this.preservePaths = !!opt.preservePaths</span><span class="s3">\n\n    </span><span class="s1">// unlink files and links before writing. This breaks existing hard</span><span class="s3">\n    </span><span class="s1">// links, and removes symlink directories rather than erroring</span><span class="s3">\n    </span><span class="s1">this.unlink = !!opt.unlink</span><span class="s3">\n\n    </span><span class="s1">this.cwd = normalizeWindowsPath(</span><span class="s3">\n      </span><span class="s1">path.resolve(opt.cwd || process.cwd()),</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">this.strip = Number(opt.strip) || 0</span><span class="s3">\n    </span><span class="s1">// if we're not chmodding, then we don't need the process umask</span><span class="s3">\n    </span><span class="s1">this.processUmask =</span><span class="s3">\n      </span><span class="s1">!this.chmod ? 0</span><span class="s3">\n      </span><span class="s1">: typeof opt.processUmask === 'number' ? opt.processUmask</span><span class="s3">\n      </span><span class="s1">: process.umask()</span><span class="s3">\n    </span><span class="s1">this.umask =</span><span class="s3">\n      </span><span class="s1">typeof opt.umask === 'number' ? opt.umask : this.processUmask</span><span class="s3">\n\n    </span><span class="s1">// default mode for dirs created as parents</span><span class="s3">\n    </span><span class="s1">this.dmode = opt.dmode || 0o0777 &amp; ~this.umask</span><span class="s3">\n    </span><span class="s1">this.fmode = opt.fmode || 0o0666 &amp; ~this.umask</span><span class="s3">\n\n    </span><span class="s1">this.on('entry', entry =&gt; this[ONENTRY](entry))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// a bad or damaged archive is a warning for Parser, but an error</span><span class="s3">\n  </span><span class="s1">// when extracting.  Mark those errors as unrecoverable, because</span><span class="s3">\n  </span><span class="s1">// the Unpack contract cannot be met.</span><span class="s3">\n  </span><span class="s1">warn(code: string, msg: string | Error, data: WarnData = {}) {</span><span class="s3">\n    </span><span class="s1">if (code === 'TAR_BAD_ARCHIVE' || code === 'TAR_ABORT') {</span><span class="s3">\n      </span><span class="s1">data.recoverable = false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return super.warn(code, msg, data)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[MAYBECLOSE]() {</span><span class="s3">\n    </span><span class="s1">if (this[ENDED] &amp;&amp; this[PENDING] === 0) {</span><span class="s3">\n      </span><span class="s1">this.emit('prefinish')</span><span class="s3">\n      </span><span class="s1">this.emit('finish')</span><span class="s3">\n      </span><span class="s1">this.emit('end')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[CHECKPATH](entry: ReadEntry) {</span><span class="s3">\n    </span><span class="s1">const p = normalizeWindowsPath(entry.path)</span><span class="s3">\n    </span><span class="s1">const parts = p.split('/')</span><span class="s3">\n\n    </span><span class="s1">if (this.strip) {</span><span class="s3">\n      </span><span class="s1">if (parts.length &lt; this.strip) {</span><span class="s3">\n        </span><span class="s1">return false</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (entry.type === 'Link') {</span><span class="s3">\n        </span><span class="s1">const linkparts = normalizeWindowsPath(</span><span class="s3">\n          </span><span class="s1">String(entry.linkpath),</span><span class="s3">\n        </span><span class="s1">).split('/')</span><span class="s3">\n        </span><span class="s1">if (linkparts.length &gt;= this.strip) {</span><span class="s3">\n          </span><span class="s1">entry.linkpath = linkparts.slice(this.strip).join('/')</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">return false</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">parts.splice(0, this.strip)</span><span class="s3">\n      </span><span class="s1">entry.path = parts.join('/')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (isFinite(this.maxDepth) &amp;&amp; parts.length &gt; this.maxDepth) {</span><span class="s3">\n      </span><span class="s1">this.warn('TAR_ENTRY_ERROR', 'path excessively deep', {</span><span class="s3">\n        </span><span class="s1">entry,</span><span class="s3">\n        </span><span class="s1">path: p,</span><span class="s3">\n        </span><span class="s1">depth: parts.length,</span><span class="s3">\n        </span><span class="s1">maxDepth: this.maxDepth,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!this.preservePaths) {</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">parts.includes('..') ||</span><span class="s3">\n        </span><span class="s1">/* c8 ignore next */</span><span class="s3">\n        </span><span class="s1">(isWindows &amp;&amp; /^[a-z]:</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">.$/i.test(parts[0] ?? ''))</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">this.warn('TAR_ENTRY_ERROR', `path contains '..'`, {</span><span class="s3">\n          </span><span class="s1">entry,</span><span class="s3">\n          </span><span class="s1">path: p,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">return false</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// strip off the root</span><span class="s3">\n      </span><span class="s1">const [root, stripped] = stripAbsolutePath(p)</span><span class="s3">\n      </span><span class="s1">if (root) {</span><span class="s3">\n        </span><span class="s1">entry.path = String(stripped)</span><span class="s3">\n        </span><span class="s1">this.warn(</span><span class="s3">\n          </span><span class="s1">'TAR_ENTRY_INFO',</span><span class="s3">\n          </span><span class="s1">`stripping ${root} from absolute path`,</span><span class="s3">\n          </span><span class="s1">{</span><span class="s3">\n            </span><span class="s1">entry,</span><span class="s3">\n            </span><span class="s1">path: p,</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (path.isAbsolute(entry.path)) {</span><span class="s3">\n      </span><span class="s1">entry.absolute = normalizeWindowsPath(path.resolve(entry.path))</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">entry.absolute = normalizeWindowsPath(</span><span class="s3">\n        </span><span class="s1">path.resolve(this.cwd, entry.path),</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// if we somehow ended up with a path that escapes the cwd, and we are</span><span class="s3">\n    </span><span class="s1">// not in preservePaths mode, then something is fishy!  This should have</span><span class="s3">\n    </span><span class="s1">// been prevented above, so ignore this for coverage.</span><span class="s3">\n    </span><span class="s1">/* c8 ignore start - defense in depth */</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!this.preservePaths &amp;&amp;</span><span class="s3">\n      </span><span class="s1">typeof entry.absolute === 'string' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">entry.absolute.indexOf(this.cwd + '/') !== 0 &amp;&amp;</span><span class="s3">\n      </span><span class="s1">entry.absolute !== this.cwd</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">this.warn('TAR_ENTRY_ERROR', 'path escaped extraction target', {</span><span class="s3">\n        </span><span class="s1">entry,</span><span class="s3">\n        </span><span class="s1">path: normalizeWindowsPath(entry.path),</span><span class="s3">\n        </span><span class="s1">resolvedPath: entry.absolute,</span><span class="s3">\n        </span><span class="s1">cwd: this.cwd,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n\n    </span><span class="s1">// an archive can set properties on the extraction directory, but it</span><span class="s3">\n    </span><span class="s1">// may not replace the cwd with a different kind of thing entirely.</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">entry.absolute === this.cwd &amp;&amp;</span><span class="s3">\n      </span><span class="s1">entry.type !== 'Directory' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">entry.type !== 'GNUDumpDir'</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// only encode : chars that aren't drive letter indicators</span><span class="s3">\n    </span><span class="s1">if (this.win32) {</span><span class="s3">\n      </span><span class="s1">const { root: aRoot } = path.win32.parse(String(entry.absolute))</span><span class="s3">\n      </span><span class="s1">entry.absolute =</span><span class="s3">\n        </span><span class="s1">aRoot + wc.encode(String(entry.absolute).slice(aRoot.length))</span><span class="s3">\n      </span><span class="s1">const { root: pRoot } = path.win32.parse(entry.path)</span><span class="s3">\n      </span><span class="s1">entry.path = pRoot + wc.encode(entry.path.slice(pRoot.length))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[ONENTRY](entry: ReadEntry) {</span><span class="s3">\n    </span><span class="s1">if (!this[CHECKPATH](entry)) {</span><span class="s3">\n      </span><span class="s1">return entry.resume()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">assert.equal(typeof entry.absolute, 'string')</span><span class="s3">\n\n    </span><span class="s1">switch (entry.type) {</span><span class="s3">\n      </span><span class="s1">case 'Directory':</span><span class="s3">\n      </span><span class="s1">case 'GNUDumpDir':</span><span class="s3">\n        </span><span class="s1">if (entry.mode) {</span><span class="s3">\n          </span><span class="s1">entry.mode = entry.mode | 0o700</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// eslint-disable-next-line no-fallthrough</span><span class="s3">\n      </span><span class="s1">case 'File':</span><span class="s3">\n      </span><span class="s1">case 'OldFile':</span><span class="s3">\n      </span><span class="s1">case 'ContiguousFile':</span><span class="s3">\n      </span><span class="s1">case 'Link':</span><span class="s3">\n      </span><span class="s1">case 'SymbolicLink':</span><span class="s3">\n        </span><span class="s1">return this[CHECKFS](entry)</span><span class="s3">\n\n      </span><span class="s1">case 'CharacterDevice':</span><span class="s3">\n      </span><span class="s1">case 'BlockDevice':</span><span class="s3">\n      </span><span class="s1">case 'FIFO':</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">return this[UNSUPPORTED](entry)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[ONERROR](er: Error, entry: ReadEntry) {</span><span class="s3">\n    </span><span class="s1">// Cwd has to exist, or else nothing works. That's serious.</span><span class="s3">\n    </span><span class="s1">// Other errors are warnings, which raise the error in strict</span><span class="s3">\n    </span><span class="s1">// mode, but otherwise continue on.</span><span class="s3">\n    </span><span class="s1">if (er.name === 'CwdError') {</span><span class="s3">\n      </span><span class="s1">this.emit('error', er)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this.warn('TAR_ENTRY_ERROR', er, { entry })</span><span class="s3">\n      </span><span class="s1">this[UNPEND]()</span><span class="s3">\n      </span><span class="s1">entry.resume()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[MKDIR](</span><span class="s3">\n    </span><span class="s1">dir: string,</span><span class="s3">\n    </span><span class="s1">mode: number,</span><span class="s3">\n    </span><span class="s1">cb: (er?: null | MkdirError, made?: string) =&gt; void,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">mkdir(</span><span class="s3">\n      </span><span class="s1">normalizeWindowsPath(dir),</span><span class="s3">\n      </span><span class="s1">{</span><span class="s3">\n        </span><span class="s1">uid: this.uid,</span><span class="s3">\n        </span><span class="s1">gid: this.gid,</span><span class="s3">\n        </span><span class="s1">processUid: this.processUid,</span><span class="s3">\n        </span><span class="s1">processGid: this.processGid,</span><span class="s3">\n        </span><span class="s1">umask: this.processUmask,</span><span class="s3">\n        </span><span class="s1">preserve: this.preservePaths,</span><span class="s3">\n        </span><span class="s1">unlink: this.unlink,</span><span class="s3">\n        </span><span class="s1">cwd: this.cwd,</span><span class="s3">\n        </span><span class="s1">mode: mode,</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">cb,</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[DOCHOWN](entry: ReadEntry) {</span><span class="s3">\n    </span><span class="s1">// in preserve owner mode, chown if the entry doesn't match process</span><span class="s3">\n    </span><span class="s1">// in set owner mode, chown if setting doesn't match process</span><span class="s3">\n    </span><span class="s1">return (</span><span class="s3">\n      </span><span class="s1">this.forceChown ||</span><span class="s3">\n      </span><span class="s1">(this.preserveOwner &amp;&amp;</span><span class="s3">\n        </span><span class="s1">((typeof entry.uid === 'number' &amp;&amp;</span><span class="s3">\n          </span><span class="s1">entry.uid !== this.processUid) ||</span><span class="s3">\n          </span><span class="s1">(typeof entry.gid === 'number' &amp;&amp;</span><span class="s3">\n            </span><span class="s1">entry.gid !== this.processGid))) ||</span><span class="s3">\n      </span><span class="s1">(typeof this.uid === 'number' &amp;&amp;</span><span class="s3">\n        </span><span class="s1">this.uid !== this.processUid) ||</span><span class="s3">\n      </span><span class="s1">(typeof this.gid === 'number' &amp;&amp; this.gid !== this.processGid)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[UID](entry: ReadEntry) {</span><span class="s3">\n    </span><span class="s1">return uint32(this.uid, entry.uid, this.processUid)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[GID](entry: ReadEntry) {</span><span class="s3">\n    </span><span class="s1">return uint32(this.gid, entry.gid, this.processGid)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[FILE](entry: ReadEntry, fullyDone: () =&gt; void) {</span><span class="s3">\n    </span><span class="s1">const mode =</span><span class="s3">\n      </span><span class="s1">typeof entry.mode === 'number' ?</span><span class="s3">\n        </span><span class="s1">entry.mode &amp; 0o7777</span><span class="s3">\n      </span><span class="s1">: this.fmode</span><span class="s3">\n    </span><span class="s1">const stream = new fsm.WriteStream(String(entry.absolute), {</span><span class="s3">\n      </span><span class="s1">// slight lie, but it can be numeric flags</span><span class="s3">\n      </span><span class="s1">flags: getWriteFlag(entry.size) as string,</span><span class="s3">\n      </span><span class="s1">mode: mode,</span><span class="s3">\n      </span><span class="s1">autoClose: false,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">stream.on('error', (er: Error) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (stream.fd) {</span><span class="s3">\n        </span><span class="s1">fs.close(stream.fd, () =&gt; {})</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// flush all the data out so that we aren't left hanging</span><span class="s3">\n      </span><span class="s1">// if the error wasn't actually fatal.  otherwise the parse</span><span class="s3">\n      </span><span class="s1">// is blocked, and we never proceed.</span><span class="s3">\n      </span><span class="s1">stream.write = () =&gt; true</span><span class="s3">\n      </span><span class="s1">this[ONERROR](er, entry)</span><span class="s3">\n      </span><span class="s1">fullyDone()</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">let actions = 1</span><span class="s3">\n    </span><span class="s1">const done = (er?: null | Error) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (er) {</span><span class="s3">\n        </span><span class="s1">/* c8 ignore start - we should always have a fd by now */</span><span class="s3">\n        </span><span class="s1">if (stream.fd) {</span><span class="s3">\n          </span><span class="s1">fs.close(stream.fd, () =&gt; {})</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n\n        </span><span class="s1">this[ONERROR](er, entry)</span><span class="s3">\n        </span><span class="s1">fullyDone()</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (--actions === 0) {</span><span class="s3">\n        </span><span class="s1">if (stream.fd !== undefined) {</span><span class="s3">\n          </span><span class="s1">fs.close(stream.fd, er =&gt; {</span><span class="s3">\n            </span><span class="s1">if (er) {</span><span class="s3">\n              </span><span class="s1">this[ONERROR](er, entry)</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">this[UNPEND]()</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">fullyDone()</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">stream.on('finish', () =&gt; {</span><span class="s3">\n      </span><span class="s1">// if futimes fails, try utimes</span><span class="s3">\n      </span><span class="s1">// if utimes fails, fail with the original error</span><span class="s3">\n      </span><span class="s1">// same for fchown/chown</span><span class="s3">\n      </span><span class="s1">const abs = String(entry.absolute)</span><span class="s3">\n      </span><span class="s1">const fd = stream.fd</span><span class="s3">\n\n      </span><span class="s1">if (typeof fd === 'number' &amp;&amp; entry.mtime &amp;&amp; !this.noMtime) {</span><span class="s3">\n        </span><span class="s1">actions++</span><span class="s3">\n        </span><span class="s1">const atime = entry.atime || new Date()</span><span class="s3">\n        </span><span class="s1">const mtime = entry.mtime</span><span class="s3">\n        </span><span class="s1">fs.futimes(fd, atime, mtime, er =&gt;</span><span class="s3">\n          </span><span class="s1">er ?</span><span class="s3">\n            </span><span class="s1">fs.utimes(abs, atime, mtime, er2 =&gt; done(er2 &amp;&amp; er))</span><span class="s3">\n          </span><span class="s1">: done(),</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (typeof fd === 'number' &amp;&amp; this[DOCHOWN](entry)) {</span><span class="s3">\n        </span><span class="s1">actions++</span><span class="s3">\n        </span><span class="s1">const uid = this[UID](entry)</span><span class="s3">\n        </span><span class="s1">const gid = this[GID](entry)</span><span class="s3">\n        </span><span class="s1">if (typeof uid === 'number' &amp;&amp; typeof gid === 'number') {</span><span class="s3">\n          </span><span class="s1">fs.fchown(fd, uid, gid, er =&gt;</span><span class="s3">\n            </span><span class="s1">er ?</span><span class="s3">\n              </span><span class="s1">fs.chown(abs, uid, gid, er2 =&gt; done(er2 &amp;&amp; er))</span><span class="s3">\n            </span><span class="s1">: done(),</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">done()</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">const tx = this.transform ? this.transform(entry) || entry : entry</span><span class="s3">\n    </span><span class="s1">if (tx !== entry) {</span><span class="s3">\n      </span><span class="s1">tx.on('error', (er: Error) =&gt; {</span><span class="s3">\n        </span><span class="s1">this[ONERROR](er, entry)</span><span class="s3">\n        </span><span class="s1">fullyDone()</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">entry.pipe(tx)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">tx.pipe(stream)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[DIRECTORY](entry: ReadEntry, fullyDone: () =&gt; void) {</span><span class="s3">\n    </span><span class="s1">const mode =</span><span class="s3">\n      </span><span class="s1">typeof entry.mode === 'number' ?</span><span class="s3">\n        </span><span class="s1">entry.mode &amp; 0o7777</span><span class="s3">\n      </span><span class="s1">: this.dmode</span><span class="s3">\n    </span><span class="s1">this[MKDIR](String(entry.absolute), mode, er =&gt; {</span><span class="s3">\n      </span><span class="s1">if (er) {</span><span class="s3">\n        </span><span class="s1">this[ONERROR](er, entry)</span><span class="s3">\n        </span><span class="s1">fullyDone()</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">let actions = 1</span><span class="s3">\n      </span><span class="s1">const done = () =&gt; {</span><span class="s3">\n        </span><span class="s1">if (--actions === 0) {</span><span class="s3">\n          </span><span class="s1">fullyDone()</span><span class="s3">\n          </span><span class="s1">this[UNPEND]()</span><span class="s3">\n          </span><span class="s1">entry.resume()</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (entry.mtime &amp;&amp; !this.noMtime) {</span><span class="s3">\n        </span><span class="s1">actions++</span><span class="s3">\n        </span><span class="s1">fs.utimes(</span><span class="s3">\n          </span><span class="s1">String(entry.absolute),</span><span class="s3">\n          </span><span class="s1">entry.atime || new Date(),</span><span class="s3">\n          </span><span class="s1">entry.mtime,</span><span class="s3">\n          </span><span class="s1">done,</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (this[DOCHOWN](entry)) {</span><span class="s3">\n        </span><span class="s1">actions++</span><span class="s3">\n        </span><span class="s1">fs.chown(</span><span class="s3">\n          </span><span class="s1">String(entry.absolute),</span><span class="s3">\n          </span><span class="s1">Number(this[UID](entry)),</span><span class="s3">\n          </span><span class="s1">Number(this[GID](entry)),</span><span class="s3">\n          </span><span class="s1">done,</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">done()</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[UNSUPPORTED](entry: ReadEntry) {</span><span class="s3">\n    </span><span class="s1">entry.unsupported = true</span><span class="s3">\n    </span><span class="s1">this.warn(</span><span class="s3">\n      </span><span class="s1">'TAR_ENTRY_UNSUPPORTED',</span><span class="s3">\n      </span><span class="s1">`unsupported entry type: ${entry.type}`,</span><span class="s3">\n      </span><span class="s1">{ entry },</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">entry.resume()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[SYMLINK](entry: ReadEntry, done: () =&gt; void) {</span><span class="s3">\n    </span><span class="s1">this[LINK](entry, String(entry.linkpath), 'symlink', done)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[HARDLINK](entry: ReadEntry, done: () =&gt; void) {</span><span class="s3">\n    </span><span class="s1">const linkpath = normalizeWindowsPath(</span><span class="s3">\n      </span><span class="s1">path.resolve(this.cwd, String(entry.linkpath)),</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">this[LINK](entry, linkpath, 'link', done)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[PEND]() {</span><span class="s3">\n    </span><span class="s1">this[PENDING]++</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[UNPEND]() {</span><span class="s3">\n    </span><span class="s1">this[PENDING]--</span><span class="s3">\n    </span><span class="s1">this[MAYBECLOSE]()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[SKIP](entry: ReadEntry) {</span><span class="s3">\n    </span><span class="s1">this[UNPEND]()</span><span class="s3">\n    </span><span class="s1">entry.resume()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Check if we can reuse an existing filesystem entry safely and</span><span class="s3">\n  </span><span class="s1">// overwrite it, rather than unlinking and recreating</span><span class="s3">\n  </span><span class="s1">// Windows doesn't report a useful nlink, so we just never reuse entries</span><span class="s3">\n  </span><span class="s1">[ISREUSABLE](entry: ReadEntry, st: Stats) {</span><span class="s3">\n    </span><span class="s1">return (</span><span class="s3">\n      </span><span class="s1">entry.type === 'File' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!this.unlink &amp;&amp;</span><span class="s3">\n      </span><span class="s1">st.isFile() &amp;&amp;</span><span class="s3">\n      </span><span class="s1">st.nlink &lt;= 1 &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!isWindows</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// check if a thing is there, and if so, try to clobber it</span><span class="s3">\n  </span><span class="s1">[CHECKFS](entry: ReadEntry) {</span><span class="s3">\n    </span><span class="s1">this[PEND]()</span><span class="s3">\n    </span><span class="s1">const paths = [entry.path]</span><span class="s3">\n    </span><span class="s1">if (entry.linkpath) {</span><span class="s3">\n      </span><span class="s1">paths.push(entry.linkpath)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.reservations.reserve(paths, done =&gt;</span><span class="s3">\n      </span><span class="s1">this[CHECKFS2](entry, done),</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[CHECKFS2](entry: ReadEntry, fullyDone: (er?: Error) =&gt; void) {</span><span class="s3">\n    </span><span class="s1">const done = (er?: Error) =&gt; {</span><span class="s3">\n      </span><span class="s1">fullyDone(er)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const checkCwd = () =&gt; {</span><span class="s3">\n      </span><span class="s1">this[MKDIR](this.cwd, this.dmode, er =&gt; {</span><span class="s3">\n        </span><span class="s1">if (er) {</span><span class="s3">\n          </span><span class="s1">this[ONERROR](er, entry)</span><span class="s3">\n          </span><span class="s1">done()</span><span class="s3">\n          </span><span class="s1">return</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this[CHECKED_CWD] = true</span><span class="s3">\n        </span><span class="s1">start()</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const start = () =&gt; {</span><span class="s3">\n      </span><span class="s1">if (entry.absolute !== this.cwd) {</span><span class="s3">\n        </span><span class="s1">const parent = normalizeWindowsPath(</span><span class="s3">\n          </span><span class="s1">path.dirname(String(entry.absolute)),</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">if (parent !== this.cwd) {</span><span class="s3">\n          </span><span class="s1">return this[MKDIR](parent, this.dmode, er =&gt; {</span><span class="s3">\n            </span><span class="s1">if (er) {</span><span class="s3">\n              </span><span class="s1">this[ONERROR](er, entry)</span><span class="s3">\n              </span><span class="s1">done()</span><span class="s3">\n              </span><span class="s1">return</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">afterMakeParent()</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">afterMakeParent()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const afterMakeParent = () =&gt; {</span><span class="s3">\n      </span><span class="s1">fs.lstat(String(entry.absolute), (lstatEr, st) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">st &amp;&amp;</span><span class="s3">\n          </span><span class="s1">(this.keep ||</span><span class="s3">\n            </span><span class="s1">/* c8 ignore next */</span><span class="s3">\n            </span><span class="s1">(this.newer &amp;&amp; st.mtime &gt; (entry.mtime ?? st.mtime)))</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">this[SKIP](entry)</span><span class="s3">\n          </span><span class="s1">done()</span><span class="s3">\n          </span><span class="s1">return</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (lstatEr || this[ISREUSABLE](entry, st)) {</span><span class="s3">\n          </span><span class="s1">return this[MAKEFS](null, entry, done)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (st.isDirectory()) {</span><span class="s3">\n          </span><span class="s1">if (entry.type === 'Directory') {</span><span class="s3">\n            </span><span class="s1">const needChmod =</span><span class="s3">\n              </span><span class="s1">this.chmod &amp;&amp;</span><span class="s3">\n              </span><span class="s1">entry.mode &amp;&amp;</span><span class="s3">\n              </span><span class="s1">(st.mode &amp; 0o7777) !== entry.mode</span><span class="s3">\n            </span><span class="s1">const afterChmod = (er?: Error | null | undefined) =&gt;</span><span class="s3">\n              </span><span class="s1">this[MAKEFS](er ?? null, entry, done)</span><span class="s3">\n            </span><span class="s1">if (!needChmod) {</span><span class="s3">\n              </span><span class="s1">return afterChmod()</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return fs.chmod(</span><span class="s3">\n              </span><span class="s1">String(entry.absolute),</span><span class="s3">\n              </span><span class="s1">Number(entry.mode),</span><span class="s3">\n              </span><span class="s1">afterChmod,</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">// Not a dir entry, have to remove it.</span><span class="s3">\n          </span><span class="s1">// NB: the only way to end up with an entry that is the cwd</span><span class="s3">\n          </span><span class="s1">// itself, in such a way that == does not detect, is a</span><span class="s3">\n          </span><span class="s1">// tricky windows absolute path with UNC or 8.3 parts (and</span><span class="s3">\n          </span><span class="s1">// preservePaths:true, or else it will have been stripped).</span><span class="s3">\n          </span><span class="s1">// In that case, the user has opted out of path protections</span><span class="s3">\n          </span><span class="s1">// explicitly, so if they blow away the cwd, c'est la vie.</span><span class="s3">\n          </span><span class="s1">if (entry.absolute !== this.cwd) {</span><span class="s3">\n            </span><span class="s1">return fs.rmdir(</span><span class="s3">\n              </span><span class="s1">String(entry.absolute),</span><span class="s3">\n              </span><span class="s1">(er?: null | Error) =&gt;</span><span class="s3">\n                </span><span class="s1">this[MAKEFS](er ?? null, entry, done),</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// not a dir, and not reusable</span><span class="s3">\n        </span><span class="s1">// don't remove if the cwd, we want that error</span><span class="s3">\n        </span><span class="s1">if (entry.absolute === this.cwd) {</span><span class="s3">\n          </span><span class="s1">return this[MAKEFS](null, entry, done)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">unlinkFile(String(entry.absolute), er =&gt;</span><span class="s3">\n          </span><span class="s1">this[MAKEFS](er ?? null, entry, done),</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (this[CHECKED_CWD]) {</span><span class="s3">\n      </span><span class="s1">start()</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">checkCwd()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[MAKEFS](</span><span class="s3">\n    </span><span class="s1">er: null | undefined | Error,</span><span class="s3">\n    </span><span class="s1">entry: ReadEntry,</span><span class="s3">\n    </span><span class="s1">done: () =&gt; void,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (er) {</span><span class="s3">\n      </span><span class="s1">this[ONERROR](er, entry)</span><span class="s3">\n      </span><span class="s1">done()</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">switch (entry.type) {</span><span class="s3">\n      </span><span class="s1">case 'File':</span><span class="s3">\n      </span><span class="s1">case 'OldFile':</span><span class="s3">\n      </span><span class="s1">case 'ContiguousFile':</span><span class="s3">\n        </span><span class="s1">return this[FILE](entry, done)</span><span class="s3">\n\n      </span><span class="s1">case 'Link':</span><span class="s3">\n        </span><span class="s1">return this[HARDLINK](entry, done)</span><span class="s3">\n\n      </span><span class="s1">case 'SymbolicLink':</span><span class="s3">\n        </span><span class="s1">return this[SYMLINK](entry, done)</span><span class="s3">\n\n      </span><span class="s1">case 'Directory':</span><span class="s3">\n      </span><span class="s1">case 'GNUDumpDir':</span><span class="s3">\n        </span><span class="s1">return this[DIRECTORY](entry, done)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[LINK](</span><span class="s3">\n    </span><span class="s1">entry: ReadEntry,</span><span class="s3">\n    </span><span class="s1">linkpath: string,</span><span class="s3">\n    </span><span class="s1">link: 'link' | 'symlink',</span><span class="s3">\n    </span><span class="s1">done: () =&gt; void,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">// XXX: get the type ('symlink' or 'junction') for windows</span><span class="s3">\n    </span><span class="s1">fs[link](linkpath, String(entry.absolute), er =&gt; {</span><span class="s3">\n      </span><span class="s1">if (er) {</span><span class="s3">\n        </span><span class="s1">this[ONERROR](er, entry)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">this[UNPEND]()</span><span class="s3">\n        </span><span class="s1">entry.resume()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">done()</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const callSync = (fn: () =&gt; any) =&gt; {</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">return [null, fn()]</span><span class="s3">\n  </span><span class="s1">} catch (er) {</span><span class="s3">\n    </span><span class="s1">return [er, null]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class UnpackSync extends Unpack {</span><span class="s3">\n  </span><span class="s1">sync: true = true;</span><span class="s3">\n\n  </span><span class="s1">[MAKEFS](er: null | Error | undefined, entry: ReadEntry) {</span><span class="s3">\n    </span><span class="s1">return super[MAKEFS](er, entry, () =&gt; {})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[CHECKFS](entry: ReadEntry) {</span><span class="s3">\n    </span><span class="s1">if (!this[CHECKED_CWD]) {</span><span class="s3">\n      </span><span class="s1">const er = this[MKDIR](this.cwd, this.dmode)</span><span class="s3">\n      </span><span class="s1">if (er) {</span><span class="s3">\n        </span><span class="s1">return this[ONERROR](er as Error, entry)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">this[CHECKED_CWD] = true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// don't bother to make the parent if the current entry is the cwd,</span><span class="s3">\n    </span><span class="s1">// we've already checked it.</span><span class="s3">\n    </span><span class="s1">if (entry.absolute !== this.cwd) {</span><span class="s3">\n      </span><span class="s1">const parent = normalizeWindowsPath(</span><span class="s3">\n        </span><span class="s1">path.dirname(String(entry.absolute)),</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">if (parent !== this.cwd) {</span><span class="s3">\n        </span><span class="s1">const mkParent = this[MKDIR](parent, this.dmode)</span><span class="s3">\n        </span><span class="s1">if (mkParent) {</span><span class="s3">\n          </span><span class="s1">return this[ONERROR](mkParent as Error, entry)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const [lstatEr, st] = callSync(() =&gt;</span><span class="s3">\n      </span><span class="s1">fs.lstatSync(String(entry.absolute)),</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">st &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(this.keep ||</span><span class="s3">\n        </span><span class="s1">/* c8 ignore next */</span><span class="s3">\n        </span><span class="s1">(this.newer &amp;&amp; st.mtime &gt; (entry.mtime ?? st.mtime)))</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return this[SKIP](entry)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (lstatEr || this[ISREUSABLE](entry, st)) {</span><span class="s3">\n      </span><span class="s1">return this[MAKEFS](null, entry)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (st.isDirectory()) {</span><span class="s3">\n      </span><span class="s1">if (entry.type === 'Directory') {</span><span class="s3">\n        </span><span class="s1">const needChmod =</span><span class="s3">\n          </span><span class="s1">this.chmod &amp;&amp;</span><span class="s3">\n          </span><span class="s1">entry.mode &amp;&amp;</span><span class="s3">\n          </span><span class="s1">(st.mode &amp; 0o7777) !== entry.mode</span><span class="s3">\n        </span><span class="s1">const [er] =</span><span class="s3">\n          </span><span class="s1">needChmod ?</span><span class="s3">\n            </span><span class="s1">callSync(() =&gt; {</span><span class="s3">\n              </span><span class="s1">fs.chmodSync(String(entry.absolute), Number(entry.mode))</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n          </span><span class="s1">: []</span><span class="s3">\n        </span><span class="s1">return this[MAKEFS](er, entry)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">// not a dir entry, have to remove it</span><span class="s3">\n      </span><span class="s1">const [er] = callSync(() =&gt;</span><span class="s3">\n        </span><span class="s1">fs.rmdirSync(String(entry.absolute)),</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">this[MAKEFS](er, entry)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// not a dir, and not reusable.</span><span class="s3">\n    </span><span class="s1">// don't remove if it's the cwd, since we want that error.</span><span class="s3">\n    </span><span class="s1">const [er] =</span><span class="s3">\n      </span><span class="s1">entry.absolute === this.cwd ?</span><span class="s3">\n        </span><span class="s1">[]</span><span class="s3">\n      </span><span class="s1">: callSync(() =&gt; unlinkFileSync(String(entry.absolute)))</span><span class="s3">\n    </span><span class="s1">this[MAKEFS](er, entry)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[FILE](entry: ReadEntry, done: () =&gt; void) {</span><span class="s3">\n    </span><span class="s1">const mode =</span><span class="s3">\n      </span><span class="s1">typeof entry.mode === 'number' ?</span><span class="s3">\n        </span><span class="s1">entry.mode &amp; 0o7777</span><span class="s3">\n      </span><span class="s1">: this.fmode</span><span class="s3">\n\n    </span><span class="s1">const oner = (er?: null | Error | undefined) =&gt; {</span><span class="s3">\n      </span><span class="s1">let closeError</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">fs.closeSync(fd)</span><span class="s3">\n      </span><span class="s1">} catch (e) {</span><span class="s3">\n        </span><span class="s1">closeError = e</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (er || closeError) {</span><span class="s3">\n        </span><span class="s1">this[ONERROR]((er as Error) || closeError, entry)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">done()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let fd: number</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">fd = fs.openSync(</span><span class="s3">\n        </span><span class="s1">String(entry.absolute),</span><span class="s3">\n        </span><span class="s1">getWriteFlag(entry.size),</span><span class="s3">\n        </span><span class="s1">mode,</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">/* c8 ignore start - This is only a problem if the file was successfully</span><span class="s3">\n       </span><span class="s1">* statted, BUT failed to open. Testing this is annoying, and we</span><span class="s3">\n       </span><span class="s1">* already have ample testint for other uses of oner() methods.</span><span class="s3">\n       </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">} catch (er) {</span><span class="s3">\n      </span><span class="s1">return oner(er as Error)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n    </span><span class="s1">const tx = this.transform ? this.transform(entry) || entry : entry</span><span class="s3">\n    </span><span class="s1">if (tx !== entry) {</span><span class="s3">\n      </span><span class="s1">tx.on('error', (er: Error) =&gt; this[ONERROR](er, entry))</span><span class="s3">\n      </span><span class="s1">entry.pipe(tx)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">tx.on('data', (chunk: Buffer) =&gt; {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">fs.writeSync(fd, chunk, 0, chunk.length)</span><span class="s3">\n      </span><span class="s1">} catch (er) {</span><span class="s3">\n        </span><span class="s1">oner(er as Error)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">tx.on('end', () =&gt; {</span><span class="s3">\n      </span><span class="s1">let er = null</span><span class="s3">\n      </span><span class="s1">// try both, falling futimes back to utimes</span><span class="s3">\n      </span><span class="s1">// if either fails, handle the first error</span><span class="s3">\n      </span><span class="s1">if (entry.mtime &amp;&amp; !this.noMtime) {</span><span class="s3">\n        </span><span class="s1">const atime = entry.atime || new Date()</span><span class="s3">\n        </span><span class="s1">const mtime = entry.mtime</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n          </span><span class="s1">fs.futimesSync(fd, atime, mtime)</span><span class="s3">\n        </span><span class="s1">} catch (futimeser) {</span><span class="s3">\n          </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">fs.utimesSync(String(entry.absolute), atime, mtime)</span><span class="s3">\n          </span><span class="s1">} catch (utimeser) {</span><span class="s3">\n            </span><span class="s1">er = futimeser</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (this[DOCHOWN](entry)) {</span><span class="s3">\n        </span><span class="s1">const uid = this[UID](entry)</span><span class="s3">\n        </span><span class="s1">const gid = this[GID](entry)</span><span class="s3">\n\n        </span><span class="s1">try {</span><span class="s3">\n          </span><span class="s1">fs.fchownSync(fd, Number(uid), Number(gid))</span><span class="s3">\n        </span><span class="s1">} catch (fchowner) {</span><span class="s3">\n          </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">fs.chownSync(</span><span class="s3">\n              </span><span class="s1">String(entry.absolute),</span><span class="s3">\n              </span><span class="s1">Number(uid),</span><span class="s3">\n              </span><span class="s1">Number(gid),</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">} catch (chowner) {</span><span class="s3">\n            </span><span class="s1">er = er || fchowner</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">oner(er as Error)</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[DIRECTORY](entry: ReadEntry, done: () =&gt; void) {</span><span class="s3">\n    </span><span class="s1">const mode =</span><span class="s3">\n      </span><span class="s1">typeof entry.mode === 'number' ?</span><span class="s3">\n        </span><span class="s1">entry.mode &amp; 0o7777</span><span class="s3">\n      </span><span class="s1">: this.dmode</span><span class="s3">\n    </span><span class="s1">const er = this[MKDIR](String(entry.absolute), mode)</span><span class="s3">\n    </span><span class="s1">if (er) {</span><span class="s3">\n      </span><span class="s1">this[ONERROR](er as Error, entry)</span><span class="s3">\n      </span><span class="s1">done()</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (entry.mtime &amp;&amp; !this.noMtime) {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">fs.utimesSync(</span><span class="s3">\n          </span><span class="s1">String(entry.absolute),</span><span class="s3">\n          </span><span class="s1">entry.atime || new Date(),</span><span class="s3">\n          </span><span class="s1">entry.mtime,</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">/* c8 ignore next */</span><span class="s3">\n      </span><span class="s1">} catch (er) {}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (this[DOCHOWN](entry)) {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">fs.chownSync(</span><span class="s3">\n          </span><span class="s1">String(entry.absolute),</span><span class="s3">\n          </span><span class="s1">Number(this[UID](entry)),</span><span class="s3">\n          </span><span class="s1">Number(this[GID](entry)),</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">} catch (er) {}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">done()</span><span class="s3">\n    </span><span class="s1">entry.resume()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[MKDIR](dir: string, mode: number) {</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">return mkdirSync(normalizeWindowsPath(dir), {</span><span class="s3">\n        </span><span class="s1">uid: this.uid,</span><span class="s3">\n        </span><span class="s1">gid: this.gid,</span><span class="s3">\n        </span><span class="s1">processUid: this.processUid,</span><span class="s3">\n        </span><span class="s1">processGid: this.processGid,</span><span class="s3">\n        </span><span class="s1">umask: this.processUmask,</span><span class="s3">\n        </span><span class="s1">preserve: this.preservePaths,</span><span class="s3">\n        </span><span class="s1">unlink: this.unlink,</span><span class="s3">\n        </span><span class="s1">cwd: this.cwd,</span><span class="s3">\n        </span><span class="s1">mode: mode,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">} catch (er) {</span><span class="s3">\n      </span><span class="s1">return er</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[LINK](</span><span class="s3">\n    </span><span class="s1">entry: ReadEntry,</span><span class="s3">\n    </span><span class="s1">linkpath: string,</span><span class="s3">\n    </span><span class="s1">link: 'link' | 'symlink',</span><span class="s3">\n    </span><span class="s1">done: () =&gt; void,</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const ls: `${typeof link}Sync` = `${link}Sync`</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">fs[ls](linkpath, String(entry.absolute))</span><span class="s3">\n      </span><span class="s1">done()</span><span class="s3">\n      </span><span class="s1">entry.resume()</span><span class="s3">\n    </span><span class="s1">} catch (er) {</span><span class="s3">\n      </span><span class="s1">return this[ONERROR](er as Error, entry)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">]}</span></pre>
</body>
</html>