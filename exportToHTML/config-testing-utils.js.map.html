<html>
<head>
<title>config-testing-utils.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
config-testing-utils.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../src/experimental/testing/server/config-testing-utils.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { IncomingHttpHeaders } from 'node:http'</span><span class="s3">\n</span><span class="s1">import { parse, type UrlWithParsedQuery } from 'node:url'</span><span class="s3">\n</span><span class="s1">import { match } from 'next/dist/compiled/path-to-regexp'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">matchHas,</span><span class="s3">\n  </span><span class="s1">prepareDestination,</span><span class="s3">\n</span><span class="s1">} from '../../../shared/lib/router/utils/prepare-destination'</span><span class="s3">\n</span><span class="s1">import { buildCustomRoute } from '../../../lib/build-custom-route'</span><span class="s3">\n</span><span class="s1">import loadCustomRoutes from '../../../lib/load-custom-routes'</span><span class="s3">\n</span><span class="s1">import type { NextConfig } from '../../../server/config-shared'</span><span class="s3">\n</span><span class="s1">import { NextResponse } from '../../../server/web/exports'</span><span class="s3">\n</span><span class="s1">import { getRedirectStatus } from '../../../lib/redirect-status'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">ManifestHeaderRoute,</span><span class="s3">\n  </span><span class="s1">ManifestRedirectRoute,</span><span class="s3">\n  </span><span class="s1">ManifestRewriteRoute,</span><span class="s3">\n</span><span class="s1">} from '../../../build'</span><span class="s3">\n</span><span class="s1">import type { BaseNextRequest } from '../../../server/base-http'</span><span class="s3">\n</span><span class="s1">import type { Params } from '../../../server/request/params'</span><span class="s3">\n</span><span class="s1">import { constructRequest } from './utils'</span><span class="s3">\n</span><span class="s1">import { parsedUrlQueryToParams } from '../../../server/route-modules/app-route/helpers/parsed-url-query-to-params'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tries to match the current request against the provided route. If there is</span><span class="s3">\n </span><span class="s1">* a match, it returns the params extracted from the path. If not, it returns</span><span class="s3">\n </span><span class="s1">* undefined.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function matchRoute(</span><span class="s3">\n  </span><span class="s1">route: ManifestHeaderRoute | ManifestRedirectRoute | ManifestRewriteRoute,</span><span class="s3">\n  </span><span class="s1">request: BaseNextRequest,</span><span class="s3">\n  </span><span class="s1">parsedUrl: UrlWithParsedQuery</span><span class="s3">\n</span><span class="s1">): Params | undefined {</span><span class="s3">\n  </span><span class="s1">const pathname = parsedUrl.pathname</span><span class="s3">\n  </span><span class="s1">if (!pathname) {</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const regexMatches = pathname?.match(route.regex)</span><span class="s3">\n\n  </span><span class="s1">if (regexMatches) {</span><span class="s3">\n    </span><span class="s1">const pathMatch = match&lt;Params&gt;(route.source)(pathname)</span><span class="s3">\n    </span><span class="s1">if (!pathMatch) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">'Unexpected error: extracting params from path failed but the regular expression matched'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (route.has || route.missing) {</span><span class="s3">\n      </span><span class="s1">if (!matchHas(request, parsedUrl.query, route.has, route.missing)) {</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return pathMatch.params</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests the logic of `headers`, `redirects`, and `rewrites` in `next.config.js`.</span><span class="s3">\n </span><span class="s1">* Given the provided next config, this function will return a `NextResponse`</span><span class="s3">\n </span><span class="s1">* with the result of running the request through the custom routes.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @example Test whether a given URL results in a redirect.</span><span class="s3">\n </span><span class="s1">* ```</span><span class="s3">\n </span><span class="s1">* import { unstable_getResponseFromNextConfig, getRedirectUrl } from 'next/server/testing'</span><span class="s3">\n </span><span class="s1">* const response = await unstable_getResponseFromNextConfig({</span><span class="s3">\n </span><span class="s1">*   url: 'https://nextjs.org/test',</span><span class="s3">\n </span><span class="s1">*   nextConfig: {</span><span class="s3">\n </span><span class="s1">*    async redirects() {</span><span class="s3">\n </span><span class="s1">*     return [</span><span class="s3">\n </span><span class="s1">*       { source: '/test', destination: '/test2', permanent: false },</span><span class="s3">\n </span><span class="s1">*     ]</span><span class="s3">\n </span><span class="s1">*    },</span><span class="s3">\n </span><span class="s1">*   }</span><span class="s3">\n </span><span class="s1">* });</span><span class="s3">\n </span><span class="s1">* expect(response.status).toEqual(307);</span><span class="s3">\n </span><span class="s1">* expect(getRedirectUrl(response)).toEqual('https://nextjs.org/test2');</span><span class="s3">\n </span><span class="s1">* ```</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export async function unstable_getResponseFromNextConfig({</span><span class="s3">\n  </span><span class="s1">url,</span><span class="s3">\n  </span><span class="s1">nextConfig,</span><span class="s3">\n  </span><span class="s1">headers = {},</span><span class="s3">\n  </span><span class="s1">cookies = {},</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">url: string</span><span class="s3">\n  </span><span class="s1">nextConfig: NextConfig</span><span class="s3">\n  </span><span class="s1">headers?: IncomingHttpHeaders</span><span class="s3">\n  </span><span class="s1">cookies?: Record&lt;string, string&gt;</span><span class="s3">\n</span><span class="s1">}): Promise&lt;NextResponse&gt; {</span><span class="s3">\n  </span><span class="s1">const parsedUrl = parse(url, true)</span><span class="s3">\n  </span><span class="s1">const request = constructRequest({ url, headers, cookies })</span><span class="s3">\n  </span><span class="s1">const routes = await loadCustomRoutes(nextConfig)</span><span class="s3">\n\n  </span><span class="s1">const headerRoutes = routes.headers.map((route) =&gt;</span><span class="s3">\n    </span><span class="s1">buildCustomRoute('header', route)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">const redirectRoutes = routes.redirects.map((route) =&gt;</span><span class="s3">\n    </span><span class="s1">buildCustomRoute('redirect', route, ['/_next/'])</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">const rewriteRoutes = [</span><span class="s3">\n    </span><span class="s1">...routes.rewrites.beforeFiles,</span><span class="s3">\n    </span><span class="s1">...routes.rewrites.afterFiles,</span><span class="s3">\n    </span><span class="s1">...routes.rewrites.fallback,</span><span class="s3">\n  </span><span class="s1">].map((route) =&gt; buildCustomRoute('rewrite', route))</span><span class="s3">\n\n  </span><span class="s1">const respHeaders: Record&lt;string, string&gt; = {}</span><span class="s3">\n  </span><span class="s1">for (const route of headerRoutes) {</span><span class="s3">\n    </span><span class="s1">const matched = matchRoute(route, request, parsedUrl)</span><span class="s3">\n    </span><span class="s1">if (matched) {</span><span class="s3">\n      </span><span class="s1">for (const header of route.headers) {</span><span class="s3">\n        </span><span class="s1">respHeaders[header.key] = header.value</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function matchRouteAndGetDestination(</span><span class="s3">\n    </span><span class="s1">route: ManifestRedirectRoute | ManifestRewriteRoute</span><span class="s3">\n  </span><span class="s1">): URL | undefined {</span><span class="s3">\n    </span><span class="s1">const params = matchRoute(route, request, parsedUrl)</span><span class="s3">\n    </span><span class="s1">if (!params) {</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const { newUrl, parsedDestination } = prepareDestination({</span><span class="s3">\n      </span><span class="s1">appendParamsToQuery: false,</span><span class="s3">\n      </span><span class="s1">destination: route.destination,</span><span class="s3">\n      </span><span class="s1">params,</span><span class="s3">\n      </span><span class="s1">query: parsedUrl.query,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">const searchParams = new URLSearchParams(</span><span class="s3">\n      </span><span class="s1">parsedUrlQueryToParams(parsedDestination.query) as Record&lt;string, string&gt;</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">return new URL(</span><span class="s3">\n      </span><span class="s1">searchParams.size &gt; 0 ? `${newUrl}?${searchParams.toString()}` : newUrl,</span><span class="s3">\n      </span><span class="s1">parsedDestination.hostname</span><span class="s3">\n        </span><span class="s1">? `${parsedDestination.protocol}//${parsedDestination.hostname}`</span><span class="s3">\n        </span><span class="s1">: parsedUrl.host</span><span class="s3">\n          </span><span class="s1">? `${parsedUrl.protocol}//${parsedUrl.host}`</span><span class="s3">\n          </span><span class="s1">: 'https://example.com'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">for (const route of redirectRoutes) {</span><span class="s3">\n    </span><span class="s1">const redirectUrl = matchRouteAndGetDestination(route)</span><span class="s3">\n    </span><span class="s1">if (!redirectUrl) {</span><span class="s3">\n      </span><span class="s1">continue</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const statusCode = getRedirectStatus(route)</span><span class="s3">\n    </span><span class="s1">return NextResponse.redirect(redirectUrl, {</span><span class="s3">\n      </span><span class="s1">status: statusCode,</span><span class="s3">\n      </span><span class="s1">headers: respHeaders,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">for (const route of rewriteRoutes) {</span><span class="s3">\n    </span><span class="s1">const rewriteUrl = matchRouteAndGetDestination(route)</span><span class="s3">\n    </span><span class="s1">if (!rewriteUrl) {</span><span class="s3">\n      </span><span class="s1">continue</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return NextResponse.rewrite(rewriteUrl, {</span><span class="s3">\n      </span><span class="s1">headers: respHeaders,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return new NextResponse('', { status: 200, headers: respHeaders })</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;unstable_getResponseFromNextConfig&quot;</span><span class="s0">,</span><span class="s1">&quot;matchRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;route&quot;</span><span class="s0">,</span><span class="s1">&quot;request&quot;</span><span class="s0">,</span><span class="s1">&quot;parsedUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;regexMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;match&quot;</span><span class="s0">,</span><span class="s1">&quot;regex&quot;</span><span class="s0">,</span><span class="s1">&quot;pathMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;source&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;missing&quot;</span><span class="s0">,</span><span class="s1">&quot;matchHas&quot;</span><span class="s0">,</span><span class="s1">&quot;query&quot;</span><span class="s0">,</span><span class="s1">&quot;params&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;nextConfig&quot;</span><span class="s0">,</span><span class="s1">&quot;headers&quot;</span><span class="s0">,</span><span class="s1">&quot;cookies&quot;</span><span class="s0">,</span><span class="s1">&quot;parse&quot;</span><span class="s0">,</span><span class="s1">&quot;constructRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;routes&quot;</span><span class="s0">,</span><span class="s1">&quot;loadCustomRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;headerRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;buildCustomRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;redirectRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;redirects&quot;</span><span class="s0">,</span><span class="s1">&quot;rewriteRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;rewrites&quot;</span><span class="s0">,</span><span class="s1">&quot;beforeFiles&quot;</span><span class="s0">,</span><span class="s1">&quot;afterFiles&quot;</span><span class="s0">,</span><span class="s1">&quot;fallback&quot;</span><span class="s0">,</span><span class="s1">&quot;respHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;matched&quot;</span><span class="s0">,</span><span class="s1">&quot;header&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;matchRouteAndGetDestination&quot;</span><span class="s0">,</span><span class="s1">&quot;newUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;parsedDestination&quot;</span><span class="s0">,</span><span class="s1">&quot;prepareDestination&quot;</span><span class="s0">,</span><span class="s1">&quot;appendParamsToQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;destination&quot;</span><span class="s0">,</span><span class="s1">&quot;searchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;URLSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;parsedUrlQueryToParams&quot;</span><span class="s0">,</span><span class="s1">&quot;URL&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">,</span><span class="s1">&quot;toString&quot;</span><span class="s0">,</span><span class="s1">&quot;hostname&quot;</span><span class="s0">,</span><span class="s1">&quot;protocol&quot;</span><span class="s0">,</span><span class="s1">&quot;host&quot;</span><span class="s0">,</span><span class="s1">&quot;redirectUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;statusCode&quot;</span><span class="s0">,</span><span class="s1">&quot;getRedirectStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;NextResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;redirect&quot;</span><span class="s0">,</span><span class="s1">&quot;status&quot;</span><span class="s0">,</span><span class="s1">&quot;rewriteUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;rewrite&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>