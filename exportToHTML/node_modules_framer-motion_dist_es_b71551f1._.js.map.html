<html>
<head>
<title>node_modules_framer-motion_dist_es_b71551f1._.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
.s4 { color: #0033b3;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
node_modules_framer-motion_dist_es_b71551f1._.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span>
  <span class="s1">&quot;version&quot;</span><span class="s0">: </span><span class="s2">3</span><span class="s0">,</span>
  <span class="s1">&quot;sources&quot;</span><span class="s0">: [],</span>
  <span class="s1">&quot;sections&quot;</span><span class="s0">: [</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">4</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/projection/geometry/conversion.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Bounding boxes tend to be defined as top, left, right, bottom. For various operations</span><span class="s3">\n </span><span class="s1">* it's easier to consider each axis individually. This function returns a bounding box</span><span class="s3">\n </span><span class="s1">* as a map of single-axis min/max values.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function convertBoundingBoxToBox({ top, left, right, bottom, }) {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">x: { min: left, max: right },</span><span class="s3">\n        </span><span class="s1">y: { min: top, max: bottom },</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function convertBoxToBoundingBox({ x, y }) {</span><span class="s3">\n    </span><span class="s1">return { top: y.min, right: x.max, bottom: y.max, left: x.min };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Applies a TransformPoint function to a bounding box. TransformPoint is usually a function</span><span class="s3">\n </span><span class="s1">* provided by Framer to allow measured points to be corrected for device scaling. This is used</span><span class="s3">\n </span><span class="s1">* when measuring DOM elements and DOM event points.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function transformBoxPoints(point, transformPoint) {</span><span class="s3">\n    </span><span class="s1">if (!transformPoint)</span><span class="s3">\n        </span><span class="s1">return point;</span><span class="s3">\n    </span><span class="s1">const topLeft = transformPoint({ x: point.left, y: point.top });</span><span class="s3">\n    </span><span class="s1">const bottomRight = transformPoint({ x: point.right, y: point.bottom });</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">top: topLeft.y,</span><span class="s3">\n        </span><span class="s1">left: topLeft.x,</span><span class="s3">\n        </span><span class="s1">bottom: bottomRight.y,</span><span class="s3">\n        </span><span class="s1">right: bottomRight.x,</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { convertBoundingBoxToBox, convertBoxToBoundingBox, transformBoxPoints };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAA;;;;CAIC;;;;;;;;AACD,SAAS,wBAAwB,KAA6B;QAA7B,EAAE,GAAG,EAAE,IAAI,EAAE,KAAK,EAAE,MAAM,EAAG,GAA7B;IAC7B,OAAO;QACH,GAAG;YAAE,KAAK;YAAM,KAAK;QAAM;QAC3B,GAAG;YAAE,KAAK;YAAK,KAAK;QAAO;IAC/B;AACJ;AACA,SAAS,wBAAwB,KAAQ;QAAR,EAAE,CAAC,EAAE,CAAC,EAAE,GAAR;IAC7B,OAAO;QAAE,KAAK,EAAE,GAAG;QAAE,OAAO,EAAE,GAAG;QAAE,QAAQ,EAAE,GAAG;QAAE,MAAM,EAAE,GAAG;IAAC;AAClE;AACA;;;;CAIC,GACD,SAAS,mBAAmB,KAAK,EAAE,cAAc;IAC7C,IAAI,CAAC,gBACD,OAAO;IACX,MAAM,UAAU,eAAe;QAAE,GAAG,MAAM,IAAI;QAAE,GAAG,MAAM,GAAG;IAAC;IAC7D,MAAM,cAAc,eAAe;QAAE,GAAG,MAAM,KAAK;QAAE,GAAG,MAAM,MAAM;IAAC;IACrE,OAAO;QACH,KAAK,QAAQ,CAAC;QACd,MAAM,QAAQ,CAAC;QACf,QAAQ,YAAY,CAAC;QACrB,OAAO,YAAY,CAAC;IACxB;AACJ&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">64</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/projection/utils/has-transform.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;function isIdentityScale(scale) {</span><span class="s3">\n    </span><span class="s1">return scale === undefined || scale === 1;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function hasScale({ scale, scaleX, scaleY }) {</span><span class="s3">\n    </span><span class="s1">return (!isIdentityScale(scale) ||</span><span class="s3">\n        </span><span class="s1">!isIdentityScale(scaleX) ||</span><span class="s3">\n        </span><span class="s1">!isIdentityScale(scaleY));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function hasTransform(values) {</span><span class="s3">\n    </span><span class="s1">return (hasScale(values) ||</span><span class="s3">\n        </span><span class="s1">has2DTranslate(values) ||</span><span class="s3">\n        </span><span class="s1">values.z ||</span><span class="s3">\n        </span><span class="s1">values.rotate ||</span><span class="s3">\n        </span><span class="s1">values.rotateX ||</span><span class="s3">\n        </span><span class="s1">values.rotateY ||</span><span class="s3">\n        </span><span class="s1">values.skewX ||</span><span class="s3">\n        </span><span class="s1">values.skewY);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function has2DTranslate(values) {</span><span class="s3">\n    </span><span class="s1">return is2DTranslate(values.x) || is2DTranslate(values.y);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function is2DTranslate(value) {</span><span class="s3">\n    </span><span class="s1">return value &amp;&amp; value !== </span><span class="s3">\&quot;</span><span class="s1">0%</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { has2DTranslate, hasScale, hasTransform };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;AAAA,SAAS,gBAAgB,KAAK;IAC1B,OAAO,UAAU,aAAa,UAAU;AAC5C;AACA,SAAS,SAAS,KAAyB;QAAzB,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,GAAzB;IACd,OAAQ,CAAC,gBAAgB,UACrB,CAAC,gBAAgB,WACjB,CAAC,gBAAgB;AACzB;AACA,SAAS,aAAa,MAAM;IACxB,OAAQ,SAAS,WACb,eAAe,WACf,OAAO,CAAC,IACR,OAAO,MAAM,IACb,OAAO,OAAO,IACd,OAAO,OAAO,IACd,OAAO,KAAK,IACZ,OAAO,KAAK;AACpB;AACA,SAAS,eAAe,MAAM;IAC1B,OAAO,cAAc,OAAO,CAAC,KAAK,cAAc,OAAO,CAAC;AAC5D;AACA,SAAS,cAAc,KAAK;IACxB,OAAO,SAAS,UAAU;AAC9B&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">93</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { mixNumber } from 'motion-dom';</span><span class="s3">\n</span><span class="s1">import { hasTransform } from '../utils/has-transform.mjs';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Scales a point based on a factor and an originPoint</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function scalePoint(point, scale, originPoint) {</span><span class="s3">\n    </span><span class="s1">const distanceFromOrigin = point - originPoint;</span><span class="s3">\n    </span><span class="s1">const scaled = scale * distanceFromOrigin;</span><span class="s3">\n    </span><span class="s1">return originPoint + scaled;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Applies a translate/scale delta to a point</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function applyPointDelta(point, translate, scale, originPoint, boxScale) {</span><span class="s3">\n    </span><span class="s1">if (boxScale !== undefined) {</span><span class="s3">\n        </span><span class="s1">point = scalePoint(point, boxScale, originPoint);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return scalePoint(point, scale, originPoint) + translate;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Applies a translate/scale delta to an axis</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function applyAxisDelta(axis, translate = 0, scale = 1, originPoint, boxScale) {</span><span class="s3">\n    </span><span class="s1">axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);</span><span class="s3">\n    </span><span class="s1">axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Applies a translate/scale delta to a box</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function applyBoxDelta(box, { x, y }) {</span><span class="s3">\n    </span><span class="s1">applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);</span><span class="s3">\n    </span><span class="s1">applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const TREE_SCALE_SNAP_MIN = 0.999999999999;</span><span class="s3">\n</span><span class="s1">const TREE_SCALE_SNAP_MAX = 1.0000000000001;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms</span><span class="s3">\n </span><span class="s1">* in a tree upon our box before then calculating how to project it into our desired viewport-relative box</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This is the final nested loop within updateLayoutDelta for future refactoring</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {</span><span class="s3">\n    </span><span class="s1">const treeLength = treePath.length;</span><span class="s3">\n    </span><span class="s1">if (!treeLength)</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">// Reset the treeScale</span><span class="s3">\n    </span><span class="s1">treeScale.x = treeScale.y = 1;</span><span class="s3">\n    </span><span class="s1">let node;</span><span class="s3">\n    </span><span class="s1">let delta;</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; treeLength; i++) {</span><span class="s3">\n        </span><span class="s1">node = treePath[i];</span><span class="s3">\n        </span><span class="s1">delta = node.projectionDelta;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* TODO: Prefer to remove this, but currently we have motion components with</span><span class="s3">\n         </span><span class="s1">* display: contents in Framer.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">const { visualElement } = node.options;</span><span class="s3">\n        </span><span class="s1">if (visualElement &amp;&amp;</span><span class="s3">\n            </span><span class="s1">visualElement.props.style &amp;&amp;</span><span class="s3">\n            </span><span class="s1">visualElement.props.style.display === </span><span class="s3">\&quot;</span><span class="s1">contents</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (isSharedTransition &amp;&amp;</span><span class="s3">\n            </span><span class="s1">node.options.layoutScroll &amp;&amp;</span><span class="s3">\n            </span><span class="s1">node.scroll &amp;&amp;</span><span class="s3">\n            </span><span class="s1">node !== node.root) {</span><span class="s3">\n            </span><span class="s1">transformBox(box, {</span><span class="s3">\n                </span><span class="s1">x: -node.scroll.offset.x,</span><span class="s3">\n                </span><span class="s1">y: -node.scroll.offset.y,</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (delta) {</span><span class="s3">\n            </span><span class="s1">// Incoporate each ancestor's scale into a culmulative treeScale for this component</span><span class="s3">\n            </span><span class="s1">treeScale.x *= delta.x.scale;</span><span class="s3">\n            </span><span class="s1">treeScale.y *= delta.y.scale;</span><span class="s3">\n            </span><span class="s1">// Apply each ancestor's calculated delta into this component's recorded layout box</span><span class="s3">\n            </span><span class="s1">applyBoxDelta(box, delta);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (isSharedTransition &amp;&amp; hasTransform(node.latestValues)) {</span><span class="s3">\n            </span><span class="s1">transformBox(box, node.latestValues);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Snap tree scale back to 1 if it's within a non-perceivable threshold.</span><span class="s3">\n     </span><span class="s1">* This will help reduce useless scales getting rendered.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">if (treeScale.x &lt; TREE_SCALE_SNAP_MAX &amp;&amp;</span><span class="s3">\n        </span><span class="s1">treeScale.x &gt; TREE_SCALE_SNAP_MIN) {</span><span class="s3">\n        </span><span class="s1">treeScale.x = 1.0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (treeScale.y &lt; TREE_SCALE_SNAP_MAX &amp;&amp;</span><span class="s3">\n        </span><span class="s1">treeScale.y &gt; TREE_SCALE_SNAP_MIN) {</span><span class="s3">\n        </span><span class="s1">treeScale.y = 1.0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function translateAxis(axis, distance) {</span><span class="s3">\n    </span><span class="s1">axis.min = axis.min + distance;</span><span class="s3">\n    </span><span class="s1">axis.max = axis.max + distance;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Apply a transform to an axis from the latest resolved motion values.</span><span class="s3">\n </span><span class="s1">* This function basically acts as a bridge between a flat motion value map</span><span class="s3">\n </span><span class="s1">* and applyAxisDelta</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {</span><span class="s3">\n    </span><span class="s1">const originPoint = mixNumber(axis.min, axis.max, axisOrigin);</span><span class="s3">\n    </span><span class="s1">// Apply the axis delta to the final axis</span><span class="s3">\n    </span><span class="s1">applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Apply a transform to a box from the latest resolved motion values.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function transformBox(box, transform) {</span><span class="s3">\n    </span><span class="s1">transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);</span><span class="s3">\n    </span><span class="s1">transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { applyAxisDelta, applyBoxDelta, applyPointDelta, applyTreeDeltas, scalePoint, transformAxis, transformBox, translateAxis };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">221</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/projection/utils/measure.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { convertBoundingBoxToBox, transformBoxPoints } from '../geometry/conversion.mjs';</span><span class="s3">\n</span><span class="s1">import { translateAxis } from '../geometry/delta-apply.mjs';</span><span class="s3">\n\n</span><span class="s1">function measureViewportBox(instance, transformPoint) {</span><span class="s3">\n    </span><span class="s1">return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function measurePageBox(element, rootProjectionNode, transformPagePoint) {</span><span class="s3">\n    </span><span class="s1">const viewportBox = measureViewportBox(element, transformPagePoint);</span><span class="s3">\n    </span><span class="s1">const { scroll } = rootProjectionNode;</span><span class="s3">\n    </span><span class="s1">if (scroll) {</span><span class="s3">\n        </span><span class="s1">translateAxis(viewportBox.x, scroll.offset.x);</span><span class="s3">\n        </span><span class="s1">translateAxis(viewportBox.y, scroll.offset.y);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return viewportBox;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { measurePageBox, measureViewportBox };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;AAAA;AACA;;;AAEA,SAAS,mBAAmB,QAAQ,EAAE,cAAc;IAChD,OAAO,IAAA,qNAAuB,EAAC,IAAA,gNAAkB,EAAC,SAAS,qBAAqB,IAAI;AACxF;AACA,SAAS,eAAe,OAAO,EAAE,kBAAkB,EAAE,kBAAkB;IACnE,MAAM,cAAc,mBAAmB,SAAS;IAChD,MAAM,EAAE,MAAM,EAAE,GAAG;IACnB,IAAI,QAAQ;QACR,IAAA,+MAAa,EAAC,YAAY,CAAC,EAAE,OAAO,MAAM,CAAC,CAAC;QAC5C,IAAA,+MAAa,EAAC,YAAY,CAAC,EAAE,OAAO,MAAM,CAAC,CAAC;IAChD;IACA,OAAO;AACX&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">248</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/motion/features/definitions.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;const featureProps = {</span><span class="s3">\n    </span><span class="s1">animation: [</span><span class="s3">\n        \&quot;</span><span class="s1">animate</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">variants</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">whileHover</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">whileTap</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">exit</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">whileInView</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">whileFocus</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">whileDrag</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">exit: [</span><span class="s3">\&quot;</span><span class="s1">exit</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">drag: [</span><span class="s3">\&quot;</span><span class="s1">drag</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">dragControls</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">focus: [</span><span class="s3">\&quot;</span><span class="s1">whileFocus</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">hover: [</span><span class="s3">\&quot;</span><span class="s1">whileHover</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">onHoverStart</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">onHoverEnd</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">tap: [</span><span class="s3">\&quot;</span><span class="s1">whileTap</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">onTap</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">onTapStart</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">onTapCancel</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">pan: [</span><span class="s3">\&quot;</span><span class="s1">onPan</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">onPanStart</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">onPanSessionStart</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">onPanEnd</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">inView: [</span><span class="s3">\&quot;</span><span class="s1">whileInView</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">onViewportEnter</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">onViewportLeave</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">layout: [</span><span class="s3">\&quot;</span><span class="s1">layout</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">layoutId</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const featureDefinitions = {};</span><span class="s3">\n</span><span class="s1">for (const key in featureProps) {</span><span class="s3">\n    </span><span class="s1">featureDefinitions[key] = {</span><span class="s3">\n        </span><span class="s1">isEnabled: (props) =&gt; featureProps[key].some((name) =&gt; !!props[name]),</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { featureDefinitions };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA,MAAM,eAAe;IACjB,WAAW;QACP;QACA;QACA;QACA;QACA;QACA;QACA;QACA;KACH;IACD,MAAM;QAAC;KAAO;IACd,MAAM;QAAC;QAAQ;KAAe;IAC9B,OAAO;QAAC;KAAa;IACrB,OAAO;QAAC;QAAc;QAAgB;KAAa;IACnD,KAAK;QAAC;QAAY;QAAS;QAAc;KAAc;IACvD,KAAK;QAAC;QAAS;QAAc;QAAqB;KAAW;IAC7D,QAAQ;QAAC;QAAe;QAAmB;KAAkB;IAC7D,QAAQ;QAAC;QAAU;KAAW;AAClC;AACA,MAAM,qBAAqB,CAAC;AAC5B,IAAK,MAAM,OAAO,aAAc;IAC5B,kBAAkB,CAAC,IAAI,GAAG;QACtB,WAAW,CAAC,QAAU,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,OAAS,CAAC,CAAC,KAAK,CAAC,KAAK;IACxE;AACJ&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">311</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/projection/geometry/models.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;const createAxisDelta = () =&gt; ({</span><span class="s3">\n    </span><span class="s1">translate: 0,</span><span class="s3">\n    </span><span class="s1">scale: 1,</span><span class="s3">\n    </span><span class="s1">origin: 0,</span><span class="s3">\n    </span><span class="s1">originPoint: 0,</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">const createDelta = () =&gt; ({</span><span class="s3">\n    </span><span class="s1">x: createAxisDelta(),</span><span class="s3">\n    </span><span class="s1">y: createAxisDelta(),</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">const createAxis = () =&gt; ({ min: 0, max: 0 });</span><span class="s3">\n</span><span class="s1">const createBox = () =&gt; ({</span><span class="s3">\n    </span><span class="s1">x: createAxis(),</span><span class="s3">\n    </span><span class="s1">y: createAxis(),</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">export { createAxis, createAxisDelta, createBox, createDelta };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;AAAA,MAAM,kBAAkB,IAAM,CAAC;QAC3B,WAAW;QACX,OAAO;QACP,QAAQ;QACR,aAAa;IACjB,CAAC;AACD,MAAM,cAAc,IAAM,CAAC;QACvB,GAAG;QACH,GAAG;IACP,CAAC;AACD,MAAM,aAAa,IAAM,CAAC;QAAE,KAAK;QAAG,KAAK;IAAE,CAAC;AAC5C,MAAM,YAAY,IAAM,CAAC;QACrB,GAAG;QACH,GAAG;IACP,CAAC&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">344</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/utils/is-browser.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;const isBrowser = typeof window !== </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export { isBrowser };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA,MAAM,YAAY,OAAO,WAAW&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">354</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/utils/reduced-motion/state.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// Does this device prefer reduced motion? Returns `null` server-side.</span><span class="s3">\n</span><span class="s1">const prefersReducedMotion = { current: null };</span><span class="s3">\n</span><span class="s1">const hasReducedMotionListener = { current: false };</span><span class="s3">\n\n</span><span class="s1">export { hasReducedMotionListener, prefersReducedMotion };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAA,sEAAsE;;;;;;;AACtE,MAAM,uBAAuB;IAAE,SAAS;AAAK;AAC7C,MAAM,2BAA2B;IAAE,SAAS;AAAM&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">372</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/utils/reduced-motion/index.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { isBrowser } from '../is-browser.mjs';</span><span class="s3">\n</span><span class="s1">import { hasReducedMotionListener, prefersReducedMotion } from './state.mjs';</span><span class="s3">\n\n</span><span class="s1">function initPrefersReducedMotion() {</span><span class="s3">\n    </span><span class="s1">hasReducedMotionListener.current = true;</span><span class="s3">\n    </span><span class="s1">if (!isBrowser)</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">if (window.matchMedia) {</span><span class="s3">\n        </span><span class="s1">const motionMediaQuery = window.matchMedia(</span><span class="s3">\&quot;</span><span class="s1">(prefers-reduced-motion)</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">const setReducedMotionPreferences = () =&gt; (prefersReducedMotion.current = motionMediaQuery.matches);</span><span class="s3">\n        </span><span class="s1">motionMediaQuery.addEventListener(</span><span class="s3">\&quot;</span><span class="s1">change</span><span class="s3">\&quot;</span><span class="s1">, setReducedMotionPreferences);</span><span class="s3">\n        </span><span class="s1">setReducedMotionPreferences();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">prefersReducedMotion.current = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { initPrefersReducedMotion };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;AACA;;;AAEA,SAAS;IACL,qNAAwB,CAAC,OAAO,GAAG;IACnC,IAAI,CAAC,yLAAS,EACV;IACJ,IAAI,OAAO,UAAU,EAAE;QACnB,MAAM,mBAAmB,OAAO,UAAU,CAAC;QAC3C,MAAM,8BAA8B,IAAO,iNAAoB,CAAC,OAAO,GAAG,iBAAiB,OAAO;QAClG,iBAAiB,gBAAgB,CAAC,UAAU;QAC5C;IACJ,OACK;QACD,iNAAoB,CAAC,OAAO,GAAG;IACnC;AACJ&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">397</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/render/store.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;const visualElementStore = new WeakMap();</span><span class="s3">\n\n</span><span class="s1">export { visualElementStore };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA,MAAM,qBAAqB,IAAI&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">407</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/animation/utils/is-animation-controls.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;function isAnimationControls(v) {</span><span class="s3">\n    </span><span class="s1">return (v !== null &amp;&amp;</span><span class="s3">\n        </span><span class="s1">typeof v === </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n        </span><span class="s1">typeof v.start === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { isAnimationControls };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA,SAAS,oBAAoB,CAAC;IAC1B,OAAQ,MAAM,QACV,OAAO,MAAM,YACb,OAAO,EAAE,KAAK,KAAK;AAC3B&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">419</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/render/utils/is-variant-label.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Decides if the supplied variable is variant label</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isVariantLabel(v) {</span><span class="s3">\n    </span><span class="s1">return typeof v === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">|| Array.isArray(v);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { isVariantLabel };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAA;;CAEC;;;;AACD,SAAS,eAAe,CAAC;IACrB,OAAO,OAAO,MAAM,YAAY,MAAM,OAAO,CAAC;AAClD&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">433</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/render/utils/variant-props.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;const variantPriorityOrder = [</span><span class="s3">\n    \&quot;</span><span class="s1">animate</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">whileInView</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">whileFocus</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">whileHover</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">whileTap</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">whileDrag</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">exit</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">const variantProps = [</span><span class="s3">\&quot;</span><span class="s1">initial</span><span class="s3">\&quot;</span><span class="s1">, ...variantPriorityOrder];</span><span class="s3">\n\n</span><span class="s1">export { variantPriorityOrder, variantProps };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;AAAA,MAAM,uBAAuB;IACzB;IACA;IACA;IACA;IACA;IACA;IACA;CACH;AACD,MAAM,eAAe;IAAC;OAAc;CAAqB&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">457</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/render/utils/is-controlling-variants.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';</span><span class="s3">\n</span><span class="s1">import { isVariantLabel } from './is-variant-label.mjs';</span><span class="s3">\n</span><span class="s1">import { variantProps } from './variant-props.mjs';</span><span class="s3">\n\n</span><span class="s1">function isControllingVariants(props) {</span><span class="s3">\n    </span><span class="s1">return (isAnimationControls(props.animate) ||</span><span class="s3">\n        </span><span class="s1">variantProps.some((name) =&gt; isVariantLabel(props[name])));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function isVariantNode(props) {</span><span class="s3">\n    </span><span class="s1">return Boolean(isControllingVariants(props) || props.variants);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { isControllingVariants, isVariantNode };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;AAAA;AACA;AACA;;;;AAEA,SAAS,sBAAsB,KAAK;IAChC,OAAQ,IAAA,8NAAmB,EAAC,MAAM,OAAO,KACrC,yMAAY,CAAC,IAAI,CAAC,CAAC,OAAS,IAAA,iNAAc,EAAC,KAAK,CAAC,KAAK;AAC9D;AACA,SAAS,cAAc,KAAK;IACxB,OAAO,QAAQ,sBAAsB,UAAU,MAAM,QAAQ;AACjE&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">480</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/render/utils/motion-values.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { isMotionValue, motionValue } from 'motion-dom';</span><span class="s3">\n\n</span><span class="s1">function updateMotionValuesFromProps(element, next, prev) {</span><span class="s3">\n    </span><span class="s1">for (const key in next) {</span><span class="s3">\n        </span><span class="s1">const nextValue = next[key];</span><span class="s3">\n        </span><span class="s1">const prevValue = prev[key];</span><span class="s3">\n        </span><span class="s1">if (isMotionValue(nextValue)) {</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* If this is a motion value found in props or style, we want to add it</span><span class="s3">\n             </span><span class="s1">* to our visual element's motion value map.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">element.addValue(key, nextValue);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (isMotionValue(prevValue)) {</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* If we're swapping from a motion value to a static value,</span><span class="s3">\n             </span><span class="s1">* create a new motion value from that</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">element.addValue(key, motionValue(nextValue, { owner: element }));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (prevValue !== nextValue) {</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* If this is a flat value that has changed, update the motion value</span><span class="s3">\n             </span><span class="s1">* or create one if it doesn't exist. We only want to do this if we're</span><span class="s3">\n             </span><span class="s1">* not handling the value with our animation state.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">if (element.hasValue(key)) {</span><span class="s3">\n                </span><span class="s1">const existingValue = element.getValue(key);</span><span class="s3">\n                </span><span class="s1">if (existingValue.liveStyle === true) {</span><span class="s3">\n                    </span><span class="s1">existingValue.jump(nextValue);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (!existingValue.hasAnimated) {</span><span class="s3">\n                    </span><span class="s1">existingValue.set(nextValue);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">const latestValue = element.getStaticValue(key);</span><span class="s3">\n                </span><span class="s1">element.addValue(key, motionValue(latestValue !== undefined ? latestValue : nextValue, { owner: element }));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Handle removed values</span><span class="s3">\n    </span><span class="s1">for (const key in prev) {</span><span class="s3">\n        </span><span class="s1">if (next[key] === undefined)</span><span class="s3">\n            </span><span class="s1">element.removeValue(key);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return next;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { updateMotionValuesFromProps };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;AAAA;;AAEA,SAAS,4BAA4B,OAAO,EAAE,IAAI,EAAE,IAAI;IACpD,IAAK,MAAM,OAAO,KAAM;QACpB,MAAM,YAAY,IAAI,CAAC,IAAI;QAC3B,MAAM,YAAY,IAAI,CAAC,IAAI;QAC3B,IAAI,IAAA,2MAAa,EAAC,YAAY;YAC1B;;;aAGC,GACD,QAAQ,QAAQ,CAAC,KAAK;QAC1B,OACK,IAAI,IAAA,2MAAa,EAAC,YAAY;YAC/B;;;aAGC,GACD,QAAQ,QAAQ,CAAC,KAAK,IAAA,gLAAW,EAAC,WAAW;gBAAE,OAAO;YAAQ;QAClE,OACK,IAAI,cAAc,WAAW;YAC9B;;;;aAIC,GACD,IAAI,QAAQ,QAAQ,CAAC,MAAM;gBACvB,MAAM,gBAAgB,QAAQ,QAAQ,CAAC;gBACvC,IAAI,cAAc,SAAS,KAAK,MAAM;oBAClC,cAAc,IAAI,CAAC;gBACvB,OACK,IAAI,CAAC,cAAc,WAAW,EAAE;oBACjC,cAAc,GAAG,CAAC;gBACtB;YACJ,OACK;gBACD,MAAM,cAAc,QAAQ,cAAc,CAAC;gBAC3C,QAAQ,QAAQ,CAAC,KAAK,IAAA,gLAAW,EAAC,gBAAgB,YAAY,cAAc,WAAW;oBAAE,OAAO;gBAAQ;YAC5G;QACJ;IACJ;IACA,wBAAwB;IACxB,IAAK,MAAM,OAAO,KAAM;QACpB,IAAI,IAAI,CAAC,IAAI,KAAK,WACd,QAAQ,WAAW,CAAC;IAC5B;IACA,OAAO;AACX&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">534</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/render/utils/resolve-variants.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;function getValueState(visualElement) {</span><span class="s3">\n    </span><span class="s1">const state = [{}, {}];</span><span class="s3">\n    </span><span class="s1">visualElement?.values.forEach((value, key) =&gt; {</span><span class="s3">\n        </span><span class="s1">state[0][key] = value.get();</span><span class="s3">\n        </span><span class="s1">state[1][key] = value.getVelocity();</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return state;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function resolveVariantFromProps(props, definition, custom, visualElement) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* If the variant definition is a function, resolve.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">if (typeof definition === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">const [current, velocity] = getValueState(visualElement);</span><span class="s3">\n        </span><span class="s1">definition = definition(custom !== undefined ? custom : props.custom, current, velocity);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* If the variant definition is a variant label, or</span><span class="s3">\n     </span><span class="s1">* the function returned a variant label, resolve.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">if (typeof definition === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">definition = props.variants &amp;&amp; props.variants[definition];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* At this point we've resolved both functions and variant labels,</span><span class="s3">\n     </span><span class="s1">* but the resolved variant label might itself have been a function.</span><span class="s3">\n     </span><span class="s1">* If so, resolve. This can only have returned a valid target object.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">if (typeof definition === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">const [current, velocity] = getValueState(visualElement);</span><span class="s3">\n        </span><span class="s1">definition = definition(custom !== undefined ? custom : props.custom, current, velocity);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return definition;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { resolveVariantFromProps };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA,SAAS,cAAc,aAAa;IAChC,MAAM,QAAQ;QAAC,CAAC;QAAG,CAAC;KAAE;IACtB,0BAAA,oCAAA,cAAe,MAAM,CAAC,OAAO,CAAC,CAAC,OAAO;QAClC,KAAK,CAAC,EAAE,CAAC,IAAI,GAAG,MAAM,GAAG;QACzB,KAAK,CAAC,EAAE,CAAC,IAAI,GAAG,MAAM,WAAW;IACrC;IACA,OAAO;AACX;AACA,SAAS,wBAAwB,KAAK,EAAE,UAAU,EAAE,MAAM,EAAE,aAAa;IACrE;;KAEC,GACD,IAAI,OAAO,eAAe,YAAY;QAClC,MAAM,CAAC,SAAS,SAAS,GAAG,cAAc;QAC1C,aAAa,WAAW,WAAW,YAAY,SAAS,MAAM,MAAM,EAAE,SAAS;IACnF;IACA;;;KAGC,GACD,IAAI,OAAO,eAAe,UAAU;QAChC,aAAa,MAAM,QAAQ,IAAI,MAAM,QAAQ,CAAC,WAAW;IAC7D;IACA;;;;KAIC,GACD,IAAI,OAAO,eAAe,YAAY;QAClC,MAAM,CAAC,SAAS,SAAS,GAAG,cAAc;QAC1C,aAAa,WAAW,WAAW,YAAY,SAAS,MAAM,MAAM,EAAE,SAAS;IACnF;IACA,OAAO;AACX&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">577</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/render/VisualElement.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { KeyframeResolver, time, frame, isMotionValue, cancelFrame, transformProps, motionValue, findValueType, complex, getAnimatableNone, microtask } from 'motion-dom';</span><span class="s3">\n</span><span class="s1">import { warnOnce, isNumericalString, isZeroValueString, SubscriptionManager } from 'motion-utils';</span><span class="s3">\n</span><span class="s1">import { featureDefinitions } from '../motion/features/definitions.mjs';</span><span class="s3">\n</span><span class="s1">import { createBox } from '../projection/geometry/models.mjs';</span><span class="s3">\n</span><span class="s1">import { initPrefersReducedMotion } from '../utils/reduced-motion/index.mjs';</span><span class="s3">\n</span><span class="s1">import { hasReducedMotionListener, prefersReducedMotion } from '../utils/reduced-motion/state.mjs';</span><span class="s3">\n</span><span class="s1">import { visualElementStore } from './store.mjs';</span><span class="s3">\n</span><span class="s1">import { isControllingVariants, isVariantNode } from './utils/is-controlling-variants.mjs';</span><span class="s3">\n</span><span class="s1">import { updateMotionValuesFromProps } from './utils/motion-values.mjs';</span><span class="s3">\n</span><span class="s1">import { resolveVariantFromProps } from './utils/resolve-variants.mjs';</span><span class="s3">\n\n</span><span class="s1">const propEventHandlers = [</span><span class="s3">\n    \&quot;</span><span class="s1">AnimationStart</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">AnimationComplete</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">Update</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">BeforeLayoutMeasure</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">LayoutMeasure</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">LayoutAnimationStart</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">LayoutAnimationComplete</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A VisualElement is an imperative abstraction around UI elements such as</span><span class="s3">\n </span><span class="s1">* HTMLElement, SVGElement, Three.Object3D etc.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class VisualElement {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* This method takes React props and returns found MotionValues. For example, HTML</span><span class="s3">\n     </span><span class="s1">* MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* This isn't an abstract method as it needs calling in the constructor, but it is</span><span class="s3">\n     </span><span class="s1">* intended to be one.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {</span><span class="s3">\n        </span><span class="s1">return {};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState, }, options = {}) {</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* A reference to the current underlying Instance, e.g. a HTMLElement</span><span class="s3">\n         </span><span class="s1">* or Three.Mesh etc.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.current = null;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* A set containing references to this VisualElement's children.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.children = new Set();</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Determine what role this visual element should take in the variant tree.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.isVariantNode = false;</span><span class="s3">\n        </span><span class="s1">this.isControllingVariants = false;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Decides whether this VisualElement should animate in reduced motion</span><span class="s3">\n         </span><span class="s1">* mode.</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* TODO: This is currently set on every individual VisualElement but feels</span><span class="s3">\n         </span><span class="s1">* like it could be set globally.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.shouldReduceMotion = null;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* A map of all motion values attached to this visual element. Motion</span><span class="s3">\n         </span><span class="s1">* values are source of truth for any given animated value. A motion</span><span class="s3">\n         </span><span class="s1">* value might be provided externally by the component via props.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.values = new Map();</span><span class="s3">\n        </span><span class="s1">this.KeyframeResolver = KeyframeResolver;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Cleanup functions for active features (hover/tap/exit etc)</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.features = {};</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* A map of every subscription that binds the provided or generated</span><span class="s3">\n         </span><span class="s1">* motion values onChange listeners to this visual element.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.valueSubscriptions = new Map();</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* A reference to the previously-provided motion values as returned</span><span class="s3">\n         </span><span class="s1">* from scrapeMotionValuesFromProps. We use the keys in here to determine</span><span class="s3">\n         </span><span class="s1">* if any motion values need to be removed after props are updated.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.prevMotionValues = {};</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* An object containing a SubscriptionManager for each active event.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.events = {};</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* An object containing an unsubscribe function for each prop event subscription.</span><span class="s3">\n         </span><span class="s1">* For example, every </span><span class="s3">\&quot;</span><span class="s1">Update</span><span class="s3">\&quot; </span><span class="s1">event can have multiple subscribers via</span><span class="s3">\n         </span><span class="s1">* VisualElement.on(), but only one of those can be defined via the onUpdate prop.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.propEventSubscriptions = {};</span><span class="s3">\n        </span><span class="s1">this.notifyUpdate = () =&gt; this.notify(</span><span class="s3">\&quot;</span><span class="s1">Update</span><span class="s3">\&quot;</span><span class="s1">, this.latestValues);</span><span class="s3">\n        </span><span class="s1">this.render = () =&gt; {</span><span class="s3">\n            </span><span class="s1">if (!this.current)</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">this.triggerBuild();</span><span class="s3">\n            </span><span class="s1">this.renderInstance(this.current, this.renderState, this.props.style, this.projection);</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">this.renderScheduledAt = 0.0;</span><span class="s3">\n        </span><span class="s1">this.scheduleRender = () =&gt; {</span><span class="s3">\n            </span><span class="s1">const now = time.now();</span><span class="s3">\n            </span><span class="s1">if (this.renderScheduledAt &lt; now) {</span><span class="s3">\n                </span><span class="s1">this.renderScheduledAt = now;</span><span class="s3">\n                </span><span class="s1">frame.render(this.render, false, true);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">const { latestValues, renderState } = visualState;</span><span class="s3">\n        </span><span class="s1">this.latestValues = latestValues;</span><span class="s3">\n        </span><span class="s1">this.baseTarget = { ...latestValues };</span><span class="s3">\n        </span><span class="s1">this.initialValues = props.initial ? { ...latestValues } : {};</span><span class="s3">\n        </span><span class="s1">this.renderState = renderState;</span><span class="s3">\n        </span><span class="s1">this.parent = parent;</span><span class="s3">\n        </span><span class="s1">this.props = props;</span><span class="s3">\n        </span><span class="s1">this.presenceContext = presenceContext;</span><span class="s3">\n        </span><span class="s1">this.depth = parent ? parent.depth + 1 : 0;</span><span class="s3">\n        </span><span class="s1">this.reducedMotionConfig = reducedMotionConfig;</span><span class="s3">\n        </span><span class="s1">this.options = options;</span><span class="s3">\n        </span><span class="s1">this.blockInitialAnimation = Boolean(blockInitialAnimation);</span><span class="s3">\n        </span><span class="s1">this.isControllingVariants = isControllingVariants(props);</span><span class="s3">\n        </span><span class="s1">this.isVariantNode = isVariantNode(props);</span><span class="s3">\n        </span><span class="s1">if (this.isVariantNode) {</span><span class="s3">\n            </span><span class="s1">this.variantChildren = new Set();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.manuallyAnimateOnMount = Boolean(parent &amp;&amp; parent.current);</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Any motion values that are provided to the element when created</span><span class="s3">\n         </span><span class="s1">* aren't yet bound to the element, as this would technically be impure.</span><span class="s3">\n         </span><span class="s1">* However, we iterate through the motion values and set them to the</span><span class="s3">\n         </span><span class="s1">* initial values for this component.</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* TODO: This is impure and we should look at changing this to run on mount.</span><span class="s3">\n         </span><span class="s1">* Doing so will break some tests but this isn't necessarily a breaking change,</span><span class="s3">\n         </span><span class="s1">* more a reflection of the test.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this);</span><span class="s3">\n        </span><span class="s1">for (const key in initialMotionValues) {</span><span class="s3">\n            </span><span class="s1">const value = initialMotionValues[key];</span><span class="s3">\n            </span><span class="s1">if (latestValues[key] !== undefined &amp;&amp; isMotionValue(value)) {</span><span class="s3">\n                </span><span class="s1">value.set(latestValues[key]);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">mount(instance) {</span><span class="s3">\n        </span><span class="s1">this.current = instance;</span><span class="s3">\n        </span><span class="s1">visualElementStore.set(instance, this);</span><span class="s3">\n        </span><span class="s1">if (this.projection &amp;&amp; !this.projection.instance) {</span><span class="s3">\n            </span><span class="s1">this.projection.mount(instance);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this.parent &amp;&amp; this.isVariantNode &amp;&amp; !this.isControllingVariants) {</span><span class="s3">\n            </span><span class="s1">this.removeFromVariantTree = this.parent.addVariantChild(this);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.values.forEach((value, key) =&gt; this.bindToMotionValue(key, value));</span><span class="s3">\n        </span><span class="s1">if (!hasReducedMotionListener.current) {</span><span class="s3">\n            </span><span class="s1">initPrefersReducedMotion();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.shouldReduceMotion =</span><span class="s3">\n            </span><span class="s1">this.reducedMotionConfig === </span><span class="s3">\&quot;</span><span class="s1">never</span><span class="s3">\&quot;\n                </span><span class="s1">? false</span><span class="s3">\n                </span><span class="s1">: this.reducedMotionConfig === </span><span class="s3">\&quot;</span><span class="s1">always</span><span class="s3">\&quot;\n                    </span><span class="s1">? true</span><span class="s3">\n                    </span><span class="s1">: prefersReducedMotion.current;</span><span class="s3">\n        </span><span class="s1">if (process.env.NODE_ENV !== </span><span class="s3">\&quot;</span><span class="s1">production</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">warnOnce(this.shouldReduceMotion !== true, </span><span class="s3">\&quot;</span><span class="s1">You have Reduced Motion enabled on your device. Animations may not appear as expected.</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">reduced-motion-disabled</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.parent?.addChild(this);</span><span class="s3">\n        </span><span class="s1">this.update(this.props, this.presenceContext);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">unmount() {</span><span class="s3">\n        </span><span class="s1">this.projection &amp;&amp; this.projection.unmount();</span><span class="s3">\n        </span><span class="s1">cancelFrame(this.notifyUpdate);</span><span class="s3">\n        </span><span class="s1">cancelFrame(this.render);</span><span class="s3">\n        </span><span class="s1">this.valueSubscriptions.forEach((remove) =&gt; remove());</span><span class="s3">\n        </span><span class="s1">this.valueSubscriptions.clear();</span><span class="s3">\n        </span><span class="s1">this.removeFromVariantTree &amp;&amp; this.removeFromVariantTree();</span><span class="s3">\n        </span><span class="s1">this.parent?.removeChild(this);</span><span class="s3">\n        </span><span class="s1">for (const key in this.events) {</span><span class="s3">\n            </span><span class="s1">this.events[key].clear();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (const key in this.features) {</span><span class="s3">\n            </span><span class="s1">const feature = this.features[key];</span><span class="s3">\n            </span><span class="s1">if (feature) {</span><span class="s3">\n                </span><span class="s1">feature.unmount();</span><span class="s3">\n                </span><span class="s1">feature.isMounted = false;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.current = null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">addChild(child) {</span><span class="s3">\n        </span><span class="s1">this.children.add(child);</span><span class="s3">\n        </span><span class="s1">this.enteringChildren ?? (this.enteringChildren = new Set());</span><span class="s3">\n        </span><span class="s1">this.enteringChildren.add(child);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">removeChild(child) {</span><span class="s3">\n        </span><span class="s1">this.children.delete(child);</span><span class="s3">\n        </span><span class="s1">this.enteringChildren &amp;&amp; this.enteringChildren.delete(child);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">bindToMotionValue(key, value) {</span><span class="s3">\n        </span><span class="s1">if (this.valueSubscriptions.has(key)) {</span><span class="s3">\n            </span><span class="s1">this.valueSubscriptions.get(key)();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const valueIsTransform = transformProps.has(key);</span><span class="s3">\n        </span><span class="s1">if (valueIsTransform &amp;&amp; this.onBindTransform) {</span><span class="s3">\n            </span><span class="s1">this.onBindTransform();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const removeOnChange = value.on(</span><span class="s3">\&quot;</span><span class="s1">change</span><span class="s3">\&quot;</span><span class="s1">, (latestValue) =&gt; {</span><span class="s3">\n            </span><span class="s1">this.latestValues[key] = latestValue;</span><span class="s3">\n            </span><span class="s1">this.props.onUpdate &amp;&amp; frame.preRender(this.notifyUpdate);</span><span class="s3">\n            </span><span class="s1">if (valueIsTransform &amp;&amp; this.projection) {</span><span class="s3">\n                </span><span class="s1">this.projection.isTransformDirty = true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this.scheduleRender();</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">let removeSyncCheck;</span><span class="s3">\n        </span><span class="s1">if (window.MotionCheckAppearSync) {</span><span class="s3">\n            </span><span class="s1">removeSyncCheck = window.MotionCheckAppearSync(this, key, value);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.valueSubscriptions.set(key, () =&gt; {</span><span class="s3">\n            </span><span class="s1">removeOnChange();</span><span class="s3">\n            </span><span class="s1">if (removeSyncCheck)</span><span class="s3">\n                </span><span class="s1">removeSyncCheck();</span><span class="s3">\n            </span><span class="s1">if (value.owner)</span><span class="s3">\n                </span><span class="s1">value.stop();</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">sortNodePosition(other) {</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* If these nodes aren't even of the same type we can't compare their depth.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">if (!this.current ||</span><span class="s3">\n            </span><span class="s1">!this.sortInstanceNodePosition ||</span><span class="s3">\n            </span><span class="s1">this.type !== other.type) {</span><span class="s3">\n            </span><span class="s1">return 0;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this.sortInstanceNodePosition(this.current, other.current);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">updateFeatures() {</span><span class="s3">\n        </span><span class="s1">let key = </span><span class="s3">\&quot;</span><span class="s1">animation</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">for (key in featureDefinitions) {</span><span class="s3">\n            </span><span class="s1">const featureDefinition = featureDefinitions[key];</span><span class="s3">\n            </span><span class="s1">if (!featureDefinition)</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">const { isEnabled, Feature: FeatureConstructor } = featureDefinition;</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* If this feature is enabled but not active, make a new instance.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">if (!this.features[key] &amp;&amp;</span><span class="s3">\n                </span><span class="s1">FeatureConstructor &amp;&amp;</span><span class="s3">\n                </span><span class="s1">isEnabled(this.props)) {</span><span class="s3">\n                </span><span class="s1">this.features[key] = new FeatureConstructor(this);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* If we have a feature, mount or update it.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">if (this.features[key]) {</span><span class="s3">\n                </span><span class="s1">const feature = this.features[key];</span><span class="s3">\n                </span><span class="s1">if (feature.isMounted) {</span><span class="s3">\n                    </span><span class="s1">feature.update();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">feature.mount();</span><span class="s3">\n                    </span><span class="s1">feature.isMounted = true;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">triggerBuild() {</span><span class="s3">\n        </span><span class="s1">this.build(this.renderState, this.latestValues, this.props);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Measure the current viewport box with or without transforms.</span><span class="s3">\n     </span><span class="s1">* Only measures axis-aligned boxes, rotate and skew must be manually</span><span class="s3">\n     </span><span class="s1">* removed with a re-render to work.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">measureViewportBox() {</span><span class="s3">\n        </span><span class="s1">return this.current</span><span class="s3">\n            </span><span class="s1">? this.measureInstanceViewportBox(this.current, this.props)</span><span class="s3">\n            </span><span class="s1">: createBox();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getStaticValue(key) {</span><span class="s3">\n        </span><span class="s1">return this.latestValues[key];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">setStaticValue(key, value) {</span><span class="s3">\n        </span><span class="s1">this.latestValues[key] = value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Update the provided props. Ensure any newly-added motion values are</span><span class="s3">\n     </span><span class="s1">* added to our map, old ones removed, and listeners updated.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">update(props, presenceContext) {</span><span class="s3">\n        </span><span class="s1">if (props.transformTemplate || this.props.transformTemplate) {</span><span class="s3">\n            </span><span class="s1">this.scheduleRender();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.prevProps = this.props;</span><span class="s3">\n        </span><span class="s1">this.props = props;</span><span class="s3">\n        </span><span class="s1">this.prevPresenceContext = this.presenceContext;</span><span class="s3">\n        </span><span class="s1">this.presenceContext = presenceContext;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Update prop event handlers ie onAnimationStart, onAnimationComplete</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; propEventHandlers.length; i++) {</span><span class="s3">\n            </span><span class="s1">const key = propEventHandlers[i];</span><span class="s3">\n            </span><span class="s1">if (this.propEventSubscriptions[key]) {</span><span class="s3">\n                </span><span class="s1">this.propEventSubscriptions[key]();</span><span class="s3">\n                </span><span class="s1">delete this.propEventSubscriptions[key];</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const listenerName = (</span><span class="s3">\&quot;</span><span class="s1">on</span><span class="s3">\&quot; </span><span class="s1">+ key);</span><span class="s3">\n            </span><span class="s1">const listener = props[listenerName];</span><span class="s3">\n            </span><span class="s1">if (listener) {</span><span class="s3">\n                </span><span class="s1">this.propEventSubscriptions[key] = this.on(key, listener);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues);</span><span class="s3">\n        </span><span class="s1">if (this.handleChildMotionValue) {</span><span class="s3">\n            </span><span class="s1">this.handleChildMotionValue();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getProps() {</span><span class="s3">\n        </span><span class="s1">return this.props;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Returns the variant definition with a given name.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getVariant(name) {</span><span class="s3">\n        </span><span class="s1">return this.props.variants ? this.props.variants[name] : undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Returns the defined default transition on this component.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getDefaultTransition() {</span><span class="s3">\n        </span><span class="s1">return this.props.transition;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getTransformPagePoint() {</span><span class="s3">\n        </span><span class="s1">return this.props.transformPagePoint;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getClosestVariantNode() {</span><span class="s3">\n        </span><span class="s1">return this.isVariantNode</span><span class="s3">\n            </span><span class="s1">? this</span><span class="s3">\n            </span><span class="s1">: this.parent</span><span class="s3">\n                </span><span class="s1">? this.parent.getClosestVariantNode()</span><span class="s3">\n                </span><span class="s1">: undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Add a child visual element to our set of children.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">addVariantChild(child) {</span><span class="s3">\n        </span><span class="s1">const closestVariantNode = this.getClosestVariantNode();</span><span class="s3">\n        </span><span class="s1">if (closestVariantNode) {</span><span class="s3">\n            </span><span class="s1">closestVariantNode.variantChildren &amp;&amp;</span><span class="s3">\n                </span><span class="s1">closestVariantNode.variantChildren.add(child);</span><span class="s3">\n            </span><span class="s1">return () =&gt; closestVariantNode.variantChildren.delete(child);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Add a motion value and bind it to this visual element.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">addValue(key, value) {</span><span class="s3">\n        </span><span class="s1">// Remove existing value if it exists</span><span class="s3">\n        </span><span class="s1">const existingValue = this.values.get(key);</span><span class="s3">\n        </span><span class="s1">if (value !== existingValue) {</span><span class="s3">\n            </span><span class="s1">if (existingValue)</span><span class="s3">\n                </span><span class="s1">this.removeValue(key);</span><span class="s3">\n            </span><span class="s1">this.bindToMotionValue(key, value);</span><span class="s3">\n            </span><span class="s1">this.values.set(key, value);</span><span class="s3">\n            </span><span class="s1">this.latestValues[key] = value.get();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Remove a motion value and unbind any active subscriptions.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">removeValue(key) {</span><span class="s3">\n        </span><span class="s1">this.values.delete(key);</span><span class="s3">\n        </span><span class="s1">const unsubscribe = this.valueSubscriptions.get(key);</span><span class="s3">\n        </span><span class="s1">if (unsubscribe) {</span><span class="s3">\n            </span><span class="s1">unsubscribe();</span><span class="s3">\n            </span><span class="s1">this.valueSubscriptions.delete(key);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">delete this.latestValues[key];</span><span class="s3">\n        </span><span class="s1">this.removeValueFromRenderState(key, this.renderState);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Check whether we have a motion value for this key</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">hasValue(key) {</span><span class="s3">\n        </span><span class="s1">return this.values.has(key);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getValue(key, defaultValue) {</span><span class="s3">\n        </span><span class="s1">if (this.props.values &amp;&amp; this.props.values[key]) {</span><span class="s3">\n            </span><span class="s1">return this.props.values[key];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let value = this.values.get(key);</span><span class="s3">\n        </span><span class="s1">if (value === undefined &amp;&amp; defaultValue !== undefined) {</span><span class="s3">\n            </span><span class="s1">value = motionValue(defaultValue === null ? undefined : defaultValue, { owner: this });</span><span class="s3">\n            </span><span class="s1">this.addValue(key, value);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* If we're trying to animate to a previously unencountered value,</span><span class="s3">\n     </span><span class="s1">* we need to check for it in our state and as a last resort read it</span><span class="s3">\n     </span><span class="s1">* directly from the instance (which might have performance implications).</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">readValue(key, target) {</span><span class="s3">\n        </span><span class="s1">let value = this.latestValues[key] !== undefined || !this.current</span><span class="s3">\n            </span><span class="s1">? this.latestValues[key]</span><span class="s3">\n            </span><span class="s1">: this.getBaseTargetFromProps(this.props, key) ??</span><span class="s3">\n                </span><span class="s1">this.readValueFromInstance(this.current, key, this.options);</span><span class="s3">\n        </span><span class="s1">if (value !== undefined &amp;&amp; value !== null) {</span><span class="s3">\n            </span><span class="s1">if (typeof value === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n                </span><span class="s1">(isNumericalString(value) || isZeroValueString(value))) {</span><span class="s3">\n                </span><span class="s1">// If this is a number read as a string, ie </span><span class="s3">\&quot;</span><span class="s1">0</span><span class="s3">\&quot; </span><span class="s1">or </span><span class="s3">\&quot;</span><span class="s1">200</span><span class="s3">\&quot;</span><span class="s1">, convert it to a number</span><span class="s3">\n                </span><span class="s1">value = parseFloat(value);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (!findValueType(value) &amp;&amp; complex.test(target)) {</span><span class="s3">\n                </span><span class="s1">value = getAnimatableNone(key, target);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return isMotionValue(value) ? value.get() : value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Set the base target to later animate back to. This is currently</span><span class="s3">\n     </span><span class="s1">* only hydrated on creation and when we first read a value.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">setBaseTarget(key, value) {</span><span class="s3">\n        </span><span class="s1">this.baseTarget[key] = value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Find the base target for a value thats been removed from all animation</span><span class="s3">\n     </span><span class="s1">* props.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getBaseTarget(key) {</span><span class="s3">\n        </span><span class="s1">const { initial } = this.props;</span><span class="s3">\n        </span><span class="s1">let valueFromInitial;</span><span class="s3">\n        </span><span class="s1">if (typeof initial === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">|| typeof initial === </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">const variant = resolveVariantFromProps(this.props, initial, this.presenceContext?.custom);</span><span class="s3">\n            </span><span class="s1">if (variant) {</span><span class="s3">\n                </span><span class="s1">valueFromInitial = variant[key];</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* If this value still exists in the current initial variant, read that.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">if (initial &amp;&amp; valueFromInitial !== undefined) {</span><span class="s3">\n            </span><span class="s1">return valueFromInitial;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Alternatively, if this VisualElement config has defined a getBaseTarget</span><span class="s3">\n         </span><span class="s1">* so we can read the value from an alternative source, try that.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">const target = this.getBaseTargetFromProps(this.props, key);</span><span class="s3">\n        </span><span class="s1">if (target !== undefined &amp;&amp; !isMotionValue(target))</span><span class="s3">\n            </span><span class="s1">return target;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* If the value was initially defined on initial, but it doesn't any more,</span><span class="s3">\n         </span><span class="s1">* return undefined. Otherwise return the value as initially read from the DOM.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">return this.initialValues[key] !== undefined &amp;&amp;</span><span class="s3">\n            </span><span class="s1">valueFromInitial === undefined</span><span class="s3">\n            </span><span class="s1">? undefined</span><span class="s3">\n            </span><span class="s1">: this.baseTarget[key];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">on(eventName, callback) {</span><span class="s3">\n        </span><span class="s1">if (!this.events[eventName]) {</span><span class="s3">\n            </span><span class="s1">this.events[eventName] = new SubscriptionManager();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this.events[eventName].add(callback);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">notify(eventName, ...args) {</span><span class="s3">\n        </span><span class="s1">if (this.events[eventName]) {</span><span class="s3">\n            </span><span class="s1">this.events[eventName].notify(...args);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">scheduleRenderMicrotask() {</span><span class="s3">\n        </span><span class="s1">microtask.render(this.render);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { VisualElement };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1035</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/render/dom/DOMVisualElement.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { DOMKeyframesResolver, isMotionValue } from 'motion-dom';</span><span class="s3">\n</span><span class="s1">import { VisualElement } from '../VisualElement.mjs';</span><span class="s3">\n\n</span><span class="s1">class DOMVisualElement extends VisualElement {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">super(...arguments);</span><span class="s3">\n        </span><span class="s1">this.KeyframeResolver = DOMKeyframesResolver;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">sortInstanceNodePosition(a, b) {</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* compareDocumentPosition returns a bitmask, by using the bitwise &amp;</span><span class="s3">\n         </span><span class="s1">* we're returning true if 2 in that bitmask is set to true. 2 is set</span><span class="s3">\n         </span><span class="s1">* to true if b preceeds a.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">return a.compareDocumentPosition(b) &amp; 2 ? 1 : -1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getBaseTargetFromProps(props, key) {</span><span class="s3">\n        </span><span class="s1">return props.style</span><span class="s3">\n            </span><span class="s1">? props.style[key]</span><span class="s3">\n            </span><span class="s1">: undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">removeValueFromRenderState(key, { vars, style }) {</span><span class="s3">\n        </span><span class="s1">delete vars[key];</span><span class="s3">\n        </span><span class="s1">delete style[key];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">handleChildMotionValue() {</span><span class="s3">\n        </span><span class="s1">if (this.childSubscription) {</span><span class="s3">\n            </span><span class="s1">this.childSubscription();</span><span class="s3">\n            </span><span class="s1">delete this.childSubscription;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const { children } = this.props;</span><span class="s3">\n        </span><span class="s1">if (isMotionValue(children)) {</span><span class="s3">\n            </span><span class="s1">this.childSubscription = children.on(</span><span class="s3">\&quot;</span><span class="s1">change</span><span class="s3">\&quot;</span><span class="s1">, (latest) =&gt; {</span><span class="s3">\n                </span><span class="s1">if (this.current) {</span><span class="s3">\n                    </span><span class="s1">this.current.textContent = `${latest}`;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { DOMVisualElement };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;AAAA;AACA;;;AAEA,MAAM,yBAAyB,8LAAa;IAKxC,yBAAyB,CAAC,EAAE,CAAC,EAAE;QAC3B;;;;SAIC,GACD,OAAO,EAAE,uBAAuB,CAAC,KAAK,IAAI,IAAI,CAAC;IACnD;IACA,uBAAuB,KAAK,EAAE,GAAG,EAAE;QAC/B,OAAO,MAAM,KAAK,GACZ,MAAM,KAAK,CAAC,IAAI,GAChB;IACV;IACA,2BAA2B,GAAG,EAAE,KAAe,EAAE;YAAjB,EAAE,IAAI,EAAE,KAAK,EAAE,GAAf;QAC5B,OAAO,IAAI,CAAC,IAAI;QAChB,OAAO,KAAK,CAAC,IAAI;IACrB;IACA,yBAAyB;QACrB,IAAI,IAAI,CAAC,iBAAiB,EAAE;YACxB,IAAI,CAAC,iBAAiB;YACtB,OAAO,IAAI,CAAC,iBAAiB;QACjC;QACA,MAAM,EAAE,QAAQ,EAAE,GAAG,IAAI,CAAC,KAAK;QAC/B,IAAI,IAAA,2MAAa,EAAC,WAAW;YACzB,IAAI,CAAC,iBAAiB,GAAG,SAAS,EAAE,CAAC,UAAU,CAAC;gBAC5C,IAAI,IAAI,CAAC,OAAO,EAAE;oBACd,IAAI,CAAC,OAAO,CAAC,WAAW,GAAG,AAAC,GAAS,OAAP;gBAClC;YACJ;QACJ;IACJ;IAlCA,aAAc;QACV,KAAK,IAAI;QACT,IAAI,CAAC,gBAAgB,GAAG,yNAAoB;IAChD;AAgCJ&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1084</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/render/html/utils/build-transform.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { transformPropOrder, getValueAsType, numberValueTypes } from 'motion-dom';</span><span class="s3">\n\n</span><span class="s1">const translateAlias = {</span><span class="s3">\n    </span><span class="s1">x: </span><span class="s3">\&quot;</span><span class="s1">translateX</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">y: </span><span class="s3">\&quot;</span><span class="s1">translateY</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">z: </span><span class="s3">\&quot;</span><span class="s1">translateZ</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">transformPerspective: </span><span class="s3">\&quot;</span><span class="s1">perspective</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const numTransforms = transformPropOrder.length;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Build a CSS transform style from individual x/y/scale etc properties.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This outputs with a default order of transforms/scales/rotations, this can be customised by</span><span class="s3">\n </span><span class="s1">* providing a transformTemplate function.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function buildTransform(latestValues, transform, transformTemplate) {</span><span class="s3">\n    </span><span class="s1">// The transform string we're going to build into.</span><span class="s3">\n    </span><span class="s1">let transformString = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">let transformIsDefault = true;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Loop over all possible transforms in order, adding the ones that</span><span class="s3">\n     </span><span class="s1">* are present to the transform string.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; numTransforms; i++) {</span><span class="s3">\n        </span><span class="s1">const key = transformPropOrder[i];</span><span class="s3">\n        </span><span class="s1">const value = latestValues[key];</span><span class="s3">\n        </span><span class="s1">if (value === undefined)</span><span class="s3">\n            </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">let valueIsDefault = true;</span><span class="s3">\n        </span><span class="s1">if (typeof value === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">valueIsDefault = value === (key.startsWith(</span><span class="s3">\&quot;</span><span class="s1">scale</span><span class="s3">\&quot;</span><span class="s1">) ? 1 : 0);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">valueIsDefault = parseFloat(value) === 0;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!valueIsDefault || transformTemplate) {</span><span class="s3">\n            </span><span class="s1">const valueAsType = getValueAsType(value, numberValueTypes[key]);</span><span class="s3">\n            </span><span class="s1">if (!valueIsDefault) {</span><span class="s3">\n                </span><span class="s1">transformIsDefault = false;</span><span class="s3">\n                </span><span class="s1">const transformName = translateAlias[key] || key;</span><span class="s3">\n                </span><span class="s1">transformString += `${transformName}(${valueAsType}) `;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (transformTemplate) {</span><span class="s3">\n                </span><span class="s1">transform[key] = valueAsType;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">transformString = transformString.trim();</span><span class="s3">\n    </span><span class="s1">// If we have a custom `transform` template, pass our transform values and</span><span class="s3">\n    </span><span class="s1">// generated transformString to that before returning</span><span class="s3">\n    </span><span class="s1">if (transformTemplate) {</span><span class="s3">\n        </span><span class="s1">transformString = transformTemplate(transform, transformIsDefault ? </span><span class="s3">\&quot;\&quot; </span><span class="s1">: transformString);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (transformIsDefault) {</span><span class="s3">\n        </span><span class="s1">transformString = </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return transformString;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { buildTransform };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;AAAA;AAAA;;AAEA,MAAM,iBAAiB;IACnB,GAAG;IACH,GAAG;IACH,GAAG;IACH,sBAAsB;AAC1B;AACA,MAAM,gBAAgB,6MAAkB,CAAC,MAAM;AAC/C;;;;;CAKC,GACD,SAAS,eAAe,YAAY,EAAE,SAAS,EAAE,iBAAiB;IAC9D,kDAAkD;IAClD,IAAI,kBAAkB;IACtB,IAAI,qBAAqB;IACzB;;;KAGC,GACD,IAAK,IAAI,IAAI,GAAG,IAAI,eAAe,IAAK;QACpC,MAAM,MAAM,6MAAkB,CAAC,EAAE;QACjC,MAAM,QAAQ,YAAY,CAAC,IAAI;QAC/B,IAAI,UAAU,WACV;QACJ,IAAI,iBAAiB;QACrB,IAAI,OAAO,UAAU,UAAU;YAC3B,iBAAiB,UAAU,CAAC,IAAI,UAAU,CAAC,WAAW,IAAI,CAAC;QAC/D,OACK;YACD,iBAAiB,WAAW,WAAW;QAC3C;QACA,IAAI,CAAC,kBAAkB,mBAAmB;YACtC,MAAM,cAAc,IAAA,iNAAc,EAAC,OAAO,uMAAgB,CAAC,IAAI;YAC/D,IAAI,CAAC,gBAAgB;gBACjB,qBAAqB;gBACrB,MAAM,gBAAgB,cAAc,CAAC,IAAI,IAAI;gBAC7C,mBAAmB,AAAC,GAAmB,OAAjB,eAAc,KAAe,OAAZ,aAAY;YACvD;YACA,IAAI,mBAAmB;gBACnB,SAAS,CAAC,IAAI,GAAG;YACrB;QACJ;IACJ;IACA,kBAAkB,gBAAgB,IAAI;IACtC,0EAA0E;IAC1E,qDAAqD;IACrD,IAAI,mBAAmB;QACnB,kBAAkB,kBAAkB,WAAW,qBAAqB,KAAK;IAC7E,OACK,IAAI,oBAAoB;QACzB,kBAAkB;IACtB;IACA,OAAO;AACX&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1148</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/render/html/utils/build-styles.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { transformProps, isCSSVariableName, getValueAsType, numberValueTypes } from 'motion-dom';</span><span class="s3">\n</span><span class="s1">import { buildTransform } from './build-transform.mjs';</span><span class="s3">\n\n</span><span class="s1">function buildHTMLStyles(state, latestValues, transformTemplate) {</span><span class="s3">\n    </span><span class="s1">const { style, vars, transformOrigin } = state;</span><span class="s3">\n    </span><span class="s1">// Track whether we encounter any transform or transformOrigin values.</span><span class="s3">\n    </span><span class="s1">let hasTransform = false;</span><span class="s3">\n    </span><span class="s1">let hasTransformOrigin = false;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Loop over all our latest animated values and decide whether to handle them</span><span class="s3">\n     </span><span class="s1">* as a style or CSS variable.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* Transforms and transform origins are kept separately for further processing.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">for (const key in latestValues) {</span><span class="s3">\n        </span><span class="s1">const value = latestValues[key];</span><span class="s3">\n        </span><span class="s1">if (transformProps.has(key)) {</span><span class="s3">\n            </span><span class="s1">// If this is a transform, flag to enable further transform processing</span><span class="s3">\n            </span><span class="s1">hasTransform = true;</span><span class="s3">\n            </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (isCSSVariableName(key)) {</span><span class="s3">\n            </span><span class="s1">vars[key] = value;</span><span class="s3">\n            </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">// Convert the value to its default value type, ie 0 -&gt; </span><span class="s3">\&quot;</span><span class="s1">0px</span><span class="s3">\&quot;\n            </span><span class="s1">const valueAsType = getValueAsType(value, numberValueTypes[key]);</span><span class="s3">\n            </span><span class="s1">if (key.startsWith(</span><span class="s3">\&quot;</span><span class="s1">origin</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n                </span><span class="s1">// If this is a transform origin, flag and enable further transform-origin processing</span><span class="s3">\n                </span><span class="s1">hasTransformOrigin = true;</span><span class="s3">\n                </span><span class="s1">transformOrigin[key] =</span><span class="s3">\n                    </span><span class="s1">valueAsType;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">style[key] = valueAsType;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!latestValues.transform) {</span><span class="s3">\n        </span><span class="s1">if (hasTransform || transformTemplate) {</span><span class="s3">\n            </span><span class="s1">style.transform = buildTransform(latestValues, state.transform, transformTemplate);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (style.transform) {</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* If we have previously created a transform but currently don't have any,</span><span class="s3">\n             </span><span class="s1">* reset transform style to none.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">style.transform = </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Build a transformOrigin style. Uses the same defaults as the browser for</span><span class="s3">\n     </span><span class="s1">* undefined origins.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">if (hasTransformOrigin) {</span><span class="s3">\n        </span><span class="s1">const { originX = </span><span class="s3">\&quot;</span><span class="s1">50%</span><span class="s3">\&quot;</span><span class="s1">, originY = </span><span class="s3">\&quot;</span><span class="s1">50%</span><span class="s3">\&quot;</span><span class="s1">, originZ = 0, } = transformOrigin;</span><span class="s3">\n        </span><span class="s1">style.transformOrigin = `${originX} ${originY} ${originZ}`;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { buildHTMLStyles };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;AAAA;AAAA;AAAA;AACA;;;AAEA,SAAS,gBAAgB,KAAK,EAAE,YAAY,EAAE,iBAAiB;IAC3D,MAAM,EAAE,KAAK,EAAE,IAAI,EAAE,eAAe,EAAE,GAAG;IACzC,sEAAsE;IACtE,IAAI,eAAe;IACnB,IAAI,qBAAqB;IACzB;;;;;KAKC,GACD,IAAK,MAAM,OAAO,aAAc;QAC5B,MAAM,QAAQ,YAAY,CAAC,IAAI;QAC/B,IAAI,yMAAc,CAAC,GAAG,CAAC,MAAM;YACzB,sEAAsE;YACtE,eAAe;YACf;QACJ,OACK,IAAI,IAAA,mNAAiB,EAAC,MAAM;YAC7B,IAAI,CAAC,IAAI,GAAG;YACZ;QACJ,OACK;YACD,6DAA6D;YAC7D,MAAM,cAAc,IAAA,iNAAc,EAAC,OAAO,uMAAgB,CAAC,IAAI;YAC/D,IAAI,IAAI,UAAU,CAAC,WAAW;gBAC1B,qFAAqF;gBACrF,qBAAqB;gBACrB,eAAe,CAAC,IAAI,GAChB;YACR,OACK;gBACD,KAAK,CAAC,IAAI,GAAG;YACjB;QACJ;IACJ;IACA,IAAI,CAAC,aAAa,SAAS,EAAE;QACzB,IAAI,gBAAgB,mBAAmB;YACnC,MAAM,SAAS,GAAG,IAAA,qNAAc,EAAC,cAAc,MAAM,SAAS,EAAE;QACpE,OACK,IAAI,MAAM,SAAS,EAAE;YACtB;;;aAGC,GACD,MAAM,SAAS,GAAG;QACtB;IACJ;IACA;;;KAGC,GACD,IAAI,oBAAoB;QACpB,MAAM,EAAE,UAAU,KAAK,EAAE,UAAU,KAAK,EAAE,UAAU,CAAC,EAAG,GAAG;QAC3D,MAAM,eAAe,GAAG,AAAC,GAAa,OAAX,SAAQ,KAAc,OAAX,SAAQ,KAAW,OAAR;IACrD;AACJ&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1213</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/render/html/utils/render.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;function renderHTML(element, { style, vars }, styleProp, projection) {</span><span class="s3">\n    </span><span class="s1">const elementStyle = element.style;</span><span class="s3">\n    </span><span class="s1">let key;</span><span class="s3">\n    </span><span class="s1">for (key in style) {</span><span class="s3">\n        </span><span class="s1">// CSSStyleDeclaration has [index: number]: string; in the types, so we use that as key type.</span><span class="s3">\n        </span><span class="s1">elementStyle[key] = style[key];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Write projection styles directly to element style</span><span class="s3">\n    </span><span class="s1">projection?.applyProjectionStyles(elementStyle, styleProp);</span><span class="s3">\n    </span><span class="s1">for (key in vars) {</span><span class="s3">\n        </span><span class="s1">// Loop over any CSS variables and assign those.</span><span class="s3">\n        </span><span class="s1">// They can only be assigned using `setProperty`.</span><span class="s3">\n        </span><span class="s1">elementStyle.setProperty(key, vars[key]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { renderHTML };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA,SAAS,WAAW,OAAO,EAAE,KAAe,EAAE,SAAS,EAAE,UAAU;QAAtC,EAAE,KAAK,EAAE,IAAI,EAAE,GAAf;IACzB,MAAM,eAAe,QAAQ,KAAK;IAClC,IAAI;IACJ,IAAK,OAAO,MAAO;QACf,6FAA6F;QAC7F,YAAY,CAAC,IAAI,GAAG,KAAK,CAAC,IAAI;IAClC;IACA,oDAAoD;IACpD,uBAAA,iCAAA,WAAY,qBAAqB,CAAC,cAAc;IAChD,IAAK,OAAO,KAAM;QACd,gDAAgD;QAChD,iDAAiD;QACjD,aAAa,WAAW,CAAC,KAAK,IAAI,CAAC,IAAI;IAC3C;AACJ&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1238</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/projection/styles/scale-correction.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { isCSSVariableName } from 'motion-dom';</span><span class="s3">\n\n</span><span class="s1">const scaleCorrectors = {};</span><span class="s3">\n</span><span class="s1">function addScaleCorrector(correctors) {</span><span class="s3">\n    </span><span class="s1">for (const key in correctors) {</span><span class="s3">\n        </span><span class="s1">scaleCorrectors[key] = correctors[key];</span><span class="s3">\n        </span><span class="s1">if (isCSSVariableName(key)) {</span><span class="s3">\n            </span><span class="s1">scaleCorrectors[key].isCSSVariable = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { addScaleCorrector, scaleCorrectors };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;AAAA;;AAEA,MAAM,kBAAkB,CAAC;AACzB,SAAS,kBAAkB,UAAU;IACjC,IAAK,MAAM,OAAO,WAAY;QAC1B,eAAe,CAAC,IAAI,GAAG,UAAU,CAAC,IAAI;QACtC,IAAI,IAAA,mNAAiB,EAAC,MAAM;YACxB,eAAe,CAAC,IAAI,CAAC,aAAa,GAAG;QACzC;IACJ;AACJ&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1260</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/motion/utils/is-forced-motion-value.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { transformProps } from 'motion-dom';</span><span class="s3">\n</span><span class="s1">import { scaleCorrectors } from '../../projection/styles/scale-correction.mjs';</span><span class="s3">\n\n</span><span class="s1">function isForcedMotionValue(key, { layout, layoutId }) {</span><span class="s3">\n    </span><span class="s1">return (transformProps.has(key) ||</span><span class="s3">\n        </span><span class="s1">key.startsWith(</span><span class="s3">\&quot;</span><span class="s1">origin</span><span class="s3">\&quot;</span><span class="s1">) ||</span><span class="s3">\n        </span><span class="s1">((layout || layoutId !== undefined) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(!!scaleCorrectors[key] || key === </span><span class="s3">\&quot;</span><span class="s1">opacity</span><span class="s3">\&quot;</span><span class="s1">)));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { isForcedMotionValue };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;AACA;;;AAEA,SAAS,oBAAoB,GAAG,EAAE,KAAoB;QAApB,EAAE,MAAM,EAAE,QAAQ,EAAE,GAApB;IAC9B,OAAQ,yMAAc,CAAC,GAAG,CAAC,QACvB,IAAI,UAAU,CAAC,aACd,CAAC,UAAU,aAAa,SAAS,KAC9B,CAAC,CAAC,CAAC,oNAAe,CAAC,IAAI,IAAI,QAAQ,SAAS;AACxD&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1277</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/render/html/utils/scrape-motion-values.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { isMotionValue } from 'motion-dom';</span><span class="s3">\n</span><span class="s1">import { isForcedMotionValue } from '../../../motion/utils/is-forced-motion-value.mjs';</span><span class="s3">\n\n</span><span class="s1">function scrapeMotionValuesFromProps(props, prevProps, visualElement) {</span><span class="s3">\n    </span><span class="s1">const { style } = props;</span><span class="s3">\n    </span><span class="s1">const newValues = {};</span><span class="s3">\n    </span><span class="s1">for (const key in style) {</span><span class="s3">\n        </span><span class="s1">if (isMotionValue(style[key]) ||</span><span class="s3">\n            </span><span class="s1">(prevProps.style &amp;&amp;</span><span class="s3">\n                </span><span class="s1">isMotionValue(prevProps.style[key])) ||</span><span class="s3">\n            </span><span class="s1">isForcedMotionValue(key, props) ||</span><span class="s3">\n            </span><span class="s1">visualElement?.getValue(key)?.liveStyle !== undefined) {</span><span class="s3">\n            </span><span class="s1">newValues[key] = style[key];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return newValues;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { scrapeMotionValuesFromProps };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;AACA;;;AAEA,SAAS,4BAA4B,KAAK,EAAE,SAAS,EAAE,aAAa;IAChE,MAAM,EAAE,KAAK,EAAE,GAAG;IAClB,MAAM,YAAY,CAAC;IACnB,IAAK,MAAM,OAAO,MAAO;YAKjB;QAJJ,IAAI,IAAA,2MAAa,EAAC,KAAK,CAAC,IAAI,KACvB,UAAU,KAAK,IACZ,IAAA,2MAAa,EAAC,UAAU,KAAK,CAAC,IAAI,KACtC,IAAA,+NAAmB,EAAC,KAAK,UACzB,CAAA,0BAAA,qCAAA,0BAAA,cAAe,QAAQ,CAAC,kBAAxB,8CAAA,wBAA8B,SAAS,MAAK,WAAW;YACvD,SAAS,CAAC,IAAI,GAAG,KAAK,CAAC,IAAI;QAC/B;IACJ;IACA,OAAO;AACX&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1301</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/render/html/HTMLVisualElement.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { transformProps, defaultTransformValue, readTransformValue, isCSSVariableName } from 'motion-dom';</span><span class="s3">\n</span><span class="s1">import { measureViewportBox } from '../../projection/utils/measure.mjs';</span><span class="s3">\n</span><span class="s1">import { DOMVisualElement } from '../dom/DOMVisualElement.mjs';</span><span class="s3">\n</span><span class="s1">import { buildHTMLStyles } from './utils/build-styles.mjs';</span><span class="s3">\n</span><span class="s1">import { renderHTML } from './utils/render.mjs';</span><span class="s3">\n</span><span class="s1">import { scrapeMotionValuesFromProps } from './utils/scrape-motion-values.mjs';</span><span class="s3">\n\n</span><span class="s1">function getComputedStyle(element) {</span><span class="s3">\n    </span><span class="s1">return window.getComputedStyle(element);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class HTMLVisualElement extends DOMVisualElement {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">super(...arguments);</span><span class="s3">\n        </span><span class="s1">this.type = </span><span class="s3">\&quot;</span><span class="s1">html</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">this.renderInstance = renderHTML;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">readValueFromInstance(instance, key) {</span><span class="s3">\n        </span><span class="s1">if (transformProps.has(key)) {</span><span class="s3">\n            </span><span class="s1">return this.projection?.isProjecting</span><span class="s3">\n                </span><span class="s1">? defaultTransformValue(key)</span><span class="s3">\n                </span><span class="s1">: readTransformValue(instance, key);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">const computedStyle = getComputedStyle(instance);</span><span class="s3">\n            </span><span class="s1">const value = (isCSSVariableName(key)</span><span class="s3">\n                </span><span class="s1">? computedStyle.getPropertyValue(key)</span><span class="s3">\n                </span><span class="s1">: computedStyle[key]) || 0;</span><span class="s3">\n            </span><span class="s1">return typeof value === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">? value.trim() : value;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">measureInstanceViewportBox(instance, { transformPagePoint }) {</span><span class="s3">\n        </span><span class="s1">return measureViewportBox(instance, transformPagePoint);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">build(renderState, latestValues, props) {</span><span class="s3">\n        </span><span class="s1">buildHTMLStyles(renderState, latestValues, props.transformTemplate);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">scrapeMotionValuesFromProps(props, prevProps, visualElement) {</span><span class="s3">\n        </span><span class="s1">return scrapeMotionValuesFromProps(props, prevProps, visualElement);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { HTMLVisualElement, getComputedStyle };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAEA,SAAS,iBAAiB,OAAO;IAC7B,OAAO,OAAO,gBAAgB,CAAC;AACnC;AACA,MAAM,0BAA0B,2MAAgB;IAM5C,sBAAsB,QAAQ,EAAE,GAAG,EAAE;QACjC,IAAI,yMAAc,CAAC,GAAG,CAAC,MAAM;gBAClB;YAAP,OAAO,EAAA,mBAAA,IAAI,CAAC,UAAU,cAAf,uCAAA,iBAAiB,YAAY,IAC9B,IAAA,+MAAqB,EAAC,OACtB,IAAA,4MAAkB,EAAC,UAAU;QACvC,OACK;YACD,MAAM,gBAAgB,iBAAiB;YACvC,MAAM,QAAQ,CAAC,IAAA,mNAAiB,EAAC,OAC3B,cAAc,gBAAgB,CAAC,OAC/B,aAAa,CAAC,IAAI,KAAK;YAC7B,OAAO,OAAO,UAAU,WAAW,MAAM,IAAI,KAAK;QACtD;IACJ;IACA,2BAA2B,QAAQ,EAAE,KAAsB,EAAE;YAAxB,EAAE,kBAAkB,EAAE,GAAtB;QACjC,OAAO,IAAA,0MAAkB,EAAC,UAAU;IACxC;IACA,MAAM,WAAW,EAAE,YAAY,EAAE,KAAK,EAAE;QACpC,IAAA,mNAAe,EAAC,aAAa,cAAc,MAAM,iBAAiB;IACtE;IACA,4BAA4B,KAAK,EAAE,SAAS,EAAE,aAAa,EAAE;QACzD,OAAO,IAAA,0OAA2B,EAAC,OAAO,WAAW;IACzD;IA3BA,aAAc;QACV,KAAK,IAAI;QACT,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,cAAc,GAAG,qMAAU;IACpC;AAwBJ&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1356</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/render/dom/utils/camel-to-dash.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Convert camelCase to dash-case properties.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const camelToDash = (str) =&gt; str.replace(/([a-z])([A-Z])/gu, </span><span class="s3">\&quot;</span><span class="s1">$1-$2</span><span class="s3">\&quot;</span><span class="s1">).toLowerCase();</span><span class="s3">\n\n</span><span class="s1">export { camelToDash };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAA;;CAEC;;;;AACD,MAAM,cAAc,CAAC,MAAQ,IAAI,OAAO,CAAC,oBAAoB,SAAS,WAAW&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1368</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/render/svg/utils/path.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { px } from 'motion-dom';</span><span class="s3">\n\n</span><span class="s1">const dashKeys = {</span><span class="s3">\n    </span><span class="s1">offset: </span><span class="s3">\&quot;</span><span class="s1">stroke-dashoffset</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">array: </span><span class="s3">\&quot;</span><span class="s1">stroke-dasharray</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const camelKeys = {</span><span class="s3">\n    </span><span class="s1">offset: </span><span class="s3">\&quot;</span><span class="s1">strokeDashoffset</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">array: </span><span class="s3">\&quot;</span><span class="s1">strokeDasharray</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Build SVG path properties. Uses the path's measured length to convert</span><span class="s3">\n </span><span class="s1">* our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset</span><span class="s3">\n </span><span class="s1">* and stroke-dasharray attributes.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This function is mutative to reduce per-frame GC.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {</span><span class="s3">\n    </span><span class="s1">// Normalise path length by setting SVG attribute pathLength to 1</span><span class="s3">\n    </span><span class="s1">attrs.pathLength = 1;</span><span class="s3">\n    </span><span class="s1">// We use dash case when setting attributes directly to the DOM node and camel case</span><span class="s3">\n    </span><span class="s1">// when defining props on a React component.</span><span class="s3">\n    </span><span class="s1">const keys = useDashCase ? dashKeys : camelKeys;</span><span class="s3">\n    </span><span class="s1">// Build the dash offset</span><span class="s3">\n    </span><span class="s1">attrs[keys.offset] = px.transform(-offset);</span><span class="s3">\n    </span><span class="s1">// Build the dash array</span><span class="s3">\n    </span><span class="s1">const pathLength = px.transform(length);</span><span class="s3">\n    </span><span class="s1">const pathSpacing = px.transform(spacing);</span><span class="s3">\n    </span><span class="s1">attrs[keys.array] = `${pathLength} ${pathSpacing}`;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { buildSVGPath };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;;AAEA,MAAM,WAAW;IACb,QAAQ;IACR,OAAO;AACX;AACA,MAAM,YAAY;IACd,QAAQ;IACR,OAAO;AACX;AACA;;;;;;CAMC,GACD,SAAS,aAAa,KAAK,EAAE,MAAM;QAAE,UAAA,iEAAU,GAAG,SAAA,iEAAS,GAAG,cAAA,iEAAc;IACxE,iEAAiE;IACjE,MAAM,UAAU,GAAG;IACnB,mFAAmF;IACnF,4CAA4C;IAC5C,MAAM,OAAO,cAAc,WAAW;IACtC,wBAAwB;IACxB,KAAK,CAAC,KAAK,MAAM,CAAC,GAAG,2LAAE,CAAC,SAAS,CAAC,CAAC;IACnC,uBAAuB;IACvB,MAAM,aAAa,2LAAE,CAAC,SAAS,CAAC;IAChC,MAAM,cAAc,2LAAE,CAAC,SAAS,CAAC;IACjC,KAAK,CAAC,KAAK,KAAK,CAAC,GAAG,AAAC,GAAgB,OAAd,YAAW,KAAe,OAAZ;AACzC&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1407</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/render/svg/utils/build-attrs.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { buildHTMLStyles } from '../../html/utils/build-styles.mjs';</span><span class="s3">\n</span><span class="s1">import { buildSVGPath } from './path.mjs';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Build SVG visual attributes, like cx and style.transform</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function buildSVGAttrs(state, { attrX, attrY, attrScale, pathLength, pathSpacing = 1, pathOffset = 0, </span><span class="s3">\n</span><span class="s1">// This is object creation, which we try to avoid per-frame.</span><span class="s3">\n</span><span class="s1">...latest }, isSVGTag, transformTemplate, styleProp) {</span><span class="s3">\n    </span><span class="s1">buildHTMLStyles(state, latest, transformTemplate);</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* For svg tags we just want to make sure viewBox is animatable and treat all the styles</span><span class="s3">\n     </span><span class="s1">* as normal HTML tags.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">if (isSVGTag) {</span><span class="s3">\n        </span><span class="s1">if (state.style.viewBox) {</span><span class="s3">\n            </span><span class="s1">state.attrs.viewBox = state.style.viewBox;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">state.attrs = state.style;</span><span class="s3">\n    </span><span class="s1">state.style = {};</span><span class="s3">\n    </span><span class="s1">const { attrs, style } = state;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* However, we apply transforms as CSS transforms.</span><span class="s3">\n     </span><span class="s1">* So if we detect a transform, transformOrigin we take it from attrs and copy it into style.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">if (attrs.transform) {</span><span class="s3">\n        </span><span class="s1">style.transform = attrs.transform;</span><span class="s3">\n        </span><span class="s1">delete attrs.transform;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (style.transform || attrs.transformOrigin) {</span><span class="s3">\n        </span><span class="s1">style.transformOrigin = attrs.transformOrigin ?? </span><span class="s3">\&quot;</span><span class="s1">50% 50%</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">delete attrs.transformOrigin;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (style.transform) {</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* SVG's element transform-origin uses its own median as a reference.</span><span class="s3">\n         </span><span class="s1">* Therefore, transformBox becomes a fill-box</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">style.transformBox = styleProp?.transformBox ?? </span><span class="s3">\&quot;</span><span class="s1">fill-box</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">delete attrs.transformBox;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Render attrX/attrY/attrScale as attributes</span><span class="s3">\n    </span><span class="s1">if (attrX !== undefined)</span><span class="s3">\n        </span><span class="s1">attrs.x = attrX;</span><span class="s3">\n    </span><span class="s1">if (attrY !== undefined)</span><span class="s3">\n        </span><span class="s1">attrs.y = attrY;</span><span class="s3">\n    </span><span class="s1">if (attrScale !== undefined)</span><span class="s3">\n        </span><span class="s1">attrs.scale = attrScale;</span><span class="s3">\n    </span><span class="s1">// Build SVG path if one has been defined</span><span class="s3">\n    </span><span class="s1">if (pathLength !== undefined) {</span><span class="s3">\n        </span><span class="s1">buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { buildSVGAttrs };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;AACA;;;AAEA;;CAEC,GACD,SAAS,cAAc,KAAK,EAAE,KAEnB,EAAE,QAAQ,EAAE,iBAAiB,EAAE,SAAS;QAFrB,EAAE,KAAK,EAAE,KAAK,EAAE,SAAS,EAAE,UAAU,EAAE,cAAc,CAAC,EAAE,aAAa,CAAC,EACpG,4DAA4D;IAC5D,GAAG,QAAQ,GAFmB;IAG1B,IAAA,mNAAe,EAAC,OAAO,QAAQ;IAC/B;;;KAGC,GACD,IAAI,UAAU;QACV,IAAI,MAAM,KAAK,CAAC,OAAO,EAAE;YACrB,MAAM,KAAK,CAAC,OAAO,GAAG,MAAM,KAAK,CAAC,OAAO;QAC7C;QACA;IACJ;IACA,MAAM,KAAK,GAAG,MAAM,KAAK;IACzB,MAAM,KAAK,GAAG,CAAC;IACf,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,GAAG;IACzB;;;KAGC,GACD,IAAI,MAAM,SAAS,EAAE;QACjB,MAAM,SAAS,GAAG,MAAM,SAAS;QACjC,OAAO,MAAM,SAAS;IAC1B;IACA,IAAI,MAAM,SAAS,IAAI,MAAM,eAAe,EAAE;YAClB;QAAxB,MAAM,eAAe,GAAG,CAAA,yBAAA,MAAM,eAAe,cAArB,oCAAA,yBAAyB;QACjD,OAAO,MAAM,eAAe;IAChC;IACA,IAAI,MAAM,SAAS,EAAE;YAKI;QAJrB;;;SAGC,GACD,MAAM,YAAY,GAAG,CAAA,0BAAA,sBAAA,gCAAA,UAAW,YAAY,cAAvB,qCAAA,0BAA2B;QAChD,OAAO,MAAM,YAAY;IAC7B;IACA,6CAA6C;IAC7C,IAAI,UAAU,WACV,MAAM,CAAC,GAAG;IACd,IAAI,UAAU,WACV,MAAM,CAAC,GAAG;IACd,IAAI,cAAc,WACd,MAAM,KAAK,GAAG;IAClB,yCAAyC;IACzC,IAAI,eAAe,WAAW;QAC1B,IAAA,oMAAY,EAAC,OAAO,YAAY,aAAa,YAAY;IAC7D;AACJ&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1467</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/render/svg/utils/camel-case-attrs.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* A set of attribute names that are always read/written as camel case.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const camelCaseAttributes = new Set([</span><span class="s3">\n    \&quot;</span><span class="s1">baseFrequency</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">diffuseConstant</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">kernelMatrix</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">kernelUnitLength</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">keySplines</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">keyTimes</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">limitingConeAngle</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">markerHeight</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">markerWidth</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">numOctaves</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">targetX</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">targetY</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">surfaceScale</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">specularConstant</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">specularExponent</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">stdDeviation</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">tableValues</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">viewBox</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">gradientTransform</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">pathLength</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">startOffset</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">textLength</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">lengthAdjust</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n</span><span class="s1">]);</span><span class="s3">\n\n</span><span class="s1">export { camelCaseAttributes };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAA;;CAEC;;;;AACD,MAAM,sBAAsB,IAAI,IAAI;IAChC;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACH&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1503</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/render/svg/utils/is-svg-tag.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;const isSVGTag = (tag) =&gt; typeof tag === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; tag.toLowerCase() === </span><span class="s3">\&quot;</span><span class="s1">svg</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">export { isSVGTag };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA,MAAM,WAAW,CAAC,MAAQ,OAAO,QAAQ,YAAY,IAAI,WAAW,OAAO&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1513</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/render/svg/utils/render.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { camelToDash } from '../../dom/utils/camel-to-dash.mjs';</span><span class="s3">\n</span><span class="s1">import { renderHTML } from '../../html/utils/render.mjs';</span><span class="s3">\n</span><span class="s1">import { camelCaseAttributes } from './camel-case-attrs.mjs';</span><span class="s3">\n\n</span><span class="s1">function renderSVG(element, renderState, _styleProp, projection) {</span><span class="s3">\n    </span><span class="s1">renderHTML(element, renderState, undefined, projection);</span><span class="s3">\n    </span><span class="s1">for (const key in renderState.attrs) {</span><span class="s3">\n        </span><span class="s1">element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { renderSVG };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;AACA;AACA;;;;AAEA,SAAS,UAAU,OAAO,EAAE,WAAW,EAAE,UAAU,EAAE,UAAU;IAC3D,IAAA,qMAAU,EAAC,SAAS,aAAa,WAAW;IAC5C,IAAK,MAAM,OAAO,YAAY,KAAK,CAAE;QACjC,QAAQ,YAAY,CAAC,CAAC,6NAAmB,CAAC,GAAG,CAAC,OAAO,IAAA,kNAAW,EAAC,OAAO,KAAK,YAAY,KAAK,CAAC,IAAI;IACvG;AACJ&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1534</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/render/svg/utils/scrape-motion-values.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { isMotionValue, transformPropOrder } from 'motion-dom';</span><span class="s3">\n</span><span class="s1">import { scrapeMotionValuesFromProps as scrapeMotionValuesFromProps$1 } from '../../html/utils/scrape-motion-values.mjs';</span><span class="s3">\n\n</span><span class="s1">function scrapeMotionValuesFromProps(props, prevProps, visualElement) {</span><span class="s3">\n    </span><span class="s1">const newValues = scrapeMotionValuesFromProps$1(props, prevProps, visualElement);</span><span class="s3">\n    </span><span class="s1">for (const key in props) {</span><span class="s3">\n        </span><span class="s1">if (isMotionValue(props[key]) ||</span><span class="s3">\n            </span><span class="s1">isMotionValue(prevProps[key])) {</span><span class="s3">\n            </span><span class="s1">const targetKey = transformPropOrder.indexOf(key) !== -1</span><span class="s3">\n                </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">attr</span><span class="s3">\&quot; </span><span class="s1">+ key.charAt(0).toUpperCase() + key.substring(1)</span><span class="s3">\n                </span><span class="s1">: key;</span><span class="s3">\n            </span><span class="s1">newValues[targetKey] = props[key];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return newValues;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { scrapeMotionValuesFromProps };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;AAAA;AACA;;;AAEA,SAAS,4BAA4B,KAAK,EAAE,SAAS,EAAE,aAAa;IAChE,MAAM,YAAY,IAAA,0OAA6B,EAAC,OAAO,WAAW;IAClE,IAAK,MAAM,OAAO,MAAO;QACrB,IAAI,IAAA,2MAAa,EAAC,KAAK,CAAC,IAAI,KACxB,IAAA,2MAAa,EAAC,SAAS,CAAC,IAAI,GAAG;YAC/B,MAAM,YAAY,6MAAkB,CAAC,OAAO,CAAC,SAAS,CAAC,IACjD,SAAS,IAAI,MAAM,CAAC,GAAG,WAAW,KAAK,IAAI,SAAS,CAAC,KACrD;YACN,SAAS,CAAC,UAAU,GAAG,KAAK,CAAC,IAAI;QACrC;IACJ;IACA,OAAO;AACX&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1558</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/render/svg/SVGVisualElement.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { transformProps, getDefaultValueType } from 'motion-dom';</span><span class="s3">\n</span><span class="s1">import { createBox } from '../../projection/geometry/models.mjs';</span><span class="s3">\n</span><span class="s1">import { DOMVisualElement } from '../dom/DOMVisualElement.mjs';</span><span class="s3">\n</span><span class="s1">import { camelToDash } from '../dom/utils/camel-to-dash.mjs';</span><span class="s3">\n</span><span class="s1">import { buildSVGAttrs } from './utils/build-attrs.mjs';</span><span class="s3">\n</span><span class="s1">import { camelCaseAttributes } from './utils/camel-case-attrs.mjs';</span><span class="s3">\n</span><span class="s1">import { isSVGTag } from './utils/is-svg-tag.mjs';</span><span class="s3">\n</span><span class="s1">import { renderSVG } from './utils/render.mjs';</span><span class="s3">\n</span><span class="s1">import { scrapeMotionValuesFromProps } from './utils/scrape-motion-values.mjs';</span><span class="s3">\n\n</span><span class="s1">class SVGVisualElement extends DOMVisualElement {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">super(...arguments);</span><span class="s3">\n        </span><span class="s1">this.type = </span><span class="s3">\&quot;</span><span class="s1">svg</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">this.isSVGTag = false;</span><span class="s3">\n        </span><span class="s1">this.measureInstanceViewportBox = createBox;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getBaseTargetFromProps(props, key) {</span><span class="s3">\n        </span><span class="s1">return props[key];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">readValueFromInstance(instance, key) {</span><span class="s3">\n        </span><span class="s1">if (transformProps.has(key)) {</span><span class="s3">\n            </span><span class="s1">const defaultType = getDefaultValueType(key);</span><span class="s3">\n            </span><span class="s1">return defaultType ? defaultType.default || 0 : 0;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;</span><span class="s3">\n        </span><span class="s1">return instance.getAttribute(key);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">scrapeMotionValuesFromProps(props, prevProps, visualElement) {</span><span class="s3">\n        </span><span class="s1">return scrapeMotionValuesFromProps(props, prevProps, visualElement);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">build(renderState, latestValues, props) {</span><span class="s3">\n        </span><span class="s1">buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate, props.style);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">renderInstance(instance, renderState, styleProp, projection) {</span><span class="s3">\n        </span><span class="s1">renderSVG(instance, renderState, styleProp, projection);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">mount(instance) {</span><span class="s3">\n        </span><span class="s1">this.isSVGTag = isSVGTag(instance.tagName);</span><span class="s3">\n        </span><span class="s1">super.mount(instance);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { SVGVisualElement };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAEA,MAAM,yBAAyB,2MAAgB;IAO3C,uBAAuB,KAAK,EAAE,GAAG,EAAE;QAC/B,OAAO,KAAK,CAAC,IAAI;IACrB;IACA,sBAAsB,QAAQ,EAAE,GAAG,EAAE;QACjC,IAAI,yMAAc,CAAC,GAAG,CAAC,MAAM;YACzB,MAAM,cAAc,IAAA,4MAAmB,EAAC;YACxC,OAAO,cAAc,YAAY,OAAO,IAAI,IAAI;QACpD;QACA,MAAM,CAAC,6NAAmB,CAAC,GAAG,CAAC,OAAO,IAAA,kNAAW,EAAC,OAAO;QACzD,OAAO,SAAS,YAAY,CAAC;IACjC;IACA,4BAA4B,KAAK,EAAE,SAAS,EAAE,aAAa,EAAE;QACzD,OAAO,IAAA,yOAA2B,EAAC,OAAO,WAAW;IACzD;IACA,MAAM,WAAW,EAAE,YAAY,EAAE,KAAK,EAAE;QACpC,IAAA,+MAAa,EAAC,aAAa,cAAc,IAAI,CAAC,QAAQ,EAAE,MAAM,iBAAiB,EAAE,MAAM,KAAK;IAChG;IACA,eAAe,QAAQ,EAAE,WAAW,EAAE,SAAS,EAAE,UAAU,EAAE;QACzD,IAAA,mMAAS,EAAC,UAAU,aAAa,WAAW;IAChD;IACA,MAAM,QAAQ,EAAE;QACZ,IAAI,CAAC,QAAQ,GAAG,IAAA,4MAAQ,EAAC,SAAS,OAAO;QACzC,KAAK,CAAC,MAAM;IAChB;IA7BA,aAAc;QACV,KAAK,IAAI;QACT,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,0BAA0B,GAAG,mMAAS;IAC/C;AAyBJ&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1618</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/render/svg/lowercase-elements.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* We keep these listed separately as we use the lowercase tag names as part</span><span class="s3">\n </span><span class="s1">* of the runtime bundle to detect SVG components</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const lowercaseSVGElements = [</span><span class="s3">\n    \&quot;</span><span class="s1">animate</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">circle</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">defs</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">desc</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">ellipse</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">image</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">line</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">filter</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">marker</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">mask</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">metadata</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">path</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">pattern</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">polygon</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">polyline</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">rect</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">stop</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">switch</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">symbol</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">svg</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">text</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">tspan</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">use</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">view</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n</span><span class="s1">];</span><span class="s3">\n\n</span><span class="s1">export { lowercaseSVGElements };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAA;;;CAGC;;;;AACD,MAAM,uBAAuB;IACzB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACH&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1657</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/render/dom/utils/is-svg-component.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { lowercaseSVGElements } from '../../svg/lowercase-elements.mjs';</span><span class="s3">\n\n</span><span class="s1">function isSVGComponent(Component) {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* If it's not a string, it's a custom React component. Currently we only support</span><span class="s3">\n     </span><span class="s1">* HTML custom React components.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">typeof Component !== </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* If it contains a dash, the element is a custom HTML webcomponent.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">Component.includes(</span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* If it's in our list of lowercase SVG tags, it's an SVG component</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">lowercaseSVGElements.indexOf(Component) &gt; -1 ||</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* If it contains a capital letter, it's an SVG component</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">/[A-Z]/u.test(Component)) {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { isSVGComponent };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;;AAEA,SAAS,eAAe,SAAS;IAC7B,IACA;;;KAGC,GACD,OAAO,cAAc,YACjB;;SAEC,GACD,UAAU,QAAQ,CAAC,MAAM;QACzB,OAAO;IACX,OACK,IACL;;KAEC,GACD,oNAAoB,CAAC,OAAO,CAAC,aAAa,CAAC,KACvC;;SAEC,GACD,SAAS,IAAI,CAAC,YAAY;QAC1B,OAAO;IACX;IACA,OAAO;AACX&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1685</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/render/dom/create-visual-element.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { Fragment } from 'react';</span><span class="s3">\n</span><span class="s1">import { HTMLVisualElement } from '../html/HTMLVisualElement.mjs';</span><span class="s3">\n</span><span class="s1">import { SVGVisualElement } from '../svg/SVGVisualElement.mjs';</span><span class="s3">\n</span><span class="s1">import { isSVGComponent } from './utils/is-svg-component.mjs';</span><span class="s3">\n\n</span><span class="s1">const createDomVisualElement = (Component, options) =&gt; {</span><span class="s3">\n    </span><span class="s1">return isSVGComponent(Component)</span><span class="s3">\n        </span><span class="s1">? new SVGVisualElement(options)</span><span class="s3">\n        </span><span class="s1">: new HTMLVisualElement(options, {</span><span class="s3">\n            </span><span class="s1">allowProjection: Component !== Fragment,</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export { createDomVisualElement };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;AACA;AACA;AACA;;;;;AAEA,MAAM,yBAAyB,CAAC,WAAW;IACvC,OAAO,IAAA,wNAAc,EAAC,aAChB,IAAI,2MAAgB,CAAC,WACrB,IAAI,8MAAiB,CAAC,SAAS;QAC7B,iBAAiB,cAAc,yKAAQ;IAC3C;AACR&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1707</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/context/LayoutGroupContext.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use client</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { createContext } from 'react';</span><span class="s3">\n\n</span><span class="s1">const LayoutGroupContext = createContext({});</span><span class="s3">\n\n</span><span class="s1">export { LayoutGroupContext };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AACA;AADA;;AAGA,MAAM,qBAAqB,IAAA,8KAAa,EAAC,CAAC&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1720</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/context/LazyContext.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use client</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { createContext } from 'react';</span><span class="s3">\n\n</span><span class="s1">const LazyContext = createContext({ strict: false });</span><span class="s3">\n\n</span><span class="s1">export { LazyContext };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AACA;AADA;;AAGA,MAAM,cAAc,IAAA,8KAAa,EAAC;IAAE,QAAQ;AAAM&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1735</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/context/MotionConfigContext.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use client</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { createContext } from 'react';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @public</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const MotionConfigContext = createContext({</span><span class="s3">\n    </span><span class="s1">transformPagePoint: (p) =&gt; p,</span><span class="s3">\n    </span><span class="s1">isStatic: false,</span><span class="s3">\n    </span><span class="s1">reducedMotion: </span><span class="s3">\&quot;</span><span class="s1">never</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">export { MotionConfigContext };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AACA;AADA;;AAGA;;CAEC,GACD,MAAM,sBAAsB,IAAA,8KAAa,EAAC;IACtC,oBAAoB,CAAC,IAAM;IAC3B,UAAU;IACV,eAAe;AACnB&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1754</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/context/MotionContext/index.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use client</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { createContext } from 'react';</span><span class="s3">\n\n</span><span class="s1">const MotionContext = /* @__PURE__ */ createContext({});</span><span class="s3">\n\n</span><span class="s1">export { MotionContext };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AACA;AADA;;AAGA,MAAM,gBAAgB,aAAa,GAAG,IAAA,8KAAa,EAAC,CAAC&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1767</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/context/MotionContext/utils.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { isControllingVariants } from '../../render/utils/is-controlling-variants.mjs';</span><span class="s3">\n</span><span class="s1">import { isVariantLabel } from '../../render/utils/is-variant-label.mjs';</span><span class="s3">\n\n</span><span class="s1">function getCurrentTreeVariants(props, context) {</span><span class="s3">\n    </span><span class="s1">if (isControllingVariants(props)) {</span><span class="s3">\n        </span><span class="s1">const { initial, animate } = props;</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">initial: initial === false || isVariantLabel(initial)</span><span class="s3">\n                </span><span class="s1">? initial</span><span class="s3">\n                </span><span class="s1">: undefined,</span><span class="s3">\n            </span><span class="s1">animate: isVariantLabel(animate) ? animate : undefined,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return props.inherit !== false ? context : {};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { getCurrentTreeVariants };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;AACA;;;AAEA,SAAS,uBAAuB,KAAK,EAAE,OAAO;IAC1C,IAAI,IAAA,+NAAqB,EAAC,QAAQ;QAC9B,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,GAAG;QAC7B,OAAO;YACH,SAAS,YAAY,SAAS,IAAA,iNAAc,EAAC,WACvC,UACA;YACN,SAAS,IAAA,iNAAc,EAAC,WAAW,UAAU;QACjD;IACJ;IACA,OAAO,MAAM,OAAO,KAAK,QAAQ,UAAU,CAAC;AAChD&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1790</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/context/MotionContext/create.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use client</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { useContext, useMemo } from 'react';</span><span class="s3">\n</span><span class="s1">import { MotionContext } from './index.mjs';</span><span class="s3">\n</span><span class="s1">import { getCurrentTreeVariants } from './utils.mjs';</span><span class="s3">\n\n</span><span class="s1">function useCreateMotionContext(props) {</span><span class="s3">\n    </span><span class="s1">const { initial, animate } = getCurrentTreeVariants(props, useContext(MotionContext));</span><span class="s3">\n    </span><span class="s1">return useMemo(() =&gt; ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function variantLabelsAsDependency(prop) {</span><span class="s3">\n    </span><span class="s1">return Array.isArray(prop) ? prop.join(</span><span class="s3">\&quot; \&quot;</span><span class="s1">) : prop;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { useCreateMotionContext };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AACA;AACA;AACA;AAHA;;;;AAKA,SAAS,uBAAuB,KAAK;IACjC,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,GAAG,IAAA,iNAAsB,EAAC,OAAO,IAAA,2KAAU,EAAC,wMAAa;IACnF,OAAO,IAAA,wKAAO;0CAAC,IAAM,CAAC;gBAAE;gBAAS;YAAQ,CAAC;yCAAG;QAAC,0BAA0B;QAAU,0BAA0B;KAAS;AACzH;AACA,SAAS,0BAA0B,IAAI;IACnC,OAAO,MAAM,OAAO,CAAC,QAAQ,KAAK,IAAI,CAAC,OAAO;AAClD&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1821</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/render/html/utils/create-render-state.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;const createHtmlRenderState = () =&gt; ({</span><span class="s3">\n    </span><span class="s1">style: {},</span><span class="s3">\n    </span><span class="s1">transform: {},</span><span class="s3">\n    </span><span class="s1">transformOrigin: {},</span><span class="s3">\n    </span><span class="s1">vars: {},</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">export { createHtmlRenderState };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA,MAAM,wBAAwB,IAAM,CAAC;QACjC,OAAO,CAAC;QACR,WAAW,CAAC;QACZ,iBAAiB,CAAC;QAClB,MAAM,CAAC;IACX,CAAC&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1836</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/render/html/use-props.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use client</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { isMotionValue } from 'motion-dom';</span><span class="s3">\n</span><span class="s1">import { useMemo } from 'react';</span><span class="s3">\n</span><span class="s1">import { isForcedMotionValue } from '../../motion/utils/is-forced-motion-value.mjs';</span><span class="s3">\n</span><span class="s1">import { buildHTMLStyles } from './utils/build-styles.mjs';</span><span class="s3">\n</span><span class="s1">import { createHtmlRenderState } from './utils/create-render-state.mjs';</span><span class="s3">\n\n</span><span class="s1">function copyRawValuesOnly(target, source, props) {</span><span class="s3">\n    </span><span class="s1">for (const key in source) {</span><span class="s3">\n        </span><span class="s1">if (!isMotionValue(source[key]) &amp;&amp; !isForcedMotionValue(key, props)) {</span><span class="s3">\n            </span><span class="s1">target[key] = source[key];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function useInitialMotionValues({ transformTemplate }, visualState) {</span><span class="s3">\n    </span><span class="s1">return useMemo(() =&gt; {</span><span class="s3">\n        </span><span class="s1">const state = createHtmlRenderState();</span><span class="s3">\n        </span><span class="s1">buildHTMLStyles(state, visualState, transformTemplate);</span><span class="s3">\n        </span><span class="s1">return Object.assign({}, state.vars, state.style);</span><span class="s3">\n    </span><span class="s1">}, [visualState]);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function useStyle(props, visualState) {</span><span class="s3">\n    </span><span class="s1">const styleProp = props.style || {};</span><span class="s3">\n    </span><span class="s1">const style = {};</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Copy non-Motion Values straight into style</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">copyRawValuesOnly(style, styleProp, props);</span><span class="s3">\n    </span><span class="s1">Object.assign(style, useInitialMotionValues(props, visualState));</span><span class="s3">\n    </span><span class="s1">return style;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function useHTMLProps(props, visualState) {</span><span class="s3">\n    </span><span class="s1">// The `any` isn't ideal but it is the type of createElement props argument</span><span class="s3">\n    </span><span class="s1">const htmlProps = {};</span><span class="s3">\n    </span><span class="s1">const style = useStyle(props, visualState);</span><span class="s3">\n    </span><span class="s1">if (props.drag &amp;&amp; props.dragListener !== false) {</span><span class="s3">\n        </span><span class="s1">// Disable the ghost element when a user drags</span><span class="s3">\n        </span><span class="s1">htmlProps.draggable = false;</span><span class="s3">\n        </span><span class="s1">// Disable text selection</span><span class="s3">\n        </span><span class="s1">style.userSelect =</span><span class="s3">\n            </span><span class="s1">style.WebkitUserSelect =</span><span class="s3">\n                </span><span class="s1">style.WebkitTouchCallout =</span><span class="s3">\n                    \&quot;</span><span class="s1">none</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">// Disable scrolling on the draggable direction</span><span class="s3">\n        </span><span class="s1">style.touchAction =</span><span class="s3">\n            </span><span class="s1">props.drag === true</span><span class="s3">\n                </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;\n                </span><span class="s1">: `pan-${props.drag === </span><span class="s3">\&quot;</span><span class="s1">x</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">y</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">x</span><span class="s3">\&quot;</span><span class="s1">}`;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (props.tabIndex === undefined &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(props.onTap || props.onTapStart || props.whileTap)) {</span><span class="s3">\n        </span><span class="s1">htmlProps.tabIndex = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">htmlProps.style = style;</span><span class="s3">\n    </span><span class="s1">return htmlProps;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { copyRawValuesOnly, useHTMLProps };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;AACA;AACA;AACA;AACA;AACA;AALA;;;;;;AAOA,SAAS,kBAAkB,MAAM,EAAE,MAAM,EAAE,KAAK;IAC5C,IAAK,MAAM,OAAO,OAAQ;QACtB,IAAI,CAAC,IAAA,2MAAa,EAAC,MAAM,CAAC,IAAI,KAAK,CAAC,IAAA,+NAAmB,EAAC,KAAK,QAAQ;YACjE,MAAM,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI;QAC7B;IACJ;AACJ;AACA,SAAS,uBAAuB,KAAqB,EAAE,WAAW;QAAlC,EAAE,iBAAiB,EAAE,GAArB;IAC5B,OAAO,IAAA,wKAAO;0CAAC;YACX,MAAM,QAAQ,IAAA,mOAAqB;YACnC,IAAA,mNAAe,EAAC,OAAO,aAAa;YACpC,OAAO,OAAO,MAAM,CAAC,CAAC,GAAG,MAAM,IAAI,EAAE,MAAM,KAAK;QACpD;yCAAG;QAAC;KAAY;AACpB;AACA,SAAS,SAAS,KAAK,EAAE,WAAW;IAChC,MAAM,YAAY,MAAM,KAAK,IAAI,CAAC;IAClC,MAAM,QAAQ,CAAC;IACf;;KAEC,GACD,kBAAkB,OAAO,WAAW;IACpC,OAAO,MAAM,CAAC,OAAO,uBAAuB,OAAO;IACnD,OAAO;AACX;AACA,SAAS,aAAa,KAAK,EAAE,WAAW;IACpC,2EAA2E;IAC3E,MAAM,YAAY,CAAC;IACnB,MAAM,QAAQ,SAAS,OAAO;IAC9B,IAAI,MAAM,IAAI,IAAI,MAAM,YAAY,KAAK,OAAO;QAC5C,8CAA8C;QAC9C,UAAU,SAAS,GAAG;QACtB,yBAAyB;QACzB,MAAM,UAAU,GACZ,MAAM,gBAAgB,GAClB,MAAM,kBAAkB,GACpB;QACZ,+CAA+C;QAC/C,MAAM,WAAW,GACb,MAAM,IAAI,KAAK,OACT,SACA,AAAC,OAAqC,OAA/B,MAAM,IAAI,KAAK,MAAM,MAAM;IAChD;IACA,IAAI,MAAM,QAAQ,KAAK,aACnB,CAAC,MAAM,KAAK,IAAI,MAAM,UAAU,IAAI,MAAM,QAAQ,GAAG;QACrD,UAAU,QAAQ,GAAG;IACzB;IACA,UAAU,KAAK,GAAG;IAClB,OAAO;AACX&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1904</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/render/svg/utils/create-render-state.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { createHtmlRenderState } from '../../html/utils/create-render-state.mjs';</span><span class="s3">\n\n</span><span class="s1">const createSvgRenderState = () =&gt; ({</span><span class="s3">\n    </span><span class="s1">...createHtmlRenderState(),</span><span class="s3">\n    </span><span class="s1">attrs: {},</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">export { createSvgRenderState };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;;AAEA,MAAM,uBAAuB,IAAM,CAAC;QAChC,GAAG,IAAA,mOAAqB,GAAE;QAC1B,OAAO,CAAC;IACZ,CAAC&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1919</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/render/svg/use-props.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use client</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { useMemo } from 'react';</span><span class="s3">\n</span><span class="s1">import { copyRawValuesOnly } from '../html/use-props.mjs';</span><span class="s3">\n</span><span class="s1">import { buildSVGAttrs } from './utils/build-attrs.mjs';</span><span class="s3">\n</span><span class="s1">import { createSvgRenderState } from './utils/create-render-state.mjs';</span><span class="s3">\n</span><span class="s1">import { isSVGTag } from './utils/is-svg-tag.mjs';</span><span class="s3">\n\n</span><span class="s1">function useSVGProps(props, visualState, _isStatic, Component) {</span><span class="s3">\n    </span><span class="s1">const visualProps = useMemo(() =&gt; {</span><span class="s3">\n        </span><span class="s1">const state = createSvgRenderState();</span><span class="s3">\n        </span><span class="s1">buildSVGAttrs(state, visualState, isSVGTag(Component), props.transformTemplate, props.style);</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">...state.attrs,</span><span class="s3">\n            </span><span class="s1">style: { ...state.style },</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}, [visualState]);</span><span class="s3">\n    </span><span class="s1">if (props.style) {</span><span class="s3">\n        </span><span class="s1">const rawStyles = {};</span><span class="s3">\n        </span><span class="s1">copyRawValuesOnly(rawStyles, props.style, props);</span><span class="s3">\n        </span><span class="s1">visualProps.style = { ...rawStyles, ...visualProps.style };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return visualProps;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { useSVGProps };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AACA;AACA;AACA;AACA;AACA;AALA;;;;;;AAOA,SAAS,YAAY,KAAK,EAAE,WAAW,EAAE,SAAS,EAAE,SAAS;IACzD,MAAM,cAAc,IAAA,wKAAO;4CAAC;YACxB,MAAM,QAAQ,IAAA,iOAAoB;YAClC,IAAA,+MAAa,EAAC,OAAO,aAAa,IAAA,4MAAQ,EAAC,YAAY,MAAM,iBAAiB,EAAE,MAAM,KAAK;YAC3F,OAAO;gBACH,GAAG,MAAM,KAAK;gBACd,OAAO;oBAAE,GAAG,MAAM,KAAK;gBAAC;YAC5B;QACJ;2CAAG;QAAC;KAAY;IAChB,IAAI,MAAM,KAAK,EAAE;QACb,MAAM,YAAY,CAAC;QACnB,IAAA,yMAAiB,EAAC,WAAW,MAAM,KAAK,EAAE;QAC1C,YAAY,KAAK,GAAG;YAAE,GAAG,SAAS;YAAE,GAAG,YAAY,KAAK;QAAC;IAC7D;IACA,OAAO;AACX&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">1964</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/motion/utils/valid-prop.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* A list of all valid MotionProps.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @privateRemarks</span><span class="s3">\n </span><span class="s1">* This doesn't throw if a `MotionProp` name is missing - it should.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const validMotionProps = new Set([</span><span class="s3">\n    \&quot;</span><span class="s1">animate</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">exit</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">variants</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">initial</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">style</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">values</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">variants</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">transition</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">transformTemplate</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">custom</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">inherit</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">onBeforeLayoutMeasure</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">onAnimationStart</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">onAnimationComplete</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">onUpdate</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">onDragStart</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">onDrag</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">onDragEnd</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">onMeasureDragConstraints</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">onDirectionLock</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">onDragTransitionEnd</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">_dragX</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">_dragY</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">onHoverStart</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">onHoverEnd</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">onViewportEnter</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">onViewportLeave</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">globalTapTarget</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">ignoreStrict</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">viewport</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n</span><span class="s1">]);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Check whether a prop name is a valid `MotionProp` key.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param key - Name of the property to check</span><span class="s3">\n </span><span class="s1">* @returns `true` is key is a valid `MotionProp`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @public</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isValidMotionProp(key) {</span><span class="s3">\n    </span><span class="s1">return (key.startsWith(</span><span class="s3">\&quot;</span><span class="s1">while</span><span class="s3">\&quot;</span><span class="s1">) ||</span><span class="s3">\n        </span><span class="s1">(key.startsWith(</span><span class="s3">\&quot;</span><span class="s1">drag</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp; key !== </span><span class="s3">\&quot;</span><span class="s1">draggable</span><span class="s3">\&quot;</span><span class="s1">) ||</span><span class="s3">\n        </span><span class="s1">key.startsWith(</span><span class="s3">\&quot;</span><span class="s1">layout</span><span class="s3">\&quot;</span><span class="s1">) ||</span><span class="s3">\n        </span><span class="s1">key.startsWith(</span><span class="s3">\&quot;</span><span class="s1">onTap</span><span class="s3">\&quot;</span><span class="s1">) ||</span><span class="s3">\n        </span><span class="s1">key.startsWith(</span><span class="s3">\&quot;</span><span class="s1">onPan</span><span class="s3">\&quot;</span><span class="s1">) ||</span><span class="s3">\n        </span><span class="s1">key.startsWith(</span><span class="s3">\&quot;</span><span class="s1">onLayout</span><span class="s3">\&quot;</span><span class="s1">) ||</span><span class="s3">\n        </span><span class="s1">validMotionProps.has(key));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { isValidMotionProp };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAA;;;;;CAKC;;;;AACD,MAAM,mBAAmB,IAAI,IAAI;IAC7B;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACH;AACD;;;;;;;CAOC,GACD,SAAS,kBAAkB,GAAG;IAC1B,OAAQ,IAAI,UAAU,CAAC,YAClB,IAAI,UAAU,CAAC,WAAW,QAAQ,eACnC,IAAI,UAAU,CAAC,aACf,IAAI,UAAU,CAAC,YACf,IAAI,UAAU,CAAC,YACf,IAAI,UAAU,CAAC,eACf,iBAAiB,GAAG,CAAC;AAC7B&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">2020</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/render/dom/utils/filter-props.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { isValidMotionProp } from '../../../motion/utils/valid-prop.mjs';</span><span class="s3">\n\n</span><span class="s1">let shouldForward = (key) =&gt; !isValidMotionProp(key);</span><span class="s3">\n</span><span class="s1">function loadExternalIsValidProp(isValidProp) {</span><span class="s3">\n    </span><span class="s1">if (typeof isValidProp !== </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">// Explicitly filter our events</span><span class="s3">\n    </span><span class="s1">shouldForward = (key) =&gt; key.startsWith(</span><span class="s3">\&quot;</span><span class="s1">on</span><span class="s3">\&quot;</span><span class="s1">) ? !isValidMotionProp(key) : isValidProp(key);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Emotion and Styled Components both allow users to pass through arbitrary props to their components</span><span class="s3">\n </span><span class="s1">* to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which</span><span class="s3">\n </span><span class="s1">* of these should be passed to the underlying DOM node.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props</span><span class="s3">\n </span><span class="s1">* as it's seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props</span><span class="s3">\n </span><span class="s1">* passed through the `custom` prop so it doesn't *need* the payload or computational overhead of</span><span class="s3">\n </span><span class="s1">* `@emotion/is-prop-valid`, however to fix this problem we need to use it.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* By making it an optionalDependency we can offer this functionality only in the situations where it's</span><span class="s3">\n </span><span class="s1">* actually required.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* We attempt to import this package but require won't be defined in esm environments, in that case</span><span class="s3">\n     </span><span class="s1">* isPropValid will have to be provided via `MotionContext`. In a 6.0.0 this should probably be removed</span><span class="s3">\n     </span><span class="s1">* in favour of explicit injection.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">loadExternalIsValidProp(require(</span><span class="s3">\&quot;</span><span class="s1">@emotion/is-prop-valid</span><span class="s3">\&quot;</span><span class="s1">).default);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">catch {</span><span class="s3">\n    </span><span class="s1">// We don't need to actually do anything here - the fallback is the existing `isPropValid`.</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function filterProps(props, isDom, forwardMotionProps) {</span><span class="s3">\n    </span><span class="s1">const filteredProps = {};</span><span class="s3">\n    </span><span class="s1">for (const key in props) {</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* values is considered a valid prop by Emotion, so if it's present</span><span class="s3">\n         </span><span class="s1">* this will be rendered out to the DOM unless explicitly filtered.</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* We check the type as it could be used with the `feColorMatrix`</span><span class="s3">\n         </span><span class="s1">* element, which we support.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">if (key === </span><span class="s3">\&quot;</span><span class="s1">values</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; typeof props.values === </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">if (shouldForward(key) ||</span><span class="s3">\n            </span><span class="s1">(forwardMotionProps === true &amp;&amp; isValidMotionProp(key)) ||</span><span class="s3">\n            </span><span class="s1">(!isDom &amp;&amp; !isValidMotionProp(key)) ||</span><span class="s3">\n            </span><span class="s1">// If trying to use native HTML drag events, forward drag listeners</span><span class="s3">\n            </span><span class="s1">(props[</span><span class="s3">\&quot;</span><span class="s1">draggable</span><span class="s3">\&quot;</span><span class="s1">] &amp;&amp;</span><span class="s3">\n                </span><span class="s1">key.startsWith(</span><span class="s3">\&quot;</span><span class="s1">onDrag</span><span class="s3">\&quot;</span><span class="s1">))) {</span><span class="s3">\n            </span><span class="s1">filteredProps[key] =</span><span class="s3">\n                </span><span class="s1">props[key];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return filteredProps;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { filterProps, loadExternalIsValidProp };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;AAAA;;AAEA,IAAI,gBAAgB,CAAC,MAAQ,CAAC,IAAA,2MAAiB,EAAC;AAChD,SAAS,wBAAwB,WAAW;IACxC,IAAI,OAAO,gBAAgB,YACvB;IACJ,+BAA+B;IAC/B,gBAAgB,CAAC,MAAQ,IAAI,UAAU,CAAC,QAAQ,CAAC,IAAA,2MAAiB,EAAC,OAAO,YAAY;AAC1F;AACA;;;;;;;;;;;;CAYC,GACD,IAAI;IACA;;;;KAIC,GACD,wBAAwB;;;;SAAkC,OAAO;AACrE,EACA,UAAM;AACF,2FAA2F;AAC/F;AACA,SAAS,YAAY,KAAK,EAAE,KAAK,EAAE,kBAAkB;IACjD,MAAM,gBAAgB,CAAC;IACvB,IAAK,MAAM,OAAO,MAAO;QACrB;;;;;;SAMC,GACD,IAAI,QAAQ,YAAY,OAAO,MAAM,MAAM,KAAK,UAC5C;QACJ,IAAI,cAAc,QACb,uBAAuB,QAAQ,IAAA,2MAAiB,EAAC,QACjD,CAAC,SAAS,CAAC,IAAA,2MAAiB,EAAC,QAE7B,KAAK,CAAC,YAAY,IACf,IAAI,UAAU,CAAC,WAAY;YAC/B,aAAa,CAAC,IAAI,GACd,KAAK,CAAC,IAAI;QAClB;IACJ;IACA,OAAO;AACX&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">2080</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/render/dom/use-render.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use client</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { isMotionValue } from 'motion-dom';</span><span class="s3">\n</span><span class="s1">import { Fragment, useMemo, createElement } from 'react';</span><span class="s3">\n</span><span class="s1">import { useHTMLProps } from '../html/use-props.mjs';</span><span class="s3">\n</span><span class="s1">import { useSVGProps } from '../svg/use-props.mjs';</span><span class="s3">\n</span><span class="s1">import { filterProps } from './utils/filter-props.mjs';</span><span class="s3">\n</span><span class="s1">import { isSVGComponent } from './utils/is-svg-component.mjs';</span><span class="s3">\n\n</span><span class="s1">function useRender(Component, props, ref, { latestValues, }, isStatic, forwardMotionProps = false) {</span><span class="s3">\n    </span><span class="s1">const useVisualProps = isSVGComponent(Component)</span><span class="s3">\n        </span><span class="s1">? useSVGProps</span><span class="s3">\n        </span><span class="s1">: useHTMLProps;</span><span class="s3">\n    </span><span class="s1">const visualProps = useVisualProps(props, latestValues, isStatic, Component);</span><span class="s3">\n    </span><span class="s1">const filteredProps = filterProps(props, typeof Component === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">, forwardMotionProps);</span><span class="s3">\n    </span><span class="s1">const elementProps = Component !== Fragment ? { ...filteredProps, ...visualProps, ref } : {};</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* If component has been handed a motion value as its child,</span><span class="s3">\n     </span><span class="s1">* memoise its initial value and render that. Subsequent updates</span><span class="s3">\n     </span><span class="s1">* will be handled by the onChange handler</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">const { children } = props;</span><span class="s3">\n    </span><span class="s1">const renderedChildren = useMemo(() =&gt; (isMotionValue(children) ? children.get() : children), [children]);</span><span class="s3">\n    </span><span class="s1">return createElement(Component, {</span><span class="s3">\n        </span><span class="s1">...elementProps,</span><span class="s3">\n        </span><span class="s1">children: renderedChildren,</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { useRender };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AANA;;;;;;;AAQA,SAAS,UAAU,SAAS,EAAE,KAAK,EAAE,GAAG,EAAE,KAAiB,EAAE,QAAQ;QAA3B,EAAE,YAAY,EAAG,GAAjB,OAA6B,qBAAA,iEAAqB;IACxF,MAAM,iBAAiB,IAAA,wNAAc,EAAC,aAChC,kMAAW,GACX,oMAAY;IAClB,MAAM,cAAc,eAAe,OAAO,cAAc,UAAU;IAClE,MAAM,gBAAgB,IAAA,8MAAW,EAAC,OAAO,OAAO,cAAc,UAAU;IACxE,MAAM,eAAe,cAAc,yKAAQ,GAAG;QAAE,GAAG,aAAa;QAAE,GAAG,WAAW;QAAE;IAAI,IAAI,CAAC;IAC3F;;;;KAIC,GACD,MAAM,EAAE,QAAQ,EAAE,GAAG;IACrB,MAAM,mBAAmB,IAAA,wKAAO;+CAAC,IAAO,IAAA,2MAAa,EAAC,YAAY,SAAS,GAAG,KAAK;8CAAW;QAAC;KAAS;IACxG,OAAO,IAAA,8KAAa,EAAC,WAAW;QAC5B,GAAG,YAAY;QACf,UAAU;IACd;AACJ&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">2127</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/context/PresenceContext.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use client</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { createContext } from 'react';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @public</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const PresenceContext = </span><span class="s3">\n</span><span class="s1">/* @__PURE__ */ createContext(null);</span><span class="s3">\n\n</span><span class="s1">export { PresenceContext };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AACA;AADA;;AAGA;;CAEC,GACD,MAAM,kBACN,aAAa,GAAG,IAAA,8KAAa,EAAC&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">2142</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/utils/use-constant.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use client</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { useRef } from 'react';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a constant value over the lifecycle of a component.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Even if `useMemo` is provided an empty array as its final argument, it doesn't offer</span><span class="s3">\n </span><span class="s1">* a guarantee that it won't re-run for performance reasons later on. By using `useConstant`</span><span class="s3">\n </span><span class="s1">* you can ensure that initialisers don't execute twice or more.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function useConstant(init) {</span><span class="s3">\n    </span><span class="s1">const ref = useRef(null);</span><span class="s3">\n    </span><span class="s1">if (ref.current === null) {</span><span class="s3">\n        </span><span class="s1">ref.current = init();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return ref.current;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { useConstant };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AACA;AADA;;AAGA;;;;;;CAMC,GACD,SAAS,YAAY,IAAI;IACrB,MAAM,MAAM,IAAA,uKAAM,EAAC;IACnB,IAAI,IAAI,OAAO,KAAK,MAAM;QACtB,IAAI,OAAO,GAAG;IAClB;IACA,OAAO,IAAI,OAAO;AACtB&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">2167</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/value/utils/resolve-motion-value.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { isMotionValue } from 'motion-dom';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* TODO: Remove and move to library</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function resolveMotionValue(value) {</span><span class="s3">\n    </span><span class="s1">return isMotionValue(value) ? value.get() : value;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { resolveMotionValue };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;;AAEA;;;;CAIC,GACD,SAAS,mBAAmB,KAAK;IAC7B,OAAO,IAAA,2MAAa,EAAC,SAAS,MAAM,GAAG,KAAK;AAChD&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">2185</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use client</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { useContext } from 'react';</span><span class="s3">\n</span><span class="s1">import { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';</span><span class="s3">\n</span><span class="s1">import { MotionContext } from '../../context/MotionContext/index.mjs';</span><span class="s3">\n</span><span class="s1">import { PresenceContext } from '../../context/PresenceContext.mjs';</span><span class="s3">\n</span><span class="s1">import { isControllingVariants, isVariantNode } from '../../render/utils/is-controlling-variants.mjs';</span><span class="s3">\n</span><span class="s1">import { resolveVariantFromProps } from '../../render/utils/resolve-variants.mjs';</span><span class="s3">\n</span><span class="s1">import { useConstant } from '../../utils/use-constant.mjs';</span><span class="s3">\n</span><span class="s1">import { resolveMotionValue } from '../../value/utils/resolve-motion-value.mjs';</span><span class="s3">\n\n</span><span class="s1">function makeState({ scrapeMotionValuesFromProps, createRenderState, }, props, context, presenceContext) {</span><span class="s3">\n    </span><span class="s1">const state = {</span><span class="s3">\n        </span><span class="s1">latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps),</span><span class="s3">\n        </span><span class="s1">renderState: createRenderState(),</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">return state;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {</span><span class="s3">\n    </span><span class="s1">const values = {};</span><span class="s3">\n    </span><span class="s1">const motionValues = scrapeMotionValues(props, {});</span><span class="s3">\n    </span><span class="s1">for (const key in motionValues) {</span><span class="s3">\n        </span><span class="s1">values[key] = resolveMotionValue(motionValues[key]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let { initial, animate } = props;</span><span class="s3">\n    </span><span class="s1">const isControllingVariants$1 = isControllingVariants(props);</span><span class="s3">\n    </span><span class="s1">const isVariantNode$1 = isVariantNode(props);</span><span class="s3">\n    </span><span class="s1">if (context &amp;&amp;</span><span class="s3">\n        </span><span class="s1">isVariantNode$1 &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!isControllingVariants$1 &amp;&amp;</span><span class="s3">\n        </span><span class="s1">props.inherit !== false) {</span><span class="s3">\n        </span><span class="s1">if (initial === undefined)</span><span class="s3">\n            </span><span class="s1">initial = context.initial;</span><span class="s3">\n        </span><span class="s1">if (animate === undefined)</span><span class="s3">\n            </span><span class="s1">animate = context.animate;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let isInitialAnimationBlocked = presenceContext</span><span class="s3">\n        </span><span class="s1">? presenceContext.initial === false</span><span class="s3">\n        </span><span class="s1">: false;</span><span class="s3">\n    </span><span class="s1">isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;</span><span class="s3">\n    </span><span class="s1">const variantToSet = isInitialAnimationBlocked ? animate : initial;</span><span class="s3">\n    </span><span class="s1">if (variantToSet &amp;&amp;</span><span class="s3">\n        </span><span class="s1">typeof variantToSet !== </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n        </span><span class="s1">!isAnimationControls(variantToSet)) {</span><span class="s3">\n        </span><span class="s1">const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; list.length; i++) {</span><span class="s3">\n            </span><span class="s1">const resolved = resolveVariantFromProps(props, list[i]);</span><span class="s3">\n            </span><span class="s1">if (resolved) {</span><span class="s3">\n                </span><span class="s1">const { transitionEnd, transition, ...target } = resolved;</span><span class="s3">\n                </span><span class="s1">for (const key in target) {</span><span class="s3">\n                    </span><span class="s1">let valueTarget = target[key];</span><span class="s3">\n                    </span><span class="s1">if (Array.isArray(valueTarget)) {</span><span class="s3">\n                        </span><span class="s1">/**</span><span class="s3">\n                         </span><span class="s1">* Take final keyframe if the initial animation is blocked because</span><span class="s3">\n                         </span><span class="s1">* we want to initialise at the end of that blocked animation.</span><span class="s3">\n                         </span><span class="s1">*/</span><span class="s3">\n                        </span><span class="s1">const index = isInitialAnimationBlocked</span><span class="s3">\n                            </span><span class="s1">? valueTarget.length - 1</span><span class="s3">\n                            </span><span class="s1">: 0;</span><span class="s3">\n                        </span><span class="s1">valueTarget = valueTarget[index];</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">if (valueTarget !== null) {</span><span class="s3">\n                        </span><span class="s1">values[key] = valueTarget;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">for (const key in transitionEnd) {</span><span class="s3">\n                    </span><span class="s1">values[key] = transitionEnd[key];</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return values;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const makeUseVisualState = (config) =&gt; (props, isStatic) =&gt; {</span><span class="s3">\n    </span><span class="s1">const context = useContext(MotionContext);</span><span class="s3">\n    </span><span class="s1">const presenceContext = useContext(PresenceContext);</span><span class="s3">\n    </span><span class="s1">const make = () =&gt; makeState(config, props, context, presenceContext);</span><span class="s3">\n    </span><span class="s1">return isStatic ? make() : useConstant(make);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export { makeUseVisualState };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;;;;;;;;;AAUA,SAAS,UAAU,KAAmD,EAAE,KAAK,EAAE,OAAO,EAAE,eAAe;QAApF,EAAE,2BAA2B,EAAE,iBAAiB,EAAG,GAAnD;IACf,MAAM,QAAQ;QACV,cAAc,iBAAiB,OAAO,SAAS,iBAAiB;QAChE,aAAa;IACjB;IACA,OAAO;AACX;AACA,SAAS,iBAAiB,KAAK,EAAE,OAAO,EAAE,eAAe,EAAE,kBAAkB;IACzE,MAAM,SAAS,CAAC;IAChB,MAAM,eAAe,mBAAmB,OAAO,CAAC;IAChD,IAAK,MAAM,OAAO,aAAc;QAC5B,MAAM,CAAC,IAAI,GAAG,IAAA,wNAAkB,EAAC,YAAY,CAAC,IAAI;IACtD;IACA,IAAI,EAAE,OAAO,EAAE,OAAO,EAAE,GAAG;IAC3B,MAAM,0BAA0B,IAAA,+NAAqB,EAAC;IACtD,MAAM,kBAAkB,IAAA,uNAAa,EAAC;IACtC,IAAI,WACA,mBACA,CAAC,2BACD,MAAM,OAAO,KAAK,OAAO;QACzB,IAAI,YAAY,WACZ,UAAU,QAAQ,OAAO;QAC7B,IAAI,YAAY,WACZ,UAAU,QAAQ,OAAO;IACjC;IACA,IAAI,4BAA4B,kBAC1B,gBAAgB,OAAO,KAAK,QAC5B;IACN,4BAA4B,6BAA6B,YAAY;IACrE,MAAM,eAAe,4BAA4B,UAAU;IAC3D,IAAI,gBACA,OAAO,iBAAiB,aACxB,CAAC,IAAA,8NAAmB,EAAC,eAAe;QACpC,MAAM,OAAO,MAAM,OAAO,CAAC,gBAAgB,eAAe;YAAC;SAAa;QACxE,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,MAAM,EAAE,IAAK;YAClC,MAAM,WAAW,IAAA,uNAAuB,EAAC,OAAO,IAAI,CAAC,EAAE;YACvD,IAAI,UAAU;gBACV,MAAM,EAAE,aAAa,EAAE,UAAU,EAAE,GAAG,QAAQ,GAAG;gBACjD,IAAK,MAAM,OAAO,OAAQ;oBACtB,IAAI,cAAc,MAAM,CAAC,IAAI;oBAC7B,IAAI,MAAM,OAAO,CAAC,cAAc;wBAC5B;;;yBAGC,GACD,MAAM,QAAQ,4BACR,YAAY,MAAM,GAAG,IACrB;wBACN,cAAc,WAAW,CAAC,MAAM;oBACpC;oBACA,IAAI,gBAAgB,MAAM;wBACtB,MAAM,CAAC,IAAI,GAAG;oBAClB;gBACJ;gBACA,IAAK,MAAM,OAAO,cAAe;oBAC7B,MAAM,CAAC,IAAI,GAAG,aAAa,CAAC,IAAI;gBACpC;YACJ;QACJ;IACJ;IACA,OAAO;AACX;AACA,MAAM,qBAAqB,CAAC,SAAW,CAAC,OAAO;QAC3C,MAAM,UAAU,IAAA,2KAAU,EAAC,wMAAa;QACxC,MAAM,kBAAkB,IAAA,2KAAU,EAAC,mMAAe;QAClD,MAAM,OAAO,IAAM,UAAU,QAAQ,OAAO,SAAS;QACrD,OAAO,WAAW,SAAS,IAAA,6LAAW,EAAC;IAC3C&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">2270</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/render/html/use-html-visual-state.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use client</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { makeUseVisualState } from '../../motion/utils/use-visual-state.mjs';</span><span class="s3">\n</span><span class="s1">import { createHtmlRenderState } from './utils/create-render-state.mjs';</span><span class="s3">\n</span><span class="s1">import { scrapeMotionValuesFromProps } from './utils/scrape-motion-values.mjs';</span><span class="s3">\n\n</span><span class="s1">const useHTMLVisualState = /*@__PURE__*/ makeUseVisualState({</span><span class="s3">\n    </span><span class="s1">scrapeMotionValuesFromProps,</span><span class="s3">\n    </span><span class="s1">createRenderState: createHtmlRenderState,</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">export { useHTMLVisualState };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AACA;AACA;AACA;AAHA;;;;AAKA,MAAM,qBAAqB,WAAW,GAAG,IAAA,qNAAkB,EAAC;IACxD,6BAAA,0OAA2B;IAC3B,mBAAmB,mOAAqB;AAC5C&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">2290</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/render/svg/use-svg-visual-state.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use client</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { makeUseVisualState } from '../../motion/utils/use-visual-state.mjs';</span><span class="s3">\n</span><span class="s1">import { createSvgRenderState } from './utils/create-render-state.mjs';</span><span class="s3">\n</span><span class="s1">import { scrapeMotionValuesFromProps } from './utils/scrape-motion-values.mjs';</span><span class="s3">\n\n</span><span class="s1">const useSVGVisualState = /*@__PURE__*/ makeUseVisualState({</span><span class="s3">\n    </span><span class="s1">scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,</span><span class="s3">\n    </span><span class="s1">createRenderState: createSvgRenderState,</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">export { useSVGVisualState };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AACA;AACA;AACA;AAHA;;;;AAKA,MAAM,oBAAoB,WAAW,GAAG,IAAA,qNAAkB,EAAC;IACvD,6BAA6B,yOAA2B;IACxD,mBAAmB,iOAAoB;AAC3C&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">2310</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/motion/features/load-features.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { featureDefinitions } from './definitions.mjs';</span><span class="s3">\n\n</span><span class="s1">function loadFeatures(features) {</span><span class="s3">\n    </span><span class="s1">for (const key in features) {</span><span class="s3">\n        </span><span class="s1">featureDefinitions[key] = {</span><span class="s3">\n            </span><span class="s1">...featureDefinitions[key],</span><span class="s3">\n            </span><span class="s1">...features[key],</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { loadFeatures };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;;AAEA,SAAS,aAAa,QAAQ;IAC1B,IAAK,MAAM,OAAO,SAAU;QACxB,6MAAkB,CAAC,IAAI,GAAG;YACtB,GAAG,6MAAkB,CAAC,IAAI;YAC1B,GAAG,QAAQ,CAAC,IAAI;QACpB;IACJ;AACJ&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">2329</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/motion/utils/symbol.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;const motionComponentSymbol = Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">motionComponentSymbol</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n</span><span class="s1">export { motionComponentSymbol };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA,MAAM,wBAAwB,OAAO,GAAG,CAAC&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">2339</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/utils/is-ref-object.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;function isRefObject(ref) {</span><span class="s3">\n    </span><span class="s1">return (ref &amp;&amp;</span><span class="s3">\n        </span><span class="s1">typeof ref === </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n        </span><span class="s1">Object.prototype.hasOwnProperty.call(ref, </span><span class="s3">\&quot;</span><span class="s1">current</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { isRefObject };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA,SAAS,YAAY,GAAG;IACpB,OAAQ,OACJ,OAAO,QAAQ,YACf,OAAO,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,KAAK;AAClD&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">2351</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use client</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { useCallback } from 'react';</span><span class="s3">\n</span><span class="s1">import { isRefObject } from '../../utils/is-ref-object.mjs';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a ref function that, when called, hydrates the provided</span><span class="s3">\n </span><span class="s1">* external ref and VisualElement.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function useMotionRef(visualState, visualElement, externalRef) {</span><span class="s3">\n    </span><span class="s1">return useCallback((instance) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (instance) {</span><span class="s3">\n            </span><span class="s1">visualState.onMount &amp;&amp; visualState.onMount(instance);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (visualElement) {</span><span class="s3">\n            </span><span class="s1">if (instance) {</span><span class="s3">\n                </span><span class="s1">visualElement.mount(instance);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">visualElement.unmount();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (externalRef) {</span><span class="s3">\n            </span><span class="s1">if (typeof externalRef === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">externalRef(instance);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (isRefObject(externalRef)) {</span><span class="s3">\n                </span><span class="s1">externalRef.current = instance;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Include externalRef in dependencies to ensure the callback updates</span><span class="s3">\n     </span><span class="s1">* when the ref changes, allowing proper ref forwarding.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">[visualElement]);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { useMotionRef };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AACA;AACA;AAFA;;;AAIA;;;CAGC,GACD,SAAS,aAAa,WAAW,EAAE,aAAa,EAAE,WAAW;IACzD,OAAO,IAAA,4KAAW;oCAAC,CAAC;YAChB,IAAI,UAAU;gBACV,YAAY,OAAO,IAAI,YAAY,OAAO,CAAC;YAC/C;YACA,IAAI,eAAe;gBACf,IAAI,UAAU;oBACV,cAAc,KAAK,CAAC;gBACxB,OACK;oBACD,cAAc,OAAO;gBACzB;YACJ;YACA,IAAI,aAAa;gBACb,IAAI,OAAO,gBAAgB,YAAY;oBACnC,YAAY;gBAChB,OACK,IAAI,IAAA,iMAAW,EAAC,cAAc;oBAC/B,YAAY,OAAO,GAAG;gBAC1B;YACJ;QACJ;mCACA;;;KAGC,GACD;QAAC;KAAc;AACnB&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">2396</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/animation/optimized-appear/data-id.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { camelToDash } from '../../render/dom/utils/camel-to-dash.mjs';</span><span class="s3">\n\n</span><span class="s1">const optimizedAppearDataId = </span><span class="s3">\&quot;</span><span class="s1">framerAppearId</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const optimizedAppearDataAttribute = </span><span class="s3">\&quot;</span><span class="s1">data-</span><span class="s3">\&quot; </span><span class="s1">+ camelToDash(optimizedAppearDataId);</span><span class="s3">\n\n</span><span class="s1">export { optimizedAppearDataAttribute, optimizedAppearDataId };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;AAAA;;AAEA,MAAM,wBAAwB;AAC9B,MAAM,+BAA+B,UAAU,IAAA,kNAAW,EAAC&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">2411</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/context/SwitchLayoutGroupContext.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use client</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { createContext } from 'react';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Internal, exported only for usage in Framer</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const SwitchLayoutGroupContext = createContext({});</span><span class="s3">\n\n</span><span class="s1">export { SwitchLayoutGroupContext };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AACA;AADA;;AAGA;;CAEC,GACD,MAAM,2BAA2B,IAAA,8KAAa,EAAC,CAAC&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">2426</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use client</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { useLayoutEffect, useEffect } from 'react';</span><span class="s3">\n</span><span class="s1">import { isBrowser } from './is-browser.mjs';</span><span class="s3">\n\n</span><span class="s1">const useIsomorphicLayoutEffect = isBrowser ? useLayoutEffect : useEffect;</span><span class="s3">\n\n</span><span class="s1">export { useIsomorphicLayoutEffect };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AACA;AACA;AAFA;;;AAIA,MAAM,4BAA4B,yLAAS,GAAG,gLAAe,GAAG,0KAAS&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">2441</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use client</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { useContext, useRef, useInsertionEffect, useEffect } from 'react';</span><span class="s3">\n</span><span class="s1">import { optimizedAppearDataAttribute } from '../../animation/optimized-appear/data-id.mjs';</span><span class="s3">\n</span><span class="s1">import { LazyContext } from '../../context/LazyContext.mjs';</span><span class="s3">\n</span><span class="s1">import { MotionConfigContext } from '../../context/MotionConfigContext.mjs';</span><span class="s3">\n</span><span class="s1">import { MotionContext } from '../../context/MotionContext/index.mjs';</span><span class="s3">\n</span><span class="s1">import { PresenceContext } from '../../context/PresenceContext.mjs';</span><span class="s3">\n</span><span class="s1">import { SwitchLayoutGroupContext } from '../../context/SwitchLayoutGroupContext.mjs';</span><span class="s3">\n</span><span class="s1">import { isRefObject } from '../../utils/is-ref-object.mjs';</span><span class="s3">\n</span><span class="s1">import { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';</span><span class="s3">\n\n</span><span class="s1">function useVisualElement(Component, visualState, props, createVisualElement, ProjectionNodeConstructor) {</span><span class="s3">\n    </span><span class="s1">const { visualElement: parent } = useContext(MotionContext);</span><span class="s3">\n    </span><span class="s1">const lazyContext = useContext(LazyContext);</span><span class="s3">\n    </span><span class="s1">const presenceContext = useContext(PresenceContext);</span><span class="s3">\n    </span><span class="s1">const reducedMotionConfig = useContext(MotionConfigContext).reducedMotion;</span><span class="s3">\n    </span><span class="s1">const visualElementRef = useRef(null);</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* If we haven't preloaded a renderer, check to see if we have one lazy-loaded</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">createVisualElement =</span><span class="s3">\n        </span><span class="s1">createVisualElement ||</span><span class="s3">\n            </span><span class="s1">lazyContext.renderer;</span><span class="s3">\n    </span><span class="s1">if (!visualElementRef.current &amp;&amp; createVisualElement) {</span><span class="s3">\n        </span><span class="s1">visualElementRef.current = createVisualElement(Component, {</span><span class="s3">\n            </span><span class="s1">visualState,</span><span class="s3">\n            </span><span class="s1">parent,</span><span class="s3">\n            </span><span class="s1">props,</span><span class="s3">\n            </span><span class="s1">presenceContext,</span><span class="s3">\n            </span><span class="s1">blockInitialAnimation: presenceContext</span><span class="s3">\n                </span><span class="s1">? presenceContext.initial === false</span><span class="s3">\n                </span><span class="s1">: false,</span><span class="s3">\n            </span><span class="s1">reducedMotionConfig,</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const visualElement = visualElementRef.current;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Load Motion gesture and animation features. These are rendered as renderless</span><span class="s3">\n     </span><span class="s1">* components so each feature can optionally make use of React lifecycle methods.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">const initialLayoutGroupConfig = useContext(SwitchLayoutGroupContext);</span><span class="s3">\n    </span><span class="s1">if (visualElement &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!visualElement.projection &amp;&amp;</span><span class="s3">\n        </span><span class="s1">ProjectionNodeConstructor &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(visualElement.type === </span><span class="s3">\&quot;</span><span class="s1">html</span><span class="s3">\&quot; </span><span class="s1">|| visualElement.type === </span><span class="s3">\&quot;</span><span class="s1">svg</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n        </span><span class="s1">createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const isMounted = useRef(false);</span><span class="s3">\n    </span><span class="s1">useInsertionEffect(() =&gt; {</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Check the component has already mounted before calling</span><span class="s3">\n         </span><span class="s1">* `update` unnecessarily. This ensures we skip the initial update.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">if (visualElement &amp;&amp; isMounted.current) {</span><span class="s3">\n            </span><span class="s1">visualElement.update(props, presenceContext);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Cache this value as we want to know whether HandoffAppearAnimations</span><span class="s3">\n     </span><span class="s1">* was present on initial render - it will be deleted after this.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">const optimisedAppearId = props[optimizedAppearDataAttribute];</span><span class="s3">\n    </span><span class="s1">const wantsHandoff = useRef(Boolean(optimisedAppearId) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!window.MotionHandoffIsComplete?.(optimisedAppearId) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">window.MotionHasOptimisedAnimation?.(optimisedAppearId));</span><span class="s3">\n    </span><span class="s1">useIsomorphicLayoutEffect(() =&gt; {</span><span class="s3">\n        </span><span class="s1">if (!visualElement)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">isMounted.current = true;</span><span class="s3">\n        </span><span class="s1">window.MotionIsMounted = true;</span><span class="s3">\n        </span><span class="s1">visualElement.updateFeatures();</span><span class="s3">\n        </span><span class="s1">visualElement.scheduleRenderMicrotask();</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Ideally this function would always run in a useEffect.</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* However, if we have optimised appear animations to handoff from,</span><span class="s3">\n         </span><span class="s1">* it needs to happen synchronously to ensure there's no flash of</span><span class="s3">\n         </span><span class="s1">* incorrect styles in the event of a hydration error.</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* So if we detect a situtation where optimised appear animations</span><span class="s3">\n         </span><span class="s1">* are running, we use useLayoutEffect to trigger animations.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">if (wantsHandoff.current &amp;&amp; visualElement.animationState) {</span><span class="s3">\n            </span><span class="s1">visualElement.animationState.animateChanges();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">useEffect(() =&gt; {</span><span class="s3">\n        </span><span class="s1">if (!visualElement)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">if (!wantsHandoff.current &amp;&amp; visualElement.animationState) {</span><span class="s3">\n            </span><span class="s1">visualElement.animationState.animateChanges();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (wantsHandoff.current) {</span><span class="s3">\n            </span><span class="s1">// This ensures all future calls to animateChanges() in this component will run in useEffect</span><span class="s3">\n            </span><span class="s1">queueMicrotask(() =&gt; {</span><span class="s3">\n                </span><span class="s1">window.MotionHandoffMarkAsComplete?.(optimisedAppearId);</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">wantsHandoff.current = false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Now we've finished triggering animations for this element we</span><span class="s3">\n         </span><span class="s1">* can wipe the enteringChildren set for the next render.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">visualElement.enteringChildren = undefined;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return visualElement;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {</span><span class="s3">\n    </span><span class="s1">const { layoutId, layout, drag, dragConstraints, layoutScroll, layoutRoot, layoutCrossfade, } = props;</span><span class="s3">\n    </span><span class="s1">visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props[</span><span class="s3">\&quot;</span><span class="s1">data-framer-portal-id</span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\n        </span><span class="s1">? undefined</span><span class="s3">\n        </span><span class="s1">: getClosestProjectingNode(visualElement.parent));</span><span class="s3">\n    </span><span class="s1">visualElement.projection.setOptions({</span><span class="s3">\n        </span><span class="s1">layoutId,</span><span class="s3">\n        </span><span class="s1">layout,</span><span class="s3">\n        </span><span class="s1">alwaysMeasureLayout: Boolean(drag) || (dragConstraints &amp;&amp; isRefObject(dragConstraints)),</span><span class="s3">\n        </span><span class="s1">visualElement,</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* TODO: Update options in an effect. This could be tricky as it'll be too late</span><span class="s3">\n         </span><span class="s1">* to update by the time layout animations run.</span><span class="s3">\n         </span><span class="s1">* We also need to fix this safeToRemove by linking it up to the one returned by usePresence,</span><span class="s3">\n         </span><span class="s1">* ensuring it gets called if there's no potential layout animations.</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">animationType: typeof layout === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">? layout : </span><span class="s3">\&quot;</span><span class="s1">both</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">initialPromotionConfig,</span><span class="s3">\n        </span><span class="s1">crossfade: layoutCrossfade,</span><span class="s3">\n        </span><span class="s1">layoutScroll,</span><span class="s3">\n        </span><span class="s1">layoutRoot,</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getClosestProjectingNode(visualElement) {</span><span class="s3">\n    </span><span class="s1">if (!visualElement)</span><span class="s3">\n        </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">return visualElement.options.allowProjection !== false</span><span class="s3">\n        </span><span class="s1">? visualElement.projection</span><span class="s3">\n        </span><span class="s1">: getClosestProjectingNode(visualElement.parent);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { useVisualElement };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">2583</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/motion/index.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use client</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { jsxs, jsx } from 'react/jsx-runtime';</span><span class="s3">\n</span><span class="s1">import { warning, invariant } from 'motion-utils';</span><span class="s3">\n</span><span class="s1">import { forwardRef, useContext } from 'react';</span><span class="s3">\n</span><span class="s1">import { LayoutGroupContext } from '../context/LayoutGroupContext.mjs';</span><span class="s3">\n</span><span class="s1">import { LazyContext } from '../context/LazyContext.mjs';</span><span class="s3">\n</span><span class="s1">import { MotionConfigContext } from '../context/MotionConfigContext.mjs';</span><span class="s3">\n</span><span class="s1">import { MotionContext } from '../context/MotionContext/index.mjs';</span><span class="s3">\n</span><span class="s1">import { useCreateMotionContext } from '../context/MotionContext/create.mjs';</span><span class="s3">\n</span><span class="s1">import { useRender } from '../render/dom/use-render.mjs';</span><span class="s3">\n</span><span class="s1">import { isSVGComponent } from '../render/dom/utils/is-svg-component.mjs';</span><span class="s3">\n</span><span class="s1">import { useHTMLVisualState } from '../render/html/use-html-visual-state.mjs';</span><span class="s3">\n</span><span class="s1">import { useSVGVisualState } from '../render/svg/use-svg-visual-state.mjs';</span><span class="s3">\n</span><span class="s1">import { isBrowser } from '../utils/is-browser.mjs';</span><span class="s3">\n</span><span class="s1">import { featureDefinitions } from './features/definitions.mjs';</span><span class="s3">\n</span><span class="s1">import { loadFeatures } from './features/load-features.mjs';</span><span class="s3">\n</span><span class="s1">import { motionComponentSymbol } from './utils/symbol.mjs';</span><span class="s3">\n</span><span class="s1">import { useMotionRef } from './utils/use-motion-ref.mjs';</span><span class="s3">\n</span><span class="s1">import { useVisualElement } from './utils/use-visual-element.mjs';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Create a `motion` component.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This function accepts a Component argument, which can be either a string (ie </span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;\n </span><span class="s1">* for `motion.div`), or an actual React component.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Alongside this is a config option which provides a way of rendering the provided</span><span class="s3">\n </span><span class="s1">* component </span><span class="s3">\&quot;</span><span class="s1">offline</span><span class="s3">\&quot;</span><span class="s1">, or outside the React render cycle.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function createMotionComponent(Component, { forwardMotionProps = false } = {}, preloadedFeatures, createVisualElement) {</span><span class="s3">\n    </span><span class="s1">preloadedFeatures &amp;&amp; loadFeatures(preloadedFeatures);</span><span class="s3">\n    </span><span class="s1">const useVisualState = isSVGComponent(Component)</span><span class="s3">\n        </span><span class="s1">? useSVGVisualState</span><span class="s3">\n        </span><span class="s1">: useHTMLVisualState;</span><span class="s3">\n    </span><span class="s1">function MotionDOMComponent(props, externalRef) {</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* If we need to measure the element we load this functionality in a</span><span class="s3">\n         </span><span class="s1">* separate class component in order to gain access to getSnapshotBeforeUpdate.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">let MeasureLayout;</span><span class="s3">\n        </span><span class="s1">const configAndProps = {</span><span class="s3">\n            </span><span class="s1">...useContext(MotionConfigContext),</span><span class="s3">\n            </span><span class="s1">...props,</span><span class="s3">\n            </span><span class="s1">layoutId: useLayoutId(props),</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">const { isStatic } = configAndProps;</span><span class="s3">\n        </span><span class="s1">const context = useCreateMotionContext(props);</span><span class="s3">\n        </span><span class="s1">const visualState = useVisualState(props, isStatic);</span><span class="s3">\n        </span><span class="s1">if (!isStatic &amp;&amp; isBrowser) {</span><span class="s3">\n            </span><span class="s1">useStrictMode(configAndProps, preloadedFeatures);</span><span class="s3">\n            </span><span class="s1">const layoutProjection = getProjectionFunctionality(configAndProps);</span><span class="s3">\n            </span><span class="s1">MeasureLayout = layoutProjection.MeasureLayout;</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* Create a VisualElement for this component. A VisualElement provides a common</span><span class="s3">\n             </span><span class="s1">* interface to renderer-specific APIs (ie DOM/Three.js etc) as well as</span><span class="s3">\n             </span><span class="s1">* providing a way of rendering to these APIs outside of the React render loop</span><span class="s3">\n             </span><span class="s1">* for more performant animations and interactions</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* The mount order and hierarchy is specific to ensure our element ref</span><span class="s3">\n         </span><span class="s1">* is hydrated by the time features fire their effects.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">return (jsxs(MotionContext.Provider, { value: context, children: [MeasureLayout &amp;&amp; context.visualElement ? (jsx(MeasureLayout, { visualElement: context.visualElement, ...configAndProps })) : null, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, forwardMotionProps)] }));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">MotionDOMComponent.displayName = `motion.${typeof Component === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;\n        </span><span class="s1">? Component</span><span class="s3">\n        </span><span class="s1">: `create(${Component.displayName ?? Component.name ?? </span><span class="s3">\&quot;\&quot;</span><span class="s1">})`}`;</span><span class="s3">\n    </span><span class="s1">const ForwardRefMotionComponent = forwardRef(MotionDOMComponent);</span><span class="s3">\n    </span><span class="s1">ForwardRefMotionComponent[motionComponentSymbol] = Component;</span><span class="s3">\n    </span><span class="s1">return ForwardRefMotionComponent;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function useLayoutId({ layoutId }) {</span><span class="s3">\n    </span><span class="s1">const layoutGroupId = useContext(LayoutGroupContext).id;</span><span class="s3">\n    </span><span class="s1">return layoutGroupId &amp;&amp; layoutId !== undefined</span><span class="s3">\n        </span><span class="s1">? layoutGroupId + </span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot; </span><span class="s1">+ layoutId</span><span class="s3">\n        </span><span class="s1">: layoutId;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function useStrictMode(configAndProps, preloadedFeatures) {</span><span class="s3">\n    </span><span class="s1">const isStrict = useContext(LazyContext).strict;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* If we're in development mode, check to make sure we're not rendering a motion component</span><span class="s3">\n     </span><span class="s1">* as a child of LazyMotion, as this will break the file-size benefits of using it.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">if (process.env.NODE_ENV !== </span><span class="s3">\&quot;</span><span class="s1">production</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n        </span><span class="s1">preloadedFeatures &amp;&amp;</span><span class="s3">\n        </span><span class="s1">isStrict) {</span><span class="s3">\n        </span><span class="s1">const strictMessage = </span><span class="s3">\&quot;</span><span class="s1">You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">configAndProps.ignoreStrict</span><span class="s3">\n            </span><span class="s1">? warning(false, strictMessage, </span><span class="s3">\&quot;</span><span class="s1">lazy-strict-mode</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">: invariant(false, strictMessage, </span><span class="s3">\&quot;</span><span class="s1">lazy-strict-mode</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getProjectionFunctionality(props) {</span><span class="s3">\n    </span><span class="s1">const { drag, layout } = featureDefinitions;</span><span class="s3">\n    </span><span class="s1">if (!drag &amp;&amp; !layout)</span><span class="s3">\n        </span><span class="s1">return {};</span><span class="s3">\n    </span><span class="s1">const combined = { ...drag, ...layout };</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">MeasureLayout: drag?.isEnabled(props) || layout?.isEnabled(props)</span><span class="s3">\n            </span><span class="s1">? combined.MeasureLayout</span><span class="s3">\n            </span><span class="s1">: undefined,</span><span class="s3">\n        </span><span class="s1">ProjectionNode: combined.ProjectionNode,</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { createMotionComponent };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAqFQ;AApFR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlBA;;;;;;;;;;;;;;;;;;;AAoBA;;;;;;;;CAQC,GACD,SAAS,sBAAsB,SAAS;QAAE,EAAE,qBAAqB,KAAK,EAAE,GAA9B,iEAAiC,CAAC,GAAG,kEAAmB;IAC9F,qBAAqB,IAAA,4MAAY,EAAC;IAClC,MAAM,iBAAiB,IAAA,wNAAc,EAAC,aAChC,yNAAiB,GACjB,4NAAkB;IACxB,SAAS,mBAAmB,KAAK,EAAE,WAAW;QAC1C;;;SAGC,GACD,IAAI;QACJ,MAAM,iBAAiB;YACnB,GAAG,IAAA,2KAAU,EAAC,2MAAmB,CAAC;YAClC,GAAG,KAAK;YACR,UAAU,YAAY;QAC1B;QACA,MAAM,EAAE,QAAQ,EAAE,GAAG;QACrB,MAAM,UAAU,IAAA,kNAAsB,EAAC;QACvC,MAAM,cAAc,eAAe,OAAO;QAC1C,IAAI,CAAC,YAAY,yLAAS,EAAE;YACxB,cAAc,gBAAgB;YAC9B,MAAM,mBAAmB,2BAA2B;YACpD,gBAAgB,iBAAiB,aAAa;YAC9C;;;;;aAKC,GACD,QAAQ,aAAa,GAAG,IAAA,qNAAgB,EAAC,WAAW,aAAa,gBAAgB,qBAAqB,iBAAiB,cAAc;QACzI;QACA;;;SAGC,GACD,OAAQ,IAAA,8KAAI,EAAC,wMAAa,CAAC,QAAQ,EAAE;YAAE,OAAO;YAAS,UAAU;gBAAC,iBAAiB,QAAQ,aAAa,GAAI,IAAA,6KAAG,EAAC,eAAe;oBAAE,eAAe,QAAQ,aAAa;oBAAE,GAAG,cAAc;gBAAC,KAAM;gBAAM,IAAA,iMAAS,EAAC,WAAW,OAAO,IAAA,6MAAY,EAAC,aAAa,QAAQ,aAAa,EAAE,cAAc,aAAa,UAAU;aAAoB;QAAC;IAChV;QAGgB,wBAAA;IAFhB,mBAAmB,WAAW,GAAG,AAAC,UAE+B,OAFtB,OAAO,cAAc,WAC1D,YACA,AAAC,UAAuD,OAA9C,CAAA,OAAA,CAAA,yBAAA,UAAU,WAAW,cAArB,oCAAA,yBAAyB,UAAU,IAAI,cAAvC,kBAAA,OAA2C,IAAG;IAC9D,MAAM,4BAA4B,IAAA,2KAAU,EAAC;IAC7C,yBAAyB,CAAC,wMAAqB,CAAC,GAAG;IACnD,OAAO;AACX;AACA,SAAS,YAAY,KAAY;QAAZ,EAAE,QAAQ,EAAE,GAAZ;IACjB,MAAM,gBAAgB,IAAA,2KAAU,EAAC,yMAAkB,EAAE,EAAE;IACvD,OAAO,iBAAiB,aAAa,YAC/B,gBAAgB,MAAM,WACtB;AACV;AACA,SAAS,cAAc,cAAc,EAAE,iBAAiB;IACpD,MAAM,WAAW,IAAA,2KAAU,EAAC,2LAAW,EAAE,MAAM;IAC/C;;;KAGC,GACD,IAAI,oDAAyB,gBACzB,qBACA,UAAU;QACV,MAAM,gBAAgB;QACtB,eAAe,YAAY,GACrB,IAAA,sKAAO,EAAC,OAAO,eAAe,sBAC9B,IAAA,wKAAS,EAAC,OAAO,eAAe;IAC1C;AACJ;AACA,SAAS,2BAA2B,KAAK;IACrC,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,GAAG,6MAAkB;IAC3C,IAAI,CAAC,QAAQ,CAAC,QACV,OAAO,CAAC;IACZ,MAAM,WAAW;QAAE,GAAG,IAAI;QAAE,GAAG,MAAM;IAAC;IACtC,OAAO;QACH,eAAe,CAAA,iBAAA,2BAAA,KAAM,SAAS,CAAC,YAAU,mBAAA,6BAAA,OAAQ,SAAS,CAAC,UACrD,SAAS,aAAa,GACtB;QACN,gBAAgB,SAAS,cAAc;IAC3C;AACJ&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">2713</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/render/components/create-proxy.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { warnOnce } from 'motion-utils';</span><span class="s3">\n</span><span class="s1">import { createMotionComponent } from '../../motion/index.mjs';</span><span class="s3">\n\n</span><span class="s1">function createMotionProxy(preloadedFeatures, createVisualElement) {</span><span class="s3">\n    </span><span class="s1">if (typeof Proxy === </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return createMotionComponent;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* A cache of generated `motion` components, e.g `motion.div`, `motion.input` etc.</span><span class="s3">\n     </span><span class="s1">* Rather than generating them anew every render.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">const componentCache = new Map();</span><span class="s3">\n    </span><span class="s1">const factory = (Component, options) =&gt; {</span><span class="s3">\n        </span><span class="s1">return createMotionComponent(Component, options, preloadedFeatures, createVisualElement);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Support for deprecated`motion(Component)` pattern</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">const deprecatedFactoryFunction = (Component, options) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (process.env.NODE_ENV !== </span><span class="s3">\&quot;</span><span class="s1">production</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">warnOnce(false, </span><span class="s3">\&quot;</span><span class="s1">motion() is deprecated. Use motion.create() instead.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return factory(Component, options);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">return new Proxy(deprecatedFactoryFunction, {</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.</span><span class="s3">\n         </span><span class="s1">* The prop name is passed through as `key` and we can use that to generate a `motion`</span><span class="s3">\n         </span><span class="s1">* DOM component with that name.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">get: (_target, key) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (key === </span><span class="s3">\&quot;</span><span class="s1">create</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n                </span><span class="s1">return factory;</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* If this element doesn't exist in the component cache, create it and cache.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">if (!componentCache.has(key)) {</span><span class="s3">\n                </span><span class="s1">componentCache.set(key, createMotionComponent(key, undefined, preloadedFeatures, createVisualElement));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return componentCache.get(key);</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { createMotionProxy };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAmBY;AAnBZ;AACA;;;AAEA,SAAS,kBAAkB,iBAAiB,EAAE,mBAAmB;IAC7D,IAAI,OAAO,UAAU,aAAa;QAC9B,OAAO,8LAAqB;IAChC;IACA;;;KAGC,GACD,MAAM,iBAAiB,IAAI;IAC3B,MAAM,UAAU,CAAC,WAAW;QACxB,OAAO,IAAA,8LAAqB,EAAC,WAAW,SAAS,mBAAmB;IACxE;IACA;;KAEC,GACD,MAAM,4BAA4B,CAAC,WAAW;QAC1C,wCAA2C;YACvC,IAAA,6KAAQ,EAAC,OAAO;QACpB;QACA,OAAO,QAAQ,WAAW;IAC9B;IACA,OAAO,IAAI,MAAM,2BAA2B;QACxC;;;;SAIC,GACD,KAAK,CAAC,SAAS;YACX,IAAI,QAAQ,UACR,OAAO;YACX;;aAEC,GACD,IAAI,CAAC,eAAe,GAAG,CAAC,MAAM;gBAC1B,eAAe,GAAG,CAAC,KAAK,IAAA,8LAAqB,EAAC,KAAK,WAAW,mBAAmB;YACrF;YACA,OAAO,eAAe,GAAG,CAAC;QAC9B;IACJ;AACJ&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">2762</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/render/utils/resolve-dynamic-variants.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { resolveVariantFromProps } from './resolve-variants.mjs';</span><span class="s3">\n\n</span><span class="s1">function resolveVariant(visualElement, definition, custom) {</span><span class="s3">\n    </span><span class="s1">const props = visualElement.getProps();</span><span class="s3">\n    </span><span class="s1">return resolveVariantFromProps(props, definition, custom !== undefined ? custom : props.custom, visualElement);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { resolveVariant };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;;AAEA,SAAS,eAAe,aAAa,EAAE,UAAU,EAAE,MAAM;IACrD,MAAM,QAAQ,cAAc,QAAQ;IACpC,OAAO,IAAA,uNAAuB,EAAC,OAAO,YAAY,WAAW,YAAY,SAAS,MAAM,MAAM,EAAE;AACpG&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">2777</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/animation/utils/is-keyframes-target.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;const isKeyframesTarget = (v) =&gt; {</span><span class="s3">\n    </span><span class="s1">return Array.isArray(v);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export { isKeyframesTarget };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA,MAAM,oBAAoB,CAAC;IACvB,OAAO,MAAM,OAAO,CAAC;AACzB&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">2789</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/render/utils/setters.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { motionValue } from 'motion-dom';</span><span class="s3">\n</span><span class="s1">import { isKeyframesTarget } from '../../animation/utils/is-keyframes-target.mjs';</span><span class="s3">\n</span><span class="s1">import { resolveVariant } from './resolve-dynamic-variants.mjs';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Set VisualElement's MotionValue, creating a new MotionValue for it if</span><span class="s3">\n </span><span class="s1">* it doesn't exist.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function setMotionValue(visualElement, key, value) {</span><span class="s3">\n    </span><span class="s1">if (visualElement.hasValue(key)) {</span><span class="s3">\n        </span><span class="s1">visualElement.getValue(key).set(value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">visualElement.addValue(key, motionValue(value));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function resolveFinalValueInKeyframes(v) {</span><span class="s3">\n    </span><span class="s1">// TODO maybe throw if v.length - 1 is placeholder token?</span><span class="s3">\n    </span><span class="s1">return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function setTarget(visualElement, definition) {</span><span class="s3">\n    </span><span class="s1">const resolved = resolveVariant(visualElement, definition);</span><span class="s3">\n    </span><span class="s1">let { transitionEnd = {}, transition = {}, ...target } = resolved || {};</span><span class="s3">\n    </span><span class="s1">target = { ...target, ...transitionEnd };</span><span class="s3">\n    </span><span class="s1">for (const key in target) {</span><span class="s3">\n        </span><span class="s1">const value = resolveFinalValueInKeyframes(target[key]);</span><span class="s3">\n        </span><span class="s1">setMotionValue(visualElement, key, value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { setTarget };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;AACA;AACA;;;;AAEA;;;CAGC,GACD,SAAS,eAAe,aAAa,EAAE,GAAG,EAAE,KAAK;IAC7C,IAAI,cAAc,QAAQ,CAAC,MAAM;QAC7B,cAAc,QAAQ,CAAC,KAAK,GAAG,CAAC;IACpC,OACK;QACD,cAAc,QAAQ,CAAC,KAAK,IAAA,gLAAW,EAAC;IAC5C;AACJ;AACA,SAAS,6BAA6B,CAAC;IACnC,yDAAyD;IACzD,OAAO,IAAA,0NAAiB,EAAC,KAAK,CAAC,CAAC,EAAE,MAAM,GAAG,EAAE,IAAI,IAAI;AACzD;AACA,SAAS,UAAU,aAAa,EAAE,UAAU;IACxC,MAAM,WAAW,IAAA,yNAAc,EAAC,eAAe;IAC/C,IAAI,EAAE,gBAAgB,CAAC,CAAC,EAAE,aAAa,CAAC,CAAC,EAAE,GAAG,QAAQ,GAAG,YAAY,CAAC;IACtE,SAAS;QAAE,GAAG,MAAM;QAAE,GAAG,aAAa;IAAC;IACvC,IAAK,MAAM,OAAO,OAAQ;QACtB,MAAM,QAAQ,6BAA6B,MAAM,CAAC,IAAI;QACtD,eAAe,eAAe,KAAK;IACvC;AACJ&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">2830</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/value/use-will-change/is.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { isMotionValue } from 'motion-dom';</span><span class="s3">\n\n</span><span class="s1">function isWillChangeMotionValue(value) {</span><span class="s3">\n    </span><span class="s1">return Boolean(isMotionValue(value) &amp;&amp; value.add);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { isWillChangeMotionValue };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;;AAEA,SAAS,wBAAwB,KAAK;IAClC,OAAO,QAAQ,IAAA,2MAAa,EAAC,UAAU,MAAM,GAAG;AACpD&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">2844</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/value/use-will-change/add-will-change.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { MotionGlobalConfig } from 'motion-utils';</span><span class="s3">\n</span><span class="s1">import { isWillChangeMotionValue } from './is.mjs';</span><span class="s3">\n\n</span><span class="s1">function addValueToWillChange(visualElement, key) {</span><span class="s3">\n    </span><span class="s1">const willChange = visualElement.getValue(</span><span class="s3">\&quot;</span><span class="s1">willChange</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* It could be that a user has set willChange to a regular MotionValue,</span><span class="s3">\n     </span><span class="s1">* in which case we can't add the value to it.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">if (isWillChangeMotionValue(willChange)) {</span><span class="s3">\n        </span><span class="s1">return willChange.add(key);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (!willChange &amp;&amp; MotionGlobalConfig.WillChange) {</span><span class="s3">\n        </span><span class="s1">const newWillChange = new MotionGlobalConfig.WillChange(</span><span class="s3">\&quot;</span><span class="s1">auto</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">visualElement.addValue(</span><span class="s3">\&quot;</span><span class="s1">willChange</span><span class="s3">\&quot;</span><span class="s1">, newWillChange);</span><span class="s3">\n        </span><span class="s1">newWillChange.add(key);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { addValueToWillChange };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;AACA;;;AAEA,SAAS,qBAAqB,aAAa,EAAE,GAAG;IAC5C,MAAM,aAAa,cAAc,QAAQ,CAAC;IAC1C;;;KAGC,GACD,IAAI,IAAA,qNAAuB,EAAC,aAAa;QACrC,OAAO,WAAW,GAAG,CAAC;IAC1B,OACK,IAAI,CAAC,cAAc,2LAAkB,CAAC,UAAU,EAAE;QACnD,MAAM,gBAAgB,IAAI,2LAAkB,CAAC,UAAU,CAAC;QACxD,cAAc,QAAQ,CAAC,cAAc;QACrC,cAAc,GAAG,CAAC;IACtB;AACJ&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">2870</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/animation/optimized-appear/get-appear-id.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { optimizedAppearDataAttribute } from './data-id.mjs';</span><span class="s3">\n\n</span><span class="s1">function getOptimisedAppearId(visualElement) {</span><span class="s3">\n    </span><span class="s1">return visualElement.props[optimizedAppearDataAttribute];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { getOptimisedAppearId };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;;AAEA,SAAS,qBAAqB,aAAa;IACvC,OAAO,cAAc,KAAK,CAAC,oOAA4B,CAAC;AAC5D&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">2884</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/animation/animators/waapi/utils/get-final-keyframe.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;const isNotNull = (value) =&gt; value !== null;</span><span class="s3">\n</span><span class="s1">function getFinalKeyframe(keyframes, { repeat, repeatType = </span><span class="s3">\&quot;</span><span class="s1">loop</span><span class="s3">\&quot; </span><span class="s1">}, finalKeyframe) {</span><span class="s3">\n    </span><span class="s1">const resolvedKeyframes = keyframes.filter(isNotNull);</span><span class="s3">\n    </span><span class="s1">const index = repeat &amp;&amp; repeatType !== </span><span class="s3">\&quot;</span><span class="s1">loop</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; repeat % 2 === 1</span><span class="s3">\n        </span><span class="s1">? 0</span><span class="s3">\n        </span><span class="s1">: resolvedKeyframes.length - 1;</span><span class="s3">\n    </span><span class="s1">return !index || finalKeyframe === undefined</span><span class="s3">\n        </span><span class="s1">? resolvedKeyframes[index]</span><span class="s3">\n        </span><span class="s1">: finalKeyframe;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { getFinalKeyframe };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA,MAAM,YAAY,CAAC,QAAU,UAAU;AACvC,SAAS,iBAAiB,SAAS,EAAE,KAA+B,EAAE,aAAa;QAA9C,EAAE,MAAM,EAAE,aAAa,MAAM,EAAE,GAA/B;IACjC,MAAM,oBAAoB,UAAU,MAAM,CAAC;IAC3C,MAAM,QAAQ,UAAU,eAAe,UAAU,SAAS,MAAM,IAC1D,IACA,kBAAkB,MAAM,GAAG;IACjC,OAAO,CAAC,SAAS,kBAAkB,YAC7B,iBAAiB,CAAC,MAAM,GACxB;AACV&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">2900</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/animation/utils/default-transitions.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { transformProps } from 'motion-dom';</span><span class="s3">\n\n</span><span class="s1">const underDampedSpring = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">spring</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">stiffness: 500,</span><span class="s3">\n    </span><span class="s1">damping: 25,</span><span class="s3">\n    </span><span class="s1">restSpeed: 10,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const criticallyDampedSpring = (target) =&gt; ({</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">spring</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">stiffness: 550,</span><span class="s3">\n    </span><span class="s1">damping: target === 0 ? 2 * Math.sqrt(550) : 30,</span><span class="s3">\n    </span><span class="s1">restSpeed: 10,</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">const keyframesTransition = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">keyframes</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">duration: 0.8,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Default easing curve is a slightly shallower version of</span><span class="s3">\n </span><span class="s1">* the default browser easing curve.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const ease = {</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">keyframes</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">ease: [0.25, 0.1, 0.35, 1],</span><span class="s3">\n    </span><span class="s1">duration: 0.3,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const getDefaultTransition = (valueKey, { keyframes }) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (keyframes.length &gt; 2) {</span><span class="s3">\n        </span><span class="s1">return keyframesTransition;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (transformProps.has(valueKey)) {</span><span class="s3">\n        </span><span class="s1">return valueKey.startsWith(</span><span class="s3">\&quot;</span><span class="s1">scale</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">? criticallyDampedSpring(keyframes[1])</span><span class="s3">\n            </span><span class="s1">: underDampedSpring;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return ease;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export { getDefaultTransition };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;;AAEA,MAAM,oBAAoB;IACtB,MAAM;IACN,WAAW;IACX,SAAS;IACT,WAAW;AACf;AACA,MAAM,yBAAyB,CAAC,SAAW,CAAC;QACxC,MAAM;QACN,WAAW;QACX,SAAS,WAAW,IAAI,IAAI,KAAK,IAAI,CAAC,OAAO;QAC7C,WAAW;IACf,CAAC;AACD,MAAM,sBAAsB;IACxB,MAAM;IACN,UAAU;AACd;AACA;;;CAGC,GACD,MAAM,OAAO;IACT,MAAM;IACN,MAAM;QAAC;QAAM;QAAK;QAAM;KAAE;IAC1B,UAAU;AACd;AACA,MAAM,uBAAuB,CAAC;QAAU,EAAE,SAAS,EAAE;IACjD,IAAI,UAAU,MAAM,GAAG,GAAG;QACtB,OAAO;IACX,OACK,IAAI,yMAAc,CAAC,GAAG,CAAC,WAAW;QACnC,OAAO,SAAS,UAAU,CAAC,WACrB,uBAAuB,SAAS,CAAC,EAAE,IACnC;IACV;IACA,OAAO;AACX&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">2949</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/animation/utils/is-transition-defined.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Decide whether a transition is defined on a given Transition.</span><span class="s3">\n </span><span class="s1">* This filters out orchestration options and returns true</span><span class="s3">\n </span><span class="s1">* if any options are left.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {</span><span class="s3">\n    </span><span class="s1">return !!Object.keys(transition).length;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { isTransitionDefined };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAA;;;;CAIC;;;;AACD,SAAS,oBAAoB,KAAwI;QAAxI,EAAE,IAAI,EAAE,OAAO,MAAM,EAAE,aAAa,EAAE,eAAe,EAAE,gBAAgB,EAAE,MAAM,EAAE,UAAU,EAAE,WAAW,EAAE,IAAI,EAAE,OAAO,EAAE,GAAG,YAAY,GAAxI;IACzB,OAAO,CAAC,CAAC,OAAO,IAAI,CAAC,YAAY,MAAM;AAC3C&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">2966</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/animation/interfaces/motion-value.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { getValueTransition, makeAnimationInstant, frame, JSAnimation, AsyncMotionValueAnimation } from 'motion-dom';</span><span class="s3">\n</span><span class="s1">import { secondsToMilliseconds, MotionGlobalConfig } from 'motion-utils';</span><span class="s3">\n</span><span class="s1">import { getFinalKeyframe } from '../animators/waapi/utils/get-final-keyframe.mjs';</span><span class="s3">\n</span><span class="s1">import { getDefaultTransition } from '../utils/default-transitions.mjs';</span><span class="s3">\n</span><span class="s1">import { isTransitionDefined } from '../utils/is-transition-defined.mjs';</span><span class="s3">\n\n</span><span class="s1">const animateMotionValue = (name, value, target, transition = {}, element, isHandoff) =&gt; (onComplete) =&gt; {</span><span class="s3">\n    </span><span class="s1">const valueTransition = getValueTransition(transition, name) || {};</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Most transition values are currently completely overwritten by value-specific</span><span class="s3">\n     </span><span class="s1">* transitions. In the future it'd be nicer to blend these transitions. But for now</span><span class="s3">\n     </span><span class="s1">* delay actually does inherit from the root transition if not value-specific.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">const delay = valueTransition.delay || transition.delay || 0;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Elapsed isn't a public transition option but can be passed through from</span><span class="s3">\n     </span><span class="s1">* optimized appear effects in milliseconds.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">let { elapsed = 0 } = transition;</span><span class="s3">\n    </span><span class="s1">elapsed = elapsed - secondsToMilliseconds(delay);</span><span class="s3">\n    </span><span class="s1">const options = {</span><span class="s3">\n        </span><span class="s1">keyframes: Array.isArray(target) ? target : [null, target],</span><span class="s3">\n        </span><span class="s1">ease: </span><span class="s3">\&quot;</span><span class="s1">easeOut</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">velocity: value.getVelocity(),</span><span class="s3">\n        </span><span class="s1">...valueTransition,</span><span class="s3">\n        </span><span class="s1">delay: -elapsed,</span><span class="s3">\n        </span><span class="s1">onUpdate: (v) =&gt; {</span><span class="s3">\n            </span><span class="s1">value.set(v);</span><span class="s3">\n            </span><span class="s1">valueTransition.onUpdate &amp;&amp; valueTransition.onUpdate(v);</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">onComplete: () =&gt; {</span><span class="s3">\n            </span><span class="s1">onComplete();</span><span class="s3">\n            </span><span class="s1">valueTransition.onComplete &amp;&amp; valueTransition.onComplete();</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">name,</span><span class="s3">\n        </span><span class="s1">motionValue: value,</span><span class="s3">\n        </span><span class="s1">element: isHandoff ? undefined : element,</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* If there's no transition defined for this value, we can generate</span><span class="s3">\n     </span><span class="s1">* unique transition settings for this value.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">if (!isTransitionDefined(valueTransition)) {</span><span class="s3">\n        </span><span class="s1">Object.assign(options, getDefaultTransition(name, options));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Both WAAPI and our internal animation functions use durations</span><span class="s3">\n     </span><span class="s1">* as defined by milliseconds, while our external API defines them</span><span class="s3">\n     </span><span class="s1">* as seconds.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">options.duration &amp;&amp; (options.duration = secondsToMilliseconds(options.duration));</span><span class="s3">\n    </span><span class="s1">options.repeatDelay &amp;&amp; (options.repeatDelay = secondsToMilliseconds(options.repeatDelay));</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Support deprecated way to set initial value. Prefer keyframe syntax.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">if (options.from !== undefined) {</span><span class="s3">\n        </span><span class="s1">options.keyframes[0] = options.from;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let shouldSkip = false;</span><span class="s3">\n    </span><span class="s1">if (options.type === false ||</span><span class="s3">\n        </span><span class="s1">(options.duration === 0 &amp;&amp; !options.repeatDelay)) {</span><span class="s3">\n        </span><span class="s1">makeAnimationInstant(options);</span><span class="s3">\n        </span><span class="s1">if (options.delay === 0) {</span><span class="s3">\n            </span><span class="s1">shouldSkip = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (MotionGlobalConfig.instantAnimations ||</span><span class="s3">\n        </span><span class="s1">MotionGlobalConfig.skipAnimations) {</span><span class="s3">\n        </span><span class="s1">shouldSkip = true;</span><span class="s3">\n        </span><span class="s1">makeAnimationInstant(options);</span><span class="s3">\n        </span><span class="s1">options.delay = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* If the transition type or easing has been explicitly set by the user</span><span class="s3">\n     </span><span class="s1">* then we don't want to allow flattening the animation.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">options.allowFlatten = !valueTransition.type &amp;&amp; !valueTransition.ease;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* If we can or must skip creating the animation, and apply only</span><span class="s3">\n     </span><span class="s1">* the final keyframe, do so. We also check once keyframes are resolved but</span><span class="s3">\n     </span><span class="s1">* this early check prevents the need to create an animation at all.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">if (shouldSkip &amp;&amp; !isHandoff &amp;&amp; value.get() !== undefined) {</span><span class="s3">\n        </span><span class="s1">const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);</span><span class="s3">\n        </span><span class="s1">if (finalKeyframe !== undefined) {</span><span class="s3">\n            </span><span class="s1">frame.update(() =&gt; {</span><span class="s3">\n                </span><span class="s1">options.onUpdate(finalKeyframe);</span><span class="s3">\n                </span><span class="s1">options.onComplete();</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return valueTransition.isSync</span><span class="s3">\n        </span><span class="s1">? new JSAnimation(options)</span><span class="s3">\n        </span><span class="s1">: new AsyncMotionValueAnimation(options);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export { animateMotionValue };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;;;;;;AAEA,MAAM,qBAAqB,SAAC,MAAM,OAAO;QAAQ,8EAAa,CAAC,GAAG,wDAAS;WAAc,CAAC;QACtF,MAAM,kBAAkB,IAAA,yNAAkB,EAAC,YAAY,SAAS,CAAC;QACjE;;;;KAIC,GACD,MAAM,QAAQ,gBAAgB,KAAK,IAAI,WAAW,KAAK,IAAI;QAC3D;;;KAGC,GACD,IAAI,EAAE,UAAU,CAAC,EAAE,GAAG;QACtB,UAAU,UAAU,IAAA,gMAAqB,EAAC;QAC1C,MAAM,UAAU;YACZ,WAAW,MAAM,OAAO,CAAC,UAAU,SAAS;gBAAC;gBAAM;aAAO;YAC1D,MAAM;YACN,UAAU,MAAM,WAAW;YAC3B,GAAG,eAAe;YAClB,OAAO,CAAC;YACR,UAAU,CAAC;gBACP,MAAM,GAAG,CAAC;gBACV,gBAAgB,QAAQ,IAAI,gBAAgB,QAAQ,CAAC;YACzD;YACA,YAAY;gBACR;gBACA,gBAAgB,UAAU,IAAI,gBAAgB,UAAU;YAC5D;YACA;YACA,aAAa;YACb,SAAS,YAAY,YAAY;QACrC;QACA;;;KAGC,GACD,IAAI,CAAC,IAAA,8NAAmB,EAAC,kBAAkB;YACvC,OAAO,MAAM,CAAC,SAAS,IAAA,0NAAoB,EAAC,MAAM;QACtD;QACA;;;;KAIC,GACD,QAAQ,QAAQ,IAAI,CAAC,QAAQ,QAAQ,GAAG,IAAA,gMAAqB,EAAC,QAAQ,QAAQ,CAAC;QAC/E,QAAQ,WAAW,IAAI,CAAC,QAAQ,WAAW,GAAG,IAAA,gMAAqB,EAAC,QAAQ,WAAW,CAAC;QACxF;;KAEC,GACD,IAAI,QAAQ,IAAI,KAAK,WAAW;YAC5B,QAAQ,SAAS,CAAC,EAAE,GAAG,QAAQ,IAAI;QACvC;QACA,IAAI,aAAa;QACjB,IAAI,QAAQ,IAAI,KAAK,SAChB,QAAQ,QAAQ,KAAK,KAAK,CAAC,QAAQ,WAAW,EAAG;YAClD,IAAA,6NAAoB,EAAC;YACrB,IAAI,QAAQ,KAAK,KAAK,GAAG;gBACrB,aAAa;YACjB;QACJ;QACA,IAAI,2LAAkB,CAAC,iBAAiB,IACpC,2LAAkB,CAAC,cAAc,EAAE;YACnC,aAAa;YACb,IAAA,6NAAoB,EAAC;YACrB,QAAQ,KAAK,GAAG;QACpB;QACA;;;KAGC,GACD,QAAQ,YAAY,GAAG,CAAC,gBAAgB,IAAI,IAAI,CAAC,gBAAgB,IAAI;QACrE;;;;KAIC,GACD,IAAI,cAAc,CAAC,aAAa,MAAM,GAAG,OAAO,WAAW;YACvD,MAAM,gBAAgB,IAAA,8OAAgB,EAAC,QAAQ,SAAS,EAAE;YAC1D,IAAI,kBAAkB,WAAW;gBAC7B,8KAAK,CAAC,MAAM,CAAC;oBACT,QAAQ,QAAQ,CAAC;oBACjB,QAAQ,UAAU;gBACtB;gBACA;YACJ;QACJ;QACA,OAAO,gBAAgB,MAAM,GACvB,IAAI,0LAAW,CAAC,WAChB,IAAI,sNAAyB,CAAC;IACxC&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">3075</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/animation/interfaces/visual-element-target.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { getValueTransition, frame, positionalKeys } from 'motion-dom';</span><span class="s3">\n</span><span class="s1">import { setTarget } from '../../render/utils/setters.mjs';</span><span class="s3">\n</span><span class="s1">import { addValueToWillChange } from '../../value/use-will-change/add-will-change.mjs';</span><span class="s3">\n</span><span class="s1">import { getOptimisedAppearId } from '../optimized-appear/get-appear-id.mjs';</span><span class="s3">\n</span><span class="s1">import { animateMotionValue } from './motion-value.mjs';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Decide whether we should block this animation. Previously, we achieved this</span><span class="s3">\n </span><span class="s1">* just by checking whether the key was listed in protectedKeys, but this</span><span class="s3">\n </span><span class="s1">* posed problems if an animation was triggered by afterChildren and protectedKeys</span><span class="s3">\n </span><span class="s1">* had been set to true in the meantime.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {</span><span class="s3">\n    </span><span class="s1">const shouldBlock = protectedKeys.hasOwnProperty(key) &amp;&amp; needsAnimating[key] !== true;</span><span class="s3">\n    </span><span class="s1">needsAnimating[key] = false;</span><span class="s3">\n    </span><span class="s1">return shouldBlock;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function animateTarget(visualElement, targetAndTransition, { delay = 0, transitionOverride, type } = {}) {</span><span class="s3">\n    </span><span class="s1">let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;</span><span class="s3">\n    </span><span class="s1">if (transitionOverride)</span><span class="s3">\n        </span><span class="s1">transition = transitionOverride;</span><span class="s3">\n    </span><span class="s1">const animations = [];</span><span class="s3">\n    </span><span class="s1">const animationTypeState = type &amp;&amp;</span><span class="s3">\n        </span><span class="s1">visualElement.animationState &amp;&amp;</span><span class="s3">\n        </span><span class="s1">visualElement.animationState.getState()[type];</span><span class="s3">\n    </span><span class="s1">for (const key in target) {</span><span class="s3">\n        </span><span class="s1">const value = visualElement.getValue(key, visualElement.latestValues[key] ?? null);</span><span class="s3">\n        </span><span class="s1">const valueTarget = target[key];</span><span class="s3">\n        </span><span class="s1">if (valueTarget === undefined ||</span><span class="s3">\n            </span><span class="s1">(animationTypeState &amp;&amp;</span><span class="s3">\n                </span><span class="s1">shouldBlockAnimation(animationTypeState, key))) {</span><span class="s3">\n            </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const valueTransition = {</span><span class="s3">\n            </span><span class="s1">delay,</span><span class="s3">\n            </span><span class="s1">...getValueTransition(transition || {}, key),</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* If the value is already at the defined target, skip the animation.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">const currentValue = value.get();</span><span class="s3">\n        </span><span class="s1">if (currentValue !== undefined &amp;&amp;</span><span class="s3">\n            </span><span class="s1">!value.isAnimating &amp;&amp;</span><span class="s3">\n            </span><span class="s1">!Array.isArray(valueTarget) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">valueTarget === currentValue &amp;&amp;</span><span class="s3">\n            </span><span class="s1">!valueTransition.velocity) {</span><span class="s3">\n            </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* If this is the first time a value is being animated, check</span><span class="s3">\n         </span><span class="s1">* to see if we're handling off from an existing animation.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">let isHandoff = false;</span><span class="s3">\n        </span><span class="s1">if (window.MotionHandoffAnimation) {</span><span class="s3">\n            </span><span class="s1">const appearId = getOptimisedAppearId(visualElement);</span><span class="s3">\n            </span><span class="s1">if (appearId) {</span><span class="s3">\n                </span><span class="s1">const startTime = window.MotionHandoffAnimation(appearId, key, frame);</span><span class="s3">\n                </span><span class="s1">if (startTime !== null) {</span><span class="s3">\n                    </span><span class="s1">valueTransition.startTime = startTime;</span><span class="s3">\n                    </span><span class="s1">isHandoff = true;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">addValueToWillChange(visualElement, key);</span><span class="s3">\n        </span><span class="s1">value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion &amp;&amp; positionalKeys.has(key)</span><span class="s3">\n            </span><span class="s1">? { type: false }</span><span class="s3">\n            </span><span class="s1">: valueTransition, visualElement, isHandoff));</span><span class="s3">\n        </span><span class="s1">const animation = value.animation;</span><span class="s3">\n        </span><span class="s1">if (animation) {</span><span class="s3">\n            </span><span class="s1">animations.push(animation);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (transitionEnd) {</span><span class="s3">\n        </span><span class="s1">Promise.all(animations).then(() =&gt; {</span><span class="s3">\n            </span><span class="s1">frame.update(() =&gt; {</span><span class="s3">\n                </span><span class="s1">transitionEnd &amp;&amp; setTarget(visualElement, transitionEnd);</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return animations;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { animateTarget };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;AAEA;;;;;CAKC,GACD,SAAS,qBAAqB,KAAiC,EAAE,GAAG;QAAtC,EAAE,aAAa,EAAE,cAAc,EAAE,GAAjC;IAC1B,MAAM,cAAc,cAAc,cAAc,CAAC,QAAQ,cAAc,CAAC,IAAI,KAAK;IACjF,cAAc,CAAC,IAAI,GAAG;IACtB,OAAO;AACX;AACA,SAAS,cAAc,aAAa,EAAE,mBAAmB;QAAE,EAAE,QAAQ,CAAC,EAAE,kBAAkB,EAAE,IAAI,EAAE,GAAvC,iEAA0C,CAAC;IAClG,IAAI,EAAE,aAAa,cAAc,oBAAoB,EAAE,EAAE,aAAa,EAAE,GAAG,QAAQ,GAAG;IACtF,IAAI,oBACA,aAAa;IACjB,MAAM,aAAa,EAAE;IACrB,MAAM,qBAAqB,QACvB,cAAc,cAAc,IAC5B,cAAc,cAAc,CAAC,QAAQ,EAAE,CAAC,KAAK;IACjD,IAAK,MAAM,OAAO,OAAQ;YACoB;QAA1C,MAAM,QAAQ,cAAc,QAAQ,CAAC,KAAK,CAAA,kCAAA,cAAc,YAAY,CAAC,IAAI,cAA/B,6CAAA,kCAAmC;QAC7E,MAAM,cAAc,MAAM,CAAC,IAAI;QAC/B,IAAI,gBAAgB,aACf,sBACG,qBAAqB,oBAAoB,MAAO;YACpD;QACJ;QACA,MAAM,kBAAkB;YACpB;YACA,GAAG,IAAA,yNAAkB,EAAC,cAAc,CAAC,GAAG,IAAI;QAChD;QACA;;SAEC,GACD,MAAM,eAAe,MAAM,GAAG;QAC9B,IAAI,iBAAiB,aACjB,CAAC,MAAM,WAAW,IAClB,CAAC,MAAM,OAAO,CAAC,gBACf,gBAAgB,gBAChB,CAAC,gBAAgB,QAAQ,EAAE;YAC3B;QACJ;QACA;;;SAGC,GACD,IAAI,YAAY;QAChB,IAAI,OAAO,sBAAsB,EAAE;YAC/B,MAAM,WAAW,IAAA,qOAAoB,EAAC;YACtC,IAAI,UAAU;gBACV,MAAM,YAAY,OAAO,sBAAsB,CAAC,UAAU,KAAK,8KAAK;gBACpE,IAAI,cAAc,MAAM;oBACpB,gBAAgB,SAAS,GAAG;oBAC5B,YAAY;gBAChB;YACJ;QACJ;QACA,IAAA,qOAAoB,EAAC,eAAe;QACpC,MAAM,KAAK,CAAC,IAAA,sNAAkB,EAAC,KAAK,OAAO,aAAa,cAAc,kBAAkB,IAAI,wMAAc,CAAC,GAAG,CAAC,OACzG;YAAE,MAAM;QAAM,IACd,iBAAiB,eAAe;QACtC,MAAM,YAAY,MAAM,SAAS;QACjC,IAAI,WAAW;YACX,WAAW,IAAI,CAAC;QACpB;IACJ;IACA,IAAI,eAAe;QACf,QAAQ,GAAG,CAAC,YAAY,IAAI,CAAC;YACzB,8KAAK,CAAC,MAAM,CAAC;gBACT,iBAAiB,IAAA,6LAAS,EAAC,eAAe;YAC9C;QACJ;IACJ;IACA,OAAO;AACX&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">3162</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/animation/utils/calc-child-stagger.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;function calcChildStagger(children, child, delayChildren, staggerChildren = 0, staggerDirection = 1) {</span><span class="s3">\n    </span><span class="s1">const index = Array.from(children)</span><span class="s3">\n        </span><span class="s1">.sort((a, b) =&gt; a.sortNodePosition(b))</span><span class="s3">\n        </span><span class="s1">.indexOf(child);</span><span class="s3">\n    </span><span class="s1">const numChildren = children.size;</span><span class="s3">\n    </span><span class="s1">const maxStaggerDuration = (numChildren - 1) * staggerChildren;</span><span class="s3">\n    </span><span class="s1">const delayIsFunction = typeof delayChildren === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">return delayIsFunction</span><span class="s3">\n        </span><span class="s1">? delayChildren(index, numChildren)</span><span class="s3">\n        </span><span class="s1">: staggerDirection === 1</span><span class="s3">\n            </span><span class="s1">? index * staggerChildren</span><span class="s3">\n            </span><span class="s1">: maxStaggerDuration - index * staggerChildren;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { calcChildStagger };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA,SAAS,iBAAiB,QAAQ,EAAE,KAAK,EAAE,aAAa;QAAE,kBAAA,iEAAkB,GAAG,mBAAA,iEAAmB;IAC9F,MAAM,QAAQ,MAAM,IAAI,CAAC,UACpB,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,gBAAgB,CAAC,IAClC,OAAO,CAAC;IACb,MAAM,cAAc,SAAS,IAAI;IACjC,MAAM,qBAAqB,CAAC,cAAc,CAAC,IAAI;IAC/C,MAAM,kBAAkB,OAAO,kBAAkB;IACjD,OAAO,kBACD,cAAc,OAAO,eACrB,qBAAqB,IACjB,QAAQ,kBACR,qBAAqB,QAAQ;AAC3C&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">3179</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/animation/interfaces/visual-element-variant.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { resolveVariant } from '../../render/utils/resolve-dynamic-variants.mjs';</span><span class="s3">\n</span><span class="s1">import { calcChildStagger } from '../utils/calc-child-stagger.mjs';</span><span class="s3">\n</span><span class="s1">import { animateTarget } from './visual-element-target.mjs';</span><span class="s3">\n\n</span><span class="s1">function animateVariant(visualElement, variant, options = {}) {</span><span class="s3">\n    </span><span class="s1">const resolved = resolveVariant(visualElement, variant, options.type === </span><span class="s3">\&quot;</span><span class="s1">exit</span><span class="s3">\&quot;\n        </span><span class="s1">? visualElement.presenceContext?.custom</span><span class="s3">\n        </span><span class="s1">: undefined);</span><span class="s3">\n    </span><span class="s1">let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};</span><span class="s3">\n    </span><span class="s1">if (options.transitionOverride) {</span><span class="s3">\n        </span><span class="s1">transition = options.transitionOverride;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* If we have a variant, create a callback that runs it as an animation.</span><span class="s3">\n     </span><span class="s1">* Otherwise, we resolve a Promise immediately for a composable no-op.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">const getAnimation = resolved</span><span class="s3">\n        </span><span class="s1">? () =&gt; Promise.all(animateTarget(visualElement, resolved, options))</span><span class="s3">\n        </span><span class="s1">: () =&gt; Promise.resolve();</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* If we have children, create a callback that runs all their animations.</span><span class="s3">\n     </span><span class="s1">* Otherwise, we resolve a Promise immediately for a composable no-op.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">const getChildAnimations = visualElement.variantChildren &amp;&amp; visualElement.variantChildren.size</span><span class="s3">\n        </span><span class="s1">? (forwardDelay = 0) =&gt; {</span><span class="s3">\n            </span><span class="s1">const { delayChildren = 0, staggerChildren, staggerDirection, } = transition;</span><span class="s3">\n            </span><span class="s1">return animateChildren(visualElement, variant, forwardDelay, delayChildren, staggerChildren, staggerDirection, options);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">: () =&gt; Promise.resolve();</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* If the transition explicitly defines a </span><span class="s3">\&quot;</span><span class="s1">when</span><span class="s3">\&quot; </span><span class="s1">option, we need to resolve either</span><span class="s3">\n     </span><span class="s1">* this animation or all children animations before playing the other.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">const { when } = transition;</span><span class="s3">\n    </span><span class="s1">if (when) {</span><span class="s3">\n        </span><span class="s1">const [first, last] = when === </span><span class="s3">\&quot;</span><span class="s1">beforeChildren</span><span class="s3">\&quot;\n            </span><span class="s1">? [getAnimation, getChildAnimations]</span><span class="s3">\n            </span><span class="s1">: [getChildAnimations, getAnimation];</span><span class="s3">\n        </span><span class="s1">return first().then(() =&gt; last());</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">return Promise.all([getAnimation(), getChildAnimations(options.delay)]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function animateChildren(visualElement, variant, delay = 0, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {</span><span class="s3">\n    </span><span class="s1">const animations = [];</span><span class="s3">\n    </span><span class="s1">for (const child of visualElement.variantChildren) {</span><span class="s3">\n        </span><span class="s1">child.notify(</span><span class="s3">\&quot;</span><span class="s1">AnimationStart</span><span class="s3">\&quot;</span><span class="s1">, variant);</span><span class="s3">\n        </span><span class="s1">animations.push(animateVariant(child, variant, {</span><span class="s3">\n            </span><span class="s1">...options,</span><span class="s3">\n            </span><span class="s1">delay: delay +</span><span class="s3">\n                </span><span class="s1">(typeof delayChildren === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">? 0 : delayChildren) +</span><span class="s3">\n                </span><span class="s1">calcChildStagger(visualElement.variantChildren, child, delayChildren, staggerChildren, staggerDirection),</span><span class="s3">\n        </span><span class="s1">}).then(() =&gt; child.notify(</span><span class="s3">\&quot;</span><span class="s1">AnimationComplete</span><span class="s3">\&quot;</span><span class="s1">, variant)));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return Promise.all(animations);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { animateVariant };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;AACA;AACA;;;;AAEA,SAAS,eAAe,aAAa,EAAE,OAAO;QAAE,UAAA,iEAAU,CAAC;QAEjD;IADN,MAAM,WAAW,IAAA,yNAAc,EAAC,eAAe,SAAS,QAAQ,IAAI,KAAK,UACnE,iCAAA,cAAc,eAAe,cAA7B,qDAAA,+BAA+B,MAAM,GACrC;IACN,IAAI,EAAE,aAAa,cAAc,oBAAoB,MAAM,CAAC,CAAC,EAAE,GAAG,YAAY,CAAC;IAC/E,IAAI,QAAQ,kBAAkB,EAAE;QAC5B,aAAa,QAAQ,kBAAkB;IAC3C;IACA;;;KAGC,GACD,MAAM,eAAe,WACf,IAAM,QAAQ,GAAG,CAAC,IAAA,6NAAa,EAAC,eAAe,UAAU,YACzD,IAAM,QAAQ,OAAO;IAC3B;;;KAGC,GACD,MAAM,qBAAqB,cAAc,eAAe,IAAI,cAAc,eAAe,CAAC,IAAI,GACxF;YAAC,gFAAe;QACd,MAAM,EAAE,gBAAgB,CAAC,EAAE,eAAe,EAAE,gBAAgB,EAAG,GAAG;QAClE,OAAO,gBAAgB,eAAe,SAAS,cAAc,eAAe,iBAAiB,kBAAkB;IACnH,IACE,IAAM,QAAQ,OAAO;IAC3B;;;KAGC,GACD,MAAM,EAAE,IAAI,EAAE,GAAG;IACjB,IAAI,MAAM;QACN,MAAM,CAAC,OAAO,KAAK,GAAG,SAAS,mBACzB;YAAC;YAAc;SAAmB,GAClC;YAAC;YAAoB;SAAa;QACxC,OAAO,QAAQ,IAAI,CAAC,IAAM;IAC9B,OACK;QACD,OAAO,QAAQ,GAAG,CAAC;YAAC;YAAgB,mBAAmB,QAAQ,KAAK;SAAE;IAC1E;AACJ;AACA,SAAS,gBAAgB,aAAa,EAAE,OAAO;QAAE,QAAA,iEAAQ,GAAG,gBAAA,iEAAgB,GAAG,kBAAA,iEAAkB,GAAG,mBAAA,iEAAmB,GAAG;IACtH,MAAM,aAAa,EAAE;IACrB,KAAK,MAAM,SAAS,cAAc,eAAe,CAAE;QAC/C,MAAM,MAAM,CAAC,kBAAkB;QAC/B,WAAW,IAAI,CAAC,eAAe,OAAO,SAAS;YAC3C,GAAG,OAAO;YACV,OAAO,QACH,CAAC,OAAO,kBAAkB,aAAa,IAAI,aAAa,IACxD,IAAA,wNAAgB,EAAC,cAAc,eAAe,EAAE,OAAO,eAAe,iBAAiB;QAC/F,GAAG,IAAI,CAAC,IAAM,MAAM,MAAM,CAAC,qBAAqB;IACpD;IACA,OAAO,QAAQ,GAAG,CAAC;AACvB&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">3246</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/animation/interfaces/visual-element.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { resolveVariant } from '../../render/utils/resolve-dynamic-variants.mjs';</span><span class="s3">\n</span><span class="s1">import { animateTarget } from './visual-element-target.mjs';</span><span class="s3">\n</span><span class="s1">import { animateVariant } from './visual-element-variant.mjs';</span><span class="s3">\n\n</span><span class="s1">function animateVisualElement(visualElement, definition, options = {}) {</span><span class="s3">\n    </span><span class="s1">visualElement.notify(</span><span class="s3">\&quot;</span><span class="s1">AnimationStart</span><span class="s3">\&quot;</span><span class="s1">, definition);</span><span class="s3">\n    </span><span class="s1">let animation;</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(definition)) {</span><span class="s3">\n        </span><span class="s1">const animations = definition.map((variant) =&gt; animateVariant(visualElement, variant, options));</span><span class="s3">\n        </span><span class="s1">animation = Promise.all(animations);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (typeof definition === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">animation = animateVariant(visualElement, definition, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">const resolvedDefinition = typeof definition === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;\n            </span><span class="s1">? resolveVariant(visualElement, definition, options.custom)</span><span class="s3">\n            </span><span class="s1">: definition;</span><span class="s3">\n        </span><span class="s1">animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return animation.then(() =&gt; {</span><span class="s3">\n        </span><span class="s1">visualElement.notify(</span><span class="s3">\&quot;</span><span class="s1">AnimationComplete</span><span class="s3">\&quot;</span><span class="s1">, definition);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { animateVisualElement };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;AACA;AACA;;;;AAEA,SAAS,qBAAqB,aAAa,EAAE,UAAU;QAAE,UAAA,iEAAU,CAAC;IAChE,cAAc,MAAM,CAAC,kBAAkB;IACvC,IAAI;IACJ,IAAI,MAAM,OAAO,CAAC,aAAa;QAC3B,MAAM,aAAa,WAAW,GAAG,CAAC,CAAC,UAAY,IAAA,+NAAc,EAAC,eAAe,SAAS;QACtF,YAAY,QAAQ,GAAG,CAAC;IAC5B,OACK,IAAI,OAAO,eAAe,UAAU;QACrC,YAAY,IAAA,+NAAc,EAAC,eAAe,YAAY;IAC1D,OACK;QACD,MAAM,qBAAqB,OAAO,eAAe,aAC3C,IAAA,yNAAc,EAAC,eAAe,YAAY,QAAQ,MAAM,IACxD;QACN,YAAY,QAAQ,GAAG,CAAC,IAAA,6NAAa,EAAC,eAAe,oBAAoB;IAC7E;IACA,OAAO,UAAU,IAAI,CAAC;QAClB,cAAc,MAAM,CAAC,qBAAqB;IAC9C;AACJ&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">3278</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/utils/shallow-compare.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;function shallowCompare(next, prev) {</span><span class="s3">\n    </span><span class="s1">if (!Array.isArray(prev))</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">const prevLength = prev.length;</span><span class="s3">\n    </span><span class="s1">if (prevLength !== next.length)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; prevLength; i++) {</span><span class="s3">\n        </span><span class="s1">if (prev[i] !== next[i])</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { shallowCompare };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA,SAAS,eAAe,IAAI,EAAE,IAAI;IAC9B,IAAI,CAAC,MAAM,OAAO,CAAC,OACf,OAAO;IACX,MAAM,aAAa,KAAK,MAAM;IAC9B,IAAI,eAAe,KAAK,MAAM,EAC1B,OAAO;IACX,IAAK,IAAI,IAAI,GAAG,IAAI,YAAY,IAAK;QACjC,IAAI,IAAI,CAAC,EAAE,KAAK,IAAI,CAAC,EAAE,EACnB,OAAO;IACf;IACA,OAAO;AACX&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">3296</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/render/utils/get-variant-context.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { isVariantLabel } from './is-variant-label.mjs';</span><span class="s3">\n</span><span class="s1">import { variantProps } from './variant-props.mjs';</span><span class="s3">\n\n</span><span class="s1">const numVariantProps = variantProps.length;</span><span class="s3">\n</span><span class="s1">function getVariantContext(visualElement) {</span><span class="s3">\n    </span><span class="s1">if (!visualElement)</span><span class="s3">\n        </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">if (!visualElement.isControllingVariants) {</span><span class="s3">\n        </span><span class="s1">const context = visualElement.parent</span><span class="s3">\n            </span><span class="s1">? getVariantContext(visualElement.parent) || {}</span><span class="s3">\n            </span><span class="s1">: {};</span><span class="s3">\n        </span><span class="s1">if (visualElement.props.initial !== undefined) {</span><span class="s3">\n            </span><span class="s1">context.initial = visualElement.props.initial;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return context;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const context = {};</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; numVariantProps; i++) {</span><span class="s3">\n        </span><span class="s1">const name = variantProps[i];</span><span class="s3">\n        </span><span class="s1">const prop = visualElement.props[name];</span><span class="s3">\n        </span><span class="s1">if (isVariantLabel(prop) || prop === false) {</span><span class="s3">\n            </span><span class="s1">context[name] = prop;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return context;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { getVariantContext };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;AACA;;;AAEA,MAAM,kBAAkB,yMAAY,CAAC,MAAM;AAC3C,SAAS,kBAAkB,aAAa;IACpC,IAAI,CAAC,eACD,OAAO;IACX,IAAI,CAAC,cAAc,qBAAqB,EAAE;QACtC,MAAM,UAAU,cAAc,MAAM,GAC9B,kBAAkB,cAAc,MAAM,KAAK,CAAC,IAC5C,CAAC;QACP,IAAI,cAAc,KAAK,CAAC,OAAO,KAAK,WAAW;YAC3C,QAAQ,OAAO,GAAG,cAAc,KAAK,CAAC,OAAO;QACjD;QACA,OAAO;IACX;IACA,MAAM,UAAU,CAAC;IACjB,IAAK,IAAI,IAAI,GAAG,IAAI,iBAAiB,IAAK;QACtC,MAAM,OAAO,yMAAY,CAAC,EAAE;QAC5B,MAAM,OAAO,cAAc,KAAK,CAAC,KAAK;QACtC,IAAI,IAAA,iNAAc,EAAC,SAAS,SAAS,OAAO;YACxC,OAAO,CAAC,KAAK,GAAG;QACpB;IACJ;IACA,OAAO;AACX&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">3329</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/render/utils/animation-state.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { animateVisualElement } from '../../animation/interfaces/visual-element.mjs';</span><span class="s3">\n</span><span class="s1">import { calcChildStagger } from '../../animation/utils/calc-child-stagger.mjs';</span><span class="s3">\n</span><span class="s1">import { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';</span><span class="s3">\n</span><span class="s1">import { isKeyframesTarget } from '../../animation/utils/is-keyframes-target.mjs';</span><span class="s3">\n</span><span class="s1">import { shallowCompare } from '../../utils/shallow-compare.mjs';</span><span class="s3">\n</span><span class="s1">import { getVariantContext } from './get-variant-context.mjs';</span><span class="s3">\n</span><span class="s1">import { isVariantLabel } from './is-variant-label.mjs';</span><span class="s3">\n</span><span class="s1">import { resolveVariant } from './resolve-dynamic-variants.mjs';</span><span class="s3">\n</span><span class="s1">import { variantPriorityOrder } from './variant-props.mjs';</span><span class="s3">\n\n</span><span class="s1">const reversePriorityOrder = [...variantPriorityOrder].reverse();</span><span class="s3">\n</span><span class="s1">const numAnimationTypes = variantPriorityOrder.length;</span><span class="s3">\n</span><span class="s1">function animateList(visualElement) {</span><span class="s3">\n    </span><span class="s1">return (animations) =&gt; Promise.all(animations.map(({ animation, options }) =&gt; animateVisualElement(visualElement, animation, options)));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function createAnimationState(visualElement) {</span><span class="s3">\n    </span><span class="s1">let animate = animateList(visualElement);</span><span class="s3">\n    </span><span class="s1">let state = createState();</span><span class="s3">\n    </span><span class="s1">let isInitialRender = true;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* This function will be used to reduce the animation definitions for</span><span class="s3">\n     </span><span class="s1">* each active animation type into an object of resolved values for it.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">const buildResolvedTypeValues = (type) =&gt; (acc, definition) =&gt; {</span><span class="s3">\n        </span><span class="s1">const resolved = resolveVariant(visualElement, definition, type === </span><span class="s3">\&quot;</span><span class="s1">exit</span><span class="s3">\&quot;\n            </span><span class="s1">? visualElement.presenceContext?.custom</span><span class="s3">\n            </span><span class="s1">: undefined);</span><span class="s3">\n        </span><span class="s1">if (resolved) {</span><span class="s3">\n            </span><span class="s1">const { transition, transitionEnd, ...target } = resolved;</span><span class="s3">\n            </span><span class="s1">acc = { ...acc, ...target, ...transitionEnd };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return acc;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* This just allows us to inject mocked animation functions</span><span class="s3">\n     </span><span class="s1">* @internal</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function setAnimateFunction(makeAnimator) {</span><span class="s3">\n        </span><span class="s1">animate = makeAnimator(visualElement);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* When we receive new props, we need to:</span><span class="s3">\n     </span><span class="s1">* 1. Create a list of protected keys for each type. This is a directory of</span><span class="s3">\n     </span><span class="s1">*    value keys that are currently being </span><span class="s3">\&quot;</span><span class="s1">handled</span><span class="s3">\&quot; </span><span class="s1">by types of a higher priority</span><span class="s3">\n     </span><span class="s1">*    so that whenever an animation is played of a given type, these values are</span><span class="s3">\n     </span><span class="s1">*    protected from being animated.</span><span class="s3">\n     </span><span class="s1">* 2. Determine if an animation type needs animating.</span><span class="s3">\n     </span><span class="s1">* 3. Determine if any values have been removed from a type and figure out</span><span class="s3">\n     </span><span class="s1">*    what to animate those to.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function animateChanges(changedActiveType) {</span><span class="s3">\n        </span><span class="s1">const { props } = visualElement;</span><span class="s3">\n        </span><span class="s1">const context = getVariantContext(visualElement.parent) || {};</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* A list of animations that we'll build into as we iterate through the animation</span><span class="s3">\n         </span><span class="s1">* types. This will get executed at the end of the function.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">const animations = [];</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Keep track of which values have been removed. Then, as we hit lower priority</span><span class="s3">\n         </span><span class="s1">* animation types, we can check if they contain removed values and animate to that.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">const removedKeys = new Set();</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* A dictionary of all encountered keys. This is an object to let us build into and</span><span class="s3">\n         </span><span class="s1">* copy it without iteration. Each time we hit an animation type we set its protected</span><span class="s3">\n         </span><span class="s1">* keys - the keys its not allowed to animate - to the latest version of this object.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">let encounteredKeys = {};</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* If a variant has been removed at a given index, and this component is controlling</span><span class="s3">\n         </span><span class="s1">* variant animations, we want to ensure lower-priority variants are forced to animate.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">let removedVariantIndex = Infinity;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Iterate through all animation types in reverse priority order. For each, we want to</span><span class="s3">\n         </span><span class="s1">* detect which values it's handling and whether or not they've changed (and therefore</span><span class="s3">\n         </span><span class="s1">* need to be animated). If any values have been removed, we want to detect those in</span><span class="s3">\n         </span><span class="s1">* lower priority props and flag for animation.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; numAnimationTypes; i++) {</span><span class="s3">\n            </span><span class="s1">const type = reversePriorityOrder[i];</span><span class="s3">\n            </span><span class="s1">const typeState = state[type];</span><span class="s3">\n            </span><span class="s1">const prop = props[type] !== undefined</span><span class="s3">\n                </span><span class="s1">? props[type]</span><span class="s3">\n                </span><span class="s1">: context[type];</span><span class="s3">\n            </span><span class="s1">const propIsVariant = isVariantLabel(prop);</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* If this type has *just* changed isActive status, set activeDelta</span><span class="s3">\n             </span><span class="s1">* to that status. Otherwise set to null.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">const activeDelta = type === changedActiveType ? typeState.isActive : null;</span><span class="s3">\n            </span><span class="s1">if (activeDelta === false)</span><span class="s3">\n                </span><span class="s1">removedVariantIndex = i;</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* If this prop is an inherited variant, rather than been set directly on the</span><span class="s3">\n             </span><span class="s1">* component itself, we want to make sure we allow the parent to trigger animations.</span><span class="s3">\n             </span><span class="s1">*</span><span class="s3">\n             </span><span class="s1">* TODO: Can probably change this to a !isControllingVariants check</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">let isInherited = prop === context[type] &amp;&amp;</span><span class="s3">\n                </span><span class="s1">prop !== props[type] &amp;&amp;</span><span class="s3">\n                </span><span class="s1">propIsVariant;</span><span class="s3">\n            </span><span class="s1">if (isInherited &amp;&amp;</span><span class="s3">\n                </span><span class="s1">isInitialRender &amp;&amp;</span><span class="s3">\n                </span><span class="s1">visualElement.manuallyAnimateOnMount) {</span><span class="s3">\n                </span><span class="s1">isInherited = false;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* Set all encountered keys so far as the protected keys for this type. This will</span><span class="s3">\n             </span><span class="s1">* be any key that has been animated or otherwise handled by active, higher-priortiy types.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">typeState.protectedKeys = { ...encounteredKeys };</span><span class="s3">\n            </span><span class="s1">// Check if we can skip analysing this prop early</span><span class="s3">\n            </span><span class="s1">if (</span><span class="s3">\n            </span><span class="s1">// If it isn't active and hasn't *just* been set as inactive</span><span class="s3">\n            </span><span class="s1">(!typeState.isActive &amp;&amp; activeDelta === null) ||</span><span class="s3">\n                </span><span class="s1">// If we didn't and don't have any defined prop for this animation type</span><span class="s3">\n                </span><span class="s1">(!prop &amp;&amp; !typeState.prevProp) ||</span><span class="s3">\n                </span><span class="s1">// Or if the prop doesn't define an animation</span><span class="s3">\n                </span><span class="s1">isAnimationControls(prop) ||</span><span class="s3">\n                </span><span class="s1">typeof prop === </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* As we go look through the values defined on this type, if we detect</span><span class="s3">\n             </span><span class="s1">* a changed value or a value that was removed in a higher priority, we set</span><span class="s3">\n             </span><span class="s1">* this to true and add this prop to the animation list.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);</span><span class="s3">\n            </span><span class="s1">let shouldAnimateType = variantDidChange ||</span><span class="s3">\n                </span><span class="s1">// If we're making this variant active, we want to always make it active</span><span class="s3">\n                </span><span class="s1">(type === changedActiveType &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">typeState.isActive &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">!isInherited &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">propIsVariant) ||</span><span class="s3">\n                </span><span class="s1">// If we removed a higher-priority variant (i is in reverse order)</span><span class="s3">\n                </span><span class="s1">(i &gt; removedVariantIndex &amp;&amp; propIsVariant);</span><span class="s3">\n            </span><span class="s1">let handledRemovedValues = false;</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* As animations can be set as variant lists, variants or target objects, we</span><span class="s3">\n             </span><span class="s1">* coerce everything to an array if it isn't one already</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">const definitionList = Array.isArray(prop) ? prop : [prop];</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* Build an object of all the resolved values. We'll use this in the subsequent</span><span class="s3">\n             </span><span class="s1">* animateChanges calls to determine whether a value has changed.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});</span><span class="s3">\n            </span><span class="s1">if (activeDelta === false)</span><span class="s3">\n                </span><span class="s1">resolvedValues = {};</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* Now we need to loop through all the keys in the prev prop and this prop,</span><span class="s3">\n             </span><span class="s1">* and decide:</span><span class="s3">\n             </span><span class="s1">* 1. If the value has changed, and needs animating</span><span class="s3">\n             </span><span class="s1">* 2. If it has been removed, and needs adding to the removedKeys set</span><span class="s3">\n             </span><span class="s1">* 3. If it has been removed in a higher priority type and needs animating</span><span class="s3">\n             </span><span class="s1">* 4. If it hasn't been removed in a higher priority but hasn't changed, and</span><span class="s3">\n             </span><span class="s1">*    needs adding to the type's protectedKeys list.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">const { prevResolvedValues = {} } = typeState;</span><span class="s3">\n            </span><span class="s1">const allKeys = {</span><span class="s3">\n                </span><span class="s1">...prevResolvedValues,</span><span class="s3">\n                </span><span class="s1">...resolvedValues,</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">const markToAnimate = (key) =&gt; {</span><span class="s3">\n                </span><span class="s1">shouldAnimateType = true;</span><span class="s3">\n                </span><span class="s1">if (removedKeys.has(key)) {</span><span class="s3">\n                    </span><span class="s1">handledRemovedValues = true;</span><span class="s3">\n                    </span><span class="s1">removedKeys.delete(key);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">typeState.needsAnimating[key] = true;</span><span class="s3">\n                </span><span class="s1">const motionValue = visualElement.getValue(key);</span><span class="s3">\n                </span><span class="s1">if (motionValue)</span><span class="s3">\n                    </span><span class="s1">motionValue.liveStyle = false;</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">for (const key in allKeys) {</span><span class="s3">\n                </span><span class="s1">const next = resolvedValues[key];</span><span class="s3">\n                </span><span class="s1">const prev = prevResolvedValues[key];</span><span class="s3">\n                </span><span class="s1">// If we've already handled this we can just skip ahead</span><span class="s3">\n                </span><span class="s1">if (encounteredKeys.hasOwnProperty(key))</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">/**</span><span class="s3">\n                 </span><span class="s1">* If the value has changed, we probably want to animate it.</span><span class="s3">\n                 </span><span class="s1">*/</span><span class="s3">\n                </span><span class="s1">let valueHasChanged = false;</span><span class="s3">\n                </span><span class="s1">if (isKeyframesTarget(next) &amp;&amp; isKeyframesTarget(prev)) {</span><span class="s3">\n                    </span><span class="s1">valueHasChanged = !shallowCompare(next, prev);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">valueHasChanged = next !== prev;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (valueHasChanged) {</span><span class="s3">\n                    </span><span class="s1">if (next !== undefined &amp;&amp; next !== null) {</span><span class="s3">\n                        </span><span class="s1">// If next is defined and doesn't equal prev, it needs animating</span><span class="s3">\n                        </span><span class="s1">markToAnimate(key);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">// If it's undefined, it's been removed.</span><span class="s3">\n                        </span><span class="s1">removedKeys.add(key);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (next !== undefined &amp;&amp; removedKeys.has(key)) {</span><span class="s3">\n                    </span><span class="s1">/**</span><span class="s3">\n                     </span><span class="s1">* If next hasn't changed and it isn't undefined, we want to check if it's</span><span class="s3">\n                     </span><span class="s1">* been removed by a higher priority</span><span class="s3">\n                     </span><span class="s1">*/</span><span class="s3">\n                    </span><span class="s1">markToAnimate(key);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">/**</span><span class="s3">\n                     </span><span class="s1">* If it hasn't changed, we add it to the list of protected values</span><span class="s3">\n                     </span><span class="s1">* to ensure it doesn't get animated.</span><span class="s3">\n                     </span><span class="s1">*/</span><span class="s3">\n                    </span><span class="s1">typeState.protectedKeys[key] = true;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* Update the typeState so next time animateChanges is called we can compare the</span><span class="s3">\n             </span><span class="s1">* latest prop and resolvedValues to these.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">typeState.prevProp = prop;</span><span class="s3">\n            </span><span class="s1">typeState.prevResolvedValues = resolvedValues;</span><span class="s3">\n            </span><span class="s1">if (typeState.isActive) {</span><span class="s3">\n                </span><span class="s1">encounteredKeys = { ...encounteredKeys, ...resolvedValues };</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (isInitialRender &amp;&amp; visualElement.blockInitialAnimation) {</span><span class="s3">\n                </span><span class="s1">shouldAnimateType = false;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* If this is an inherited prop we want to skip this animation</span><span class="s3">\n             </span><span class="s1">* unless the inherited variants haven't changed on this render.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">const willAnimateViaParent = isInherited &amp;&amp; variantDidChange;</span><span class="s3">\n            </span><span class="s1">const needsAnimating = !willAnimateViaParent || handledRemovedValues;</span><span class="s3">\n            </span><span class="s1">if (shouldAnimateType &amp;&amp; needsAnimating) {</span><span class="s3">\n                </span><span class="s1">animations.push(...definitionList.map((animation) =&gt; {</span><span class="s3">\n                    </span><span class="s1">const options = { type };</span><span class="s3">\n                    </span><span class="s1">/**</span><span class="s3">\n                     </span><span class="s1">* If we're performing the initial animation, but we're not</span><span class="s3">\n                     </span><span class="s1">* rendering at the same time as the variant-controlling parent,</span><span class="s3">\n                     </span><span class="s1">* we want to use the parent's transition to calculate the stagger.</span><span class="s3">\n                     </span><span class="s1">*/</span><span class="s3">\n                    </span><span class="s1">if (typeof animation === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n                        </span><span class="s1">isInitialRender &amp;&amp;</span><span class="s3">\n                        </span><span class="s1">!willAnimateViaParent &amp;&amp;</span><span class="s3">\n                        </span><span class="s1">visualElement.manuallyAnimateOnMount &amp;&amp;</span><span class="s3">\n                        </span><span class="s1">visualElement.parent) {</span><span class="s3">\n                        </span><span class="s1">const { parent } = visualElement;</span><span class="s3">\n                        </span><span class="s1">const parentVariant = resolveVariant(parent, animation);</span><span class="s3">\n                        </span><span class="s1">if (parent.enteringChildren &amp;&amp; parentVariant) {</span><span class="s3">\n                            </span><span class="s1">const { delayChildren } = parentVariant.transition || {};</span><span class="s3">\n                            </span><span class="s1">options.delay = calcChildStagger(parent.enteringChildren, visualElement, delayChildren);</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">return {</span><span class="s3">\n                        </span><span class="s1">animation: animation,</span><span class="s3">\n                        </span><span class="s1">options,</span><span class="s3">\n                    </span><span class="s1">};</span><span class="s3">\n                </span><span class="s1">}));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* If there are some removed value that haven't been dealt with,</span><span class="s3">\n         </span><span class="s1">* we need to create a new animation that falls back either to the value</span><span class="s3">\n         </span><span class="s1">* defined in the style prop, or the last read value.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">if (removedKeys.size) {</span><span class="s3">\n            </span><span class="s1">const fallbackAnimation = {};</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* If the initial prop contains a transition we can use that, otherwise</span><span class="s3">\n             </span><span class="s1">* allow the animation function to use the visual element's default.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">if (typeof props.initial !== </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">const initialTransition = resolveVariant(visualElement, Array.isArray(props.initial)</span><span class="s3">\n                    </span><span class="s1">? props.initial[0]</span><span class="s3">\n                    </span><span class="s1">: props.initial);</span><span class="s3">\n                </span><span class="s1">if (initialTransition &amp;&amp; initialTransition.transition) {</span><span class="s3">\n                    </span><span class="s1">fallbackAnimation.transition = initialTransition.transition;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">removedKeys.forEach((key) =&gt; {</span><span class="s3">\n                </span><span class="s1">const fallbackTarget = visualElement.getBaseTarget(key);</span><span class="s3">\n                </span><span class="s1">const motionValue = visualElement.getValue(key);</span><span class="s3">\n                </span><span class="s1">if (motionValue)</span><span class="s3">\n                    </span><span class="s1">motionValue.liveStyle = true;</span><span class="s3">\n                </span><span class="s1">// @ts-expect-error - @mattgperry to figure if we should do something here</span><span class="s3">\n                </span><span class="s1">fallbackAnimation[key] = fallbackTarget ?? null;</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">animations.push({ animation: fallbackAnimation });</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let shouldAnimate = Boolean(animations.length);</span><span class="s3">\n        </span><span class="s1">if (isInitialRender &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(props.initial === false || props.initial === props.animate) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">!visualElement.manuallyAnimateOnMount) {</span><span class="s3">\n            </span><span class="s1">shouldAnimate = false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">isInitialRender = false;</span><span class="s3">\n        </span><span class="s1">return shouldAnimate ? animate(animations) : Promise.resolve();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Change whether a certain animation type is active.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function setActive(type, isActive) {</span><span class="s3">\n        </span><span class="s1">// If the active state hasn't changed, we can safely do nothing here</span><span class="s3">\n        </span><span class="s1">if (state[type].isActive === isActive)</span><span class="s3">\n            </span><span class="s1">return Promise.resolve();</span><span class="s3">\n        </span><span class="s1">// Propagate active change to children</span><span class="s3">\n        </span><span class="s1">visualElement.variantChildren?.forEach((child) =&gt; child.animationState?.setActive(type, isActive));</span><span class="s3">\n        </span><span class="s1">state[type].isActive = isActive;</span><span class="s3">\n        </span><span class="s1">const animations = animateChanges(type);</span><span class="s3">\n        </span><span class="s1">for (const key in state) {</span><span class="s3">\n            </span><span class="s1">state[key].protectedKeys = {};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return animations;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">animateChanges,</span><span class="s3">\n        </span><span class="s1">setActive,</span><span class="s3">\n        </span><span class="s1">setAnimateFunction,</span><span class="s3">\n        </span><span class="s1">getState: () =&gt; state,</span><span class="s3">\n        </span><span class="s1">reset: () =&gt; {</span><span class="s3">\n            </span><span class="s1">state = createState();</span><span class="s3">\n            </span><span class="s1">isInitialRender = true;</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function checkVariantsDidChange(prev, next) {</span><span class="s3">\n    </span><span class="s1">if (typeof next === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return next !== prev;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (Array.isArray(next)) {</span><span class="s3">\n        </span><span class="s1">return !shallowCompare(next, prev);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function createTypeState(isActive = false) {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">isActive,</span><span class="s3">\n        </span><span class="s1">protectedKeys: {},</span><span class="s3">\n        </span><span class="s1">needsAnimating: {},</span><span class="s3">\n        </span><span class="s1">prevResolvedValues: {},</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function createState() {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">animate: createTypeState(true),</span><span class="s3">\n        </span><span class="s1">whileInView: createTypeState(),</span><span class="s3">\n        </span><span class="s1">whileHover: createTypeState(),</span><span class="s3">\n        </span><span class="s1">whileTap: createTypeState(),</span><span class="s3">\n        </span><span class="s1">whileDrag: createTypeState(),</span><span class="s3">\n        </span><span class="s1">whileFocus: createTypeState(),</span><span class="s3">\n        </span><span class="s1">exit: createTypeState(),</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { checkVariantsDidChange, createAnimationState };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAEA,MAAM,uBAAuB;OAAI,iNAAoB;CAAC,CAAC,OAAO;AAC9D,MAAM,oBAAoB,iNAAoB,CAAC,MAAM;AACrD,SAAS,YAAY,aAAa;IAC9B,OAAO,CAAC,aAAe,QAAQ,GAAG,CAAC,WAAW,GAAG,CAAC;gBAAC,EAAE,SAAS,EAAE,OAAO,EAAE;mBAAK,IAAA,0NAAoB,EAAC,eAAe,WAAW;;AACjI;AACA,SAAS,qBAAqB,aAAa;IACvC,IAAI,UAAU,YAAY;IAC1B,IAAI,QAAQ;IACZ,IAAI,kBAAkB;IACtB;;;KAGC,GACD,MAAM,0BAA0B,CAAC,OAAS,CAAC,KAAK;gBAEtC;YADN,MAAM,WAAW,IAAA,yNAAc,EAAC,eAAe,YAAY,SAAS,UAC9D,iCAAA,cAAc,eAAe,cAA7B,qDAAA,+BAA+B,MAAM,GACrC;YACN,IAAI,UAAU;gBACV,MAAM,EAAE,UAAU,EAAE,aAAa,EAAE,GAAG,QAAQ,GAAG;gBACjD,MAAM;oBAAE,GAAG,GAAG;oBAAE,GAAG,MAAM;oBAAE,GAAG,aAAa;gBAAC;YAChD;YACA,OAAO;QACX;IACA;;;KAGC,GACD,SAAS,mBAAmB,YAAY;QACpC,UAAU,aAAa;IAC3B;IACA;;;;;;;;;KASC,GACD,SAAS,eAAe,iBAAiB;QACrC,MAAM,EAAE,KAAK,EAAE,GAAG;QAClB,MAAM,UAAU,IAAA,uNAAiB,EAAC,cAAc,MAAM,KAAK,CAAC;QAC5D;;;SAGC,GACD,MAAM,aAAa,EAAE;QACrB;;;SAGC,GACD,MAAM,cAAc,IAAI;QACxB;;;;SAIC,GACD,IAAI,kBAAkB,CAAC;QACvB;;;SAGC,GACD,IAAI,sBAAsB;QAC1B;;;;;SAKC,GACD,IAAK,IAAI,IAAI,GAAG,IAAI,mBAAmB,IAAK;YACxC,MAAM,OAAO,oBAAoB,CAAC,EAAE;YACpC,MAAM,YAAY,KAAK,CAAC,KAAK;YAC7B,MAAM,OAAO,KAAK,CAAC,KAAK,KAAK,YACvB,KAAK,CAAC,KAAK,GACX,OAAO,CAAC,KAAK;YACnB,MAAM,gBAAgB,IAAA,iNAAc,EAAC;YACrC;;;aAGC,GACD,MAAM,cAAc,SAAS,oBAAoB,UAAU,QAAQ,GAAG;YACtE,IAAI,gBAAgB,OAChB,sBAAsB;YAC1B;;;;;aAKC,GACD,IAAI,cAAc,SAAS,OAAO,CAAC,KAAK,IACpC,SAAS,KAAK,CAAC,KAAK,IACpB;YACJ,IAAI,eACA,mBACA,cAAc,sBAAsB,EAAE;gBACtC,cAAc;YAClB;YACA;;;aAGC,GACD,UAAU,aAAa,GAAG;gBAAE,GAAG,eAAe;YAAC;YAC/C,iDAAiD;YACjD,IACA,4DAA4D;YAC3D,CAAC,UAAU,QAAQ,IAAI,gBAAgB,QAEnC,CAAC,QAAQ,CAAC,UAAU,QAAQ,IAC7B,6CAA6C;YAC7C,IAAA,8NAAmB,EAAC,SACpB,OAAO,SAAS,WAAW;gBAC3B;YACJ;YACA;;;;aAIC,GACD,MAAM,mBAAmB,uBAAuB,UAAU,QAAQ,EAAE;YACpE,IAAI,oBAAoB,oBAEnB,SAAS,qBACN,UAAU,QAAQ,IAClB,CAAC,eACD,iBAEH,IAAI,uBAAuB;YAChC,IAAI,uBAAuB;YAC3B;;;aAGC,GACD,MAAM,iBAAiB,MAAM,OAAO,CAAC,QAAQ,OAAO;gBAAC;aAAK;YAC1D;;;aAGC,GACD,IAAI,iBAAiB,eAAe,MAAM,CAAC,wBAAwB,OAAO,CAAC;YAC3E,IAAI,gBAAgB,OAChB,iBAAiB,CAAC;YACtB;;;;;;;;aAQC,GACD,MAAM,EAAE,qBAAqB,CAAC,CAAC,EAAE,GAAG;YACpC,MAAM,UAAU;gBACZ,GAAG,kBAAkB;gBACrB,GAAG,cAAc;YACrB;YACA,MAAM,gBAAgB,CAAC;gBACnB,oBAAoB;gBACpB,IAAI,YAAY,GAAG,CAAC,MAAM;oBACtB,uBAAuB;oBACvB,YAAY,MAAM,CAAC;gBACvB;gBACA,UAAU,cAAc,CAAC,IAAI,GAAG;gBAChC,MAAM,cAAc,cAAc,QAAQ,CAAC;gBAC3C,IAAI,aACA,YAAY,SAAS,GAAG;YAChC;YACA,IAAK,MAAM,OAAO,QAAS;gBACvB,MAAM,OAAO,cAAc,CAAC,IAAI;gBAChC,MAAM,OAAO,kBAAkB,CAAC,IAAI;gBACpC,uDAAuD;gBACvD,IAAI,gBAAgB,cAAc,CAAC,MAC/B;gBACJ;;iBAEC,GACD,IAAI,kBAAkB;gBACtB,IAAI,IAAA,0NAAiB,EAAC,SAAS,IAAA,0NAAiB,EAAC,OAAO;oBACpD,kBAAkB,CAAC,IAAA,mMAAc,EAAC,MAAM;gBAC5C,OACK;oBACD,kBAAkB,SAAS;gBAC/B;gBACA,IAAI,iBAAiB;oBACjB,IAAI,SAAS,aAAa,SAAS,MAAM;wBACrC,gEAAgE;wBAChE,cAAc;oBAClB,OACK;wBACD,wCAAwC;wBACxC,YAAY,GAAG,CAAC;oBACpB;gBACJ,OACK,IAAI,SAAS,aAAa,YAAY,GAAG,CAAC,MAAM;oBACjD;;;qBAGC,GACD,cAAc;gBAClB,OACK;oBACD;;;qBAGC,GACD,UAAU,aAAa,CAAC,IAAI,GAAG;gBACnC;YACJ;YACA;;;aAGC,GACD,UAAU,QAAQ,GAAG;YACrB,UAAU,kBAAkB,GAAG;YAC/B,IAAI,UAAU,QAAQ,EAAE;gBACpB,kBAAkB;oBAAE,GAAG,eAAe;oBAAE,GAAG,cAAc;gBAAC;YAC9D;YACA,IAAI,mBAAmB,cAAc,qBAAqB,EAAE;gBACxD,oBAAoB;YACxB;YACA;;;aAGC,GACD,MAAM,uBAAuB,eAAe;YAC5C,MAAM,iBAAiB,CAAC,wBAAwB;YAChD,IAAI,qBAAqB,gBAAgB;gBACrC,WAAW,IAAI,IAAI,eAAe,GAAG,CAAC,CAAC;oBACnC,MAAM,UAAU;wBAAE;oBAAK;oBACvB;;;;qBAIC,GACD,IAAI,OAAO,cAAc,YACrB,mBACA,CAAC,wBACD,cAAc,sBAAsB,IACpC,cAAc,MAAM,EAAE;wBACtB,MAAM,EAAE,MAAM,EAAE,GAAG;wBACnB,MAAM,gBAAgB,IAAA,yNAAc,EAAC,QAAQ;wBAC7C,IAAI,OAAO,gBAAgB,IAAI,eAAe;4BAC1C,MAAM,EAAE,aAAa,EAAE,GAAG,cAAc,UAAU,IAAI,CAAC;4BACvD,QAAQ,KAAK,GAAG,IAAA,wNAAgB,EAAC,OAAO,gBAAgB,EAAE,eAAe;wBAC7E;oBACJ;oBACA,OAAO;wBACH,WAAW;wBACX;oBACJ;gBACJ;YACJ;QACJ;QACA;;;;SAIC,GACD,IAAI,YAAY,IAAI,EAAE;YAClB,MAAM,oBAAoB,CAAC;YAC3B;;;aAGC,GACD,IAAI,OAAO,MAAM,OAAO,KAAK,WAAW;gBACpC,MAAM,oBAAoB,IAAA,yNAAc,EAAC,eAAe,MAAM,OAAO,CAAC,MAAM,OAAO,IAC7E,MAAM,OAAO,CAAC,EAAE,GAChB,MAAM,OAAO;gBACnB,IAAI,qBAAqB,kBAAkB,UAAU,EAAE;oBACnD,kBAAkB,UAAU,GAAG,kBAAkB,UAAU;gBAC/D;YACJ;YACA,YAAY,OAAO,CAAC,CAAC;gBACjB,MAAM,iBAAiB,cAAc,aAAa,CAAC;gBACnD,MAAM,cAAc,cAAc,QAAQ,CAAC;gBAC3C,IAAI,aACA,YAAY,SAAS,GAAG;gBAC5B,0EAA0E;gBAC1E,iBAAiB,CAAC,IAAI,GAAG,2BAAA,4BAAA,iBAAkB;YAC/C;YACA,WAAW,IAAI,CAAC;gBAAE,WAAW;YAAkB;QACnD;QACA,IAAI,gBAAgB,QAAQ,WAAW,MAAM;QAC7C,IAAI,mBACA,CAAC,MAAM,OAAO,KAAK,SAAS,MAAM,OAAO,KAAK,MAAM,OAAO,KAC3D,CAAC,cAAc,sBAAsB,EAAE;YACvC,gBAAgB;QACpB;QACA,kBAAkB;QAClB,OAAO,gBAAgB,QAAQ,cAAc,QAAQ,OAAO;IAChE;IACA;;KAEC,GACD,SAAS,UAAU,IAAI,EAAE,QAAQ;YAI7B,sCAAsC;QACtC;QAJA,oEAAoE;QACpE,IAAI,KAAK,CAAC,KAAK,CAAC,QAAQ,KAAK,UACzB,OAAO,QAAQ,OAAO;SAE1B,iCAAA,cAAc,eAAe,cAA7B,qDAAA,+BAA+B,OAAO,CAAC,CAAC;gBAAU;oBAAA,wBAAA,MAAM,cAAc,cAApB,4CAAA,sBAAsB,SAAS,CAAC,MAAM;;QACxF,KAAK,CAAC,KAAK,CAAC,QAAQ,GAAG;QACvB,MAAM,aAAa,eAAe;QAClC,IAAK,MAAM,OAAO,MAAO;YACrB,KAAK,CAAC,IAAI,CAAC,aAAa,GAAG,CAAC;QAChC;QACA,OAAO;IACX;IACA,OAAO;QACH;QACA;QACA;QACA,UAAU,IAAM;QAChB,OAAO;YACH,QAAQ;YACR,kBAAkB;QACtB;IACJ;AACJ;AACA,SAAS,uBAAuB,IAAI,EAAE,IAAI;IACtC,IAAI,OAAO,SAAS,UAAU;QAC1B,OAAO,SAAS;IACpB,OACK,IAAI,MAAM,OAAO,CAAC,OAAO;QAC1B,OAAO,CAAC,IAAA,mMAAc,EAAC,MAAM;IACjC;IACA,OAAO;AACX;AACA,SAAS;QAAgB,WAAA,iEAAW;IAChC,OAAO;QACH;QACA,eAAe,CAAC;QAChB,gBAAgB,CAAC;QACjB,oBAAoB,CAAC;IACzB;AACJ;AACA,SAAS;IACL,OAAO;QACH,SAAS,gBAAgB;QACzB,aAAa;QACb,YAAY;QACZ,UAAU;QACV,WAAW;QACX,YAAY;QACZ,MAAM;IACV;AACJ&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">3666</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/motion/features/Feature.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;class Feature {</span><span class="s3">\n    </span><span class="s1">constructor(node) {</span><span class="s3">\n        </span><span class="s1">this.isMounted = false;</span><span class="s3">\n        </span><span class="s1">this.node = node;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">update() { }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { Feature };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA,MAAM;IAKF,SAAS,CAAE;IAJX,YAAY,IAAI,CAAE;QACd,IAAI,CAAC,SAAS,GAAG;QACjB,IAAI,CAAC,IAAI,GAAG;IAChB;AAEJ&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">3682</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/motion/features/animation/index.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { isAnimationControls } from '../../../animation/utils/is-animation-controls.mjs';</span><span class="s3">\n</span><span class="s1">import { createAnimationState } from '../../../render/utils/animation-state.mjs';</span><span class="s3">\n</span><span class="s1">import { Feature } from '../Feature.mjs';</span><span class="s3">\n\n</span><span class="s1">class AnimationFeature extends Feature {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* We dynamically generate the AnimationState manager as it contains a reference</span><span class="s3">\n     </span><span class="s1">* to the underlying animation library. We only want to load that if we load this,</span><span class="s3">\n     </span><span class="s1">* so people can optionally code split it out using the `m` component.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(node) {</span><span class="s3">\n        </span><span class="s1">super(node);</span><span class="s3">\n        </span><span class="s1">node.animationState || (node.animationState = createAnimationState(node));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">updateAnimationControlsSubscription() {</span><span class="s3">\n        </span><span class="s1">const { animate } = this.node.getProps();</span><span class="s3">\n        </span><span class="s1">if (isAnimationControls(animate)) {</span><span class="s3">\n            </span><span class="s1">this.unmountControls = animate.subscribe(this.node);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Subscribe any provided AnimationControls to the component's VisualElement</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">mount() {</span><span class="s3">\n        </span><span class="s1">this.updateAnimationControlsSubscription();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">update() {</span><span class="s3">\n        </span><span class="s1">const { animate } = this.node.getProps();</span><span class="s3">\n        </span><span class="s1">const { animate: prevAnimate } = this.node.prevProps || {};</span><span class="s3">\n        </span><span class="s1">if (animate !== prevAnimate) {</span><span class="s3">\n            </span><span class="s1">this.updateAnimationControlsSubscription();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">unmount() {</span><span class="s3">\n        </span><span class="s1">this.node.animationState.reset();</span><span class="s3">\n        </span><span class="s1">this.unmountControls?.();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { AnimationFeature };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;AACA;AACA;;;;AAEA,MAAM,yBAAyB,8LAAO;IAUlC,sCAAsC;QAClC,MAAM,EAAE,OAAO,EAAE,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ;QACtC,IAAI,IAAA,8NAAmB,EAAC,UAAU;YAC9B,IAAI,CAAC,eAAe,GAAG,QAAQ,SAAS,CAAC,IAAI,CAAC,IAAI;QACtD;IACJ;IACA;;KAEC,GACD,QAAQ;QACJ,IAAI,CAAC,mCAAmC;IAC5C;IACA,SAAS;QACL,MAAM,EAAE,OAAO,EAAE,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ;QACtC,MAAM,EAAE,SAAS,WAAW,EAAE,GAAG,IAAI,CAAC,IAAI,CAAC,SAAS,IAAI,CAAC;QACzD,IAAI,YAAY,aAAa;YACzB,IAAI,CAAC,mCAAmC;QAC5C;IACJ;IACA,UAAU;YAEN,uBAAA;QADA,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,KAAK;SAC9B,wBAAA,CAAA,QAAA,IAAI,EAAC,eAAe,cAApB,4CAAA,2BAAA;IACJ;IA/BA;;;;KAIC,GACD,YAAY,IAAI,CAAE;QACd,KAAK,CAAC;QACN,KAAK,cAAc,IAAI,CAAC,KAAK,cAAc,GAAG,IAAA,mNAAoB,EAAC,KAAK;IAC5E;AAwBJ&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">3730</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/motion/features/animation/exit.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { Feature } from '../Feature.mjs';</span><span class="s3">\n\n</span><span class="s1">let id = 0;</span><span class="s3">\n</span><span class="s1">class ExitAnimationFeature extends Feature {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">super(...arguments);</span><span class="s3">\n        </span><span class="s1">this.id = id++;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">update() {</span><span class="s3">\n        </span><span class="s1">if (!this.node.presenceContext)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">const { isPresent, onExitComplete } = this.node.presenceContext;</span><span class="s3">\n        </span><span class="s1">const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};</span><span class="s3">\n        </span><span class="s1">if (!this.node.animationState || isPresent === prevIsPresent) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const exitAnimation = this.node.animationState.setActive(</span><span class="s3">\&quot;</span><span class="s1">exit</span><span class="s3">\&quot;</span><span class="s1">, !isPresent);</span><span class="s3">\n        </span><span class="s1">if (onExitComplete &amp;&amp; !isPresent) {</span><span class="s3">\n            </span><span class="s1">exitAnimation.then(() =&gt; {</span><span class="s3">\n                </span><span class="s1">onExitComplete(this.id);</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">mount() {</span><span class="s3">\n        </span><span class="s1">const { register, onExitComplete } = this.node.presenceContext || {};</span><span class="s3">\n        </span><span class="s1">if (onExitComplete) {</span><span class="s3">\n            </span><span class="s1">onExitComplete(this.id);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (register) {</span><span class="s3">\n            </span><span class="s1">this.unmount = register(this.id);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">unmount() { }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { ExitAnimationFeature };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;;AAEA,IAAI,KAAK;AACT,MAAM,6BAA6B,8LAAO;IAKtC,SAAS;QACL,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,eAAe,EAC1B;QACJ,MAAM,EAAE,SAAS,EAAE,cAAc,EAAE,GAAG,IAAI,CAAC,IAAI,CAAC,eAAe;QAC/D,MAAM,EAAE,WAAW,aAAa,EAAE,GAAG,IAAI,CAAC,IAAI,CAAC,mBAAmB,IAAI,CAAC;QACvE,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,cAAc,IAAI,cAAc,eAAe;YAC1D;QACJ;QACA,MAAM,gBAAgB,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,SAAS,CAAC,QAAQ,CAAC;QAClE,IAAI,kBAAkB,CAAC,WAAW;YAC9B,cAAc,IAAI,CAAC;gBACf,eAAe,IAAI,CAAC,EAAE;YAC1B;QACJ;IACJ;IACA,QAAQ;QACJ,MAAM,EAAE,QAAQ,EAAE,cAAc,EAAE,GAAG,IAAI,CAAC,IAAI,CAAC,eAAe,IAAI,CAAC;QACnE,IAAI,gBAAgB;YAChB,eAAe,IAAI,CAAC,EAAE;QAC1B;QACA,IAAI,UAAU;YACV,IAAI,CAAC,OAAO,GAAG,SAAS,IAAI,CAAC,EAAE;QACnC;IACJ;IACA,UAAU,CAAE;IA5BZ,aAAc;QACV,KAAK,IAAI;QACT,IAAI,CAAC,EAAE,GAAG;IACd;AA0BJ&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">3772</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/motion/features/animations.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { AnimationFeature } from './animation/index.mjs';</span><span class="s3">\n</span><span class="s1">import { ExitAnimationFeature } from './animation/exit.mjs';</span><span class="s3">\n\n</span><span class="s1">const animations = {</span><span class="s3">\n    </span><span class="s1">animation: {</span><span class="s3">\n        </span><span class="s1">Feature: AnimationFeature,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">exit: {</span><span class="s3">\n        </span><span class="s1">Feature: ExitAnimationFeature,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export { animations };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;AACA;;;AAEA,MAAM,aAAa;IACf,WAAW;QACP,SAAS,kNAAgB;IAC7B;IACA,MAAM;QACF,SAAS,qNAAoB;IACjC;AACJ&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">3793</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/events/add-dom-event.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;function addDomEvent(target, eventName, handler, options = { passive: true }) {</span><span class="s3">\n    </span><span class="s1">target.addEventListener(eventName, handler, options);</span><span class="s3">\n    </span><span class="s1">return () =&gt; target.removeEventListener(eventName, handler);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { addDomEvent };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA,SAAS,YAAY,MAAM,EAAE,SAAS,EAAE,OAAO;QAAE,UAAA,iEAAU;QAAE,SAAS;IAAK;IACvE,OAAO,gBAAgB,CAAC,WAAW,SAAS;IAC5C,OAAO,IAAM,OAAO,mBAAmB,CAAC,WAAW;AACvD&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">3809</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/events/event-info.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { isPrimaryPointer } from 'motion-dom';</span><span class="s3">\n\n</span><span class="s1">function extractEventInfo(event) {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">point: {</span><span class="s3">\n            </span><span class="s1">x: event.pageX,</span><span class="s3">\n            </span><span class="s1">y: event.pageY,</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const addPointerInfo = (handler) =&gt; {</span><span class="s3">\n    </span><span class="s1">return (event) =&gt; isPrimaryPointer(event) &amp;&amp; handler(event, extractEventInfo(event));</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export { addPointerInfo, extractEventInfo };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;AAAA;;AAEA,SAAS,iBAAiB,KAAK;IAC3B,OAAO;QACH,OAAO;YACH,GAAG,MAAM,KAAK;YACd,GAAG,MAAM,KAAK;QAClB;IACJ;AACJ;AACA,MAAM,iBAAiB,CAAC;IACpB,OAAO,CAAC,QAAU,IAAA,oNAAgB,EAAC,UAAU,QAAQ,OAAO,iBAAiB;AACjF&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">3833</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/events/add-pointer-event.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { addDomEvent } from './add-dom-event.mjs';</span><span class="s3">\n</span><span class="s1">import { addPointerInfo } from './event-info.mjs';</span><span class="s3">\n\n</span><span class="s1">function addPointerEvent(target, eventName, handler, options) {</span><span class="s3">\n    </span><span class="s1">return addDomEvent(target, eventName, addPointerInfo(handler), options);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { addPointerEvent };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;AACA;;;AAEA,SAAS,gBAAgB,MAAM,EAAE,SAAS,EAAE,OAAO,EAAE,OAAO;IACxD,OAAO,IAAA,kMAAW,EAAC,QAAQ,WAAW,IAAA,+LAAc,EAAC,UAAU;AACnE&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">3849</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/projection/geometry/delta-calc.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { mixNumber } from 'motion-dom';</span><span class="s3">\n\n</span><span class="s1">const SCALE_PRECISION = 0.0001;</span><span class="s3">\n</span><span class="s1">const SCALE_MIN = 1 - SCALE_PRECISION;</span><span class="s3">\n</span><span class="s1">const SCALE_MAX = 1 + SCALE_PRECISION;</span><span class="s3">\n</span><span class="s1">const TRANSLATE_PRECISION = 0.01;</span><span class="s3">\n</span><span class="s1">const TRANSLATE_MIN = 0 - TRANSLATE_PRECISION;</span><span class="s3">\n</span><span class="s1">const TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;</span><span class="s3">\n</span><span class="s1">function calcLength(axis) {</span><span class="s3">\n    </span><span class="s1">return axis.max - axis.min;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function isNear(value, target, maxDistance) {</span><span class="s3">\n    </span><span class="s1">return Math.abs(value - target) &lt;= maxDistance;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function calcAxisDelta(delta, source, target, origin = 0.5) {</span><span class="s3">\n    </span><span class="s1">delta.origin = origin;</span><span class="s3">\n    </span><span class="s1">delta.originPoint = mixNumber(source.min, source.max, delta.origin);</span><span class="s3">\n    </span><span class="s1">delta.scale = calcLength(target) / calcLength(source);</span><span class="s3">\n    </span><span class="s1">delta.translate =</span><span class="s3">\n        </span><span class="s1">mixNumber(target.min, target.max, delta.origin) - delta.originPoint;</span><span class="s3">\n    </span><span class="s1">if ((delta.scale &gt;= SCALE_MIN &amp;&amp; delta.scale &lt;= SCALE_MAX) ||</span><span class="s3">\n        </span><span class="s1">isNaN(delta.scale)) {</span><span class="s3">\n        </span><span class="s1">delta.scale = 1.0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if ((delta.translate &gt;= TRANSLATE_MIN &amp;&amp;</span><span class="s3">\n        </span><span class="s1">delta.translate &lt;= TRANSLATE_MAX) ||</span><span class="s3">\n        </span><span class="s1">isNaN(delta.translate)) {</span><span class="s3">\n        </span><span class="s1">delta.translate = 0.0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function calcBoxDelta(delta, source, target, origin) {</span><span class="s3">\n    </span><span class="s1">calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : undefined);</span><span class="s3">\n    </span><span class="s1">calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : undefined);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function calcRelativeAxis(target, relative, parent) {</span><span class="s3">\n    </span><span class="s1">target.min = parent.min + relative.min;</span><span class="s3">\n    </span><span class="s1">target.max = target.min + calcLength(relative);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function calcRelativeBox(target, relative, parent) {</span><span class="s3">\n    </span><span class="s1">calcRelativeAxis(target.x, relative.x, parent.x);</span><span class="s3">\n    </span><span class="s1">calcRelativeAxis(target.y, relative.y, parent.y);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function calcRelativeAxisPosition(target, layout, parent) {</span><span class="s3">\n    </span><span class="s1">target.min = layout.min - parent.min;</span><span class="s3">\n    </span><span class="s1">target.max = target.min + calcLength(layout);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function calcRelativePosition(target, layout, parent) {</span><span class="s3">\n    </span><span class="s1">calcRelativeAxisPosition(target.x, layout.x, parent.x);</span><span class="s3">\n    </span><span class="s1">calcRelativeAxisPosition(target.y, layout.y, parent.y);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { calcAxisDelta, calcBoxDelta, calcLength, calcRelativeAxis, calcRelativeAxisPosition, calcRelativeBox, calcRelativePosition, isNear };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;;;;AAAA;;AAEA,MAAM,kBAAkB;AACxB,MAAM,YAAY,IAAI;AACtB,MAAM,YAAY,IAAI;AACtB,MAAM,sBAAsB;AAC5B,MAAM,gBAAgB,IAAI;AAC1B,MAAM,gBAAgB,IAAI;AAC1B,SAAS,WAAW,IAAI;IACpB,OAAO,KAAK,GAAG,GAAG,KAAK,GAAG;AAC9B;AACA,SAAS,OAAO,KAAK,EAAE,MAAM,EAAE,WAAW;IACtC,OAAO,KAAK,GAAG,CAAC,QAAQ,WAAW;AACvC;AACA,SAAS,cAAc,KAAK,EAAE,MAAM,EAAE,MAAM;QAAE,SAAA,iEAAS;IACnD,MAAM,MAAM,GAAG;IACf,MAAM,WAAW,GAAG,IAAA,sLAAS,EAAC,OAAO,GAAG,EAAE,OAAO,GAAG,EAAE,MAAM,MAAM;IAClE,MAAM,KAAK,GAAG,WAAW,UAAU,WAAW;IAC9C,MAAM,SAAS,GACX,IAAA,sLAAS,EAAC,OAAO,GAAG,EAAE,OAAO,GAAG,EAAE,MAAM,MAAM,IAAI,MAAM,WAAW;IACvE,IAAI,AAAC,MAAM,KAAK,IAAI,aAAa,MAAM,KAAK,IAAI,aAC5C,MAAM,MAAM,KAAK,GAAG;QACpB,MAAM,KAAK,GAAG;IAClB;IACA,IAAI,AAAC,MAAM,SAAS,IAAI,iBACpB,MAAM,SAAS,IAAI,iBACnB,MAAM,MAAM,SAAS,GAAG;QACxB,MAAM,SAAS,GAAG;IACtB;AACJ;AACA,SAAS,aAAa,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM;IAC/C,cAAc,MAAM,CAAC,EAAE,OAAO,CAAC,EAAE,OAAO,CAAC,EAAE,SAAS,OAAO,OAAO,GAAG;IACrE,cAAc,MAAM,CAAC,EAAE,OAAO,CAAC,EAAE,OAAO,CAAC,EAAE,SAAS,OAAO,OAAO,GAAG;AACzE;AACA,SAAS,iBAAiB,MAAM,EAAE,QAAQ,EAAE,MAAM;IAC9C,OAAO,GAAG,GAAG,OAAO,GAAG,GAAG,SAAS,GAAG;IACtC,OAAO,GAAG,GAAG,OAAO,GAAG,GAAG,WAAW;AACzC;AACA,SAAS,gBAAgB,MAAM,EAAE,QAAQ,EAAE,MAAM;IAC7C,iBAAiB,OAAO,CAAC,EAAE,SAAS,CAAC,EAAE,OAAO,CAAC;IAC/C,iBAAiB,OAAO,CAAC,EAAE,SAAS,CAAC,EAAE,OAAO,CAAC;AACnD;AACA,SAAS,yBAAyB,MAAM,EAAE,MAAM,EAAE,MAAM;IACpD,OAAO,GAAG,GAAG,OAAO,GAAG,GAAG,OAAO,GAAG;IACpC,OAAO,GAAG,GAAG,OAAO,GAAG,GAAG,WAAW;AACzC;AACA,SAAS,qBAAqB,MAAM,EAAE,MAAM,EAAE,MAAM;IAChD,yBAAyB,OAAO,CAAC,EAAE,OAAO,CAAC,EAAE,OAAO,CAAC;IACrD,yBAAyB,OAAO,CAAC,EAAE,OAAO,CAAC,EAAE,OAAO,CAAC;AACzD&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">3919</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/projection/utils/each-axis.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;function eachAxis(callback) {</span><span class="s3">\n    </span><span class="s1">return [callback(</span><span class="s3">\&quot;</span><span class="s1">x</span><span class="s3">\&quot;</span><span class="s1">), callback(</span><span class="s3">\&quot;</span><span class="s1">y</span><span class="s3">\&quot;</span><span class="s1">)];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { eachAxis };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA,SAAS,SAAS,QAAQ;IACtB,OAAO;QAAC,SAAS;QAAM,SAAS;KAAK;AACzC&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">3934</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/utils/get-context-window.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// Fixes https://github.com/motiondivision/motion/issues/2270</span><span class="s3">\n</span><span class="s1">const getContextWindow = ({ current }) =&gt; {</span><span class="s3">\n    </span><span class="s1">return current ? current.ownerDocument.defaultView : null;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export { getContextWindow };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAA,6DAA6D;;;;;AAC7D,MAAM,mBAAmB;QAAC,EAAE,OAAO,EAAE;IACjC,OAAO,UAAU,QAAQ,aAAa,CAAC,WAAW,GAAG;AACzD&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">3948</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/utils/distance.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;const distance = (a, b) =&gt; Math.abs(a - b);</span><span class="s3">\n</span><span class="s1">function distance2D(a, b) {</span><span class="s3">\n    </span><span class="s1">// Multi-dimensional</span><span class="s3">\n    </span><span class="s1">const xDelta = distance(a.x, b.x);</span><span class="s3">\n    </span><span class="s1">const yDelta = distance(a.y, b.y);</span><span class="s3">\n    </span><span class="s1">return Math.sqrt(xDelta ** 2 + yDelta ** 2);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { distance, distance2D };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;AAAA,MAAM,WAAW,CAAC,GAAG,IAAM,KAAK,GAAG,CAAC,IAAI;AACxC,SAAS,WAAW,CAAC,EAAE,CAAC;IACpB,oBAAoB;IACpB,MAAM,SAAS,SAAS,EAAE,CAAC,EAAE,EAAE,CAAC;IAChC,MAAM,SAAS,SAAS,EAAE,CAAC,EAAE,EAAE,CAAC;IAChC,OAAO,KAAK,IAAI,CAAC,UAAU,IAAI,UAAU;AAC7C&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">3966</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/gestures/pan/PanSession.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { frame, isPrimaryPointer, cancelFrame, frameData } from 'motion-dom';</span><span class="s3">\n</span><span class="s1">import { pipe, secondsToMilliseconds, millisecondsToSeconds } from 'motion-utils';</span><span class="s3">\n</span><span class="s1">import { addPointerEvent } from '../../events/add-pointer-event.mjs';</span><span class="s3">\n</span><span class="s1">import { extractEventInfo } from '../../events/event-info.mjs';</span><span class="s3">\n</span><span class="s1">import { distance2D } from '../../utils/distance.mjs';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @internal</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class PanSession {</span><span class="s3">\n    </span><span class="s1">constructor(event, handlers, { transformPagePoint, contextWindow = window, dragSnapToOrigin = false, distanceThreshold = 3, } = {}) {</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* @internal</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.startEvent = null;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* @internal</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.lastMoveEvent = null;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* @internal</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.lastMoveEventInfo = null;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* @internal</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.handlers = {};</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* @internal</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.contextWindow = window;</span><span class="s3">\n        </span><span class="s1">this.updatePoint = () =&gt; {</span><span class="s3">\n            </span><span class="s1">if (!(this.lastMoveEvent &amp;&amp; this.lastMoveEventInfo))</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">const info = getPanInfo(this.lastMoveEventInfo, this.history);</span><span class="s3">\n            </span><span class="s1">const isPanStarted = this.startEvent !== null;</span><span class="s3">\n            </span><span class="s1">// Only start panning if the offset is larger than 3 pixels. If we make it</span><span class="s3">\n            </span><span class="s1">// any larger than this we'll want to reset the pointer history</span><span class="s3">\n            </span><span class="s1">// on the first update to avoid visual snapping to the cursor.</span><span class="s3">\n            </span><span class="s1">const isDistancePastThreshold = distance2D(info.offset, { x: 0, y: 0 }) &gt;= this.distanceThreshold;</span><span class="s3">\n            </span><span class="s1">if (!isPanStarted &amp;&amp; !isDistancePastThreshold)</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">const { point } = info;</span><span class="s3">\n            </span><span class="s1">const { timestamp } = frameData;</span><span class="s3">\n            </span><span class="s1">this.history.push({ ...point, timestamp });</span><span class="s3">\n            </span><span class="s1">const { onStart, onMove } = this.handlers;</span><span class="s3">\n            </span><span class="s1">if (!isPanStarted) {</span><span class="s3">\n                </span><span class="s1">onStart &amp;&amp; onStart(this.lastMoveEvent, info);</span><span class="s3">\n                </span><span class="s1">this.startEvent = this.lastMoveEvent;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">onMove &amp;&amp; onMove(this.lastMoveEvent, info);</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">this.handlePointerMove = (event, info) =&gt; {</span><span class="s3">\n            </span><span class="s1">this.lastMoveEvent = event;</span><span class="s3">\n            </span><span class="s1">this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint);</span><span class="s3">\n            </span><span class="s1">// Throttle mouse move event to once per frame</span><span class="s3">\n            </span><span class="s1">frame.update(this.updatePoint, true);</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">this.handlePointerUp = (event, info) =&gt; {</span><span class="s3">\n            </span><span class="s1">this.end();</span><span class="s3">\n            </span><span class="s1">const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;</span><span class="s3">\n            </span><span class="s1">if (this.dragSnapToOrigin)</span><span class="s3">\n                </span><span class="s1">resumeAnimation &amp;&amp; resumeAnimation();</span><span class="s3">\n            </span><span class="s1">if (!(this.lastMoveEvent &amp;&amp; this.lastMoveEventInfo))</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">const panInfo = getPanInfo(event.type === </span><span class="s3">\&quot;</span><span class="s1">pointercancel</span><span class="s3">\&quot;\n                </span><span class="s1">? this.lastMoveEventInfo</span><span class="s3">\n                </span><span class="s1">: transformPoint(info, this.transformPagePoint), this.history);</span><span class="s3">\n            </span><span class="s1">if (this.startEvent &amp;&amp; onEnd) {</span><span class="s3">\n                </span><span class="s1">onEnd(event, panInfo);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">onSessionEnd &amp;&amp; onSessionEnd(event, panInfo);</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">// If we have more than one touch, don't start detecting this gesture</span><span class="s3">\n        </span><span class="s1">if (!isPrimaryPointer(event))</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">this.dragSnapToOrigin = dragSnapToOrigin;</span><span class="s3">\n        </span><span class="s1">this.handlers = handlers;</span><span class="s3">\n        </span><span class="s1">this.transformPagePoint = transformPagePoint;</span><span class="s3">\n        </span><span class="s1">this.distanceThreshold = distanceThreshold;</span><span class="s3">\n        </span><span class="s1">this.contextWindow = contextWindow || window;</span><span class="s3">\n        </span><span class="s1">const info = extractEventInfo(event);</span><span class="s3">\n        </span><span class="s1">const initialInfo = transformPoint(info, this.transformPagePoint);</span><span class="s3">\n        </span><span class="s1">const { point } = initialInfo;</span><span class="s3">\n        </span><span class="s1">const { timestamp } = frameData;</span><span class="s3">\n        </span><span class="s1">this.history = [{ ...point, timestamp }];</span><span class="s3">\n        </span><span class="s1">const { onSessionStart } = handlers;</span><span class="s3">\n        </span><span class="s1">onSessionStart &amp;&amp;</span><span class="s3">\n            </span><span class="s1">onSessionStart(event, getPanInfo(initialInfo, this.history));</span><span class="s3">\n        </span><span class="s1">this.removeListeners = pipe(addPointerEvent(this.contextWindow, </span><span class="s3">\&quot;</span><span class="s1">pointermove</span><span class="s3">\&quot;</span><span class="s1">, this.handlePointerMove), addPointerEvent(this.contextWindow, </span><span class="s3">\&quot;</span><span class="s1">pointerup</span><span class="s3">\&quot;</span><span class="s1">, this.handlePointerUp), addPointerEvent(this.contextWindow, </span><span class="s3">\&quot;</span><span class="s1">pointercancel</span><span class="s3">\&quot;</span><span class="s1">, this.handlePointerUp));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">updateHandlers(handlers) {</span><span class="s3">\n        </span><span class="s1">this.handlers = handlers;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">end() {</span><span class="s3">\n        </span><span class="s1">this.removeListeners &amp;&amp; this.removeListeners();</span><span class="s3">\n        </span><span class="s1">cancelFrame(this.updatePoint);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function transformPoint(info, transformPagePoint) {</span><span class="s3">\n    </span><span class="s1">return transformPagePoint ? { point: transformPagePoint(info.point) } : info;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function subtractPoint(a, b) {</span><span class="s3">\n    </span><span class="s1">return { x: a.x - b.x, y: a.y - b.y };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getPanInfo({ point }, history) {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">point,</span><span class="s3">\n        </span><span class="s1">delta: subtractPoint(point, lastDevicePoint(history)),</span><span class="s3">\n        </span><span class="s1">offset: subtractPoint(point, startDevicePoint(history)),</span><span class="s3">\n        </span><span class="s1">velocity: getVelocity(history, 0.1),</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function startDevicePoint(history) {</span><span class="s3">\n    </span><span class="s1">return history[0];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function lastDevicePoint(history) {</span><span class="s3">\n    </span><span class="s1">return history[history.length - 1];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getVelocity(history, timeDelta) {</span><span class="s3">\n    </span><span class="s1">if (history.length &lt; 2) {</span><span class="s3">\n        </span><span class="s1">return { x: 0, y: 0 };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let i = history.length - 1;</span><span class="s3">\n    </span><span class="s1">let timestampedPoint = null;</span><span class="s3">\n    </span><span class="s1">const lastPoint = lastDevicePoint(history);</span><span class="s3">\n    </span><span class="s1">while (i &gt;= 0) {</span><span class="s3">\n        </span><span class="s1">timestampedPoint = history[i];</span><span class="s3">\n        </span><span class="s1">if (lastPoint.timestamp - timestampedPoint.timestamp &gt;</span><span class="s3">\n            </span><span class="s1">secondsToMilliseconds(timeDelta)) {</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">i--;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!timestampedPoint) {</span><span class="s3">\n        </span><span class="s1">return { x: 0, y: 0 };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const time = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);</span><span class="s3">\n    </span><span class="s1">if (time === 0) {</span><span class="s3">\n        </span><span class="s1">return { x: 0, y: 0 };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const currentVelocity = {</span><span class="s3">\n        </span><span class="s1">x: (lastPoint.x - timestampedPoint.x) / time,</span><span class="s3">\n        </span><span class="s1">y: (lastPoint.y - timestampedPoint.y) / time,</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">if (currentVelocity.x === Infinity) {</span><span class="s3">\n        </span><span class="s1">currentVelocity.x = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (currentVelocity.y === Infinity) {</span><span class="s3">\n        </span><span class="s1">currentVelocity.y = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return currentVelocity;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { PanSession };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">4145</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/gestures/drag/utils/constraints.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { mixNumber } from 'motion-dom';</span><span class="s3">\n</span><span class="s1">import { progress, clamp } from 'motion-utils';</span><span class="s3">\n</span><span class="s1">import { calcLength } from '../../../projection/geometry/delta-calc.mjs';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Apply constraints to a point. These constraints are both physical along an</span><span class="s3">\n </span><span class="s1">* axis, and an elastic factor that determines how much to constrain the point</span><span class="s3">\n </span><span class="s1">* by if it does lie outside the defined parameters.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function applyConstraints(point, { min, max }, elastic) {</span><span class="s3">\n    </span><span class="s1">if (min !== undefined &amp;&amp; point &lt; min) {</span><span class="s3">\n        </span><span class="s1">// If we have a min point defined, and this is outside of that, constrain</span><span class="s3">\n        </span><span class="s1">point = elastic</span><span class="s3">\n            </span><span class="s1">? mixNumber(min, point, elastic.min)</span><span class="s3">\n            </span><span class="s1">: Math.max(point, min);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (max !== undefined &amp;&amp; point &gt; max) {</span><span class="s3">\n        </span><span class="s1">// If we have a max point defined, and this is outside of that, constrain</span><span class="s3">\n        </span><span class="s1">point = elastic</span><span class="s3">\n            </span><span class="s1">? mixNumber(max, point, elastic.max)</span><span class="s3">\n            </span><span class="s1">: Math.min(point, max);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return point;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Calculate constraints in terms of the viewport when defined relatively to the</span><span class="s3">\n </span><span class="s1">* measured axis. This is measured from the nearest edge, so a max constraint of 200</span><span class="s3">\n </span><span class="s1">* on an axis with a max value of 300 would return a constraint of 500 - axis length</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function calcRelativeAxisConstraints(axis, min, max) {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">min: min !== undefined ? axis.min + min : undefined,</span><span class="s3">\n        </span><span class="s1">max: max !== undefined</span><span class="s3">\n            </span><span class="s1">? axis.max + max - (axis.max - axis.min)</span><span class="s3">\n            </span><span class="s1">: undefined,</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Calculate constraints in terms of the viewport when</span><span class="s3">\n </span><span class="s1">* defined relatively to the measured bounding box.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">x: calcRelativeAxisConstraints(layoutBox.x, left, right),</span><span class="s3">\n        </span><span class="s1">y: calcRelativeAxisConstraints(layoutBox.y, top, bottom),</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Calculate viewport constraints when defined as another viewport-relative axis</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {</span><span class="s3">\n    </span><span class="s1">let min = constraintsAxis.min - layoutAxis.min;</span><span class="s3">\n    </span><span class="s1">let max = constraintsAxis.max - layoutAxis.max;</span><span class="s3">\n    </span><span class="s1">// If the constraints axis is actually smaller than the layout axis then we can</span><span class="s3">\n    </span><span class="s1">// flip the constraints</span><span class="s3">\n    </span><span class="s1">if (constraintsAxis.max - constraintsAxis.min &lt;</span><span class="s3">\n        </span><span class="s1">layoutAxis.max - layoutAxis.min) {</span><span class="s3">\n        </span><span class="s1">[min, max] = [max, min];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return { min, max };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Calculate viewport constraints when defined as another viewport-relative box</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function calcViewportConstraints(layoutBox, constraintsBox) {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),</span><span class="s3">\n        </span><span class="s1">y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y),</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Calculate a transform origin relative to the source axis, between 0-1, that results</span><span class="s3">\n </span><span class="s1">* in an asthetically pleasing scale/transform needed to project from source to target.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function calcOrigin(source, target) {</span><span class="s3">\n    </span><span class="s1">let origin = 0.5;</span><span class="s3">\n    </span><span class="s1">const sourceLength = calcLength(source);</span><span class="s3">\n    </span><span class="s1">const targetLength = calcLength(target);</span><span class="s3">\n    </span><span class="s1">if (targetLength &gt; sourceLength) {</span><span class="s3">\n        </span><span class="s1">origin = progress(target.min, target.max - sourceLength, source.min);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (sourceLength &gt; targetLength) {</span><span class="s3">\n        </span><span class="s1">origin = progress(source.min, source.max - targetLength, target.min);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return clamp(0, 1, origin);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Rebase the calculated viewport constraints relative to the layout.min point.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function rebaseAxisConstraints(layout, constraints) {</span><span class="s3">\n    </span><span class="s1">const relativeConstraints = {};</span><span class="s3">\n    </span><span class="s1">if (constraints.min !== undefined) {</span><span class="s3">\n        </span><span class="s1">relativeConstraints.min = constraints.min - layout.min;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (constraints.max !== undefined) {</span><span class="s3">\n        </span><span class="s1">relativeConstraints.max = constraints.max - layout.min;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return relativeConstraints;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const defaultElastic = 0.35;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Accepts a dragElastic prop and returns resolved elastic values for each axis.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function resolveDragElastic(dragElastic = defaultElastic) {</span><span class="s3">\n    </span><span class="s1">if (dragElastic === false) {</span><span class="s3">\n        </span><span class="s1">dragElastic = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (dragElastic === true) {</span><span class="s3">\n        </span><span class="s1">dragElastic = defaultElastic;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">x: resolveAxisElastic(dragElastic, </span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">y: resolveAxisElastic(dragElastic, </span><span class="s3">\&quot;</span><span class="s1">top</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">bottom</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function resolveAxisElastic(dragElastic, minLabel, maxLabel) {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">min: resolvePointElastic(dragElastic, minLabel),</span><span class="s3">\n        </span><span class="s1">max: resolvePointElastic(dragElastic, maxLabel),</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function resolvePointElastic(dragElastic, label) {</span><span class="s3">\n    </span><span class="s1">return typeof dragElastic === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;\n        </span><span class="s1">? dragElastic</span><span class="s3">\n        </span><span class="s1">: dragElastic[label] || 0;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { applyConstraints, calcOrigin, calcRelativeAxisConstraints, calcRelativeConstraints, calcViewportAxisConstraints, calcViewportConstraints, defaultElastic, rebaseAxisConstraints, resolveAxisElastic, resolveDragElastic, resolvePointElastic };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">4292</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/gestures/drag/VisualElementDragControls.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { frame, mixNumber, setDragLock, percent } from 'motion-dom';</span><span class="s3">\n</span><span class="s1">import { invariant } from 'motion-utils';</span><span class="s3">\n</span><span class="s1">import { animateMotionValue } from '../../animation/interfaces/motion-value.mjs';</span><span class="s3">\n</span><span class="s1">import { addDomEvent } from '../../events/add-dom-event.mjs';</span><span class="s3">\n</span><span class="s1">import { addPointerEvent } from '../../events/add-pointer-event.mjs';</span><span class="s3">\n</span><span class="s1">import { extractEventInfo } from '../../events/event-info.mjs';</span><span class="s3">\n</span><span class="s1">import { convertBoxToBoundingBox, convertBoundingBoxToBox } from '../../projection/geometry/conversion.mjs';</span><span class="s3">\n</span><span class="s1">import { calcLength } from '../../projection/geometry/delta-calc.mjs';</span><span class="s3">\n</span><span class="s1">import { createBox } from '../../projection/geometry/models.mjs';</span><span class="s3">\n</span><span class="s1">import { eachAxis } from '../../projection/utils/each-axis.mjs';</span><span class="s3">\n</span><span class="s1">import { measurePageBox } from '../../projection/utils/measure.mjs';</span><span class="s3">\n</span><span class="s1">import { getContextWindow } from '../../utils/get-context-window.mjs';</span><span class="s3">\n</span><span class="s1">import { isRefObject } from '../../utils/is-ref-object.mjs';</span><span class="s3">\n</span><span class="s1">import { addValueToWillChange } from '../../value/use-will-change/add-will-change.mjs';</span><span class="s3">\n</span><span class="s1">import { PanSession } from '../pan/PanSession.mjs';</span><span class="s3">\n</span><span class="s1">import { applyConstraints, calcRelativeConstraints, resolveDragElastic, rebaseAxisConstraints, calcViewportConstraints, calcOrigin, defaultElastic } from './utils/constraints.mjs';</span><span class="s3">\n\n</span><span class="s1">const elementDragControls = new WeakMap();</span><span class="s3">\n</span><span class="s1">class VisualElementDragControls {</span><span class="s3">\n    </span><span class="s1">constructor(visualElement) {</span><span class="s3">\n        </span><span class="s1">this.openDragLock = null;</span><span class="s3">\n        </span><span class="s1">this.isDragging = false;</span><span class="s3">\n        </span><span class="s1">this.currentDirection = null;</span><span class="s3">\n        </span><span class="s1">this.originPoint = { x: 0, y: 0 };</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* The permitted boundaries of travel, in pixels.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.constraints = false;</span><span class="s3">\n        </span><span class="s1">this.hasMutatedConstraints = false;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* The per-axis resolved elastic values.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.elastic = createBox();</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* The latest pointer event. Used as fallback when the `cancel` and `stop` functions are called without arguments.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.latestPointerEvent = null;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* The latest pan info. Used as fallback when the `cancel` and `stop` functions are called without arguments.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.latestPanInfo = null;</span><span class="s3">\n        </span><span class="s1">this.visualElement = visualElement;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">start(originEvent, { snapToCursor = false, distanceThreshold } = {}) {</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Don't start dragging if this component is exiting</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">const { presenceContext } = this.visualElement;</span><span class="s3">\n        </span><span class="s1">if (presenceContext &amp;&amp; presenceContext.isPresent === false)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">const onSessionStart = (event) =&gt; {</span><span class="s3">\n            </span><span class="s1">const { dragSnapToOrigin } = this.getProps();</span><span class="s3">\n            </span><span class="s1">// Stop or pause any animations on both axis values immediately. This allows the user to throw and catch</span><span class="s3">\n            </span><span class="s1">// the component.</span><span class="s3">\n            </span><span class="s1">dragSnapToOrigin ? this.pauseAnimation() : this.stopAnimation();</span><span class="s3">\n            </span><span class="s1">if (snapToCursor) {</span><span class="s3">\n                </span><span class="s1">this.snapToCursor(extractEventInfo(event).point);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">const onStart = (event, info) =&gt; {</span><span class="s3">\n            </span><span class="s1">// Attempt to grab the global drag gesture lock - maybe make this part of PanSession</span><span class="s3">\n            </span><span class="s1">const { drag, dragPropagation, onDragStart } = this.getProps();</span><span class="s3">\n            </span><span class="s1">if (drag &amp;&amp; !dragPropagation) {</span><span class="s3">\n                </span><span class="s1">if (this.openDragLock)</span><span class="s3">\n                    </span><span class="s1">this.openDragLock();</span><span class="s3">\n                </span><span class="s1">this.openDragLock = setDragLock(drag);</span><span class="s3">\n                </span><span class="s1">// If we don 't have the lock, don't start dragging</span><span class="s3">\n                </span><span class="s1">if (!this.openDragLock)</span><span class="s3">\n                    </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this.latestPointerEvent = event;</span><span class="s3">\n            </span><span class="s1">this.latestPanInfo = info;</span><span class="s3">\n            </span><span class="s1">this.isDragging = true;</span><span class="s3">\n            </span><span class="s1">this.currentDirection = null;</span><span class="s3">\n            </span><span class="s1">this.resolveConstraints();</span><span class="s3">\n            </span><span class="s1">if (this.visualElement.projection) {</span><span class="s3">\n                </span><span class="s1">this.visualElement.projection.isAnimationBlocked = true;</span><span class="s3">\n                </span><span class="s1">this.visualElement.projection.target = undefined;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* Record gesture origin</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">eachAxis((axis) =&gt; {</span><span class="s3">\n                </span><span class="s1">let current = this.getAxisMotionValue(axis).get() || 0;</span><span class="s3">\n                </span><span class="s1">/**</span><span class="s3">\n                 </span><span class="s1">* If the MotionValue is a percentage value convert to px</span><span class="s3">\n                 </span><span class="s1">*/</span><span class="s3">\n                </span><span class="s1">if (percent.test(current)) {</span><span class="s3">\n                    </span><span class="s1">const { projection } = this.visualElement;</span><span class="s3">\n                    </span><span class="s1">if (projection &amp;&amp; projection.layout) {</span><span class="s3">\n                        </span><span class="s1">const measuredAxis = projection.layout.layoutBox[axis];</span><span class="s3">\n                        </span><span class="s1">if (measuredAxis) {</span><span class="s3">\n                            </span><span class="s1">const length = calcLength(measuredAxis);</span><span class="s3">\n                            </span><span class="s1">current = length * (parseFloat(current) / 100);</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">this.originPoint[axis] = current;</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">// Fire onDragStart event</span><span class="s3">\n            </span><span class="s1">if (onDragStart) {</span><span class="s3">\n                </span><span class="s1">frame.postRender(() =&gt; onDragStart(event, info));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">addValueToWillChange(this.visualElement, </span><span class="s3">\&quot;</span><span class="s1">transform</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">const { animationState } = this.visualElement;</span><span class="s3">\n            </span><span class="s1">animationState &amp;&amp; animationState.setActive(</span><span class="s3">\&quot;</span><span class="s1">whileDrag</span><span class="s3">\&quot;</span><span class="s1">, true);</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">const onMove = (event, info) =&gt; {</span><span class="s3">\n            </span><span class="s1">this.latestPointerEvent = event;</span><span class="s3">\n            </span><span class="s1">this.latestPanInfo = info;</span><span class="s3">\n            </span><span class="s1">const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag, } = this.getProps();</span><span class="s3">\n            </span><span class="s1">// If we didn't successfully receive the gesture lock, early return.</span><span class="s3">\n            </span><span class="s1">if (!dragPropagation &amp;&amp; !this.openDragLock)</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">const { offset } = info;</span><span class="s3">\n            </span><span class="s1">// Attempt to detect drag direction if directionLock is true</span><span class="s3">\n            </span><span class="s1">if (dragDirectionLock &amp;&amp; this.currentDirection === null) {</span><span class="s3">\n                </span><span class="s1">this.currentDirection = getCurrentDirection(offset);</span><span class="s3">\n                </span><span class="s1">// If we've successfully set a direction, notify listener</span><span class="s3">\n                </span><span class="s1">if (this.currentDirection !== null) {</span><span class="s3">\n                    </span><span class="s1">onDirectionLock &amp;&amp; onDirectionLock(this.currentDirection);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Update each point with the latest position</span><span class="s3">\n            </span><span class="s1">this.updateAxis(</span><span class="s3">\&quot;</span><span class="s1">x</span><span class="s3">\&quot;</span><span class="s1">, info.point, offset);</span><span class="s3">\n            </span><span class="s1">this.updateAxis(</span><span class="s3">\&quot;</span><span class="s1">y</span><span class="s3">\&quot;</span><span class="s1">, info.point, offset);</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* Ideally we would leave the renderer to fire naturally at the end of</span><span class="s3">\n             </span><span class="s1">* this frame but if the element is about to change layout as the result</span><span class="s3">\n             </span><span class="s1">* of a re-render we want to ensure the browser can read the latest</span><span class="s3">\n             </span><span class="s1">* bounding box to ensure the pointer and element don't fall out of sync.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">this.visualElement.render();</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* This must fire after the render call as it might trigger a state</span><span class="s3">\n             </span><span class="s1">* change which itself might trigger a layout update.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">onDrag &amp;&amp; onDrag(event, info);</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">const onSessionEnd = (event, info) =&gt; {</span><span class="s3">\n            </span><span class="s1">this.latestPointerEvent = event;</span><span class="s3">\n            </span><span class="s1">this.latestPanInfo = info;</span><span class="s3">\n            </span><span class="s1">this.stop(event, info);</span><span class="s3">\n            </span><span class="s1">this.latestPointerEvent = null;</span><span class="s3">\n            </span><span class="s1">this.latestPanInfo = null;</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">const resumeAnimation = () =&gt; eachAxis((axis) =&gt; this.getAnimationState(axis) === </span><span class="s3">\&quot;</span><span class="s1">paused</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n            </span><span class="s1">this.getAxisMotionValue(axis).animation?.play());</span><span class="s3">\n        </span><span class="s1">const { dragSnapToOrigin } = this.getProps();</span><span class="s3">\n        </span><span class="s1">this.panSession = new PanSession(originEvent, {</span><span class="s3">\n            </span><span class="s1">onSessionStart,</span><span class="s3">\n            </span><span class="s1">onStart,</span><span class="s3">\n            </span><span class="s1">onMove,</span><span class="s3">\n            </span><span class="s1">onSessionEnd,</span><span class="s3">\n            </span><span class="s1">resumeAnimation,</span><span class="s3">\n        </span><span class="s1">}, {</span><span class="s3">\n            </span><span class="s1">transformPagePoint: this.visualElement.getTransformPagePoint(),</span><span class="s3">\n            </span><span class="s1">dragSnapToOrigin,</span><span class="s3">\n            </span><span class="s1">distanceThreshold,</span><span class="s3">\n            </span><span class="s1">contextWindow: getContextWindow(this.visualElement),</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @internal</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">stop(event, panInfo) {</span><span class="s3">\n        </span><span class="s1">const finalEvent = event || this.latestPointerEvent;</span><span class="s3">\n        </span><span class="s1">const finalPanInfo = panInfo || this.latestPanInfo;</span><span class="s3">\n        </span><span class="s1">const isDragging = this.isDragging;</span><span class="s3">\n        </span><span class="s1">this.cancel();</span><span class="s3">\n        </span><span class="s1">if (!isDragging || !finalPanInfo || !finalEvent)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">const { velocity } = finalPanInfo;</span><span class="s3">\n        </span><span class="s1">this.startAnimation(velocity);</span><span class="s3">\n        </span><span class="s1">const { onDragEnd } = this.getProps();</span><span class="s3">\n        </span><span class="s1">if (onDragEnd) {</span><span class="s3">\n            </span><span class="s1">frame.postRender(() =&gt; onDragEnd(finalEvent, finalPanInfo));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @internal</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">cancel() {</span><span class="s3">\n        </span><span class="s1">this.isDragging = false;</span><span class="s3">\n        </span><span class="s1">const { projection, animationState } = this.visualElement;</span><span class="s3">\n        </span><span class="s1">if (projection) {</span><span class="s3">\n            </span><span class="s1">projection.isAnimationBlocked = false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.panSession &amp;&amp; this.panSession.end();</span><span class="s3">\n        </span><span class="s1">this.panSession = undefined;</span><span class="s3">\n        </span><span class="s1">const { dragPropagation } = this.getProps();</span><span class="s3">\n        </span><span class="s1">if (!dragPropagation &amp;&amp; this.openDragLock) {</span><span class="s3">\n            </span><span class="s1">this.openDragLock();</span><span class="s3">\n            </span><span class="s1">this.openDragLock = null;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">animationState &amp;&amp; animationState.setActive(</span><span class="s3">\&quot;</span><span class="s1">whileDrag</span><span class="s3">\&quot;</span><span class="s1">, false);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">updateAxis(axis, _point, offset) {</span><span class="s3">\n        </span><span class="s1">const { drag } = this.getProps();</span><span class="s3">\n        </span><span class="s1">// If we're not dragging this axis, do an early return.</span><span class="s3">\n        </span><span class="s1">if (!offset || !shouldDrag(axis, drag, this.currentDirection))</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">const axisValue = this.getAxisMotionValue(axis);</span><span class="s3">\n        </span><span class="s1">let next = this.originPoint[axis] + offset[axis];</span><span class="s3">\n        </span><span class="s1">// Apply constraints</span><span class="s3">\n        </span><span class="s1">if (this.constraints &amp;&amp; this.constraints[axis]) {</span><span class="s3">\n            </span><span class="s1">next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">axisValue.set(next);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">resolveConstraints() {</span><span class="s3">\n        </span><span class="s1">const { dragConstraints, dragElastic } = this.getProps();</span><span class="s3">\n        </span><span class="s1">const layout = this.visualElement.projection &amp;&amp;</span><span class="s3">\n            </span><span class="s1">!this.visualElement.projection.layout</span><span class="s3">\n            </span><span class="s1">? this.visualElement.projection.measure(false)</span><span class="s3">\n            </span><span class="s1">: this.visualElement.projection?.layout;</span><span class="s3">\n        </span><span class="s1">const prevConstraints = this.constraints;</span><span class="s3">\n        </span><span class="s1">if (dragConstraints &amp;&amp; isRefObject(dragConstraints)) {</span><span class="s3">\n            </span><span class="s1">if (!this.constraints) {</span><span class="s3">\n                </span><span class="s1">this.constraints = this.resolveRefConstraints();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">if (dragConstraints &amp;&amp; layout) {</span><span class="s3">\n                </span><span class="s1">this.constraints = calcRelativeConstraints(layout.layoutBox, dragConstraints);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">this.constraints = false;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.elastic = resolveDragElastic(dragElastic);</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* If we're outputting to external MotionValues, we want to rebase the measured constraints</span><span class="s3">\n         </span><span class="s1">* from viewport-relative to component-relative.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">if (prevConstraints !== this.constraints &amp;&amp;</span><span class="s3">\n            </span><span class="s1">layout &amp;&amp;</span><span class="s3">\n            </span><span class="s1">this.constraints &amp;&amp;</span><span class="s3">\n            </span><span class="s1">!this.hasMutatedConstraints) {</span><span class="s3">\n            </span><span class="s1">eachAxis((axis) =&gt; {</span><span class="s3">\n                </span><span class="s1">if (this.constraints !== false &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">this.getAxisMotionValue(axis)) {</span><span class="s3">\n                    </span><span class="s1">this.constraints[axis] = rebaseAxisConstraints(layout.layoutBox[axis], this.constraints[axis]);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">resolveRefConstraints() {</span><span class="s3">\n        </span><span class="s1">const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();</span><span class="s3">\n        </span><span class="s1">if (!constraints || !isRefObject(constraints))</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">const constraintsElement = constraints.current;</span><span class="s3">\n        </span><span class="s1">invariant(constraintsElement !== null, </span><span class="s3">\&quot;</span><span class="s1">If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">drag-constraints-ref</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">const { projection } = this.visualElement;</span><span class="s3">\n        </span><span class="s1">// TODO</span><span class="s3">\n        </span><span class="s1">if (!projection || !projection.layout)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());</span><span class="s3">\n        </span><span class="s1">let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* If there's an onMeasureDragConstraints listener we call it and</span><span class="s3">\n         </span><span class="s1">* if different constraints are returned, set constraints to that</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">if (onMeasureDragConstraints) {</span><span class="s3">\n            </span><span class="s1">const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));</span><span class="s3">\n            </span><span class="s1">this.hasMutatedConstraints = !!userConstraints;</span><span class="s3">\n            </span><span class="s1">if (userConstraints) {</span><span class="s3">\n                </span><span class="s1">measuredConstraints = convertBoundingBoxToBox(userConstraints);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return measuredConstraints;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">startAnimation(velocity) {</span><span class="s3">\n        </span><span class="s1">const { drag, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd, } = this.getProps();</span><span class="s3">\n        </span><span class="s1">const constraints = this.constraints || {};</span><span class="s3">\n        </span><span class="s1">const momentumAnimations = eachAxis((axis) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (!shouldDrag(axis, drag, this.currentDirection)) {</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">let transition = (constraints &amp;&amp; constraints[axis]) || {};</span><span class="s3">\n            </span><span class="s1">if (dragSnapToOrigin)</span><span class="s3">\n                </span><span class="s1">transition = { min: 0, max: 0 };</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame</span><span class="s3">\n             </span><span class="s1">* of spring animations so we should look into adding a disable spring option to `inertia`.</span><span class="s3">\n             </span><span class="s1">* We could do something here where we affect the `bounceStiffness` and `bounceDamping`</span><span class="s3">\n             </span><span class="s1">* using the value of `dragElastic`.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">const bounceStiffness = dragElastic ? 200 : 1000000;</span><span class="s3">\n            </span><span class="s1">const bounceDamping = dragElastic ? 40 : 10000000;</span><span class="s3">\n            </span><span class="s1">const inertia = {</span><span class="s3">\n                </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">inertia</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                </span><span class="s1">velocity: dragMomentum ? velocity[axis] : 0,</span><span class="s3">\n                </span><span class="s1">bounceStiffness,</span><span class="s3">\n                </span><span class="s1">bounceDamping,</span><span class="s3">\n                </span><span class="s1">timeConstant: 750,</span><span class="s3">\n                </span><span class="s1">restDelta: 1,</span><span class="s3">\n                </span><span class="s1">restSpeed: 10,</span><span class="s3">\n                </span><span class="s1">...dragTransition,</span><span class="s3">\n                </span><span class="s1">...transition,</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">// If we're not animating on an externally-provided `MotionValue` we can use the</span><span class="s3">\n            </span><span class="s1">// component's animation controls which will handle interactions with whileHover (etc),</span><span class="s3">\n            </span><span class="s1">// otherwise we just have to animate the `MotionValue` itself.</span><span class="s3">\n            </span><span class="s1">return this.startAxisValueAnimation(axis, inertia);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">// Run all animations and then resolve the new drag constraints.</span><span class="s3">\n        </span><span class="s1">return Promise.all(momentumAnimations).then(onDragTransitionEnd);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">startAxisValueAnimation(axis, transition) {</span><span class="s3">\n        </span><span class="s1">const axisValue = this.getAxisMotionValue(axis);</span><span class="s3">\n        </span><span class="s1">addValueToWillChange(this.visualElement, axis);</span><span class="s3">\n        </span><span class="s1">return axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, false));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">stopAnimation() {</span><span class="s3">\n        </span><span class="s1">eachAxis((axis) =&gt; this.getAxisMotionValue(axis).stop());</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">pauseAnimation() {</span><span class="s3">\n        </span><span class="s1">eachAxis((axis) =&gt; this.getAxisMotionValue(axis).animation?.pause());</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getAnimationState(axis) {</span><span class="s3">\n        </span><span class="s1">return this.getAxisMotionValue(axis).animation?.state;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Drag works differently depending on which props are provided.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.</span><span class="s3">\n     </span><span class="s1">* - Otherwise, we apply the delta to the x/y motion values.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getAxisMotionValue(axis) {</span><span class="s3">\n        </span><span class="s1">const dragKey = `_drag${axis.toUpperCase()}`;</span><span class="s3">\n        </span><span class="s1">const props = this.visualElement.getProps();</span><span class="s3">\n        </span><span class="s1">const externalMotionValue = props[dragKey];</span><span class="s3">\n        </span><span class="s1">return externalMotionValue</span><span class="s3">\n            </span><span class="s1">? externalMotionValue</span><span class="s3">\n            </span><span class="s1">: this.visualElement.getValue(axis, (props.initial</span><span class="s3">\n                </span><span class="s1">? props.initial[axis]</span><span class="s3">\n                </span><span class="s1">: undefined) || 0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">snapToCursor(point) {</span><span class="s3">\n        </span><span class="s1">eachAxis((axis) =&gt; {</span><span class="s3">\n            </span><span class="s1">const { drag } = this.getProps();</span><span class="s3">\n            </span><span class="s1">// If we're not dragging this axis, do an early return.</span><span class="s3">\n            </span><span class="s1">if (!shouldDrag(axis, drag, this.currentDirection))</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">const { projection } = this.visualElement;</span><span class="s3">\n            </span><span class="s1">const axisValue = this.getAxisMotionValue(axis);</span><span class="s3">\n            </span><span class="s1">if (projection &amp;&amp; projection.layout) {</span><span class="s3">\n                </span><span class="s1">const { min, max } = projection.layout.layoutBox[axis];</span><span class="s3">\n                </span><span class="s1">axisValue.set(point[axis] - mixNumber(min, max, 0.5));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* When the viewport resizes we want to check if the measured constraints</span><span class="s3">\n     </span><span class="s1">* have changed and, if so, reposition the element within those new constraints</span><span class="s3">\n     </span><span class="s1">* relative to where it was before the resize.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">scalePositionWithinConstraints() {</span><span class="s3">\n        </span><span class="s1">if (!this.visualElement.current)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">const { drag, dragConstraints } = this.getProps();</span><span class="s3">\n        </span><span class="s1">const { projection } = this.visualElement;</span><span class="s3">\n        </span><span class="s1">if (!isRefObject(dragConstraints) || !projection || !this.constraints)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Stop current animations as there can be visual glitching if we try to do</span><span class="s3">\n         </span><span class="s1">* this mid-animation</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.stopAnimation();</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Record the relative position of the dragged element relative to the</span><span class="s3">\n         </span><span class="s1">* constraints box and save as a progress value.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">const boxProgress = { x: 0, y: 0 };</span><span class="s3">\n        </span><span class="s1">eachAxis((axis) =&gt; {</span><span class="s3">\n            </span><span class="s1">const axisValue = this.getAxisMotionValue(axis);</span><span class="s3">\n            </span><span class="s1">if (axisValue &amp;&amp; this.constraints !== false) {</span><span class="s3">\n                </span><span class="s1">const latest = axisValue.get();</span><span class="s3">\n                </span><span class="s1">boxProgress[axis] = calcOrigin({ min: latest, max: latest }, this.constraints[axis]);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Update the layout of this element and resolve the latest drag constraints</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">const { transformTemplate } = this.visualElement.getProps();</span><span class="s3">\n        </span><span class="s1">this.visualElement.current.style.transform = transformTemplate</span><span class="s3">\n            </span><span class="s1">? transformTemplate({}, </span><span class="s3">\&quot;\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">projection.root &amp;&amp; projection.root.updateScroll();</span><span class="s3">\n        </span><span class="s1">projection.updateLayout();</span><span class="s3">\n        </span><span class="s1">this.resolveConstraints();</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* For each axis, calculate the current progress of the layout axis</span><span class="s3">\n         </span><span class="s1">* within the new constraints.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">eachAxis((axis) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (!shouldDrag(axis, drag, null))</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* Calculate a new transform based on the previous box progress</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">const axisValue = this.getAxisMotionValue(axis);</span><span class="s3">\n            </span><span class="s1">const { min, max } = this.constraints[axis];</span><span class="s3">\n            </span><span class="s1">axisValue.set(mixNumber(min, max, boxProgress[axis]));</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">addListeners() {</span><span class="s3">\n        </span><span class="s1">if (!this.visualElement.current)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">elementDragControls.set(this.visualElement, this);</span><span class="s3">\n        </span><span class="s1">const element = this.visualElement.current;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Attach a pointerdown event listener on this DOM element to initiate drag tracking.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">const stopPointerListener = addPointerEvent(element, </span><span class="s3">\&quot;</span><span class="s1">pointerdown</span><span class="s3">\&quot;</span><span class="s1">, (event) =&gt; {</span><span class="s3">\n            </span><span class="s1">const { drag, dragListener = true } = this.getProps();</span><span class="s3">\n            </span><span class="s1">drag &amp;&amp; dragListener &amp;&amp; this.start(event);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">const measureDragConstraints = () =&gt; {</span><span class="s3">\n            </span><span class="s1">const { dragConstraints } = this.getProps();</span><span class="s3">\n            </span><span class="s1">if (isRefObject(dragConstraints) &amp;&amp; dragConstraints.current) {</span><span class="s3">\n                </span><span class="s1">this.constraints = this.resolveRefConstraints();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">const { projection } = this.visualElement;</span><span class="s3">\n        </span><span class="s1">const stopMeasureLayoutListener = projection.addEventListener(</span><span class="s3">\&quot;</span><span class="s1">measure</span><span class="s3">\&quot;</span><span class="s1">, measureDragConstraints);</span><span class="s3">\n        </span><span class="s1">if (projection &amp;&amp; !projection.layout) {</span><span class="s3">\n            </span><span class="s1">projection.root &amp;&amp; projection.root.updateScroll();</span><span class="s3">\n            </span><span class="s1">projection.updateLayout();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">frame.read(measureDragConstraints);</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Attach a window resize listener to scale the draggable target within its defined</span><span class="s3">\n         </span><span class="s1">* constraints as the window resizes.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">const stopResizeListener = addDomEvent(window, </span><span class="s3">\&quot;</span><span class="s1">resize</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; this.scalePositionWithinConstraints());</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* If the element's layout changes, calculate the delta and apply that to</span><span class="s3">\n         </span><span class="s1">* the drag gesture's origin point.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">const stopLayoutUpdateListener = projection.addEventListener(</span><span class="s3">\&quot;</span><span class="s1">didUpdate</span><span class="s3">\&quot;</span><span class="s1">, (({ delta, hasLayoutChanged }) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (this.isDragging &amp;&amp; hasLayoutChanged) {</span><span class="s3">\n                </span><span class="s1">eachAxis((axis) =&gt; {</span><span class="s3">\n                    </span><span class="s1">const motionValue = this.getAxisMotionValue(axis);</span><span class="s3">\n                    </span><span class="s1">if (!motionValue)</span><span class="s3">\n                        </span><span class="s1">return;</span><span class="s3">\n                    </span><span class="s1">this.originPoint[axis] += delta[axis].translate;</span><span class="s3">\n                    </span><span class="s1">motionValue.set(motionValue.get() + delta[axis].translate);</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">this.visualElement.render();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}));</span><span class="s3">\n        </span><span class="s1">return () =&gt; {</span><span class="s3">\n            </span><span class="s1">stopResizeListener();</span><span class="s3">\n            </span><span class="s1">stopPointerListener();</span><span class="s3">\n            </span><span class="s1">stopMeasureLayoutListener();</span><span class="s3">\n            </span><span class="s1">stopLayoutUpdateListener &amp;&amp; stopLayoutUpdateListener();</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getProps() {</span><span class="s3">\n        </span><span class="s1">const props = this.visualElement.getProps();</span><span class="s3">\n        </span><span class="s1">const { drag = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true, } = props;</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">...props,</span><span class="s3">\n            </span><span class="s1">drag,</span><span class="s3">\n            </span><span class="s1">dragDirectionLock,</span><span class="s3">\n            </span><span class="s1">dragPropagation,</span><span class="s3">\n            </span><span class="s1">dragConstraints,</span><span class="s3">\n            </span><span class="s1">dragElastic,</span><span class="s3">\n            </span><span class="s1">dragMomentum,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function shouldDrag(direction, drag, currentDirection) {</span><span class="s3">\n    </span><span class="s1">return ((drag === true || drag === direction) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(currentDirection === null || currentDirection === direction));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Based on an x/y offset determine the current drag direction. If both axis' offsets are lower</span><span class="s3">\n </span><span class="s1">* than the provided threshold, return `null`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param offset - The x/y offset from origin.</span><span class="s3">\n </span><span class="s1">* @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getCurrentDirection(offset, lockThreshold = 10) {</span><span class="s3">\n    </span><span class="s1">let direction = null;</span><span class="s3">\n    </span><span class="s1">if (Math.abs(offset.y) &gt; lockThreshold) {</span><span class="s3">\n        </span><span class="s1">direction = </span><span class="s3">\&quot;</span><span class="s1">y</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (Math.abs(offset.x) &gt; lockThreshold) {</span><span class="s3">\n        </span><span class="s1">direction = </span><span class="s3">\&quot;</span><span class="s1">x</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return direction;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { VisualElementDragControls, elementDragControls };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">4782</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/gestures/drag/index.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { Feature } from '../../motion/features/Feature.mjs';</span><span class="s3">\n</span><span class="s1">import { noop } from 'motion-utils';</span><span class="s3">\n</span><span class="s1">import { VisualElementDragControls } from './VisualElementDragControls.mjs';</span><span class="s3">\n\n</span><span class="s1">class DragGesture extends Feature {</span><span class="s3">\n    </span><span class="s1">constructor(node) {</span><span class="s3">\n        </span><span class="s1">super(node);</span><span class="s3">\n        </span><span class="s1">this.removeGroupControls = noop;</span><span class="s3">\n        </span><span class="s1">this.removeListeners = noop;</span><span class="s3">\n        </span><span class="s1">this.controls = new VisualElementDragControls(node);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">mount() {</span><span class="s3">\n        </span><span class="s1">// If we've been provided a DragControls for manual control over the drag gesture,</span><span class="s3">\n        </span><span class="s1">// subscribe this component to it on mount.</span><span class="s3">\n        </span><span class="s1">const { dragControls } = this.node.getProps();</span><span class="s3">\n        </span><span class="s1">if (dragControls) {</span><span class="s3">\n            </span><span class="s1">this.removeGroupControls = dragControls.subscribe(this.controls);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.removeListeners = this.controls.addListeners() || noop;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">unmount() {</span><span class="s3">\n        </span><span class="s1">this.removeGroupControls();</span><span class="s3">\n        </span><span class="s1">this.removeListeners();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { DragGesture };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;AACA;AACA;;;;AAEA,MAAM,oBAAoB,8LAAO;IAO7B,QAAQ;QACJ,kFAAkF;QAClF,2CAA2C;QAC3C,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ;QAC3C,IAAI,cAAc;YACd,IAAI,CAAC,mBAAmB,GAAG,aAAa,SAAS,CAAC,IAAI,CAAC,QAAQ;QACnE;QACA,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,QAAQ,CAAC,YAAY,MAAM,iKAAI;IAC/D;IACA,UAAU;QACN,IAAI,CAAC,mBAAmB;QACxB,IAAI,CAAC,eAAe;IACxB;IAlBA,YAAY,IAAI,CAAE;QACd,KAAK,CAAC;QACN,IAAI,CAAC,mBAAmB,GAAG,iKAAI;QAC/B,IAAI,CAAC,eAAe,GAAG,iKAAI;QAC3B,IAAI,CAAC,QAAQ,GAAG,IAAI,gOAAyB,CAAC;IAClD;AAcJ&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">4818</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/gestures/pan/index.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { frame } from 'motion-dom';</span><span class="s3">\n</span><span class="s1">import { noop } from 'motion-utils';</span><span class="s3">\n</span><span class="s1">import { addPointerEvent } from '../../events/add-pointer-event.mjs';</span><span class="s3">\n</span><span class="s1">import { Feature } from '../../motion/features/Feature.mjs';</span><span class="s3">\n</span><span class="s1">import { getContextWindow } from '../../utils/get-context-window.mjs';</span><span class="s3">\n</span><span class="s1">import { PanSession } from './PanSession.mjs';</span><span class="s3">\n\n</span><span class="s1">const asyncHandler = (handler) =&gt; (event, info) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (handler) {</span><span class="s3">\n        </span><span class="s1">frame.postRender(() =&gt; handler(event, info));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">class PanGesture extends Feature {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">super(...arguments);</span><span class="s3">\n        </span><span class="s1">this.removePointerDownListener = noop;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">onPointerDown(pointerDownEvent) {</span><span class="s3">\n        </span><span class="s1">this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {</span><span class="s3">\n            </span><span class="s1">transformPagePoint: this.node.getTransformPagePoint(),</span><span class="s3">\n            </span><span class="s1">contextWindow: getContextWindow(this.node),</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">createPanHandlers() {</span><span class="s3">\n        </span><span class="s1">const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">onSessionStart: asyncHandler(onPanSessionStart),</span><span class="s3">\n            </span><span class="s1">onStart: asyncHandler(onPanStart),</span><span class="s3">\n            </span><span class="s1">onMove: onPan,</span><span class="s3">\n            </span><span class="s1">onEnd: (event, info) =&gt; {</span><span class="s3">\n                </span><span class="s1">delete this.session;</span><span class="s3">\n                </span><span class="s1">if (onPanEnd) {</span><span class="s3">\n                    </span><span class="s1">frame.postRender(() =&gt; onPanEnd(event, info));</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">mount() {</span><span class="s3">\n        </span><span class="s1">this.removePointerDownListener = addPointerEvent(this.node.current, </span><span class="s3">\&quot;</span><span class="s1">pointerdown</span><span class="s3">\&quot;</span><span class="s1">, (event) =&gt; this.onPointerDown(event));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">update() {</span><span class="s3">\n        </span><span class="s1">this.session &amp;&amp; this.session.updateHandlers(this.createPanHandlers());</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">unmount() {</span><span class="s3">\n        </span><span class="s1">this.removePointerDownListener();</span><span class="s3">\n        </span><span class="s1">this.session &amp;&amp; this.session.end();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { PanGesture };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAEA,MAAM,eAAe,CAAC,UAAY,CAAC,OAAO;QACtC,IAAI,SAAS;YACT,8KAAK,CAAC,UAAU,CAAC,IAAM,QAAQ,OAAO;QAC1C;IACJ;AACA,MAAM,mBAAmB,8LAAO;IAK5B,cAAc,gBAAgB,EAAE;QAC5B,IAAI,CAAC,OAAO,GAAG,IAAI,iMAAU,CAAC,kBAAkB,IAAI,CAAC,iBAAiB,IAAI;YACtE,oBAAoB,IAAI,CAAC,IAAI,CAAC,qBAAqB;YACnD,eAAe,IAAA,2MAAgB,EAAC,IAAI,CAAC,IAAI;QAC7C;IACJ;IACA,oBAAoB;QAChB,MAAM,EAAE,iBAAiB,EAAE,UAAU,EAAE,KAAK,EAAE,QAAQ,EAAE,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ;QAC7E,OAAO;YACH,gBAAgB,aAAa;YAC7B,SAAS,aAAa;YACtB,QAAQ;YACR,OAAO,CAAC,OAAO;gBACX,OAAO,IAAI,CAAC,OAAO;gBACnB,IAAI,UAAU;oBACV,8KAAK,CAAC,UAAU,CAAC,IAAM,SAAS,OAAO;gBAC3C;YACJ;QACJ;IACJ;IACA,QAAQ;QACJ,IAAI,CAAC,yBAAyB,GAAG,IAAA,0MAAe,EAAC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,eAAe,CAAC,QAAU,IAAI,CAAC,aAAa,CAAC;IACrH;IACA,SAAS;QACL,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,IAAI,CAAC,iBAAiB;IACtE;IACA,UAAU;QACN,IAAI,CAAC,yBAAyB;QAC9B,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,OAAO,CAAC,GAAG;IACpC;IAjCA,aAAc;QACV,KAAK,IAAI;QACT,IAAI,CAAC,yBAAyB,GAAG,iKAAI;IACzC;AA+BJ&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">4880</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/components/AnimatePresence/use-presence.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use client</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { useContext, useId, useEffect, useCallback } from 'react';</span><span class="s3">\n</span><span class="s1">import { PresenceContext } from '../../context/PresenceContext.mjs';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* When a component is the child of `AnimatePresence`, it can use `usePresence`</span><span class="s3">\n </span><span class="s1">* to access information about whether it's still present in the React tree.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* ```jsx</span><span class="s3">\n </span><span class="s1">* import { usePresence } from </span><span class="s3">\&quot;</span><span class="s1">framer-motion</span><span class="s3">\&quot;\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* export const Component = () =&gt; {</span><span class="s3">\n </span><span class="s1">*   const [isPresent, safeToRemove] = usePresence()</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*   useEffect(() =&gt; {</span><span class="s3">\n </span><span class="s1">*     !isPresent &amp;&amp; setTimeout(safeToRemove, 1000)</span><span class="s3">\n </span><span class="s1">*   }, [isPresent])</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*   return &lt;div /&gt;</span><span class="s3">\n </span><span class="s1">* }</span><span class="s3">\n </span><span class="s1">* ```</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* If `isPresent` is `false`, it means that a component has been removed the tree, but</span><span class="s3">\n </span><span class="s1">* `AnimatePresence` won't really remove it until `safeToRemove` has been called.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @public</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function usePresence(subscribe = true) {</span><span class="s3">\n    </span><span class="s1">const context = useContext(PresenceContext);</span><span class="s3">\n    </span><span class="s1">if (context === null)</span><span class="s3">\n        </span><span class="s1">return [true, null];</span><span class="s3">\n    </span><span class="s1">const { isPresent, onExitComplete, register } = context;</span><span class="s3">\n    </span><span class="s1">// It's safe to call the following hooks conditionally (after an early return) because the context will always</span><span class="s3">\n    </span><span class="s1">// either be null or non-null for the lifespan of the component.</span><span class="s3">\n    </span><span class="s1">const id = useId();</span><span class="s3">\n    </span><span class="s1">useEffect(() =&gt; {</span><span class="s3">\n        </span><span class="s1">if (subscribe) {</span><span class="s3">\n            </span><span class="s1">return register(id);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}, [subscribe]);</span><span class="s3">\n    </span><span class="s1">const safeToRemove = useCallback(() =&gt; subscribe &amp;&amp; onExitComplete &amp;&amp; onExitComplete(id), [id, onExitComplete, subscribe]);</span><span class="s3">\n    </span><span class="s1">return !isPresent &amp;&amp; onExitComplete ? [false, safeToRemove] : [true];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Similar to `usePresence`, except `useIsPresent` simply returns whether or not the component is present.</span><span class="s3">\n </span><span class="s1">* There is no `safeToRemove` function.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* ```jsx</span><span class="s3">\n </span><span class="s1">* import { useIsPresent } from </span><span class="s3">\&quot;</span><span class="s1">framer-motion</span><span class="s3">\&quot;\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* export const Component = () =&gt; {</span><span class="s3">\n </span><span class="s1">*   const isPresent = useIsPresent()</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*   useEffect(() =&gt; {</span><span class="s3">\n </span><span class="s1">*     !isPresent &amp;&amp; console.log(</span><span class="s3">\&quot;</span><span class="s1">I've been removed!</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n </span><span class="s1">*   }, [isPresent])</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*   return &lt;div /&gt;</span><span class="s3">\n </span><span class="s1">* }</span><span class="s3">\n </span><span class="s1">* ```</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @public</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function useIsPresent() {</span><span class="s3">\n    </span><span class="s1">return isPresent(useContext(PresenceContext));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function isPresent(context) {</span><span class="s3">\n    </span><span class="s1">return context === null ? true : context.isPresent;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { isPresent, useIsPresent, usePresence };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;AACA;AACA;AAFA;;;AAIA;;;;;;;;;;;;;;;;;;;;;;CAsBC,GACD,SAAS;QAAY,YAAA,iEAAY;IAC7B,MAAM,UAAU,IAAA,2KAAU,EAAC,mMAAe;IAC1C,IAAI,YAAY,MACZ,OAAO;QAAC;QAAM;KAAK;IACvB,MAAM,EAAE,SAAS,EAAE,cAAc,EAAE,QAAQ,EAAE,GAAG;IAChD,8GAA8G;IAC9G,gEAAgE;IAChE,MAAM,KAAK,IAAA,sKAAK;IAChB,IAAA,0KAAS;iCAAC;YACN,IAAI,WAAW;gBACX,OAAO,SAAS;YACpB;QACJ;gCAAG;QAAC;KAAU;IACd,MAAM,eAAe,IAAA,4KAAW;iDAAC,IAAM,aAAa,kBAAkB,eAAe;gDAAK;QAAC;QAAI;QAAgB;KAAU;IACzH,OAAO,CAAC,aAAa,iBAAiB;QAAC;QAAO;KAAa,GAAG;QAAC;KAAK;AACxE;AACA;;;;;;;;;;;;;;;;;;;CAmBC,GACD,SAAS;IACL,OAAO,UAAU,IAAA,2KAAU,EAAC,mMAAe;AAC/C;AACA,SAAS,UAAU,OAAO;IACtB,OAAO,YAAY,OAAO,OAAO,QAAQ,SAAS;AACtD&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">4979</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/projection/node/state.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* This should only ever be modified on the client otherwise it'll</span><span class="s3">\n </span><span class="s1">* persist through server requests. If we need instanced states we</span><span class="s3">\n </span><span class="s1">* could lazy-init via root.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const globalProjectionState = {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Global flag as to whether the tree has animated since the last time</span><span class="s3">\n     </span><span class="s1">* we resized the window</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">hasAnimatedSinceResize: true,</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* We set this to true once, on the first update. Any nodes added to the tree beyond that</span><span class="s3">\n     </span><span class="s1">* update will be given a `data-projection-id` attribute.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">hasEverUpdated: false,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export { globalProjectionState };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAA;;;;CAIC;;;;AACD,MAAM,wBAAwB;IAC1B;;;KAGC,GACD,wBAAwB;IACxB;;;KAGC,GACD,gBAAgB;AACpB&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">5002</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/projection/styles/scale-border-radius.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { px } from 'motion-dom';</span><span class="s3">\n\n</span><span class="s1">function pixelsToPercent(pixels, axis) {</span><span class="s3">\n    </span><span class="s1">if (axis.max === axis.min)</span><span class="s3">\n        </span><span class="s1">return 0;</span><span class="s3">\n    </span><span class="s1">return (pixels / (axis.max - axis.min)) * 100;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* We always correct borderRadius as a percentage rather than pixels to reduce paints.</span><span class="s3">\n </span><span class="s1">* For example, if you are projecting a box that is 100px wide with a 10px borderRadius</span><span class="s3">\n </span><span class="s1">* into a box that is 200px wide with a 20px borderRadius, that is actually a 10%</span><span class="s3">\n </span><span class="s1">* borderRadius in both states. If we animate between the two in pixels that will trigger</span><span class="s3">\n </span><span class="s1">* a paint each time. If we animate between the two in percentage we'll avoid a paint.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const correctBorderRadius = {</span><span class="s3">\n    </span><span class="s1">correct: (latest, node) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (!node.target)</span><span class="s3">\n            </span><span class="s1">return latest;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* If latest is a string, if it's a percentage we can return immediately as it's</span><span class="s3">\n         </span><span class="s1">* going to be stretched appropriately. Otherwise, if it's a pixel, convert it to a number.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">if (typeof latest === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">if (px.test(latest)) {</span><span class="s3">\n                </span><span class="s1">latest = parseFloat(latest);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">return latest;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* If latest is a number, it's a pixel value. We use the current viewportBox to calculate that</span><span class="s3">\n         </span><span class="s1">* pixel value as a percentage of each axis</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">const x = pixelsToPercent(latest, node.target.x);</span><span class="s3">\n        </span><span class="s1">const y = pixelsToPercent(latest, node.target.y);</span><span class="s3">\n        </span><span class="s1">return `${x}% ${y}%`;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export { correctBorderRadius, pixelsToPercent };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;AAAA;;AAEA,SAAS,gBAAgB,MAAM,EAAE,IAAI;IACjC,IAAI,KAAK,GAAG,KAAK,KAAK,GAAG,EACrB,OAAO;IACX,OAAO,AAAC,SAAS,CAAC,KAAK,GAAG,GAAG,KAAK,GAAG,IAAK;AAC9C;AACA;;;;;;CAMC,GACD,MAAM,sBAAsB;IACxB,SAAS,CAAC,QAAQ;QACd,IAAI,CAAC,KAAK,MAAM,EACZ,OAAO;QACX;;;SAGC,GACD,IAAI,OAAO,WAAW,UAAU;YAC5B,IAAI,2LAAE,CAAC,IAAI,CAAC,SAAS;gBACjB,SAAS,WAAW;YACxB,OACK;gBACD,OAAO;YACX;QACJ;QACA;;;SAGC,GACD,MAAM,IAAI,gBAAgB,QAAQ,KAAK,MAAM,CAAC,CAAC;QAC/C,MAAM,IAAI,gBAAgB,QAAQ,KAAK,MAAM,CAAC,CAAC;QAC/C,OAAO,AAAC,GAAQ,OAAN,GAAE,MAAM,OAAF,GAAE;IACtB;AACJ&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">5046</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/projection/styles/scale-box-shadow.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { complex, mixNumber } from 'motion-dom';</span><span class="s3">\n\n</span><span class="s1">const correctBoxShadow = {</span><span class="s3">\n    </span><span class="s1">correct: (latest, { treeScale, projectionDelta }) =&gt; {</span><span class="s3">\n        </span><span class="s1">const original = latest;</span><span class="s3">\n        </span><span class="s1">const shadow = complex.parse(latest);</span><span class="s3">\n        </span><span class="s1">// TODO: Doesn't support multiple shadows</span><span class="s3">\n        </span><span class="s1">if (shadow.length &gt; 5)</span><span class="s3">\n            </span><span class="s1">return original;</span><span class="s3">\n        </span><span class="s1">const template = complex.createTransformer(latest);</span><span class="s3">\n        </span><span class="s1">const offset = typeof shadow[0] !== </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">? 1 : 0;</span><span class="s3">\n        </span><span class="s1">// Calculate the overall context scale</span><span class="s3">\n        </span><span class="s1">const xScale = projectionDelta.x.scale * treeScale.x;</span><span class="s3">\n        </span><span class="s1">const yScale = projectionDelta.y.scale * treeScale.y;</span><span class="s3">\n        </span><span class="s1">shadow[0 + offset] /= xScale;</span><span class="s3">\n        </span><span class="s1">shadow[1 + offset] /= yScale;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Ideally we'd correct x and y scales individually, but because blur and</span><span class="s3">\n         </span><span class="s1">* spread apply to both we have to take a scale average and apply that instead.</span><span class="s3">\n         </span><span class="s1">* We could potentially improve the outcome of this by incorporating the ratio between</span><span class="s3">\n         </span><span class="s1">* the two scales.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">const averageScale = mixNumber(xScale, yScale, 0.5);</span><span class="s3">\n        </span><span class="s1">// Blur</span><span class="s3">\n        </span><span class="s1">if (typeof shadow[2 + offset] === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">shadow[2 + offset] /= averageScale;</span><span class="s3">\n        </span><span class="s1">// Spread</span><span class="s3">\n        </span><span class="s1">if (typeof shadow[3 + offset] === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">shadow[3 + offset] /= averageScale;</span><span class="s3">\n        </span><span class="s1">return template(shadow);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export { correctBoxShadow };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;AAAA;;AAEA,MAAM,mBAAmB;IACrB,SAAS,CAAC;YAAQ,EAAE,SAAS,EAAE,eAAe,EAAE;QAC5C,MAAM,WAAW;QACjB,MAAM,SAAS,gMAAO,CAAC,KAAK,CAAC;QAC7B,yCAAyC;QACzC,IAAI,OAAO,MAAM,GAAG,GAChB,OAAO;QACX,MAAM,WAAW,gMAAO,CAAC,iBAAiB,CAAC;QAC3C,MAAM,SAAS,OAAO,MAAM,CAAC,EAAE,KAAK,WAAW,IAAI;QACnD,sCAAsC;QACtC,MAAM,SAAS,gBAAgB,CAAC,CAAC,KAAK,GAAG,UAAU,CAAC;QACpD,MAAM,SAAS,gBAAgB,CAAC,CAAC,KAAK,GAAG,UAAU,CAAC;QACpD,MAAM,CAAC,IAAI,OAAO,IAAI;QACtB,MAAM,CAAC,IAAI,OAAO,IAAI;QACtB;;;;;SAKC,GACD,MAAM,eAAe,IAAA,sLAAS,EAAC,QAAQ,QAAQ;QAC/C,OAAO;QACP,IAAI,OAAO,MAAM,CAAC,IAAI,OAAO,KAAK,UAC9B,MAAM,CAAC,IAAI,OAAO,IAAI;QAC1B,SAAS;QACT,IAAI,OAAO,MAAM,CAAC,IAAI,OAAO,KAAK,UAC9B,MAAM,CAAC,IAAI,OAAO,IAAI;QAC1B,OAAO,SAAS;IACpB;AACJ&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">5085</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use client</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { jsx } from 'react/jsx-runtime';</span><span class="s3">\n</span><span class="s1">import { frame, microtask } from 'motion-dom';</span><span class="s3">\n</span><span class="s1">import { useContext, Component } from 'react';</span><span class="s3">\n</span><span class="s1">import { usePresence } from '../../../components/AnimatePresence/use-presence.mjs';</span><span class="s3">\n</span><span class="s1">import { LayoutGroupContext } from '../../../context/LayoutGroupContext.mjs';</span><span class="s3">\n</span><span class="s1">import { SwitchLayoutGroupContext } from '../../../context/SwitchLayoutGroupContext.mjs';</span><span class="s3">\n</span><span class="s1">import { globalProjectionState } from '../../../projection/node/state.mjs';</span><span class="s3">\n</span><span class="s1">import { correctBorderRadius } from '../../../projection/styles/scale-border-radius.mjs';</span><span class="s3">\n</span><span class="s1">import { correctBoxShadow } from '../../../projection/styles/scale-box-shadow.mjs';</span><span class="s3">\n</span><span class="s1">import { addScaleCorrector } from '../../../projection/styles/scale-correction.mjs';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Track whether we've taken any snapshots yet. If not,</span><span class="s3">\n </span><span class="s1">* we can safely skip notification of didUpdate.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Difficult to capture in a test but to prevent flickering</span><span class="s3">\n </span><span class="s1">* we must set this to true either on update or unmount.</span><span class="s3">\n </span><span class="s1">* Running `next-env/layout-id` in Safari will show this behaviour if broken.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">let hasTakenAnySnapshot = false;</span><span class="s3">\n</span><span class="s1">class MeasureLayoutWithContext extends Component {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* This only mounts projection nodes for components that</span><span class="s3">\n     </span><span class="s1">* need measuring, we might want to do it for all components</span><span class="s3">\n     </span><span class="s1">* in order to incorporate transforms</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">componentDidMount() {</span><span class="s3">\n        </span><span class="s1">const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;</span><span class="s3">\n        </span><span class="s1">const { projection } = visualElement;</span><span class="s3">\n        </span><span class="s1">addScaleCorrector(defaultScaleCorrectors);</span><span class="s3">\n        </span><span class="s1">if (projection) {</span><span class="s3">\n            </span><span class="s1">if (layoutGroup.group)</span><span class="s3">\n                </span><span class="s1">layoutGroup.group.add(projection);</span><span class="s3">\n            </span><span class="s1">if (switchLayoutGroup &amp;&amp; switchLayoutGroup.register &amp;&amp; layoutId) {</span><span class="s3">\n                </span><span class="s1">switchLayoutGroup.register(projection);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (hasTakenAnySnapshot) {</span><span class="s3">\n                </span><span class="s1">projection.root.didUpdate();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">projection.addEventListener(</span><span class="s3">\&quot;</span><span class="s1">animationComplete</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; {</span><span class="s3">\n                </span><span class="s1">this.safeToRemove();</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">projection.setOptions({</span><span class="s3">\n                </span><span class="s1">...projection.options,</span><span class="s3">\n                </span><span class="s1">onExitComplete: () =&gt; this.safeToRemove(),</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">globalProjectionState.hasEverUpdated = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getSnapshotBeforeUpdate(prevProps) {</span><span class="s3">\n        </span><span class="s1">const { layoutDependency, visualElement, drag, isPresent } = this.props;</span><span class="s3">\n        </span><span class="s1">const { projection } = visualElement;</span><span class="s3">\n        </span><span class="s1">if (!projection)</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* TODO: We use this data in relegate to determine whether to</span><span class="s3">\n         </span><span class="s1">* promote a previous element. There's no guarantee its presence data</span><span class="s3">\n         </span><span class="s1">* will have updated by this point - if a bug like this arises it will</span><span class="s3">\n         </span><span class="s1">* have to be that we markForRelegation and then find a new lead some other way,</span><span class="s3">\n         </span><span class="s1">* perhaps in didUpdate</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">projection.isPresent = isPresent;</span><span class="s3">\n        </span><span class="s1">hasTakenAnySnapshot = true;</span><span class="s3">\n        </span><span class="s1">if (drag ||</span><span class="s3">\n            </span><span class="s1">prevProps.layoutDependency !== layoutDependency ||</span><span class="s3">\n            </span><span class="s1">layoutDependency === undefined ||</span><span class="s3">\n            </span><span class="s1">prevProps.isPresent !== isPresent) {</span><span class="s3">\n            </span><span class="s1">projection.willUpdate();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this.safeToRemove();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (prevProps.isPresent !== isPresent) {</span><span class="s3">\n            </span><span class="s1">if (isPresent) {</span><span class="s3">\n                </span><span class="s1">projection.promote();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (!projection.relegate()) {</span><span class="s3">\n                </span><span class="s1">/**</span><span class="s3">\n                 </span><span class="s1">* If there's another stack member taking over from this one,</span><span class="s3">\n                 </span><span class="s1">* it's in charge of the exit animation and therefore should</span><span class="s3">\n                 </span><span class="s1">* be in charge of the safe to remove. Otherwise we call it here.</span><span class="s3">\n                 </span><span class="s1">*/</span><span class="s3">\n                </span><span class="s1">frame.postRender(() =&gt; {</span><span class="s3">\n                    </span><span class="s1">const stack = projection.getStack();</span><span class="s3">\n                    </span><span class="s1">if (!stack || !stack.members.length) {</span><span class="s3">\n                        </span><span class="s1">this.safeToRemove();</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">componentDidUpdate() {</span><span class="s3">\n        </span><span class="s1">const { projection } = this.props.visualElement;</span><span class="s3">\n        </span><span class="s1">if (projection) {</span><span class="s3">\n            </span><span class="s1">projection.root.didUpdate();</span><span class="s3">\n            </span><span class="s1">microtask.postRender(() =&gt; {</span><span class="s3">\n                </span><span class="s1">if (!projection.currentAnimation &amp;&amp; projection.isLead()) {</span><span class="s3">\n                    </span><span class="s1">this.safeToRemove();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">componentWillUnmount() {</span><span class="s3">\n        </span><span class="s1">const { visualElement, layoutGroup, switchLayoutGroup: promoteContext, } = this.props;</span><span class="s3">\n        </span><span class="s1">const { projection } = visualElement;</span><span class="s3">\n        </span><span class="s1">hasTakenAnySnapshot = true;</span><span class="s3">\n        </span><span class="s1">if (projection) {</span><span class="s3">\n            </span><span class="s1">projection.scheduleCheckAfterUnmount();</span><span class="s3">\n            </span><span class="s1">if (layoutGroup &amp;&amp; layoutGroup.group)</span><span class="s3">\n                </span><span class="s1">layoutGroup.group.remove(projection);</span><span class="s3">\n            </span><span class="s1">if (promoteContext &amp;&amp; promoteContext.deregister)</span><span class="s3">\n                </span><span class="s1">promoteContext.deregister(projection);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">safeToRemove() {</span><span class="s3">\n        </span><span class="s1">const { safeToRemove } = this.props;</span><span class="s3">\n        </span><span class="s1">safeToRemove &amp;&amp; safeToRemove();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">render() {</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function MeasureLayout(props) {</span><span class="s3">\n    </span><span class="s1">const [isPresent, safeToRemove] = usePresence();</span><span class="s3">\n    </span><span class="s1">const layoutGroup = useContext(LayoutGroupContext);</span><span class="s3">\n    </span><span class="s1">return (jsx(MeasureLayoutWithContext, { ...props, layoutGroup: layoutGroup, switchLayoutGroup: useContext(SwitchLayoutGroupContext), isPresent: isPresent, safeToRemove: safeToRemove }));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const defaultScaleCorrectors = {</span><span class="s3">\n    </span><span class="s1">borderRadius: {</span><span class="s3">\n        </span><span class="s1">...correctBorderRadius,</span><span class="s3">\n        </span><span class="s1">applyTo: [</span><span class="s3">\n            \&quot;</span><span class="s1">borderTopLeftRadius</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            \&quot;</span><span class="s1">borderTopRightRadius</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            \&quot;</span><span class="s1">borderBottomLeftRadius</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            \&quot;</span><span class="s1">borderBottomRightRadius</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">borderTopLeftRadius: correctBorderRadius,</span><span class="s3">\n    </span><span class="s1">borderTopRightRadius: correctBorderRadius,</span><span class="s3">\n    </span><span class="s1">borderBottomLeftRadius: correctBorderRadius,</span><span class="s3">\n    </span><span class="s1">borderBottomRightRadius: correctBorderRadius,</span><span class="s3">\n    </span><span class="s1">boxShadow: correctBoxShadow,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export { MeasureLayout };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;;;;;;;;;;;AAYA;;;;;;;CAOC,GACD,IAAI,sBAAsB;AAC1B,MAAM,iCAAiC,0KAAS;IAC5C;;;;KAIC,GACD,oBAAoB;QAChB,MAAM,EAAE,aAAa,EAAE,WAAW,EAAE,iBAAiB,EAAE,QAAQ,EAAE,GAAG,IAAI,CAAC,KAAK;QAC9E,MAAM,EAAE,UAAU,EAAE,GAAG;QACvB,IAAA,sNAAiB,EAAC;QAClB,IAAI,YAAY;YACZ,IAAI,YAAY,KAAK,EACjB,YAAY,KAAK,CAAC,GAAG,CAAC;YAC1B,IAAI,qBAAqB,kBAAkB,QAAQ,IAAI,UAAU;gBAC7D,kBAAkB,QAAQ,CAAC;YAC/B;YACA,IAAI,qBAAqB;gBACrB,WAAW,IAAI,CAAC,SAAS;YAC7B;YACA,WAAW,gBAAgB,CAAC,qBAAqB;gBAC7C,IAAI,CAAC,YAAY;YACrB;YACA,WAAW,UAAU,CAAC;gBAClB,GAAG,WAAW,OAAO;gBACrB,gBAAgB,IAAM,IAAI,CAAC,YAAY;YAC3C;QACJ;QACA,0MAAqB,CAAC,cAAc,GAAG;IAC3C;IACA,wBAAwB,SAAS,EAAE;QAC/B,MAAM,EAAE,gBAAgB,EAAE,aAAa,EAAE,IAAI,EAAE,SAAS,EAAE,GAAG,IAAI,CAAC,KAAK;QACvE,MAAM,EAAE,UAAU,EAAE,GAAG;QACvB,IAAI,CAAC,YACD,OAAO;QACX;;;;;;SAMC,GACD,WAAW,SAAS,GAAG;QACvB,sBAAsB;QACtB,IAAI,QACA,UAAU,gBAAgB,KAAK,oBAC/B,qBAAqB,aACrB,UAAU,SAAS,KAAK,WAAW;YACnC,WAAW,UAAU;QACzB,OACK;YACD,IAAI,CAAC,YAAY;QACrB;QACA,IAAI,UAAU,SAAS,KAAK,WAAW;YACnC,IAAI,WAAW;gBACX,WAAW,OAAO;YACtB,OACK,IAAI,CAAC,WAAW,QAAQ,IAAI;gBAC7B;;;;iBAIC,GACD,8KAAK,CAAC,UAAU,CAAC;oBACb,MAAM,QAAQ,WAAW,QAAQ;oBACjC,IAAI,CAAC,SAAS,CAAC,MAAM,OAAO,CAAC,MAAM,EAAE;wBACjC,IAAI,CAAC,YAAY;oBACrB;gBACJ;YACJ;QACJ;QACA,OAAO;IACX;IACA,qBAAqB;QACjB,MAAM,EAAE,UAAU,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC,aAAa;QAC/C,IAAI,YAAY;YACZ,WAAW,IAAI,CAAC,SAAS;YACzB,sLAAS,CAAC,UAAU,CAAC;gBACjB,IAAI,CAAC,WAAW,gBAAgB,IAAI,WAAW,MAAM,IAAI;oBACrD,IAAI,CAAC,YAAY;gBACrB;YACJ;QACJ;IACJ;IACA,uBAAuB;QACnB,MAAM,EAAE,aAAa,EAAE,WAAW,EAAE,mBAAmB,cAAc,EAAG,GAAG,IAAI,CAAC,KAAK;QACrF,MAAM,EAAE,UAAU,EAAE,GAAG;QACvB,sBAAsB;QACtB,IAAI,YAAY;YACZ,WAAW,yBAAyB;YACpC,IAAI,eAAe,YAAY,KAAK,EAChC,YAAY,KAAK,CAAC,MAAM,CAAC;YAC7B,IAAI,kBAAkB,eAAe,UAAU,EAC3C,eAAe,UAAU,CAAC;QAClC;IACJ;IACA,eAAe;QACX,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,CAAC,KAAK;QACnC,gBAAgB;IACpB;IACA,SAAS;QACL,OAAO;IACX;AACJ;AACA,SAAS,cAAc,KAAK;IACxB,MAAM,CAAC,WAAW,aAAa,GAAG,IAAA,qNAAW;IAC7C,MAAM,cAAc,IAAA,2KAAU,EAAC,yMAAkB;IACjD,OAAQ,IAAA,6KAAG,EAAC,0BAA0B;QAAE,GAAG,KAAK;QAAE,aAAa;QAAa,mBAAmB,IAAA,2KAAU,EAAC,qNAAwB;QAAG,WAAW;QAAW,cAAc;IAAa;AAC1L;AACA,MAAM,yBAAyB;IAC3B,cAAc;QACV,GAAG,8NAAmB;QACtB,SAAS;YACL;YACA;YACA;YACA;SACH;IACL;IACA,qBAAqB,8NAAmB;IACxC,sBAAsB,8NAAmB;IACzC,wBAAwB,8NAAmB;IAC3C,yBAAyB,8NAAmB;IAC5C,WAAW,wNAAgB;AAC/B&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">5242</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/animation/animate/single-value.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { isMotionValue, motionValue } from 'motion-dom';</span><span class="s3">\n</span><span class="s1">import { animateMotionValue } from '../interfaces/motion-value.mjs';</span><span class="s3">\n\n</span><span class="s1">function animateSingleValue(value, keyframes, options) {</span><span class="s3">\n    </span><span class="s1">const motionValue$1 = isMotionValue(value) ? value : motionValue(value);</span><span class="s3">\n    </span><span class="s1">motionValue$1.start(animateMotionValue(</span><span class="s3">\&quot;\&quot;</span><span class="s1">, motionValue$1, keyframes, options));</span><span class="s3">\n    </span><span class="s1">return motionValue$1.animation;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { animateSingleValue };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;AAAA;AACA;;;AAEA,SAAS,mBAAmB,KAAK,EAAE,SAAS,EAAE,OAAO;IACjD,MAAM,gBAAgB,IAAA,2MAAa,EAAC,SAAS,QAAQ,IAAA,gLAAW,EAAC;IACjE,cAAc,KAAK,CAAC,IAAA,sNAAkB,EAAC,IAAI,eAAe,WAAW;IACrE,OAAO,cAAc,SAAS;AAClC&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">5261</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/render/utils/compare-by-depth.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;const compareByDepth = (a, b) =&gt; a.depth - b.depth;</span><span class="s3">\n\n</span><span class="s1">export { compareByDepth };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA,MAAM,iBAAiB,CAAC,GAAG,IAAM,EAAE,KAAK,GAAG,EAAE,KAAK&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">5271</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/render/utils/flat-tree.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { addUniqueItem, removeItem } from 'motion-utils';</span><span class="s3">\n</span><span class="s1">import { compareByDepth } from './compare-by-depth.mjs';</span><span class="s3">\n\n</span><span class="s1">class FlatTree {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">this.children = [];</span><span class="s3">\n        </span><span class="s1">this.isDirty = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">add(child) {</span><span class="s3">\n        </span><span class="s1">addUniqueItem(this.children, child);</span><span class="s3">\n        </span><span class="s1">this.isDirty = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">remove(child) {</span><span class="s3">\n        </span><span class="s1">removeItem(this.children, child);</span><span class="s3">\n        </span><span class="s1">this.isDirty = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">forEach(callback) {</span><span class="s3">\n        </span><span class="s1">this.isDirty &amp;&amp; this.children.sort(compareByDepth);</span><span class="s3">\n        </span><span class="s1">this.isDirty = false;</span><span class="s3">\n        </span><span class="s1">this.children.forEach(callback);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { FlatTree };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;AACA;;;AAEA,MAAM;IAKF,IAAI,KAAK,EAAE;QACP,IAAA,2KAAa,EAAC,IAAI,CAAC,QAAQ,EAAE;QAC7B,IAAI,CAAC,OAAO,GAAG;IACnB;IACA,OAAO,KAAK,EAAE;QACV,IAAA,wKAAU,EAAC,IAAI,CAAC,QAAQ,EAAE;QAC1B,IAAI,CAAC,OAAO,GAAG;IACnB;IACA,QAAQ,QAAQ,EAAE;QACd,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,iNAAc;QACjD,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC;IAC1B;IAhBA,aAAc;QACV,IAAI,CAAC,QAAQ,GAAG,EAAE;QAClB,IAAI,CAAC,OAAO,GAAG;IACnB;AAcJ&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">5303</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/utils/delay.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { time, frame, cancelFrame } from 'motion-dom';</span><span class="s3">\n</span><span class="s1">import { secondsToMilliseconds } from 'motion-utils';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Timeout defined in ms</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function delay(callback, timeout) {</span><span class="s3">\n    </span><span class="s1">const start = time.now();</span><span class="s3">\n    </span><span class="s1">const checkElapsed = ({ timestamp }) =&gt; {</span><span class="s3">\n        </span><span class="s1">const elapsed = timestamp - start;</span><span class="s3">\n        </span><span class="s1">if (elapsed &gt;= timeout) {</span><span class="s3">\n            </span><span class="s1">cancelFrame(checkElapsed);</span><span class="s3">\n            </span><span class="s1">callback(elapsed - timeout);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">frame.setup(checkElapsed, true);</span><span class="s3">\n    </span><span class="s1">return () =&gt; cancelFrame(checkElapsed);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function delayInSeconds(callback, timeout) {</span><span class="s3">\n    </span><span class="s1">return delay(callback, secondsToMilliseconds(timeout));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { delay, delayInSeconds };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;AAAA;AAAA;AACA;;;AAEA;;CAEC,GACD,SAAS,MAAM,QAAQ,EAAE,OAAO;IAC5B,MAAM,QAAQ,oLAAI,CAAC,GAAG;IACtB,MAAM,eAAe;YAAC,EAAE,SAAS,EAAE;QAC/B,MAAM,UAAU,YAAY;QAC5B,IAAI,WAAW,SAAS;YACpB,IAAA,oLAAW,EAAC;YACZ,SAAS,UAAU;QACvB;IACJ;IACA,8KAAK,CAAC,KAAK,CAAC,cAAc;IAC1B,OAAO,IAAM,IAAA,oLAAW,EAAC;AAC7B;AACA,SAAS,eAAe,QAAQ,EAAE,OAAO;IACrC,OAAO,MAAM,UAAU,IAAA,gMAAqB,EAAC;AACjD&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">5337</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/projection/animation/mix-values.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { mixNumber, percent, px } from 'motion-dom';</span><span class="s3">\n</span><span class="s1">import { progress, circOut, noop } from 'motion-utils';</span><span class="s3">\n\n</span><span class="s1">const borders = [</span><span class="s3">\&quot;</span><span class="s1">TopLeft</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">TopRight</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">BottomLeft</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">BottomRight</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">const numBorders = borders.length;</span><span class="s3">\n</span><span class="s1">const asNumber = (value) =&gt; typeof value === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">? parseFloat(value) : value;</span><span class="s3">\n</span><span class="s1">const isPx = (value) =&gt; typeof value === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">|| px.test(value);</span><span class="s3">\n</span><span class="s1">function mixValues(target, follow, lead, progress, shouldCrossfadeOpacity, isOnlyMember) {</span><span class="s3">\n    </span><span class="s1">if (shouldCrossfadeOpacity) {</span><span class="s3">\n        </span><span class="s1">target.opacity = mixNumber(0, lead.opacity ?? 1, easeCrossfadeIn(progress));</span><span class="s3">\n        </span><span class="s1">target.opacityExit = mixNumber(follow.opacity ?? 1, 0, easeCrossfadeOut(progress));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (isOnlyMember) {</span><span class="s3">\n        </span><span class="s1">target.opacity = mixNumber(follow.opacity ?? 1, lead.opacity ?? 1, progress);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Mix border radius</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; numBorders; i++) {</span><span class="s3">\n        </span><span class="s1">const borderLabel = `border${borders[i]}Radius`;</span><span class="s3">\n        </span><span class="s1">let followRadius = getRadius(follow, borderLabel);</span><span class="s3">\n        </span><span class="s1">let leadRadius = getRadius(lead, borderLabel);</span><span class="s3">\n        </span><span class="s1">if (followRadius === undefined &amp;&amp; leadRadius === undefined)</span><span class="s3">\n            </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">followRadius || (followRadius = 0);</span><span class="s3">\n        </span><span class="s1">leadRadius || (leadRadius = 0);</span><span class="s3">\n        </span><span class="s1">const canMix = followRadius === 0 ||</span><span class="s3">\n            </span><span class="s1">leadRadius === 0 ||</span><span class="s3">\n            </span><span class="s1">isPx(followRadius) === isPx(leadRadius);</span><span class="s3">\n        </span><span class="s1">if (canMix) {</span><span class="s3">\n            </span><span class="s1">target[borderLabel] = Math.max(mixNumber(asNumber(followRadius), asNumber(leadRadius), progress), 0);</span><span class="s3">\n            </span><span class="s1">if (percent.test(leadRadius) || percent.test(followRadius)) {</span><span class="s3">\n                </span><span class="s1">target[borderLabel] += </span><span class="s3">\&quot;</span><span class="s1">%</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">target[borderLabel] = leadRadius;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Mix rotation</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">if (follow.rotate || lead.rotate) {</span><span class="s3">\n        </span><span class="s1">target.rotate = mixNumber(follow.rotate || 0, lead.rotate || 0, progress);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getRadius(values, radiusName) {</span><span class="s3">\n    </span><span class="s1">return values[radiusName] !== undefined</span><span class="s3">\n        </span><span class="s1">? values[radiusName]</span><span class="s3">\n        </span><span class="s1">: values.borderRadius;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// /**</span><span class="s3">\n</span><span class="s1">//  * We only want to mix the background color if there's a follow element</span><span class="s3">\n</span><span class="s1">//  * that we're not crossfading opacity between. For instance with switch</span><span class="s3">\n</span><span class="s1">//  * AnimateSharedLayout animations, this helps the illusion of a continuous</span><span class="s3">\n</span><span class="s1">//  * element being animated but also cuts down on the number of paints triggered</span><span class="s3">\n</span><span class="s1">//  * for elements where opacity is doing that work for us.</span><span class="s3">\n</span><span class="s1">//  */</span><span class="s3">\n</span><span class="s1">// if (</span><span class="s3">\n</span><span class="s1">//     !hasFollowElement &amp;&amp;</span><span class="s3">\n</span><span class="s1">//     latestLeadValues.backgroundColor &amp;&amp;</span><span class="s3">\n</span><span class="s1">//     latestFollowValues.backgroundColor</span><span class="s3">\n</span><span class="s1">// ) {</span><span class="s3">\n</span><span class="s1">//     /**</span><span class="s3">\n</span><span class="s1">//      * This isn't ideal performance-wise as mixColor is creating a new function every frame.</span><span class="s3">\n</span><span class="s1">//      * We could probably create a mixer that runs at the start of the animation but</span><span class="s3">\n</span><span class="s1">//      * the idea behind the crossfader is that it runs dynamically between two potentially</span><span class="s3">\n</span><span class="s1">//      * changing targets (ie opacity or borderRadius may be animating independently via variants)</span><span class="s3">\n</span><span class="s1">//      */</span><span class="s3">\n</span><span class="s1">//     leadState.backgroundColor = followState.backgroundColor = mixColor(</span><span class="s3">\n</span><span class="s1">//         latestFollowValues.backgroundColor as string,</span><span class="s3">\n</span><span class="s1">//         latestLeadValues.backgroundColor as string</span><span class="s3">\n</span><span class="s1">//     )(p)</span><span class="s3">\n</span><span class="s1">// }</span><span class="s3">\n</span><span class="s1">const easeCrossfadeIn = /*@__PURE__*/ compress(0, 0.5, circOut);</span><span class="s3">\n</span><span class="s1">const easeCrossfadeOut = /*@__PURE__*/ compress(0.5, 0.95, noop);</span><span class="s3">\n</span><span class="s1">function compress(min, max, easing) {</span><span class="s3">\n    </span><span class="s1">return (p) =&gt; {</span><span class="s3">\n        </span><span class="s1">// Could replace ifs with clamp</span><span class="s3">\n        </span><span class="s1">if (p &lt; min)</span><span class="s3">\n            </span><span class="s1">return 0;</span><span class="s3">\n        </span><span class="s1">if (p &gt; max)</span><span class="s3">\n            </span><span class="s1">return 1;</span><span class="s3">\n        </span><span class="s1">return easing(progress(min, max, p));</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { mixValues };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;AAAA;AACA;AAAA;AAAA;;;AAEA,MAAM,UAAU;IAAC;IAAW;IAAY;IAAc;CAAc;AACpE,MAAM,aAAa,QAAQ,MAAM;AACjC,MAAM,WAAW,CAAC,QAAU,OAAO,UAAU,WAAW,WAAW,SAAS;AAC5E,MAAM,OAAO,CAAC,QAAU,OAAO,UAAU,YAAY,2LAAE,CAAC,IAAI,CAAC;AAC7D,SAAS,UAAU,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,QAAQ,EAAE,sBAAsB,EAAE,YAAY;IACnF,IAAI,wBAAwB;YACM;QAA9B,OAAO,OAAO,GAAG,IAAA,sLAAS,EAAC,GAAG,CAAA,gBAAA,KAAK,OAAO,cAAZ,2BAAA,gBAAgB,GAAG,gBAAgB;YAClC;QAA/B,OAAO,WAAW,GAAG,IAAA,sLAAS,EAAC,CAAA,kBAAA,OAAO,OAAO,cAAd,6BAAA,kBAAkB,GAAG,GAAG,iBAAiB;IAC5E,OACK,IAAI,cAAc;YACQ,kBAAqB;QAAhD,OAAO,OAAO,GAAG,IAAA,sLAAS,EAAC,CAAA,mBAAA,OAAO,OAAO,cAAd,8BAAA,mBAAkB,GAAG,CAAA,iBAAA,KAAK,OAAO,cAAZ,4BAAA,iBAAgB,GAAG;IACvE;IACA;;KAEC,GACD,IAAK,IAAI,IAAI,GAAG,IAAI,YAAY,IAAK;QACjC,MAAM,cAAc,AAAC,SAAmB,OAAX,OAAO,CAAC,EAAE,EAAC;QACxC,IAAI,eAAe,UAAU,QAAQ;QACrC,IAAI,aAAa,UAAU,MAAM;QACjC,IAAI,iBAAiB,aAAa,eAAe,WAC7C;QACJ,gBAAgB,CAAC,eAAe,CAAC;QACjC,cAAc,CAAC,aAAa,CAAC;QAC7B,MAAM,SAAS,iBAAiB,KAC5B,eAAe,KACf,KAAK,kBAAkB,KAAK;QAChC,IAAI,QAAQ;YACR,MAAM,CAAC,YAAY,GAAG,KAAK,GAAG,CAAC,IAAA,sLAAS,EAAC,SAAS,eAAe,SAAS,aAAa,WAAW;YAClG,IAAI,gMAAO,CAAC,IAAI,CAAC,eAAe,gMAAO,CAAC,IAAI,CAAC,eAAe;gBACxD,MAAM,CAAC,YAAY,IAAI;YAC3B;QACJ,OACK;YACD,MAAM,CAAC,YAAY,GAAG;QAC1B;IACJ;IACA;;KAEC,GACD,IAAI,OAAO,MAAM,IAAI,KAAK,MAAM,EAAE;QAC9B,OAAO,MAAM,GAAG,IAAA,sLAAS,EAAC,OAAO,MAAM,IAAI,GAAG,KAAK,MAAM,IAAI,GAAG;IACpE;AACJ;AACA,SAAS,UAAU,MAAM,EAAE,UAAU;IACjC,OAAO,MAAM,CAAC,WAAW,KAAK,YACxB,MAAM,CAAC,WAAW,GAClB,OAAO,YAAY;AAC7B;AACA,MAAM;AACN,0EAA0E;AAC1E,0EAA0E;AAC1E,6EAA6E;AAC7E,iFAAiF;AACjF,2DAA2D;AAC3D,MAAM;AACN,OAAO;AACP,2BAA2B;AAC3B,0CAA0C;AAC1C,yCAAyC;AACzC,MAAM;AACN,UAAU;AACV,+FAA+F;AAC/F,sFAAsF;AACtF,4FAA4F;AAC5F,mGAAmG;AACnG,UAAU;AACV,0EAA0E;AAC1E,wDAAwD;AACxD,qDAAqD;AACrD,WAAW;AACX,IAAI;AACJ,MAAM,kBAAkB,WAAW,GAAG,SAAS,GAAG,KAAK,8KAAO;AAC9D,MAAM,mBAAmB,WAAW,GAAG,SAAS,KAAK,MAAM,iKAAI;AAC/D,SAAS,SAAS,GAAG,EAAE,GAAG,EAAE,MAAM;IAC9B,OAAO,CAAC;QACJ,+BAA+B;QAC/B,IAAI,IAAI,KACJ,OAAO;QACX,IAAI,IAAI,KACJ,OAAO;QACX,OAAO,OAAO,IAAA,yKAAQ,EAAC,KAAK,KAAK;IACrC;AACJ&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">5433</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/projection/geometry/copy.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Reset an axis to the provided origin box.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This is a mutative operation.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function copyAxisInto(axis, originAxis) {</span><span class="s3">\n    </span><span class="s1">axis.min = originAxis.min;</span><span class="s3">\n    </span><span class="s1">axis.max = originAxis.max;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Reset a box to the provided origin box.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This is a mutative operation.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function copyBoxInto(box, originBox) {</span><span class="s3">\n    </span><span class="s1">copyAxisInto(box.x, originBox.x);</span><span class="s3">\n    </span><span class="s1">copyAxisInto(box.y, originBox.y);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Reset a delta to the provided origin box.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This is a mutative operation.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function copyAxisDeltaInto(delta, originDelta) {</span><span class="s3">\n    </span><span class="s1">delta.translate = originDelta.translate;</span><span class="s3">\n    </span><span class="s1">delta.scale = originDelta.scale;</span><span class="s3">\n    </span><span class="s1">delta.originPoint = originDelta.originPoint;</span><span class="s3">\n    </span><span class="s1">delta.origin = originDelta.origin;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { copyAxisDeltaInto, copyAxisInto, copyBoxInto };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAA;;;;CAIC;;;;;;;;AACD,SAAS,aAAa,IAAI,EAAE,UAAU;IAClC,KAAK,GAAG,GAAG,WAAW,GAAG;IACzB,KAAK,GAAG,GAAG,WAAW,GAAG;AAC7B;AACA;;;;CAIC,GACD,SAAS,YAAY,GAAG,EAAE,SAAS;IAC/B,aAAa,IAAI,CAAC,EAAE,UAAU,CAAC;IAC/B,aAAa,IAAI,CAAC,EAAE,UAAU,CAAC;AACnC;AACA;;;;CAIC,GACD,SAAS,kBAAkB,KAAK,EAAE,WAAW;IACzC,MAAM,SAAS,GAAG,YAAY,SAAS;IACvC,MAAM,KAAK,GAAG,YAAY,KAAK;IAC/B,MAAM,WAAW,GAAG,YAAY,WAAW;IAC3C,MAAM,MAAM,GAAG,YAAY,MAAM;AACrC&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">5472</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/projection/geometry/delta-remove.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { percent, mixNumber } from 'motion-dom';</span><span class="s3">\n</span><span class="s1">import { scalePoint } from './delta-apply.mjs';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function removePointDelta(point, translate, scale, originPoint, boxScale) {</span><span class="s3">\n    </span><span class="s1">point -= translate;</span><span class="s3">\n    </span><span class="s1">point = scalePoint(point, 1 / scale, originPoint);</span><span class="s3">\n    </span><span class="s1">if (boxScale !== undefined) {</span><span class="s3">\n        </span><span class="s1">point = scalePoint(point, 1 / boxScale, originPoint);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return point;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function removeAxisDelta(axis, translate = 0, scale = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {</span><span class="s3">\n    </span><span class="s1">if (percent.test(translate)) {</span><span class="s3">\n        </span><span class="s1">translate = parseFloat(translate);</span><span class="s3">\n        </span><span class="s1">const relativeProgress = mixNumber(sourceAxis.min, sourceAxis.max, translate / 100);</span><span class="s3">\n        </span><span class="s1">translate = relativeProgress - sourceAxis.min;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (typeof translate !== </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">let originPoint = mixNumber(originAxis.min, originAxis.max, origin);</span><span class="s3">\n    </span><span class="s1">if (axis === originAxis)</span><span class="s3">\n        </span><span class="s1">originPoint -= translate;</span><span class="s3">\n    </span><span class="s1">axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);</span><span class="s3">\n    </span><span class="s1">axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse</span><span class="s3">\n </span><span class="s1">* and acts as a bridge between motion values and removeAxisDelta</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {</span><span class="s3">\n    </span><span class="s1">removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The names of the motion values we want to apply as translation, scale and origin.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const xKeys = [</span><span class="s3">\&quot;</span><span class="s1">x</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">scaleX</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">originX</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">const yKeys = [</span><span class="s3">\&quot;</span><span class="s1">y</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">scaleY</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">originY</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse</span><span class="s3">\n </span><span class="s1">* and acts as a bridge between motion values and removeAxisDelta</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function removeBoxTransforms(box, transforms, originBox, sourceBox) {</span><span class="s3">\n    </span><span class="s1">removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : undefined, sourceBox ? sourceBox.x : undefined);</span><span class="s3">\n    </span><span class="s1">removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : undefined, sourceBox ? sourceBox.y : undefined);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { removeAxisDelta, removeAxisTransforms, removeBoxTransforms, removePointDelta };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;AAAA;AAAA;AACA;;;AAEA;;CAEC,GACD,SAAS,iBAAiB,KAAK,EAAE,SAAS,EAAE,KAAK,EAAE,WAAW,EAAE,QAAQ;IACpE,SAAS;IACT,QAAQ,IAAA,4MAAU,EAAC,OAAO,IAAI,OAAO;IACrC,IAAI,aAAa,WAAW;QACxB,QAAQ,IAAA,4MAAU,EAAC,OAAO,IAAI,UAAU;IAC5C;IACA,OAAO;AACX;AACA;;CAEC,GACD,SAAS,gBAAgB,IAAI;QAAE,YAAA,iEAAY,GAAG,QAAA,iEAAQ,GAAG,SAAA,iEAAS,KAAK,yDAAU,aAAA,iEAAa,MAAM,aAAA,iEAAa;IAC7G,IAAI,gMAAO,CAAC,IAAI,CAAC,YAAY;QACzB,YAAY,WAAW;QACvB,MAAM,mBAAmB,IAAA,sLAAS,EAAC,WAAW,GAAG,EAAE,WAAW,GAAG,EAAE,YAAY;QAC/E,YAAY,mBAAmB,WAAW,GAAG;IACjD;IACA,IAAI,OAAO,cAAc,UACrB;IACJ,IAAI,cAAc,IAAA,sLAAS,EAAC,WAAW,GAAG,EAAE,WAAW,GAAG,EAAE;IAC5D,IAAI,SAAS,YACT,eAAe;IACnB,KAAK,GAAG,GAAG,iBAAiB,KAAK,GAAG,EAAE,WAAW,OAAO,aAAa;IACrE,KAAK,GAAG,GAAG,iBAAiB,KAAK,GAAG,EAAE,WAAW,OAAO,aAAa;AACzE;AACA;;;CAGC,GACD,SAAS,qBAAqB,IAAI,EAAE,UAAU,EAAE,KAA0B,EAAE,MAAM,EAAE,UAAU;QAA9C,CAAC,KAAK,UAAU,UAAU,GAA1B;IAC5C,gBAAgB,MAAM,UAAU,CAAC,IAAI,EAAE,UAAU,CAAC,SAAS,EAAE,UAAU,CAAC,UAAU,EAAE,WAAW,KAAK,EAAE,QAAQ;AAClH;AACA;;CAEC,GACD,MAAM,QAAQ;IAAC;IAAK;IAAU;CAAU;AACxC,MAAM,QAAQ;IAAC;IAAK;IAAU;CAAU;AACxC;;;CAGC,GACD,SAAS,oBAAoB,GAAG,EAAE,UAAU,EAAE,SAAS,EAAE,SAAS;IAC9D,qBAAqB,IAAI,CAAC,EAAE,YAAY,OAAO,YAAY,UAAU,CAAC,GAAG,WAAW,YAAY,UAAU,CAAC,GAAG;IAC9G,qBAAqB,IAAI,CAAC,EAAE,YAAY,OAAO,YAAY,UAAU,CAAC,GAAG,WAAW,YAAY,UAAU,CAAC,GAAG;AAClH&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">5543</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/projection/geometry/utils.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { calcLength } from './delta-calc.mjs';</span><span class="s3">\n\n</span><span class="s1">function isAxisDeltaZero(delta) {</span><span class="s3">\n    </span><span class="s1">return delta.translate === 0 &amp;&amp; delta.scale === 1;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function isDeltaZero(delta) {</span><span class="s3">\n    </span><span class="s1">return isAxisDeltaZero(delta.x) &amp;&amp; isAxisDeltaZero(delta.y);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function axisEquals(a, b) {</span><span class="s3">\n    </span><span class="s1">return a.min === b.min &amp;&amp; a.max === b.max;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function boxEquals(a, b) {</span><span class="s3">\n    </span><span class="s1">return axisEquals(a.x, b.x) &amp;&amp; axisEquals(a.y, b.y);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function axisEqualsRounded(a, b) {</span><span class="s3">\n    </span><span class="s1">return (Math.round(a.min) === Math.round(b.min) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">Math.round(a.max) === Math.round(b.max));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function boxEqualsRounded(a, b) {</span><span class="s3">\n    </span><span class="s1">return axisEqualsRounded(a.x, b.x) &amp;&amp; axisEqualsRounded(a.y, b.y);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function aspectRatio(box) {</span><span class="s3">\n    </span><span class="s1">return calcLength(box.x) / calcLength(box.y);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function axisDeltaEquals(a, b) {</span><span class="s3">\n    </span><span class="s1">return (a.translate === b.translate &amp;&amp;</span><span class="s3">\n        </span><span class="s1">a.scale === b.scale &amp;&amp;</span><span class="s3">\n        </span><span class="s1">a.originPoint === b.originPoint);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { aspectRatio, axisDeltaEquals, axisEquals, axisEqualsRounded, boxEquals, boxEqualsRounded, isDeltaZero };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;;AAAA;;AAEA,SAAS,gBAAgB,KAAK;IAC1B,OAAO,MAAM,SAAS,KAAK,KAAK,MAAM,KAAK,KAAK;AACpD;AACA,SAAS,YAAY,KAAK;IACtB,OAAO,gBAAgB,MAAM,CAAC,KAAK,gBAAgB,MAAM,CAAC;AAC9D;AACA,SAAS,WAAW,CAAC,EAAE,CAAC;IACpB,OAAO,EAAE,GAAG,KAAK,EAAE,GAAG,IAAI,EAAE,GAAG,KAAK,EAAE,GAAG;AAC7C;AACA,SAAS,UAAU,CAAC,EAAE,CAAC;IACnB,OAAO,WAAW,EAAE,CAAC,EAAE,EAAE,CAAC,KAAK,WAAW,EAAE,CAAC,EAAE,EAAE,CAAC;AACtD;AACA,SAAS,kBAAkB,CAAC,EAAE,CAAC;IAC3B,OAAQ,KAAK,KAAK,CAAC,EAAE,GAAG,MAAM,KAAK,KAAK,CAAC,EAAE,GAAG,KAC1C,KAAK,KAAK,CAAC,EAAE,GAAG,MAAM,KAAK,KAAK,CAAC,EAAE,GAAG;AAC9C;AACA,SAAS,iBAAiB,CAAC,EAAE,CAAC;IAC1B,OAAO,kBAAkB,EAAE,CAAC,EAAE,EAAE,CAAC,KAAK,kBAAkB,EAAE,CAAC,EAAE,EAAE,CAAC;AACpE;AACA,SAAS,YAAY,GAAG;IACpB,OAAO,IAAA,2MAAU,EAAC,IAAI,CAAC,IAAI,IAAA,2MAAU,EAAC,IAAI,CAAC;AAC/C;AACA,SAAS,gBAAgB,CAAC,EAAE,CAAC;IACzB,OAAQ,EAAE,SAAS,KAAK,EAAE,SAAS,IAC/B,EAAE,KAAK,KAAK,EAAE,KAAK,IACnB,EAAE,WAAW,KAAK,EAAE,WAAW;AACvC&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">5590</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/projection/shared/stack.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { addUniqueItem, removeItem } from 'motion-utils';</span><span class="s3">\n\n</span><span class="s1">class NodeStack {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">this.members = [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">add(node) {</span><span class="s3">\n        </span><span class="s1">addUniqueItem(this.members, node);</span><span class="s3">\n        </span><span class="s1">node.scheduleRender();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">remove(node) {</span><span class="s3">\n        </span><span class="s1">removeItem(this.members, node);</span><span class="s3">\n        </span><span class="s1">if (node === this.prevLead) {</span><span class="s3">\n            </span><span class="s1">this.prevLead = undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (node === this.lead) {</span><span class="s3">\n            </span><span class="s1">const prevLead = this.members[this.members.length - 1];</span><span class="s3">\n            </span><span class="s1">if (prevLead) {</span><span class="s3">\n                </span><span class="s1">this.promote(prevLead);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">relegate(node) {</span><span class="s3">\n        </span><span class="s1">const indexOfNode = this.members.findIndex((member) =&gt; node === member);</span><span class="s3">\n        </span><span class="s1">if (indexOfNode === 0)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Find the next projection node that is present</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">let prevLead;</span><span class="s3">\n        </span><span class="s1">for (let i = indexOfNode; i &gt;= 0; i--) {</span><span class="s3">\n            </span><span class="s1">const member = this.members[i];</span><span class="s3">\n            </span><span class="s1">if (member.isPresent !== false) {</span><span class="s3">\n                </span><span class="s1">prevLead = member;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (prevLead) {</span><span class="s3">\n            </span><span class="s1">this.promote(prevLead);</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">promote(node, preserveFollowOpacity) {</span><span class="s3">\n        </span><span class="s1">const prevLead = this.lead;</span><span class="s3">\n        </span><span class="s1">if (node === prevLead)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">this.prevLead = prevLead;</span><span class="s3">\n        </span><span class="s1">this.lead = node;</span><span class="s3">\n        </span><span class="s1">node.show();</span><span class="s3">\n        </span><span class="s1">if (prevLead) {</span><span class="s3">\n            </span><span class="s1">prevLead.instance &amp;&amp; prevLead.scheduleRender();</span><span class="s3">\n            </span><span class="s1">node.scheduleRender();</span><span class="s3">\n            </span><span class="s1">node.resumeFrom = prevLead;</span><span class="s3">\n            </span><span class="s1">if (preserveFollowOpacity) {</span><span class="s3">\n                </span><span class="s1">node.resumeFrom.preserveOpacity = true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (prevLead.snapshot) {</span><span class="s3">\n                </span><span class="s1">node.snapshot = prevLead.snapshot;</span><span class="s3">\n                </span><span class="s1">node.snapshot.latestValues =</span><span class="s3">\n                    </span><span class="s1">prevLead.animationValues || prevLead.latestValues;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (node.root &amp;&amp; node.root.isUpdating) {</span><span class="s3">\n                </span><span class="s1">node.isLayoutDirty = true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const { crossfade } = node.options;</span><span class="s3">\n            </span><span class="s1">if (crossfade === false) {</span><span class="s3">\n                </span><span class="s1">prevLead.hide();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* TODO:</span><span class="s3">\n             </span><span class="s1">*   - Test border radius when previous node was deleted</span><span class="s3">\n             </span><span class="s1">*   - boxShadow mixing</span><span class="s3">\n             </span><span class="s1">*   - Shared between element A in scrolled container and element B (scroll stays the same or changes)</span><span class="s3">\n             </span><span class="s1">*   - Shared between element A in transformed container and element B (transform stays the same or changes)</span><span class="s3">\n             </span><span class="s1">*   - Shared between element A in scrolled page and element B (scroll stays the same or changes)</span><span class="s3">\n             </span><span class="s1">* ---</span><span class="s3">\n             </span><span class="s1">*   - Crossfade opacity of root nodes</span><span class="s3">\n             </span><span class="s1">*   - layoutId changes after animation</span><span class="s3">\n             </span><span class="s1">*   - layoutId changes mid animation</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">exitAnimationComplete() {</span><span class="s3">\n        </span><span class="s1">this.members.forEach((node) =&gt; {</span><span class="s3">\n            </span><span class="s1">const { options, resumingFrom } = node;</span><span class="s3">\n            </span><span class="s1">options.onExitComplete &amp;&amp; options.onExitComplete();</span><span class="s3">\n            </span><span class="s1">if (resumingFrom) {</span><span class="s3">\n                </span><span class="s1">resumingFrom.options.onExitComplete &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">resumingFrom.options.onExitComplete();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">scheduleRender() {</span><span class="s3">\n        </span><span class="s1">this.members.forEach((node) =&gt; {</span><span class="s3">\n            </span><span class="s1">node.instance &amp;&amp; node.scheduleRender(false);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Clear any leads that have been removed this render to prevent them from being</span><span class="s3">\n     </span><span class="s1">* used in future animations and to prevent memory leaks</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">removeLeadSnapshot() {</span><span class="s3">\n        </span><span class="s1">if (this.lead &amp;&amp; this.lead.snapshot) {</span><span class="s3">\n            </span><span class="s1">this.lead.snapshot = undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { NodeStack };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;;AAEA,MAAM;IAIF,IAAI,IAAI,EAAE;QACN,IAAA,2KAAa,EAAC,IAAI,CAAC,OAAO,EAAE;QAC5B,KAAK,cAAc;IACvB;IACA,OAAO,IAAI,EAAE;QACT,IAAA,wKAAU,EAAC,IAAI,CAAC,OAAO,EAAE;QACzB,IAAI,SAAS,IAAI,CAAC,QAAQ,EAAE;YACxB,IAAI,CAAC,QAAQ,GAAG;QACpB;QACA,IAAI,SAAS,IAAI,CAAC,IAAI,EAAE;YACpB,MAAM,WAAW,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,EAAE;YACtD,IAAI,UAAU;gBACV,IAAI,CAAC,OAAO,CAAC;YACjB;QACJ;IACJ;IACA,SAAS,IAAI,EAAE;QACX,MAAM,cAAc,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC,SAAW,SAAS;QAChE,IAAI,gBAAgB,GAChB,OAAO;QACX;;SAEC,GACD,IAAI;QACJ,IAAK,IAAI,IAAI,aAAa,KAAK,GAAG,IAAK;YACnC,MAAM,SAAS,IAAI,CAAC,OAAO,CAAC,EAAE;YAC9B,IAAI,OAAO,SAAS,KAAK,OAAO;gBAC5B,WAAW;gBACX;YACJ;QACJ;QACA,IAAI,UAAU;YACV,IAAI,CAAC,OAAO,CAAC;YACb,OAAO;QACX,OACK;YACD,OAAO;QACX;IACJ;IACA,QAAQ,IAAI,EAAE,qBAAqB,EAAE;QACjC,MAAM,WAAW,IAAI,CAAC,IAAI;QAC1B,IAAI,SAAS,UACT;QACJ,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,IAAI,GAAG;QACZ,KAAK,IAAI;QACT,IAAI,UAAU;YACV,SAAS,QAAQ,IAAI,SAAS,cAAc;YAC5C,KAAK,cAAc;YACnB,KAAK,UAAU,GAAG;YAClB,IAAI,uBAAuB;gBACvB,KAAK,UAAU,CAAC,eAAe,GAAG;YACtC;YACA,IAAI,SAAS,QAAQ,EAAE;gBACnB,KAAK,QAAQ,GAAG,SAAS,QAAQ;gBACjC,KAAK,QAAQ,CAAC,YAAY,GACtB,SAAS,eAAe,IAAI,SAAS,YAAY;YACzD;YACA,IAAI,KAAK,IAAI,IAAI,KAAK,IAAI,CAAC,UAAU,EAAE;gBACnC,KAAK,aAAa,GAAG;YACzB;YACA,MAAM,EAAE,SAAS,EAAE,GAAG,KAAK,OAAO;YAClC,IAAI,cAAc,OAAO;gBACrB,SAAS,IAAI;YACjB;QACA;;;;;;;;;;;aAWC,GACL;IACJ;IACA,wBAAwB;QACpB,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;YAClB,MAAM,EAAE,OAAO,EAAE,YAAY,EAAE,GAAG;YAClC,QAAQ,cAAc,IAAI,QAAQ,cAAc;YAChD,IAAI,cAAc;gBACd,aAAa,OAAO,CAAC,cAAc,IAC/B,aAAa,OAAO,CAAC,cAAc;YAC3C;QACJ;IACJ;IACA,iBAAiB;QACb,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;YAClB,KAAK,QAAQ,IAAI,KAAK,cAAc,CAAC;QACzC;IACJ;IACA;;;KAGC,GACD,qBAAqB;QACjB,IAAI,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;YACjC,IAAI,CAAC,IAAI,CAAC,QAAQ,GAAG;QACzB;IACJ;IAzGA,aAAc;QACV,IAAI,CAAC,OAAO,GAAG,EAAE;IACrB;AAwGJ&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">5701</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/projection/styles/transform.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;function buildProjectionTransform(delta, treeScale, latestTransform) {</span><span class="s3">\n    </span><span class="s1">let transform = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The translations we use to calculate are always relative to the viewport coordinate space.</span><span class="s3">\n     </span><span class="s1">* But when we apply scales, we also scale the coordinate space of an element and its children.</span><span class="s3">\n     </span><span class="s1">* For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need</span><span class="s3">\n     </span><span class="s1">* to move an element 100 pixels, we actually need to move it 200 in within that scaled space.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">const xTranslate = delta.x.translate / treeScale.x;</span><span class="s3">\n    </span><span class="s1">const yTranslate = delta.y.translate / treeScale.y;</span><span class="s3">\n    </span><span class="s1">const zTranslate = latestTransform?.z || 0;</span><span class="s3">\n    </span><span class="s1">if (xTranslate || yTranslate || zTranslate) {</span><span class="s3">\n        </span><span class="s1">transform = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Apply scale correction for the tree transform.</span><span class="s3">\n     </span><span class="s1">* This will apply scale to the screen-orientated axes.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">if (treeScale.x !== 1 || treeScale.y !== 1) {</span><span class="s3">\n        </span><span class="s1">transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (latestTransform) {</span><span class="s3">\n        </span><span class="s1">const { transformPerspective, rotate, rotateX, rotateY, skewX, skewY } = latestTransform;</span><span class="s3">\n        </span><span class="s1">if (transformPerspective)</span><span class="s3">\n            </span><span class="s1">transform = `perspective(${transformPerspective}px) ${transform}`;</span><span class="s3">\n        </span><span class="s1">if (rotate)</span><span class="s3">\n            </span><span class="s1">transform += `rotate(${rotate}deg) `;</span><span class="s3">\n        </span><span class="s1">if (rotateX)</span><span class="s3">\n            </span><span class="s1">transform += `rotateX(${rotateX}deg) `;</span><span class="s3">\n        </span><span class="s1">if (rotateY)</span><span class="s3">\n            </span><span class="s1">transform += `rotateY(${rotateY}deg) `;</span><span class="s3">\n        </span><span class="s1">if (skewX)</span><span class="s3">\n            </span><span class="s1">transform += `skewX(${skewX}deg) `;</span><span class="s3">\n        </span><span class="s1">if (skewY)</span><span class="s3">\n            </span><span class="s1">transform += `skewY(${skewY}deg) `;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Apply scale to match the size of the element to the size we want it.</span><span class="s3">\n     </span><span class="s1">* This will apply scale to the element-orientated axes.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">const elementScaleX = delta.x.scale * treeScale.x;</span><span class="s3">\n    </span><span class="s1">const elementScaleY = delta.y.scale * treeScale.y;</span><span class="s3">\n    </span><span class="s1">if (elementScaleX !== 1 || elementScaleY !== 1) {</span><span class="s3">\n        </span><span class="s1">transform += `scale(${elementScaleX}, ${elementScaleY})`;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return transform || </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { buildProjectionTransform };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA,SAAS,yBAAyB,KAAK,EAAE,SAAS,EAAE,eAAe;IAC/D,IAAI,YAAY;IAChB;;;;;KAKC,GACD,MAAM,aAAa,MAAM,CAAC,CAAC,SAAS,GAAG,UAAU,CAAC;IAClD,MAAM,aAAa,MAAM,CAAC,CAAC,SAAS,GAAG,UAAU,CAAC;IAClD,MAAM,aAAa,CAAA,4BAAA,sCAAA,gBAAiB,CAAC,KAAI;IACzC,IAAI,cAAc,cAAc,YAAY;QACxC,YAAY,AAAC,eAA+B,OAAjB,YAAW,QAAuB,OAAjB,YAAW,QAAiB,OAAX,YAAW;IAC5E;IACA;;;KAGC,GACD,IAAI,UAAU,CAAC,KAAK,KAAK,UAAU,CAAC,KAAK,GAAG;QACxC,aAAa,AAAC,SAA4B,OAApB,IAAI,UAAU,CAAC,EAAC,MAAoB,OAAhB,IAAI,UAAU,CAAC,EAAC;IAC9D;IACA,IAAI,iBAAiB;QACjB,MAAM,EAAE,oBAAoB,EAAE,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,KAAK,EAAE,KAAK,EAAE,GAAG;QACzE,IAAI,sBACA,YAAY,AAAC,eAAyC,OAA3B,sBAAqB,QAAgB,OAAV;QAC1D,IAAI,QACA,aAAa,AAAC,UAAgB,OAAP,QAAO;QAClC,IAAI,SACA,aAAa,AAAC,WAAkB,OAAR,SAAQ;QACpC,IAAI,SACA,aAAa,AAAC,WAAkB,OAAR,SAAQ;QACpC,IAAI,OACA,aAAa,AAAC,SAAc,OAAN,OAAM;QAChC,IAAI,OACA,aAAa,AAAC,SAAc,OAAN,OAAM;IACpC;IACA;;;KAGC,GACD,MAAM,gBAAgB,MAAM,CAAC,CAAC,KAAK,GAAG,UAAU,CAAC;IACjD,MAAM,gBAAgB,MAAM,CAAC,CAAC,KAAK,GAAG,UAAU,CAAC;IACjD,IAAI,kBAAkB,KAAK,kBAAkB,GAAG;QAC5C,aAAa,AAAC,SAA0B,OAAlB,eAAc,MAAkB,OAAd,eAAc;IAC1D;IACA,OAAO,aAAa;AACxB&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">5748</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/projection/node/create-projection-node.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { statsBuffer, isSVGElement, isSVGSVGElement, frame, getValueTransition, cancelFrame, time, frameData, frameSteps, microtask, activeAnimations, motionValue, mixNumber } from 'motion-dom';</span><span class="s3">\n</span><span class="s1">import { SubscriptionManager, clamp, noop } from 'motion-utils';</span><span class="s3">\n</span><span class="s1">import { animateSingleValue } from '../../animation/animate/single-value.mjs';</span><span class="s3">\n</span><span class="s1">import { getOptimisedAppearId } from '../../animation/optimized-appear/get-appear-id.mjs';</span><span class="s3">\n</span><span class="s1">import { FlatTree } from '../../render/utils/flat-tree.mjs';</span><span class="s3">\n</span><span class="s1">import { delay } from '../../utils/delay.mjs';</span><span class="s3">\n</span><span class="s1">import { resolveMotionValue } from '../../value/utils/resolve-motion-value.mjs';</span><span class="s3">\n</span><span class="s1">import { mixValues } from '../animation/mix-values.mjs';</span><span class="s3">\n</span><span class="s1">import { copyBoxInto, copyAxisDeltaInto } from '../geometry/copy.mjs';</span><span class="s3">\n</span><span class="s1">import { translateAxis, transformBox, applyBoxDelta, applyTreeDeltas } from '../geometry/delta-apply.mjs';</span><span class="s3">\n</span><span class="s1">import { calcLength, calcRelativePosition, calcRelativeBox, calcBoxDelta, isNear } from '../geometry/delta-calc.mjs';</span><span class="s3">\n</span><span class="s1">import { removeBoxTransforms } from '../geometry/delta-remove.mjs';</span><span class="s3">\n</span><span class="s1">import { createBox, createDelta } from '../geometry/models.mjs';</span><span class="s3">\n</span><span class="s1">import { boxEqualsRounded, isDeltaZero, axisDeltaEquals, aspectRatio, boxEquals } from '../geometry/utils.mjs';</span><span class="s3">\n</span><span class="s1">import { NodeStack } from '../shared/stack.mjs';</span><span class="s3">\n</span><span class="s1">import { scaleCorrectors } from '../styles/scale-correction.mjs';</span><span class="s3">\n</span><span class="s1">import { buildProjectionTransform } from '../styles/transform.mjs';</span><span class="s3">\n</span><span class="s1">import { eachAxis } from '../utils/each-axis.mjs';</span><span class="s3">\n</span><span class="s1">import { hasTransform, hasScale, has2DTranslate } from '../utils/has-transform.mjs';</span><span class="s3">\n</span><span class="s1">import { globalProjectionState } from './state.mjs';</span><span class="s3">\n\n</span><span class="s1">const metrics = {</span><span class="s3">\n    </span><span class="s1">nodes: 0,</span><span class="s3">\n    </span><span class="s1">calculatedTargetDeltas: 0,</span><span class="s3">\n    </span><span class="s1">calculatedProjections: 0,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const transformAxes = [</span><span class="s3">\&quot;\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">X</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">Y</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">Z</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* We use 1000 as the animation target as 0-1000 maps better to pixels than 0-1</span><span class="s3">\n </span><span class="s1">* which has a noticeable difference in spring animations</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const animationTarget = 1000;</span><span class="s3">\n</span><span class="s1">let id = 0;</span><span class="s3">\n</span><span class="s1">function resetDistortingTransform(key, visualElement, values, sharedAnimationValues) {</span><span class="s3">\n    </span><span class="s1">const { latestValues } = visualElement;</span><span class="s3">\n    </span><span class="s1">// Record the distorting transform and then temporarily set it to 0</span><span class="s3">\n    </span><span class="s1">if (latestValues[key]) {</span><span class="s3">\n        </span><span class="s1">values[key] = latestValues[key];</span><span class="s3">\n        </span><span class="s1">visualElement.setStaticValue(key, 0);</span><span class="s3">\n        </span><span class="s1">if (sharedAnimationValues) {</span><span class="s3">\n            </span><span class="s1">sharedAnimationValues[key] = 0;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function cancelTreeOptimisedTransformAnimations(projectionNode) {</span><span class="s3">\n    </span><span class="s1">projectionNode.hasCheckedOptimisedAppear = true;</span><span class="s3">\n    </span><span class="s1">if (projectionNode.root === projectionNode)</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">const { visualElement } = projectionNode.options;</span><span class="s3">\n    </span><span class="s1">if (!visualElement)</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">const appearId = getOptimisedAppearId(visualElement);</span><span class="s3">\n    </span><span class="s1">if (window.MotionHasOptimisedAnimation(appearId, </span><span class="s3">\&quot;</span><span class="s1">transform</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n        </span><span class="s1">const { layout, layoutId } = projectionNode.options;</span><span class="s3">\n        </span><span class="s1">window.MotionCancelOptimisedAnimation(appearId, </span><span class="s3">\&quot;</span><span class="s1">transform</span><span class="s3">\&quot;</span><span class="s1">, frame, !(layout || layoutId));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const { parent } = projectionNode;</span><span class="s3">\n    </span><span class="s1">if (parent &amp;&amp; !parent.hasCheckedOptimisedAppear) {</span><span class="s3">\n        </span><span class="s1">cancelTreeOptimisedTransformAnimations(parent);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform, }) {</span><span class="s3">\n    </span><span class="s1">return class ProjectionNode {</span><span class="s3">\n        </span><span class="s1">constructor(latestValues = {}, parent = defaultParent?.()) {</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* A unique ID generated for every projection node.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">this.id = id++;</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* An id that represents a unique session instigated by startUpdate.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">this.animationId = 0;</span><span class="s3">\n            </span><span class="s1">this.animationCommitId = 0;</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* A Set containing all this component's children. This is used to iterate</span><span class="s3">\n             </span><span class="s1">* through the children.</span><span class="s3">\n             </span><span class="s1">*</span><span class="s3">\n             </span><span class="s1">* TODO: This could be faster to iterate as a flat array stored on the root node.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">this.children = new Set();</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* Options for the node. We use this to configure what kind of layout animations</span><span class="s3">\n             </span><span class="s1">* we should perform (if any).</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">this.options = {};</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* We use this to detect when its safe to shut down part of a projection tree.</span><span class="s3">\n             </span><span class="s1">* We have to keep projecting children for scale correction and relative projection</span><span class="s3">\n             </span><span class="s1">* until all their parents stop performing layout animations.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">this.isTreeAnimating = false;</span><span class="s3">\n            </span><span class="s1">this.isAnimationBlocked = false;</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* Flag to true if we think this layout has been changed. We can't always know this,</span><span class="s3">\n             </span><span class="s1">* currently we set it to true every time a component renders, or if it has a layoutDependency</span><span class="s3">\n             </span><span class="s1">* if that has changed between renders. Additionally, components can be grouped by LayoutGroup</span><span class="s3">\n             </span><span class="s1">* and if one node is dirtied, they all are.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">this.isLayoutDirty = false;</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* Flag to true if we think the projection calculations for this node needs</span><span class="s3">\n             </span><span class="s1">* recalculating as a result of an updated transform or layout animation.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">this.isProjectionDirty = false;</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* Flag to true if the layout *or* transform has changed. This then gets propagated</span><span class="s3">\n             </span><span class="s1">* throughout the projection tree, forcing any element below to recalculate on the next frame.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">this.isSharedProjectionDirty = false;</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* Flag transform dirty. This gets propagated throughout the whole tree but is only</span><span class="s3">\n             </span><span class="s1">* respected by shared nodes.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">this.isTransformDirty = false;</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* Block layout updates for instant layout transitions throughout the tree.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">this.updateManuallyBlocked = false;</span><span class="s3">\n            </span><span class="s1">this.updateBlockedByResize = false;</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* Set to true between the start of the first `willUpdate` call and the end of the `didUpdate`</span><span class="s3">\n             </span><span class="s1">* call.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">this.isUpdating = false;</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* If this is an SVG element we currently disable projection transforms</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">this.isSVG = false;</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* Flag to true (during promotion) if a node doing an instant layout transition needs to reset</span><span class="s3">\n             </span><span class="s1">* its projection styles.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">this.needsReset = false;</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* Flags whether this node should have its transform reset prior to measuring.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">this.shouldResetTransform = false;</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* Store whether this node has been checked for optimised appear animations. As</span><span class="s3">\n             </span><span class="s1">* effects fire bottom-up, and we want to look up the tree for appear animations,</span><span class="s3">\n             </span><span class="s1">* this makes sure we only check each path once, stopping at nodes that</span><span class="s3">\n             </span><span class="s1">* have already been checked.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">this.hasCheckedOptimisedAppear = false;</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* An object representing the calculated contextual/accumulated/tree scale.</span><span class="s3">\n             </span><span class="s1">* This will be used to scale calculcated projection transforms, as these are</span><span class="s3">\n             </span><span class="s1">* calculated in screen-space but need to be scaled for elements to layoutly</span><span class="s3">\n             </span><span class="s1">* make it to their calculated destinations.</span><span class="s3">\n             </span><span class="s1">*</span><span class="s3">\n             </span><span class="s1">* TODO: Lazy-init</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">this.treeScale = { x: 1, y: 1 };</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">*</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">this.eventHandlers = new Map();</span><span class="s3">\n            </span><span class="s1">this.hasTreeAnimated = false;</span><span class="s3">\n            </span><span class="s1">// Note: Currently only running on root node</span><span class="s3">\n            </span><span class="s1">this.updateScheduled = false;</span><span class="s3">\n            </span><span class="s1">this.scheduleUpdate = () =&gt; this.update();</span><span class="s3">\n            </span><span class="s1">this.projectionUpdateScheduled = false;</span><span class="s3">\n            </span><span class="s1">this.checkUpdateFailed = () =&gt; {</span><span class="s3">\n                </span><span class="s1">if (this.isUpdating) {</span><span class="s3">\n                    </span><span class="s1">this.isUpdating = false;</span><span class="s3">\n                    </span><span class="s1">this.clearAllSnapshots();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* This is a multi-step process as shared nodes might be of different depths. Nodes</span><span class="s3">\n             </span><span class="s1">* are sorted by depth order, so we need to resolve the entire tree before moving to</span><span class="s3">\n             </span><span class="s1">* the next step.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">this.updateProjection = () =&gt; {</span><span class="s3">\n                </span><span class="s1">this.projectionUpdateScheduled = false;</span><span class="s3">\n                </span><span class="s1">/**</span><span class="s3">\n                 </span><span class="s1">* Reset debug counts. Manually resetting rather than creating a new</span><span class="s3">\n                 </span><span class="s1">* object each frame.</span><span class="s3">\n                 </span><span class="s1">*/</span><span class="s3">\n                </span><span class="s1">if (statsBuffer.value) {</span><span class="s3">\n                    </span><span class="s1">metrics.nodes =</span><span class="s3">\n                        </span><span class="s1">metrics.calculatedTargetDeltas =</span><span class="s3">\n                            </span><span class="s1">metrics.calculatedProjections =</span><span class="s3">\n                                </span><span class="s1">0;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">this.nodes.forEach(propagateDirtyNodes);</span><span class="s3">\n                </span><span class="s1">this.nodes.forEach(resolveTargetDelta);</span><span class="s3">\n                </span><span class="s1">this.nodes.forEach(calcProjection);</span><span class="s3">\n                </span><span class="s1">this.nodes.forEach(cleanDirtyNodes);</span><span class="s3">\n                </span><span class="s1">if (statsBuffer.addProjectionMetrics) {</span><span class="s3">\n                    </span><span class="s1">statsBuffer.addProjectionMetrics(metrics);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* Frame calculations</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">this.resolvedRelativeTargetAt = 0.0;</span><span class="s3">\n            </span><span class="s1">this.hasProjected = false;</span><span class="s3">\n            </span><span class="s1">this.isVisible = true;</span><span class="s3">\n            </span><span class="s1">this.animationProgress = 0;</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* Shared layout</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">// TODO Only running on root node</span><span class="s3">\n            </span><span class="s1">this.sharedNodes = new Map();</span><span class="s3">\n            </span><span class="s1">this.latestValues = latestValues;</span><span class="s3">\n            </span><span class="s1">this.root = parent ? parent.root || parent : this;</span><span class="s3">\n            </span><span class="s1">this.path = parent ? [...parent.path, parent] : [];</span><span class="s3">\n            </span><span class="s1">this.parent = parent;</span><span class="s3">\n            </span><span class="s1">this.depth = parent ? parent.depth + 1 : 0;</span><span class="s3">\n            </span><span class="s1">for (let i = 0; i &lt; this.path.length; i++) {</span><span class="s3">\n                </span><span class="s1">this.path[i].shouldResetTransform = true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (this.root === this)</span><span class="s3">\n                </span><span class="s1">this.nodes = new FlatTree();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">addEventListener(name, handler) {</span><span class="s3">\n            </span><span class="s1">if (!this.eventHandlers.has(name)) {</span><span class="s3">\n                </span><span class="s1">this.eventHandlers.set(name, new SubscriptionManager());</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return this.eventHandlers.get(name).add(handler);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">notifyListeners(name, ...args) {</span><span class="s3">\n            </span><span class="s1">const subscriptionManager = this.eventHandlers.get(name);</span><span class="s3">\n            </span><span class="s1">subscriptionManager &amp;&amp; subscriptionManager.notify(...args);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">hasListeners(name) {</span><span class="s3">\n            </span><span class="s1">return this.eventHandlers.has(name);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Lifecycles</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">mount(instance) {</span><span class="s3">\n            </span><span class="s1">if (this.instance)</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">this.isSVG = isSVGElement(instance) &amp;&amp; !isSVGSVGElement(instance);</span><span class="s3">\n            </span><span class="s1">this.instance = instance;</span><span class="s3">\n            </span><span class="s1">const { layoutId, layout, visualElement } = this.options;</span><span class="s3">\n            </span><span class="s1">if (visualElement &amp;&amp; !visualElement.current) {</span><span class="s3">\n                </span><span class="s1">visualElement.mount(instance);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this.root.nodes.add(this);</span><span class="s3">\n            </span><span class="s1">this.parent &amp;&amp; this.parent.children.add(this);</span><span class="s3">\n            </span><span class="s1">if (this.root.hasTreeAnimated &amp;&amp; (layout || layoutId)) {</span><span class="s3">\n                </span><span class="s1">this.isLayoutDirty = true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (attachResizeListener) {</span><span class="s3">\n                </span><span class="s1">let cancelDelay;</span><span class="s3">\n                </span><span class="s1">let innerWidth = 0;</span><span class="s3">\n                </span><span class="s1">const resizeUnblockUpdate = () =&gt; (this.root.updateBlockedByResize = false);</span><span class="s3">\n                </span><span class="s1">// Set initial innerWidth in a frame.read callback to batch the read</span><span class="s3">\n                </span><span class="s1">frame.read(() =&gt; {</span><span class="s3">\n                    </span><span class="s1">innerWidth = window.innerWidth;</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">attachResizeListener(instance, () =&gt; {</span><span class="s3">\n                    </span><span class="s1">const newInnerWidth = window.innerWidth;</span><span class="s3">\n                    </span><span class="s1">if (newInnerWidth === innerWidth)</span><span class="s3">\n                        </span><span class="s1">return;</span><span class="s3">\n                    </span><span class="s1">innerWidth = newInnerWidth;</span><span class="s3">\n                    </span><span class="s1">this.root.updateBlockedByResize = true;</span><span class="s3">\n                    </span><span class="s1">cancelDelay &amp;&amp; cancelDelay();</span><span class="s3">\n                    </span><span class="s1">cancelDelay = delay(resizeUnblockUpdate, 250);</span><span class="s3">\n                    </span><span class="s1">if (globalProjectionState.hasAnimatedSinceResize) {</span><span class="s3">\n                        </span><span class="s1">globalProjectionState.hasAnimatedSinceResize = false;</span><span class="s3">\n                        </span><span class="s1">this.nodes.forEach(finishAnimation);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (layoutId) {</span><span class="s3">\n                </span><span class="s1">this.root.registerSharedNode(layoutId, this);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Only register the handler if it requires layout animation</span><span class="s3">\n            </span><span class="s1">if (this.options.animate !== false &amp;&amp;</span><span class="s3">\n                </span><span class="s1">visualElement &amp;&amp;</span><span class="s3">\n                </span><span class="s1">(layoutId || layout)) {</span><span class="s3">\n                </span><span class="s1">this.addEventListener(</span><span class="s3">\&quot;</span><span class="s1">didUpdate</span><span class="s3">\&quot;</span><span class="s1">, ({ delta, hasLayoutChanged, hasRelativeLayoutChanged, layout: newLayout, }) =&gt; {</span><span class="s3">\n                    </span><span class="s1">if (this.isTreeAnimationBlocked()) {</span><span class="s3">\n                        </span><span class="s1">this.target = undefined;</span><span class="s3">\n                        </span><span class="s1">this.relativeTarget = undefined;</span><span class="s3">\n                        </span><span class="s1">return;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">// TODO: Check here if an animation exists</span><span class="s3">\n                    </span><span class="s1">const layoutTransition = this.options.transition ||</span><span class="s3">\n                        </span><span class="s1">visualElement.getDefaultTransition() ||</span><span class="s3">\n                        </span><span class="s1">defaultLayoutTransition;</span><span class="s3">\n                    </span><span class="s1">const { onLayoutAnimationStart, onLayoutAnimationComplete, } = visualElement.getProps();</span><span class="s3">\n                    </span><span class="s1">/**</span><span class="s3">\n                     </span><span class="s1">* The target layout of the element might stay the same,</span><span class="s3">\n                     </span><span class="s1">* but its position relative to its parent has changed.</span><span class="s3">\n                     </span><span class="s1">*/</span><span class="s3">\n                    </span><span class="s1">const hasTargetChanged = !this.targetLayout ||</span><span class="s3">\n                        </span><span class="s1">!boxEqualsRounded(this.targetLayout, newLayout);</span><span class="s3">\n                    </span><span class="s1">/*</span><span class="s3">\n                     </span><span class="s1">* Note: Disabled to fix relative animations always triggering new</span><span class="s3">\n                     </span><span class="s1">* layout animations. If this causes further issues, we can try</span><span class="s3">\n                     </span><span class="s1">* a different approach to detecting relative target changes.</span><span class="s3">\n                     </span><span class="s1">*/</span><span class="s3">\n                    </span><span class="s1">// || hasRelativeLayoutChanged</span><span class="s3">\n                    </span><span class="s1">/**</span><span class="s3">\n                     </span><span class="s1">* If the layout hasn't seemed to have changed, it might be that the</span><span class="s3">\n                     </span><span class="s1">* element is visually in the same place in the document but its position</span><span class="s3">\n                     </span><span class="s1">* relative to its parent has indeed changed. So here we check for that.</span><span class="s3">\n                     </span><span class="s1">*/</span><span class="s3">\n                    </span><span class="s1">const hasOnlyRelativeTargetChanged = !hasLayoutChanged &amp;&amp; hasRelativeLayoutChanged;</span><span class="s3">\n                    </span><span class="s1">if (this.options.layoutRoot ||</span><span class="s3">\n                        </span><span class="s1">this.resumeFrom ||</span><span class="s3">\n                        </span><span class="s1">hasOnlyRelativeTargetChanged ||</span><span class="s3">\n                        </span><span class="s1">(hasLayoutChanged &amp;&amp;</span><span class="s3">\n                            </span><span class="s1">(hasTargetChanged || !this.currentAnimation))) {</span><span class="s3">\n                        </span><span class="s1">if (this.resumeFrom) {</span><span class="s3">\n                            </span><span class="s1">this.resumingFrom = this.resumeFrom;</span><span class="s3">\n                            </span><span class="s1">this.resumingFrom.resumingFrom = undefined;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">const animationOptions = {</span><span class="s3">\n                            </span><span class="s1">...getValueTransition(layoutTransition, </span><span class="s3">\&quot;</span><span class="s1">layout</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n                            </span><span class="s1">onPlay: onLayoutAnimationStart,</span><span class="s3">\n                            </span><span class="s1">onComplete: onLayoutAnimationComplete,</span><span class="s3">\n                        </span><span class="s1">};</span><span class="s3">\n                        </span><span class="s1">if (visualElement.shouldReduceMotion ||</span><span class="s3">\n                            </span><span class="s1">this.options.layoutRoot) {</span><span class="s3">\n                            </span><span class="s1">animationOptions.delay = 0;</span><span class="s3">\n                            </span><span class="s1">animationOptions.type = false;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">this.startAnimation(animationOptions);</span><span class="s3">\n                        </span><span class="s1">/**</span><span class="s3">\n                         </span><span class="s1">* Set animation origin after starting animation to avoid layout jump</span><span class="s3">\n                         </span><span class="s1">* caused by stopping previous layout animation</span><span class="s3">\n                         </span><span class="s1">*/</span><span class="s3">\n                        </span><span class="s1">this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">/**</span><span class="s3">\n                         </span><span class="s1">* If the layout hasn't changed and we have an animation that hasn't started yet,</span><span class="s3">\n                         </span><span class="s1">* finish it immediately. Otherwise it will be animating from a location</span><span class="s3">\n                         </span><span class="s1">* that was probably never commited to screen and look like a jumpy box.</span><span class="s3">\n                         </span><span class="s1">*/</span><span class="s3">\n                        </span><span class="s1">if (!hasLayoutChanged) {</span><span class="s3">\n                            </span><span class="s1">finishAnimation(this);</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">if (this.isLead() &amp;&amp; this.options.onExitComplete) {</span><span class="s3">\n                            </span><span class="s1">this.options.onExitComplete();</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">this.targetLayout = newLayout;</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">unmount() {</span><span class="s3">\n            </span><span class="s1">this.options.layoutId &amp;&amp; this.willUpdate();</span><span class="s3">\n            </span><span class="s1">this.root.nodes.remove(this);</span><span class="s3">\n            </span><span class="s1">const stack = this.getStack();</span><span class="s3">\n            </span><span class="s1">stack &amp;&amp; stack.remove(this);</span><span class="s3">\n            </span><span class="s1">this.parent &amp;&amp; this.parent.children.delete(this);</span><span class="s3">\n            </span><span class="s1">this.instance = undefined;</span><span class="s3">\n            </span><span class="s1">this.eventHandlers.clear();</span><span class="s3">\n            </span><span class="s1">cancelFrame(this.updateProjection);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// only on the root</span><span class="s3">\n        </span><span class="s1">blockUpdate() {</span><span class="s3">\n            </span><span class="s1">this.updateManuallyBlocked = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">unblockUpdate() {</span><span class="s3">\n            </span><span class="s1">this.updateManuallyBlocked = false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">isUpdateBlocked() {</span><span class="s3">\n            </span><span class="s1">return this.updateManuallyBlocked || this.updateBlockedByResize;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">isTreeAnimationBlocked() {</span><span class="s3">\n            </span><span class="s1">return (this.isAnimationBlocked ||</span><span class="s3">\n                </span><span class="s1">(this.parent &amp;&amp; this.parent.isTreeAnimationBlocked()) ||</span><span class="s3">\n                </span><span class="s1">false);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Note: currently only running on root node</span><span class="s3">\n        </span><span class="s1">startUpdate() {</span><span class="s3">\n            </span><span class="s1">if (this.isUpdateBlocked())</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">this.isUpdating = true;</span><span class="s3">\n            </span><span class="s1">this.nodes &amp;&amp; this.nodes.forEach(resetSkewAndRotation);</span><span class="s3">\n            </span><span class="s1">this.animationId++;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">getTransformTemplate() {</span><span class="s3">\n            </span><span class="s1">const { visualElement } = this.options;</span><span class="s3">\n            </span><span class="s1">return visualElement &amp;&amp; visualElement.getProps().transformTemplate;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">willUpdate(shouldNotifyListeners = true) {</span><span class="s3">\n            </span><span class="s1">this.root.hasTreeAnimated = true;</span><span class="s3">\n            </span><span class="s1">if (this.root.isUpdateBlocked()) {</span><span class="s3">\n                </span><span class="s1">this.options.onExitComplete &amp;&amp; this.options.onExitComplete();</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* If we're running optimised appear animations then these must be</span><span class="s3">\n             </span><span class="s1">* cancelled before measuring the DOM. This is so we can measure</span><span class="s3">\n             </span><span class="s1">* the true layout of the element rather than the WAAPI animation</span><span class="s3">\n             </span><span class="s1">* which will be unaffected by the resetSkewAndRotate step.</span><span class="s3">\n             </span><span class="s1">*</span><span class="s3">\n             </span><span class="s1">* Note: This is a DOM write. Worst case scenario is this is sandwiched</span><span class="s3">\n             </span><span class="s1">* between other snapshot reads which will cause unnecessary style recalculations.</span><span class="s3">\n             </span><span class="s1">* This has to happen here though, as we don't yet know which nodes will need</span><span class="s3">\n             </span><span class="s1">* snapshots in startUpdate(), but we only want to cancel optimised animations</span><span class="s3">\n             </span><span class="s1">* if a layout animation measurement is actually going to be affected by them.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">if (window.MotionCancelOptimisedAnimation &amp;&amp;</span><span class="s3">\n                </span><span class="s1">!this.hasCheckedOptimisedAppear) {</span><span class="s3">\n                </span><span class="s1">cancelTreeOptimisedTransformAnimations(this);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">!this.root.isUpdating &amp;&amp; this.root.startUpdate();</span><span class="s3">\n            </span><span class="s1">if (this.isLayoutDirty)</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">this.isLayoutDirty = true;</span><span class="s3">\n            </span><span class="s1">for (let i = 0; i &lt; this.path.length; i++) {</span><span class="s3">\n                </span><span class="s1">const node = this.path[i];</span><span class="s3">\n                </span><span class="s1">node.shouldResetTransform = true;</span><span class="s3">\n                </span><span class="s1">node.updateScroll(</span><span class="s3">\&quot;</span><span class="s1">snapshot</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">if (node.options.layoutRoot) {</span><span class="s3">\n                    </span><span class="s1">node.willUpdate(false);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const { layoutId, layout } = this.options;</span><span class="s3">\n            </span><span class="s1">if (layoutId === undefined &amp;&amp; !layout)</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">const transformTemplate = this.getTransformTemplate();</span><span class="s3">\n            </span><span class="s1">this.prevTransformTemplateValue = transformTemplate</span><span class="s3">\n                </span><span class="s1">? transformTemplate(this.latestValues, </span><span class="s3">\&quot;\&quot;</span><span class="s1">)</span><span class="s3">\n                </span><span class="s1">: undefined;</span><span class="s3">\n            </span><span class="s1">this.updateSnapshot();</span><span class="s3">\n            </span><span class="s1">shouldNotifyListeners &amp;&amp; this.notifyListeners(</span><span class="s3">\&quot;</span><span class="s1">willUpdate</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">update() {</span><span class="s3">\n            </span><span class="s1">this.updateScheduled = false;</span><span class="s3">\n            </span><span class="s1">const updateWasBlocked = this.isUpdateBlocked();</span><span class="s3">\n            </span><span class="s1">// When doing an instant transition, we skip the layout update,</span><span class="s3">\n            </span><span class="s1">// but should still clean up the measurements so that the next</span><span class="s3">\n            </span><span class="s1">// snapshot could be taken correctly.</span><span class="s3">\n            </span><span class="s1">if (updateWasBlocked) {</span><span class="s3">\n                </span><span class="s1">this.unblockUpdate();</span><span class="s3">\n                </span><span class="s1">this.clearAllSnapshots();</span><span class="s3">\n                </span><span class="s1">this.nodes.forEach(clearMeasurements);</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* If this is a repeat of didUpdate then ignore the animation.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">if (this.animationId &lt;= this.animationCommitId) {</span><span class="s3">\n                </span><span class="s1">this.nodes.forEach(clearIsLayoutDirty);</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this.animationCommitId = this.animationId;</span><span class="s3">\n            </span><span class="s1">if (!this.isUpdating) {</span><span class="s3">\n                </span><span class="s1">this.nodes.forEach(clearIsLayoutDirty);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">this.isUpdating = false;</span><span class="s3">\n                </span><span class="s1">/**</span><span class="s3">\n                 </span><span class="s1">* Write</span><span class="s3">\n                 </span><span class="s1">*/</span><span class="s3">\n                </span><span class="s1">this.nodes.forEach(resetTransformStyle);</span><span class="s3">\n                </span><span class="s1">/**</span><span class="s3">\n                 </span><span class="s1">* Read ==================</span><span class="s3">\n                 </span><span class="s1">*/</span><span class="s3">\n                </span><span class="s1">// Update layout measurements of updated children</span><span class="s3">\n                </span><span class="s1">this.nodes.forEach(updateLayout);</span><span class="s3">\n                </span><span class="s1">/**</span><span class="s3">\n                 </span><span class="s1">* Write</span><span class="s3">\n                 </span><span class="s1">*/</span><span class="s3">\n                </span><span class="s1">// Notify listeners that the layout is updated</span><span class="s3">\n                </span><span class="s1">this.nodes.forEach(notifyLayoutUpdate);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this.clearAllSnapshots();</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* Manually flush any pending updates. Ideally</span><span class="s3">\n             </span><span class="s1">* we could leave this to the following requestAnimationFrame but this seems</span><span class="s3">\n             </span><span class="s1">* to leave a flash of incorrectly styled content.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">const now = time.now();</span><span class="s3">\n            </span><span class="s1">frameData.delta = clamp(0, 1000 / 60, now - frameData.timestamp);</span><span class="s3">\n            </span><span class="s1">frameData.timestamp = now;</span><span class="s3">\n            </span><span class="s1">frameData.isProcessing = true;</span><span class="s3">\n            </span><span class="s1">frameSteps.update.process(frameData);</span><span class="s3">\n            </span><span class="s1">frameSteps.preRender.process(frameData);</span><span class="s3">\n            </span><span class="s1">frameSteps.render.process(frameData);</span><span class="s3">\n            </span><span class="s1">frameData.isProcessing = false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">didUpdate() {</span><span class="s3">\n            </span><span class="s1">if (!this.updateScheduled) {</span><span class="s3">\n                </span><span class="s1">this.updateScheduled = true;</span><span class="s3">\n                </span><span class="s1">microtask.read(this.scheduleUpdate);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">clearAllSnapshots() {</span><span class="s3">\n            </span><span class="s1">this.nodes.forEach(clearSnapshot);</span><span class="s3">\n            </span><span class="s1">this.sharedNodes.forEach(removeLeadSnapshots);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">scheduleUpdateProjection() {</span><span class="s3">\n            </span><span class="s1">if (!this.projectionUpdateScheduled) {</span><span class="s3">\n                </span><span class="s1">this.projectionUpdateScheduled = true;</span><span class="s3">\n                </span><span class="s1">frame.preRender(this.updateProjection, false, true);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">scheduleCheckAfterUnmount() {</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* If the unmounting node is in a layoutGroup and did trigger a willUpdate,</span><span class="s3">\n             </span><span class="s1">* we manually call didUpdate to give a chance to the siblings to animate.</span><span class="s3">\n             </span><span class="s1">* Otherwise, cleanup all snapshots to prevents future nodes from reusing them.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">frame.postRender(() =&gt; {</span><span class="s3">\n                </span><span class="s1">if (this.isLayoutDirty) {</span><span class="s3">\n                    </span><span class="s1">this.root.didUpdate();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">this.root.checkUpdateFailed();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Update measurements</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">updateSnapshot() {</span><span class="s3">\n            </span><span class="s1">if (this.snapshot || !this.instance)</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">this.snapshot = this.measure();</span><span class="s3">\n            </span><span class="s1">if (this.snapshot &amp;&amp;</span><span class="s3">\n                </span><span class="s1">!calcLength(this.snapshot.measuredBox.x) &amp;&amp;</span><span class="s3">\n                </span><span class="s1">!calcLength(this.snapshot.measuredBox.y)) {</span><span class="s3">\n                </span><span class="s1">this.snapshot = undefined;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">updateLayout() {</span><span class="s3">\n            </span><span class="s1">if (!this.instance)</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">this.updateScroll();</span><span class="s3">\n            </span><span class="s1">if (!(this.options.alwaysMeasureLayout &amp;&amp; this.isLead()) &amp;&amp;</span><span class="s3">\n                </span><span class="s1">!this.isLayoutDirty) {</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* When a node is mounted, it simply resumes from the prevLead's</span><span class="s3">\n             </span><span class="s1">* snapshot instead of taking a new one, but the ancestors scroll</span><span class="s3">\n             </span><span class="s1">* might have updated while the prevLead is unmounted. We need to</span><span class="s3">\n             </span><span class="s1">* update the scroll again to make sure the layout we measure is</span><span class="s3">\n             </span><span class="s1">* up to date.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">if (this.resumeFrom &amp;&amp; !this.resumeFrom.instance) {</span><span class="s3">\n                </span><span class="s1">for (let i = 0; i &lt; this.path.length; i++) {</span><span class="s3">\n                    </span><span class="s1">const node = this.path[i];</span><span class="s3">\n                    </span><span class="s1">node.updateScroll();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const prevLayout = this.layout;</span><span class="s3">\n            </span><span class="s1">this.layout = this.measure(false);</span><span class="s3">\n            </span><span class="s1">this.layoutCorrected = createBox();</span><span class="s3">\n            </span><span class="s1">this.isLayoutDirty = false;</span><span class="s3">\n            </span><span class="s1">this.projectionDelta = undefined;</span><span class="s3">\n            </span><span class="s1">this.notifyListeners(</span><span class="s3">\&quot;</span><span class="s1">measure</span><span class="s3">\&quot;</span><span class="s1">, this.layout.layoutBox);</span><span class="s3">\n            </span><span class="s1">const { visualElement } = this.options;</span><span class="s3">\n            </span><span class="s1">visualElement &amp;&amp;</span><span class="s3">\n                </span><span class="s1">visualElement.notify(</span><span class="s3">\&quot;</span><span class="s1">LayoutMeasure</span><span class="s3">\&quot;</span><span class="s1">, this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : undefined);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">updateScroll(phase = </span><span class="s3">\&quot;</span><span class="s1">measure</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">let needsMeasurement = Boolean(this.options.layoutScroll &amp;&amp; this.instance);</span><span class="s3">\n            </span><span class="s1">if (this.scroll &amp;&amp;</span><span class="s3">\n                </span><span class="s1">this.scroll.animationId === this.root.animationId &amp;&amp;</span><span class="s3">\n                </span><span class="s1">this.scroll.phase === phase) {</span><span class="s3">\n                </span><span class="s1">needsMeasurement = false;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (needsMeasurement &amp;&amp; this.instance) {</span><span class="s3">\n                </span><span class="s1">const isRoot = checkIsScrollRoot(this.instance);</span><span class="s3">\n                </span><span class="s1">this.scroll = {</span><span class="s3">\n                    </span><span class="s1">animationId: this.root.animationId,</span><span class="s3">\n                    </span><span class="s1">phase,</span><span class="s3">\n                    </span><span class="s1">isRoot,</span><span class="s3">\n                    </span><span class="s1">offset: measureScroll(this.instance),</span><span class="s3">\n                    </span><span class="s1">wasRoot: this.scroll ? this.scroll.isRoot : isRoot,</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">resetTransform() {</span><span class="s3">\n            </span><span class="s1">if (!resetTransform)</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">const isResetRequested = this.isLayoutDirty ||</span><span class="s3">\n                </span><span class="s1">this.shouldResetTransform ||</span><span class="s3">\n                </span><span class="s1">this.options.alwaysMeasureLayout;</span><span class="s3">\n            </span><span class="s1">const hasProjection = this.projectionDelta &amp;&amp; !isDeltaZero(this.projectionDelta);</span><span class="s3">\n            </span><span class="s1">const transformTemplate = this.getTransformTemplate();</span><span class="s3">\n            </span><span class="s1">const transformTemplateValue = transformTemplate</span><span class="s3">\n                </span><span class="s1">? transformTemplate(this.latestValues, </span><span class="s3">\&quot;\&quot;</span><span class="s1">)</span><span class="s3">\n                </span><span class="s1">: undefined;</span><span class="s3">\n            </span><span class="s1">const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;</span><span class="s3">\n            </span><span class="s1">if (isResetRequested &amp;&amp;</span><span class="s3">\n                </span><span class="s1">this.instance &amp;&amp;</span><span class="s3">\n                </span><span class="s1">(hasProjection ||</span><span class="s3">\n                    </span><span class="s1">hasTransform(this.latestValues) ||</span><span class="s3">\n                    </span><span class="s1">transformTemplateHasChanged)) {</span><span class="s3">\n                </span><span class="s1">resetTransform(this.instance, transformTemplateValue);</span><span class="s3">\n                </span><span class="s1">this.shouldResetTransform = false;</span><span class="s3">\n                </span><span class="s1">this.scheduleRender();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">measure(removeTransform = true) {</span><span class="s3">\n            </span><span class="s1">const pageBox = this.measurePageBox();</span><span class="s3">\n            </span><span class="s1">let layoutBox = this.removeElementScroll(pageBox);</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* Measurements taken during the pre-render stage</span><span class="s3">\n             </span><span class="s1">* still have transforms applied so we remove them</span><span class="s3">\n             </span><span class="s1">* via calculation.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">if (removeTransform) {</span><span class="s3">\n                </span><span class="s1">layoutBox = this.removeTransform(layoutBox);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">roundBox(layoutBox);</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">animationId: this.root.animationId,</span><span class="s3">\n                </span><span class="s1">measuredBox: pageBox,</span><span class="s3">\n                </span><span class="s1">layoutBox,</span><span class="s3">\n                </span><span class="s1">latestValues: {},</span><span class="s3">\n                </span><span class="s1">source: this.id,</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">measurePageBox() {</span><span class="s3">\n            </span><span class="s1">const { visualElement } = this.options;</span><span class="s3">\n            </span><span class="s1">if (!visualElement)</span><span class="s3">\n                </span><span class="s1">return createBox();</span><span class="s3">\n            </span><span class="s1">const box = visualElement.measureViewportBox();</span><span class="s3">\n            </span><span class="s1">const wasInScrollRoot = this.scroll?.wasRoot || this.path.some(checkNodeWasScrollRoot);</span><span class="s3">\n            </span><span class="s1">if (!wasInScrollRoot) {</span><span class="s3">\n                </span><span class="s1">// Remove viewport scroll to give page-relative coordinates</span><span class="s3">\n                </span><span class="s1">const { scroll } = this.root;</span><span class="s3">\n                </span><span class="s1">if (scroll) {</span><span class="s3">\n                    </span><span class="s1">translateAxis(box.x, scroll.offset.x);</span><span class="s3">\n                    </span><span class="s1">translateAxis(box.y, scroll.offset.y);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return box;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">removeElementScroll(box) {</span><span class="s3">\n            </span><span class="s1">const boxWithoutScroll = createBox();</span><span class="s3">\n            </span><span class="s1">copyBoxInto(boxWithoutScroll, box);</span><span class="s3">\n            </span><span class="s1">if (this.scroll?.wasRoot) {</span><span class="s3">\n                </span><span class="s1">return boxWithoutScroll;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* Performance TODO: Keep a cumulative scroll offset down the tree</span><span class="s3">\n             </span><span class="s1">* rather than loop back up the path.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">for (let i = 0; i &lt; this.path.length; i++) {</span><span class="s3">\n                </span><span class="s1">const node = this.path[i];</span><span class="s3">\n                </span><span class="s1">const { scroll, options } = node;</span><span class="s3">\n                </span><span class="s1">if (node !== this.root &amp;&amp; scroll &amp;&amp; options.layoutScroll) {</span><span class="s3">\n                    </span><span class="s1">/**</span><span class="s3">\n                     </span><span class="s1">* If this is a new scroll root, we want to remove all previous scrolls</span><span class="s3">\n                     </span><span class="s1">* from the viewport box.</span><span class="s3">\n                     </span><span class="s1">*/</span><span class="s3">\n                    </span><span class="s1">if (scroll.wasRoot) {</span><span class="s3">\n                        </span><span class="s1">copyBoxInto(boxWithoutScroll, box);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">translateAxis(boxWithoutScroll.x, scroll.offset.x);</span><span class="s3">\n                    </span><span class="s1">translateAxis(boxWithoutScroll.y, scroll.offset.y);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return boxWithoutScroll;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">applyTransform(box, transformOnly = false) {</span><span class="s3">\n            </span><span class="s1">const withTransforms = createBox();</span><span class="s3">\n            </span><span class="s1">copyBoxInto(withTransforms, box);</span><span class="s3">\n            </span><span class="s1">for (let i = 0; i &lt; this.path.length; i++) {</span><span class="s3">\n                </span><span class="s1">const node = this.path[i];</span><span class="s3">\n                </span><span class="s1">if (!transformOnly &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">node.options.layoutScroll &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">node.scroll &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">node !== node.root) {</span><span class="s3">\n                    </span><span class="s1">transformBox(withTransforms, {</span><span class="s3">\n                        </span><span class="s1">x: -node.scroll.offset.x,</span><span class="s3">\n                        </span><span class="s1">y: -node.scroll.offset.y,</span><span class="s3">\n                    </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (!hasTransform(node.latestValues))</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">transformBox(withTransforms, node.latestValues);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (hasTransform(this.latestValues)) {</span><span class="s3">\n                </span><span class="s1">transformBox(withTransforms, this.latestValues);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return withTransforms;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">removeTransform(box) {</span><span class="s3">\n            </span><span class="s1">const boxWithoutTransform = createBox();</span><span class="s3">\n            </span><span class="s1">copyBoxInto(boxWithoutTransform, box);</span><span class="s3">\n            </span><span class="s1">for (let i = 0; i &lt; this.path.length; i++) {</span><span class="s3">\n                </span><span class="s1">const node = this.path[i];</span><span class="s3">\n                </span><span class="s1">if (!node.instance)</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">if (!hasTransform(node.latestValues))</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">hasScale(node.latestValues) &amp;&amp; node.updateSnapshot();</span><span class="s3">\n                </span><span class="s1">const sourceBox = createBox();</span><span class="s3">\n                </span><span class="s1">const nodeBox = node.measurePageBox();</span><span class="s3">\n                </span><span class="s1">copyBoxInto(sourceBox, nodeBox);</span><span class="s3">\n                </span><span class="s1">removeBoxTransforms(boxWithoutTransform, node.latestValues, node.snapshot ? node.snapshot.layoutBox : undefined, sourceBox);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (hasTransform(this.latestValues)) {</span><span class="s3">\n                </span><span class="s1">removeBoxTransforms(boxWithoutTransform, this.latestValues);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return boxWithoutTransform;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">setTargetDelta(delta) {</span><span class="s3">\n            </span><span class="s1">this.targetDelta = delta;</span><span class="s3">\n            </span><span class="s1">this.root.scheduleUpdateProjection();</span><span class="s3">\n            </span><span class="s1">this.isProjectionDirty = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">setOptions(options) {</span><span class="s3">\n            </span><span class="s1">this.options = {</span><span class="s3">\n                </span><span class="s1">...this.options,</span><span class="s3">\n                </span><span class="s1">...options,</span><span class="s3">\n                </span><span class="s1">crossfade: options.crossfade !== undefined ? options.crossfade : true,</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">clearMeasurements() {</span><span class="s3">\n            </span><span class="s1">this.scroll = undefined;</span><span class="s3">\n            </span><span class="s1">this.layout = undefined;</span><span class="s3">\n            </span><span class="s1">this.snapshot = undefined;</span><span class="s3">\n            </span><span class="s1">this.prevTransformTemplateValue = undefined;</span><span class="s3">\n            </span><span class="s1">this.targetDelta = undefined;</span><span class="s3">\n            </span><span class="s1">this.target = undefined;</span><span class="s3">\n            </span><span class="s1">this.isLayoutDirty = false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">forceRelativeParentToResolveTarget() {</span><span class="s3">\n            </span><span class="s1">if (!this.relativeParent)</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* If the parent target isn't up-to-date, force it to update.</span><span class="s3">\n             </span><span class="s1">* This is an unfortunate de-optimisation as it means any updating relative</span><span class="s3">\n             </span><span class="s1">* projection will cause all the relative parents to recalculate back</span><span class="s3">\n             </span><span class="s1">* up the tree.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">if (this.relativeParent.resolvedRelativeTargetAt !==</span><span class="s3">\n                </span><span class="s1">frameData.timestamp) {</span><span class="s3">\n                </span><span class="s1">this.relativeParent.resolveTargetDelta(true);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">resolveTargetDelta(forceRecalculation = false) {</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* Once the dirty status of nodes has been spread through the tree, we also</span><span class="s3">\n             </span><span class="s1">* need to check if we have a shared node of a different depth that has itself</span><span class="s3">\n             </span><span class="s1">* been dirtied.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">const lead = this.getLead();</span><span class="s3">\n            </span><span class="s1">this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);</span><span class="s3">\n            </span><span class="s1">this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);</span><span class="s3">\n            </span><span class="s1">this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);</span><span class="s3">\n            </span><span class="s1">const isShared = Boolean(this.resumingFrom) || this !== lead;</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* We don't use transform for this step of processing so we don't</span><span class="s3">\n             </span><span class="s1">* need to check whether any nodes have changed transform.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">const canSkip = !(forceRecalculation ||</span><span class="s3">\n                </span><span class="s1">(isShared &amp;&amp; this.isSharedProjectionDirty) ||</span><span class="s3">\n                </span><span class="s1">this.isProjectionDirty ||</span><span class="s3">\n                </span><span class="s1">this.parent?.isProjectionDirty ||</span><span class="s3">\n                </span><span class="s1">this.attemptToResolveRelativeTarget ||</span><span class="s3">\n                </span><span class="s1">this.root.updateBlockedByResize);</span><span class="s3">\n            </span><span class="s1">if (canSkip)</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">const { layout, layoutId } = this.options;</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* If we have no layout, we can't perform projection, so early return</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">if (!this.layout || !(layout || layoutId))</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">this.resolvedRelativeTargetAt = frameData.timestamp;</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* If we don't have a targetDelta but do have a layout, we can attempt to resolve</span><span class="s3">\n             </span><span class="s1">* a relativeParent. This will allow a component to perform scale correction</span><span class="s3">\n             </span><span class="s1">* even if no animation has started.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">if (!this.targetDelta &amp;&amp; !this.relativeTarget) {</span><span class="s3">\n                </span><span class="s1">const relativeParent = this.getClosestProjectingParent();</span><span class="s3">\n                </span><span class="s1">if (relativeParent &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">relativeParent.layout &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">this.animationProgress !== 1) {</span><span class="s3">\n                    </span><span class="s1">this.relativeParent = relativeParent;</span><span class="s3">\n                    </span><span class="s1">this.forceRelativeParentToResolveTarget();</span><span class="s3">\n                    </span><span class="s1">this.relativeTarget = createBox();</span><span class="s3">\n                    </span><span class="s1">this.relativeTargetOrigin = createBox();</span><span class="s3">\n                    </span><span class="s1">calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);</span><span class="s3">\n                    </span><span class="s1">copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">this.relativeParent = this.relativeTarget = undefined;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* If we have no relative target or no target delta our target isn't valid</span><span class="s3">\n             </span><span class="s1">* for this frame.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">if (!this.relativeTarget &amp;&amp; !this.targetDelta)</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* Lazy-init target data structure</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">if (!this.target) {</span><span class="s3">\n                </span><span class="s1">this.target = createBox();</span><span class="s3">\n                </span><span class="s1">this.targetWithTransforms = createBox();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* If we've got a relative box for this component, resolve it into a target relative to the parent.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">if (this.relativeTarget &amp;&amp;</span><span class="s3">\n                </span><span class="s1">this.relativeTargetOrigin &amp;&amp;</span><span class="s3">\n                </span><span class="s1">this.relativeParent &amp;&amp;</span><span class="s3">\n                </span><span class="s1">this.relativeParent.target) {</span><span class="s3">\n                </span><span class="s1">this.forceRelativeParentToResolveTarget();</span><span class="s3">\n                </span><span class="s1">calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);</span><span class="s3">\n                </span><span class="s1">/**</span><span class="s3">\n                 </span><span class="s1">* If we've only got a targetDelta, resolve it into a target</span><span class="s3">\n                 </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (this.targetDelta) {</span><span class="s3">\n                </span><span class="s1">if (Boolean(this.resumingFrom)) {</span><span class="s3">\n                    </span><span class="s1">// TODO: This is creating a new object every frame</span><span class="s3">\n                    </span><span class="s1">this.target = this.applyTransform(this.layout.layoutBox);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">copyBoxInto(this.target, this.layout.layoutBox);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">applyBoxDelta(this.target, this.targetDelta);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">/**</span><span class="s3">\n                 </span><span class="s1">* If no target, use own layout as target</span><span class="s3">\n                 </span><span class="s1">*/</span><span class="s3">\n                </span><span class="s1">copyBoxInto(this.target, this.layout.layoutBox);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* If we've been told to attempt to resolve a relative target, do so.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">if (this.attemptToResolveRelativeTarget) {</span><span class="s3">\n                </span><span class="s1">this.attemptToResolveRelativeTarget = false;</span><span class="s3">\n                </span><span class="s1">const relativeParent = this.getClosestProjectingParent();</span><span class="s3">\n                </span><span class="s1">if (relativeParent &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">Boolean(relativeParent.resumingFrom) ===</span><span class="s3">\n                        </span><span class="s1">Boolean(this.resumingFrom) &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">!relativeParent.options.layoutScroll &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">relativeParent.target &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">this.animationProgress !== 1) {</span><span class="s3">\n                    </span><span class="s1">this.relativeParent = relativeParent;</span><span class="s3">\n                    </span><span class="s1">this.forceRelativeParentToResolveTarget();</span><span class="s3">\n                    </span><span class="s1">this.relativeTarget = createBox();</span><span class="s3">\n                    </span><span class="s1">this.relativeTargetOrigin = createBox();</span><span class="s3">\n                    </span><span class="s1">calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);</span><span class="s3">\n                    </span><span class="s1">copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">this.relativeParent = this.relativeTarget = undefined;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* Increase debug counter for resolved target deltas</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">if (statsBuffer.value) {</span><span class="s3">\n                </span><span class="s1">metrics.calculatedTargetDeltas++;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">getClosestProjectingParent() {</span><span class="s3">\n            </span><span class="s1">if (!this.parent ||</span><span class="s3">\n                </span><span class="s1">hasScale(this.parent.latestValues) ||</span><span class="s3">\n                </span><span class="s1">has2DTranslate(this.parent.latestValues)) {</span><span class="s3">\n                </span><span class="s1">return undefined;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (this.parent.isProjecting()) {</span><span class="s3">\n                </span><span class="s1">return this.parent;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">return this.parent.getClosestProjectingParent();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">isProjecting() {</span><span class="s3">\n            </span><span class="s1">return Boolean((this.relativeTarget ||</span><span class="s3">\n                </span><span class="s1">this.targetDelta ||</span><span class="s3">\n                </span><span class="s1">this.options.layoutRoot) &amp;&amp;</span><span class="s3">\n                </span><span class="s1">this.layout);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">calcProjection() {</span><span class="s3">\n            </span><span class="s1">const lead = this.getLead();</span><span class="s3">\n            </span><span class="s1">const isShared = Boolean(this.resumingFrom) || this !== lead;</span><span class="s3">\n            </span><span class="s1">let canSkip = true;</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* If this is a normal layout animation and neither this node nor its nearest projecting</span><span class="s3">\n             </span><span class="s1">* is dirty then we can't skip.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">if (this.isProjectionDirty || this.parent?.isProjectionDirty) {</span><span class="s3">\n                </span><span class="s1">canSkip = false;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* If this is a shared layout animation and this node's shared projection is dirty then</span><span class="s3">\n             </span><span class="s1">* we can't skip.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">if (isShared &amp;&amp;</span><span class="s3">\n                </span><span class="s1">(this.isSharedProjectionDirty || this.isTransformDirty)) {</span><span class="s3">\n                </span><span class="s1">canSkip = false;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* If we have resolved the target this frame we must recalculate the</span><span class="s3">\n             </span><span class="s1">* projection to ensure it visually represents the internal calculations.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">if (this.resolvedRelativeTargetAt === frameData.timestamp) {</span><span class="s3">\n                </span><span class="s1">canSkip = false;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (canSkip)</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">const { layout, layoutId } = this.options;</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* If this section of the tree isn't animating we can</span><span class="s3">\n             </span><span class="s1">* delete our target sources for the following frame.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">this.isTreeAnimating = Boolean((this.parent &amp;&amp; this.parent.isTreeAnimating) ||</span><span class="s3">\n                </span><span class="s1">this.currentAnimation ||</span><span class="s3">\n                </span><span class="s1">this.pendingAnimation);</span><span class="s3">\n            </span><span class="s1">if (!this.isTreeAnimating) {</span><span class="s3">\n                </span><span class="s1">this.targetDelta = this.relativeTarget = undefined;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (!this.layout || !(layout || layoutId))</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* Reset the corrected box with the latest values from box, as we're then going</span><span class="s3">\n             </span><span class="s1">* to perform mutative operations on it.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">copyBoxInto(this.layoutCorrected, this.layout.layoutBox);</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* Record previous tree scales before updating.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">const prevTreeScaleX = this.treeScale.x;</span><span class="s3">\n            </span><span class="s1">const prevTreeScaleY = this.treeScale.y;</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* Apply all the parent deltas to this box to produce the corrected box. This</span><span class="s3">\n             </span><span class="s1">* is the layout box, as it will appear on screen as a result of the transforms of its parents.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* If this layer needs to perform scale correction but doesn't have a target,</span><span class="s3">\n             </span><span class="s1">* use the layout as the target.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">if (lead.layout &amp;&amp;</span><span class="s3">\n                </span><span class="s1">!lead.target &amp;&amp;</span><span class="s3">\n                </span><span class="s1">(this.treeScale.x !== 1 || this.treeScale.y !== 1)) {</span><span class="s3">\n                </span><span class="s1">lead.target = lead.layout.layoutBox;</span><span class="s3">\n                </span><span class="s1">lead.targetWithTransforms = createBox();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const { target } = lead;</span><span class="s3">\n            </span><span class="s1">if (!target) {</span><span class="s3">\n                </span><span class="s1">/**</span><span class="s3">\n                 </span><span class="s1">* If we don't have a target to project into, but we were previously</span><span class="s3">\n                 </span><span class="s1">* projecting, we want to remove the stored transform and schedule</span><span class="s3">\n                 </span><span class="s1">* a render to ensure the elements reflect the removed transform.</span><span class="s3">\n                 </span><span class="s1">*/</span><span class="s3">\n                </span><span class="s1">if (this.prevProjectionDelta) {</span><span class="s3">\n                    </span><span class="s1">this.createProjectionDeltas();</span><span class="s3">\n                    </span><span class="s1">this.scheduleRender();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (!this.projectionDelta || !this.prevProjectionDelta) {</span><span class="s3">\n                </span><span class="s1">this.createProjectionDeltas();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x);</span><span class="s3">\n                </span><span class="s1">copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* Update the delta between the corrected box and the target box before user-set transforms were applied.</span><span class="s3">\n             </span><span class="s1">* This will allow us to calculate the corrected borderRadius and boxShadow to compensate</span><span class="s3">\n             </span><span class="s1">* for our layout reprojection, but still allow them to be scaled correctly by the user.</span><span class="s3">\n             </span><span class="s1">* It might be that to simplify this we may want to accept that user-set scale is also corrected</span><span class="s3">\n             </span><span class="s1">* and we wouldn't have to keep and calc both deltas, OR we could support a user setting</span><span class="s3">\n             </span><span class="s1">* to allow people to choose whether these styles are corrected based on just the</span><span class="s3">\n             </span><span class="s1">* layout reprojection or the final bounding box.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);</span><span class="s3">\n            </span><span class="s1">if (this.treeScale.x !== prevTreeScaleX ||</span><span class="s3">\n                </span><span class="s1">this.treeScale.y !== prevTreeScaleY ||</span><span class="s3">\n                </span><span class="s1">!axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) ||</span><span class="s3">\n                </span><span class="s1">!axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) {</span><span class="s3">\n                </span><span class="s1">this.hasProjected = true;</span><span class="s3">\n                </span><span class="s1">this.scheduleRender();</span><span class="s3">\n                </span><span class="s1">this.notifyListeners(</span><span class="s3">\&quot;</span><span class="s1">projectionUpdate</span><span class="s3">\&quot;</span><span class="s1">, target);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* Increase debug counter for recalculated projections</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">if (statsBuffer.value) {</span><span class="s3">\n                </span><span class="s1">metrics.calculatedProjections++;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">hide() {</span><span class="s3">\n            </span><span class="s1">this.isVisible = false;</span><span class="s3">\n            </span><span class="s1">// TODO: Schedule render</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">show() {</span><span class="s3">\n            </span><span class="s1">this.isVisible = true;</span><span class="s3">\n            </span><span class="s1">// TODO: Schedule render</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">scheduleRender(notifyAll = true) {</span><span class="s3">\n            </span><span class="s1">this.options.visualElement?.scheduleRender();</span><span class="s3">\n            </span><span class="s1">if (notifyAll) {</span><span class="s3">\n                </span><span class="s1">const stack = this.getStack();</span><span class="s3">\n                </span><span class="s1">stack &amp;&amp; stack.scheduleRender();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (this.resumingFrom &amp;&amp; !this.resumingFrom.instance) {</span><span class="s3">\n                </span><span class="s1">this.resumingFrom = undefined;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">createProjectionDeltas() {</span><span class="s3">\n            </span><span class="s1">this.prevProjectionDelta = createDelta();</span><span class="s3">\n            </span><span class="s1">this.projectionDelta = createDelta();</span><span class="s3">\n            </span><span class="s1">this.projectionDeltaWithTransform = createDelta();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {</span><span class="s3">\n            </span><span class="s1">const snapshot = this.snapshot;</span><span class="s3">\n            </span><span class="s1">const snapshotLatestValues = snapshot ? snapshot.latestValues : {};</span><span class="s3">\n            </span><span class="s1">const mixedValues = { ...this.latestValues };</span><span class="s3">\n            </span><span class="s1">const targetDelta = createDelta();</span><span class="s3">\n            </span><span class="s1">if (!this.relativeParent ||</span><span class="s3">\n                </span><span class="s1">!this.relativeParent.options.layoutRoot) {</span><span class="s3">\n                </span><span class="s1">this.relativeTarget = this.relativeTargetOrigin = undefined;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;</span><span class="s3">\n            </span><span class="s1">const relativeLayout = createBox();</span><span class="s3">\n            </span><span class="s1">const snapshotSource = snapshot ? snapshot.source : undefined;</span><span class="s3">\n            </span><span class="s1">const layoutSource = this.layout ? this.layout.source : undefined;</span><span class="s3">\n            </span><span class="s1">const isSharedLayoutAnimation = snapshotSource !== layoutSource;</span><span class="s3">\n            </span><span class="s1">const stack = this.getStack();</span><span class="s3">\n            </span><span class="s1">const isOnlyMember = !stack || stack.members.length &lt;= 1;</span><span class="s3">\n            </span><span class="s1">const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation &amp;&amp;</span><span class="s3">\n                </span><span class="s1">!isOnlyMember &amp;&amp;</span><span class="s3">\n                </span><span class="s1">this.options.crossfade === true &amp;&amp;</span><span class="s3">\n                </span><span class="s1">!this.path.some(hasOpacityCrossfade));</span><span class="s3">\n            </span><span class="s1">this.animationProgress = 0;</span><span class="s3">\n            </span><span class="s1">let prevRelativeTarget;</span><span class="s3">\n            </span><span class="s1">this.mixTargetDelta = (latest) =&gt; {</span><span class="s3">\n                </span><span class="s1">const progress = latest / 1000;</span><span class="s3">\n                </span><span class="s1">mixAxisDelta(targetDelta.x, delta.x, progress);</span><span class="s3">\n                </span><span class="s1">mixAxisDelta(targetDelta.y, delta.y, progress);</span><span class="s3">\n                </span><span class="s1">this.setTargetDelta(targetDelta);</span><span class="s3">\n                </span><span class="s1">if (this.relativeTarget &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">this.relativeTargetOrigin &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">this.layout &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">this.relativeParent &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">this.relativeParent.layout) {</span><span class="s3">\n                    </span><span class="s1">calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);</span><span class="s3">\n                    </span><span class="s1">mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress);</span><span class="s3">\n                    </span><span class="s1">/**</span><span class="s3">\n                     </span><span class="s1">* If this is an unchanged relative target we can consider the</span><span class="s3">\n                     </span><span class="s1">* projection not dirty.</span><span class="s3">\n                     </span><span class="s1">*/</span><span class="s3">\n                    </span><span class="s1">if (prevRelativeTarget &amp;&amp;</span><span class="s3">\n                        </span><span class="s1">boxEquals(this.relativeTarget, prevRelativeTarget)) {</span><span class="s3">\n                        </span><span class="s1">this.isProjectionDirty = false;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">if (!prevRelativeTarget)</span><span class="s3">\n                        </span><span class="s1">prevRelativeTarget = createBox();</span><span class="s3">\n                    </span><span class="s1">copyBoxInto(prevRelativeTarget, this.relativeTarget);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (isSharedLayoutAnimation) {</span><span class="s3">\n                    </span><span class="s1">this.animationValues = mixedValues;</span><span class="s3">\n                    </span><span class="s1">mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress, shouldCrossfadeOpacity, isOnlyMember);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">this.root.scheduleUpdateProjection();</span><span class="s3">\n                </span><span class="s1">this.scheduleRender();</span><span class="s3">\n                </span><span class="s1">this.animationProgress = progress;</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">this.mixTargetDelta(this.options.layoutRoot ? 1000 : 0);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">startAnimation(options) {</span><span class="s3">\n            </span><span class="s1">this.notifyListeners(</span><span class="s3">\&quot;</span><span class="s1">animationStart</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">this.currentAnimation?.stop();</span><span class="s3">\n            </span><span class="s1">this.resumingFrom?.currentAnimation?.stop();</span><span class="s3">\n            </span><span class="s1">if (this.pendingAnimation) {</span><span class="s3">\n                </span><span class="s1">cancelFrame(this.pendingAnimation);</span><span class="s3">\n                </span><span class="s1">this.pendingAnimation = undefined;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* Start the animation in the next frame to have a frame with progress 0,</span><span class="s3">\n             </span><span class="s1">* where the target is the same as when the animation started, so we can</span><span class="s3">\n             </span><span class="s1">* calculate the relative positions correctly for instant transitions.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">this.pendingAnimation = frame.update(() =&gt; {</span><span class="s3">\n                </span><span class="s1">globalProjectionState.hasAnimatedSinceResize = true;</span><span class="s3">\n                </span><span class="s1">activeAnimations.layout++;</span><span class="s3">\n                </span><span class="s1">this.motionValue || (this.motionValue = motionValue(0));</span><span class="s3">\n                </span><span class="s1">this.currentAnimation = animateSingleValue(this.motionValue, [0, 1000], {</span><span class="s3">\n                    </span><span class="s1">...options,</span><span class="s3">\n                    </span><span class="s1">velocity: 0,</span><span class="s3">\n                    </span><span class="s1">isSync: true,</span><span class="s3">\n                    </span><span class="s1">onUpdate: (latest) =&gt; {</span><span class="s3">\n                        </span><span class="s1">this.mixTargetDelta(latest);</span><span class="s3">\n                        </span><span class="s1">options.onUpdate &amp;&amp; options.onUpdate(latest);</span><span class="s3">\n                    </span><span class="s1">},</span><span class="s3">\n                    </span><span class="s1">onStop: () =&gt; {</span><span class="s3">\n                        </span><span class="s1">activeAnimations.layout--;</span><span class="s3">\n                    </span><span class="s1">},</span><span class="s3">\n                    </span><span class="s1">onComplete: () =&gt; {</span><span class="s3">\n                        </span><span class="s1">activeAnimations.layout--;</span><span class="s3">\n                        </span><span class="s1">options.onComplete &amp;&amp; options.onComplete();</span><span class="s3">\n                        </span><span class="s1">this.completeAnimation();</span><span class="s3">\n                    </span><span class="s1">},</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">if (this.resumingFrom) {</span><span class="s3">\n                    </span><span class="s1">this.resumingFrom.currentAnimation = this.currentAnimation;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">this.pendingAnimation = undefined;</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">completeAnimation() {</span><span class="s3">\n            </span><span class="s1">if (this.resumingFrom) {</span><span class="s3">\n                </span><span class="s1">this.resumingFrom.currentAnimation = undefined;</span><span class="s3">\n                </span><span class="s1">this.resumingFrom.preserveOpacity = undefined;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const stack = this.getStack();</span><span class="s3">\n            </span><span class="s1">stack &amp;&amp; stack.exitAnimationComplete();</span><span class="s3">\n            </span><span class="s1">this.resumingFrom =</span><span class="s3">\n                </span><span class="s1">this.currentAnimation =</span><span class="s3">\n                    </span><span class="s1">this.animationValues =</span><span class="s3">\n                        </span><span class="s1">undefined;</span><span class="s3">\n            </span><span class="s1">this.notifyListeners(</span><span class="s3">\&quot;</span><span class="s1">animationComplete</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">finishAnimation() {</span><span class="s3">\n            </span><span class="s1">if (this.currentAnimation) {</span><span class="s3">\n                </span><span class="s1">this.mixTargetDelta &amp;&amp; this.mixTargetDelta(animationTarget);</span><span class="s3">\n                </span><span class="s1">this.currentAnimation.stop();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this.completeAnimation();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">applyTransformsToTarget() {</span><span class="s3">\n            </span><span class="s1">const lead = this.getLead();</span><span class="s3">\n            </span><span class="s1">let { targetWithTransforms, target, layout, latestValues } = lead;</span><span class="s3">\n            </span><span class="s1">if (!targetWithTransforms || !target || !layout)</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* If we're only animating position, and this element isn't the lead element,</span><span class="s3">\n             </span><span class="s1">* then instead of projecting into the lead box we instead want to calculate</span><span class="s3">\n             </span><span class="s1">* a new target that aligns the two boxes but maintains the layout shape.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">if (this !== lead &amp;&amp;</span><span class="s3">\n                </span><span class="s1">this.layout &amp;&amp;</span><span class="s3">\n                </span><span class="s1">layout &amp;&amp;</span><span class="s3">\n                </span><span class="s1">shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout.layoutBox)) {</span><span class="s3">\n                </span><span class="s1">target = this.target || createBox();</span><span class="s3">\n                </span><span class="s1">const xLength = calcLength(this.layout.layoutBox.x);</span><span class="s3">\n                </span><span class="s1">target.x.min = lead.target.x.min;</span><span class="s3">\n                </span><span class="s1">target.x.max = target.x.min + xLength;</span><span class="s3">\n                </span><span class="s1">const yLength = calcLength(this.layout.layoutBox.y);</span><span class="s3">\n                </span><span class="s1">target.y.min = lead.target.y.min;</span><span class="s3">\n                </span><span class="s1">target.y.max = target.y.min + yLength;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">copyBoxInto(targetWithTransforms, target);</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.</span><span class="s3">\n             </span><span class="s1">* This is the final box that we will then project into by calculating a transform delta and</span><span class="s3">\n             </span><span class="s1">* applying it to the corrected box.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">transformBox(targetWithTransforms, latestValues);</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* Update the delta between the corrected box and the final target box, after</span><span class="s3">\n             </span><span class="s1">* user-set transforms are applied to it. This will be used by the renderer to</span><span class="s3">\n             </span><span class="s1">* create a transform style that will reproject the element from its layout layout</span><span class="s3">\n             </span><span class="s1">* into the desired bounding box.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">registerSharedNode(layoutId, node) {</span><span class="s3">\n            </span><span class="s1">if (!this.sharedNodes.has(layoutId)) {</span><span class="s3">\n                </span><span class="s1">this.sharedNodes.set(layoutId, new NodeStack());</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const stack = this.sharedNodes.get(layoutId);</span><span class="s3">\n            </span><span class="s1">stack.add(node);</span><span class="s3">\n            </span><span class="s1">const config = node.options.initialPromotionConfig;</span><span class="s3">\n            </span><span class="s1">node.promote({</span><span class="s3">\n                </span><span class="s1">transition: config ? config.transition : undefined,</span><span class="s3">\n                </span><span class="s1">preserveFollowOpacity: config &amp;&amp; config.shouldPreserveFollowOpacity</span><span class="s3">\n                    </span><span class="s1">? config.shouldPreserveFollowOpacity(node)</span><span class="s3">\n                    </span><span class="s1">: undefined,</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">isLead() {</span><span class="s3">\n            </span><span class="s1">const stack = this.getStack();</span><span class="s3">\n            </span><span class="s1">return stack ? stack.lead === this : true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">getLead() {</span><span class="s3">\n            </span><span class="s1">const { layoutId } = this.options;</span><span class="s3">\n            </span><span class="s1">return layoutId ? this.getStack()?.lead || this : this;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">getPrevLead() {</span><span class="s3">\n            </span><span class="s1">const { layoutId } = this.options;</span><span class="s3">\n            </span><span class="s1">return layoutId ? this.getStack()?.prevLead : undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">getStack() {</span><span class="s3">\n            </span><span class="s1">const { layoutId } = this.options;</span><span class="s3">\n            </span><span class="s1">if (layoutId)</span><span class="s3">\n                </span><span class="s1">return this.root.sharedNodes.get(layoutId);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">promote({ needsReset, transition, preserveFollowOpacity, } = {}) {</span><span class="s3">\n            </span><span class="s1">const stack = this.getStack();</span><span class="s3">\n            </span><span class="s1">if (stack)</span><span class="s3">\n                </span><span class="s1">stack.promote(this, preserveFollowOpacity);</span><span class="s3">\n            </span><span class="s1">if (needsReset) {</span><span class="s3">\n                </span><span class="s1">this.projectionDelta = undefined;</span><span class="s3">\n                </span><span class="s1">this.needsReset = true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (transition)</span><span class="s3">\n                </span><span class="s1">this.setOptions({ transition });</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">relegate() {</span><span class="s3">\n            </span><span class="s1">const stack = this.getStack();</span><span class="s3">\n            </span><span class="s1">if (stack) {</span><span class="s3">\n                </span><span class="s1">return stack.relegate(this);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">resetSkewAndRotation() {</span><span class="s3">\n            </span><span class="s1">const { visualElement } = this.options;</span><span class="s3">\n            </span><span class="s1">if (!visualElement)</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">// If there's no detected skew or rotation values, we can early return without a forced render.</span><span class="s3">\n            </span><span class="s1">let hasDistortingTransform = false;</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* An unrolled check for rotation values. Most elements don't have any rotation and</span><span class="s3">\n             </span><span class="s1">* skipping the nested loop and new object creation is 50% faster.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">const { latestValues } = visualElement;</span><span class="s3">\n            </span><span class="s1">if (latestValues.z ||</span><span class="s3">\n                </span><span class="s1">latestValues.rotate ||</span><span class="s3">\n                </span><span class="s1">latestValues.rotateX ||</span><span class="s3">\n                </span><span class="s1">latestValues.rotateY ||</span><span class="s3">\n                </span><span class="s1">latestValues.rotateZ ||</span><span class="s3">\n                </span><span class="s1">latestValues.skewX ||</span><span class="s3">\n                </span><span class="s1">latestValues.skewY) {</span><span class="s3">\n                </span><span class="s1">hasDistortingTransform = true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// If there's no distorting values, we don't need to do any more.</span><span class="s3">\n            </span><span class="s1">if (!hasDistortingTransform)</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">const resetValues = {};</span><span class="s3">\n            </span><span class="s1">if (latestValues.z) {</span><span class="s3">\n                </span><span class="s1">resetDistortingTransform(</span><span class="s3">\&quot;</span><span class="s1">z</span><span class="s3">\&quot;</span><span class="s1">, visualElement, resetValues, this.animationValues);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Check the skew and rotate value of all axes and reset to 0</span><span class="s3">\n            </span><span class="s1">for (let i = 0; i &lt; transformAxes.length; i++) {</span><span class="s3">\n                </span><span class="s1">resetDistortingTransform(`rotate${transformAxes[i]}`, visualElement, resetValues, this.animationValues);</span><span class="s3">\n                </span><span class="s1">resetDistortingTransform(`skew${transformAxes[i]}`, visualElement, resetValues, this.animationValues);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Force a render of this element to apply the transform with all skews and rotations</span><span class="s3">\n            </span><span class="s1">// set to 0.</span><span class="s3">\n            </span><span class="s1">visualElement.render();</span><span class="s3">\n            </span><span class="s1">// Put back all the values we reset</span><span class="s3">\n            </span><span class="s1">for (const key in resetValues) {</span><span class="s3">\n                </span><span class="s1">visualElement.setStaticValue(key, resetValues[key]);</span><span class="s3">\n                </span><span class="s1">if (this.animationValues) {</span><span class="s3">\n                    </span><span class="s1">this.animationValues[key] = resetValues[key];</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Schedule a render for the next frame. This ensures we won't visually</span><span class="s3">\n            </span><span class="s1">// see the element with the reset rotate value applied.</span><span class="s3">\n            </span><span class="s1">visualElement.scheduleRender();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">applyProjectionStyles(targetStyle, // CSSStyleDeclaration - doesn't allow numbers to be assigned to properties</span><span class="s3">\n        </span><span class="s1">styleProp) {</span><span class="s3">\n            </span><span class="s1">if (!this.instance || this.isSVG)</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">if (!this.isVisible) {</span><span class="s3">\n                </span><span class="s1">targetStyle.visibility = </span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const transformTemplate = this.getTransformTemplate();</span><span class="s3">\n            </span><span class="s1">if (this.needsReset) {</span><span class="s3">\n                </span><span class="s1">this.needsReset = false;</span><span class="s3">\n                </span><span class="s1">targetStyle.visibility = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n                </span><span class="s1">targetStyle.opacity = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n                </span><span class="s1">targetStyle.pointerEvents =</span><span class="s3">\n                    </span><span class="s1">resolveMotionValue(styleProp?.pointerEvents) || </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n                </span><span class="s1">targetStyle.transform = transformTemplate</span><span class="s3">\n                    </span><span class="s1">? transformTemplate(this.latestValues, </span><span class="s3">\&quot;\&quot;</span><span class="s1">)</span><span class="s3">\n                    </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const lead = this.getLead();</span><span class="s3">\n            </span><span class="s1">if (!this.projectionDelta || !this.layout || !lead.target) {</span><span class="s3">\n                </span><span class="s1">if (this.options.layoutId) {</span><span class="s3">\n                    </span><span class="s1">targetStyle.opacity =</span><span class="s3">\n                        </span><span class="s1">this.latestValues.opacity !== undefined</span><span class="s3">\n                            </span><span class="s1">? this.latestValues.opacity</span><span class="s3">\n                            </span><span class="s1">: 1;</span><span class="s3">\n                    </span><span class="s1">targetStyle.pointerEvents =</span><span class="s3">\n                        </span><span class="s1">resolveMotionValue(styleProp?.pointerEvents) || </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (this.hasProjected &amp;&amp; !hasTransform(this.latestValues)) {</span><span class="s3">\n                    </span><span class="s1">targetStyle.transform = transformTemplate</span><span class="s3">\n                        </span><span class="s1">? transformTemplate({}, </span><span class="s3">\&quot;\&quot;</span><span class="s1">)</span><span class="s3">\n                        </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n                    </span><span class="s1">this.hasProjected = false;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">targetStyle.visibility = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">const valuesToRender = lead.animationValues || lead.latestValues;</span><span class="s3">\n            </span><span class="s1">this.applyTransformsToTarget();</span><span class="s3">\n            </span><span class="s1">let transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);</span><span class="s3">\n            </span><span class="s1">if (transformTemplate) {</span><span class="s3">\n                </span><span class="s1">transform = transformTemplate(valuesToRender, transform);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">targetStyle.transform = transform;</span><span class="s3">\n            </span><span class="s1">const { x, y } = this.projectionDelta;</span><span class="s3">\n            </span><span class="s1">targetStyle.transformOrigin = `${x.origin * 100}% ${y.origin * 100}% 0`;</span><span class="s3">\n            </span><span class="s1">if (lead.animationValues) {</span><span class="s3">\n                </span><span class="s1">/**</span><span class="s3">\n                 </span><span class="s1">* If the lead component is animating, assign this either the entering/leaving</span><span class="s3">\n                 </span><span class="s1">* opacity</span><span class="s3">\n                 </span><span class="s1">*/</span><span class="s3">\n                </span><span class="s1">targetStyle.opacity =</span><span class="s3">\n                    </span><span class="s1">lead === this</span><span class="s3">\n                        </span><span class="s1">? valuesToRender.opacity ??</span><span class="s3">\n                            </span><span class="s1">this.latestValues.opacity ??</span><span class="s3">\n                            </span><span class="s1">1</span><span class="s3">\n                        </span><span class="s1">: this.preserveOpacity</span><span class="s3">\n                            </span><span class="s1">? this.latestValues.opacity</span><span class="s3">\n                            </span><span class="s1">: valuesToRender.opacityExit;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">/**</span><span class="s3">\n                 </span><span class="s1">* Or we're not animating at all, set the lead component to its layout</span><span class="s3">\n                 </span><span class="s1">* opacity and other components to hidden.</span><span class="s3">\n                 </span><span class="s1">*/</span><span class="s3">\n                </span><span class="s1">targetStyle.opacity =</span><span class="s3">\n                    </span><span class="s1">lead === this</span><span class="s3">\n                        </span><span class="s1">? valuesToRender.opacity !== undefined</span><span class="s3">\n                            </span><span class="s1">? valuesToRender.opacity</span><span class="s3">\n                            </span><span class="s1">: </span><span class="s3">\&quot;\&quot;\n                        </span><span class="s1">: valuesToRender.opacityExit !== undefined</span><span class="s3">\n                            </span><span class="s1">? valuesToRender.opacityExit</span><span class="s3">\n                            </span><span class="s1">: 0;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* Apply scale correction</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">for (const key in scaleCorrectors) {</span><span class="s3">\n                </span><span class="s1">if (valuesToRender[key] === undefined)</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">const { correct, applyTo, isCSSVariable } = scaleCorrectors[key];</span><span class="s3">\n                </span><span class="s1">/**</span><span class="s3">\n                 </span><span class="s1">* Only apply scale correction to the value if we have an</span><span class="s3">\n                 </span><span class="s1">* active projection transform. Otherwise these values become</span><span class="s3">\n                 </span><span class="s1">* vulnerable to distortion if the element changes size without</span><span class="s3">\n                 </span><span class="s1">* a corresponding layout animation.</span><span class="s3">\n                 </span><span class="s1">*/</span><span class="s3">\n                </span><span class="s1">const corrected = transform === </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;\n                    </span><span class="s1">? valuesToRender[key]</span><span class="s3">\n                    </span><span class="s1">: correct(valuesToRender[key], lead);</span><span class="s3">\n                </span><span class="s1">if (applyTo) {</span><span class="s3">\n                    </span><span class="s1">const num = applyTo.length;</span><span class="s3">\n                    </span><span class="s1">for (let i = 0; i &lt; num; i++) {</span><span class="s3">\n                        </span><span class="s1">targetStyle[applyTo[i]] = corrected;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">// If this is a CSS variable, set it directly on the instance.</span><span class="s3">\n                    </span><span class="s1">// Replacing this function from creating styles to setting them</span><span class="s3">\n                    </span><span class="s1">// would be a good place to remove per frame object creation</span><span class="s3">\n                    </span><span class="s1">if (isCSSVariable) {</span><span class="s3">\n                        </span><span class="s1">this.options.visualElement.renderState.vars[key] = corrected;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">targetStyle[key] = corrected;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* Disable pointer events on follow components. This is to ensure</span><span class="s3">\n             </span><span class="s1">* that if a follow component covers a lead component it doesn't block</span><span class="s3">\n             </span><span class="s1">* pointer events on the lead.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">if (this.options.layoutId) {</span><span class="s3">\n                </span><span class="s1">targetStyle.pointerEvents =</span><span class="s3">\n                    </span><span class="s1">lead === this</span><span class="s3">\n                        </span><span class="s1">? resolveMotionValue(styleProp?.pointerEvents) || </span><span class="s3">\&quot;\&quot;\n                        </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">clearSnapshot() {</span><span class="s3">\n            </span><span class="s1">this.resumeFrom = this.snapshot = undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Only run on root</span><span class="s3">\n        </span><span class="s1">resetTree() {</span><span class="s3">\n            </span><span class="s1">this.root.nodes.forEach((node) =&gt; node.currentAnimation?.stop());</span><span class="s3">\n            </span><span class="s1">this.root.nodes.forEach(clearMeasurements);</span><span class="s3">\n            </span><span class="s1">this.root.sharedNodes.clear();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function updateLayout(node) {</span><span class="s3">\n    </span><span class="s1">node.updateLayout();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function notifyLayoutUpdate(node) {</span><span class="s3">\n    </span><span class="s1">const snapshot = node.resumeFrom?.snapshot || node.snapshot;</span><span class="s3">\n    </span><span class="s1">if (node.isLead() &amp;&amp;</span><span class="s3">\n        </span><span class="s1">node.layout &amp;&amp;</span><span class="s3">\n        </span><span class="s1">snapshot &amp;&amp;</span><span class="s3">\n        </span><span class="s1">node.hasListeners(</span><span class="s3">\&quot;</span><span class="s1">didUpdate</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n        </span><span class="s1">const { layoutBox: layout, measuredBox: measuredLayout } = node.layout;</span><span class="s3">\n        </span><span class="s1">const { animationType } = node.options;</span><span class="s3">\n        </span><span class="s1">const isShared = snapshot.source !== node.layout.source;</span><span class="s3">\n        </span><span class="s1">// TODO Maybe we want to also resize the layout snapshot so we don't trigger</span><span class="s3">\n        </span><span class="s1">// animations for instance if layout=</span><span class="s3">\&quot;</span><span class="s1">size</span><span class="s3">\&quot; </span><span class="s1">and an element has only changed position</span><span class="s3">\n        </span><span class="s1">if (animationType === </span><span class="s3">\&quot;</span><span class="s1">size</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">eachAxis((axis) =&gt; {</span><span class="s3">\n                </span><span class="s1">const axisSnapshot = isShared</span><span class="s3">\n                    </span><span class="s1">? snapshot.measuredBox[axis]</span><span class="s3">\n                    </span><span class="s1">: snapshot.layoutBox[axis];</span><span class="s3">\n                </span><span class="s1">const length = calcLength(axisSnapshot);</span><span class="s3">\n                </span><span class="s1">axisSnapshot.min = layout[axis].min;</span><span class="s3">\n                </span><span class="s1">axisSnapshot.max = axisSnapshot.min + length;</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout)) {</span><span class="s3">\n            </span><span class="s1">eachAxis((axis) =&gt; {</span><span class="s3">\n                </span><span class="s1">const axisSnapshot = isShared</span><span class="s3">\n                    </span><span class="s1">? snapshot.measuredBox[axis]</span><span class="s3">\n                    </span><span class="s1">: snapshot.layoutBox[axis];</span><span class="s3">\n                </span><span class="s1">const length = calcLength(layout[axis]);</span><span class="s3">\n                </span><span class="s1">axisSnapshot.max = axisSnapshot.min + length;</span><span class="s3">\n                </span><span class="s1">/**</span><span class="s3">\n                 </span><span class="s1">* Ensure relative target gets resized and rerendererd</span><span class="s3">\n                 </span><span class="s1">*/</span><span class="s3">\n                </span><span class="s1">if (node.relativeTarget &amp;&amp; !node.currentAnimation) {</span><span class="s3">\n                    </span><span class="s1">node.isProjectionDirty = true;</span><span class="s3">\n                    </span><span class="s1">node.relativeTarget[axis].max =</span><span class="s3">\n                        </span><span class="s1">node.relativeTarget[axis].min + length;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const layoutDelta = createDelta();</span><span class="s3">\n        </span><span class="s1">calcBoxDelta(layoutDelta, layout, snapshot.layoutBox);</span><span class="s3">\n        </span><span class="s1">const visualDelta = createDelta();</span><span class="s3">\n        </span><span class="s1">if (isShared) {</span><span class="s3">\n            </span><span class="s1">calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measuredBox);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">calcBoxDelta(visualDelta, layout, snapshot.layoutBox);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const hasLayoutChanged = !isDeltaZero(layoutDelta);</span><span class="s3">\n        </span><span class="s1">let hasRelativeLayoutChanged = false;</span><span class="s3">\n        </span><span class="s1">if (!node.resumeFrom) {</span><span class="s3">\n            </span><span class="s1">const relativeParent = node.getClosestProjectingParent();</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* If the relativeParent is itself resuming from a different element then</span><span class="s3">\n             </span><span class="s1">* the relative snapshot is not relavent</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">if (relativeParent &amp;&amp; !relativeParent.resumeFrom) {</span><span class="s3">\n                </span><span class="s1">const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;</span><span class="s3">\n                </span><span class="s1">if (parentSnapshot &amp;&amp; parentLayout) {</span><span class="s3">\n                    </span><span class="s1">const relativeSnapshot = createBox();</span><span class="s3">\n                    </span><span class="s1">calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);</span><span class="s3">\n                    </span><span class="s1">const relativeLayout = createBox();</span><span class="s3">\n                    </span><span class="s1">calcRelativePosition(relativeLayout, layout, parentLayout.layoutBox);</span><span class="s3">\n                    </span><span class="s1">if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {</span><span class="s3">\n                        </span><span class="s1">hasRelativeLayoutChanged = true;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">if (relativeParent.options.layoutRoot) {</span><span class="s3">\n                        </span><span class="s1">node.relativeTarget = relativeLayout;</span><span class="s3">\n                        </span><span class="s1">node.relativeTargetOrigin = relativeSnapshot;</span><span class="s3">\n                        </span><span class="s1">node.relativeParent = relativeParent;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">node.notifyListeners(</span><span class="s3">\&quot;</span><span class="s1">didUpdate</span><span class="s3">\&quot;</span><span class="s1">, {</span><span class="s3">\n            </span><span class="s1">layout,</span><span class="s3">\n            </span><span class="s1">snapshot,</span><span class="s3">\n            </span><span class="s1">delta: visualDelta,</span><span class="s3">\n            </span><span class="s1">layoutDelta,</span><span class="s3">\n            </span><span class="s1">hasLayoutChanged,</span><span class="s3">\n            </span><span class="s1">hasRelativeLayoutChanged,</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (node.isLead()) {</span><span class="s3">\n        </span><span class="s1">const { onExitComplete } = node.options;</span><span class="s3">\n        </span><span class="s1">onExitComplete &amp;&amp; onExitComplete();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Clearing transition</span><span class="s3">\n     </span><span class="s1">* TODO: Investigate why this transition is being passed in as {type: false } from Framer</span><span class="s3">\n     </span><span class="s1">* and why we need it at all</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">node.options.transition = undefined;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function propagateDirtyNodes(node) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Increase debug counter for nodes encountered this frame</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">if (statsBuffer.value) {</span><span class="s3">\n        </span><span class="s1">metrics.nodes++;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!node.parent)</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* If this node isn't projecting, propagate isProjectionDirty. It will have</span><span class="s3">\n     </span><span class="s1">* no performance impact but it will allow the next child that *is* projecting</span><span class="s3">\n     </span><span class="s1">* but *isn't* dirty to just check its parent to see if *any* ancestor needs</span><span class="s3">\n     </span><span class="s1">* correcting.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">if (!node.isProjecting()) {</span><span class="s3">\n        </span><span class="s1">node.isProjectionDirty = node.parent.isProjectionDirty;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Propagate isSharedProjectionDirty and isTransformDirty</span><span class="s3">\n     </span><span class="s1">* throughout the whole tree. A future revision can take another look at</span><span class="s3">\n     </span><span class="s1">* this but for safety we still recalcualte shared nodes.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">node.isSharedProjectionDirty || (node.isSharedProjectionDirty = Boolean(node.isProjectionDirty ||</span><span class="s3">\n        </span><span class="s1">node.parent.isProjectionDirty ||</span><span class="s3">\n        </span><span class="s1">node.parent.isSharedProjectionDirty));</span><span class="s3">\n    </span><span class="s1">node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function cleanDirtyNodes(node) {</span><span class="s3">\n    </span><span class="s1">node.isProjectionDirty =</span><span class="s3">\n        </span><span class="s1">node.isSharedProjectionDirty =</span><span class="s3">\n            </span><span class="s1">node.isTransformDirty =</span><span class="s3">\n                </span><span class="s1">false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function clearSnapshot(node) {</span><span class="s3">\n    </span><span class="s1">node.clearSnapshot();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function clearMeasurements(node) {</span><span class="s3">\n    </span><span class="s1">node.clearMeasurements();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function clearIsLayoutDirty(node) {</span><span class="s3">\n    </span><span class="s1">node.isLayoutDirty = false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function resetTransformStyle(node) {</span><span class="s3">\n    </span><span class="s1">const { visualElement } = node.options;</span><span class="s3">\n    </span><span class="s1">if (visualElement &amp;&amp; visualElement.getProps().onBeforeLayoutMeasure) {</span><span class="s3">\n        </span><span class="s1">visualElement.notify(</span><span class="s3">\&quot;</span><span class="s1">BeforeLayoutMeasure</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">node.resetTransform();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function finishAnimation(node) {</span><span class="s3">\n    </span><span class="s1">node.finishAnimation();</span><span class="s3">\n    </span><span class="s1">node.targetDelta = node.relativeTarget = node.target = undefined;</span><span class="s3">\n    </span><span class="s1">node.isProjectionDirty = true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function resolveTargetDelta(node) {</span><span class="s3">\n    </span><span class="s1">node.resolveTargetDelta();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function calcProjection(node) {</span><span class="s3">\n    </span><span class="s1">node.calcProjection();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function resetSkewAndRotation(node) {</span><span class="s3">\n    </span><span class="s1">node.resetSkewAndRotation();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function removeLeadSnapshots(stack) {</span><span class="s3">\n    </span><span class="s1">stack.removeLeadSnapshot();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function mixAxisDelta(output, delta, p) {</span><span class="s3">\n    </span><span class="s1">output.translate = mixNumber(delta.translate, 0, p);</span><span class="s3">\n    </span><span class="s1">output.scale = mixNumber(delta.scale, 1, p);</span><span class="s3">\n    </span><span class="s1">output.origin = delta.origin;</span><span class="s3">\n    </span><span class="s1">output.originPoint = delta.originPoint;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function mixAxis(output, from, to, p) {</span><span class="s3">\n    </span><span class="s1">output.min = mixNumber(from.min, to.min, p);</span><span class="s3">\n    </span><span class="s1">output.max = mixNumber(from.max, to.max, p);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function mixBox(output, from, to, p) {</span><span class="s3">\n    </span><span class="s1">mixAxis(output.x, from.x, to.x, p);</span><span class="s3">\n    </span><span class="s1">mixAxis(output.y, from.y, to.y, p);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function hasOpacityCrossfade(node) {</span><span class="s3">\n    </span><span class="s1">return (node.animationValues &amp;&amp; node.animationValues.opacityExit !== undefined);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const defaultLayoutTransition = {</span><span class="s3">\n    </span><span class="s1">duration: 0.45,</span><span class="s3">\n    </span><span class="s1">ease: [0.4, 0, 0.1, 1],</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const userAgentContains = (string) =&gt; typeof navigator !== </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n    </span><span class="s1">navigator.userAgent &amp;&amp;</span><span class="s3">\n    </span><span class="s1">navigator.userAgent.toLowerCase().includes(string);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Measured bounding boxes must be rounded in Safari and</span><span class="s3">\n </span><span class="s1">* left untouched in Chrome, otherwise non-integer layouts within scaled-up elements</span><span class="s3">\n </span><span class="s1">* can appear to jump.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const roundPoint = userAgentContains(</span><span class="s3">\&quot;</span><span class="s1">applewebkit/</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp; !userAgentContains(</span><span class="s3">\&quot;</span><span class="s1">chrome/</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">? Math.round</span><span class="s3">\n    </span><span class="s1">: noop;</span><span class="s3">\n</span><span class="s1">function roundAxis(axis) {</span><span class="s3">\n    </span><span class="s1">// Round to the nearest .5 pixels to support subpixel layouts</span><span class="s3">\n    </span><span class="s1">axis.min = roundPoint(axis.min);</span><span class="s3">\n    </span><span class="s1">axis.max = roundPoint(axis.max);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function roundBox(box) {</span><span class="s3">\n    </span><span class="s1">roundAxis(box.x);</span><span class="s3">\n    </span><span class="s1">roundAxis(box.y);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function shouldAnimatePositionOnly(animationType, snapshot, layout) {</span><span class="s3">\n    </span><span class="s1">return (animationType === </span><span class="s3">\&quot;</span><span class="s1">position</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n        </span><span class="s1">(animationType === </span><span class="s3">\&quot;</span><span class="s1">preserve-aspect</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n            </span><span class="s1">!isNear(aspectRatio(snapshot), aspectRatio(layout), 0.2)));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function checkNodeWasScrollRoot(node) {</span><span class="s3">\n    </span><span class="s1">return node !== node.root &amp;&amp; node.scroll?.wasRoot;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { cleanDirtyNodes, createProjectionNode, mixAxis, mixAxisDelta, mixBox, propagateDirtyNodes };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">7193</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/projection/node/DocumentProjectionNode.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { addDomEvent } from '../../events/add-dom-event.mjs';</span><span class="s3">\n</span><span class="s1">import { createProjectionNode } from './create-projection-node.mjs';</span><span class="s3">\n\n</span><span class="s1">const DocumentProjectionNode = createProjectionNode({</span><span class="s3">\n    </span><span class="s1">attachResizeListener: (ref, notify) =&gt; addDomEvent(ref, </span><span class="s3">\&quot;</span><span class="s1">resize</span><span class="s3">\&quot;</span><span class="s1">, notify),</span><span class="s3">\n    </span><span class="s1">measureScroll: () =&gt; ({</span><span class="s3">\n        </span><span class="s1">x: document.documentElement.scrollLeft || document.body.scrollLeft,</span><span class="s3">\n        </span><span class="s1">y: document.documentElement.scrollTop || document.body.scrollTop,</span><span class="s3">\n    </span><span class="s1">}),</span><span class="s3">\n    </span><span class="s1">checkIsScrollRoot: () =&gt; true,</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">export { DocumentProjectionNode };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;AACA;;;AAEA,MAAM,yBAAyB,IAAA,gOAAoB,EAAC;IAChD,sBAAsB,CAAC,KAAK,SAAW,IAAA,kMAAW,EAAC,KAAK,UAAU;IAClE,eAAe,IAAM,CAAC;YAClB,GAAG,SAAS,eAAe,CAAC,UAAU,IAAI,SAAS,IAAI,CAAC,UAAU;YAClE,GAAG,SAAS,eAAe,CAAC,SAAS,IAAI,SAAS,IAAI,CAAC,SAAS;QACpE,CAAC;IACD,mBAAmB,IAAM;AAC7B&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">7214</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/projection/node/HTMLProjectionNode.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { createProjectionNode } from './create-projection-node.mjs';</span><span class="s3">\n</span><span class="s1">import { DocumentProjectionNode } from './DocumentProjectionNode.mjs';</span><span class="s3">\n\n</span><span class="s1">const rootProjectionNode = {</span><span class="s3">\n    </span><span class="s1">current: undefined,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const HTMLProjectionNode = createProjectionNode({</span><span class="s3">\n    </span><span class="s1">measureScroll: (instance) =&gt; ({</span><span class="s3">\n        </span><span class="s1">x: instance.scrollLeft,</span><span class="s3">\n        </span><span class="s1">y: instance.scrollTop,</span><span class="s3">\n    </span><span class="s1">}),</span><span class="s3">\n    </span><span class="s1">defaultParent: () =&gt; {</span><span class="s3">\n        </span><span class="s1">if (!rootProjectionNode.current) {</span><span class="s3">\n            </span><span class="s1">const documentNode = new DocumentProjectionNode({});</span><span class="s3">\n            </span><span class="s1">documentNode.mount(window);</span><span class="s3">\n            </span><span class="s1">documentNode.setOptions({ layoutScroll: true });</span><span class="s3">\n            </span><span class="s1">rootProjectionNode.current = documentNode;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return rootProjectionNode.current;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">resetTransform: (instance, value) =&gt; {</span><span class="s3">\n        </span><span class="s1">instance.style.transform = value !== undefined ? value : </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">checkIsScrollRoot: (instance) =&gt; Boolean(window.getComputedStyle(instance).position === </span><span class="s3">\&quot;</span><span class="s1">fixed</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">export { HTMLProjectionNode, rootProjectionNode };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;AAAA;AACA;;;AAEA,MAAM,qBAAqB;IACvB,SAAS;AACb;AACA,MAAM,qBAAqB,IAAA,gOAAoB,EAAC;IAC5C,eAAe,CAAC,WAAa,CAAC;YAC1B,GAAG,SAAS,UAAU;YACtB,GAAG,SAAS,SAAS;QACzB,CAAC;IACD,eAAe;QACX,IAAI,CAAC,mBAAmB,OAAO,EAAE;YAC7B,MAAM,eAAe,IAAI,4NAAsB,CAAC,CAAC;YACjD,aAAa,KAAK,CAAC;YACnB,aAAa,UAAU,CAAC;gBAAE,cAAc;YAAK;YAC7C,mBAAmB,OAAO,GAAG;QACjC;QACA,OAAO,mBAAmB,OAAO;IACrC;IACA,gBAAgB,CAAC,UAAU;QACvB,SAAS,KAAK,CAAC,SAAS,GAAG,UAAU,YAAY,QAAQ;IAC7D;IACA,mBAAmB,CAAC,WAAa,QAAQ,OAAO,gBAAgB,CAAC,UAAU,QAAQ,KAAK;AAC5F&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">7253</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/motion/features/drag.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { DragGesture } from '../../gestures/drag/index.mjs';</span><span class="s3">\n</span><span class="s1">import { PanGesture } from '../../gestures/pan/index.mjs';</span><span class="s3">\n</span><span class="s1">import { MeasureLayout } from './layout/MeasureLayout.mjs';</span><span class="s3">\n</span><span class="s1">import { HTMLProjectionNode } from '../../projection/node/HTMLProjectionNode.mjs';</span><span class="s3">\n\n</span><span class="s1">const drag = {</span><span class="s3">\n    </span><span class="s1">pan: {</span><span class="s3">\n        </span><span class="s1">Feature: PanGesture,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">drag: {</span><span class="s3">\n        </span><span class="s1">Feature: DragGesture,</span><span class="s3">\n        </span><span class="s1">ProjectionNode: HTMLProjectionNode,</span><span class="s3">\n        </span><span class="s1">MeasureLayout,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export { drag };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;AACA;AACA;AACA;;;;;AAEA,MAAM,OAAO;IACT,KAAK;QACD,SAAS,4LAAU;IACvB;IACA,MAAM;QACF,SAAS,8LAAW;QACpB,gBAAgB,oNAAkB;QAClC,eAAA,oNAAa;IACjB;AACJ&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">7280</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/gestures/hover.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { hover, frame } from 'motion-dom';</span><span class="s3">\n</span><span class="s1">import { extractEventInfo } from '../events/event-info.mjs';</span><span class="s3">\n</span><span class="s1">import { Feature } from '../motion/features/Feature.mjs';</span><span class="s3">\n\n</span><span class="s1">function handleHoverEvent(node, event, lifecycle) {</span><span class="s3">\n    </span><span class="s1">const { props } = node;</span><span class="s3">\n    </span><span class="s1">if (node.animationState &amp;&amp; props.whileHover) {</span><span class="s3">\n        </span><span class="s1">node.animationState.setActive(</span><span class="s3">\&quot;</span><span class="s1">whileHover</span><span class="s3">\&quot;</span><span class="s1">, lifecycle === </span><span class="s3">\&quot;</span><span class="s1">Start</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const eventName = (</span><span class="s3">\&quot;</span><span class="s1">onHover</span><span class="s3">\&quot; </span><span class="s1">+ lifecycle);</span><span class="s3">\n    </span><span class="s1">const callback = props[eventName];</span><span class="s3">\n    </span><span class="s1">if (callback) {</span><span class="s3">\n        </span><span class="s1">frame.postRender(() =&gt; callback(event, extractEventInfo(event)));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class HoverGesture extends Feature {</span><span class="s3">\n    </span><span class="s1">mount() {</span><span class="s3">\n        </span><span class="s1">const { current } = this.node;</span><span class="s3">\n        </span><span class="s1">if (!current)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">this.unmount = hover(current, (_element, startEvent) =&gt; {</span><span class="s3">\n            </span><span class="s1">handleHoverEvent(this.node, startEvent, </span><span class="s3">\&quot;</span><span class="s1">Start</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">return (endEvent) =&gt; handleHoverEvent(this.node, endEvent, </span><span class="s3">\&quot;</span><span class="s1">End</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">unmount() { }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { HoverGesture };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;AAAA;AACA;AACA;;;;AAEA,SAAS,iBAAiB,IAAI,EAAE,KAAK,EAAE,SAAS;IAC5C,MAAM,EAAE,KAAK,EAAE,GAAG;IAClB,IAAI,KAAK,cAAc,IAAI,MAAM,UAAU,EAAE;QACzC,KAAK,cAAc,CAAC,SAAS,CAAC,cAAc,cAAc;IAC9D;IACA,MAAM,YAAa,YAAY;IAC/B,MAAM,WAAW,KAAK,CAAC,UAAU;IACjC,IAAI,UAAU;QACV,8KAAK,CAAC,UAAU,CAAC,IAAM,SAAS,OAAO,IAAA,iMAAgB,EAAC;IAC5D;AACJ;AACA,MAAM,qBAAqB,8LAAO;IAC9B,QAAQ;QACJ,MAAM,EAAE,OAAO,EAAE,GAAG,IAAI,CAAC,IAAI;QAC7B,IAAI,CAAC,SACD;QACJ,IAAI,CAAC,OAAO,GAAG,IAAA,6KAAK,EAAC,SAAS,CAAC,UAAU;YACrC,iBAAiB,IAAI,CAAC,IAAI,EAAE,YAAY;YACxC,OAAO,CAAC,WAAa,iBAAiB,IAAI,CAAC,IAAI,EAAE,UAAU;QAC/D;IACJ;IACA,UAAU,CAAE;AAChB&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">7318</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/gestures/focus.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { pipe } from 'motion-utils';</span><span class="s3">\n</span><span class="s1">import { addDomEvent } from '../events/add-dom-event.mjs';</span><span class="s3">\n</span><span class="s1">import { Feature } from '../motion/features/Feature.mjs';</span><span class="s3">\n\n</span><span class="s1">class FocusGesture extends Feature {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">super(...arguments);</span><span class="s3">\n        </span><span class="s1">this.isActive = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">onFocus() {</span><span class="s3">\n        </span><span class="s1">let isFocusVisible = false;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* If this element doesn't match focus-visible then don't</span><span class="s3">\n         </span><span class="s1">* apply whileHover. But, if matches throws that focus-visible</span><span class="s3">\n         </span><span class="s1">* is not a valid selector then in that browser outline styles will be applied</span><span class="s3">\n         </span><span class="s1">* to the element by default and we want to match that behaviour with whileFocus.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">isFocusVisible = this.node.current.matches(</span><span class="s3">\&quot;</span><span class="s1">:focus-visible</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">catch (e) {</span><span class="s3">\n            </span><span class="s1">isFocusVisible = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!isFocusVisible || !this.node.animationState)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">this.node.animationState.setActive(</span><span class="s3">\&quot;</span><span class="s1">whileFocus</span><span class="s3">\&quot;</span><span class="s1">, true);</span><span class="s3">\n        </span><span class="s1">this.isActive = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">onBlur() {</span><span class="s3">\n        </span><span class="s1">if (!this.isActive || !this.node.animationState)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">this.node.animationState.setActive(</span><span class="s3">\&quot;</span><span class="s1">whileFocus</span><span class="s3">\&quot;</span><span class="s1">, false);</span><span class="s3">\n        </span><span class="s1">this.isActive = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">mount() {</span><span class="s3">\n        </span><span class="s1">this.unmount = pipe(addDomEvent(this.node.current, </span><span class="s3">\&quot;</span><span class="s1">focus</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; this.onFocus()), addDomEvent(this.node.current, </span><span class="s3">\&quot;</span><span class="s1">blur</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; this.onBlur()));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">unmount() { }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { FocusGesture };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;AACA;AACA;;;;AAEA,MAAM,qBAAqB,8LAAO;IAK9B,UAAU;QACN,IAAI,iBAAiB;QACrB;;;;;SAKC,GACD,IAAI;YACA,iBAAiB,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC;QAC/C,EACA,OAAO,GAAG;YACN,iBAAiB;QACrB;QACA,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,IAAI,CAAC,cAAc,EAC5C;QACJ,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,SAAS,CAAC,cAAc;QACjD,IAAI,CAAC,QAAQ,GAAG;IACpB;IACA,SAAS;QACL,IAAI,CAAC,IAAI,CAAC,QAAQ,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,cAAc,EAC3C;QACJ,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,SAAS,CAAC,cAAc;QACjD,IAAI,CAAC,QAAQ,GAAG;IACpB;IACA,QAAQ;QACJ,IAAI,CAAC,OAAO,GAAG,IAAA,iKAAI,EAAC,IAAA,kMAAW,EAAC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,SAAS,IAAM,IAAI,CAAC,OAAO,KAAK,IAAA,kMAAW,EAAC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,QAAQ,IAAM,IAAI,CAAC,MAAM;IAC/I;IACA,UAAU,CAAE;IAhCZ,aAAc;QACV,KAAK,IAAI;QACT,IAAI,CAAC,QAAQ,GAAG;IACpB;AA8BJ&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">7364</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/gestures/press.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { press, frame } from 'motion-dom';</span><span class="s3">\n</span><span class="s1">import { extractEventInfo } from '../events/event-info.mjs';</span><span class="s3">\n</span><span class="s1">import { Feature } from '../motion/features/Feature.mjs';</span><span class="s3">\n\n</span><span class="s1">function handlePressEvent(node, event, lifecycle) {</span><span class="s3">\n    </span><span class="s1">const { props } = node;</span><span class="s3">\n    </span><span class="s1">if (node.current instanceof HTMLButtonElement &amp;&amp; node.current.disabled) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (node.animationState &amp;&amp; props.whileTap) {</span><span class="s3">\n        </span><span class="s1">node.animationState.setActive(</span><span class="s3">\&quot;</span><span class="s1">whileTap</span><span class="s3">\&quot;</span><span class="s1">, lifecycle === </span><span class="s3">\&quot;</span><span class="s1">Start</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const eventName = (</span><span class="s3">\&quot;</span><span class="s1">onTap</span><span class="s3">\&quot; </span><span class="s1">+ (lifecycle === </span><span class="s3">\&quot;</span><span class="s1">End</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;\&quot; </span><span class="s1">: lifecycle));</span><span class="s3">\n    </span><span class="s1">const callback = props[eventName];</span><span class="s3">\n    </span><span class="s1">if (callback) {</span><span class="s3">\n        </span><span class="s1">frame.postRender(() =&gt; callback(event, extractEventInfo(event)));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class PressGesture extends Feature {</span><span class="s3">\n    </span><span class="s1">mount() {</span><span class="s3">\n        </span><span class="s1">const { current } = this.node;</span><span class="s3">\n        </span><span class="s1">if (!current)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">this.unmount = press(current, (_element, startEvent) =&gt; {</span><span class="s3">\n            </span><span class="s1">handlePressEvent(this.node, startEvent, </span><span class="s3">\&quot;</span><span class="s1">Start</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">return (endEvent, { success }) =&gt; handlePressEvent(this.node, endEvent, success ? </span><span class="s3">\&quot;</span><span class="s1">End</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">Cancel</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}, { useGlobalTarget: this.node.props.globalTapTarget });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">unmount() { }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { PressGesture };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;AAAA;AACA;AACA;;;;AAEA,SAAS,iBAAiB,IAAI,EAAE,KAAK,EAAE,SAAS;IAC5C,MAAM,EAAE,KAAK,EAAE,GAAG;IAClB,IAAI,KAAK,OAAO,YAAY,qBAAqB,KAAK,OAAO,CAAC,QAAQ,EAAE;QACpE;IACJ;IACA,IAAI,KAAK,cAAc,IAAI,MAAM,QAAQ,EAAE;QACvC,KAAK,cAAc,CAAC,SAAS,CAAC,YAAY,cAAc;IAC5D;IACA,MAAM,YAAa,UAAU,CAAC,cAAc,QAAQ,KAAK,SAAS;IAClE,MAAM,WAAW,KAAK,CAAC,UAAU;IACjC,IAAI,UAAU;QACV,8KAAK,CAAC,UAAU,CAAC,IAAM,SAAS,OAAO,IAAA,iMAAgB,EAAC;IAC5D;AACJ;AACA,MAAM,qBAAqB,8LAAO;IAC9B,QAAQ;QACJ,MAAM,EAAE,OAAO,EAAE,GAAG,IAAI,CAAC,IAAI;QAC7B,IAAI,CAAC,SACD;QACJ,IAAI,CAAC,OAAO,GAAG,IAAA,sLAAK,EAAC,SAAS,CAAC,UAAU;YACrC,iBAAiB,IAAI,CAAC,IAAI,EAAE,YAAY;YACxC,OAAO,CAAC;oBAAU,EAAE,OAAO,EAAE;uBAAK,iBAAiB,IAAI,CAAC,IAAI,EAAE,UAAU,UAAU,QAAQ;;QAC9F,GAAG;YAAE,iBAAiB,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,eAAe;QAAC;IAC1D;IACA,UAAU,CAAE;AAChB&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">7410</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/motion/features/viewport/observers.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Map an IntersectionHandler callback to an element. We only ever make one handler for one</span><span class="s3">\n </span><span class="s1">* element, so even though these handlers might all be triggered by different</span><span class="s3">\n </span><span class="s1">* observers, we can keep them in the same map.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const observerCallbacks = new WeakMap();</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Multiple observers can be created for multiple element/document roots. Each with</span><span class="s3">\n </span><span class="s1">* different settings. So here we store dictionaries of observers to each root,</span><span class="s3">\n </span><span class="s1">* using serialised settings (threshold/margin) as lookup keys.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const observers = new WeakMap();</span><span class="s3">\n</span><span class="s1">const fireObserverCallback = (entry) =&gt; {</span><span class="s3">\n    </span><span class="s1">const callback = observerCallbacks.get(entry.target);</span><span class="s3">\n    </span><span class="s1">callback &amp;&amp; callback(entry);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const fireAllObserverCallbacks = (entries) =&gt; {</span><span class="s3">\n    </span><span class="s1">entries.forEach(fireObserverCallback);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function initIntersectionObserver({ root, ...options }) {</span><span class="s3">\n    </span><span class="s1">const lookupRoot = root || document;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* If we don't have an observer lookup map for this root, create one.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">if (!observers.has(lookupRoot)) {</span><span class="s3">\n        </span><span class="s1">observers.set(lookupRoot, {});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const rootObservers = observers.get(lookupRoot);</span><span class="s3">\n    </span><span class="s1">const key = JSON.stringify(options);</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* If we don't have an observer for this combination of root and settings,</span><span class="s3">\n     </span><span class="s1">* create one.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">if (!rootObservers[key]) {</span><span class="s3">\n        </span><span class="s1">rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return rootObservers[key];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function observeIntersection(element, options, callback) {</span><span class="s3">\n    </span><span class="s1">const rootInteresectionObserver = initIntersectionObserver(options);</span><span class="s3">\n    </span><span class="s1">observerCallbacks.set(element, callback);</span><span class="s3">\n    </span><span class="s1">rootInteresectionObserver.observe(element);</span><span class="s3">\n    </span><span class="s1">return () =&gt; {</span><span class="s3">\n        </span><span class="s1">observerCallbacks.delete(element);</span><span class="s3">\n        </span><span class="s1">rootInteresectionObserver.unobserve(element);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { observeIntersection };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAA;;;;CAIC;;;;AACD,MAAM,oBAAoB,IAAI;AAC9B;;;;CAIC,GACD,MAAM,YAAY,IAAI;AACtB,MAAM,uBAAuB,CAAC;IAC1B,MAAM,WAAW,kBAAkB,GAAG,CAAC,MAAM,MAAM;IACnD,YAAY,SAAS;AACzB;AACA,MAAM,2BAA2B,CAAC;IAC9B,QAAQ,OAAO,CAAC;AACpB;AACA,SAAS,yBAAyB,KAAoB;QAApB,EAAE,IAAI,EAAE,GAAG,SAAS,GAApB;IAC9B,MAAM,aAAa,QAAQ;IAC3B;;KAEC,GACD,IAAI,CAAC,UAAU,GAAG,CAAC,aAAa;QAC5B,UAAU,GAAG,CAAC,YAAY,CAAC;IAC/B;IACA,MAAM,gBAAgB,UAAU,GAAG,CAAC;IACpC,MAAM,MAAM,KAAK,SAAS,CAAC;IAC3B;;;KAGC,GACD,IAAI,CAAC,aAAa,CAAC,IAAI,EAAE;QACrB,aAAa,CAAC,IAAI,GAAG,IAAI,qBAAqB,0BAA0B;YAAE;YAAM,GAAG,OAAO;QAAC;IAC/F;IACA,OAAO,aAAa,CAAC,IAAI;AAC7B;AACA,SAAS,oBAAoB,OAAO,EAAE,OAAO,EAAE,QAAQ;IACnD,MAAM,4BAA4B,yBAAyB;IAC3D,kBAAkB,GAAG,CAAC,SAAS;IAC/B,0BAA0B,OAAO,CAAC;IAClC,OAAO;QACH,kBAAkB,MAAM,CAAC;QACzB,0BAA0B,SAAS,CAAC;IACxC;AACJ&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">7466</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/motion/features/viewport/index.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { Feature } from '../Feature.mjs';</span><span class="s3">\n</span><span class="s1">import { observeIntersection } from './observers.mjs';</span><span class="s3">\n\n</span><span class="s1">const thresholdNames = {</span><span class="s3">\n    </span><span class="s1">some: 0,</span><span class="s3">\n    </span><span class="s1">all: 1,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">class InViewFeature extends Feature {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">super(...arguments);</span><span class="s3">\n        </span><span class="s1">this.hasEnteredView = false;</span><span class="s3">\n        </span><span class="s1">this.isInView = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">startObserver() {</span><span class="s3">\n        </span><span class="s1">this.unmount();</span><span class="s3">\n        </span><span class="s1">const { viewport = {} } = this.node.getProps();</span><span class="s3">\n        </span><span class="s1">const { root, margin: rootMargin, amount = </span><span class="s3">\&quot;</span><span class="s1">some</span><span class="s3">\&quot;</span><span class="s1">, once } = viewport;</span><span class="s3">\n        </span><span class="s1">const options = {</span><span class="s3">\n            </span><span class="s1">root: root ? root.current : undefined,</span><span class="s3">\n            </span><span class="s1">rootMargin,</span><span class="s3">\n            </span><span class="s1">threshold: typeof amount === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">? amount : thresholdNames[amount],</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">const onIntersectionUpdate = (entry) =&gt; {</span><span class="s3">\n            </span><span class="s1">const { isIntersecting } = entry;</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* If there's been no change in the viewport state, early return.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">if (this.isInView === isIntersecting)</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">this.isInView = isIntersecting;</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* Handle hasEnteredView. If this is only meant to run once, and</span><span class="s3">\n             </span><span class="s1">* element isn't visible, early return. Otherwise set hasEnteredView to true.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">if (once &amp;&amp; !isIntersecting &amp;&amp; this.hasEnteredView) {</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (isIntersecting) {</span><span class="s3">\n                </span><span class="s1">this.hasEnteredView = true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (this.node.animationState) {</span><span class="s3">\n                </span><span class="s1">this.node.animationState.setActive(</span><span class="s3">\&quot;</span><span class="s1">whileInView</span><span class="s3">\&quot;</span><span class="s1">, isIntersecting);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* Use the latest committed props rather than the ones in scope</span><span class="s3">\n             </span><span class="s1">* when this observer is created</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">const { onViewportEnter, onViewportLeave } = this.node.getProps();</span><span class="s3">\n            </span><span class="s1">const callback = isIntersecting ? onViewportEnter : onViewportLeave;</span><span class="s3">\n            </span><span class="s1">callback &amp;&amp; callback(entry);</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">return observeIntersection(this.node.current, options, onIntersectionUpdate);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">mount() {</span><span class="s3">\n        </span><span class="s1">this.startObserver();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">update() {</span><span class="s3">\n        </span><span class="s1">if (typeof IntersectionObserver === </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">const { props, prevProps } = this.node;</span><span class="s3">\n        </span><span class="s1">const hasOptionsChanged = [</span><span class="s3">\&quot;</span><span class="s1">amount</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">margin</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">root</span><span class="s3">\&quot;</span><span class="s1">].some(hasViewportOptionChanged(props, prevProps));</span><span class="s3">\n        </span><span class="s1">if (hasOptionsChanged) {</span><span class="s3">\n            </span><span class="s1">this.startObserver();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">unmount() { }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {</span><span class="s3">\n    </span><span class="s1">return (name) =&gt; viewport[name] !== prevViewport[name];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { InViewFeature };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;AACA;;;AAEA,MAAM,iBAAiB;IACnB,MAAM;IACN,KAAK;AACT;AACA,MAAM,sBAAsB,8LAAO;IAM/B,gBAAgB;QACZ,IAAI,CAAC,OAAO;QACZ,MAAM,EAAE,WAAW,CAAC,CAAC,EAAE,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ;QAC5C,MAAM,EAAE,IAAI,EAAE,QAAQ,UAAU,EAAE,SAAS,MAAM,EAAE,IAAI,EAAE,GAAG;QAC5D,MAAM,UAAU;YACZ,MAAM,OAAO,KAAK,OAAO,GAAG;YAC5B;YACA,WAAW,OAAO,WAAW,WAAW,SAAS,cAAc,CAAC,OAAO;QAC3E;QACA,MAAM,uBAAuB,CAAC;YAC1B,MAAM,EAAE,cAAc,EAAE,GAAG;YAC3B;;aAEC,GACD,IAAI,IAAI,CAAC,QAAQ,KAAK,gBAClB;YACJ,IAAI,CAAC,QAAQ,GAAG;YAChB;;;aAGC,GACD,IAAI,QAAQ,CAAC,kBAAkB,IAAI,CAAC,cAAc,EAAE;gBAChD;YACJ,OACK,IAAI,gBAAgB;gBACrB,IAAI,CAAC,cAAc,GAAG;YAC1B;YACA,IAAI,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE;gBAC1B,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,SAAS,CAAC,eAAe;YACtD;YACA;;;aAGC,GACD,MAAM,EAAE,eAAe,EAAE,eAAe,EAAE,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ;YAC/D,MAAM,WAAW,iBAAiB,kBAAkB;YACpD,YAAY,SAAS;QACzB;QACA,OAAO,IAAA,wNAAmB,EAAC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,SAAS;IAC3D;IACA,QAAQ;QACJ,IAAI,CAAC,aAAa;IACtB;IACA,SAAS;QACL,IAAI,OAAO,yBAAyB,aAChC;QACJ,MAAM,EAAE,KAAK,EAAE,SAAS,EAAE,GAAG,IAAI,CAAC,IAAI;QACtC,MAAM,oBAAoB;YAAC;YAAU;YAAU;SAAO,CAAC,IAAI,CAAC,yBAAyB,OAAO;QAC5F,IAAI,mBAAmB;YACnB,IAAI,CAAC,aAAa;QACtB;IACJ;IACA,UAAU,CAAE;IAzDZ,aAAc;QACV,KAAK,IAAI;QACT,IAAI,CAAC,cAAc,GAAG;QACtB,IAAI,CAAC,QAAQ,GAAG;IACpB;AAsDJ;AACA,SAAS,yBAAyB,KAAiB;QAAjB,EAAE,WAAW,CAAC,CAAC,EAAE,GAAjB,OAAmB,EAAE,UAAU,eAAe,CAAC,CAAC,EAAE,GAA/B,iEAAkC,CAAC;IACpF,OAAO,CAAC,OAAS,QAAQ,CAAC,KAAK,KAAK,YAAY,CAAC,KAAK;AAC1D&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">7545</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/motion/features/gestures.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { HoverGesture } from '../../gestures/hover.mjs';</span><span class="s3">\n</span><span class="s1">import { FocusGesture } from '../../gestures/focus.mjs';</span><span class="s3">\n</span><span class="s1">import { PressGesture } from '../../gestures/press.mjs';</span><span class="s3">\n</span><span class="s1">import { InViewFeature } from './viewport/index.mjs';</span><span class="s3">\n\n</span><span class="s1">const gestureAnimations = {</span><span class="s3">\n    </span><span class="s1">inView: {</span><span class="s3">\n        </span><span class="s1">Feature: InViewFeature,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">tap: {</span><span class="s3">\n        </span><span class="s1">Feature: PressGesture,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">focus: {</span><span class="s3">\n        </span><span class="s1">Feature: FocusGesture,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">hover: {</span><span class="s3">\n        </span><span class="s1">Feature: HoverGesture,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export { gestureAnimations };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;AACA;AACA;AACA;;;;;AAEA,MAAM,oBAAoB;IACtB,QAAQ;QACJ,SAAS,8MAAa;IAC1B;IACA,KAAK;QACD,SAAS,uLAAY;IACzB;IACA,OAAO;QACH,SAAS,uLAAY;IACzB;IACA,OAAO;QACH,SAAS,uLAAY;IACzB;AACJ&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">7576</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/motion/features/layout.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { HTMLProjectionNode } from '../../projection/node/HTMLProjectionNode.mjs';</span><span class="s3">\n</span><span class="s1">import { MeasureLayout } from './layout/MeasureLayout.mjs';</span><span class="s3">\n\n</span><span class="s1">const layout = {</span><span class="s3">\n    </span><span class="s1">layout: {</span><span class="s3">\n        </span><span class="s1">ProjectionNode: HTMLProjectionNode,</span><span class="s3">\n        </span><span class="s1">MeasureLayout,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export { layout };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;AACA;;;AAEA,MAAM,SAAS;IACX,QAAQ;QACJ,gBAAgB,oNAAkB;QAClC,eAAA,oNAAa;IACjB;AACJ&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">7595</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/render/components/motion/feature-bundle.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { animations } from '../../../motion/features/animations.mjs';</span><span class="s3">\n</span><span class="s1">import { drag } from '../../../motion/features/drag.mjs';</span><span class="s3">\n</span><span class="s1">import { gestureAnimations } from '../../../motion/features/gestures.mjs';</span><span class="s3">\n</span><span class="s1">import { layout } from '../../../motion/features/layout.mjs';</span><span class="s3">\n\n</span><span class="s1">const featureBundle = {</span><span class="s3">\n    </span><span class="s1">...animations,</span><span class="s3">\n    </span><span class="s1">...gestureAnimations,</span><span class="s3">\n    </span><span class="s1">...drag,</span><span class="s3">\n    </span><span class="s1">...layout,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export { featureBundle };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;AACA;AACA;AACA;;;;;AAEA,MAAM,gBAAgB;IAClB,GAAG,oMAAU;IACb,GAAG,yMAAiB;IACpB,GAAG,wLAAI;IACP,GAAG,4LAAM;AACb&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}},</span>
    <span class="s0">{</span><span class="s1">&quot;offset&quot;</span><span class="s0">: {</span><span class="s1">&quot;line&quot;</span><span class="s0">: </span><span class="s2">7618</span><span class="s0">, </span><span class="s1">&quot;column&quot;</span><span class="s0">: </span><span class="s2">0</span><span class="s0">}, </span><span class="s1">&quot;map&quot;</span><span class="s0">: {</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;file:///Users/dh/WebstormProjects/bluestag/node_modules/framer-motion/dist/es/render/components/motion/proxy.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { createDomVisualElement } from '../../dom/create-visual-element.mjs';</span><span class="s3">\n</span><span class="s1">import { createMotionProxy } from '../create-proxy.mjs';</span><span class="s3">\n</span><span class="s1">import { featureBundle } from './feature-bundle.mjs';</span><span class="s3">\n\n</span><span class="s1">const motion = /*@__PURE__*/ createMotionProxy(featureBundle, createDomVisualElement);</span><span class="s3">\n\n</span><span class="s1">export { motion };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;AAAA;AACA;AACA;;;;AAEA,MAAM,SAAS,WAAW,GAAG,IAAA,kNAAiB,EAAC,0NAAa,EAAE,4NAAsB&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">],</span><span class="s1">&quot;debugId&quot;</span><span class="s0">:</span><span class="s4">null</span><span class="s0">}}]</span>
<span class="s0">}</span></pre>
</body>
</html>