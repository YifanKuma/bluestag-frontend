<html>
<head>
<title>motion-utils.dev.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #0033b3;}
.s2 { color: #067d17;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #264eff;}
.s6 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
motion-utils.dev.js</font>
</center></td></tr></table>
<pre><span class="s0">(</span><span class="s1">function </span><span class="s0">(global, factory) {</span>
    <span class="s1">typeof </span><span class="s0">exports === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">module !== </span><span class="s2">'undefined' </span><span class="s0">? factory(exports) :</span>
    <span class="s1">typeof </span><span class="s0">define === </span><span class="s2">'function' </span><span class="s0">&amp;&amp; define.amd ? define([</span><span class="s2">'exports'</span><span class="s0">], factory) :</span>
    <span class="s0">(global = </span><span class="s1">typeof </span><span class="s0">globalThis !== </span><span class="s2">'undefined' </span><span class="s0">? globalThis : global || self, factory(global.MotionUtils = {}));</span>
<span class="s0">})(</span><span class="s1">this</span><span class="s0">, (</span><span class="s1">function </span><span class="s0">(exports) { </span><span class="s2">'use strict'</span><span class="s0">;</span>

    <span class="s1">function </span><span class="s0">addUniqueItem(arr, item) {</span>
        <span class="s1">if </span><span class="s0">(arr.indexOf(item) === -</span><span class="s3">1</span><span class="s0">)</span>
            <span class="s0">arr.push(item);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">removeItem(arr, item) {</span>
        <span class="s1">const </span><span class="s0">index = arr.indexOf(item);</span>
        <span class="s1">if </span><span class="s0">(index &gt; -</span><span class="s3">1</span><span class="s0">)</span>
            <span class="s0">arr.splice(index, </span><span class="s3">1</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s4">// Adapted from array-move</span>
    <span class="s1">function </span><span class="s0">moveItem([...arr], fromIndex, toIndex) {</span>
        <span class="s1">const </span><span class="s0">startIndex = fromIndex &lt; </span><span class="s3">0 </span><span class="s0">? arr.length + fromIndex : fromIndex;</span>
        <span class="s1">if </span><span class="s0">(startIndex &gt;= </span><span class="s3">0 </span><span class="s0">&amp;&amp; startIndex &lt; arr.length) {</span>
            <span class="s1">const </span><span class="s0">endIndex = toIndex &lt; </span><span class="s3">0 </span><span class="s0">? arr.length + toIndex : toIndex;</span>
            <span class="s1">const </span><span class="s0">[item] = arr.splice(fromIndex, </span><span class="s3">1</span><span class="s0">);</span>
            <span class="s0">arr.splice(endIndex, </span><span class="s3">0</span><span class="s0">, item);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">arr;</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">clamp = (min, max, v) =&gt; {</span>
        <span class="s1">if </span><span class="s0">(v &gt; max)</span>
            <span class="s1">return </span><span class="s0">max;</span>
        <span class="s1">if </span><span class="s0">(v &lt; min)</span>
            <span class="s1">return </span><span class="s0">min;</span>
        <span class="s1">return </span><span class="s0">v;</span>
    <span class="s0">};</span>

    <span class="s1">function </span><span class="s0">formatErrorMessage(message, errorCode) {</span>
        <span class="s1">return </span><span class="s0">errorCode</span>
            <span class="s0">? </span><span class="s2">`</span><span class="s0">${message}</span><span class="s2">. For more information and steps for solving, visit https://motion.dev/troubleshooting/</span><span class="s0">${errorCode}</span><span class="s2">`</span>
            <span class="s0">: message;</span>
    <span class="s0">}</span>

    <span class="s0">exports.warning = () =&gt; { };</span>
    <span class="s0">exports.invariant = () =&gt; { };</span>
    <span class="s0">{</span>
        <span class="s0">exports.warning = (check, message, errorCode) =&gt; {</span>
            <span class="s1">if </span><span class="s0">(!check &amp;&amp; </span><span class="s1">typeof </span><span class="s0">console !== </span><span class="s2">&quot;undefined&quot;</span><span class="s0">) {</span>
                <span class="s0">console.warn(formatErrorMessage(message, errorCode));</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
        <span class="s0">exports.invariant = (check, message, errorCode) =&gt; {</span>
            <span class="s1">if </span><span class="s0">(!check) {</span>
                <span class="s1">throw new </span><span class="s0">Error(formatErrorMessage(message, errorCode));</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">MotionGlobalConfig = {};</span>

    <span class="s4">/**</span>
     <span class="s4">* Check if value is a numerical string, ie a string that is purely a number eg &quot;100&quot; or &quot;-100.1&quot;</span>
     <span class="s4">*/</span>
    <span class="s1">const </span><span class="s0">isNumericalString = (v) =&gt; </span><span class="s5">/^-?(?:\d+(?:\.\d+)?|\.\d+)$/u</span><span class="s0">.test(v);</span>

    <span class="s1">function </span><span class="s0">isObject(value) {</span>
        <span class="s1">return typeof </span><span class="s0">value === </span><span class="s2">&quot;object&quot; </span><span class="s0">&amp;&amp; value !== </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s4">/**</span>
     <span class="s4">* Check if the value is a zero value string like &quot;0px&quot; or &quot;0%&quot;</span>
     <span class="s4">*/</span>
    <span class="s1">const </span><span class="s0">isZeroValueString = (v) =&gt; </span><span class="s5">/^0[^.\s]+$/u</span><span class="s0">.test(v);</span>

    <span class="s4">/*#__NO_SIDE_EFFECTS__*/</span>
    <span class="s1">function </span><span class="s0">memo(callback) {</span>
        <span class="s1">let </span><span class="s0">result;</span>
        <span class="s1">return </span><span class="s0">() =&gt; {</span>
            <span class="s1">if </span><span class="s0">(result === undefined)</span>
                <span class="s0">result = callback();</span>
            <span class="s1">return </span><span class="s0">result;</span>
        <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s4">/*#__NO_SIDE_EFFECTS__*/</span>
    <span class="s1">const </span><span class="s0">noop = (any) =&gt; any;</span>

    <span class="s4">/**</span>
     <span class="s4">* Pipe</span>
     <span class="s4">* Compose other transformers to run linearily</span>
     <span class="s4">* pipe(min(20), max(40))</span>
     <span class="s4">* </span><span class="s6">@param  </span><span class="s4">{...functions} transformers</span>
     <span class="s4">* </span><span class="s6">@return </span><span class="s4">{function}</span>
     <span class="s4">*/</span>
    <span class="s1">const </span><span class="s0">combineFunctions = (a, b) =&gt; (v) =&gt; b(a(v));</span>
    <span class="s1">const </span><span class="s0">pipe = (...transformers) =&gt; transformers.reduce(combineFunctions);</span>

    <span class="s4">/* 
      Progress within given range 
 
      Given a lower limit and an upper limit, we return the progress 
      (expressed as a number 0-1) represented by the given value, and 
      limit that progress to within 0-1. 
 
      @param [number]: Lower limit 
      @param [number]: Upper limit 
      @param [number]: Value to find progress within given range 
      @return [number]: Progress of value within range as expressed 0-1 
    */</span>
    <span class="s4">/*#__NO_SIDE_EFFECTS__*/</span>
    <span class="s1">const </span><span class="s0">progress = (from, to, value) =&gt; {</span>
        <span class="s1">const </span><span class="s0">toFromDifference = to - from;</span>
        <span class="s1">return </span><span class="s0">toFromDifference === </span><span class="s3">0 </span><span class="s0">? </span><span class="s3">1 </span><span class="s0">: (value - from) / toFromDifference;</span>
    <span class="s0">};</span>

    <span class="s1">class </span><span class="s0">SubscriptionManager {</span>
        <span class="s0">constructor() {</span>
            <span class="s1">this</span><span class="s0">.subscriptions = [];</span>
        <span class="s0">}</span>
        <span class="s0">add(handler) {</span>
            <span class="s0">addUniqueItem(</span><span class="s1">this</span><span class="s0">.subscriptions, handler);</span>
            <span class="s1">return </span><span class="s0">() =&gt; removeItem(</span><span class="s1">this</span><span class="s0">.subscriptions, handler);</span>
        <span class="s0">}</span>
        <span class="s0">notify(a, b, c) {</span>
            <span class="s1">const </span><span class="s0">numSubscriptions = </span><span class="s1">this</span><span class="s0">.subscriptions.length;</span>
            <span class="s1">if </span><span class="s0">(!numSubscriptions)</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(numSubscriptions === </span><span class="s3">1</span><span class="s0">) {</span>
                <span class="s4">/**</span>
                 <span class="s4">* If there's only a single handler we can just call it without invoking a loop.</span>
                 <span class="s4">*/</span>
                <span class="s1">this</span><span class="s0">.subscriptions[</span><span class="s3">0</span><span class="s0">](a, b, c);</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s3">0</span><span class="s0">; i &lt; numSubscriptions; i++) {</span>
                    <span class="s4">/**</span>
                     <span class="s4">* Check whether the handler exists before firing as it's possible</span>
                     <span class="s4">* the subscriptions were modified during this loop running.</span>
                     <span class="s4">*/</span>
                    <span class="s1">const </span><span class="s0">handler = </span><span class="s1">this</span><span class="s0">.subscriptions[i];</span>
                    <span class="s0">handler &amp;&amp; handler(a, b, c);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">getSize() {</span>
            <span class="s1">return this</span><span class="s0">.subscriptions.length;</span>
        <span class="s0">}</span>
        <span class="s0">clear() {</span>
            <span class="s1">this</span><span class="s0">.subscriptions.length = </span><span class="s3">0</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>

    <span class="s4">/**</span>
     <span class="s4">* Converts seconds to milliseconds</span>
     <span class="s4">*</span>
     <span class="s4">* </span><span class="s6">@param </span><span class="s4">seconds - Time in seconds.</span>
     <span class="s4">* </span><span class="s6">@return </span><span class="s4">milliseconds - Converted time in milliseconds.</span>
     <span class="s4">*/</span>
    <span class="s4">/*#__NO_SIDE_EFFECTS__*/</span>
    <span class="s1">const </span><span class="s0">secondsToMilliseconds = (seconds) =&gt; seconds * </span><span class="s3">1000</span><span class="s0">;</span>
    <span class="s4">/*#__NO_SIDE_EFFECTS__*/</span>
    <span class="s1">const </span><span class="s0">millisecondsToSeconds = (milliseconds) =&gt; milliseconds / </span><span class="s3">1000</span><span class="s0">;</span>

    <span class="s4">/* 
      Convert velocity into velocity per second 
 
      @param [number]: Unit per frame 
      @param [number]: Frame duration in ms 
    */</span>
    <span class="s1">function </span><span class="s0">velocityPerSecond(velocity, frameDuration) {</span>
        <span class="s1">return </span><span class="s0">frameDuration ? velocity * (</span><span class="s3">1000 </span><span class="s0">/ frameDuration) : </span><span class="s3">0</span><span class="s0">;</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">warned = </span><span class="s1">new </span><span class="s0">Set();</span>
    <span class="s1">function </span><span class="s0">hasWarned(message) {</span>
        <span class="s1">return </span><span class="s0">warned.has(message);</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">warnOnce(condition, message, errorCode) {</span>
        <span class="s1">if </span><span class="s0">(condition || warned.has(message))</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s0">console.warn(formatErrorMessage(message, errorCode));</span>
        <span class="s0">warned.add(message);</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">wrap = (min, max, v) =&gt; {</span>
        <span class="s1">const </span><span class="s0">rangeSize = max - min;</span>
        <span class="s1">return </span><span class="s0">((((v - min) % rangeSize) + rangeSize) % rangeSize) + min;</span>
    <span class="s0">};</span>

    <span class="s4">/* 
      Bezier function generator 
      This has been modified from GaÃ«tan Renaudeau's BezierEasing 
      https://github.com/gre/bezier-easing/blob/master/src/index.js 
      https://github.com/gre/bezier-easing/blob/master/LICENSE 
       
      I've removed the newtonRaphsonIterate algo because in benchmarking it 
      wasn't noticeably faster than binarySubdivision, indeed removing it 
      usually improved times, depending on the curve. 
      I also removed the lookup table, as for the added bundle size and loop we're 
      only cutting ~4 or so subdivision iterations. I bumped the max iterations up 
      to 12 to compensate and this still tended to be faster for no perceivable 
      loss in accuracy. 
      Usage 
        const easeOut = cubicBezier(.17,.67,.83,.67); 
        const x = easeOut(0.5); // returns 0.627... 
    */</span>
    <span class="s4">// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.</span>
    <span class="s1">const </span><span class="s0">calcBezier = (t, a1, a2) =&gt; (((</span><span class="s3">1.0 </span><span class="s0">- </span><span class="s3">3.0 </span><span class="s0">* a2 + </span><span class="s3">3.0 </span><span class="s0">* a1) * t + (</span><span class="s3">3.0 </span><span class="s0">* a2 - </span><span class="s3">6.0 </span><span class="s0">* a1)) * t + </span><span class="s3">3.0 </span><span class="s0">* a1) *</span>
        <span class="s0">t;</span>
    <span class="s1">const </span><span class="s0">subdivisionPrecision = </span><span class="s3">0.0000001</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">subdivisionMaxIterations = </span><span class="s3">12</span><span class="s0">;</span>
    <span class="s1">function </span><span class="s0">binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {</span>
        <span class="s1">let </span><span class="s0">currentX;</span>
        <span class="s1">let </span><span class="s0">currentT;</span>
        <span class="s1">let </span><span class="s0">i = </span><span class="s3">0</span><span class="s0">;</span>
        <span class="s1">do </span><span class="s0">{</span>
            <span class="s0">currentT = lowerBound + (upperBound - lowerBound) / </span><span class="s3">2.0</span><span class="s0">;</span>
            <span class="s0">currentX = calcBezier(currentT, mX1, mX2) - x;</span>
            <span class="s1">if </span><span class="s0">(currentX &gt; </span><span class="s3">0.0</span><span class="s0">) {</span>
                <span class="s0">upperBound = currentT;</span>
            <span class="s0">}</span>
            <span class="s1">else </span><span class="s0">{</span>
                <span class="s0">lowerBound = currentT;</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">while </span><span class="s0">(Math.abs(currentX) &gt; subdivisionPrecision &amp;&amp;</span>
            <span class="s0">++i &lt; subdivisionMaxIterations);</span>
        <span class="s1">return </span><span class="s0">currentT;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">cubicBezier(mX1, mY1, mX2, mY2) {</span>
        <span class="s4">// If this is a linear gradient, return linear easing</span>
        <span class="s1">if </span><span class="s0">(mX1 === mY1 &amp;&amp; mX2 === mY2)</span>
            <span class="s1">return </span><span class="s0">noop;</span>
        <span class="s1">const </span><span class="s0">getTForX = (aX) =&gt; binarySubdivide(aX, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, mX1, mX2);</span>
        <span class="s4">// If animation is at start/end, return t without easing</span>
        <span class="s1">return </span><span class="s0">(t) =&gt; t === </span><span class="s3">0 </span><span class="s0">|| t === </span><span class="s3">1 </span><span class="s0">? t : calcBezier(getTForX(t), mY1, mY2);</span>
    <span class="s0">}</span>

    <span class="s4">// Accepts an easing function and returns a new one that outputs mirrored values for</span>
    <span class="s4">// the second half of the animation. Turns easeIn into easeInOut.</span>
    <span class="s1">const </span><span class="s0">mirrorEasing = (easing) =&gt; (p) =&gt; p &lt;= </span><span class="s3">0.5 </span><span class="s0">? easing(</span><span class="s3">2 </span><span class="s0">* p) / </span><span class="s3">2 </span><span class="s0">: (</span><span class="s3">2 </span><span class="s0">- easing(</span><span class="s3">2 </span><span class="s0">* (</span><span class="s3">1 </span><span class="s0">- p))) / </span><span class="s3">2</span><span class="s0">;</span>

    <span class="s4">// Accepts an easing function and returns a new one that outputs reversed values.</span>
    <span class="s4">// Turns easeIn into easeOut.</span>
    <span class="s1">const </span><span class="s0">reverseEasing = (easing) =&gt; (p) =&gt; </span><span class="s3">1 </span><span class="s0">- easing(</span><span class="s3">1 </span><span class="s0">- p);</span>

    <span class="s1">const </span><span class="s0">backOut = </span><span class="s4">/*@__PURE__*/ </span><span class="s0">cubicBezier(</span><span class="s3">0.33</span><span class="s0">, </span><span class="s3">1.53</span><span class="s0">, </span><span class="s3">0.69</span><span class="s0">, </span><span class="s3">0.99</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">backIn = </span><span class="s4">/*@__PURE__*/ </span><span class="s0">reverseEasing(backOut);</span>
    <span class="s1">const </span><span class="s0">backInOut = </span><span class="s4">/*@__PURE__*/ </span><span class="s0">mirrorEasing(backIn);</span>

    <span class="s1">const </span><span class="s0">anticipate = (p) =&gt; (p *= </span><span class="s3">2</span><span class="s0">) &lt; </span><span class="s3">1 </span><span class="s0">? </span><span class="s3">0.5 </span><span class="s0">* backIn(p) : </span><span class="s3">0.5 </span><span class="s0">* (</span><span class="s3">2 </span><span class="s0">- Math.pow(</span><span class="s3">2</span><span class="s0">, -</span><span class="s3">10 </span><span class="s0">* (p - </span><span class="s3">1</span><span class="s0">)));</span>

    <span class="s1">const </span><span class="s0">circIn = (p) =&gt; </span><span class="s3">1 </span><span class="s0">- Math.sin(Math.acos(p));</span>
    <span class="s1">const </span><span class="s0">circOut = reverseEasing(circIn);</span>
    <span class="s1">const </span><span class="s0">circInOut = mirrorEasing(circIn);</span>

    <span class="s1">const </span><span class="s0">easeIn = </span><span class="s4">/*@__PURE__*/ </span><span class="s0">cubicBezier(</span><span class="s3">0.42</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">easeOut = </span><span class="s4">/*@__PURE__*/ </span><span class="s0">cubicBezier(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0.58</span><span class="s0">, </span><span class="s3">1</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">easeInOut = </span><span class="s4">/*@__PURE__*/ </span><span class="s0">cubicBezier(</span><span class="s3">0.42</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0.58</span><span class="s0">, </span><span class="s3">1</span><span class="s0">);</span>

    <span class="s1">function </span><span class="s0">steps(numSteps, direction = </span><span class="s2">&quot;end&quot;</span><span class="s0">) {</span>
        <span class="s1">return </span><span class="s0">(progress) =&gt; {</span>
            <span class="s0">progress =</span>
                <span class="s0">direction === </span><span class="s2">&quot;end&quot;</span>
                    <span class="s0">? Math.min(progress, </span><span class="s3">0.999</span><span class="s0">)</span>
                    <span class="s0">: Math.max(progress, </span><span class="s3">0.001</span><span class="s0">);</span>
            <span class="s1">const </span><span class="s0">expanded = progress * numSteps;</span>
            <span class="s1">const </span><span class="s0">rounded = direction === </span><span class="s2">&quot;end&quot; </span><span class="s0">? Math.floor(expanded) : Math.ceil(expanded);</span>
            <span class="s1">return </span><span class="s0">clamp(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, rounded / numSteps);</span>
        <span class="s0">};</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">isEasingArray = (ease) =&gt; {</span>
        <span class="s1">return </span><span class="s0">Array.isArray(ease) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">ease[</span><span class="s3">0</span><span class="s0">] !== </span><span class="s2">&quot;number&quot;</span><span class="s0">;</span>
    <span class="s0">};</span>

    <span class="s1">function </span><span class="s0">getEasingForSegment(easing, i) {</span>
        <span class="s1">return </span><span class="s0">isEasingArray(easing) ? easing[wrap(</span><span class="s3">0</span><span class="s0">, easing.length, i)] : easing;</span>
    <span class="s0">}</span>

    <span class="s1">const </span><span class="s0">isBezierDefinition = (easing) =&gt; Array.isArray(easing) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">easing[</span><span class="s3">0</span><span class="s0">] === </span><span class="s2">&quot;number&quot;</span><span class="s0">;</span>

    <span class="s1">const </span><span class="s0">easingLookup = {</span>
        <span class="s0">linear: noop,</span>
        <span class="s0">easeIn,</span>
        <span class="s0">easeInOut,</span>
        <span class="s0">easeOut,</span>
        <span class="s0">circIn,</span>
        <span class="s0">circInOut,</span>
        <span class="s0">circOut,</span>
        <span class="s0">backIn,</span>
        <span class="s0">backInOut,</span>
        <span class="s0">backOut,</span>
        <span class="s0">anticipate,</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">isValidEasing = (easing) =&gt; {</span>
        <span class="s1">return typeof </span><span class="s0">easing === </span><span class="s2">&quot;string&quot;</span><span class="s0">;</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">easingDefinitionToFunction = (definition) =&gt; {</span>
        <span class="s1">if </span><span class="s0">(isBezierDefinition(definition)) {</span>
            <span class="s4">// If cubic bezier definition, create bezier curve</span>
            <span class="s0">exports.invariant(definition.length === </span><span class="s3">4</span><span class="s0">, </span><span class="s2">`Cubic bezier arrays must contain four numerical values.`</span><span class="s0">, </span><span class="s2">&quot;cubic-bezier-length&quot;</span><span class="s0">);</span>
            <span class="s1">const </span><span class="s0">[x1, y1, x2, y2] = definition;</span>
            <span class="s1">return </span><span class="s0">cubicBezier(x1, y1, x2, y2);</span>
        <span class="s0">}</span>
        <span class="s1">else if </span><span class="s0">(isValidEasing(definition)) {</span>
            <span class="s4">// Else lookup from table</span>
            <span class="s0">exports.invariant(easingLookup[definition] !== undefined, </span><span class="s2">`Invalid easing type '</span><span class="s0">${definition}</span><span class="s2">'`</span><span class="s0">, </span><span class="s2">&quot;invalid-easing-type&quot;</span><span class="s0">);</span>
            <span class="s1">return </span><span class="s0">easingLookup[definition];</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">definition;</span>
    <span class="s0">};</span>

    <span class="s0">exports.MotionGlobalConfig = MotionGlobalConfig;</span>
    <span class="s0">exports.SubscriptionManager = SubscriptionManager;</span>
    <span class="s0">exports.addUniqueItem = addUniqueItem;</span>
    <span class="s0">exports.anticipate = anticipate;</span>
    <span class="s0">exports.backIn = backIn;</span>
    <span class="s0">exports.backInOut = backInOut;</span>
    <span class="s0">exports.backOut = backOut;</span>
    <span class="s0">exports.circIn = circIn;</span>
    <span class="s0">exports.circInOut = circInOut;</span>
    <span class="s0">exports.circOut = circOut;</span>
    <span class="s0">exports.clamp = clamp;</span>
    <span class="s0">exports.cubicBezier = cubicBezier;</span>
    <span class="s0">exports.easeIn = easeIn;</span>
    <span class="s0">exports.easeInOut = easeInOut;</span>
    <span class="s0">exports.easeOut = easeOut;</span>
    <span class="s0">exports.easingDefinitionToFunction = easingDefinitionToFunction;</span>
    <span class="s0">exports.getEasingForSegment = getEasingForSegment;</span>
    <span class="s0">exports.hasWarned = hasWarned;</span>
    <span class="s0">exports.isBezierDefinition = isBezierDefinition;</span>
    <span class="s0">exports.isEasingArray = isEasingArray;</span>
    <span class="s0">exports.isNumericalString = isNumericalString;</span>
    <span class="s0">exports.isObject = isObject;</span>
    <span class="s0">exports.isZeroValueString = isZeroValueString;</span>
    <span class="s0">exports.memo = memo;</span>
    <span class="s0">exports.millisecondsToSeconds = millisecondsToSeconds;</span>
    <span class="s0">exports.mirrorEasing = mirrorEasing;</span>
    <span class="s0">exports.moveItem = moveItem;</span>
    <span class="s0">exports.noop = noop;</span>
    <span class="s0">exports.pipe = pipe;</span>
    <span class="s0">exports.progress = progress;</span>
    <span class="s0">exports.removeItem = removeItem;</span>
    <span class="s0">exports.reverseEasing = reverseEasing;</span>
    <span class="s0">exports.secondsToMilliseconds = secondsToMilliseconds;</span>
    <span class="s0">exports.steps = steps;</span>
    <span class="s0">exports.velocityPerSecond = velocityPerSecond;</span>
    <span class="s0">exports.warnOnce = warnOnce;</span>
    <span class="s0">exports.wrap = wrap;</span>

<span class="s0">}));</span>
</pre>
</body>
</html>