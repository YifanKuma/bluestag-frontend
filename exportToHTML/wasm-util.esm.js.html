<html>
<head>
<title>wasm-util.esm.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
.s5 { color: #8c8c8c; font-style: italic;}
.s6 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
wasm-util.esm.js</font>
</center></td></tr></table>
<pre><span class="s0">const </span><span class="s1">_WebAssembly = </span><span class="s0">typeof </span><span class="s1">WebAssembly !== </span><span class="s2">'undefined'</span>
    <span class="s1">? WebAssembly</span>
    <span class="s1">: </span><span class="s0">typeof </span><span class="s1">WXWebAssembly !== </span><span class="s2">'undefined'</span>
        <span class="s1">? WXWebAssembly</span>
        <span class="s1">: undefined;</span>
<span class="s0">if </span><span class="s1">(!_WebAssembly) {</span>
    <span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">'WebAssembly is not supported in this environment'</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s3">/* eslint-disable spaced-comment */</span>

<span class="s0">function </span><span class="s1">validateObject(value, name) {</span>
    <span class="s0">if </span><span class="s1">(value === </span><span class="s0">null </span><span class="s1">|| </span><span class="s0">typeof </span><span class="s1">value !== </span><span class="s2">'object'</span><span class="s1">) {</span>
        <span class="s0">throw new </span><span class="s1">TypeError(</span><span class="s2">`</span><span class="s1">${name} </span><span class="s2">must be an object. Received </span><span class="s1">${value === </span><span class="s0">null </span><span class="s1">? </span><span class="s2">'null' </span><span class="s1">: </span><span class="s0">typeof </span><span class="s1">value}</span><span class="s2">`</span><span class="s1">);</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">validateArray(value, name) {</span>
    <span class="s0">if </span><span class="s1">(!Array.isArray(value)) {</span>
        <span class="s0">throw new </span><span class="s1">TypeError(</span><span class="s2">`</span><span class="s1">${name} </span><span class="s2">must be an array. Received </span><span class="s1">${value === </span><span class="s0">null </span><span class="s1">? </span><span class="s2">'null' </span><span class="s1">: </span><span class="s0">typeof </span><span class="s1">value}</span><span class="s2">`</span><span class="s1">);</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">validateBoolean(value, name) {</span>
    <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">value !== </span><span class="s2">'boolean'</span><span class="s1">) {</span>
        <span class="s0">throw new </span><span class="s1">TypeError(</span><span class="s2">`</span><span class="s1">${name} </span><span class="s2">must be a boolean. Received </span><span class="s1">${value === </span><span class="s0">null </span><span class="s1">? </span><span class="s2">'null' </span><span class="s1">: </span><span class="s0">typeof </span><span class="s1">value}</span><span class="s2">`</span><span class="s1">);</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">validateString(value, name) {</span>
    <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">value !== </span><span class="s2">'string'</span><span class="s1">) {</span>
        <span class="s0">throw new </span><span class="s1">TypeError(</span><span class="s2">`</span><span class="s1">${name} </span><span class="s2">must be a string. Received </span><span class="s1">${value === </span><span class="s0">null </span><span class="s1">? </span><span class="s2">'null' </span><span class="s1">: </span><span class="s0">typeof </span><span class="s1">value}</span><span class="s2">`</span><span class="s1">);</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">validateFunction(value, name) {</span>
    <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">value !== </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s0">throw new </span><span class="s1">TypeError(</span><span class="s2">`</span><span class="s1">${name} </span><span class="s2">must be a function. Received </span><span class="s1">${value === </span><span class="s0">null </span><span class="s1">? </span><span class="s2">'null' </span><span class="s1">: </span><span class="s0">typeof </span><span class="s1">value}</span><span class="s2">`</span><span class="s1">);</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">validateUndefined(value, name) {</span>
    <span class="s0">if </span><span class="s1">(value !== undefined) {</span>
        <span class="s0">throw new </span><span class="s1">TypeError(</span><span class="s2">`</span><span class="s1">${name} </span><span class="s2">must be undefined. Received </span><span class="s1">${value === </span><span class="s0">null </span><span class="s1">? </span><span class="s2">'null' </span><span class="s1">: </span><span class="s0">typeof </span><span class="s1">value}</span><span class="s2">`</span><span class="s1">);</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">isPromiseLike(obj) {</span>
    <span class="s0">return </span><span class="s1">!!(obj &amp;&amp; (</span><span class="s0">typeof </span><span class="s1">obj === </span><span class="s2">'object' </span><span class="s1">|| </span><span class="s0">typeof </span><span class="s1">obj === </span><span class="s2">'function'</span><span class="s1">) &amp;&amp; </span><span class="s0">typeof </span><span class="s1">obj.then === </span><span class="s2">'function'</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">wrapInstanceExports(exports, mapFn) {</span>
    <span class="s0">const </span><span class="s1">newExports = Object.create(</span><span class="s0">null</span><span class="s1">);</span>
    <span class="s1">Object.keys(exports).forEach(name =&gt; {</span>
        <span class="s0">const </span><span class="s1">exportValue = exports[name];</span>
        <span class="s1">Object.defineProperty(newExports, name, {</span>
            <span class="s1">enumerable: </span><span class="s0">true</span><span class="s1">,</span>
            <span class="s1">value: mapFn(exportValue, name)</span>
        <span class="s1">});</span>
    <span class="s1">});</span>
    <span class="s0">return </span><span class="s1">newExports;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">sleepBreakIf(delay, breakIf) {</span>
    <span class="s0">const </span><span class="s1">start = Date.now();</span>
    <span class="s0">const </span><span class="s1">end = start + delay;</span>
    <span class="s0">let </span><span class="s1">ret = </span><span class="s0">false</span><span class="s1">;</span>
    <span class="s0">while </span><span class="s1">(Date.now() &lt; end) {</span>
        <span class="s0">if </span><span class="s1">(breakIf()) {</span>
            <span class="s1">ret = </span><span class="s0">true</span><span class="s1">;</span>
            <span class="s0">break</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">ret;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">unsharedSlice(view, start, end) {</span>
    <span class="s0">return </span><span class="s1">((</span><span class="s0">typeof </span><span class="s1">SharedArrayBuffer === </span><span class="s2">'function' </span><span class="s1">&amp;&amp; view.buffer </span><span class="s0">instanceof </span><span class="s1">SharedArrayBuffer) || (Object.prototype.toString.call(view.buffer.constructor) === </span><span class="s2">'[object SharedArrayBuffer]'</span><span class="s1">))</span>
        <span class="s1">? view.slice(start, end)</span>
        <span class="s1">: view.subarray(start, end);</span>
<span class="s1">}</span>

<span class="s0">const </span><span class="s1">ignoreNames = [</span>
    <span class="s2">'asyncify_get_state'</span><span class="s1">,</span>
    <span class="s2">'asyncify_start_rewind'</span><span class="s1">,</span>
    <span class="s2">'asyncify_start_unwind'</span><span class="s1">,</span>
    <span class="s2">'asyncify_stop_rewind'</span><span class="s1">,</span>
    <span class="s2">'asyncify_stop_unwind'</span>
<span class="s1">];</span>
<span class="s0">function </span><span class="s1">tryAllocate(instance, wasm64, size, mallocName) {</span>
    <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">instance.exports[mallocName] !== </span><span class="s2">'function' </span><span class="s1">|| size &lt;= </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s0">return </span><span class="s1">{</span>
            <span class="s1">wasm64,</span>
            <span class="s1">dataPtr: </span><span class="s4">16</span><span class="s1">,</span>
            <span class="s1">start: wasm64 ? </span><span class="s4">32 </span><span class="s1">: </span><span class="s4">24</span><span class="s1">,</span>
            <span class="s1">end: </span><span class="s4">1024</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s0">const </span><span class="s1">malloc = instance.exports[mallocName];</span>
    <span class="s0">const </span><span class="s1">dataPtr = wasm64 ? Number(malloc(BigInt(</span><span class="s4">16</span><span class="s1">) + BigInt(size))) : malloc(</span><span class="s4">8 </span><span class="s1">+ size);</span>
    <span class="s0">if </span><span class="s1">(dataPtr === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">'Allocate asyncify data failed'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">wasm64</span>
        <span class="s1">? { wasm64, dataPtr, start: dataPtr + </span><span class="s4">16</span><span class="s1">, end: dataPtr + </span><span class="s4">16 </span><span class="s1">+ size }</span>
        <span class="s1">: { wasm64, dataPtr, start: dataPtr + </span><span class="s4">8</span><span class="s1">, end: dataPtr + </span><span class="s4">8 </span><span class="s1">+ size };</span>
<span class="s1">}</span>
<span class="s3">/** </span><span class="s5">@public </span><span class="s3">*/</span>
<span class="s0">class </span><span class="s1">Asyncify {</span>
    <span class="s1">constructor() {</span>
        <span class="s0">this</span><span class="s1">.value = undefined;</span>
        <span class="s0">this</span><span class="s1">.exports = undefined;</span>
        <span class="s0">this</span><span class="s1">.dataPtr = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">init(memory, instance, options) {</span>
        <span class="s0">var </span><span class="s1">_a, _b;</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.exports) {</span>
            <span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">'Asyncify has been initialized'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(!(memory </span><span class="s0">instanceof </span><span class="s1">_WebAssembly.Memory)) {</span>
            <span class="s0">throw new </span><span class="s1">TypeError(</span><span class="s2">'Require WebAssembly.Memory object'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s0">const </span><span class="s1">exports = instance.exports;</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; ignoreNames.length; ++i) {</span>
            <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">exports[ignoreNames[i]] !== </span><span class="s2">'function'</span><span class="s1">) {</span>
                <span class="s0">throw new </span><span class="s1">TypeError(</span><span class="s2">'Invalid asyncify wasm'</span><span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">let </span><span class="s1">address;</span>
        <span class="s0">const </span><span class="s1">wasm64 = Boolean(options.wasm64);</span>
        <span class="s0">if </span><span class="s1">(!options.tryAllocate) {</span>
            <span class="s1">address = {</span>
                <span class="s1">wasm64,</span>
                <span class="s1">dataPtr: </span><span class="s4">16</span><span class="s1">,</span>
                <span class="s1">start: wasm64 ? </span><span class="s4">32 </span><span class="s1">: </span><span class="s4">24</span><span class="s1">,</span>
                <span class="s1">end: </span><span class="s4">1024</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s0">if </span><span class="s1">(options.tryAllocate === </span><span class="s0">true</span><span class="s1">) {</span>
                <span class="s1">address = tryAllocate(instance, wasm64, </span><span class="s4">4096</span><span class="s1">, </span><span class="s2">'malloc'</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">address = tryAllocate(instance, wasm64, (_a = options.tryAllocate.size) !== </span><span class="s0">null </span><span class="s1">&amp;&amp; _a !== </span><span class="s0">void </span><span class="s4">0 </span><span class="s1">? _a : </span><span class="s4">4096</span><span class="s1">, (_b = options.tryAllocate.name) !== </span><span class="s0">null </span><span class="s1">&amp;&amp; _b !== </span><span class="s0">void </span><span class="s4">0 </span><span class="s1">? _b : </span><span class="s2">'malloc'</span><span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">this</span><span class="s1">.dataPtr = address.dataPtr;</span>
        <span class="s0">if </span><span class="s1">(wasm64) {</span>
            <span class="s0">new </span><span class="s1">BigInt64Array(memory.buffer, </span><span class="s0">this</span><span class="s1">.dataPtr).set([BigInt(address.start), BigInt(address.end)]);</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s0">new </span><span class="s1">Int32Array(memory.buffer, </span><span class="s0">this</span><span class="s1">.dataPtr).set([address.start, address.end]);</span>
        <span class="s1">}</span>
        <span class="s0">this</span><span class="s1">.exports = </span><span class="s0">this</span><span class="s1">.wrapExports(exports, options.wrapExports);</span>
        <span class="s0">const </span><span class="s1">asyncifiedInstance = Object.create(_WebAssembly.Instance.prototype);</span>
        <span class="s1">Object.defineProperty(asyncifiedInstance, </span><span class="s2">'exports'</span><span class="s1">, { value: </span><span class="s0">this</span><span class="s1">.exports });</span>
        <span class="s3">// Object.setPrototypeOf(instance, Instance.prototype)</span>
        <span class="s0">return </span><span class="s1">asyncifiedInstance;</span>
    <span class="s1">}</span>
    <span class="s1">assertState() {</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.exports.asyncify_get_state() !== </span><span class="s4">0 </span><span class="s3">/* AsyncifyState.NONE */</span><span class="s1">) {</span>
            <span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">'Asyncify state error'</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">wrapImportFunction(f) {</span>
        <span class="s3">// eslint-disable-next-line @typescript-eslint/no-this-alias</span>
        <span class="s0">const </span><span class="s1">_this = </span><span class="s0">this</span><span class="s1">;</span>
        <span class="s0">return </span><span class="s1">(</span><span class="s0">function </span><span class="s1">() {</span>
            <span class="s3">// eslint-disable-next-line no-unreachable-loop</span>
            <span class="s0">while </span><span class="s1">(_this.exports.asyncify_get_state() === </span><span class="s4">2 </span><span class="s3">/* AsyncifyState.REWINDING */</span><span class="s1">) {</span>
                <span class="s1">_this.exports.asyncify_stop_rewind();</span>
                <span class="s0">return </span><span class="s1">_this.value;</span>
            <span class="s1">}</span>
            <span class="s1">_this.assertState();</span>
            <span class="s0">const </span><span class="s1">v = f.apply(</span><span class="s0">this</span><span class="s1">, arguments);</span>
            <span class="s0">if </span><span class="s1">(!isPromiseLike(v))</span>
                <span class="s0">return </span><span class="s1">v;</span>
            <span class="s1">_this.exports.asyncify_start_unwind(_this.dataPtr);</span>
            <span class="s1">_this.value = v;</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">wrapImports(imports) {</span>
        <span class="s0">const </span><span class="s1">importObject = {};</span>
        <span class="s1">Object.keys(imports).forEach(k =&gt; {</span>
            <span class="s0">const </span><span class="s1">mod = imports[k];</span>
            <span class="s0">const </span><span class="s1">newModule = {};</span>
            <span class="s1">Object.keys(mod).forEach(name =&gt; {</span>
                <span class="s0">const </span><span class="s1">importValue = mod[name];</span>
                <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">importValue === </span><span class="s2">'function'</span><span class="s1">) {</span>
                    <span class="s1">newModule[name] = </span><span class="s0">this</span><span class="s1">.wrapImportFunction(importValue);</span>
                <span class="s1">}</span>
                <span class="s0">else </span><span class="s1">{</span>
                    <span class="s1">newModule[name] = importValue;</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
            <span class="s1">importObject[k] = newModule;</span>
        <span class="s1">});</span>
        <span class="s0">return </span><span class="s1">importObject;</span>
    <span class="s1">}</span>
    <span class="s1">wrapExportFunction(f) {</span>
        <span class="s3">// eslint-disable-next-line @typescript-eslint/no-this-alias</span>
        <span class="s0">const </span><span class="s1">_this = </span><span class="s0">this</span><span class="s1">;</span>
        <span class="s0">return </span><span class="s1">(async </span><span class="s0">function </span><span class="s1">() {</span>
            <span class="s1">_this.assertState();</span>
            <span class="s0">let </span><span class="s1">ret = f.apply(</span><span class="s0">this</span><span class="s1">, arguments);</span>
            <span class="s0">while </span><span class="s1">(_this.exports.asyncify_get_state() === </span><span class="s4">1 </span><span class="s3">/* AsyncifyState.UNWINDING */</span><span class="s1">) {</span>
                <span class="s1">_this.exports.asyncify_stop_unwind();</span>
                <span class="s1">_this.value = </span><span class="s0">await </span><span class="s1">_this.value;</span>
                <span class="s1">_this.assertState();</span>
                <span class="s1">_this.exports.asyncify_start_rewind(_this.dataPtr);</span>
                <span class="s1">ret = f.call(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s1">_this.assertState();</span>
            <span class="s0">return </span><span class="s1">ret;</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">wrapExports(exports, needWrap) {</span>
        <span class="s0">return </span><span class="s1">wrapInstanceExports(exports, (exportValue, name) =&gt; {</span>
            <span class="s0">let </span><span class="s1">ignore = ignoreNames.indexOf(name) !== -</span><span class="s4">1 </span><span class="s1">|| </span><span class="s0">typeof </span><span class="s1">exportValue !== </span><span class="s2">'function'</span><span class="s1">;</span>
            <span class="s0">if </span><span class="s1">(Array.isArray(needWrap)) {</span>
                <span class="s1">ignore = ignore || (needWrap.indexOf(name) === -</span><span class="s4">1</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s0">return </span><span class="s1">ignore ? exportValue : </span><span class="s0">this</span><span class="s1">.wrapExportFunction(exportValue);</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">validateImports(imports) {</span>
    <span class="s0">if </span><span class="s1">(imports &amp;&amp; </span><span class="s0">typeof </span><span class="s1">imports !== </span><span class="s2">'object'</span><span class="s1">) {</span>
        <span class="s0">throw new </span><span class="s1">TypeError(</span><span class="s2">'imports must be an object or undefined'</span><span class="s1">);</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">fetchWasm(urlOrBuffer, imports) {</span>
    <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">wx !== </span><span class="s2">'undefined' </span><span class="s1">&amp;&amp; </span><span class="s0">typeof </span><span class="s1">__wxConfig !== </span><span class="s2">'undefined'</span><span class="s1">) {</span>
        <span class="s0">return </span><span class="s1">_WebAssembly.instantiate(urlOrBuffer, imports);</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">fetch(urlOrBuffer)</span>
        <span class="s1">.then(response =&gt; response.arrayBuffer())</span>
        <span class="s1">.then(buffer =&gt; _WebAssembly.instantiate(buffer, imports));</span>
<span class="s1">}</span>
<span class="s3">/** </span><span class="s5">@public </span><span class="s3">*/</span>
<span class="s0">function </span><span class="s1">load(wasmInput, imports) {</span>
    <span class="s1">validateImports(imports);</span>
    <span class="s1">imports = imports !== </span><span class="s0">null </span><span class="s1">&amp;&amp; imports !== </span><span class="s0">void </span><span class="s4">0 </span><span class="s1">? imports : {};</span>
    <span class="s0">let </span><span class="s1">source;</span>
    <span class="s0">if </span><span class="s1">(wasmInput </span><span class="s0">instanceof </span><span class="s1">ArrayBuffer || ArrayBuffer.isView(wasmInput)) {</span>
        <span class="s0">return </span><span class="s1">_WebAssembly.instantiate(wasmInput, imports);</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(wasmInput </span><span class="s0">instanceof </span><span class="s1">_WebAssembly.Module) {</span>
        <span class="s0">return </span><span class="s1">_WebAssembly.instantiate(wasmInput, imports).then((instance) =&gt; {</span>
            <span class="s0">return </span><span class="s1">{ instance, module: wasmInput };</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">wasmInput !== </span><span class="s2">'string' </span><span class="s1">&amp;&amp; !(wasmInput </span><span class="s0">instanceof </span><span class="s1">URL)) {</span>
        <span class="s0">throw new </span><span class="s1">TypeError(</span><span class="s2">'Invalid source'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">_WebAssembly.instantiateStreaming === </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s0">let </span><span class="s1">responsePromise;</span>
        <span class="s0">try </span><span class="s1">{</span>
            <span class="s1">responsePromise = fetch(wasmInput);</span>
            <span class="s1">source = _WebAssembly.instantiateStreaming(responsePromise, imports).catch(() =&gt; {</span>
                <span class="s0">return </span><span class="s1">fetchWasm(wasmInput, imports);</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s0">catch </span><span class="s1">(_) {</span>
            <span class="s1">source = fetchWasm(wasmInput, imports);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">else </span><span class="s1">{</span>
        <span class="s1">source = fetchWasm(wasmInput, imports);</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">source;</span>
<span class="s1">}</span>
<span class="s3">/** </span><span class="s5">@public </span><span class="s3">*/</span>
<span class="s0">function </span><span class="s1">asyncifyLoad(asyncify, urlOrBuffer, imports) {</span>
    <span class="s1">validateImports(imports);</span>
    <span class="s1">imports = imports !== </span><span class="s0">null </span><span class="s1">&amp;&amp; imports !== </span><span class="s0">void </span><span class="s4">0 </span><span class="s1">? imports : {};</span>
    <span class="s0">const </span><span class="s1">asyncifyHelper = </span><span class="s0">new </span><span class="s1">Asyncify();</span>
    <span class="s1">imports = asyncifyHelper.wrapImports(imports);</span>
    <span class="s0">return </span><span class="s1">load(urlOrBuffer, imports).then(source =&gt; {</span>
        <span class="s0">var </span><span class="s1">_a;</span>
        <span class="s0">const </span><span class="s1">memory = source.instance.exports.memory || ((_a = imports.env) === </span><span class="s0">null </span><span class="s1">|| _a === </span><span class="s0">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s0">void </span><span class="s4">0 </span><span class="s1">: _a.memory);</span>
        <span class="s0">return </span><span class="s1">{ module: source.module, instance: asyncifyHelper.init(memory, source.instance, asyncify) };</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s3">/** </span><span class="s5">@public </span><span class="s3">*/</span>
<span class="s0">function </span><span class="s1">loadSync(wasmInput, imports) {</span>
    <span class="s1">validateImports(imports);</span>
    <span class="s1">imports = imports !== </span><span class="s0">null </span><span class="s1">&amp;&amp; imports !== </span><span class="s0">void </span><span class="s4">0 </span><span class="s1">? imports : {};</span>
    <span class="s0">let </span><span class="s1">module;</span>
    <span class="s0">if </span><span class="s1">((wasmInput </span><span class="s0">instanceof </span><span class="s1">ArrayBuffer) || ArrayBuffer.isView(wasmInput)) {</span>
        <span class="s1">module = </span><span class="s0">new </span><span class="s1">_WebAssembly.Module(wasmInput);</span>
    <span class="s1">}</span>
    <span class="s0">else if </span><span class="s1">(wasmInput </span><span class="s0">instanceof </span><span class="s1">WebAssembly.Module) {</span>
        <span class="s1">module = wasmInput;</span>
    <span class="s1">}</span>
    <span class="s0">else </span><span class="s1">{</span>
        <span class="s0">throw new </span><span class="s1">TypeError(</span><span class="s2">'Invalid source'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s0">const </span><span class="s1">instance = </span><span class="s0">new </span><span class="s1">_WebAssembly.Instance(module, imports);</span>
    <span class="s0">const </span><span class="s1">source = { instance, module };</span>
    <span class="s0">return </span><span class="s1">source;</span>
<span class="s1">}</span>
<span class="s3">/** </span><span class="s5">@public </span><span class="s3">*/</span>
<span class="s0">function </span><span class="s1">asyncifyLoadSync(asyncify, buffer, imports) {</span>
    <span class="s0">var </span><span class="s1">_a;</span>
    <span class="s1">validateImports(imports);</span>
    <span class="s1">imports = imports !== </span><span class="s0">null </span><span class="s1">&amp;&amp; imports !== </span><span class="s0">void </span><span class="s4">0 </span><span class="s1">? imports : {};</span>
    <span class="s0">const </span><span class="s1">asyncifyHelper = </span><span class="s0">new </span><span class="s1">Asyncify();</span>
    <span class="s1">imports = asyncifyHelper.wrapImports(imports);</span>
    <span class="s0">const </span><span class="s1">source = loadSync(buffer, imports);</span>
    <span class="s0">const </span><span class="s1">memory = source.instance.exports.memory || ((_a = imports.env) === </span><span class="s0">null </span><span class="s1">|| _a === </span><span class="s0">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s0">void </span><span class="s4">0 </span><span class="s1">: _a.memory);</span>
    <span class="s0">return </span><span class="s1">{ module: source.module, instance: asyncifyHelper.init(memory, source.instance, asyncify) };</span>
<span class="s1">}</span>

<span class="s0">const </span><span class="s1">CHAR_DOT = </span><span class="s4">46</span><span class="s1">; </span><span class="s3">/* . */</span>
<span class="s0">const </span><span class="s1">CHAR_FORWARD_SLASH = </span><span class="s4">47</span><span class="s1">; </span><span class="s3">/* / */</span>
<span class="s0">function </span><span class="s1">isPosixPathSeparator(code) {</span>
    <span class="s0">return </span><span class="s1">code === CHAR_FORWARD_SLASH;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">normalizeString(path, allowAboveRoot, separator, isPathSeparator) {</span>
    <span class="s0">let </span><span class="s1">res = </span><span class="s2">''</span><span class="s1">;</span>
    <span class="s0">let </span><span class="s1">lastSegmentLength = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s0">let </span><span class="s1">lastSlash = -</span><span class="s4">1</span><span class="s1">;</span>
    <span class="s0">let </span><span class="s1">dots = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s0">let </span><span class="s1">code = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt;= path.length; ++i) {</span>
        <span class="s0">if </span><span class="s1">(i &lt; path.length) {</span>
            <span class="s1">code = path.charCodeAt(i);</span>
        <span class="s1">}</span>
        <span class="s0">else if </span><span class="s1">(isPathSeparator(code)) {</span>
            <span class="s0">break</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s1">code = CHAR_FORWARD_SLASH;</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(isPathSeparator(code)) {</span>
            <span class="s0">if </span><span class="s1">(lastSlash === i - </span><span class="s4">1 </span><span class="s1">|| dots === </span><span class="s4">1</span><span class="s1">) ;</span>
            <span class="s0">else if </span><span class="s1">(dots === </span><span class="s4">2</span><span class="s1">) {</span>
                <span class="s0">if </span><span class="s1">(res.length &lt; </span><span class="s4">2 </span><span class="s1">|| lastSegmentLength !== </span><span class="s4">2 </span><span class="s1">||</span>
                    <span class="s1">res.charCodeAt(res.length - </span><span class="s4">1</span><span class="s1">) !== CHAR_DOT ||</span>
                    <span class="s1">res.charCodeAt(res.length - </span><span class="s4">2</span><span class="s1">) !== CHAR_DOT) {</span>
                    <span class="s0">if </span><span class="s1">(res.length &gt; </span><span class="s4">2</span><span class="s1">) {</span>
                        <span class="s0">const </span><span class="s1">lastSlashIndex = res.indexOf(separator);</span>
                        <span class="s0">if </span><span class="s1">(lastSlashIndex === -</span><span class="s4">1</span><span class="s1">) {</span>
                            <span class="s1">res = </span><span class="s2">''</span><span class="s1">;</span>
                            <span class="s1">lastSegmentLength = </span><span class="s4">0</span><span class="s1">;</span>
                        <span class="s1">}</span>
                        <span class="s0">else </span><span class="s1">{</span>
                            <span class="s1">res = res.slice(</span><span class="s4">0</span><span class="s1">, lastSlashIndex);</span>
                            <span class="s1">lastSegmentLength =</span>
                                <span class="s1">res.length - </span><span class="s4">1 </span><span class="s1">- res.indexOf(separator);</span>
                        <span class="s1">}</span>
                        <span class="s1">lastSlash = i;</span>
                        <span class="s1">dots = </span><span class="s4">0</span><span class="s1">;</span>
                        <span class="s0">continue</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s0">else if </span><span class="s1">(res.length !== </span><span class="s4">0</span><span class="s1">) {</span>
                        <span class="s1">res = </span><span class="s2">''</span><span class="s1">;</span>
                        <span class="s1">lastSegmentLength = </span><span class="s4">0</span><span class="s1">;</span>
                        <span class="s1">lastSlash = i;</span>
                        <span class="s1">dots = </span><span class="s4">0</span><span class="s1">;</span>
                        <span class="s0">continue</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s0">if </span><span class="s1">(allowAboveRoot) {</span>
                    <span class="s1">res += res.length &gt; </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">`</span><span class="s1">${separator}</span><span class="s2">..` </span><span class="s1">: </span><span class="s2">'..'</span><span class="s1">;</span>
                    <span class="s1">lastSegmentLength = </span><span class="s4">2</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s0">if </span><span class="s1">(res.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s1">res += </span><span class="s2">`</span><span class="s1">${separator}${path.slice(lastSlash + </span><span class="s4">1</span><span class="s1">, i)}</span><span class="s2">`</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s0">else </span><span class="s1">{</span>
                    <span class="s1">res = path.slice(lastSlash + </span><span class="s4">1</span><span class="s1">, i);</span>
                <span class="s1">}</span>
                <span class="s1">lastSegmentLength = i - lastSlash - </span><span class="s4">1</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">lastSlash = i;</span>
            <span class="s1">dots = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s0">else if </span><span class="s1">(code === CHAR_DOT &amp;&amp; dots !== -</span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s1">++dots;</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s1">dots = -</span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">res;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">resolve(...args) {</span>
    <span class="s0">let </span><span class="s1">resolvedPath = </span><span class="s2">''</span><span class="s1">;</span>
    <span class="s0">let </span><span class="s1">resolvedAbsolute = </span><span class="s0">false</span><span class="s1">;</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = args.length - </span><span class="s4">1</span><span class="s1">; i &gt;= -</span><span class="s4">1 </span><span class="s1">&amp;&amp; !resolvedAbsolute; i--) {</span>
        <span class="s0">const </span><span class="s1">path = i &gt;= </span><span class="s4">0 </span><span class="s1">? args[i] : </span><span class="s2">'/'</span><span class="s1">;</span>
        <span class="s1">validateString(path, </span><span class="s2">'path'</span><span class="s1">);</span>
        <span class="s3">// Skip empty entries</span>
        <span class="s0">if </span><span class="s1">(path.length === </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s0">continue</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">resolvedPath = </span><span class="s2">`</span><span class="s1">${path}</span><span class="s2">/</span><span class="s1">${resolvedPath}</span><span class="s2">`</span><span class="s1">;</span>
        <span class="s1">resolvedAbsolute = path.charCodeAt(</span><span class="s4">0</span><span class="s1">) === CHAR_FORWARD_SLASH;</span>
    <span class="s1">}</span>
    <span class="s3">// At this point the path should be resolved to a full absolute path, but</span>
    <span class="s3">// handle relative paths to be safe (might happen when process.cwd() fails)</span>
    <span class="s3">// Normalize the path</span>
    <span class="s1">resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, </span><span class="s2">'/'</span><span class="s1">, isPosixPathSeparator);</span>
    <span class="s0">if </span><span class="s1">(resolvedAbsolute) {</span>
        <span class="s0">return </span><span class="s2">`/</span><span class="s1">${resolvedPath}</span><span class="s2">`</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">resolvedPath.length &gt; </span><span class="s4">0 </span><span class="s1">? resolvedPath : </span><span class="s2">'.'</span><span class="s1">;</span>
<span class="s1">}</span>

<span class="s0">const </span><span class="s1">FD_DATASYNC = ( </span><span class="s3">/*#__PURE__*/</span><span class="s1">BigInt(</span><span class="s4">1</span><span class="s1">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s1">BigInt(</span><span class="s4">0</span><span class="s1">));</span>
<span class="s0">const </span><span class="s1">FD_READ = ( </span><span class="s3">/*#__PURE__*/</span><span class="s1">BigInt(</span><span class="s4">1</span><span class="s1">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s1">BigInt(</span><span class="s4">1</span><span class="s1">));</span>
<span class="s0">const </span><span class="s1">FD_SEEK = ( </span><span class="s3">/*#__PURE__*/</span><span class="s1">BigInt(</span><span class="s4">1</span><span class="s1">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s1">BigInt(</span><span class="s4">2</span><span class="s1">));</span>
<span class="s0">const </span><span class="s1">FD_FDSTAT_SET_FLAGS = ( </span><span class="s3">/*#__PURE__*/</span><span class="s1">BigInt(</span><span class="s4">1</span><span class="s1">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s1">BigInt(</span><span class="s4">3</span><span class="s1">));</span>
<span class="s0">const </span><span class="s1">FD_SYNC = ( </span><span class="s3">/*#__PURE__*/</span><span class="s1">BigInt(</span><span class="s4">1</span><span class="s1">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s1">BigInt(</span><span class="s4">4</span><span class="s1">));</span>
<span class="s0">const </span><span class="s1">FD_TELL = ( </span><span class="s3">/*#__PURE__*/</span><span class="s1">BigInt(</span><span class="s4">1</span><span class="s1">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s1">BigInt(</span><span class="s4">5</span><span class="s1">));</span>
<span class="s0">const </span><span class="s1">FD_WRITE = ( </span><span class="s3">/*#__PURE__*/</span><span class="s1">BigInt(</span><span class="s4">1</span><span class="s1">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s1">BigInt(</span><span class="s4">6</span><span class="s1">));</span>
<span class="s0">const </span><span class="s1">FD_ADVISE = ( </span><span class="s3">/*#__PURE__*/</span><span class="s1">BigInt(</span><span class="s4">1</span><span class="s1">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s1">BigInt(</span><span class="s4">7</span><span class="s1">));</span>
<span class="s0">const </span><span class="s1">FD_ALLOCATE = ( </span><span class="s3">/*#__PURE__*/</span><span class="s1">BigInt(</span><span class="s4">1</span><span class="s1">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s1">BigInt(</span><span class="s4">8</span><span class="s1">));</span>
<span class="s0">const </span><span class="s1">PATH_CREATE_DIRECTORY = ( </span><span class="s3">/*#__PURE__*/</span><span class="s1">BigInt(</span><span class="s4">1</span><span class="s1">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s1">BigInt(</span><span class="s4">9</span><span class="s1">));</span>
<span class="s0">const </span><span class="s1">PATH_CREATE_FILE = ( </span><span class="s3">/*#__PURE__*/</span><span class="s1">BigInt(</span><span class="s4">1</span><span class="s1">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s1">BigInt(</span><span class="s4">10</span><span class="s1">));</span>
<span class="s0">const </span><span class="s1">PATH_LINK_SOURCE = ( </span><span class="s3">/*#__PURE__*/</span><span class="s1">BigInt(</span><span class="s4">1</span><span class="s1">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s1">BigInt(</span><span class="s4">11</span><span class="s1">));</span>
<span class="s0">const </span><span class="s1">PATH_LINK_TARGET = ( </span><span class="s3">/*#__PURE__*/</span><span class="s1">BigInt(</span><span class="s4">1</span><span class="s1">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s1">BigInt(</span><span class="s4">12</span><span class="s1">));</span>
<span class="s0">const </span><span class="s1">PATH_OPEN = ( </span><span class="s3">/*#__PURE__*/</span><span class="s1">BigInt(</span><span class="s4">1</span><span class="s1">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s1">BigInt(</span><span class="s4">13</span><span class="s1">));</span>
<span class="s0">const </span><span class="s1">FD_READDIR = ( </span><span class="s3">/*#__PURE__*/</span><span class="s1">BigInt(</span><span class="s4">1</span><span class="s1">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s1">BigInt(</span><span class="s4">14</span><span class="s1">));</span>
<span class="s0">const </span><span class="s1">PATH_READLINK = ( </span><span class="s3">/*#__PURE__*/</span><span class="s1">BigInt(</span><span class="s4">1</span><span class="s1">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s1">BigInt(</span><span class="s4">15</span><span class="s1">));</span>
<span class="s0">const </span><span class="s1">PATH_RENAME_SOURCE = ( </span><span class="s3">/*#__PURE__*/</span><span class="s1">BigInt(</span><span class="s4">1</span><span class="s1">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s1">BigInt(</span><span class="s4">16</span><span class="s1">));</span>
<span class="s0">const </span><span class="s1">PATH_RENAME_TARGET = ( </span><span class="s3">/*#__PURE__*/</span><span class="s1">BigInt(</span><span class="s4">1</span><span class="s1">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s1">BigInt(</span><span class="s4">17</span><span class="s1">));</span>
<span class="s0">const </span><span class="s1">PATH_FILESTAT_GET = ( </span><span class="s3">/*#__PURE__*/</span><span class="s1">BigInt(</span><span class="s4">1</span><span class="s1">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s1">BigInt(</span><span class="s4">18</span><span class="s1">));</span>
<span class="s0">const </span><span class="s1">PATH_FILESTAT_SET_SIZE = ( </span><span class="s3">/*#__PURE__*/</span><span class="s1">BigInt(</span><span class="s4">1</span><span class="s1">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s1">BigInt(</span><span class="s4">19</span><span class="s1">));</span>
<span class="s0">const </span><span class="s1">PATH_FILESTAT_SET_TIMES = ( </span><span class="s3">/*#__PURE__*/</span><span class="s1">BigInt(</span><span class="s4">1</span><span class="s1">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s1">BigInt(</span><span class="s4">20</span><span class="s1">));</span>
<span class="s0">const </span><span class="s1">FD_FILESTAT_GET = ( </span><span class="s3">/*#__PURE__*/</span><span class="s1">BigInt(</span><span class="s4">1</span><span class="s1">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s1">BigInt(</span><span class="s4">21</span><span class="s1">));</span>
<span class="s0">const </span><span class="s1">FD_FILESTAT_SET_SIZE = ( </span><span class="s3">/*#__PURE__*/</span><span class="s1">BigInt(</span><span class="s4">1</span><span class="s1">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s1">BigInt(</span><span class="s4">22</span><span class="s1">));</span>
<span class="s0">const </span><span class="s1">FD_FILESTAT_SET_TIMES = ( </span><span class="s3">/*#__PURE__*/</span><span class="s1">BigInt(</span><span class="s4">1</span><span class="s1">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s1">BigInt(</span><span class="s4">23</span><span class="s1">));</span>
<span class="s0">const </span><span class="s1">PATH_SYMLINK = ( </span><span class="s3">/*#__PURE__*/</span><span class="s1">BigInt(</span><span class="s4">1</span><span class="s1">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s1">BigInt(</span><span class="s4">24</span><span class="s1">));</span>
<span class="s0">const </span><span class="s1">PATH_REMOVE_DIRECTORY = ( </span><span class="s3">/*#__PURE__*/</span><span class="s1">BigInt(</span><span class="s4">1</span><span class="s1">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s1">BigInt(</span><span class="s4">25</span><span class="s1">));</span>
<span class="s0">const </span><span class="s1">PATH_UNLINK_FILE = ( </span><span class="s3">/*#__PURE__*/</span><span class="s1">BigInt(</span><span class="s4">1</span><span class="s1">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s1">BigInt(</span><span class="s4">26</span><span class="s1">));</span>
<span class="s0">const </span><span class="s1">POLL_FD_READWRITE = ( </span><span class="s3">/*#__PURE__*/</span><span class="s1">BigInt(</span><span class="s4">1</span><span class="s1">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s1">BigInt(</span><span class="s4">27</span><span class="s1">));</span>
<span class="s0">const </span><span class="s1">SOCK_SHUTDOWN = ( </span><span class="s3">/*#__PURE__*/</span><span class="s1">BigInt(</span><span class="s4">1</span><span class="s1">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s1">BigInt(</span><span class="s4">28</span><span class="s1">));</span>
<span class="s0">const </span><span class="s1">SOCK_ACCEPT = ( </span><span class="s3">/*#__PURE__*/</span><span class="s1">BigInt(</span><span class="s4">1</span><span class="s1">) &lt;&lt; </span><span class="s3">/*#__PURE__*/ </span><span class="s1">BigInt(</span><span class="s4">29</span><span class="s1">));</span>
<span class="s0">const </span><span class="s1">WasiRights = {</span>
    <span class="s1">FD_DATASYNC,</span>
    <span class="s1">FD_READ,</span>
    <span class="s1">FD_SEEK,</span>
    <span class="s1">FD_FDSTAT_SET_FLAGS,</span>
    <span class="s1">FD_SYNC,</span>
    <span class="s1">FD_TELL,</span>
    <span class="s1">FD_WRITE,</span>
    <span class="s1">FD_ADVISE,</span>
    <span class="s1">FD_ALLOCATE,</span>
    <span class="s1">PATH_CREATE_DIRECTORY,</span>
    <span class="s1">PATH_CREATE_FILE,</span>
    <span class="s1">PATH_LINK_SOURCE,</span>
    <span class="s1">PATH_LINK_TARGET,</span>
    <span class="s1">PATH_OPEN,</span>
    <span class="s1">FD_READDIR,</span>
    <span class="s1">PATH_READLINK,</span>
    <span class="s1">PATH_RENAME_SOURCE,</span>
    <span class="s1">PATH_RENAME_TARGET,</span>
    <span class="s1">PATH_FILESTAT_GET,</span>
    <span class="s1">PATH_FILESTAT_SET_SIZE,</span>
    <span class="s1">PATH_FILESTAT_SET_TIMES,</span>
    <span class="s1">FD_FILESTAT_GET,</span>
    <span class="s1">FD_FILESTAT_SET_SIZE,</span>
    <span class="s1">FD_FILESTAT_SET_TIMES,</span>
    <span class="s1">PATH_SYMLINK,</span>
    <span class="s1">PATH_REMOVE_DIRECTORY,</span>
    <span class="s1">PATH_UNLINK_FILE,</span>
    <span class="s1">POLL_FD_READWRITE,</span>
    <span class="s1">SOCK_SHUTDOWN,</span>
    <span class="s1">SOCK_ACCEPT</span>
<span class="s1">};</span>

<span class="s0">function </span><span class="s1">strerror(errno) {</span>
    <span class="s0">switch </span><span class="s1">(errno) {</span>
        <span class="s0">case </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Success'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">1 </span><span class="s3">/* WasiErrno.E2BIG */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Argument list too long'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">2 </span><span class="s3">/* WasiErrno.EACCES */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Permission denied'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">3 </span><span class="s3">/* WasiErrno.EADDRINUSE */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Address in use'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">4 </span><span class="s3">/* WasiErrno.EADDRNOTAVAIL */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Address not available'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">5 </span><span class="s3">/* WasiErrno.EAFNOSUPPORT */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Address family not supported by protocol'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">6 </span><span class="s3">/* WasiErrno.EAGAIN */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Resource temporarily unavailable'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">7 </span><span class="s3">/* WasiErrno.EALREADY */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Operation already in progress'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">8 </span><span class="s3">/* WasiErrno.EBADF */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Bad file descriptor'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">9 </span><span class="s3">/* WasiErrno.EBADMSG */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Bad message'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">10 </span><span class="s3">/* WasiErrno.EBUSY */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Resource busy'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">11 </span><span class="s3">/* WasiErrno.ECANCELED */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Operation canceled'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">12 </span><span class="s3">/* WasiErrno.ECHILD */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'No child process'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">13 </span><span class="s3">/* WasiErrno.ECONNABORTED */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Connection aborted'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">14 </span><span class="s3">/* WasiErrno.ECONNREFUSED */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Connection refused'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">15 </span><span class="s3">/* WasiErrno.ECONNRESET */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Connection reset by peer'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">16 </span><span class="s3">/* WasiErrno.EDEADLK */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Resource deadlock would occur'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">17 </span><span class="s3">/* WasiErrno.EDESTADDRREQ */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Destination address required'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">18 </span><span class="s3">/* WasiErrno.EDOM */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Domain error'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">19 </span><span class="s3">/* WasiErrno.EDQUOT */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Quota exceeded'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">20 </span><span class="s3">/* WasiErrno.EEXIST */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'File exists'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">21 </span><span class="s3">/* WasiErrno.EFAULT */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Bad address'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">22 </span><span class="s3">/* WasiErrno.EFBIG */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'File too large'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">23 </span><span class="s3">/* WasiErrno.EHOSTUNREACH */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Host is unreachable'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">24 </span><span class="s3">/* WasiErrno.EIDRM */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Identifier removed'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">25 </span><span class="s3">/* WasiErrno.EILSEQ */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Illegal byte sequence'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">26 </span><span class="s3">/* WasiErrno.EINPROGRESS */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Operation in progress'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">27 </span><span class="s3">/* WasiErrno.EINTR */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Interrupted system call'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Invalid argument'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">29 </span><span class="s3">/* WasiErrno.EIO */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'I/O error'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">30 </span><span class="s3">/* WasiErrno.EISCONN */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Socket is connected'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">31 </span><span class="s3">/* WasiErrno.EISDIR */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Is a directory'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">32 </span><span class="s3">/* WasiErrno.ELOOP */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Symbolic link loop'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">33 </span><span class="s3">/* WasiErrno.EMFILE */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'No file descriptors available'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">34 </span><span class="s3">/* WasiErrno.EMLINK */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Too many links'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">35 </span><span class="s3">/* WasiErrno.EMSGSIZE */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Message too large'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">36 </span><span class="s3">/* WasiErrno.EMULTIHOP */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Multihop attempted'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">37 </span><span class="s3">/* WasiErrno.ENAMETOOLONG */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Filename too long'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">38 </span><span class="s3">/* WasiErrno.ENETDOWN */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Network is down'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">39 </span><span class="s3">/* WasiErrno.ENETRESET */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Connection reset by network'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">40 </span><span class="s3">/* WasiErrno.ENETUNREACH */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Network unreachable'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">41 </span><span class="s3">/* WasiErrno.ENFILE */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Too many files open in system'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">42 </span><span class="s3">/* WasiErrno.ENOBUFS */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'No buffer space available'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">43 </span><span class="s3">/* WasiErrno.ENODEV */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'No such device'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">44 </span><span class="s3">/* WasiErrno.ENOENT */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'No such file or directory'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">45 </span><span class="s3">/* WasiErrno.ENOEXEC */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Exec format error'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">46 </span><span class="s3">/* WasiErrno.ENOLCK */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'No locks available'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">47 </span><span class="s3">/* WasiErrno.ENOLINK */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Link has been severed'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">48 </span><span class="s3">/* WasiErrno.ENOMEM */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Out of memory'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">49 </span><span class="s3">/* WasiErrno.ENOMSG */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'No message of the desired type'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">50 </span><span class="s3">/* WasiErrno.ENOPROTOOPT */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Protocol not available'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">51 </span><span class="s3">/* WasiErrno.ENOSPC */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'No space left on device'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">52 </span><span class="s3">/* WasiErrno.ENOSYS */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Function not implemented'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">53 </span><span class="s3">/* WasiErrno.ENOTCONN */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Socket not connected'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">54 </span><span class="s3">/* WasiErrno.ENOTDIR */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Not a directory'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">55 </span><span class="s3">/* WasiErrno.ENOTEMPTY */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Directory not empty'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">56 </span><span class="s3">/* WasiErrno.ENOTRECOVERABLE */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'State not recoverable'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">57 </span><span class="s3">/* WasiErrno.ENOTSOCK */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Not a socket'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">58 </span><span class="s3">/* WasiErrno.ENOTSUP */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Not supported'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">59 </span><span class="s3">/* WasiErrno.ENOTTY */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Not a tty'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">60 </span><span class="s3">/* WasiErrno.ENXIO */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'No such device or address'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">61 </span><span class="s3">/* WasiErrno.EOVERFLOW */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Value too large for data type'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">62 </span><span class="s3">/* WasiErrno.EOWNERDEAD */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Previous owner died'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">63 </span><span class="s3">/* WasiErrno.EPERM */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Operation not permitted'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">64 </span><span class="s3">/* WasiErrno.EPIPE */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Broken pipe'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">65 </span><span class="s3">/* WasiErrno.EPROTO */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Protocol error'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">66 </span><span class="s3">/* WasiErrno.EPROTONOSUPPORT */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Protocol not supported'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">67 </span><span class="s3">/* WasiErrno.EPROTOTYPE */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Protocol wrong type for socket'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">68 </span><span class="s3">/* WasiErrno.ERANGE */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Result not representable'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">69 </span><span class="s3">/* WasiErrno.EROFS */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Read-only file system'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">70 </span><span class="s3">/* WasiErrno.ESPIPE */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Invalid seek'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">71 </span><span class="s3">/* WasiErrno.ESRCH */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'No such process'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">72 </span><span class="s3">/* WasiErrno.ESTALE */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Stale file handle'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">73 </span><span class="s3">/* WasiErrno.ETIMEDOUT */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Operation timed out'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">74 </span><span class="s3">/* WasiErrno.ETXTBSY */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Text file busy'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">75 </span><span class="s3">/* WasiErrno.EXDEV */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Cross-device link'</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">76 </span><span class="s3">/* WasiErrno.ENOTCAPABLE */</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Capabilities insufficient'</span><span class="s1">;</span>
        <span class="s0">default</span><span class="s1">: </span><span class="s0">return </span><span class="s2">'Unknown error'</span><span class="s1">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">class </span><span class="s1">WasiError </span><span class="s0">extends </span><span class="s1">Error {</span>
    <span class="s1">constructor(message, errno) {</span>
        <span class="s0">super</span><span class="s1">(message);</span>
        <span class="s0">this</span><span class="s1">.errno = errno;</span>
    <span class="s1">}</span>
    <span class="s1">getErrorMessage() {</span>
        <span class="s0">return </span><span class="s1">strerror(</span><span class="s0">this</span><span class="s1">.errno);</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">Object.defineProperty(WasiError.prototype, </span><span class="s2">'name'</span><span class="s1">, {</span>
    <span class="s1">configurable: </span><span class="s0">true</span><span class="s1">,</span>
    <span class="s1">writable: </span><span class="s0">true</span><span class="s1">,</span>
    <span class="s1">value: </span><span class="s2">'WasiError'</span>
<span class="s1">});</span>

<span class="s0">const </span><span class="s1">RIGHTS_ALL = WasiRights.FD_DATASYNC |</span>
    <span class="s1">WasiRights.FD_READ |</span>
    <span class="s1">WasiRights.FD_SEEK |</span>
    <span class="s1">WasiRights.FD_FDSTAT_SET_FLAGS |</span>
    <span class="s1">WasiRights.FD_SYNC |</span>
    <span class="s1">WasiRights.FD_TELL |</span>
    <span class="s1">WasiRights.FD_WRITE |</span>
    <span class="s1">WasiRights.FD_ADVISE |</span>
    <span class="s1">WasiRights.FD_ALLOCATE |</span>
    <span class="s1">WasiRights.PATH_CREATE_DIRECTORY |</span>
    <span class="s1">WasiRights.PATH_CREATE_FILE |</span>
    <span class="s1">WasiRights.PATH_LINK_SOURCE |</span>
    <span class="s1">WasiRights.PATH_LINK_TARGET |</span>
    <span class="s1">WasiRights.PATH_OPEN |</span>
    <span class="s1">WasiRights.FD_READDIR |</span>
    <span class="s1">WasiRights.PATH_READLINK |</span>
    <span class="s1">WasiRights.PATH_RENAME_SOURCE |</span>
    <span class="s1">WasiRights.PATH_RENAME_TARGET |</span>
    <span class="s1">WasiRights.PATH_FILESTAT_GET |</span>
    <span class="s1">WasiRights.PATH_FILESTAT_SET_SIZE |</span>
    <span class="s1">WasiRights.PATH_FILESTAT_SET_TIMES |</span>
    <span class="s1">WasiRights.FD_FILESTAT_GET |</span>
    <span class="s1">WasiRights.FD_FILESTAT_SET_TIMES |</span>
    <span class="s1">WasiRights.FD_FILESTAT_SET_SIZE |</span>
    <span class="s1">WasiRights.PATH_SYMLINK |</span>
    <span class="s1">WasiRights.PATH_UNLINK_FILE |</span>
    <span class="s1">WasiRights.PATH_REMOVE_DIRECTORY |</span>
    <span class="s1">WasiRights.POLL_FD_READWRITE |</span>
    <span class="s1">WasiRights.SOCK_SHUTDOWN |</span>
    <span class="s1">WasiRights.SOCK_ACCEPT;</span>
<span class="s0">const </span><span class="s1">BLOCK_DEVICE_BASE = RIGHTS_ALL;</span>
<span class="s0">const </span><span class="s1">BLOCK_DEVICE_INHERITING = RIGHTS_ALL;</span>
<span class="s0">const </span><span class="s1">CHARACTER_DEVICE_BASE = RIGHTS_ALL;</span>
<span class="s0">const </span><span class="s1">CHARACTER_DEVICE_INHERITING = RIGHTS_ALL;</span>
<span class="s0">const </span><span class="s1">REGULAR_FILE_BASE = WasiRights.FD_DATASYNC |</span>
    <span class="s1">WasiRights.FD_READ |</span>
    <span class="s1">WasiRights.FD_SEEK |</span>
    <span class="s1">WasiRights.FD_FDSTAT_SET_FLAGS |</span>
    <span class="s1">WasiRights.FD_SYNC |</span>
    <span class="s1">WasiRights.FD_TELL |</span>
    <span class="s1">WasiRights.FD_WRITE |</span>
    <span class="s1">WasiRights.FD_ADVISE |</span>
    <span class="s1">WasiRights.FD_ALLOCATE |</span>
    <span class="s1">WasiRights.FD_FILESTAT_GET |</span>
    <span class="s1">WasiRights.FD_FILESTAT_SET_SIZE |</span>
    <span class="s1">WasiRights.FD_FILESTAT_SET_TIMES |</span>
    <span class="s1">WasiRights.POLL_FD_READWRITE;</span>
<span class="s0">const </span><span class="s1">REGULAR_FILE_INHERITING = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">BigInt(</span><span class="s4">0</span><span class="s1">);</span>
<span class="s0">const </span><span class="s1">DIRECTORY_BASE = WasiRights.FD_FDSTAT_SET_FLAGS |</span>
    <span class="s1">WasiRights.FD_SYNC |</span>
    <span class="s1">WasiRights.FD_ADVISE |</span>
    <span class="s1">WasiRights.PATH_CREATE_DIRECTORY |</span>
    <span class="s1">WasiRights.PATH_CREATE_FILE |</span>
    <span class="s1">WasiRights.PATH_LINK_SOURCE |</span>
    <span class="s1">WasiRights.PATH_LINK_TARGET |</span>
    <span class="s1">WasiRights.PATH_OPEN |</span>
    <span class="s1">WasiRights.FD_READDIR |</span>
    <span class="s1">WasiRights.PATH_READLINK |</span>
    <span class="s1">WasiRights.PATH_RENAME_SOURCE |</span>
    <span class="s1">WasiRights.PATH_RENAME_TARGET |</span>
    <span class="s1">WasiRights.PATH_FILESTAT_GET |</span>
    <span class="s1">WasiRights.PATH_FILESTAT_SET_SIZE |</span>
    <span class="s1">WasiRights.PATH_FILESTAT_SET_TIMES |</span>
    <span class="s1">WasiRights.FD_FILESTAT_GET |</span>
    <span class="s1">WasiRights.FD_FILESTAT_SET_TIMES |</span>
    <span class="s1">WasiRights.PATH_SYMLINK |</span>
    <span class="s1">WasiRights.PATH_UNLINK_FILE |</span>
    <span class="s1">WasiRights.PATH_REMOVE_DIRECTORY |</span>
    <span class="s1">WasiRights.POLL_FD_READWRITE;</span>
<span class="s0">const </span><span class="s1">DIRECTORY_INHERITING = DIRECTORY_BASE | REGULAR_FILE_BASE;</span>
<span class="s0">const </span><span class="s1">SOCKET_BASE = (WasiRights.FD_READ |</span>
    <span class="s1">WasiRights.FD_FDSTAT_SET_FLAGS |</span>
    <span class="s1">WasiRights.FD_WRITE |</span>
    <span class="s1">WasiRights.FD_FILESTAT_GET |</span>
    <span class="s1">WasiRights.POLL_FD_READWRITE |</span>
    <span class="s1">WasiRights.SOCK_SHUTDOWN);</span>
<span class="s0">const </span><span class="s1">SOCKET_INHERITING = RIGHTS_ALL;</span>
<span class="s0">const </span><span class="s1">TTY_BASE = WasiRights.FD_READ |</span>
    <span class="s1">WasiRights.FD_FDSTAT_SET_FLAGS |</span>
    <span class="s1">WasiRights.FD_WRITE |</span>
    <span class="s1">WasiRights.FD_FILESTAT_GET |</span>
    <span class="s1">WasiRights.POLL_FD_READWRITE;</span>
<span class="s0">const </span><span class="s1">TTY_INHERITING = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">BigInt(</span><span class="s4">0</span><span class="s1">);</span>
<span class="s0">function </span><span class="s1">getRights(stdio, fd, flags, type) {</span>
    <span class="s0">const </span><span class="s1">ret = {</span>
        <span class="s1">base: BigInt(</span><span class="s4">0</span><span class="s1">),</span>
        <span class="s1">inheriting: BigInt(</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">};</span>
    <span class="s0">if </span><span class="s1">(type === </span><span class="s4">0 </span><span class="s3">/* WasiFileType.UNKNOWN */</span><span class="s1">) {</span>
        <span class="s0">throw new </span><span class="s1">WasiError(</span><span class="s2">'Unknown file type'</span><span class="s1">, </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s0">switch </span><span class="s1">(type) {</span>
        <span class="s0">case </span><span class="s4">4 </span><span class="s3">/* WasiFileType.REGULAR_FILE */</span><span class="s1">:</span>
            <span class="s1">ret.base = REGULAR_FILE_BASE;</span>
            <span class="s1">ret.inheriting = REGULAR_FILE_INHERITING;</span>
            <span class="s0">break</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">3 </span><span class="s3">/* WasiFileType.DIRECTORY */</span><span class="s1">:</span>
            <span class="s1">ret.base = DIRECTORY_BASE;</span>
            <span class="s1">ret.inheriting = DIRECTORY_INHERITING;</span>
            <span class="s0">break</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">6 </span><span class="s3">/* WasiFileType.SOCKET_STREAM */</span><span class="s1">:</span>
        <span class="s0">case </span><span class="s4">5 </span><span class="s3">/* WasiFileType.SOCKET_DGRAM */</span><span class="s1">:</span>
            <span class="s1">ret.base = SOCKET_BASE;</span>
            <span class="s1">ret.inheriting = SOCKET_INHERITING;</span>
            <span class="s0">break</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">2 </span><span class="s3">/* WasiFileType.CHARACTER_DEVICE */</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">(stdio.indexOf(fd) !== -</span><span class="s4">1</span><span class="s1">) {</span>
                <span class="s1">ret.base = TTY_BASE;</span>
                <span class="s1">ret.inheriting = TTY_INHERITING;</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">ret.base = CHARACTER_DEVICE_BASE;</span>
                <span class="s1">ret.inheriting = CHARACTER_DEVICE_INHERITING;</span>
            <span class="s1">}</span>
            <span class="s0">break</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s4">1 </span><span class="s3">/* WasiFileType.BLOCK_DEVICE */</span><span class="s1">:</span>
            <span class="s1">ret.base = BLOCK_DEVICE_BASE;</span>
            <span class="s1">ret.inheriting = BLOCK_DEVICE_INHERITING;</span>
            <span class="s0">break</span><span class="s1">;</span>
        <span class="s0">default</span><span class="s1">:</span>
            <span class="s1">ret.base = BigInt(</span><span class="s4">0</span><span class="s1">);</span>
            <span class="s1">ret.inheriting = BigInt(</span><span class="s4">0</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">/* Disable read/write bits depending on access mode. */</span>
    <span class="s0">const </span><span class="s1">read_or_write_only = flags &amp; (</span><span class="s4">0 </span><span class="s1">| </span><span class="s4">1 </span><span class="s1">| </span><span class="s4">2</span><span class="s1">);</span>
    <span class="s0">if </span><span class="s1">(read_or_write_only === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">ret.base &amp;= ~WasiRights.FD_WRITE;</span>
    <span class="s1">}</span>
    <span class="s0">else if </span><span class="s1">(read_or_write_only === </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">ret.base &amp;= ~WasiRights.FD_READ;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">ret;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">concatBuffer(buffers, size) {</span>
    <span class="s0">let </span><span class="s1">total = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">size === </span><span class="s2">'number' </span><span class="s1">&amp;&amp; size &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">total = size;</span>
    <span class="s1">}</span>
    <span class="s0">else </span><span class="s1">{</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; buffers.length; i++) {</span>
            <span class="s0">const </span><span class="s1">buffer = buffers[i];</span>
            <span class="s1">total += buffer.length;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">let </span><span class="s1">pos = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s0">const </span><span class="s1">ret = </span><span class="s0">new </span><span class="s1">Uint8Array(total);</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; buffers.length; i++) {</span>
        <span class="s0">const </span><span class="s1">buffer = buffers[i];</span>
        <span class="s1">ret.set(buffer, pos);</span>
        <span class="s1">pos += buffer.length;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">ret;</span>
<span class="s1">}</span>
<span class="s0">class </span><span class="s1">FileDescriptor {</span>
    <span class="s1">constructor(id, fd, path, realPath, type, rightsBase, rightsInheriting, preopen) {</span>
        <span class="s0">this</span><span class="s1">.id = id;</span>
        <span class="s0">this</span><span class="s1">.fd = fd;</span>
        <span class="s0">this</span><span class="s1">.path = path;</span>
        <span class="s0">this</span><span class="s1">.realPath = realPath;</span>
        <span class="s0">this</span><span class="s1">.type = type;</span>
        <span class="s0">this</span><span class="s1">.rightsBase = rightsBase;</span>
        <span class="s0">this</span><span class="s1">.rightsInheriting = rightsInheriting;</span>
        <span class="s0">this</span><span class="s1">.preopen = preopen;</span>
        <span class="s0">this</span><span class="s1">.pos = BigInt(</span><span class="s4">0</span><span class="s1">);</span>
        <span class="s0">this</span><span class="s1">.size = BigInt(</span><span class="s4">0</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">seek(offset, whence) {</span>
        <span class="s0">if </span><span class="s1">(whence === </span><span class="s4">0 </span><span class="s3">/* WasiWhence.SET */</span><span class="s1">) {</span>
            <span class="s0">this</span><span class="s1">.pos = BigInt(offset);</span>
        <span class="s1">}</span>
        <span class="s0">else if </span><span class="s1">(whence === </span><span class="s4">1 </span><span class="s3">/* WasiWhence.CUR */</span><span class="s1">) {</span>
            <span class="s0">this</span><span class="s1">.pos += BigInt(offset);</span>
        <span class="s1">}</span>
        <span class="s0">else if </span><span class="s1">(whence === </span><span class="s4">2 </span><span class="s3">/* WasiWhence.END */</span><span class="s1">) {</span>
            <span class="s0">this</span><span class="s1">.pos = BigInt(</span><span class="s0">this</span><span class="s1">.size) - BigInt(offset);</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s0">throw new </span><span class="s1">WasiError(</span><span class="s2">'Unknown whence'</span><span class="s1">, </span><span class="s4">29 </span><span class="s3">/* WasiErrno.EIO */</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s0">return this</span><span class="s1">.pos;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">class </span><span class="s1">StandardOutput </span><span class="s0">extends </span><span class="s1">FileDescriptor {</span>
    <span class="s1">constructor(log, id, fd, path, realPath, type, rightsBase, rightsInheriting, preopen) {</span>
        <span class="s0">super</span><span class="s1">(id, fd, path, realPath, type, rightsBase, rightsInheriting, preopen);</span>
        <span class="s0">this</span><span class="s1">._log = log;</span>
        <span class="s0">this</span><span class="s1">._buf = </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">write(buffer) {</span>
        <span class="s0">const </span><span class="s1">originalBuffer = buffer;</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">._buf) {</span>
            <span class="s1">buffer = concatBuffer([</span><span class="s0">this</span><span class="s1">._buf, buffer]);</span>
            <span class="s0">this</span><span class="s1">._buf = </span><span class="s0">null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(buffer.indexOf(</span><span class="s4">10</span><span class="s1">) === -</span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s0">this</span><span class="s1">._buf = buffer;</span>
            <span class="s0">return </span><span class="s1">originalBuffer.byteLength;</span>
        <span class="s1">}</span>
        <span class="s0">let </span><span class="s1">written = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s0">let </span><span class="s1">lastBegin = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s0">let </span><span class="s1">index;</span>
        <span class="s0">while </span><span class="s1">((index = buffer.indexOf(</span><span class="s4">10</span><span class="s1">, written)) !== -</span><span class="s4">1</span><span class="s1">) {</span>
            <span class="s0">const </span><span class="s1">str = </span><span class="s0">new </span><span class="s1">TextDecoder().decode(buffer.subarray(lastBegin, index));</span>
            <span class="s0">this</span><span class="s1">._log(str);</span>
            <span class="s1">written += index - lastBegin + </span><span class="s4">1</span><span class="s1">;</span>
            <span class="s1">lastBegin = index + </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(written &lt; buffer.length) {</span>
            <span class="s0">this</span><span class="s1">._buf = buffer.slice(written);</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">originalBuffer.byteLength;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">toFileType(stat) {</span>
    <span class="s0">if </span><span class="s1">(stat.isBlockDevice())</span>
        <span class="s0">return </span><span class="s4">1 </span><span class="s3">/* WasiFileType.BLOCK_DEVICE */</span><span class="s1">;</span>
    <span class="s0">if </span><span class="s1">(stat.isCharacterDevice())</span>
        <span class="s0">return </span><span class="s4">2 </span><span class="s3">/* WasiFileType.CHARACTER_DEVICE */</span><span class="s1">;</span>
    <span class="s0">if </span><span class="s1">(stat.isDirectory())</span>
        <span class="s0">return </span><span class="s4">3 </span><span class="s3">/* WasiFileType.DIRECTORY */</span><span class="s1">;</span>
    <span class="s0">if </span><span class="s1">(stat.isSocket())</span>
        <span class="s0">return </span><span class="s4">6 </span><span class="s3">/* WasiFileType.SOCKET_STREAM */</span><span class="s1">;</span>
    <span class="s0">if </span><span class="s1">(stat.isFile())</span>
        <span class="s0">return </span><span class="s4">4 </span><span class="s3">/* WasiFileType.REGULAR_FILE */</span><span class="s1">;</span>
    <span class="s0">if </span><span class="s1">(stat.isSymbolicLink())</span>
        <span class="s0">return </span><span class="s4">7 </span><span class="s3">/* WasiFileType.SYMBOLIC_LINK */</span><span class="s1">;</span>
    <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiFileType.UNKNOWN */</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">toFileStat(view, buf, stat) {</span>
    <span class="s1">view.setBigUint64(buf, stat.dev, </span><span class="s0">true</span><span class="s1">);</span>
    <span class="s1">view.setBigUint64(buf + </span><span class="s4">8</span><span class="s1">, stat.ino, </span><span class="s0">true</span><span class="s1">);</span>
    <span class="s1">view.setBigUint64(buf + </span><span class="s4">16</span><span class="s1">, BigInt(toFileType(stat)), </span><span class="s0">true</span><span class="s1">);</span>
    <span class="s1">view.setBigUint64(buf + </span><span class="s4">24</span><span class="s1">, stat.nlink, </span><span class="s0">true</span><span class="s1">);</span>
    <span class="s1">view.setBigUint64(buf + </span><span class="s4">32</span><span class="s1">, stat.size, </span><span class="s0">true</span><span class="s1">);</span>
    <span class="s1">view.setBigUint64(buf + </span><span class="s4">40</span><span class="s1">, stat.atimeMs * BigInt(</span><span class="s4">1000000</span><span class="s1">), </span><span class="s0">true</span><span class="s1">);</span>
    <span class="s1">view.setBigUint64(buf + </span><span class="s4">48</span><span class="s1">, stat.mtimeMs * BigInt(</span><span class="s4">1000000</span><span class="s1">), </span><span class="s0">true</span><span class="s1">);</span>
    <span class="s1">view.setBigUint64(buf + </span><span class="s4">56</span><span class="s1">, stat.ctimeMs * BigInt(</span><span class="s4">1000000</span><span class="s1">), </span><span class="s0">true</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s0">class </span><span class="s1">FileDescriptorTable {</span>
    <span class="s1">constructor(options) {</span>
        <span class="s0">this</span><span class="s1">.used = </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s0">this</span><span class="s1">.size = options.size;</span>
        <span class="s0">this</span><span class="s1">.fds = Array(options.size);</span>
        <span class="s0">this</span><span class="s1">.stdio = [options.in, options.out, options.err];</span>
        <span class="s0">this</span><span class="s1">.print = options.print;</span>
        <span class="s0">this</span><span class="s1">.printErr = options.printErr;</span>
        <span class="s0">this</span><span class="s1">.insertStdio(options.in, </span><span class="s4">0</span><span class="s1">, </span><span class="s2">'&lt;stdin&gt;'</span><span class="s1">);</span>
        <span class="s0">this</span><span class="s1">.insertStdio(options.out, </span><span class="s4">1</span><span class="s1">, </span><span class="s2">'&lt;stdout&gt;'</span><span class="s1">);</span>
        <span class="s0">this</span><span class="s1">.insertStdio(options.err, </span><span class="s4">2</span><span class="s1">, </span><span class="s2">'&lt;stderr&gt;'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">insertStdio(fd, expected, name) {</span>
        <span class="s0">const </span><span class="s1">type = </span><span class="s4">2 </span><span class="s3">/* WasiFileType.CHARACTER_DEVICE */</span><span class="s1">;</span>
        <span class="s0">const </span><span class="s1">{ base, inheriting } = getRights(</span><span class="s0">this</span><span class="s1">.stdio, fd, </span><span class="s4">2 </span><span class="s3">/* FileControlFlag.O_RDWR */</span><span class="s1">, type);</span>
        <span class="s0">const </span><span class="s1">wrap = </span><span class="s0">this</span><span class="s1">.insert(fd, name, name, type, base, inheriting, </span><span class="s4">0</span><span class="s1">);</span>
        <span class="s0">if </span><span class="s1">(wrap.id !== expected) {</span>
            <span class="s0">throw new </span><span class="s1">WasiError(</span><span class="s2">`id: </span><span class="s1">${wrap.id} </span><span class="s2">!== expected: </span><span class="s1">${expected}</span><span class="s2">`</span><span class="s1">, </span><span class="s4">8 </span><span class="s3">/* WasiErrno.EBADF */</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">wrap;</span>
    <span class="s1">}</span>
    <span class="s1">insert(fd, mappedPath, realPath, type, rightsBase, rightsInheriting, preopen) {</span>
        <span class="s0">var </span><span class="s1">_a, _b;</span>
        <span class="s0">let </span><span class="s1">index = -</span><span class="s4">1</span><span class="s1">;</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.used &gt;= </span><span class="s0">this</span><span class="s1">.size) {</span>
            <span class="s0">const </span><span class="s1">newSize = </span><span class="s0">this</span><span class="s1">.size * </span><span class="s4">2</span><span class="s1">;</span>
            <span class="s0">this</span><span class="s1">.fds.length = newSize;</span>
            <span class="s1">index = </span><span class="s0">this</span><span class="s1">.size;</span>
            <span class="s0">this</span><span class="s1">.size = newSize;</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; </span><span class="s0">this</span><span class="s1">.size; ++i) {</span>
                <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.fds[i] == </span><span class="s0">null</span><span class="s1">) {</span>
                    <span class="s1">index = i;</span>
                    <span class="s0">break</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">let </span><span class="s1">entry;</span>
        <span class="s0">if </span><span class="s1">(mappedPath === </span><span class="s2">'&lt;stdout&gt;'</span><span class="s1">) {</span>
            <span class="s1">entry = </span><span class="s0">new </span><span class="s1">StandardOutput((_a = </span><span class="s0">this</span><span class="s1">.print) !== </span><span class="s0">null </span><span class="s1">&amp;&amp; _a !== </span><span class="s0">void </span><span class="s4">0 </span><span class="s1">? _a : console.log, index, fd, mappedPath, realPath, type, rightsBase, rightsInheriting, preopen);</span>
        <span class="s1">}</span>
        <span class="s0">else if </span><span class="s1">(mappedPath === </span><span class="s2">'&lt;stderr&gt;'</span><span class="s1">) {</span>
            <span class="s1">entry = </span><span class="s0">new </span><span class="s1">StandardOutput((_b = </span><span class="s0">this</span><span class="s1">.printErr) !== </span><span class="s0">null </span><span class="s1">&amp;&amp; _b !== </span><span class="s0">void </span><span class="s4">0 </span><span class="s1">? _b : console.error, index, fd, mappedPath, realPath, type, rightsBase, rightsInheriting, preopen);</span>
        <span class="s1">}</span>
        <span class="s0">else </span><span class="s1">{</span>
            <span class="s1">entry = </span><span class="s0">new </span><span class="s1">FileDescriptor(index, fd, mappedPath, realPath, type, rightsBase, rightsInheriting, preopen);</span>
        <span class="s1">}</span>
        <span class="s0">this</span><span class="s1">.fds[index] = entry;</span>
        <span class="s0">this</span><span class="s1">.used++;</span>
        <span class="s0">return </span><span class="s1">entry;</span>
    <span class="s1">}</span>
    <span class="s1">get(id, base, inheriting) {</span>
        <span class="s0">if </span><span class="s1">(id &gt;= </span><span class="s0">this</span><span class="s1">.size) {</span>
            <span class="s0">throw new </span><span class="s1">WasiError(</span><span class="s2">'Invalid fd'</span><span class="s1">, </span><span class="s4">8 </span><span class="s3">/* WasiErrno.EBADF */</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s0">const </span><span class="s1">entry = </span><span class="s0">this</span><span class="s1">.fds[id];</span>
        <span class="s0">if </span><span class="s1">(!entry || entry.id !== id) {</span>
            <span class="s0">throw new </span><span class="s1">WasiError(</span><span class="s2">'Bad file descriptor'</span><span class="s1">, </span><span class="s4">8 </span><span class="s3">/* WasiErrno.EBADF */</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s3">/* Validate that the fd has the necessary rights. */</span>
        <span class="s0">if </span><span class="s1">((~entry.rightsBase &amp; base) !== BigInt(</span><span class="s4">0</span><span class="s1">) || (~entry.rightsInheriting &amp; inheriting) !== BigInt(</span><span class="s4">0</span><span class="s1">)) {</span>
            <span class="s0">throw new </span><span class="s1">WasiError(</span><span class="s2">'Capabilities insufficient'</span><span class="s1">, </span><span class="s4">76 </span><span class="s3">/* WasiErrno.ENOTCAPABLE */</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">entry;</span>
    <span class="s1">}</span>
    <span class="s1">remove(id) {</span>
        <span class="s0">if </span><span class="s1">(id &gt;= </span><span class="s0">this</span><span class="s1">.size) {</span>
            <span class="s0">throw new </span><span class="s1">WasiError(</span><span class="s2">'Invalid fd'</span><span class="s1">, </span><span class="s4">8 </span><span class="s3">/* WasiErrno.EBADF */</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s0">const </span><span class="s1">entry = </span><span class="s0">this</span><span class="s1">.fds[id];</span>
        <span class="s0">if </span><span class="s1">(!entry || entry.id !== id) {</span>
            <span class="s0">throw new </span><span class="s1">WasiError(</span><span class="s2">'Bad file descriptor'</span><span class="s1">, </span><span class="s4">8 </span><span class="s3">/* WasiErrno.EBADF */</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s0">this</span><span class="s1">.fds[id] = undefined;</span>
        <span class="s0">this</span><span class="s1">.used--;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">class </span><span class="s1">SyncTable </span><span class="s0">extends </span><span class="s1">FileDescriptorTable {</span>
    <span class="s1">constructor(options) {</span>
        <span class="s0">super</span><span class="s1">(options);</span>
        <span class="s0">this</span><span class="s1">.fs = options.fs;</span>
    <span class="s1">}</span>
    <span class="s1">getFileTypeByFd(fd) {</span>
        <span class="s0">const </span><span class="s1">stats = </span><span class="s0">this</span><span class="s1">.fs.fstatSync(fd, { bigint: </span><span class="s0">true </span><span class="s1">});</span>
        <span class="s0">return </span><span class="s1">toFileType(stats);</span>
    <span class="s1">}</span>
    <span class="s1">insertPreopen(fd, mappedPath, realPath) {</span>
        <span class="s0">const </span><span class="s1">type = </span><span class="s0">this</span><span class="s1">.getFileTypeByFd(fd);</span>
        <span class="s0">if </span><span class="s1">(type !== </span><span class="s4">3 </span><span class="s3">/* WasiFileType.DIRECTORY */</span><span class="s1">) {</span>
            <span class="s0">throw new </span><span class="s1">WasiError(</span><span class="s2">`Preopen not dir: [&quot;</span><span class="s1">${mappedPath}</span><span class="s2">&quot;, &quot;</span><span class="s1">${realPath}</span><span class="s2">&quot;]`</span><span class="s1">, </span><span class="s4">54 </span><span class="s3">/* WasiErrno.ENOTDIR */</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s0">const </span><span class="s1">result = getRights(</span><span class="s0">this</span><span class="s1">.stdio, fd, </span><span class="s4">0</span><span class="s1">, type);</span>
        <span class="s0">return this</span><span class="s1">.insert(fd, mappedPath, realPath, type, result.base, result.inheriting, </span><span class="s4">1</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">renumber(dst, src) {</span>
        <span class="s0">if </span><span class="s1">(dst === src)</span>
            <span class="s0">return</span><span class="s1">;</span>
        <span class="s0">if </span><span class="s1">(dst &gt;= </span><span class="s0">this</span><span class="s1">.size || src &gt;= </span><span class="s0">this</span><span class="s1">.size) {</span>
            <span class="s0">throw new </span><span class="s1">WasiError(</span><span class="s2">'Invalid fd'</span><span class="s1">, </span><span class="s4">8 </span><span class="s3">/* WasiErrno.EBADF */</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s0">const </span><span class="s1">dstEntry = </span><span class="s0">this</span><span class="s1">.fds[dst];</span>
        <span class="s0">const </span><span class="s1">srcEntry = </span><span class="s0">this</span><span class="s1">.fds[src];</span>
        <span class="s0">if </span><span class="s1">(!dstEntry || !srcEntry || dstEntry.id !== dst || srcEntry.id !== src) {</span>
            <span class="s0">throw new </span><span class="s1">WasiError(</span><span class="s2">'Invalid fd'</span><span class="s1">, </span><span class="s4">8 </span><span class="s3">/* WasiErrno.EBADF */</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s0">this</span><span class="s1">.fs.closeSync(dstEntry.fd);</span>
        <span class="s0">this</span><span class="s1">.fds[dst] = </span><span class="s0">this</span><span class="s1">.fds[src];</span>
        <span class="s0">this</span><span class="s1">.fds[dst].id = dst;</span>
        <span class="s0">this</span><span class="s1">.fds[src] = undefined;</span>
        <span class="s0">this</span><span class="s1">.used--;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">class </span><span class="s1">AsyncTable </span><span class="s0">extends </span><span class="s1">FileDescriptorTable {</span>
    <span class="s3">// eslint-disable-next-line @typescript-eslint/no-useless-constructor</span>
    <span class="s1">constructor(options) {</span>
        <span class="s0">super</span><span class="s1">(options);</span>
    <span class="s1">}</span>
    <span class="s1">async getFileTypeByFd(fd) {</span>
        <span class="s0">const </span><span class="s1">stats = </span><span class="s0">await </span><span class="s1">fd.stat({ bigint: </span><span class="s0">true </span><span class="s1">});</span>
        <span class="s0">return </span><span class="s1">toFileType(stats);</span>
    <span class="s1">}</span>
    <span class="s1">async insertPreopen(fd, mappedPath, realPath) {</span>
        <span class="s0">const </span><span class="s1">type = </span><span class="s0">await this</span><span class="s1">.getFileTypeByFd(fd);</span>
        <span class="s0">if </span><span class="s1">(type !== </span><span class="s4">3 </span><span class="s3">/* WasiFileType.DIRECTORY */</span><span class="s1">) {</span>
            <span class="s0">throw new </span><span class="s1">WasiError(</span><span class="s2">`Preopen not dir: [&quot;</span><span class="s1">${mappedPath}</span><span class="s2">&quot;, &quot;</span><span class="s1">${realPath}</span><span class="s2">&quot;]`</span><span class="s1">, </span><span class="s4">54 </span><span class="s3">/* WasiErrno.ENOTDIR */</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s0">const </span><span class="s1">result = getRights(</span><span class="s0">this</span><span class="s1">.stdio, fd.fd, </span><span class="s4">0</span><span class="s1">, type);</span>
        <span class="s0">return this</span><span class="s1">.insert(fd, mappedPath, realPath, type, result.base, result.inheriting, </span><span class="s4">1</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">async renumber(dst, src) {</span>
        <span class="s0">if </span><span class="s1">(dst === src)</span>
            <span class="s0">return</span><span class="s1">;</span>
        <span class="s0">if </span><span class="s1">(dst &gt;= </span><span class="s0">this</span><span class="s1">.size || src &gt;= </span><span class="s0">this</span><span class="s1">.size) {</span>
            <span class="s0">throw new </span><span class="s1">WasiError(</span><span class="s2">'Invalid fd'</span><span class="s1">, </span><span class="s4">8 </span><span class="s3">/* WasiErrno.EBADF */</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s0">const </span><span class="s1">dstEntry = </span><span class="s0">this</span><span class="s1">.fds[dst];</span>
        <span class="s0">const </span><span class="s1">srcEntry = </span><span class="s0">this</span><span class="s1">.fds[src];</span>
        <span class="s0">if </span><span class="s1">(!dstEntry || !srcEntry || dstEntry.id !== dst || srcEntry.id !== src) {</span>
            <span class="s0">throw new </span><span class="s1">WasiError(</span><span class="s2">'Invalid fd'</span><span class="s1">, </span><span class="s4">8 </span><span class="s3">/* WasiErrno.EBADF */</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s0">await </span><span class="s1">dstEntry.fd.close();</span>
        <span class="s0">this</span><span class="s1">.fds[dst] = </span><span class="s0">this</span><span class="s1">.fds[src];</span>
        <span class="s0">this</span><span class="s1">.fds[dst].id = dst;</span>
        <span class="s0">this</span><span class="s1">.fds[src] = undefined;</span>
        <span class="s0">this</span><span class="s1">.used--;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">/** </span><span class="s5">@public </span><span class="s3">*/</span>
<span class="s0">const </span><span class="s1">WebAssemblyMemory = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">(</span><span class="s0">function </span><span class="s1">() { </span><span class="s0">return </span><span class="s1">_WebAssembly.Memory; })();</span>
<span class="s3">/** </span><span class="s5">@public </span><span class="s3">*/</span>
<span class="s0">class </span><span class="s1">Memory </span><span class="s0">extends </span><span class="s1">WebAssemblyMemory {</span>
    <span class="s3">// eslint-disable-next-line @typescript-eslint/no-useless-constructor</span>
    <span class="s1">constructor(descriptor) {</span>
        <span class="s0">super</span><span class="s1">(descriptor);</span>
    <span class="s1">}</span>
    <span class="s1">get HEAP8() { </span><span class="s0">return new </span><span class="s1">Int8Array(</span><span class="s0">super</span><span class="s1">.buffer); }</span>
    <span class="s1">get HEAPU8() { </span><span class="s0">return new </span><span class="s1">Uint8Array(</span><span class="s0">super</span><span class="s1">.buffer); }</span>
    <span class="s1">get HEAP16() { </span><span class="s0">return new </span><span class="s1">Int16Array(</span><span class="s0">super</span><span class="s1">.buffer); }</span>
    <span class="s1">get HEAPU16() { </span><span class="s0">return new </span><span class="s1">Uint16Array(</span><span class="s0">super</span><span class="s1">.buffer); }</span>
    <span class="s1">get HEAP32() { </span><span class="s0">return new </span><span class="s1">Int32Array(</span><span class="s0">super</span><span class="s1">.buffer); }</span>
    <span class="s1">get HEAPU32() { </span><span class="s0">return new </span><span class="s1">Uint32Array(</span><span class="s0">super</span><span class="s1">.buffer); }</span>
    <span class="s1">get HEAP64() { </span><span class="s0">return new </span><span class="s1">BigInt64Array(</span><span class="s0">super</span><span class="s1">.buffer); }</span>
    <span class="s1">get HEAPU64() { </span><span class="s0">return new </span><span class="s1">BigUint64Array(</span><span class="s0">super</span><span class="s1">.buffer); }</span>
    <span class="s1">get HEAPF32() { </span><span class="s0">return new </span><span class="s1">Float32Array(</span><span class="s0">super</span><span class="s1">.buffer); }</span>
    <span class="s1">get HEAPF64() { </span><span class="s0">return new </span><span class="s1">Float64Array(</span><span class="s0">super</span><span class="s1">.buffer); }</span>
    <span class="s1">get view() { </span><span class="s0">return new </span><span class="s1">DataView(</span><span class="s0">super</span><span class="s1">.buffer); }</span>
<span class="s1">}</span>
<span class="s3">/** </span><span class="s5">@public </span><span class="s3">*/</span>
<span class="s0">function </span><span class="s1">extendMemory(memory) {</span>
    <span class="s0">if </span><span class="s1">(Object.getPrototypeOf(memory) === _WebAssembly.Memory.prototype) {</span>
        <span class="s1">Object.setPrototypeOf(memory, Memory.prototype);</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">memory;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">checkWebAssemblyFunction() {</span>
    <span class="s0">const </span><span class="s1">WebAssemblyFunction = _WebAssembly.Function;</span>
    <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">WebAssemblyFunction !== </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">'WebAssembly.Function is not supported in this environment.' </span><span class="s1">+</span>
            <span class="s2">' If you are using V8 based browser like Chrome, try to specify' </span><span class="s1">+</span>
            <span class="s2">' --js-flags=&quot;--wasm-staging --experimental-wasm-stack-switching&quot;'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">WebAssemblyFunction;</span>
<span class="s1">}</span>
<span class="s3">/** </span><span class="s5">@public </span><span class="s3">*/</span>
<span class="s0">function </span><span class="s1">wrapAsyncImport(f, parameterType, returnType) {</span>
    <span class="s0">const </span><span class="s1">WebAssemblyFunction = checkWebAssemblyFunction();</span>
    <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">f !== </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s0">throw new </span><span class="s1">TypeError(</span><span class="s2">'Function required'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s0">const </span><span class="s1">parameters = parameterType.slice(</span><span class="s4">0</span><span class="s1">);</span>
    <span class="s1">parameters.unshift(</span><span class="s2">'externref'</span><span class="s1">);</span>
    <span class="s0">return new </span><span class="s1">WebAssemblyFunction({ parameters, results: returnType }, f, { suspending: </span><span class="s2">'first' </span><span class="s1">});</span>
<span class="s1">}</span>
<span class="s3">/** </span><span class="s5">@public </span><span class="s3">*/</span>
<span class="s0">function </span><span class="s1">wrapAsyncExport(f) {</span>
    <span class="s0">const </span><span class="s1">WebAssemblyFunction = checkWebAssemblyFunction();</span>
    <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">f !== </span><span class="s2">'function'</span><span class="s1">) {</span>
        <span class="s0">throw new </span><span class="s1">TypeError(</span><span class="s2">'Function required'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s0">return new </span><span class="s1">WebAssemblyFunction({ parameters: [...WebAssemblyFunction.type(f).parameters.slice(</span><span class="s4">1</span><span class="s1">)], results: [</span><span class="s2">'externref'</span><span class="s1">] }, f, { promising: </span><span class="s2">'first' </span><span class="s1">});</span>
<span class="s1">}</span>
<span class="s3">/** </span><span class="s5">@public </span><span class="s3">*/</span>
<span class="s0">function </span><span class="s1">wrapExports(exports, needWrap) {</span>
    <span class="s0">return </span><span class="s1">wrapInstanceExports(exports, (exportValue, name) =&gt; {</span>
        <span class="s0">let </span><span class="s1">ignore = </span><span class="s0">typeof </span><span class="s1">exportValue !== </span><span class="s2">'function'</span><span class="s1">;</span>
        <span class="s0">if </span><span class="s1">(Array.isArray(needWrap)) {</span>
            <span class="s1">ignore = ignore || (needWrap.indexOf(name) === -</span><span class="s4">1</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">ignore ? exportValue : wrapAsyncExport(exportValue);</span>
    <span class="s1">});</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">copyMemory(targets, src) {</span>
    <span class="s0">if </span><span class="s1">(targets.length === </span><span class="s4">0 </span><span class="s1">|| src.length === </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s0">let </span><span class="s1">copied = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s0">let </span><span class="s1">left = src.length - copied;</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; targets.length; ++i) {</span>
        <span class="s0">const </span><span class="s1">target = targets[i];</span>
        <span class="s0">if </span><span class="s1">(left &lt; target.length) {</span>
            <span class="s1">target.set(src.subarray(copied, copied + left), </span><span class="s4">0</span><span class="s1">);</span>
            <span class="s1">copied += left;</span>
            <span class="s1">left = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s0">return </span><span class="s1">copied;</span>
        <span class="s1">}</span>
        <span class="s1">target.set(src.subarray(copied, copied + target.length), </span><span class="s4">0</span><span class="s1">);</span>
        <span class="s1">copied += target.length;</span>
        <span class="s1">left -= target.length;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">copied;</span>
<span class="s1">}</span>
<span class="s0">const </span><span class="s1">_memory = </span><span class="s0">new </span><span class="s1">WeakMap();</span>
<span class="s0">const </span><span class="s1">_wasi = </span><span class="s0">new </span><span class="s1">WeakMap();</span>
<span class="s0">const </span><span class="s1">_fs = </span><span class="s0">new </span><span class="s1">WeakMap();</span>
<span class="s0">function </span><span class="s1">getMemory(wasi) {</span>
    <span class="s0">return </span><span class="s1">_memory.get(wasi);</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">getFs(wasi) {</span>
    <span class="s0">const </span><span class="s1">fs = _fs.get(wasi);</span>
    <span class="s0">if </span><span class="s1">(!fs)</span>
        <span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">'filesystem is unavailable'</span><span class="s1">);</span>
    <span class="s0">return </span><span class="s1">fs;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">handleError(err) {</span>
    <span class="s0">if </span><span class="s1">(err </span><span class="s0">instanceof </span><span class="s1">WasiError) {</span>
        <span class="s1">{</span>
            <span class="s1">console.warn(err);</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">err.errno;</span>
    <span class="s1">}</span>
    <span class="s0">switch </span><span class="s1">(err.code) {</span>
        <span class="s0">case </span><span class="s2">'ENOENT'</span><span class="s1">: </span><span class="s0">return </span><span class="s4">44 </span><span class="s3">/* WasiErrno.ENOENT */</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s2">'EBADF'</span><span class="s1">: </span><span class="s0">return </span><span class="s4">8 </span><span class="s3">/* WasiErrno.EBADF */</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s2">'EINVAL'</span><span class="s1">: </span><span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s2">'EPERM'</span><span class="s1">: </span><span class="s0">return </span><span class="s4">63 </span><span class="s3">/* WasiErrno.EPERM */</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s2">'EPROTO'</span><span class="s1">: </span><span class="s0">return </span><span class="s4">65 </span><span class="s3">/* WasiErrno.EPROTO */</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s2">'EEXIST'</span><span class="s1">: </span><span class="s0">return </span><span class="s4">20 </span><span class="s3">/* WasiErrno.EEXIST */</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s2">'ENOTDIR'</span><span class="s1">: </span><span class="s0">return </span><span class="s4">54 </span><span class="s3">/* WasiErrno.ENOTDIR */</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s2">'EMFILE'</span><span class="s1">: </span><span class="s0">return </span><span class="s4">33 </span><span class="s3">/* WasiErrno.EMFILE */</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s2">'EACCES'</span><span class="s1">: </span><span class="s0">return </span><span class="s4">2 </span><span class="s3">/* WasiErrno.EACCES */</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s2">'EISDIR'</span><span class="s1">: </span><span class="s0">return </span><span class="s4">31 </span><span class="s3">/* WasiErrno.EISDIR */</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s2">'ENOTEMPTY'</span><span class="s1">: </span><span class="s0">return </span><span class="s4">55 </span><span class="s3">/* WasiErrno.ENOTEMPTY */</span><span class="s1">;</span>
        <span class="s0">case </span><span class="s2">'ENOSYS'</span><span class="s1">: </span><span class="s0">return </span><span class="s4">52 </span><span class="s3">/* WasiErrno.ENOSYS */</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">throw </span><span class="s1">err;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">defineName(name, f) {</span>
    <span class="s1">Object.defineProperty(f, </span><span class="s2">'name'</span><span class="s1">, { value: name });</span>
    <span class="s0">return </span><span class="s1">f;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">tryCall(f, wasi, args) {</span>
    <span class="s0">let </span><span class="s1">r;</span>
    <span class="s0">try </span><span class="s1">{</span>
        <span class="s1">r = f.apply(wasi, args);</span>
    <span class="s1">}</span>
    <span class="s0">catch </span><span class="s1">(err) {</span>
        <span class="s0">return </span><span class="s1">handleError(err);</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(isPromiseLike(r)) {</span>
        <span class="s0">return </span><span class="s1">r.then(_ =&gt; _, handleError);</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">r;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">syscallWrap(self, name, f) {</span>
    <span class="s0">let </span><span class="s1">debug = </span><span class="s0">false</span><span class="s1">;</span>
    <span class="s0">const </span><span class="s1">NODE_DEBUG_NATIVE = (() =&gt; {</span>
        <span class="s0">try </span><span class="s1">{</span>
            <span class="s0">return </span><span class="s2">&quot;wasi&quot;</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s0">catch </span><span class="s1">(_) {</span>
            <span class="s0">return </span><span class="s1">undefined;</span>
        <span class="s1">}</span>
    <span class="s1">})();</span>
    <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">NODE_DEBUG_NATIVE === </span><span class="s2">'string' </span><span class="s1">&amp;&amp; NODE_DEBUG_NATIVE.split(</span><span class="s2">','</span><span class="s1">).includes(</span><span class="s2">'wasi'</span><span class="s1">)) {</span>
        <span class="s1">debug = </span><span class="s0">true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">debug</span>
        <span class="s1">? defineName(name, </span><span class="s0">function </span><span class="s1">() {</span>
            <span class="s0">const </span><span class="s1">args = Array.prototype.slice.call(arguments);</span>
            <span class="s0">let </span><span class="s1">debugArgs = [</span><span class="s2">`</span><span class="s1">${name}</span><span class="s2">(</span><span class="s1">${Array.from({ length: arguments.length }).map(() =&gt; </span><span class="s2">'%d'</span><span class="s1">).join(</span><span class="s2">', '</span><span class="s1">)}</span><span class="s2">)`</span><span class="s1">];</span>
            <span class="s1">debugArgs = debugArgs.concat(args);</span>
            <span class="s1">console.debug.apply(console, debugArgs);</span>
            <span class="s0">return </span><span class="s1">tryCall(f, self, args);</span>
        <span class="s1">})</span>
        <span class="s1">: defineName(name, </span><span class="s0">function </span><span class="s1">() {</span>
            <span class="s0">return </span><span class="s1">tryCall(f, self, arguments);</span>
        <span class="s1">});</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">resolvePathSync(fs, fileDescriptor, path, flags) {</span>
    <span class="s0">let </span><span class="s1">resolvedPath = resolve(fileDescriptor.realPath, path);</span>
    <span class="s0">if </span><span class="s1">((flags &amp; </span><span class="s4">1</span><span class="s1">) === </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s0">try </span><span class="s1">{</span>
            <span class="s1">resolvedPath = fs.readlinkSync(resolvedPath);</span>
        <span class="s1">}</span>
        <span class="s0">catch </span><span class="s1">(err) {</span>
            <span class="s0">if </span><span class="s1">(err.code !== </span><span class="s2">'EINVAL' </span><span class="s1">&amp;&amp; err.code !== </span><span class="s2">'ENOENT'</span><span class="s1">) {</span>
                <span class="s0">throw </span><span class="s1">err;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">resolvedPath;</span>
<span class="s1">}</span>
<span class="s1">async </span><span class="s0">function </span><span class="s1">resolvePathAsync(fs, fileDescriptor, path, flags) {</span>
    <span class="s0">let </span><span class="s1">resolvedPath = resolve(fileDescriptor.realPath, path);</span>
    <span class="s0">if </span><span class="s1">((flags &amp; </span><span class="s4">1</span><span class="s1">) === </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s0">try </span><span class="s1">{</span>
            <span class="s1">resolvedPath = </span><span class="s0">await </span><span class="s1">fs.promises.readlink(resolvedPath);</span>
        <span class="s1">}</span>
        <span class="s0">catch </span><span class="s1">(err) {</span>
            <span class="s0">if </span><span class="s1">(err.code !== </span><span class="s2">'EINVAL' </span><span class="s1">&amp;&amp; err.code !== </span><span class="s2">'ENOENT'</span><span class="s1">) {</span>
                <span class="s0">throw </span><span class="s1">err;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">resolvedPath;</span>
<span class="s1">}</span>
<span class="s3">// eslint-disable-next-line spaced-comment</span>
<span class="s0">const </span><span class="s1">encoder = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">new </span><span class="s1">TextEncoder();</span>
<span class="s3">// eslint-disable-next-line spaced-comment</span>
<span class="s0">const </span><span class="s1">decoder = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">new </span><span class="s1">TextDecoder();</span>
<span class="s0">const </span><span class="s1">INT64_MAX = (BigInt(</span><span class="s4">1</span><span class="s1">) &lt;&lt; BigInt(</span><span class="s4">63</span><span class="s1">)) - BigInt(</span><span class="s4">1</span><span class="s1">);</span>
<span class="s0">function </span><span class="s1">readStdin() {</span>
    <span class="s0">const </span><span class="s1">value = window.prompt();</span>
    <span class="s0">if </span><span class="s1">(value === </span><span class="s0">null</span><span class="s1">)</span>
        <span class="s0">return new </span><span class="s1">Uint8Array();</span>
    <span class="s0">const </span><span class="s1">buffer = </span><span class="s0">new </span><span class="s1">TextEncoder().encode(value + </span><span class="s2">'</span><span class="s6">\n</span><span class="s2">'</span><span class="s1">);</span>
    <span class="s0">return </span><span class="s1">buffer;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">validateFstFlagsOrReturn(flags) {</span>
    <span class="s0">return </span><span class="s1">(Boolean((flags) &amp; ~(</span><span class="s4">1 </span><span class="s3">/* WasiFstFlag.SET_ATIM */ </span><span class="s1">| </span><span class="s4">2 </span><span class="s3">/* WasiFstFlag.SET_ATIM_NOW */ </span><span class="s1">|</span>
        <span class="s4">4 </span><span class="s3">/* WasiFstFlag.SET_MTIM */ </span><span class="s1">| </span><span class="s4">8 </span><span class="s3">/* WasiFstFlag.SET_MTIM_NOW */</span><span class="s1">)) ||</span>
        <span class="s1">((flags) &amp; (</span><span class="s4">1 </span><span class="s3">/* WasiFstFlag.SET_ATIM */ </span><span class="s1">| </span><span class="s4">2 </span><span class="s3">/* WasiFstFlag.SET_ATIM_NOW */</span><span class="s1">)) ===</span>
            <span class="s1">(</span><span class="s4">1 </span><span class="s3">/* WasiFstFlag.SET_ATIM */ </span><span class="s1">| </span><span class="s4">2 </span><span class="s3">/* WasiFstFlag.SET_ATIM_NOW */</span><span class="s1">) ||</span>
        <span class="s1">((flags) &amp; (</span><span class="s4">4 </span><span class="s3">/* WasiFstFlag.SET_MTIM */ </span><span class="s1">| </span><span class="s4">8 </span><span class="s3">/* WasiFstFlag.SET_MTIM_NOW */</span><span class="s1">)) ===</span>
            <span class="s1">(</span><span class="s4">4 </span><span class="s3">/* WasiFstFlag.SET_MTIM */ </span><span class="s1">| </span><span class="s4">8 </span><span class="s3">/* WasiFstFlag.SET_MTIM_NOW */</span><span class="s1">));</span>
<span class="s1">}</span>
<span class="s0">class </span><span class="s1">WASI$1 {</span>
    <span class="s1">constructor(args, env, fds, asyncFs, fs, asyncify) {</span>
        <span class="s0">this</span><span class="s1">.args_get = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'args_get'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">(argv, argv_buf) {</span>
            <span class="s1">argv = Number(argv);</span>
            <span class="s1">argv_buf = Number(argv_buf);</span>
            <span class="s0">if </span><span class="s1">(argv === </span><span class="s4">0 </span><span class="s1">|| argv_buf === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8, view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">args = wasi.args;</span>
            <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; args.length; ++i) {</span>
                <span class="s0">const </span><span class="s1">arg = args[i];</span>
                <span class="s1">view.setInt32(argv, argv_buf, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s1">argv += </span><span class="s4">4</span><span class="s1">;</span>
                <span class="s0">const </span><span class="s1">data = encoder.encode(arg + </span><span class="s2">'</span><span class="s6">\0</span><span class="s2">'</span><span class="s1">);</span>
                <span class="s1">HEAPU8.set(data, argv_buf);</span>
                <span class="s1">argv_buf += data.length;</span>
            <span class="s1">}</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.args_sizes_get = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'args_sizes_get'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">(argc, argv_buf_size) {</span>
            <span class="s1">argc = Number(argc);</span>
            <span class="s1">argv_buf_size = Number(argv_buf_size);</span>
            <span class="s0">if </span><span class="s1">(argc === </span><span class="s4">0 </span><span class="s1">|| argv_buf_size === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">args = wasi.args;</span>
            <span class="s1">view.setUint32(argc, args.length, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s1">view.setUint32(argv_buf_size, encoder.encode(args.join(</span><span class="s2">'</span><span class="s6">\0</span><span class="s2">'</span><span class="s1">) + </span><span class="s2">'</span><span class="s6">\0</span><span class="s2">'</span><span class="s1">).length, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.environ_get = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'environ_get'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">(environ, environ_buf) {</span>
            <span class="s1">environ = Number(environ);</span>
            <span class="s1">environ_buf = Number(environ_buf);</span>
            <span class="s0">if </span><span class="s1">(environ === </span><span class="s4">0 </span><span class="s1">|| environ_buf === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8, view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">env = wasi.env;</span>
            <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; env.length; ++i) {</span>
                <span class="s0">const </span><span class="s1">pair = env[i];</span>
                <span class="s1">view.setInt32(environ, environ_buf, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s1">environ += </span><span class="s4">4</span><span class="s1">;</span>
                <span class="s0">const </span><span class="s1">data = encoder.encode(pair + </span><span class="s2">'</span><span class="s6">\0</span><span class="s2">'</span><span class="s1">);</span>
                <span class="s1">HEAPU8.set(data, environ_buf);</span>
                <span class="s1">environ_buf += data.length;</span>
            <span class="s1">}</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.environ_sizes_get = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'environ_sizes_get'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">(len, buflen) {</span>
            <span class="s1">len = Number(len);</span>
            <span class="s1">buflen = Number(buflen);</span>
            <span class="s0">if </span><span class="s1">(len === </span><span class="s4">0 </span><span class="s1">|| buflen === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">view.setUint32(len, wasi.env.length, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s1">view.setUint32(buflen, encoder.encode(wasi.env.join(</span><span class="s2">'</span><span class="s6">\0</span><span class="s2">'</span><span class="s1">) + </span><span class="s2">'</span><span class="s6">\0</span><span class="s2">'</span><span class="s1">).length, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.clock_res_get = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'clock_res_get'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">(id, resolution) {</span>
            <span class="s1">resolution = Number(resolution);</span>
            <span class="s0">if </span><span class="s1">(resolution === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">switch </span><span class="s1">(id) {</span>
                <span class="s0">case </span><span class="s4">0 </span><span class="s3">/* WasiClockid.REALTIME */</span><span class="s1">:</span>
                    <span class="s1">view.setBigUint64(resolution, BigInt(</span><span class="s4">1000000</span><span class="s1">), </span><span class="s0">true</span><span class="s1">);</span>
                    <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
                <span class="s0">case </span><span class="s4">1 </span><span class="s3">/* WasiClockid.MONOTONIC */</span><span class="s1">:</span>
                <span class="s0">case </span><span class="s4">2 </span><span class="s3">/* WasiClockid.PROCESS_CPUTIME_ID */</span><span class="s1">:</span>
                <span class="s0">case </span><span class="s4">3 </span><span class="s3">/* WasiClockid.THREAD_CPUTIME_ID */</span><span class="s1">:</span>
                    <span class="s1">view.setBigUint64(resolution, BigInt(</span><span class="s4">1000</span><span class="s1">), </span><span class="s0">true</span><span class="s1">);</span>
                    <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
                <span class="s0">default</span><span class="s1">: </span><span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.clock_time_get = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'clock_time_get'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">(id, _percision, time) {</span>
            <span class="s1">time = Number(time);</span>
            <span class="s0">if </span><span class="s1">(time === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">switch </span><span class="s1">(id) {</span>
                <span class="s0">case </span><span class="s4">0 </span><span class="s3">/* WasiClockid.REALTIME */</span><span class="s1">:</span>
                    <span class="s1">view.setBigUint64(time, BigInt(Date.now()) * BigInt(</span><span class="s4">1000000</span><span class="s1">), </span><span class="s0">true</span><span class="s1">);</span>
                    <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
                <span class="s0">case </span><span class="s4">1 </span><span class="s3">/* WasiClockid.MONOTONIC */</span><span class="s1">:</span>
                <span class="s0">case </span><span class="s4">2 </span><span class="s3">/* WasiClockid.PROCESS_CPUTIME_ID */</span><span class="s1">:</span>
                <span class="s0">case </span><span class="s4">3 </span><span class="s3">/* WasiClockid.THREAD_CPUTIME_ID */</span><span class="s1">: {</span>
                    <span class="s0">const </span><span class="s1">t = performance.now() / </span><span class="s4">1000</span><span class="s1">;</span>
                    <span class="s0">const </span><span class="s1">s = Math.trunc(t);</span>
                    <span class="s0">const </span><span class="s1">ms = Math.floor((t - s) * </span><span class="s4">1000</span><span class="s1">);</span>
                    <span class="s0">const </span><span class="s1">result = BigInt(s) * BigInt(</span><span class="s4">1000000000</span><span class="s1">) + BigInt(ms) * BigInt(</span><span class="s4">1000000</span><span class="s1">);</span>
                    <span class="s1">view.setBigUint64(time, result, </span><span class="s0">true</span><span class="s1">);</span>
                    <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s0">default</span><span class="s1">: </span><span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.fd_advise = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'fd_advise'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">(_fd, _offset, _len, _advice) {</span>
            <span class="s0">return </span><span class="s4">52 </span><span class="s3">/* WasiErrno.ENOSYS */</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.fd_fdstat_get = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'fd_fdstat_get'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">(fd, fdstat) {</span>
            <span class="s1">fdstat = Number(fdstat);</span>
            <span class="s0">if </span><span class="s1">(fdstat === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, BigInt(</span><span class="s4">0</span><span class="s1">), BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s0">const </span><span class="s1">{ view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">view.setUint16(fdstat, fileDescriptor.type, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s1">view.setUint16(fdstat + </span><span class="s4">2</span><span class="s1">, </span><span class="s4">0</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s1">view.setBigUint64(fdstat + </span><span class="s4">8</span><span class="s1">, fileDescriptor.rightsBase, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s1">view.setBigUint64(fdstat + </span><span class="s4">16</span><span class="s1">, fileDescriptor.rightsInheriting, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.fd_fdstat_set_flags = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'fd_fdstat_set_flags'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">(_fd, _flags) {</span>
            <span class="s0">return </span><span class="s4">52 </span><span class="s3">/* WasiErrno.ENOSYS */</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.fd_fdstat_set_rights = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'fd_fdstat_set_rights'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">(fd, rightsBase, rightsInheriting) {</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, BigInt(</span><span class="s4">0</span><span class="s1">), BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s0">if </span><span class="s1">((rightsBase | fileDescriptor.rightsBase) &gt; fileDescriptor.rightsBase) {</span>
                <span class="s0">return </span><span class="s4">76 </span><span class="s3">/* WasiErrno.ENOTCAPABLE */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">((rightsInheriting | fileDescriptor.rightsInheriting) &gt;</span>
                <span class="s1">fileDescriptor.rightsInheriting) {</span>
                <span class="s0">return </span><span class="s4">76 </span><span class="s3">/* WasiErrno.ENOTCAPABLE */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">fileDescriptor.rightsBase = rightsBase;</span>
            <span class="s1">fileDescriptor.rightsInheriting = rightsInheriting;</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.fd_prestat_get = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'fd_prestat_get'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">(fd, prestat) {</span>
            <span class="s1">prestat = Number(prestat);</span>
            <span class="s0">if </span><span class="s1">(prestat === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">let </span><span class="s1">fileDescriptor;</span>
            <span class="s0">try </span><span class="s1">{</span>
                <span class="s1">fileDescriptor = wasi.fds.get(fd, BigInt(</span><span class="s4">0</span><span class="s1">), BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s0">catch </span><span class="s1">(err) {</span>
                <span class="s0">if </span><span class="s1">(err </span><span class="s0">instanceof </span><span class="s1">WasiError)</span>
                    <span class="s0">return </span><span class="s1">err.errno;</span>
                <span class="s0">throw </span><span class="s1">err;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">(fileDescriptor.preopen !== </span><span class="s4">1</span><span class="s1">)</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s0">const </span><span class="s1">{ view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s3">// preopen type is dir(0)</span>
            <span class="s1">view.setUint32(prestat, </span><span class="s4">0</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s1">view.setUint32(prestat + </span><span class="s4">4</span><span class="s1">, encoder.encode(fileDescriptor.path).length, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.fd_prestat_dir_name = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'fd_prestat_dir_name'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">(fd, path, path_len) {</span>
            <span class="s1">path = Number(path);</span>
            <span class="s1">path_len = Number(path_len);</span>
            <span class="s0">if </span><span class="s1">(path === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, BigInt(</span><span class="s4">0</span><span class="s1">), BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s0">if </span><span class="s1">(fileDescriptor.preopen !== </span><span class="s4">1</span><span class="s1">)</span>
                <span class="s0">return </span><span class="s4">8 </span><span class="s3">/* WasiErrno.EBADF */</span><span class="s1">;</span>
            <span class="s0">const </span><span class="s1">buffer = encoder.encode(fileDescriptor.path);</span>
            <span class="s0">const </span><span class="s1">size = buffer.length;</span>
            <span class="s0">if </span><span class="s1">(size &gt; path_len)</span>
                <span class="s0">return </span><span class="s4">42 </span><span class="s3">/* WasiErrno.ENOBUFS */</span><span class="s1">;</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8 } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">HEAPU8.set(buffer, path);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.fd_seek = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'fd_seek'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">(fd, offset, whence, newOffset) {</span>
            <span class="s1">newOffset = Number(newOffset);</span>
            <span class="s0">if </span><span class="s1">(newOffset === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">(fd === </span><span class="s4">0 </span><span class="s1">|| fd === </span><span class="s4">1 </span><span class="s1">|| fd === </span><span class="s4">2</span><span class="s1">)</span>
                <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_SEEK, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s0">const </span><span class="s1">r = fileDescriptor.seek(offset, whence);</span>
            <span class="s0">const </span><span class="s1">{ view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">view.setBigUint64(newOffset, r, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.fd_tell = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'fd_tell'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">(fd, offset) {</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_TELL, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s0">const </span><span class="s1">pos = BigInt(fileDescriptor.pos);</span>
            <span class="s0">const </span><span class="s1">{ view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">view.setBigUint64(Number(offset), pos, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.poll_oneoff = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'poll_oneoff'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">(in_ptr, out_ptr, nsubscriptions, nevents) {</span>
            <span class="s1">in_ptr = Number(in_ptr);</span>
            <span class="s1">out_ptr = Number(out_ptr);</span>
            <span class="s1">nevents = Number(nevents);</span>
            <span class="s1">nsubscriptions = Number(nsubscriptions);</span>
            <span class="s1">nsubscriptions = nsubscriptions &gt;&gt;&gt; </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s0">if </span><span class="s1">(in_ptr === </span><span class="s4">0 </span><span class="s1">|| out_ptr === </span><span class="s4">0 </span><span class="s1">|| nsubscriptions === </span><span class="s4">0 </span><span class="s1">|| nevents === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">view.setUint32(nevents, </span><span class="s4">0</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s0">let </span><span class="s1">timer_userdata = BigInt(</span><span class="s4">0</span><span class="s1">);</span>
            <span class="s0">let </span><span class="s1">cur_timeout = BigInt(</span><span class="s4">0</span><span class="s1">);</span>
            <span class="s0">let </span><span class="s1">has_timeout = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s0">let </span><span class="s1">min_timeout = BigInt(</span><span class="s4">0</span><span class="s1">);</span>
            <span class="s0">let </span><span class="s1">sub;</span>
            <span class="s0">const </span><span class="s1">subscriptions = Array(nsubscriptions);</span>
            <span class="s0">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s1">; i &lt; nsubscriptions; i++) {</span>
                <span class="s1">sub = in_ptr + i * </span><span class="s4">48</span><span class="s1">;</span>
                <span class="s0">const </span><span class="s1">userdata = view.getBigUint64(sub, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">type = view.getUint8(sub + </span><span class="s4">8</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">clockIdOrFd = view.getUint32(sub + </span><span class="s4">16</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">timeout = view.getBigUint64(sub + </span><span class="s4">24</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">precision = view.getBigUint64(sub + </span><span class="s4">32</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">flags = view.getUint16(sub + </span><span class="s4">40</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s1">subscriptions[i] = {</span>
                    <span class="s1">userdata,</span>
                    <span class="s1">type,</span>
                    <span class="s1">u: {</span>
                        <span class="s1">clock: {</span>
                            <span class="s1">clock_id: clockIdOrFd,</span>
                            <span class="s1">timeout,</span>
                            <span class="s1">precision,</span>
                            <span class="s1">flags</span>
                        <span class="s1">},</span>
                        <span class="s1">fd_readwrite: {</span>
                            <span class="s1">fd: clockIdOrFd</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">fdevents = [];</span>
            <span class="s0">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s1">; i &lt; nsubscriptions; i++) {</span>
                <span class="s1">sub = subscriptions[i];</span>
                <span class="s0">switch </span><span class="s1">(sub.type) {</span>
                    <span class="s0">case </span><span class="s4">0 </span><span class="s3">/* WasiEventType.CLOCK */</span><span class="s1">: {</span>
                        <span class="s0">if </span><span class="s1">(sub.u.clock.flags === </span><span class="s4">1 </span><span class="s3">/* WasiSubclockflags.ABSTIME */</span><span class="s1">) {</span>
                            <span class="s3">/* Convert absolute time to relative delay. */</span>
                            <span class="s0">const </span><span class="s1">now = BigInt(Date.now()) * BigInt(</span><span class="s4">1000000</span><span class="s1">);</span>
                            <span class="s1">cur_timeout = sub.u.clock.timeout - now;</span>
                        <span class="s1">}</span>
                        <span class="s0">else </span><span class="s1">{</span>
                            <span class="s1">cur_timeout = sub.u.clock.timeout;</span>
                        <span class="s1">}</span>
                        <span class="s0">if </span><span class="s1">(has_timeout === </span><span class="s4">0 </span><span class="s1">|| cur_timeout &lt; min_timeout) {</span>
                            <span class="s1">min_timeout = cur_timeout;</span>
                            <span class="s1">timer_userdata = sub.userdata;</span>
                            <span class="s1">has_timeout = </span><span class="s4">1</span><span class="s1">;</span>
                        <span class="s1">}</span>
                        <span class="s0">break</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s0">case </span><span class="s4">1 </span><span class="s3">/* WasiEventType.FD_READ */</span><span class="s1">:</span>
                    <span class="s0">case </span><span class="s4">2 </span><span class="s3">/* WasiEventType.FD_WRITE */</span><span class="s1">:</span>
                        <span class="s1">fdevents.push(sub);</span>
                        <span class="s0">break</span><span class="s1">;</span>
                    <span class="s0">default</span><span class="s1">: </span><span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">(fdevents.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s0">for </span><span class="s1">(i = </span><span class="s4">0</span><span class="s1">; i &lt; fdevents.length; i++) {</span>
                    <span class="s0">const </span><span class="s1">fdevent = fdevents[i];</span>
                    <span class="s0">const </span><span class="s1">event = out_ptr + </span><span class="s4">32 </span><span class="s1">* i;</span>
                    <span class="s1">view.setBigUint64(event, fdevent.userdata, </span><span class="s0">true</span><span class="s1">);</span>
                    <span class="s1">view.setUint32(event + </span><span class="s4">8</span><span class="s1">, </span><span class="s4">52 </span><span class="s3">/* WasiErrno.ENOSYS */</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                    <span class="s1">view.setUint32(event + </span><span class="s4">12</span><span class="s1">, fdevent.type, </span><span class="s0">true</span><span class="s1">);</span>
                    <span class="s1">view.setBigUint64(event + </span><span class="s4">16</span><span class="s1">, BigInt(</span><span class="s4">0</span><span class="s1">), </span><span class="s0">true</span><span class="s1">);</span>
                    <span class="s1">view.setUint16(event + </span><span class="s4">24</span><span class="s1">, </span><span class="s4">0</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                    <span class="s1">view.setUint32(nevents, </span><span class="s4">1</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s1">view.setUint32(nevents, fdevents.length, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">(has_timeout) {</span>
                <span class="s0">const </span><span class="s1">delay = Number(min_timeout / BigInt(</span><span class="s4">1000000</span><span class="s1">));</span>
                <span class="s3">// if (isMainThread || typeof SharedArrayBuffer !== 'function') {</span>
                <span class="s1">sleepBreakIf(delay, () =&gt; </span><span class="s0">false</span><span class="s1">);</span>
                <span class="s3">// } else {</span>
                <span class="s3">//   const buf = new SharedArrayBuffer(4)</span>
                <span class="s3">//   const arr = new Int32Array(buf)</span>
                <span class="s3">//   postMsg({</span>
                <span class="s3">//     __tybys_wasm_util_wasi__: {</span>
                <span class="s3">//       type: 'set-timeout',</span>
                <span class="s3">//       payload: {</span>
                <span class="s3">//         buffer: buf,</span>
                <span class="s3">//         delay</span>
                <span class="s3">//       }</span>
                <span class="s3">//     }</span>
                <span class="s3">//   })</span>
                <span class="s3">//   Atomics.wait(arr, 0, 0)</span>
                <span class="s3">// }</span>
                <span class="s0">const </span><span class="s1">event = out_ptr;</span>
                <span class="s1">view.setBigUint64(event, timer_userdata, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s1">view.setUint32(event + </span><span class="s4">8</span><span class="s1">, </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s1">view.setUint32(event + </span><span class="s4">12</span><span class="s1">, </span><span class="s4">0 </span><span class="s3">/* WasiEventType.CLOCK */</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s1">view.setUint32(nevents, </span><span class="s4">1</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.proc_exit = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'proc_exit'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">(rval) {</span>
            <span class="s0">if </span><span class="s1">((</span><span class="s0">typeof </span><span class="s1">process === </span><span class="s2">'object'</span><span class="s1">) &amp;&amp; (process !== </span><span class="s0">null</span><span class="s1">) &amp;&amp; (</span><span class="s0">typeof </span><span class="s1">process.exit === </span><span class="s2">'function'</span><span class="s1">)) {</span>
                <span class="s1">process.exit(rval);</span>
            <span class="s1">}</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.proc_raise = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'proc_raise'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">(_sig) {</span>
            <span class="s0">return </span><span class="s4">52 </span><span class="s3">/* WasiErrno.ENOSYS */</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.sched_yield = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'sched_yield'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">() {</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.random_get = </span><span class="s0">typeof </span><span class="s1">crypto !== </span><span class="s2">'undefined' </span><span class="s1">&amp;&amp; </span><span class="s0">typeof </span><span class="s1">crypto.getRandomValues === </span><span class="s2">'function'</span>
            <span class="s1">? syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'random_get'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">(buf, buf_len) {</span>
                <span class="s1">buf = Number(buf);</span>
                <span class="s0">if </span><span class="s1">(buf === </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">buf_len = Number(buf_len);</span>
                <span class="s0">const </span><span class="s1">{ HEAPU8, view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
                <span class="s0">if </span><span class="s1">((</span><span class="s0">typeof </span><span class="s1">SharedArrayBuffer === </span><span class="s2">'function' </span><span class="s1">&amp;&amp; HEAPU8.buffer </span><span class="s0">instanceof </span><span class="s1">SharedArrayBuffer) ||</span>
                    <span class="s1">(Object.prototype.toString.call(HEAPU8.buffer) === </span><span class="s2">'[object SharedArrayBuffer]'</span><span class="s1">)) {</span>
                    <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = buf; i &lt; buf + buf_len; ++i) {</span>
                        <span class="s1">view.setUint8(i, Math.floor(Math.random() * </span><span class="s4">256</span><span class="s1">));</span>
                    <span class="s1">}</span>
                    <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s0">let </span><span class="s1">pos;</span>
                <span class="s0">const </span><span class="s1">stride = </span><span class="s4">65536</span><span class="s1">;</span>
                <span class="s0">for </span><span class="s1">(pos = </span><span class="s4">0</span><span class="s1">; pos + stride &lt; buf_len; pos += stride) {</span>
                    <span class="s1">crypto.getRandomValues(HEAPU8.subarray(buf + pos, buf + pos + stride));</span>
                <span class="s1">}</span>
                <span class="s1">crypto.getRandomValues(HEAPU8.subarray(buf + pos, buf + buf_len));</span>
                <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
            <span class="s1">})</span>
            <span class="s1">: syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'random_get'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">(buf, buf_len) {</span>
                <span class="s1">buf = Number(buf);</span>
                <span class="s0">if </span><span class="s1">(buf === </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">buf_len = Number(buf_len);</span>
                <span class="s0">const </span><span class="s1">{ view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
                <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = buf; i &lt; buf + buf_len; ++i) {</span>
                    <span class="s1">view.setUint8(i, Math.floor(Math.random() * </span><span class="s4">256</span><span class="s1">));</span>
                <span class="s1">}</span>
                <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
            <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.sock_recv = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'sock_recv'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">() {</span>
            <span class="s0">return </span><span class="s4">58 </span><span class="s3">/* WasiErrno.ENOTSUP */</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.sock_send = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'sock_send'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">() {</span>
            <span class="s0">return </span><span class="s4">58 </span><span class="s3">/* WasiErrno.ENOTSUP */</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.sock_shutdown = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'sock_shutdown'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">() {</span>
            <span class="s0">return </span><span class="s4">58 </span><span class="s3">/* WasiErrno.ENOTSUP */</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s0">this</span><span class="s1">.sock_accept = syscallWrap(</span><span class="s0">this</span><span class="s1">, </span><span class="s2">'sock_accept'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">() {</span>
            <span class="s0">return </span><span class="s4">58 </span><span class="s3">/* WasiErrno.ENOTSUP */</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s1">_wasi.set(</span><span class="s0">this</span><span class="s1">, {</span>
            <span class="s1">fds,</span>
            <span class="s1">args,</span>
            <span class="s1">env</span>
        <span class="s1">});</span>
        <span class="s0">if </span><span class="s1">(fs)</span>
            <span class="s1">_fs.set(</span><span class="s0">this</span><span class="s1">, fs);</span>
        <span class="s3">// eslint-disable-next-line @typescript-eslint/no-this-alias</span>
        <span class="s0">const </span><span class="s1">_this = </span><span class="s0">this</span><span class="s1">;</span>
        <span class="s0">function </span><span class="s1">defineImport(name, syncVersion, asyncVersion, parameterType, returnType) {</span>
            <span class="s0">if </span><span class="s1">(asyncFs) {</span>
                <span class="s0">if </span><span class="s1">(asyncify) {</span>
                    <span class="s1">_this[name] = asyncify.wrapImportFunction(syscallWrap(_this, name, asyncVersion));</span>
                <span class="s1">}</span>
                <span class="s0">else </span><span class="s1">{</span>
                    <span class="s1">_this[name] = wrapAsyncImport(syscallWrap(_this, name, asyncVersion), parameterType, returnType);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">_this[name] = syscallWrap(_this, name, syncVersion);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">defineImport(</span><span class="s2">'fd_allocate'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">fd_allocate(fd, offset, len) {</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_ALLOCATE, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s0">const </span><span class="s1">stat = fs.fstatSync(fileDescriptor.fd, { bigint: </span><span class="s0">true </span><span class="s1">});</span>
            <span class="s0">if </span><span class="s1">(stat.size &lt; offset + len) {</span>
                <span class="s1">fs.ftruncateSync(fileDescriptor.fd, Number(offset + len));</span>
            <span class="s1">}</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">fd_allocate(fd, offset, len) {</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_ALLOCATE, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s0">const </span><span class="s1">h = fileDescriptor.fd;</span>
            <span class="s0">const </span><span class="s1">stat = </span><span class="s0">await </span><span class="s1">h.stat({ bigint: </span><span class="s0">true </span><span class="s1">});</span>
            <span class="s0">if </span><span class="s1">(stat.size &lt; offset + len) {</span>
                <span class="s0">await </span><span class="s1">h.truncate(Number(offset + len));</span>
            <span class="s1">}</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i64'</span><span class="s1">, </span><span class="s2">'f64'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s1">defineImport(</span><span class="s2">'fd_close'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">fd_close(fd) {</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, BigInt(</span><span class="s4">0</span><span class="s1">), BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">fs.closeSync(fileDescriptor.fd);</span>
            <span class="s1">wasi.fds.remove(fd);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">fd_close(fd) {</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, BigInt(</span><span class="s4">0</span><span class="s1">), BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s0">await </span><span class="s1">fileDescriptor.fd.close();</span>
            <span class="s1">wasi.fds.remove(fd);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s1">defineImport(</span><span class="s2">'fd_datasync'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">fd_datasync(fd) {</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_DATASYNC, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">fs.fdatasyncSync(fileDescriptor.fd);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">fd_datasync(fd) {</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_DATASYNC, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s0">await </span><span class="s1">fileDescriptor.fd.datasync();</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s1">defineImport(</span><span class="s2">'fd_filestat_get'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">fd_filestat_get(fd, buf) {</span>
            <span class="s1">buf = Number(buf);</span>
            <span class="s0">if </span><span class="s1">(buf === </span><span class="s4">0</span><span class="s1">)</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_FILESTAT_GET, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">stat = fs.fstatSync(fileDescriptor.fd, { bigint: </span><span class="s0">true </span><span class="s1">});</span>
            <span class="s0">const </span><span class="s1">{ view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">toFileStat(view, buf, stat);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">fd_filestat_get(fd, buf) {</span>
            <span class="s1">buf = Number(buf);</span>
            <span class="s0">if </span><span class="s1">(buf === </span><span class="s4">0</span><span class="s1">)</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_FILESTAT_GET, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s0">const </span><span class="s1">h = fileDescriptor.fd;</span>
            <span class="s0">const </span><span class="s1">stat = </span><span class="s0">await </span><span class="s1">h.stat({ bigint: </span><span class="s0">true </span><span class="s1">});</span>
            <span class="s0">const </span><span class="s1">{ view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">toFileStat(view, buf, stat);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s1">defineImport(</span><span class="s2">'fd_filestat_set_size'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">fd_filestat_set_size(fd, size) {</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_FILESTAT_SET_SIZE, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">fs.ftruncateSync(fileDescriptor.fd, Number(size));</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">fd_filestat_set_size(fd, size) {</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_FILESTAT_SET_SIZE, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s0">const </span><span class="s1">h = fileDescriptor.fd;</span>
            <span class="s0">await </span><span class="s1">h.truncate(Number(size));</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i64'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s0">function </span><span class="s1">fdFilestatGetTimes(fd, atim, mtim, flags) {</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_FILESTAT_SET_TIMES, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s0">if </span><span class="s1">((flags &amp; </span><span class="s4">2 </span><span class="s3">/* WasiFstFlag.SET_ATIM_NOW */</span><span class="s1">) === </span><span class="s4">2 </span><span class="s3">/* WasiFstFlag.SET_ATIM_NOW */</span><span class="s1">) {</span>
                <span class="s1">atim = BigInt(Date.now() * </span><span class="s4">1000000</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">((flags &amp; </span><span class="s4">8 </span><span class="s3">/* WasiFstFlag.SET_MTIM_NOW */</span><span class="s1">) === </span><span class="s4">8 </span><span class="s3">/* WasiFstFlag.SET_MTIM_NOW */</span><span class="s1">) {</span>
                <span class="s1">mtim = BigInt(Date.now() * </span><span class="s4">1000000</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s0">return </span><span class="s1">{ fileDescriptor, atim, mtim };</span>
        <span class="s1">}</span>
        <span class="s1">defineImport(</span><span class="s2">'fd_filestat_set_times'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">fd_filestat_set_times(fd, atim, mtim, flags) {</span>
            <span class="s0">if </span><span class="s1">(validateFstFlagsOrReturn(flags)) {</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ fileDescriptor, atim: atimRes, mtim: mtimRes } = fdFilestatGetTimes.call(</span><span class="s0">this</span><span class="s1">, fd, atim, mtim, flags);</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">fs.futimesSync(fileDescriptor.fd, Number(atimRes), Number(mtimRes));</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">fd_filestat_set_times(fd, atim, mtim, flags) {</span>
            <span class="s0">if </span><span class="s1">(validateFstFlagsOrReturn(flags)) {</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ fileDescriptor, atim: atimRes, mtim: mtimRes } = fdFilestatGetTimes.call(</span><span class="s0">this</span><span class="s1">, fd, atim, mtim, flags);</span>
            <span class="s0">const </span><span class="s1">h = fileDescriptor.fd;</span>
            <span class="s0">await </span><span class="s1">h.utimes(Number(atimRes), Number(mtimRes));</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i64'</span><span class="s1">, </span><span class="s2">'i64'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s1">defineImport(</span><span class="s2">'fd_pread'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">fd_pread(fd, iovs, iovslen, offset, size) {</span>
            <span class="s1">iovs = Number(iovs);</span>
            <span class="s1">size = Number(size);</span>
            <span class="s0">if </span><span class="s1">((iovs === </span><span class="s4">0 </span><span class="s1">&amp;&amp; iovslen) || size === </span><span class="s4">0 </span><span class="s1">|| offset &gt; INT64_MAX) {</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8, view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_READ | WasiRights.FD_SEEK, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s0">if </span><span class="s1">(!iovslen) {</span>
                <span class="s1">view.setUint32(size, </span><span class="s4">0</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">let </span><span class="s1">totalSize = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s0">const </span><span class="s1">ioVecs = Array.from({ length: Number(iovslen) }, (_, i) =&gt; {</span>
                <span class="s0">const </span><span class="s1">offset = iovs + (i * </span><span class="s4">8</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">buf = view.getInt32(offset, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">bufLen = view.getUint32(offset + </span><span class="s4">4</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s1">totalSize += bufLen;</span>
                <span class="s0">return </span><span class="s1">HEAPU8.subarray(buf, buf + bufLen);</span>
            <span class="s1">});</span>
            <span class="s0">let </span><span class="s1">nread = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s0">const </span><span class="s1">buffer = (() =&gt; {</span>
                <span class="s0">try </span><span class="s1">{</span>
                    <span class="s0">return new </span><span class="s1">Uint8Array(</span><span class="s0">new </span><span class="s1">SharedArrayBuffer(totalSize));</span>
                <span class="s1">}</span>
                <span class="s0">catch </span><span class="s1">(_) {</span>
                    <span class="s0">return new </span><span class="s1">Uint8Array(totalSize);</span>
                <span class="s1">}</span>
            <span class="s1">})();</span>
            <span class="s1">buffer._isBuffer = </span><span class="s0">true</span><span class="s1">;</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">bytesRead = fs.readSync(fileDescriptor.fd, buffer, </span><span class="s4">0</span><span class="s1">, buffer.length, Number(offset));</span>
            <span class="s1">nread = buffer ? copyMemory(ioVecs, buffer.subarray(</span><span class="s4">0</span><span class="s1">, bytesRead)) : </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s1">view.setUint32(size, nread, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">(fd, iovs, iovslen, offset, size) {</span>
            <span class="s1">iovs = Number(iovs);</span>
            <span class="s1">size = Number(size);</span>
            <span class="s0">if </span><span class="s1">((iovs === </span><span class="s4">0 </span><span class="s1">&amp;&amp; iovslen) || size === </span><span class="s4">0 </span><span class="s1">|| offset &gt; INT64_MAX) {</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8, view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_READ | WasiRights.FD_SEEK, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s0">if </span><span class="s1">(!iovslen) {</span>
                <span class="s1">view.setUint32(size, </span><span class="s4">0</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">let </span><span class="s1">totalSize = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s0">const </span><span class="s1">ioVecs = Array.from({ length: Number(iovslen) }, (_, i) =&gt; {</span>
                <span class="s0">const </span><span class="s1">offset = iovs + (i * </span><span class="s4">8</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">buf = view.getInt32(offset, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">bufLen = view.getUint32(offset + </span><span class="s4">4</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s1">totalSize += bufLen;</span>
                <span class="s0">return </span><span class="s1">HEAPU8.subarray(buf, buf + bufLen);</span>
            <span class="s1">});</span>
            <span class="s0">let </span><span class="s1">nread = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s0">const </span><span class="s1">buffer = </span><span class="s0">new </span><span class="s1">Uint8Array(totalSize);</span>
            <span class="s1">buffer._isBuffer = </span><span class="s0">true</span><span class="s1">;</span>
            <span class="s0">const </span><span class="s1">{ bytesRead } = </span><span class="s0">await </span><span class="s1">fileDescriptor.fd.read(buffer, </span><span class="s4">0</span><span class="s1">, buffer.length, Number(offset));</span>
            <span class="s1">nread = buffer ? copyMemory(ioVecs, buffer.subarray(</span><span class="s4">0</span><span class="s1">, bytesRead)) : </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s1">view.setUint32(size, nread, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i64'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s1">defineImport(</span><span class="s2">'fd_pwrite'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">fd_pwrite(fd, iovs, iovslen, offset, size) {</span>
            <span class="s1">iovs = Number(iovs);</span>
            <span class="s1">size = Number(size);</span>
            <span class="s0">if </span><span class="s1">((iovs === </span><span class="s4">0 </span><span class="s1">&amp;&amp; iovslen) || size === </span><span class="s4">0 </span><span class="s1">|| offset &gt; INT64_MAX) {</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8, view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_WRITE | WasiRights.FD_SEEK, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s0">if </span><span class="s1">(!iovslen) {</span>
                <span class="s1">view.setUint32(size, </span><span class="s4">0</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">buffer = concatBuffer(Array.from({ length: Number(iovslen) }, (_, i) =&gt; {</span>
                <span class="s0">const </span><span class="s1">offset = iovs + (i * </span><span class="s4">8</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">buf = view.getInt32(offset, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">bufLen = view.getUint32(offset + </span><span class="s4">4</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">return </span><span class="s1">HEAPU8.subarray(buf, buf + bufLen);</span>
            <span class="s1">}));</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">nwritten = fs.writeSync(fileDescriptor.fd, buffer, </span><span class="s4">0</span><span class="s1">, buffer.length, Number(offset));</span>
            <span class="s1">view.setUint32(size, nwritten, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">fd_pwrite(fd, iovs, iovslen, offset, size) {</span>
            <span class="s1">iovs = Number(iovs);</span>
            <span class="s1">size = Number(size);</span>
            <span class="s0">if </span><span class="s1">((iovs === </span><span class="s4">0 </span><span class="s1">&amp;&amp; iovslen) || size === </span><span class="s4">0 </span><span class="s1">|| offset &gt; INT64_MAX) {</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8, view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_WRITE | WasiRights.FD_SEEK, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s0">if </span><span class="s1">(!iovslen) {</span>
                <span class="s1">view.setUint32(size, </span><span class="s4">0</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">buffer = concatBuffer(Array.from({ length: Number(iovslen) }, (_, i) =&gt; {</span>
                <span class="s0">const </span><span class="s1">offset = iovs + (i * </span><span class="s4">8</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">buf = view.getInt32(offset, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">bufLen = view.getUint32(offset + </span><span class="s4">4</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">return </span><span class="s1">HEAPU8.subarray(buf, buf + bufLen);</span>
            <span class="s1">}));</span>
            <span class="s0">const </span><span class="s1">{ bytesWritten } = </span><span class="s0">await </span><span class="s1">fileDescriptor.fd.write(buffer, </span><span class="s4">0</span><span class="s1">, buffer.length, Number(offset));</span>
            <span class="s1">view.setUint32(size, bytesWritten, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i64'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s1">defineImport(</span><span class="s2">'fd_read'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">fd_read(fd, iovs, iovslen, size) {</span>
            <span class="s1">iovs = Number(iovs);</span>
            <span class="s1">size = Number(size);</span>
            <span class="s0">if </span><span class="s1">((iovs === </span><span class="s4">0 </span><span class="s1">&amp;&amp; iovslen) || size === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8, view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_READ, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s0">if </span><span class="s1">(!iovslen) {</span>
                <span class="s1">view.setUint32(size, </span><span class="s4">0</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">let </span><span class="s1">totalSize = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s0">const </span><span class="s1">ioVecs = Array.from({ length: Number(iovslen) }, (_, i) =&gt; {</span>
                <span class="s0">const </span><span class="s1">offset = iovs + (i * </span><span class="s4">8</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">buf = view.getInt32(offset, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">bufLen = view.getUint32(offset + </span><span class="s4">4</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s1">totalSize += bufLen;</span>
                <span class="s0">return </span><span class="s1">HEAPU8.subarray(buf, buf + bufLen);</span>
            <span class="s1">});</span>
            <span class="s0">let </span><span class="s1">buffer;</span>
            <span class="s0">let </span><span class="s1">nread = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s0">if </span><span class="s1">(fd === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">window === </span><span class="s2">'undefined' </span><span class="s1">|| </span><span class="s0">typeof </span><span class="s1">window.prompt !== </span><span class="s2">'function'</span><span class="s1">) {</span>
                    <span class="s0">return </span><span class="s4">58 </span><span class="s3">/* WasiErrno.ENOTSUP */</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">buffer = readStdin();</span>
                <span class="s1">nread = buffer ? copyMemory(ioVecs, buffer) : </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">buffer = (() =&gt; {</span>
                    <span class="s0">try </span><span class="s1">{</span>
                        <span class="s0">return new </span><span class="s1">Uint8Array(</span><span class="s0">new </span><span class="s1">SharedArrayBuffer(totalSize));</span>
                    <span class="s1">}</span>
                    <span class="s0">catch </span><span class="s1">(_) {</span>
                        <span class="s0">return new </span><span class="s1">Uint8Array(totalSize);</span>
                    <span class="s1">}</span>
                <span class="s1">})();</span>
                <span class="s1">buffer._isBuffer = </span><span class="s0">true</span><span class="s1">;</span>
                <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">bytesRead = fs.readSync(fileDescriptor.fd, buffer, </span><span class="s4">0</span><span class="s1">, buffer.length, Number(fileDescriptor.pos));</span>
                <span class="s1">nread = buffer ? copyMemory(ioVecs, buffer.subarray(</span><span class="s4">0</span><span class="s1">, bytesRead)) : </span><span class="s4">0</span><span class="s1">;</span>
                <span class="s1">fileDescriptor.pos += BigInt(nread);</span>
            <span class="s1">}</span>
            <span class="s1">view.setUint32(size, nread, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">fd_read(fd, iovs, iovslen, size) {</span>
            <span class="s1">iovs = Number(iovs);</span>
            <span class="s1">size = Number(size);</span>
            <span class="s0">if </span><span class="s1">((iovs === </span><span class="s4">0 </span><span class="s1">&amp;&amp; iovslen) || size === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8, view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_READ, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s0">if </span><span class="s1">(!iovslen) {</span>
                <span class="s1">view.setUint32(size, </span><span class="s4">0</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">let </span><span class="s1">totalSize = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s0">const </span><span class="s1">ioVecs = Array.from({ length: Number(iovslen) }, (_, i) =&gt; {</span>
                <span class="s0">const </span><span class="s1">offset = iovs + (i * </span><span class="s4">8</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">buf = view.getInt32(offset, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">bufLen = view.getUint32(offset + </span><span class="s4">4</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s1">totalSize += bufLen;</span>
                <span class="s0">return </span><span class="s1">HEAPU8.subarray(buf, buf + bufLen);</span>
            <span class="s1">});</span>
            <span class="s0">let </span><span class="s1">buffer;</span>
            <span class="s0">let </span><span class="s1">nread = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s0">if </span><span class="s1">(fd === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">window === </span><span class="s2">'undefined' </span><span class="s1">|| </span><span class="s0">typeof </span><span class="s1">window.prompt !== </span><span class="s2">'function'</span><span class="s1">) {</span>
                    <span class="s0">return </span><span class="s4">58 </span><span class="s3">/* WasiErrno.ENOTSUP */</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">buffer = readStdin();</span>
                <span class="s1">nread = buffer ? copyMemory(ioVecs, buffer) : </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">buffer = </span><span class="s0">new </span><span class="s1">Uint8Array(totalSize);</span>
                <span class="s1">buffer._isBuffer = </span><span class="s0">true</span><span class="s1">;</span>
                <span class="s0">const </span><span class="s1">{ bytesRead } = </span><span class="s0">await </span><span class="s1">fileDescriptor.fd.read(buffer, </span><span class="s4">0</span><span class="s1">, buffer.length, Number(fileDescriptor.pos));</span>
                <span class="s1">nread = buffer ? copyMemory(ioVecs, buffer.subarray(</span><span class="s4">0</span><span class="s1">, bytesRead)) : </span><span class="s4">0</span><span class="s1">;</span>
                <span class="s1">fileDescriptor.pos += BigInt(nread);</span>
            <span class="s1">}</span>
            <span class="s1">view.setUint32(size, nread, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s1">defineImport(</span><span class="s2">'fd_readdir'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">fd_readdir(fd, buf, buf_len, cookie, bufused) {</span>
            <span class="s1">buf = Number(buf);</span>
            <span class="s1">buf_len = Number(buf_len);</span>
            <span class="s1">bufused = Number(bufused);</span>
            <span class="s0">if </span><span class="s1">(buf === </span><span class="s4">0 </span><span class="s1">|| bufused === </span><span class="s4">0</span><span class="s1">)</span>
                <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_READDIR, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">entries = fs.readdirSync(fileDescriptor.realPath, { withFileTypes: </span><span class="s0">true </span><span class="s1">});</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8, view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">let </span><span class="s1">bufferUsed = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = Number(cookie); i &lt; entries.length; i++) {</span>
                <span class="s0">const </span><span class="s1">nameData = encoder.encode(entries[i].name);</span>
                <span class="s0">const </span><span class="s1">entryInfo = fs.statSync(resolve(fileDescriptor.realPath, entries[i].name), { bigint: </span><span class="s0">true </span><span class="s1">});</span>
                <span class="s0">const </span><span class="s1">entryData = </span><span class="s0">new </span><span class="s1">Uint8Array(</span><span class="s4">24 </span><span class="s1">+ nameData.byteLength);</span>
                <span class="s0">const </span><span class="s1">entryView = </span><span class="s0">new </span><span class="s1">DataView(entryData.buffer);</span>
                <span class="s1">entryView.setBigUint64(</span><span class="s4">0</span><span class="s1">, BigInt(i + </span><span class="s4">1</span><span class="s1">), </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s1">entryView.setBigUint64(</span><span class="s4">8</span><span class="s1">, BigInt(entryInfo.ino ? entryInfo.ino : </span><span class="s4">0</span><span class="s1">), </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s1">entryView.setUint32(</span><span class="s4">16</span><span class="s1">, nameData.byteLength, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">let </span><span class="s1">type;</span>
                <span class="s0">if </span><span class="s1">(entries[i].isFile()) {</span>
                    <span class="s1">type = </span><span class="s4">4 </span><span class="s3">/* WasiFileType.REGULAR_FILE */</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s0">else if </span><span class="s1">(entries[i].isDirectory()) {</span>
                    <span class="s1">type = </span><span class="s4">3 </span><span class="s3">/* WasiFileType.DIRECTORY */</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s0">else if </span><span class="s1">(entries[i].isSymbolicLink()) {</span>
                    <span class="s1">type = </span><span class="s4">7 </span><span class="s3">/* WasiFileType.SYMBOLIC_LINK */</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s0">else if </span><span class="s1">(entries[i].isCharacterDevice()) {</span>
                    <span class="s1">type = </span><span class="s4">2 </span><span class="s3">/* WasiFileType.CHARACTER_DEVICE */</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s0">else if </span><span class="s1">(entries[i].isBlockDevice()) {</span>
                    <span class="s1">type = </span><span class="s4">1 </span><span class="s3">/* WasiFileType.BLOCK_DEVICE */</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s0">else if </span><span class="s1">(entries[i].isSocket()) {</span>
                    <span class="s1">type = </span><span class="s4">6 </span><span class="s3">/* WasiFileType.SOCKET_STREAM */</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s0">else </span><span class="s1">{</span>
                    <span class="s1">type = </span><span class="s4">0 </span><span class="s3">/* WasiFileType.UNKNOWN */</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">entryView.setUint8(</span><span class="s4">20</span><span class="s1">, type);</span>
                <span class="s1">entryData.set(nameData, </span><span class="s4">24</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">data = entryData.slice(</span><span class="s4">0</span><span class="s1">, Math.min(entryData.length, buf_len - bufferUsed));</span>
                <span class="s1">HEAPU8.set(data, buf + bufferUsed);</span>
                <span class="s1">bufferUsed += data.byteLength;</span>
            <span class="s1">}</span>
            <span class="s1">view.setUint32(bufused, bufferUsed, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">fd_readdir(fd, buf, buf_len, cookie, bufused) {</span>
            <span class="s1">buf = Number(buf);</span>
            <span class="s1">buf_len = Number(buf_len);</span>
            <span class="s1">bufused = Number(bufused);</span>
            <span class="s0">if </span><span class="s1">(buf === </span><span class="s4">0 </span><span class="s1">|| bufused === </span><span class="s4">0</span><span class="s1">)</span>
                <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_READDIR, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">entries = </span><span class="s0">await </span><span class="s1">fs.promises.readdir(fileDescriptor.realPath, { withFileTypes: </span><span class="s0">true </span><span class="s1">});</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8, view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">let </span><span class="s1">bufferUsed = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = Number(cookie); i &lt; entries.length; i++) {</span>
                <span class="s0">const </span><span class="s1">nameData = encoder.encode(entries[i].name);</span>
                <span class="s0">const </span><span class="s1">entryInfo = </span><span class="s0">await </span><span class="s1">fs.promises.stat(resolve(fileDescriptor.realPath, entries[i].name), { bigint: </span><span class="s0">true </span><span class="s1">});</span>
                <span class="s0">const </span><span class="s1">entryData = </span><span class="s0">new </span><span class="s1">Uint8Array(</span><span class="s4">24 </span><span class="s1">+ nameData.byteLength);</span>
                <span class="s0">const </span><span class="s1">entryView = </span><span class="s0">new </span><span class="s1">DataView(entryData.buffer);</span>
                <span class="s1">entryView.setBigUint64(</span><span class="s4">0</span><span class="s1">, BigInt(i + </span><span class="s4">1</span><span class="s1">), </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s1">entryView.setBigUint64(</span><span class="s4">8</span><span class="s1">, BigInt(entryInfo.ino ? entryInfo.ino : </span><span class="s4">0</span><span class="s1">), </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s1">entryView.setUint32(</span><span class="s4">16</span><span class="s1">, nameData.byteLength, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">let </span><span class="s1">type;</span>
                <span class="s0">if </span><span class="s1">(entries[i].isFile()) {</span>
                    <span class="s1">type = </span><span class="s4">4 </span><span class="s3">/* WasiFileType.REGULAR_FILE */</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s0">else if </span><span class="s1">(entries[i].isDirectory()) {</span>
                    <span class="s1">type = </span><span class="s4">3 </span><span class="s3">/* WasiFileType.DIRECTORY */</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s0">else if </span><span class="s1">(entries[i].isSymbolicLink()) {</span>
                    <span class="s1">type = </span><span class="s4">7 </span><span class="s3">/* WasiFileType.SYMBOLIC_LINK */</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s0">else if </span><span class="s1">(entries[i].isCharacterDevice()) {</span>
                    <span class="s1">type = </span><span class="s4">2 </span><span class="s3">/* WasiFileType.CHARACTER_DEVICE */</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s0">else if </span><span class="s1">(entries[i].isBlockDevice()) {</span>
                    <span class="s1">type = </span><span class="s4">1 </span><span class="s3">/* WasiFileType.BLOCK_DEVICE */</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s0">else if </span><span class="s1">(entries[i].isSocket()) {</span>
                    <span class="s1">type = </span><span class="s4">6 </span><span class="s3">/* WasiFileType.SOCKET_STREAM */</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s0">else </span><span class="s1">{</span>
                    <span class="s1">type = </span><span class="s4">0 </span><span class="s3">/* WasiFileType.UNKNOWN */</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">entryView.setUint8(</span><span class="s4">20</span><span class="s1">, type);</span>
                <span class="s1">entryData.set(nameData, </span><span class="s4">24</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">data = entryData.slice(</span><span class="s4">0</span><span class="s1">, Math.min(entryData.length, buf_len - bufferUsed));</span>
                <span class="s1">HEAPU8.set(data, buf + bufferUsed);</span>
                <span class="s1">bufferUsed += data.byteLength;</span>
            <span class="s1">}</span>
            <span class="s1">view.setUint32(bufused, bufferUsed, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i64'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s1">defineImport(</span><span class="s2">'fd_renumber'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">fd_renumber(from, to) {</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">wasi.fds.renumber(to, from);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">fd_renumber(from, to) {</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">await </span><span class="s1">wasi.fds.renumber(to, from);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s1">defineImport(</span><span class="s2">'fd_sync'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">fd_sync(fd) {</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_SYNC, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">fs.fsyncSync(fileDescriptor.fd);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">fd_sync(fd) {</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_SYNC, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s0">await </span><span class="s1">fileDescriptor.fd.sync();</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s1">defineImport(</span><span class="s2">'fd_write'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">fd_write(fd, iovs, iovslen, size) {</span>
            <span class="s1">iovs = Number(iovs);</span>
            <span class="s1">size = Number(size);</span>
            <span class="s0">if </span><span class="s1">((iovs === </span><span class="s4">0 </span><span class="s1">&amp;&amp; iovslen) || size === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8, view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_WRITE, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s0">if </span><span class="s1">(!iovslen) {</span>
                <span class="s1">view.setUint32(size, </span><span class="s4">0</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">buffer = concatBuffer(Array.from({ length: Number(iovslen) }, (_, i) =&gt; {</span>
                <span class="s0">const </span><span class="s1">offset = iovs + (i * </span><span class="s4">8</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">buf = view.getInt32(offset, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">bufLen = view.getUint32(offset + </span><span class="s4">4</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">return </span><span class="s1">HEAPU8.subarray(buf, buf + bufLen);</span>
            <span class="s1">}));</span>
            <span class="s0">let </span><span class="s1">nwritten;</span>
            <span class="s0">if </span><span class="s1">(fd === </span><span class="s4">1 </span><span class="s1">|| fd === </span><span class="s4">2</span><span class="s1">) {</span>
                <span class="s1">nwritten = fileDescriptor.write(buffer);</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
                <span class="s1">nwritten = fs.writeSync(fileDescriptor.fd, buffer, </span><span class="s4">0</span><span class="s1">, buffer.length, Number(fileDescriptor.pos));</span>
                <span class="s1">fileDescriptor.pos += BigInt(nwritten);</span>
            <span class="s1">}</span>
            <span class="s1">view.setUint32(size, nwritten, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">fd_write(fd, iovs, iovslen, size) {</span>
            <span class="s1">iovs = Number(iovs);</span>
            <span class="s1">size = Number(size);</span>
            <span class="s0">if </span><span class="s1">((iovs === </span><span class="s4">0 </span><span class="s1">&amp;&amp; iovslen) || size === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8, view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.FD_WRITE, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s0">if </span><span class="s1">(!iovslen) {</span>
                <span class="s1">view.setUint32(size, </span><span class="s4">0</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">buffer = concatBuffer(Array.from({ length: Number(iovslen) }, (_, i) =&gt; {</span>
                <span class="s0">const </span><span class="s1">offset = iovs + (i * </span><span class="s4">8</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">buf = view.getInt32(offset, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">bufLen = view.getUint32(offset + </span><span class="s4">4</span><span class="s1">, </span><span class="s0">true</span><span class="s1">);</span>
                <span class="s0">return </span><span class="s1">HEAPU8.subarray(buf, buf + bufLen);</span>
            <span class="s1">}));</span>
            <span class="s0">let </span><span class="s1">nwritten;</span>
            <span class="s0">if </span><span class="s1">(fd === </span><span class="s4">1 </span><span class="s1">|| fd === </span><span class="s4">2</span><span class="s1">) {</span>
                <span class="s1">nwritten = fileDescriptor.write(buffer);</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">nwritten = </span><span class="s0">await </span><span class="s1">(</span><span class="s0">await </span><span class="s1">(fileDescriptor.fd.write(buffer, </span><span class="s4">0</span><span class="s1">, buffer.length, Number(fileDescriptor.pos)))).bytesWritten;</span>
                <span class="s1">fileDescriptor.pos += BigInt(nwritten);</span>
            <span class="s1">}</span>
            <span class="s1">view.setUint32(size, nwritten, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s1">defineImport(</span><span class="s2">'path_create_directory'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">path_create_directory(fd, path, path_len) {</span>
            <span class="s1">path = Number(path);</span>
            <span class="s1">path_len = Number(path_len);</span>
            <span class="s0">if </span><span class="s1">(path === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8 } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.PATH_CREATE_DIRECTORY, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s0">let </span><span class="s1">pathString = decoder.decode(unsharedSlice(HEAPU8, path, path + path_len));</span>
            <span class="s1">pathString = resolve(fileDescriptor.realPath, pathString);</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">fs.mkdirSync(pathString);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">path_create_directory(fd, path, path_len) {</span>
            <span class="s1">path = Number(path);</span>
            <span class="s1">path_len = Number(path_len);</span>
            <span class="s0">if </span><span class="s1">(path === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8 } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.PATH_CREATE_DIRECTORY, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s0">let </span><span class="s1">pathString = decoder.decode(unsharedSlice(HEAPU8, path, path + path_len));</span>
            <span class="s1">pathString = resolve(fileDescriptor.realPath, pathString);</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">await </span><span class="s1">fs.promises.mkdir(pathString);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s1">defineImport(</span><span class="s2">'path_filestat_get'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">path_filestat_get(fd, flags, path, path_len, filestat) {</span>
            <span class="s1">path = Number(path);</span>
            <span class="s1">path_len = Number(path_len);</span>
            <span class="s1">filestat = Number(filestat);</span>
            <span class="s0">if </span><span class="s1">(path === </span><span class="s4">0 </span><span class="s1">|| filestat === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8, view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.PATH_FILESTAT_GET, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s0">let </span><span class="s1">pathString = decoder.decode(unsharedSlice(HEAPU8, path, path + path_len));</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">pathString = resolve(fileDescriptor.realPath, pathString);</span>
            <span class="s0">let </span><span class="s1">stat;</span>
            <span class="s0">if </span><span class="s1">((flags &amp; </span><span class="s4">1</span><span class="s1">) === </span><span class="s4">1</span><span class="s1">) {</span>
                <span class="s1">stat = fs.statSync(pathString, { bigint: </span><span class="s0">true </span><span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">stat = fs.lstatSync(pathString, { bigint: </span><span class="s0">true </span><span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s1">toFileStat(view, filestat, stat);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">path_filestat_get(fd, flags, path, path_len, filestat) {</span>
            <span class="s1">path = Number(path);</span>
            <span class="s1">path_len = Number(path_len);</span>
            <span class="s1">filestat = Number(filestat);</span>
            <span class="s0">if </span><span class="s1">(path === </span><span class="s4">0 </span><span class="s1">|| filestat === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8, view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.PATH_FILESTAT_GET, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s0">let </span><span class="s1">pathString = decoder.decode(unsharedSlice(HEAPU8, path, path + path_len));</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">pathString = resolve(fileDescriptor.realPath, pathString);</span>
            <span class="s0">let </span><span class="s1">stat;</span>
            <span class="s0">if </span><span class="s1">((flags &amp; </span><span class="s4">1</span><span class="s1">) === </span><span class="s4">1</span><span class="s1">) {</span>
                <span class="s1">stat = </span><span class="s0">await </span><span class="s1">fs.promises.stat(pathString, { bigint: </span><span class="s0">true </span><span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">stat = </span><span class="s0">await </span><span class="s1">fs.promises.lstat(pathString, { bigint: </span><span class="s0">true </span><span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s1">toFileStat(view, filestat, stat);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s1">defineImport(</span><span class="s2">'path_filestat_set_times'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">path_filestat_set_times(fd, flags, path, path_len, atim, mtim, fst_flags) {</span>
            <span class="s1">path = Number(path);</span>
            <span class="s1">path_len = Number(path_len);</span>
            <span class="s0">if </span><span class="s1">(path === </span><span class="s4">0</span><span class="s1">)</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8 } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.PATH_FILESTAT_SET_TIMES, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s0">if </span><span class="s1">(validateFstFlagsOrReturn(fst_flags)) {</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">resolvedPath = resolvePathSync(fs, fileDescriptor, decoder.decode(unsharedSlice(HEAPU8, path, path + path_len)), flags);</span>
            <span class="s0">if </span><span class="s1">((fst_flags &amp; </span><span class="s4">2 </span><span class="s3">/* WasiFstFlag.SET_ATIM_NOW */</span><span class="s1">) === </span><span class="s4">2 </span><span class="s3">/* WasiFstFlag.SET_ATIM_NOW */</span><span class="s1">) {</span>
                <span class="s1">atim = BigInt(Date.now() * </span><span class="s4">1000000</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">((fst_flags &amp; </span><span class="s4">8 </span><span class="s3">/* WasiFstFlag.SET_MTIM_NOW */</span><span class="s1">) === </span><span class="s4">8 </span><span class="s3">/* WasiFstFlag.SET_MTIM_NOW */</span><span class="s1">) {</span>
                <span class="s1">mtim = BigInt(Date.now() * </span><span class="s4">1000000</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s1">fs.utimesSync(resolvedPath, Number(atim), Number(mtim));</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">path_filestat_set_times(fd, flags, path, path_len, atim, mtim, fst_flags) {</span>
            <span class="s1">path = Number(path);</span>
            <span class="s1">path_len = Number(path_len);</span>
            <span class="s0">if </span><span class="s1">(path === </span><span class="s4">0</span><span class="s1">)</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8 } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.PATH_FILESTAT_SET_TIMES, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s0">if </span><span class="s1">(validateFstFlagsOrReturn(fst_flags)) {</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">resolvedPath = </span><span class="s0">await </span><span class="s1">resolvePathAsync(fs, fileDescriptor, decoder.decode(unsharedSlice(HEAPU8, path, path + path_len)), flags);</span>
            <span class="s0">if </span><span class="s1">((fst_flags &amp; </span><span class="s4">2 </span><span class="s3">/* WasiFstFlag.SET_ATIM_NOW */</span><span class="s1">) === </span><span class="s4">2 </span><span class="s3">/* WasiFstFlag.SET_ATIM_NOW */</span><span class="s1">) {</span>
                <span class="s1">atim = BigInt(Date.now() * </span><span class="s4">1000000</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">((fst_flags &amp; </span><span class="s4">8 </span><span class="s3">/* WasiFstFlag.SET_MTIM_NOW */</span><span class="s1">) === </span><span class="s4">8 </span><span class="s3">/* WasiFstFlag.SET_MTIM_NOW */</span><span class="s1">) {</span>
                <span class="s1">mtim = BigInt(Date.now() * </span><span class="s4">1000000</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s0">await </span><span class="s1">fs.promises.utimes(resolvedPath, Number(atim), Number(mtim));</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i64'</span><span class="s1">, </span><span class="s2">'i64'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s1">defineImport(</span><span class="s2">'path_link'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">path_link(old_fd, old_flags, old_path, old_path_len, new_fd, new_path, new_path_len) {</span>
            <span class="s1">old_path = Number(old_path);</span>
            <span class="s1">old_path_len = Number(old_path_len);</span>
            <span class="s1">new_path = Number(new_path);</span>
            <span class="s1">new_path_len = Number(new_path_len);</span>
            <span class="s0">if </span><span class="s1">(old_path === </span><span class="s4">0 </span><span class="s1">|| new_path === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">let </span><span class="s1">oldWrap;</span>
            <span class="s0">let </span><span class="s1">newWrap;</span>
            <span class="s0">if </span><span class="s1">(old_fd === new_fd) {</span>
                <span class="s1">oldWrap = newWrap = wasi.fds.get(old_fd, WasiRights.PATH_LINK_SOURCE | WasiRights.PATH_LINK_TARGET, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">oldWrap = wasi.fds.get(old_fd, WasiRights.PATH_LINK_SOURCE, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
                <span class="s1">newWrap = wasi.fds.get(new_fd, WasiRights.PATH_LINK_TARGET, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8 } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">resolvedOldPath = resolvePathSync(fs, oldWrap, decoder.decode(unsharedSlice(HEAPU8, old_path, old_path + old_path_len)), old_flags);</span>
            <span class="s0">const </span><span class="s1">resolvedNewPath = resolve(newWrap.realPath, decoder.decode(unsharedSlice(HEAPU8, new_path, new_path + new_path_len)));</span>
            <span class="s1">fs.linkSync(resolvedOldPath, resolvedNewPath);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">path_link(old_fd, old_flags, old_path, old_path_len, new_fd, new_path, new_path_len) {</span>
            <span class="s1">old_path = Number(old_path);</span>
            <span class="s1">old_path_len = Number(old_path_len);</span>
            <span class="s1">new_path = Number(new_path);</span>
            <span class="s1">new_path_len = Number(new_path_len);</span>
            <span class="s0">if </span><span class="s1">(old_path === </span><span class="s4">0 </span><span class="s1">|| new_path === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">let </span><span class="s1">oldWrap;</span>
            <span class="s0">let </span><span class="s1">newWrap;</span>
            <span class="s0">if </span><span class="s1">(old_fd === new_fd) {</span>
                <span class="s1">oldWrap = newWrap = wasi.fds.get(old_fd, WasiRights.PATH_LINK_SOURCE | WasiRights.PATH_LINK_TARGET, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">oldWrap = wasi.fds.get(old_fd, WasiRights.PATH_LINK_SOURCE, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
                <span class="s1">newWrap = wasi.fds.get(new_fd, WasiRights.PATH_LINK_TARGET, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8 } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">resolvedOldPath = </span><span class="s0">await </span><span class="s1">resolvePathAsync(fs, oldWrap, decoder.decode(unsharedSlice(HEAPU8, old_path, old_path + old_path_len)), old_flags);</span>
            <span class="s0">const </span><span class="s1">resolvedNewPath = resolve(newWrap.realPath, decoder.decode(unsharedSlice(HEAPU8, new_path, new_path + new_path_len)));</span>
            <span class="s0">await </span><span class="s1">fs.promises.link(resolvedOldPath, resolvedNewPath);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s0">function </span><span class="s1">pathOpen(o_flags, fs_rights_base, fs_rights_inheriting, fs_flags) {</span>
            <span class="s0">const </span><span class="s1">read = (fs_rights_base &amp; (WasiRights.FD_READ |</span>
                <span class="s1">WasiRights.FD_READDIR)) !== BigInt(</span><span class="s4">0</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">write = (fs_rights_base &amp; (WasiRights.FD_DATASYNC |</span>
                <span class="s1">WasiRights.FD_WRITE |</span>
                <span class="s1">WasiRights.FD_ALLOCATE |</span>
                <span class="s1">WasiRights.FD_FILESTAT_SET_SIZE)) !== BigInt(</span><span class="s4">0</span><span class="s1">);</span>
            <span class="s0">let </span><span class="s1">flags = write ? read ? </span><span class="s4">2 </span><span class="s3">/* FileControlFlag.O_RDWR */ </span><span class="s1">: </span><span class="s4">1 </span><span class="s3">/* FileControlFlag.O_WRONLY */ </span><span class="s1">: </span><span class="s4">0 </span><span class="s3">/* FileControlFlag.O_RDONLY */</span><span class="s1">;</span>
            <span class="s0">let </span><span class="s1">needed_base = WasiRights.PATH_OPEN;</span>
            <span class="s0">let </span><span class="s1">needed_inheriting = fs_rights_base | fs_rights_inheriting;</span>
            <span class="s0">if </span><span class="s1">((o_flags &amp; </span><span class="s4">1 </span><span class="s3">/* WasiFileControlFlag.O_CREAT */</span><span class="s1">) !== </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s1">flags |= </span><span class="s4">64 </span><span class="s3">/* FileControlFlag.O_CREAT */</span><span class="s1">;</span>
                <span class="s1">needed_base |= WasiRights.PATH_CREATE_FILE;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">((o_flags &amp; </span><span class="s4">2 </span><span class="s3">/* WasiFileControlFlag.O_DIRECTORY */</span><span class="s1">) !== </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s1">flags |= </span><span class="s4">65536 </span><span class="s3">/* FileControlFlag.O_DIRECTORY */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">((o_flags &amp; </span><span class="s4">4 </span><span class="s3">/* WasiFileControlFlag.O_EXCL */</span><span class="s1">) !== </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s1">flags |= </span><span class="s4">128 </span><span class="s3">/* FileControlFlag.O_EXCL */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">((o_flags &amp; </span><span class="s4">8 </span><span class="s3">/* WasiFileControlFlag.O_TRUNC */</span><span class="s1">) !== </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s1">flags |= </span><span class="s4">512 </span><span class="s3">/* FileControlFlag.O_TRUNC */</span><span class="s1">;</span>
                <span class="s1">needed_base |= WasiRights.PATH_FILESTAT_SET_SIZE;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">((fs_flags &amp; </span><span class="s4">1 </span><span class="s3">/* WasiFdFlag.APPEND */</span><span class="s1">) !== </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s1">flags |= </span><span class="s4">1024 </span><span class="s3">/* FileControlFlag.O_APPEND */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">((fs_flags &amp; </span><span class="s4">2 </span><span class="s3">/* WasiFdFlag.DSYNC */</span><span class="s1">) !== </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s3">// flags |= FileControlFlag.O_DSYNC;</span>
                <span class="s1">needed_inheriting |= WasiRights.FD_DATASYNC;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">((fs_flags &amp; </span><span class="s4">4 </span><span class="s3">/* WasiFdFlag.NONBLOCK */</span><span class="s1">) !== </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s1">flags |= </span><span class="s4">2048 </span><span class="s3">/* FileControlFlag.O_NONBLOCK */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">((fs_flags &amp; </span><span class="s4">8 </span><span class="s3">/* WasiFdFlag.RSYNC */</span><span class="s1">) !== </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s1">flags |= </span><span class="s4">1052672 </span><span class="s3">/* FileControlFlag.O_SYNC */</span><span class="s1">;</span>
                <span class="s1">needed_inheriting |= WasiRights.FD_SYNC;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">((fs_flags &amp; </span><span class="s4">16 </span><span class="s3">/* WasiFdFlag.SYNC */</span><span class="s1">) !== </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s1">flags |= </span><span class="s4">1052672 </span><span class="s3">/* FileControlFlag.O_SYNC */</span><span class="s1">;</span>
                <span class="s1">needed_inheriting |= WasiRights.FD_SYNC;</span>
            <span class="s1">}</span>
            <span class="s0">if </span><span class="s1">(write &amp;&amp; (flags &amp; (</span><span class="s4">1024 </span><span class="s3">/* FileControlFlag.O_APPEND */ </span><span class="s1">| </span><span class="s4">512 </span><span class="s3">/* FileControlFlag.O_TRUNC */</span><span class="s1">)) === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s1">needed_inheriting |= WasiRights.FD_SEEK;</span>
            <span class="s1">}</span>
            <span class="s0">return </span><span class="s1">{ flags, needed_base, needed_inheriting };</span>
        <span class="s1">}</span>
        <span class="s1">defineImport(</span><span class="s2">'path_open'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">path_open(dirfd, dirflags, path, path_len, o_flags, fs_rights_base, fs_rights_inheriting, fs_flags, fd) {</span>
            <span class="s1">path = Number(path);</span>
            <span class="s1">fd = Number(fd);</span>
            <span class="s0">if </span><span class="s1">(path === </span><span class="s4">0 </span><span class="s1">|| fd === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">path_len = Number(path_len);</span>
            <span class="s1">fs_rights_base = BigInt(fs_rights_base);</span>
            <span class="s1">fs_rights_inheriting = BigInt(fs_rights_inheriting);</span>
            <span class="s0">const </span><span class="s1">{ flags: flagsRes, needed_base: neededBase, needed_inheriting: neededInheriting } = pathOpen(o_flags, fs_rights_base, fs_rights_inheriting, fs_flags);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(dirfd, neededBase, neededInheriting);</span>
            <span class="s0">const </span><span class="s1">memory = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">HEAPU8 = memory.HEAPU8;</span>
            <span class="s0">const </span><span class="s1">pathString = decoder.decode(unsharedSlice(HEAPU8, path, path + path_len));</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">resolved_path = resolvePathSync(fs, fileDescriptor, pathString, dirflags);</span>
            <span class="s0">const </span><span class="s1">r = fs.openSync(resolved_path, flagsRes, </span><span class="s4">0o666</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">filetype = wasi.fds.getFileTypeByFd(r);</span>
            <span class="s0">if </span><span class="s1">((filetype !== </span><span class="s4">3 </span><span class="s3">/* WasiFileType.DIRECTORY */</span><span class="s1">) &amp;&amp;</span>
                <span class="s1">((o_flags &amp; </span><span class="s4">2 </span><span class="s3">/* WasiFileControlFlag.O_DIRECTORY */</span><span class="s1">) !== </span><span class="s4">0 </span><span class="s1">||</span>
                    <span class="s1">(resolved_path.endsWith(</span><span class="s2">'/'</span><span class="s1">)))) {</span>
                <span class="s0">return </span><span class="s4">54 </span><span class="s3">/* WasiErrno.ENOTDIR */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ base: max_base, inheriting: max_inheriting } = getRights(wasi.fds.stdio, r, flagsRes, filetype);</span>
            <span class="s0">const </span><span class="s1">wrap = wasi.fds.insert(r, resolved_path, resolved_path, filetype, fs_rights_base &amp; max_base, fs_rights_inheriting &amp; max_inheriting, </span><span class="s4">0</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">stat = fs.fstatSync(r, { bigint: </span><span class="s0">true </span><span class="s1">});</span>
            <span class="s0">if </span><span class="s1">(stat.isFile()) {</span>
                <span class="s1">wrap.size = stat.size;</span>
                <span class="s0">if </span><span class="s1">((flagsRes &amp; </span><span class="s4">1024 </span><span class="s3">/* FileControlFlag.O_APPEND */</span><span class="s1">) !== </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s1">wrap.pos = stat.size;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">view = memory.view;</span>
            <span class="s1">view.setInt32(fd, wrap.id, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">path_open(dirfd, dirflags, path, path_len, o_flags, fs_rights_base, fs_rights_inheriting, fs_flags, fd) {</span>
            <span class="s1">path = Number(path);</span>
            <span class="s1">fd = Number(fd);</span>
            <span class="s0">if </span><span class="s1">(path === </span><span class="s4">0 </span><span class="s1">|| fd === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">path_len = Number(path_len);</span>
            <span class="s1">fs_rights_base = BigInt(fs_rights_base);</span>
            <span class="s1">fs_rights_inheriting = BigInt(fs_rights_inheriting);</span>
            <span class="s0">const </span><span class="s1">{ flags: flagsRes, needed_base: neededBase, needed_inheriting: neededInheriting } = pathOpen(o_flags, fs_rights_base, fs_rights_inheriting, fs_flags);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(dirfd, neededBase, neededInheriting);</span>
            <span class="s0">const </span><span class="s1">memory = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">HEAPU8 = memory.HEAPU8;</span>
            <span class="s0">const </span><span class="s1">pathString = decoder.decode(unsharedSlice(HEAPU8, path, path + path_len));</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">resolved_path = </span><span class="s0">await </span><span class="s1">resolvePathAsync(fs, fileDescriptor, pathString, dirflags);</span>
            <span class="s0">const </span><span class="s1">r = </span><span class="s0">await </span><span class="s1">fs.promises.open(resolved_path, flagsRes, </span><span class="s4">0o666</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">filetype = </span><span class="s0">await </span><span class="s1">wasi.fds.getFileTypeByFd(r);</span>
            <span class="s0">if </span><span class="s1">((o_flags &amp; </span><span class="s4">2 </span><span class="s3">/* WasiFileControlFlag.O_DIRECTORY */</span><span class="s1">) !== </span><span class="s4">0 </span><span class="s1">&amp;&amp; filetype !== </span><span class="s4">3 </span><span class="s3">/* WasiFileType.DIRECTORY */</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s4">54 </span><span class="s3">/* WasiErrno.ENOTDIR */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ base: max_base, inheriting: max_inheriting } = getRights(wasi.fds.stdio, r.fd, flagsRes, filetype);</span>
            <span class="s0">const </span><span class="s1">wrap = wasi.fds.insert(r, resolved_path, resolved_path, filetype, fs_rights_base &amp; max_base, fs_rights_inheriting &amp; max_inheriting, </span><span class="s4">0</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">stat = </span><span class="s0">await </span><span class="s1">r.stat({ bigint: </span><span class="s0">true </span><span class="s1">});</span>
            <span class="s0">if </span><span class="s1">(stat.isFile()) {</span>
                <span class="s1">wrap.size = stat.size;</span>
                <span class="s0">if </span><span class="s1">((flagsRes &amp; </span><span class="s4">1024 </span><span class="s3">/* FileControlFlag.O_APPEND */</span><span class="s1">) !== </span><span class="s4">0</span><span class="s1">) {</span>
                    <span class="s1">wrap.pos = stat.size;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">view = memory.view;</span>
            <span class="s1">view.setInt32(fd, wrap.id, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i64'</span><span class="s1">, </span><span class="s2">'i64'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s1">defineImport(</span><span class="s2">'path_readlink'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">path_readlink(fd, path, path_len, buf, buf_len, bufused) {</span>
            <span class="s1">path = Number(path);</span>
            <span class="s1">path_len = Number(path_len);</span>
            <span class="s1">buf = Number(buf);</span>
            <span class="s1">buf_len = Number(buf_len);</span>
            <span class="s1">bufused = Number(bufused);</span>
            <span class="s0">if </span><span class="s1">(path === </span><span class="s4">0 </span><span class="s1">|| buf === </span><span class="s4">0 </span><span class="s1">|| bufused === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8, view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.PATH_READLINK, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s0">let </span><span class="s1">pathString = decoder.decode(unsharedSlice(HEAPU8, path, path + path_len));</span>
            <span class="s1">pathString = resolve(fileDescriptor.realPath, pathString);</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">link = fs.readlinkSync(pathString);</span>
            <span class="s0">const </span><span class="s1">linkData = encoder.encode(link);</span>
            <span class="s0">const </span><span class="s1">len = Math.min(linkData.length, buf_len);</span>
            <span class="s0">if </span><span class="s1">(len &gt;= buf_len)</span>
                <span class="s0">return </span><span class="s4">42 </span><span class="s3">/* WasiErrno.ENOBUFS */</span><span class="s1">;</span>
            <span class="s1">HEAPU8.set(linkData.subarray(</span><span class="s4">0</span><span class="s1">, len), buf);</span>
            <span class="s1">HEAPU8[buf + len] = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s1">view.setUint32(bufused, len, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">path_readlink(fd, path, path_len, buf, buf_len, bufused) {</span>
            <span class="s1">path = Number(path);</span>
            <span class="s1">path_len = Number(path_len);</span>
            <span class="s1">buf = Number(buf);</span>
            <span class="s1">buf_len = Number(buf_len);</span>
            <span class="s1">bufused = Number(bufused);</span>
            <span class="s0">if </span><span class="s1">(path === </span><span class="s4">0 </span><span class="s1">|| buf === </span><span class="s4">0 </span><span class="s1">|| bufused === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8, view } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.PATH_READLINK, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s0">let </span><span class="s1">pathString = decoder.decode(unsharedSlice(HEAPU8, path, path + path_len));</span>
            <span class="s1">pathString = resolve(fileDescriptor.realPath, pathString);</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">link = </span><span class="s0">await </span><span class="s1">fs.promises.readlink(pathString);</span>
            <span class="s0">const </span><span class="s1">linkData = encoder.encode(link);</span>
            <span class="s0">const </span><span class="s1">len = Math.min(linkData.length, buf_len);</span>
            <span class="s0">if </span><span class="s1">(len &gt;= buf_len)</span>
                <span class="s0">return </span><span class="s4">42 </span><span class="s3">/* WasiErrno.ENOBUFS */</span><span class="s1">;</span>
            <span class="s1">HEAPU8.set(linkData.subarray(</span><span class="s4">0</span><span class="s1">, len), buf);</span>
            <span class="s1">HEAPU8[buf + len] = </span><span class="s4">0</span><span class="s1">;</span>
            <span class="s1">view.setUint32(bufused, len, </span><span class="s0">true</span><span class="s1">);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s1">defineImport(</span><span class="s2">'path_remove_directory'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">path_remove_directory(fd, path, path_len) {</span>
            <span class="s1">path = Number(path);</span>
            <span class="s1">path_len = Number(path_len);</span>
            <span class="s0">if </span><span class="s1">(path === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8 } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.PATH_REMOVE_DIRECTORY, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s0">let </span><span class="s1">pathString = decoder.decode(unsharedSlice(HEAPU8, path, path + path_len));</span>
            <span class="s1">pathString = resolve(fileDescriptor.realPath, pathString);</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">fs.rmdirSync(pathString);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">path_remove_directory(fd, path, path_len) {</span>
            <span class="s1">path = Number(path);</span>
            <span class="s1">path_len = Number(path_len);</span>
            <span class="s0">if </span><span class="s1">(path === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8 } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.PATH_REMOVE_DIRECTORY, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s0">let </span><span class="s1">pathString = decoder.decode(unsharedSlice(HEAPU8, path, path + path_len));</span>
            <span class="s1">pathString = resolve(fileDescriptor.realPath, pathString);</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">await </span><span class="s1">fs.promises.rmdir(pathString);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s1">defineImport(</span><span class="s2">'path_rename'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">path_rename(old_fd, old_path, old_path_len, new_fd, new_path, new_path_len) {</span>
            <span class="s1">old_path = Number(old_path);</span>
            <span class="s1">old_path_len = Number(old_path_len);</span>
            <span class="s1">new_path = Number(new_path);</span>
            <span class="s1">new_path_len = Number(new_path_len);</span>
            <span class="s0">if </span><span class="s1">(old_path === </span><span class="s4">0 </span><span class="s1">|| new_path === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">let </span><span class="s1">oldWrap;</span>
            <span class="s0">let </span><span class="s1">newWrap;</span>
            <span class="s0">if </span><span class="s1">(old_fd === new_fd) {</span>
                <span class="s1">oldWrap = newWrap = wasi.fds.get(old_fd, WasiRights.PATH_RENAME_SOURCE | WasiRights.PATH_RENAME_TARGET, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">oldWrap = wasi.fds.get(old_fd, WasiRights.PATH_RENAME_SOURCE, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
                <span class="s1">newWrap = wasi.fds.get(new_fd, WasiRights.PATH_RENAME_TARGET, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8 } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">resolvedOldPath = resolve(oldWrap.realPath, decoder.decode(unsharedSlice(HEAPU8, old_path, old_path + old_path_len)));</span>
            <span class="s0">const </span><span class="s1">resolvedNewPath = resolve(newWrap.realPath, decoder.decode(unsharedSlice(HEAPU8, new_path, new_path + new_path_len)));</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">fs.renameSync(resolvedOldPath, resolvedNewPath);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">path_rename(old_fd, old_path, old_path_len, new_fd, new_path, new_path_len) {</span>
            <span class="s1">old_path = Number(old_path);</span>
            <span class="s1">old_path_len = Number(old_path_len);</span>
            <span class="s1">new_path = Number(new_path);</span>
            <span class="s1">new_path_len = Number(new_path_len);</span>
            <span class="s0">if </span><span class="s1">(old_path === </span><span class="s4">0 </span><span class="s1">|| new_path === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">let </span><span class="s1">oldWrap;</span>
            <span class="s0">let </span><span class="s1">newWrap;</span>
            <span class="s0">if </span><span class="s1">(old_fd === new_fd) {</span>
                <span class="s1">oldWrap = newWrap = wasi.fds.get(old_fd, WasiRights.PATH_RENAME_SOURCE | WasiRights.PATH_RENAME_TARGET, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">oldWrap = wasi.fds.get(old_fd, WasiRights.PATH_RENAME_SOURCE, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
                <span class="s1">newWrap = wasi.fds.get(new_fd, WasiRights.PATH_RENAME_TARGET, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8 } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">resolvedOldPath = resolve(oldWrap.realPath, decoder.decode(unsharedSlice(HEAPU8, old_path, old_path + old_path_len)));</span>
            <span class="s0">const </span><span class="s1">resolvedNewPath = resolve(newWrap.realPath, decoder.decode(unsharedSlice(HEAPU8, new_path, new_path + new_path_len)));</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">await </span><span class="s1">fs.promises.rename(resolvedOldPath, resolvedNewPath);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s1">defineImport(</span><span class="s2">'path_symlink'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">path_symlink(old_path, old_path_len, fd, new_path, new_path_len) {</span>
            <span class="s1">old_path = Number(old_path);</span>
            <span class="s1">old_path_len = Number(old_path_len);</span>
            <span class="s1">new_path = Number(new_path);</span>
            <span class="s1">new_path_len = Number(new_path_len);</span>
            <span class="s0">if </span><span class="s1">(old_path === </span><span class="s4">0 </span><span class="s1">|| new_path === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8 } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.PATH_SYMLINK, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s0">const </span><span class="s1">oldPath = decoder.decode(unsharedSlice(HEAPU8, old_path, old_path + old_path_len));</span>
            <span class="s0">if </span><span class="s1">(oldPath.length &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; oldPath[</span><span class="s4">0</span><span class="s1">] === </span><span class="s2">'/'</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s4">63 </span><span class="s3">/* WasiErrno.EPERM */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">let </span><span class="s1">newPath = decoder.decode(unsharedSlice(HEAPU8, new_path, new_path + new_path_len));</span>
            <span class="s1">newPath = resolve(fileDescriptor.realPath, newPath);</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">fs.symlinkSync(oldPath, newPath);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">path_symlink(old_path, old_path_len, fd, new_path, new_path_len) {</span>
            <span class="s1">old_path = Number(old_path);</span>
            <span class="s1">old_path_len = Number(old_path_len);</span>
            <span class="s1">new_path = Number(new_path);</span>
            <span class="s1">new_path_len = Number(new_path_len);</span>
            <span class="s0">if </span><span class="s1">(old_path === </span><span class="s4">0 </span><span class="s1">|| new_path === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8 } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.PATH_SYMLINK, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s0">const </span><span class="s1">oldPath = decoder.decode(unsharedSlice(HEAPU8, old_path, old_path + old_path_len));</span>
            <span class="s0">let </span><span class="s1">newPath = decoder.decode(unsharedSlice(HEAPU8, new_path, new_path + new_path_len));</span>
            <span class="s1">newPath = resolve(fileDescriptor.realPath, newPath);</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">await </span><span class="s1">fs.promises.symlink(oldPath, newPath);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s1">defineImport(</span><span class="s2">'path_unlink_file'</span><span class="s1">, </span><span class="s0">function </span><span class="s1">path_unlink_file(fd, path, path_len) {</span>
            <span class="s1">path = Number(path);</span>
            <span class="s1">path_len = Number(path_len);</span>
            <span class="s0">if </span><span class="s1">(path === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8 } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.PATH_UNLINK_FILE, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s0">let </span><span class="s1">pathString = decoder.decode(unsharedSlice(HEAPU8, path, path + path_len));</span>
            <span class="s1">pathString = resolve(fileDescriptor.realPath, pathString);</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s1">fs.unlinkSync(pathString);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, async </span><span class="s0">function </span><span class="s1">path_unlink_file(fd, path, path_len) {</span>
            <span class="s1">path = Number(path);</span>
            <span class="s1">path_len = Number(path_len);</span>
            <span class="s0">if </span><span class="s1">(path === </span><span class="s4">0</span><span class="s1">) {</span>
                <span class="s0">return </span><span class="s4">28 </span><span class="s3">/* WasiErrno.EINVAL */</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">const </span><span class="s1">{ HEAPU8 } = getMemory(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">wasi = _wasi.get(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">const </span><span class="s1">fileDescriptor = wasi.fds.get(fd, WasiRights.PATH_UNLINK_FILE, BigInt(</span><span class="s4">0</span><span class="s1">));</span>
            <span class="s0">let </span><span class="s1">pathString = decoder.decode(unsharedSlice(HEAPU8, path, path + path_len));</span>
            <span class="s1">pathString = resolve(fileDescriptor.realPath, pathString);</span>
            <span class="s0">const </span><span class="s1">fs = getFs(</span><span class="s0">this</span><span class="s1">);</span>
            <span class="s0">await </span><span class="s1">fs.promises.unlink(pathString);</span>
            <span class="s0">return </span><span class="s4">0 </span><span class="s3">/* WasiErrno.ESUCCESS */</span><span class="s1">;</span>
        <span class="s1">}, [</span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">, </span><span class="s2">'i32'</span><span class="s1">], [</span><span class="s2">'i32'</span><span class="s1">]);</span>
        <span class="s0">this</span><span class="s1">._setMemory = </span><span class="s0">function </span><span class="s1">setMemory(m) {</span>
            <span class="s0">if </span><span class="s1">(!(m </span><span class="s0">instanceof </span><span class="s1">_WebAssembly.Memory)) {</span>
                <span class="s0">throw new </span><span class="s1">TypeError(</span><span class="s2">'&quot;instance.exports.memory&quot; property must be a WebAssembly.Memory'</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s1">_memory.set(_this, extendMemory(m));</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s0">static </span><span class="s1">createSync(args, env, preopens, stdio, fs, print, printErr) {</span>
        <span class="s0">const </span><span class="s1">fds = </span><span class="s0">new </span><span class="s1">SyncTable({</span>
            <span class="s1">size: </span><span class="s4">3</span><span class="s1">,</span>
            <span class="s0">in</span><span class="s1">: stdio[</span><span class="s4">0</span><span class="s1">],</span>
            <span class="s1">out: stdio[</span><span class="s4">1</span><span class="s1">],</span>
            <span class="s1">err: stdio[</span><span class="s4">2</span><span class="s1">],</span>
            <span class="s1">fs,</span>
            <span class="s1">print,</span>
            <span class="s1">printErr</span>
        <span class="s1">});</span>
        <span class="s0">const </span><span class="s1">_this = </span><span class="s0">new </span><span class="s1">WASI$1(args, env, fds, </span><span class="s0">false</span><span class="s1">, fs);</span>
        <span class="s0">if </span><span class="s1">(preopens.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; preopens.length; ++i) {</span>
                <span class="s0">const </span><span class="s1">realPath = fs.realpathSync(preopens[i].realPath, </span><span class="s2">'utf8'</span><span class="s1">);</span>
                <span class="s0">const </span><span class="s1">fd = fs.openSync(realPath, </span><span class="s2">'r'</span><span class="s1">, </span><span class="s4">0o666</span><span class="s1">);</span>
                <span class="s1">fds.insertPreopen(fd, preopens[i].mappedPath, realPath);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">_this;</span>
    <span class="s1">}</span>
    <span class="s0">static </span><span class="s1">async createAsync(args, env, preopens, stdio, fs, print, printErr, asyncify) {</span>
        <span class="s0">const </span><span class="s1">fds = </span><span class="s0">new </span><span class="s1">AsyncTable({</span>
            <span class="s1">size: </span><span class="s4">3</span><span class="s1">,</span>
            <span class="s0">in</span><span class="s1">: stdio[</span><span class="s4">0</span><span class="s1">],</span>
            <span class="s1">out: stdio[</span><span class="s4">1</span><span class="s1">],</span>
            <span class="s1">err: stdio[</span><span class="s4">2</span><span class="s1">],</span>
            <span class="s1">print,</span>
            <span class="s1">printErr</span>
        <span class="s1">});</span>
        <span class="s0">const </span><span class="s1">_this = </span><span class="s0">new </span><span class="s1">WASI$1(args, env, fds, </span><span class="s0">true</span><span class="s1">, fs, asyncify);</span>
        <span class="s0">if </span><span class="s1">(preopens.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; preopens.length; ++i) {</span>
                <span class="s0">const </span><span class="s1">entry = preopens[i];</span>
                <span class="s0">const </span><span class="s1">realPath = </span><span class="s0">await </span><span class="s1">fs.promises.realpath(entry.realPath);</span>
                <span class="s0">const </span><span class="s1">fd = </span><span class="s0">await </span><span class="s1">fs.promises.open(realPath, </span><span class="s2">'r'</span><span class="s1">, </span><span class="s4">0o666</span><span class="s1">);</span>
                <span class="s0">await </span><span class="s1">fds.insertPreopen(fd, entry.mappedPath, realPath);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">_this;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">// eslint-disable-next-line spaced-comment</span>
<span class="s0">const </span><span class="s1">kEmptyObject = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">Object.freeze(</span><span class="s3">/*#__PURE__*/ </span><span class="s1">Object.create(</span><span class="s0">null</span><span class="s1">));</span>
<span class="s0">const </span><span class="s1">kExitCode = Symbol(</span><span class="s2">'kExitCode'</span><span class="s1">);</span>
<span class="s0">const </span><span class="s1">kSetMemory = Symbol(</span><span class="s2">'kSetMemory'</span><span class="s1">);</span>
<span class="s0">const </span><span class="s1">kStarted = Symbol(</span><span class="s2">'kStarted'</span><span class="s1">);</span>
<span class="s0">const </span><span class="s1">kInstance = Symbol(</span><span class="s2">'kInstance'</span><span class="s1">);</span>
<span class="s0">const </span><span class="s1">kBindingName = Symbol(</span><span class="s2">'kBindingName'</span><span class="s1">);</span>
<span class="s0">function </span><span class="s1">validateOptions(options) {</span>
    <span class="s0">var </span><span class="s1">_a;</span>
    <span class="s1">validateObject(options, </span><span class="s2">'options'</span><span class="s1">);</span>
    <span class="s0">let </span><span class="s1">_WASI;</span>
    <span class="s0">if </span><span class="s1">(options.version !== undefined) {</span>
        <span class="s1">validateString(options.version, </span><span class="s2">'options.version'</span><span class="s1">);</span>
        <span class="s0">switch </span><span class="s1">(options.version) {</span>
            <span class="s0">case </span><span class="s2">'unstable'</span><span class="s1">:</span>
                <span class="s1">_WASI = WASI$1;</span>
                <span class="s0">this</span><span class="s1">[kBindingName] = </span><span class="s2">'wasi_unstable'</span><span class="s1">;</span>
                <span class="s0">break</span><span class="s1">;</span>
            <span class="s0">case </span><span class="s2">'preview1'</span><span class="s1">:</span>
                <span class="s1">_WASI = WASI$1;</span>
                <span class="s0">this</span><span class="s1">[kBindingName] = </span><span class="s2">'wasi_snapshot_preview1'</span><span class="s1">;</span>
                <span class="s0">break</span><span class="s1">;</span>
            <span class="s0">default</span><span class="s1">:</span>
                <span class="s0">throw new </span><span class="s1">TypeError(</span><span class="s2">`unsupported WASI version &quot;</span><span class="s1">${options.version}</span><span class="s2">&quot;`</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">else </span><span class="s1">{</span>
        <span class="s1">_WASI = WASI$1;</span>
        <span class="s0">this</span><span class="s1">[kBindingName] = </span><span class="s2">'wasi_snapshot_preview1'</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(options.args !== undefined) {</span>
        <span class="s1">validateArray(options.args, </span><span class="s2">'options.args'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s0">const </span><span class="s1">args = ((_a = options.args) !== </span><span class="s0">null </span><span class="s1">&amp;&amp; _a !== </span><span class="s0">void </span><span class="s4">0 </span><span class="s1">? _a : []).map(String);</span>
    <span class="s0">const </span><span class="s1">env = [];</span>
    <span class="s0">if </span><span class="s1">(options.env !== undefined) {</span>
        <span class="s1">validateObject(options.env, </span><span class="s2">'options.env'</span><span class="s1">);</span>
        <span class="s1">Object.entries(options.env).forEach(({ </span><span class="s4">0</span><span class="s1">: key, </span><span class="s4">1</span><span class="s1">: value }) =&gt; {</span>
            <span class="s0">if </span><span class="s1">(value !== undefined) {</span>
                <span class="s1">env.push(</span><span class="s2">`</span><span class="s1">${key}</span><span class="s2">=</span><span class="s1">${value}</span><span class="s2">`</span><span class="s1">);</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s0">const </span><span class="s1">preopens = [];</span>
    <span class="s0">if </span><span class="s1">(options.preopens !== undefined) {</span>
        <span class="s1">validateObject(options.preopens, </span><span class="s2">'options.preopens'</span><span class="s1">);</span>
        <span class="s1">Object.entries(options.preopens).forEach(({ </span><span class="s4">0</span><span class="s1">: key, </span><span class="s4">1</span><span class="s1">: value }) =&gt; preopens.push({ mappedPath: String(key), realPath: String(value) }));</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">(preopens.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s0">if </span><span class="s1">(options.fs === undefined) {</span>
            <span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">'filesystem is disabled, can not preopen directory'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s0">try </span><span class="s1">{</span>
            <span class="s1">validateObject(options.fs, </span><span class="s2">'options.fs'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s0">catch </span><span class="s1">(_) {</span>
            <span class="s0">throw new </span><span class="s1">TypeError(</span><span class="s2">'Node.js fs like implementation is not provided'</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">// if (options.filesystem !== undefined) {</span>
    <span class="s3">//   validateObject(options.filesystem, 'options.filesystem')</span>
    <span class="s3">//   validateString(options.filesystem.type, 'options.filesystem.type')</span>
    <span class="s3">//   if (options.filesystem.type !== 'memfs' &amp;&amp; options.filesystem.type !== 'file-system-access-api') {</span>
    <span class="s3">//     throw new Error(`Filesystem type ${(options.filesystem as any).type as string} is not supported, only &quot;memfs&quot; and &quot;file-system-access-api&quot; is supported currently`)</span>
    <span class="s3">//   }</span>
    <span class="s3">//   try {</span>
    <span class="s3">//     validateObject(options.filesystem.fs, 'options.filesystem.fs')</span>
    <span class="s3">//   } catch (_) {</span>
    <span class="s3">//     throw new Error('Node.js fs like implementation is not provided')</span>
    <span class="s3">//   }</span>
    <span class="s3">// }</span>
    <span class="s0">if </span><span class="s1">(options.print !== undefined)</span>
        <span class="s1">validateFunction(options.print, </span><span class="s2">'options.print'</span><span class="s1">);</span>
    <span class="s0">if </span><span class="s1">(options.printErr !== undefined)</span>
        <span class="s1">validateFunction(options.printErr, </span><span class="s2">'options.printErr'</span><span class="s1">);</span>
    <span class="s0">if </span><span class="s1">(options.returnOnExit !== undefined) {</span>
        <span class="s1">validateBoolean(options.returnOnExit, </span><span class="s2">'options.returnOnExit'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s3">// const { stdin = 0, stdout = 1, stderr = 2 } = options</span>
    <span class="s3">// validateInt32(stdin, 'options.stdin', 0)</span>
    <span class="s3">// validateInt32(stdout, 'options.stdout', 0)</span>
    <span class="s3">// validateInt32(stderr, 'options.stderr', 0)</span>
    <span class="s3">// const stdio = [stdin, stdout, stderr] as const</span>
    <span class="s0">const </span><span class="s1">stdio = [</span><span class="s4">0</span><span class="s1">, </span><span class="s4">1</span><span class="s1">, </span><span class="s4">2</span><span class="s1">];</span>
    <span class="s0">return </span><span class="s1">{</span>
        <span class="s1">args,</span>
        <span class="s1">env,</span>
        <span class="s1">preopens,</span>
        <span class="s1">stdio,</span>
        <span class="s1">_WASI</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">initWASI(setMemory, wrap) {</span>
    <span class="s0">this</span><span class="s1">[kSetMemory] = setMemory;</span>
    <span class="s0">this</span><span class="s1">.wasiImport = wrap;</span>
    <span class="s0">this</span><span class="s1">[kStarted] = </span><span class="s0">false</span><span class="s1">;</span>
    <span class="s0">this</span><span class="s1">[kExitCode] = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s0">this</span><span class="s1">[kInstance] = undefined;</span>
<span class="s1">}</span>
<span class="s3">/** </span><span class="s5">@public </span><span class="s3">*/</span>
<span class="s0">class </span><span class="s1">WASI {</span>
    <span class="s1">constructor(options = kEmptyObject) {</span>
        <span class="s0">const </span><span class="s1">{ args, env, preopens, stdio, _WASI } = validateOptions.call(</span><span class="s0">this</span><span class="s1">, options);</span>
        <span class="s0">const </span><span class="s1">wrap = _WASI.createSync(args, env, preopens, stdio, options.fs, options.print, options.printErr);</span>
        <span class="s0">const </span><span class="s1">setMemory = wrap._setMemory;</span>
        <span class="s0">delete </span><span class="s1">wrap._setMemory;</span>
        <span class="s1">initWASI.call(</span><span class="s0">this</span><span class="s1">, setMemory, wrap);</span>
        <span class="s0">if </span><span class="s1">(options.returnOnExit) {</span>
            <span class="s1">wrap.proc_exit = wasiReturnOnProcExit.bind(</span><span class="s0">this</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">finalizeBindings(instance, _a) {</span>
        <span class="s0">var </span><span class="s1">_b;</span>
        <span class="s0">var </span><span class="s1">{ memory = (_b = instance === </span><span class="s0">null </span><span class="s1">|| instance === </span><span class="s0">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s0">void </span><span class="s4">0 </span><span class="s1">: instance.exports) === </span><span class="s0">null </span><span class="s1">|| _b === </span><span class="s0">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s0">void </span><span class="s4">0 </span><span class="s1">: _b.memory } = _a === </span><span class="s0">void </span><span class="s4">0 </span><span class="s1">? {} : _a;</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">[kStarted]) {</span>
            <span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">'WASI instance has already started'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s1">validateObject(instance, </span><span class="s2">'instance'</span><span class="s1">);</span>
        <span class="s1">validateObject(instance.exports, </span><span class="s2">'instance.exports'</span><span class="s1">);</span>
        <span class="s0">this</span><span class="s1">[kSetMemory](memory);</span>
        <span class="s0">this</span><span class="s1">[kInstance] = instance;</span>
        <span class="s0">this</span><span class="s1">[kStarted] = </span><span class="s0">true</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">// Must not export _initialize, must export _start</span>
    <span class="s1">start(instance) {</span>
        <span class="s0">this</span><span class="s1">.finalizeBindings(instance);</span>
        <span class="s0">const </span><span class="s1">{ _start, _initialize } = </span><span class="s0">this</span><span class="s1">[kInstance].exports;</span>
        <span class="s1">validateFunction(_start, </span><span class="s2">'instance.exports._start'</span><span class="s1">);</span>
        <span class="s1">validateUndefined(_initialize, </span><span class="s2">'instance.exports._initialize'</span><span class="s1">);</span>
        <span class="s0">let </span><span class="s1">ret;</span>
        <span class="s0">try </span><span class="s1">{</span>
            <span class="s1">ret = _start();</span>
        <span class="s1">}</span>
        <span class="s0">catch </span><span class="s1">(err) {</span>
            <span class="s0">if </span><span class="s1">(err !== kExitCode) {</span>
                <span class="s0">throw </span><span class="s1">err;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(ret </span><span class="s0">instanceof </span><span class="s1">Promise) {</span>
            <span class="s0">return </span><span class="s1">ret.then(() =&gt; </span><span class="s0">this</span><span class="s1">[kExitCode], (err) =&gt; {</span>
                <span class="s0">if </span><span class="s1">(err !== kExitCode) {</span>
                    <span class="s0">throw </span><span class="s1">err;</span>
                <span class="s1">}</span>
                <span class="s0">return this</span><span class="s1">[kExitCode];</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s0">return this</span><span class="s1">[kExitCode];</span>
    <span class="s1">}</span>
    <span class="s3">// Must not export _start, may optionally export _initialize</span>
    <span class="s1">initialize(instance) {</span>
        <span class="s0">this</span><span class="s1">.finalizeBindings(instance);</span>
        <span class="s0">const </span><span class="s1">{ _start, _initialize } = </span><span class="s0">this</span><span class="s1">[kInstance].exports;</span>
        <span class="s1">validateUndefined(_start, </span><span class="s2">'instance.exports._start'</span><span class="s1">);</span>
        <span class="s0">if </span><span class="s1">(_initialize !== undefined) {</span>
            <span class="s1">validateFunction(_initialize, </span><span class="s2">'instance.exports._initialize'</span><span class="s1">);</span>
            <span class="s0">return </span><span class="s1">_initialize();</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">getImportObject() {</span>
        <span class="s0">return </span><span class="s1">{ [</span><span class="s0">this</span><span class="s1">[kBindingName]]: </span><span class="s0">this</span><span class="s1">.wasiImport };</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">wasiReturnOnProcExit(rval) {</span>
    <span class="s0">this</span><span class="s1">[kExitCode] = rval;</span>
    <span class="s3">// eslint-disable-next-line @typescript-eslint/no-throw-literal</span>
    <span class="s0">throw </span><span class="s1">kExitCode;</span>
<span class="s1">}</span>
<span class="s3">/** </span><span class="s5">@public </span><span class="s3">*/</span>
<span class="s1">async </span><span class="s0">function </span><span class="s1">createAsyncWASI(options = kEmptyObject) {</span>
    <span class="s0">const </span><span class="s1">_this = Object.create(WASI.prototype);</span>
    <span class="s0">const </span><span class="s1">{ args, env, preopens, stdio, _WASI } = validateOptions.call(_this, options);</span>
    <span class="s0">if </span><span class="s1">(options.asyncify !== undefined) {</span>
        <span class="s1">validateObject(options.asyncify, </span><span class="s2">'options.asyncify'</span><span class="s1">);</span>
        <span class="s1">validateFunction(options.asyncify.wrapImportFunction, </span><span class="s2">'options.asyncify.wrapImportFunction'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s0">const </span><span class="s1">wrap = </span><span class="s0">await </span><span class="s1">_WASI.createAsync(args, env, preopens, stdio, options.fs, options.print, options.printErr, options.asyncify);</span>
    <span class="s0">const </span><span class="s1">setMemory = wrap._setMemory;</span>
    <span class="s0">delete </span><span class="s1">wrap._setMemory;</span>
    <span class="s1">initWASI.call(_this, setMemory, wrap);</span>
    <span class="s0">if </span><span class="s1">(options.returnOnExit) {</span>
        <span class="s1">wrap.proc_exit = wasiReturnOnProcExit.bind(_this);</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">_this;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">{ Asyncify, Memory, WASI, WebAssemblyMemory, asyncifyLoad, asyncifyLoadSync, createAsyncWASI, extendMemory, load, loadSync, wrapAsyncExport, wrapAsyncImport, wrapExports };</span>
</pre>
</body>
</html>