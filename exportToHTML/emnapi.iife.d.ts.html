<html>
<head>
<title>emnapi.iife.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #0033b3;}
.s2 { color: #8c8c8c; font-style: italic;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
emnapi.iife.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">declare namespace emnapi {</span>

<span class="s1">export </span><span class="s0">type CleanupHookCallbackFunction = number | ((arg: number) =&gt; </span><span class="s1">void</span><span class="s0">);</span>

<span class="s1">export class </span><span class="s0">ConstHandle&lt;S </span><span class="s1">extends </span><span class="s0">undefined | </span><span class="s1">null </span><span class="s0">| boolean | </span><span class="s1">typeof </span><span class="s0">globalThis&gt; </span><span class="s1">extends </span><span class="s0">Handle&lt;S&gt; {</span>
    <span class="s0">constructor(id: number, value: S);</span>
    <span class="s0">dispose(): </span><span class="s1">void</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s1">export class </span><span class="s0">Context {</span>
    <span class="s1">private </span><span class="s0">_isStopping;</span>
    <span class="s1">private </span><span class="s0">_canCallIntoJs;</span>
    <span class="s1">private </span><span class="s0">_suppressDestroy;</span>
    <span class="s0">envStore: Store&lt;Env&gt;;</span>
    <span class="s0">scopeStore: ScopeStore;</span>
    <span class="s0">refStore: Store&lt;Reference&gt;;</span>
    <span class="s0">deferredStore: Store&lt;Deferred&lt;any&gt;&gt;;</span>
    <span class="s0">handleStore: HandleStore;</span>
    <span class="s1">private </span><span class="s0">readonly refCounter?;</span>
    <span class="s1">private </span><span class="s0">readonly cleanupQueue;</span>
    <span class="s0">feature: {</span>
        <span class="s0">supportReflect: boolean;</span>
        <span class="s0">supportFinalizer: boolean;</span>
        <span class="s0">supportWeakSymbol: boolean;</span>
        <span class="s0">supportBigInt: boolean;</span>
        <span class="s0">supportNewFunction: boolean;</span>
        <span class="s0">canSetFunctionName: boolean;</span>
        <span class="s0">setImmediate: (callback: () =&gt; </span><span class="s1">void</span><span class="s0">) =&gt; </span><span class="s1">void</span><span class="s0">;</span>
        <span class="s0">Buffer: BufferCtor | undefined;</span>
        <span class="s0">MessageChannel: {</span>
            <span class="s1">new </span><span class="s0">(): MessageChannel;</span>
            <span class="s0">prototype: MessageChannel;</span>
        <span class="s0">} | undefined;</span>
    <span class="s0">};</span>
    <span class="s0">constructor();</span>
    <span class="s2">/**</span>
     <span class="s2">* Suppress the destroy on `beforeExit` event in Node.js.</span>
     <span class="s2">* Call this method if you want to keep the context and</span>
     <span class="s2">* all associated {</span><span class="s3">@link </span><span class="s2">Env | Env} alive,</span>
     <span class="s2">* this also means that cleanup hooks will not be called.</span>
     <span class="s2">* After call this method, you should call</span>
     <span class="s2">* {</span><span class="s3">@link </span><span class="s2">Context.destroy | `Context.prototype.destroy`} method manually.</span>
     <span class="s2">*/</span>
    <span class="s0">suppressDestroy(): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">getRuntimeVersions(): {</span>
        <span class="s0">version: string;</span>
        <span class="s0">NODE_API_SUPPORTED_VERSION_MAX: Version;</span>
        <span class="s0">NAPI_VERSION_EXPERIMENTAL: Version;</span>
        <span class="s0">NODE_API_DEFAULT_MODULE_API_VERSION: Version;</span>
    <span class="s0">};</span>
    <span class="s0">createNotSupportWeakRefError(api: string, message: string): NotSupportWeakRefError;</span>
    <span class="s0">createNotSupportBufferError(api: string, message: string): NotSupportBufferError;</span>
    <span class="s0">createReference(envObject: Env, handle_id: napi_value, initialRefcount: uint32_t, ownership: ReferenceOwnership): Reference;</span>
    <span class="s0">createReferenceWithData(envObject: Env, handle_id: napi_value, initialRefcount: uint32_t, ownership: ReferenceOwnership, data: void_p): Reference;</span>
    <span class="s0">createReferenceWithFinalizer(envObject: Env, handle_id: napi_value, initialRefcount: uint32_t, ownership: ReferenceOwnership, finalize_callback?: napi_finalize, finalize_data?: void_p, finalize_hint?: void_p): Reference;</span>
    <span class="s0">createDeferred&lt;T = any&gt;(value: IDeferrdValue&lt;T&gt;): Deferred&lt;T&gt;;</span>
    <span class="s0">createEnv(filename: string, moduleApiVersion: number, makeDynCall_vppp: (cb: Ptr) =&gt; (a: Ptr, b: Ptr, c: Ptr) =&gt; </span><span class="s1">void</span><span class="s0">, makeDynCall_vp: (cb: Ptr) =&gt; (a: Ptr) =&gt; </span><span class="s1">void</span><span class="s0">, abort: (msg?: string) =&gt; never, nodeBinding?: any): Env;</span>
    <span class="s0">createTrackedFinalizer(envObject: Env, finalize_callback: napi_finalize, finalize_data: void_p, finalize_hint: void_p): TrackedFinalizer;</span>
    <span class="s0">getCurrentScope(): HandleScope | </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s0">addToCurrentScope&lt;V&gt;(value: V): Handle&lt;V&gt;;</span>
    <span class="s0">openScope(envObject?: Env): HandleScope;</span>
    <span class="s0">closeScope(envObject?: Env, _scope?: HandleScope): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">ensureHandle&lt;S&gt;(value: S): Handle&lt;S&gt;;</span>
    <span class="s0">addCleanupHook(envObject: Env, fn: CleanupHookCallbackFunction, arg: number): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">removeCleanupHook(envObject: Env, fn: CleanupHookCallbackFunction, arg: number): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">runCleanup(): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">increaseWaitingRequestCounter(): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">decreaseWaitingRequestCounter(): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">setCanCallIntoJs(value: boolean): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">setStopping(value: boolean): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">canCallIntoJs(): boolean;</span>
    <span class="s2">/**</span>
     <span class="s2">* Destroy the context and call cleanup hooks.</span>
     <span class="s2">* Associated {</span><span class="s3">@link </span><span class="s2">Env | Env} will be destroyed.</span>
     <span class="s2">*/</span>
    <span class="s0">destroy(): </span><span class="s1">void</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s1">export function </span><span class="s0">createContext(): Context;</span>

<span class="s1">export class </span><span class="s0">Deferred&lt;T = any&gt; </span><span class="s1">implements </span><span class="s0">IStoreValue {</span>
    <span class="s1">static </span><span class="s0">create&lt;T = any&gt;(ctx: Context, value: IDeferrdValue&lt;T&gt;): Deferred;</span>
    <span class="s0">id: number;</span>
    <span class="s0">ctx: Context;</span>
    <span class="s0">value: IDeferrdValue&lt;T&gt;;</span>
    <span class="s0">constructor(ctx: Context, value: IDeferrdValue&lt;T&gt;);</span>
    <span class="s0">resolve(value: T): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">reject(reason?: any): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">dispose(): </span><span class="s1">void</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s1">export class </span><span class="s0">EmnapiError </span><span class="s1">extends </span><span class="s0">Error {</span>
    <span class="s0">constructor(message?: string);</span>
<span class="s0">}</span>

<span class="s1">export </span><span class="s0">abstract </span><span class="s1">class </span><span class="s0">Env </span><span class="s1">implements </span><span class="s0">IStoreValue {</span>
    <span class="s0">readonly ctx: Context;</span>
    <span class="s0">moduleApiVersion: number;</span>
    <span class="s0">makeDynCall_vppp: (cb: Ptr) =&gt; (a: Ptr, b: Ptr, c: Ptr) =&gt; </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">makeDynCall_vp: (cb: Ptr) =&gt; (a: Ptr) =&gt; </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">abort: (msg?: string) =&gt; never;</span>
    <span class="s0">id: number;</span>
    <span class="s0">openHandleScopes: number;</span>
    <span class="s0">instanceData: TrackedFinalizer | </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s0">tryCatch: TryCatch;</span>
    <span class="s0">refs: number;</span>
    <span class="s0">reflist: RefTracker;</span>
    <span class="s0">finalizing_reflist: RefTracker;</span>
    <span class="s0">pendingFinalizers: RefTracker[];</span>
    <span class="s0">lastError: {</span>
        <span class="s0">errorCode: napi_status;</span>
        <span class="s0">engineErrorCode: number;</span>
        <span class="s0">engineReserved: Ptr;</span>
    <span class="s0">};</span>
    <span class="s0">inGcFinalizer: boolean;</span>
    <span class="s0">constructor(ctx: Context, moduleApiVersion: number, makeDynCall_vppp: (cb: Ptr) =&gt; (a: Ptr, b: Ptr, c: Ptr) =&gt; </span><span class="s1">void</span><span class="s0">, makeDynCall_vp: (cb: Ptr) =&gt; (a: Ptr) =&gt; </span><span class="s1">void</span><span class="s0">, abort: (msg?: string) =&gt; never);</span>
    <span class="s2">/** </span><span class="s3">@virtual </span><span class="s2">*/</span>
    <span class="s0">canCallIntoJs(): boolean;</span>
    <span class="s0">terminatedOrTerminating(): boolean;</span>
    <span class="s0">ref(): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">unref(): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">ensureHandle&lt;S&gt;(value: S): Handle&lt;S&gt;;</span>
    <span class="s0">ensureHandleId(value: any): napi_value;</span>
    <span class="s0">clearLastError(): napi_status;</span>
    <span class="s0">setLastError(error_code: napi_status, engine_error_code?: uint32_t, engine_reserved?: void_p): napi_status;</span>
    <span class="s0">getReturnStatus(): napi_status;</span>
    <span class="s0">callIntoModule&lt;T&gt;(fn: (env: Env) =&gt; T, handleException?: (envObject: Env, value: any) =&gt; </span><span class="s1">void</span><span class="s0">): T;</span>
    <span class="s2">/** </span><span class="s3">@virtual </span><span class="s2">*/</span>
    <span class="s0">abstract callFinalizer(cb: napi_finalize, data: void_p, hint: void_p): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">invokeFinalizerFromGC(finalizer: RefTracker): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">checkGCAccess(): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s2">/** </span><span class="s3">@virtual </span><span class="s2">*/</span>
    <span class="s0">enqueueFinalizer(finalizer: RefTracker): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s2">/** </span><span class="s3">@virtual </span><span class="s2">*/</span>
    <span class="s0">dequeueFinalizer(finalizer: RefTracker): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s2">/** </span><span class="s3">@virtual </span><span class="s2">*/</span>
    <span class="s0">deleteMe(): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">dispose(): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s1">private </span><span class="s0">readonly _bindingMap;</span>
    <span class="s0">initObjectBinding&lt;S </span><span class="s1">extends </span><span class="s0">object&gt;(value: S): IReferenceBinding;</span>
    <span class="s0">getObjectBinding&lt;S </span><span class="s1">extends </span><span class="s0">object&gt;(value: S): IReferenceBinding;</span>
    <span class="s0">setInstanceData(data: number, finalize_cb: number, finalize_hint: number): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">getInstanceData(): number;</span>
<span class="s0">}</span>

<span class="s2">/** </span><span class="s3">@public </span><span class="s2">*/</span>
<span class="s1">interface </span><span class="s0">External_2 </span><span class="s1">extends </span><span class="s0">Record&lt;any, any&gt; {</span>
<span class="s0">}</span>

<span class="s2">/** </span><span class="s3">@public </span><span class="s2">*/</span>
<span class="s1">const </span><span class="s0">External_2: {</span>
    <span class="s1">new </span><span class="s0">(value: number | bigint): External_2;</span>
    <span class="s0">prototype: </span><span class="s1">null</span><span class="s0">;</span>
<span class="s0">};</span>
<span class="s1">export </span><span class="s0">{ External_2 as External }</span>

<span class="s1">export class </span><span class="s0">Finalizer {</span>
    <span class="s0">envObject: Env;</span>
    <span class="s1">private </span><span class="s0">_finalizeCallback;</span>
    <span class="s1">private </span><span class="s0">_finalizeData;</span>
    <span class="s1">private </span><span class="s0">_finalizeHint;</span>
    <span class="s1">private </span><span class="s0">_makeDynCall_vppp;</span>
    <span class="s0">constructor(envObject: Env, _finalizeCallback?: napi_finalize, _finalizeData?: void_p, _finalizeHint?: void_p);</span>
    <span class="s0">callback(): napi_finalize;</span>
    <span class="s0">data(): void_p;</span>
    <span class="s0">hint(): void_p;</span>
    <span class="s0">resetEnv(): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">resetFinalizer(): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">callFinalizer(): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">dispose(): </span><span class="s1">void</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s1">export function </span><span class="s0">getDefaultContext(): Context;</span>

<span class="s2">/** </span><span class="s3">@public </span><span class="s2">*/</span>
<span class="s1">export function </span><span class="s0">getExternalValue(external: External_2): number | bigint;</span>

<span class="s1">export class </span><span class="s0">Handle&lt;S&gt; {</span>
    <span class="s0">id: number;</span>
    <span class="s0">value: S;</span>
    <span class="s0">constructor(id: number, value: S);</span>
    <span class="s0">data(): void_p;</span>
    <span class="s0">isNumber(): boolean;</span>
    <span class="s0">isBigInt(): boolean;</span>
    <span class="s0">isString(): boolean;</span>
    <span class="s0">isFunction(): boolean;</span>
    <span class="s0">isExternal(): boolean;</span>
    <span class="s0">isObject(): boolean;</span>
    <span class="s0">isArray(): boolean;</span>
    <span class="s0">isArrayBuffer(): boolean;</span>
    <span class="s0">isTypedArray(): boolean;</span>
    <span class="s0">isBuffer(BufferConstructor?: BufferCtor): boolean;</span>
    <span class="s0">isDataView(): boolean;</span>
    <span class="s0">isDate(): boolean;</span>
    <span class="s0">isPromise(): boolean;</span>
    <span class="s0">isBoolean(): boolean;</span>
    <span class="s0">isUndefined(): boolean;</span>
    <span class="s0">isSymbol(): boolean;</span>
    <span class="s0">isNull(): boolean;</span>
    <span class="s0">dispose(): </span><span class="s1">void</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s1">export class </span><span class="s0">HandleScope {</span>
    <span class="s0">handleStore: HandleStore;</span>
    <span class="s0">id: number;</span>
    <span class="s0">parent: HandleScope | </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s0">child: HandleScope | </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s0">start: number;</span>
    <span class="s0">end: number;</span>
    <span class="s1">private </span><span class="s0">_escapeCalled;</span>
    <span class="s0">callbackInfo: ICallbackInfo;</span>
    <span class="s0">constructor(handleStore: HandleStore, id: number, parentScope: HandleScope | </span><span class="s1">null</span><span class="s0">, start: number, end?: number);</span>
    <span class="s0">add&lt;V&gt;(value: V): Handle&lt;V&gt;;</span>
    <span class="s0">addExternal(data: void_p): Handle&lt;object&gt;;</span>
    <span class="s0">dispose(): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">escape(handle: number): Handle&lt;any&gt; | </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s0">escapeCalled(): boolean;</span>
<span class="s0">}</span>

<span class="s1">export class </span><span class="s0">HandleStore {</span>
    <span class="s1">static </span><span class="s0">UNDEFINED: ConstHandle&lt;undefined&gt;;</span>
    <span class="s1">static </span><span class="s0">NULL: ConstHandle&lt;</span><span class="s1">null</span><span class="s0">&gt;;</span>
    <span class="s1">static </span><span class="s0">FALSE: ConstHandle&lt;</span><span class="s1">false</span><span class="s0">&gt;;</span>
    <span class="s1">static </span><span class="s0">TRUE: ConstHandle&lt;</span><span class="s1">true</span><span class="s0">&gt;;</span>
    <span class="s1">static </span><span class="s0">GLOBAL: ConstHandle&lt;</span><span class="s1">typeof </span><span class="s0">globalThis&gt;;</span>
    <span class="s1">static </span><span class="s0">MIN_ID: </span><span class="s4">6</span><span class="s0">;</span>
    <span class="s1">private </span><span class="s0">readonly _values;</span>
    <span class="s1">private </span><span class="s0">_next;</span>
    <span class="s0">push&lt;S&gt;(value: S): Handle&lt;S&gt;;</span>
    <span class="s0">erase(start: number, end: number): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">get(id: Ptr): Handle&lt;any&gt; | undefined;</span>
    <span class="s0">swap(a: number, b: number): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">dispose(): </span><span class="s1">void</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s1">export interface </span><span class="s0">ICallbackInfo {</span>
    <span class="s0">thiz: any;</span>
    <span class="s0">data: void_p;</span>
    <span class="s0">args: ArrayLike&lt;any&gt;;</span>
    <span class="s0">fn: Function;</span>
<span class="s0">}</span>

<span class="s1">export interface </span><span class="s0">IDeferrdValue&lt;T = any&gt; {</span>
    <span class="s0">resolve: (value: T) =&gt; </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">reject: (reason?: any) =&gt; </span><span class="s1">void</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s1">export interface </span><span class="s0">IReferenceBinding {</span>
    <span class="s0">wrapped: number;</span>
    <span class="s0">tag: Uint32Array | </span><span class="s1">null</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s2">/** </span><span class="s3">@public </span><span class="s2">*/</span>
<span class="s1">export function </span><span class="s0">isExternal(object: unknown): object is External_2;</span>

<span class="s1">export function </span><span class="s0">isReferenceType(v: any): v is object;</span>

<span class="s1">export interface </span><span class="s0">IStoreValue {</span>
    <span class="s0">id: number;</span>
    <span class="s0">dispose(): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">[x: string]: any;</span>
<span class="s0">}</span>

<span class="s1">export const </span><span class="s0">NAPI_VERSION_EXPERIMENTAL = Version.NAPI_VERSION_EXPERIMENTAL;</span>

<span class="s1">export const </span><span class="s0">NODE_API_DEFAULT_MODULE_API_VERSION = Version.NODE_API_DEFAULT_MODULE_API_VERSION;</span>

<span class="s1">export const </span><span class="s0">NODE_API_SUPPORTED_VERSION_MAX = Version.NODE_API_SUPPORTED_VERSION_MAX;</span>

<span class="s1">export const </span><span class="s0">NODE_API_SUPPORTED_VERSION_MIN = Version.NODE_API_SUPPORTED_VERSION_MIN;</span>

<span class="s1">export class </span><span class="s0">NodeEnv </span><span class="s1">extends </span><span class="s0">Env {</span>
    <span class="s0">filename: string;</span>
    <span class="s1">private </span><span class="s0">readonly nodeBinding?;</span>
    <span class="s0">destructing: boolean;</span>
    <span class="s0">finalizationScheduled: boolean;</span>
    <span class="s0">constructor(ctx: Context, filename: string, moduleApiVersion: number, makeDynCall_vppp: (cb: Ptr) =&gt; (a: Ptr, b: Ptr, c: Ptr) =&gt; </span><span class="s1">void</span><span class="s0">, makeDynCall_vp: (cb: Ptr) =&gt; (a: Ptr) =&gt; </span><span class="s1">void</span><span class="s0">, abort: (msg?: string) =&gt; never, nodeBinding?: any);</span>
    <span class="s0">deleteMe(): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">canCallIntoJs(): boolean;</span>
    <span class="s0">triggerFatalException(err: any): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">callbackIntoModule&lt;T&gt;(enforceUncaughtExceptionPolicy: boolean, fn: (env: Env) =&gt; T): T;</span>
    <span class="s0">callFinalizer(cb: napi_finalize, data: void_p, hint: void_p): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">callFinalizerInternal(forceUncaught: int, cb: napi_finalize, data: void_p, hint: void_p): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">enqueueFinalizer(finalizer: RefTracker): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">drainFinalizerQueue(): </span><span class="s1">void</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s1">export class </span><span class="s0">NotSupportBufferError </span><span class="s1">extends </span><span class="s0">EmnapiError {</span>
    <span class="s0">constructor(api: string, message: string);</span>
<span class="s0">}</span>

<span class="s1">export class </span><span class="s0">NotSupportWeakRefError </span><span class="s1">extends </span><span class="s0">EmnapiError {</span>
    <span class="s0">constructor(api: string, message: string);</span>
<span class="s0">}</span>

<span class="s1">export class </span><span class="s0">Persistent&lt;T&gt; {</span>
    <span class="s1">private </span><span class="s0">_ref;</span>
    <span class="s1">private </span><span class="s0">_param;</span>
    <span class="s1">private </span><span class="s0">_callback;</span>
    <span class="s1">private static </span><span class="s0">readonly _registry;</span>
    <span class="s0">constructor(value: T);</span>
    <span class="s0">setWeak&lt;P&gt;(param: P, callback: (param: P) =&gt; </span><span class="s1">void</span><span class="s0">): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">clearWeak(): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">reset(): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">isEmpty(): boolean;</span>
    <span class="s0">deref(): T | undefined;</span>
<span class="s0">}</span>

<span class="s1">export class </span><span class="s0">Reference </span><span class="s1">extends </span><span class="s0">RefTracker </span><span class="s1">implements </span><span class="s0">IStoreValue {</span>
    <span class="s1">private static </span><span class="s0">weakCallback;</span>
    <span class="s0">id: number;</span>
    <span class="s0">envObject: Env;</span>
    <span class="s1">private </span><span class="s0">readonly canBeWeak;</span>
    <span class="s1">private </span><span class="s0">_refcount;</span>
    <span class="s1">private </span><span class="s0">readonly _ownership;</span>
    <span class="s0">persistent: Persistent&lt;object&gt;;</span>
    <span class="s1">static </span><span class="s0">create(envObject: Env, handle_id: napi_value, initialRefcount: uint32_t, ownership: ReferenceOwnership, _unused1?: void_p, _unused2?: void_p, _unused3?: void_p): Reference;</span>
    <span class="s1">protected </span><span class="s0">constructor(envObject: Env, handle_id: napi_value, initialRefcount: uint32_t, ownership: ReferenceOwnership);</span>
    <span class="s0">ref(): number;</span>
    <span class="s0">unref(): number;</span>
    <span class="s0">get(envObject?: Env): napi_value;</span>
    <span class="s2">/** </span><span class="s3">@virtual </span><span class="s2">*/</span>
    <span class="s0">resetFinalizer(): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s2">/** </span><span class="s3">@virtual </span><span class="s2">*/</span>
    <span class="s0">data(): void_p;</span>
    <span class="s0">refcount(): number;</span>
    <span class="s0">ownership(): ReferenceOwnership;</span>
    <span class="s2">/** </span><span class="s3">@virtual </span><span class="s2">*/</span>
    <span class="s1">protected </span><span class="s0">callUserFinalizer(): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s2">/** </span><span class="s3">@virtual </span><span class="s2">*/</span>
    <span class="s1">protected </span><span class="s0">invokeFinalizerFromGC(): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s1">private </span><span class="s0">_setWeak;</span>
    <span class="s0">finalize(): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">dispose(): </span><span class="s1">void</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s1">export enum </span><span class="s0">ReferenceOwnership {</span>
    <span class="s0">kRuntime = </span><span class="s4">0</span><span class="s0">,</span>
    <span class="s0">kUserland = </span><span class="s4">1</span>
<span class="s0">}</span>

<span class="s1">export class </span><span class="s0">ReferenceWithData </span><span class="s1">extends </span><span class="s0">Reference {</span>
    <span class="s1">private </span><span class="s0">readonly _data;</span>
    <span class="s1">static </span><span class="s0">create(envObject: Env, value: napi_value, initialRefcount: uint32_t, ownership: ReferenceOwnership, data: void_p): ReferenceWithData;</span>
    <span class="s1">private </span><span class="s0">constructor();</span>
    <span class="s0">data(): void_p;</span>
<span class="s0">}</span>

<span class="s1">export class </span><span class="s0">ReferenceWithFinalizer </span><span class="s1">extends </span><span class="s0">Reference {</span>
    <span class="s1">private </span><span class="s0">_finalizer;</span>
    <span class="s1">static </span><span class="s0">create(envObject: Env, value: napi_value, initialRefcount: uint32_t, ownership: ReferenceOwnership, finalize_callback: napi_finalize, finalize_data: void_p, finalize_hint: void_p): ReferenceWithFinalizer;</span>
    <span class="s1">private </span><span class="s0">constructor();</span>
    <span class="s0">resetFinalizer(): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">data(): void_p;</span>
    <span class="s1">protected </span><span class="s0">callUserFinalizer(): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s1">protected </span><span class="s0">invokeFinalizerFromGC(): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">dispose(): </span><span class="s1">void</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s1">export class </span><span class="s0">RefTracker {</span>
    <span class="s2">/** </span><span class="s3">@virtual </span><span class="s2">*/</span>
    <span class="s0">dispose(): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s2">/** </span><span class="s3">@virtual </span><span class="s2">*/</span>
    <span class="s0">finalize(): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s1">private </span><span class="s0">_next;</span>
    <span class="s1">private </span><span class="s0">_prev;</span>
    <span class="s0">link(list: RefTracker): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">unlink(): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s1">static </span><span class="s0">finalizeAll(list: RefTracker): </span><span class="s1">void</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s1">export class </span><span class="s0">ScopeStore {</span>
    <span class="s1">private </span><span class="s0">readonly _rootScope;</span>
    <span class="s0">currentScope: HandleScope;</span>
    <span class="s1">private </span><span class="s0">readonly _values;</span>
    <span class="s0">constructor();</span>
    <span class="s0">get(id: number): HandleScope | undefined;</span>
    <span class="s0">openScope(handleStore: HandleStore): HandleScope;</span>
    <span class="s0">closeScope(): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">dispose(): </span><span class="s1">void</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s1">export class </span><span class="s0">Store&lt;V </span><span class="s1">extends </span><span class="s0">IStoreValue&gt; {</span>
    <span class="s1">protected </span><span class="s0">_values: Array&lt;V | undefined&gt;;</span>
    <span class="s1">private </span><span class="s0">_freeList;</span>
    <span class="s1">private </span><span class="s0">_size;</span>
    <span class="s0">constructor();</span>
    <span class="s0">add(value: V): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">get(id: Ptr): V | undefined;</span>
    <span class="s0">has(id: Ptr): boolean;</span>
    <span class="s0">remove(id: Ptr): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">dispose(): </span><span class="s1">void</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s1">export class </span><span class="s0">TrackedFinalizer </span><span class="s1">extends </span><span class="s0">RefTracker {</span>
    <span class="s1">private </span><span class="s0">_finalizer;</span>
    <span class="s1">static </span><span class="s0">create(envObject: Env, finalize_callback: napi_finalize, finalize_data: void_p, finalize_hint: void_p): TrackedFinalizer;</span>
    <span class="s1">private </span><span class="s0">constructor();</span>
    <span class="s0">data(): void_p;</span>
    <span class="s0">dispose(): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">finalize(): </span><span class="s1">void</span><span class="s0">;</span>
<span class="s0">}</span>

<span class="s1">export class </span><span class="s0">TryCatch {</span>
    <span class="s1">private </span><span class="s0">_exception;</span>
    <span class="s1">private </span><span class="s0">_caught;</span>
    <span class="s0">isEmpty(): boolean;</span>
    <span class="s0">hasCaught(): boolean;</span>
    <span class="s0">exception(): any;</span>
    <span class="s0">setError(err: any): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">reset(): </span><span class="s1">void</span><span class="s0">;</span>
    <span class="s0">extractException(): any;</span>
<span class="s0">}</span>

<span class="s1">export const </span><span class="s0">version: string;</span>




<span class="s0">}</span></pre>
</body>
</html>