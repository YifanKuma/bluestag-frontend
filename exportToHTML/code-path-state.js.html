<html>
<head>
<title>code-path-state.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #8c8c8c; font-style: italic;}
.s2 { color: #080808;}
.s3 { color: #067d17;}
.s4 { color: #0033b3;}
.s5 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
code-path-state.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@fileoverview </span><span class="s0">A class to manage state of generating a code path.</span>
 <span class="s0">* </span><span class="s1">@author </span><span class="s0">Toru Nagashima</span>
 <span class="s0">*/</span>

<span class="s3">&quot;use strict&quot;</span><span class="s2">;</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Requirements</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s4">const </span><span class="s2">CodePathSegment = require(</span><span class="s3">&quot;./code-path-segment&quot;</span><span class="s2">),</span>
	<span class="s2">ForkContext = require(</span><span class="s3">&quot;./fork-context&quot;</span><span class="s2">);</span>

<span class="s0">//-----------------------------------------------------------------------------</span>
<span class="s0">// Contexts</span>
<span class="s0">//-----------------------------------------------------------------------------</span>

<span class="s0">/**</span>
 <span class="s0">* Represents the context in which a `break` statement can be used.</span>
 <span class="s0">*</span>
 <span class="s0">* A `break` statement without a label is only valid in a few places in</span>
 <span class="s0">* JavaScript: any type of loop or a `switch` statement. Otherwise, `break`</span>
 <span class="s0">* without a label causes a syntax error. For these contexts, `breakable` is</span>
 <span class="s0">* set to `true` to indicate that a `break` without a label is valid.</span>
 <span class="s0">*</span>
 <span class="s0">* However, a `break` statement with a label is also valid inside of a labeled</span>
 <span class="s0">* statement. For example, this is valid:</span>
 <span class="s0">*</span>
 <span class="s0">*     a : {</span>
 <span class="s0">*         break a;</span>
 <span class="s0">*     }</span>
 <span class="s0">*</span>
 <span class="s0">* The `breakable` property is set false for labeled statements to indicate</span>
 <span class="s0">* that `break` without a label is invalid.</span>
 <span class="s0">*/</span>
<span class="s4">class </span><span class="s2">BreakContext {</span>
	<span class="s0">/**</span>
	 <span class="s0">* Creates a new instance.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{BreakContext} upperContext The previous `BreakContext`.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean} breakable Indicates if we are inside a statement where</span>
	 <span class="s0">*      `break` without a label will exit the statement.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|null} label The label for the statement.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ForkContext} forkContext The current fork context.</span>
	 <span class="s0">*/</span>
	<span class="s2">constructor(upperContext, breakable, label, forkContext) {</span>
		<span class="s0">/**</span>
		 <span class="s0">* The previous `BreakContext`</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{BreakContext}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.upper = upperContext;</span>

		<span class="s0">/**</span>
		 <span class="s0">* Indicates if we are inside a statement where `break` without a label</span>
		 <span class="s0">* will exit the statement.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{boolean}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.breakable = breakable;</span>

		<span class="s0">/**</span>
		 <span class="s0">* The label associated with the statement.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{string|null}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.label = label;</span>

		<span class="s0">/**</span>
		 <span class="s0">* The fork context for the `break`.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{ForkContext}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.brokenForkContext = ForkContext.newEmpty(forkContext);</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Represents the context for `ChainExpression` nodes.</span>
 <span class="s0">*/</span>
<span class="s4">class </span><span class="s2">ChainContext {</span>
	<span class="s0">/**</span>
	 <span class="s0">* Creates a new instance.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ChainContext} upperContext The previous `ChainContext`.</span>
	 <span class="s0">*/</span>
	<span class="s2">constructor(upperContext) {</span>
		<span class="s0">/**</span>
		 <span class="s0">* The previous `ChainContext`</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{ChainContext}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.upper = upperContext;</span>

		<span class="s0">/**</span>
		 <span class="s0">* The number of choice contexts inside of the `ChainContext`.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{number}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.choiceContextCount = </span><span class="s5">0</span><span class="s2">;</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Represents a choice in the code path.</span>
 <span class="s0">*</span>
 <span class="s0">* Choices are created by logical operators such as `&amp;&amp;`, loops, conditionals,</span>
 <span class="s0">* and `if` statements. This is the point at which the code path has a choice of</span>
 <span class="s0">* which direction to go.</span>
 <span class="s0">*</span>
 <span class="s0">* The result of a choice might be in the left (test) expression of another choice,</span>
 <span class="s0">* and in that case, may create a new fork. For example, `a || b` is a choice</span>
 <span class="s0">* but does not create a new fork because the result of the expression is</span>
 <span class="s0">* not used as the test expression in another expression. In this case,</span>
 <span class="s0">* `isForkingAsResult` is false. In the expression `a || b || c`, the `a || b`</span>
 <span class="s0">* expression appears as the test expression for `|| c`, so the</span>
 <span class="s0">* result of `a || b` creates a fork because execution may or may not</span>
 <span class="s0">* continue to `|| c`. `isForkingAsResult` for `a || b` in this case is true</span>
 <span class="s0">* while `isForkingAsResult` for `|| c` is false. (`isForkingAsResult` is always</span>
 <span class="s0">* false for `if` statements, conditional expressions, and loops.)</span>
 <span class="s0">*</span>
 <span class="s0">* All of the choices except one (`??`) operate on a true/false fork, meaning if</span>
 <span class="s0">* true go one way and if false go the other (tracked by `trueForkContext` and</span>
 <span class="s0">* `falseForkContext`). The `??` operator doesn't operate on true/false because</span>
 <span class="s0">* the left expression is evaluated to be nullish or not, so only if nullish do</span>
 <span class="s0">* we fork to the right expression (tracked by `nullishForkContext`).</span>
 <span class="s0">*/</span>
<span class="s4">class </span><span class="s2">ChoiceContext {</span>
	<span class="s0">/**</span>
	 <span class="s0">* Creates a new instance.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ChoiceContext} upperContext The previous `ChoiceContext`.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} kind The kind of choice. If it's a logical or assignment expression, this</span>
	 <span class="s0">*      is `&quot;&amp;&amp;&quot;` or `&quot;||&quot;` or `&quot;??&quot;`; if it's an `if` statement or</span>
	 <span class="s0">*      conditional expression, this is `&quot;test&quot;`; otherwise, this is `&quot;loop&quot;`.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean} isForkingAsResult Indicates if the result of the choice</span>
	 <span class="s0">*      creates a fork.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ForkContext} forkContext The containing `ForkContext`.</span>
	 <span class="s0">*/</span>
	<span class="s2">constructor(upperContext, kind, isForkingAsResult, forkContext) {</span>
		<span class="s0">/**</span>
		 <span class="s0">* The previous `ChoiceContext`</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{ChoiceContext}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.upper = upperContext;</span>

		<span class="s0">/**</span>
		 <span class="s0">* The kind of choice. If it's a logical or assignment expression, this</span>
		 <span class="s0">* is `&quot;&amp;&amp;&quot;` or `&quot;||&quot;` or `&quot;??&quot;`; if it's an `if` statement or</span>
		 <span class="s0">* conditional expression, this is `&quot;test&quot;`; otherwise, this is `&quot;loop&quot;`.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{string}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.kind = kind;</span>

		<span class="s0">/**</span>
		 <span class="s0">* Indicates if the result of the choice forks the code path.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{boolean}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.isForkingAsResult = isForkingAsResult;</span>

		<span class="s0">/**</span>
		 <span class="s0">* The fork context for the `true` path of the choice.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{ForkContext}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.trueForkContext = ForkContext.newEmpty(forkContext);</span>

		<span class="s0">/**</span>
		 <span class="s0">* The fork context for the `false` path of the choice.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{ForkContext}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.falseForkContext = ForkContext.newEmpty(forkContext);</span>

		<span class="s0">/**</span>
		 <span class="s0">* The fork context for when the choice result is `null` or `undefined`.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{ForkContext}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.nullishForkContext = ForkContext.newEmpty(forkContext);</span>

		<span class="s0">/**</span>
		 <span class="s0">* Indicates if any of `trueForkContext`, `falseForkContext`, or</span>
		 <span class="s0">* `nullishForkContext` have been updated with segments from a child context.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{boolean}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.processed = </span><span class="s4">false</span><span class="s2">;</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Base class for all loop contexts.</span>
 <span class="s0">*/</span>
<span class="s4">class </span><span class="s2">LoopContextBase {</span>
	<span class="s0">/**</span>
	 <span class="s0">* Creates a new instance.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{LoopContext|null} upperContext The previous `LoopContext`.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} type The AST node's `type` for the loop.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|null} label The label for the loop from an enclosing `LabeledStatement`.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{BreakContext} breakContext The context for breaking the loop.</span>
	 <span class="s0">*/</span>
	<span class="s2">constructor(upperContext, type, label, breakContext) {</span>
		<span class="s0">/**</span>
		 <span class="s0">* The previous `LoopContext`.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{LoopContext}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.upper = upperContext;</span>

		<span class="s0">/**</span>
		 <span class="s0">* The AST node's `type` for the loop.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{string}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.type = type;</span>

		<span class="s0">/**</span>
		 <span class="s0">* The label for the loop from an enclosing `LabeledStatement`.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{string|null}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.label = label;</span>

		<span class="s0">/**</span>
		 <span class="s0">* The fork context for when `break` is encountered.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{ForkContext}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.brokenForkContext = breakContext.brokenForkContext;</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Represents the context for a `while` loop.</span>
 <span class="s0">*/</span>
<span class="s4">class </span><span class="s2">WhileLoopContext </span><span class="s4">extends </span><span class="s2">LoopContextBase {</span>
	<span class="s0">/**</span>
	 <span class="s0">* Creates a new instance.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{LoopContext|null} upperContext The previous `LoopContext`.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|null} label The label for the loop from an enclosing `LabeledStatement`.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{BreakContext} breakContext The context for breaking the loop.</span>
	 <span class="s0">*/</span>
	<span class="s2">constructor(upperContext, label, breakContext) {</span>
		<span class="s4">super</span><span class="s2">(upperContext, </span><span class="s3">&quot;WhileStatement&quot;</span><span class="s2">, label, breakContext);</span>

		<span class="s0">/**</span>
		 <span class="s0">* The hardcoded literal boolean test condition for</span>
		 <span class="s0">* the loop. Used to catch infinite or skipped loops.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{boolean|undefined}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.test = </span><span class="s4">void </span><span class="s5">0</span><span class="s2">;</span>

		<span class="s0">/**</span>
		 <span class="s0">* The segments representing the test condition where `continue` will</span>
		 <span class="s0">* jump to. The test condition will typically have just one segment but</span>
		 <span class="s0">* it's possible for there to be more than one.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;|null}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.continueDestSegments = </span><span class="s4">null</span><span class="s2">;</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Represents the context for a `do-while` loop.</span>
 <span class="s0">*/</span>
<span class="s4">class </span><span class="s2">DoWhileLoopContext </span><span class="s4">extends </span><span class="s2">LoopContextBase {</span>
	<span class="s0">/**</span>
	 <span class="s0">* Creates a new instance.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{LoopContext|null} upperContext The previous `LoopContext`.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|null} label The label for the loop from an enclosing `LabeledStatement`.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{BreakContext} breakContext The context for breaking the loop.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ForkContext} forkContext The enclosing fork context.</span>
	 <span class="s0">*/</span>
	<span class="s2">constructor(upperContext, label, breakContext, forkContext) {</span>
		<span class="s4">super</span><span class="s2">(upperContext, </span><span class="s3">&quot;DoWhileStatement&quot;</span><span class="s2">, label, breakContext);</span>

		<span class="s0">/**</span>
		 <span class="s0">* The hardcoded literal boolean test condition for</span>
		 <span class="s0">* the loop. Used to catch infinite or skipped loops.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{boolean|undefined}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.test = </span><span class="s4">void </span><span class="s5">0</span><span class="s2">;</span>

		<span class="s0">/**</span>
		 <span class="s0">* The segments at the start of the loop body. This is the only loop</span>
		 <span class="s0">* where the test comes at the end, so the first iteration always</span>
		 <span class="s0">* happens and we need a reference to the first statements.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;|null}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.entrySegments = </span><span class="s4">null</span><span class="s2">;</span>

		<span class="s0">/**</span>
		 <span class="s0">* The fork context to follow when a `continue` is found.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{ForkContext}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.continueForkContext = ForkContext.newEmpty(forkContext);</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Represents the context for a `for` loop.</span>
 <span class="s0">*/</span>
<span class="s4">class </span><span class="s2">ForLoopContext </span><span class="s4">extends </span><span class="s2">LoopContextBase {</span>
	<span class="s0">/**</span>
	 <span class="s0">* Creates a new instance.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{LoopContext|null} upperContext The previous `LoopContext`.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|null} label The label for the loop from an enclosing `LabeledStatement`.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{BreakContext} breakContext The context for breaking the loop.</span>
	 <span class="s0">*/</span>
	<span class="s2">constructor(upperContext, label, breakContext) {</span>
		<span class="s4">super</span><span class="s2">(upperContext, </span><span class="s3">&quot;ForStatement&quot;</span><span class="s2">, label, breakContext);</span>

		<span class="s0">/**</span>
		 <span class="s0">* The hardcoded literal boolean test condition for</span>
		 <span class="s0">* the loop. Used to catch infinite or skipped loops.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{boolean|undefined}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.test = </span><span class="s4">void </span><span class="s5">0</span><span class="s2">;</span>

		<span class="s0">/**</span>
		 <span class="s0">* The end of the init expression. This may change during the lifetime</span>
		 <span class="s0">* of the instance as we traverse the loop because some loops don't have</span>
		 <span class="s0">* an init expression.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;|null}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.endOfInitSegments = </span><span class="s4">null</span><span class="s2">;</span>

		<span class="s0">/**</span>
		 <span class="s0">* The start of the test expression. This may change during the lifetime</span>
		 <span class="s0">* of the instance as we traverse the loop because some loops don't have</span>
		 <span class="s0">* a test expression.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;|null}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.testSegments = </span><span class="s4">null</span><span class="s2">;</span>

		<span class="s0">/**</span>
		 <span class="s0">* The end of the test expression. This may change during the lifetime</span>
		 <span class="s0">* of the instance as we traverse the loop because some loops don't have</span>
		 <span class="s0">* a test expression.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;|null}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.endOfTestSegments = </span><span class="s4">null</span><span class="s2">;</span>

		<span class="s0">/**</span>
		 <span class="s0">* The start of the update expression. This may change during the lifetime</span>
		 <span class="s0">* of the instance as we traverse the loop because some loops don't have</span>
		 <span class="s0">* an update expression.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;|null}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.updateSegments = </span><span class="s4">null</span><span class="s2">;</span>

		<span class="s0">/**</span>
		 <span class="s0">* The end of the update expression. This may change during the lifetime</span>
		 <span class="s0">* of the instance as we traverse the loop because some loops don't have</span>
		 <span class="s0">* an update expression.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;|null}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.endOfUpdateSegments = </span><span class="s4">null</span><span class="s2">;</span>

		<span class="s0">/**</span>
		 <span class="s0">* The segments representing the test condition where `continue` will</span>
		 <span class="s0">* jump to. The test condition will typically have just one segment but</span>
		 <span class="s0">* it's possible for there to be more than one. This may change during the</span>
		 <span class="s0">* lifetime of the instance as we traverse the loop because some loops</span>
		 <span class="s0">* don't have an update expression. When there is an update expression, this</span>
		 <span class="s0">* will end up pointing to that expression; otherwise it will end up pointing</span>
		 <span class="s0">* to the test expression.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;|null}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.continueDestSegments = </span><span class="s4">null</span><span class="s2">;</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Represents the context for a `for-in` loop.</span>
 <span class="s0">*</span>
 <span class="s0">* Terminology:</span>
 <span class="s0">* - &quot;left&quot; means the part of the loop to the left of the `in` keyword. For</span>
 <span class="s0">*   example, in `for (var x in y)`, the left is `var x`.</span>
 <span class="s0">* - &quot;right&quot; means the part of the loop to the right of the `in` keyword. For</span>
 <span class="s0">*   example, in `for (var x in y)`, the right is `y`.</span>
 <span class="s0">*/</span>
<span class="s4">class </span><span class="s2">ForInLoopContext </span><span class="s4">extends </span><span class="s2">LoopContextBase {</span>
	<span class="s0">/**</span>
	 <span class="s0">* Creates a new instance.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{LoopContext|null} upperContext The previous `LoopContext`.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|null} label The label for the loop from an enclosing `LabeledStatement`.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{BreakContext} breakContext The context for breaking the loop.</span>
	 <span class="s0">*/</span>
	<span class="s2">constructor(upperContext, label, breakContext) {</span>
		<span class="s4">super</span><span class="s2">(upperContext, </span><span class="s3">&quot;ForInStatement&quot;</span><span class="s2">, label, breakContext);</span>

		<span class="s0">/**</span>
		 <span class="s0">* The segments that came immediately before the start of the loop.</span>
		 <span class="s0">* This allows you to traverse backwards out of the loop into the</span>
		 <span class="s0">* surrounding code. This is necessary to evaluate the right expression</span>
		 <span class="s0">* correctly, as it must be evaluated in the same way as the left</span>
		 <span class="s0">* expression, but the pointer to these segments would otherwise be</span>
		 <span class="s0">* lost if not stored on the instance. Once the right expression has</span>
		 <span class="s0">* been evaluated, this property is no longer used.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;|null}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.prevSegments = </span><span class="s4">null</span><span class="s2">;</span>

		<span class="s0">/**</span>
		 <span class="s0">* Segments representing the start of everything to the left of the</span>
		 <span class="s0">* `in` keyword. This can be used to move forward towards</span>
		 <span class="s0">* `endOfLeftSegments`. `leftSegments` and `endOfLeftSegments` are</span>
		 <span class="s0">* effectively the head and tail of a doubly-linked list.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;|null}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.leftSegments = </span><span class="s4">null</span><span class="s2">;</span>

		<span class="s0">/**</span>
		 <span class="s0">* Segments representing the end of everything to the left of the</span>
		 <span class="s0">* `in` keyword. This can be used to move backward towards `leftSegments`.</span>
		 <span class="s0">* `leftSegments` and `endOfLeftSegments` are effectively the head</span>
		 <span class="s0">* and tail of a doubly-linked list.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;|null}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.endOfLeftSegments = </span><span class="s4">null</span><span class="s2">;</span>

		<span class="s0">/**</span>
		 <span class="s0">* The segments representing the left expression where `continue` will</span>
		 <span class="s0">* jump to. In `for-in` loops, `continue` must always re-execute the</span>
		 <span class="s0">* left expression each time through the loop. This contains the same</span>
		 <span class="s0">* segments as `leftSegments`, but is duplicated here so each loop</span>
		 <span class="s0">* context has the same property pointing to where `continue` should</span>
		 <span class="s0">* end up.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;|null}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.continueDestSegments = </span><span class="s4">null</span><span class="s2">;</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Represents the context for a `for-of` loop.</span>
 <span class="s0">*/</span>
<span class="s4">class </span><span class="s2">ForOfLoopContext </span><span class="s4">extends </span><span class="s2">LoopContextBase {</span>
	<span class="s0">/**</span>
	 <span class="s0">* Creates a new instance.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{LoopContext|null} upperContext The previous `LoopContext`.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|null} label The label for the loop from an enclosing `LabeledStatement`.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{BreakContext} breakContext The context for breaking the loop.</span>
	 <span class="s0">*/</span>
	<span class="s2">constructor(upperContext, label, breakContext) {</span>
		<span class="s4">super</span><span class="s2">(upperContext, </span><span class="s3">&quot;ForOfStatement&quot;</span><span class="s2">, label, breakContext);</span>

		<span class="s0">/**</span>
		 <span class="s0">* The segments that came immediately before the start of the loop.</span>
		 <span class="s0">* This allows you to traverse backwards out of the loop into the</span>
		 <span class="s0">* surrounding code. This is necessary to evaluate the right expression</span>
		 <span class="s0">* correctly, as it must be evaluated in the same way as the left</span>
		 <span class="s0">* expression, but the pointer to these segments would otherwise be</span>
		 <span class="s0">* lost if not stored on the instance. Once the right expression has</span>
		 <span class="s0">* been evaluated, this property is no longer used.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;|null}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.prevSegments = </span><span class="s4">null</span><span class="s2">;</span>

		<span class="s0">/**</span>
		 <span class="s0">* Segments representing the start of everything to the left of the</span>
		 <span class="s0">* `of` keyword. This can be used to move forward towards</span>
		 <span class="s0">* `endOfLeftSegments`. `leftSegments` and `endOfLeftSegments` are</span>
		 <span class="s0">* effectively the head and tail of a doubly-linked list.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;|null}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.leftSegments = </span><span class="s4">null</span><span class="s2">;</span>

		<span class="s0">/**</span>
		 <span class="s0">* Segments representing the end of everything to the left of the</span>
		 <span class="s0">* `of` keyword. This can be used to move backward towards `leftSegments`.</span>
		 <span class="s0">* `leftSegments` and `endOfLeftSegments` are effectively the head</span>
		 <span class="s0">* and tail of a doubly-linked list.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;|null}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.endOfLeftSegments = </span><span class="s4">null</span><span class="s2">;</span>

		<span class="s0">/**</span>
		 <span class="s0">* The segments representing the left expression where `continue` will</span>
		 <span class="s0">* jump to. In `for-in` loops, `continue` must always re-execute the</span>
		 <span class="s0">* left expression each time through the loop. This contains the same</span>
		 <span class="s0">* segments as `leftSegments`, but is duplicated here so each loop</span>
		 <span class="s0">* context has the same property pointing to where `continue` should</span>
		 <span class="s0">* end up.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;|null}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.continueDestSegments = </span><span class="s4">null</span><span class="s2">;</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Represents the context for any loop.</span>
 <span class="s0">* </span><span class="s1">@typedef </span><span class="s0">{WhileLoopContext|DoWhileLoopContext|ForLoopContext|ForInLoopContext|ForOfLoopContext} LoopContext</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* Represents the context for a `switch` statement.</span>
 <span class="s0">*/</span>
<span class="s4">class </span><span class="s2">SwitchContext {</span>
	<span class="s0">/**</span>
	 <span class="s0">* Creates a new instance.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{SwitchContext} upperContext The previous context.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean} hasCase Indicates if there is at least one `case` statement.</span>
	 <span class="s0">*      `default` doesn't count.</span>
	 <span class="s0">*/</span>
	<span class="s2">constructor(upperContext, hasCase) {</span>
		<span class="s0">/**</span>
		 <span class="s0">* The previous context.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{SwitchContext}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.upper = upperContext;</span>

		<span class="s0">/**</span>
		 <span class="s0">* Indicates if there is at least one `case` statement. `default` doesn't count.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{boolean}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.hasCase = hasCase;</span>

		<span class="s0">/**</span>
		 <span class="s0">* The `default` keyword.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;|null}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.defaultSegments = </span><span class="s4">null</span><span class="s2">;</span>

		<span class="s0">/**</span>
		 <span class="s0">* The default case body starting segments.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;|null}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.defaultBodySegments = </span><span class="s4">null</span><span class="s2">;</span>

		<span class="s0">/**</span>
		 <span class="s0">* Indicates if a `default` case and is empty exists.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{boolean}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.foundEmptyDefault = </span><span class="s4">false</span><span class="s2">;</span>

		<span class="s0">/**</span>
		 <span class="s0">* Indicates that a `default` exists and is the last case.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{boolean}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.lastIsDefault = </span><span class="s4">false</span><span class="s2">;</span>

		<span class="s0">/**</span>
		 <span class="s0">* The number of fork contexts created. This is equivalent to the</span>
		 <span class="s0">* number of `case` statements plus a `default` statement (if present).</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{number}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.forkCount = </span><span class="s5">0</span><span class="s2">;</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Represents the context for a `try` statement.</span>
 <span class="s0">*/</span>
<span class="s4">class </span><span class="s2">TryContext {</span>
	<span class="s0">/**</span>
	 <span class="s0">* Creates a new instance.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{TryContext} upperContext The previous context.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean} hasFinalizer Indicates if the `try` statement has a</span>
	 <span class="s0">*      `finally` block.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ForkContext} forkContext The enclosing fork context.</span>
	 <span class="s0">*/</span>
	<span class="s2">constructor(upperContext, hasFinalizer, forkContext) {</span>
		<span class="s0">/**</span>
		 <span class="s0">* The previous context.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{TryContext}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.upper = upperContext;</span>

		<span class="s0">/**</span>
		 <span class="s0">* Indicates if the `try` statement has a `finally` block.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{boolean}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.hasFinalizer = hasFinalizer;</span>

		<span class="s0">/**</span>
		 <span class="s0">* Tracks the traversal position inside of the `try` statement. This is</span>
		 <span class="s0">* used to help determine the context necessary to create paths because</span>
		 <span class="s0">* a `try` statement may or may not have `catch` or `finally` blocks,</span>
		 <span class="s0">* and code paths behave differently in those blocks.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{&quot;try&quot;|&quot;catch&quot;|&quot;finally&quot;}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.position = </span><span class="s3">&quot;try&quot;</span><span class="s2">;</span>

		<span class="s0">/**</span>
		 <span class="s0">* If the `try` statement has a `finally` block, this affects how a</span>
		 <span class="s0">* `return` statement behaves in the `try` block. Without `finally`,</span>
		 <span class="s0">* `return` behaves as usual and doesn't require a fork; with `finally`,</span>
		 <span class="s0">* `return` forks into the `finally` block, so we need a fork context</span>
		 <span class="s0">* to track it.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{ForkContext|null}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.returnedForkContext = hasFinalizer</span>
			<span class="s2">? ForkContext.newEmpty(forkContext)</span>
			<span class="s2">: </span><span class="s4">null</span><span class="s2">;</span>

		<span class="s0">/**</span>
		 <span class="s0">* When a `throw` occurs inside of a `try` block, the code path forks</span>
		 <span class="s0">* into the `catch` or `finally` blocks, and this fork context tracks</span>
		 <span class="s0">* that path.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{ForkContext}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.thrownForkContext = ForkContext.newEmpty(forkContext);</span>

		<span class="s0">/**</span>
		 <span class="s0">* Indicates if the last segment in the `try` block is reachable.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{boolean}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.lastOfTryIsReachable = </span><span class="s4">false</span><span class="s2">;</span>

		<span class="s0">/**</span>
		 <span class="s0">* Indicates if the last segment in the `catch` block is reachable.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{boolean}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.lastOfCatchIsReachable = </span><span class="s4">false</span><span class="s2">;</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Helpers</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s0">/**</span>
 <span class="s0">* Adds given segments into the `dest` array.</span>
 <span class="s0">* If the `others` array does not include the given segments, adds to the `all`</span>
 <span class="s0">* array as well.</span>
 <span class="s0">*</span>
 <span class="s0">* This adds only reachable and used segments.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{CodePathSegment[]} dest A destination array (`returnedSegments` or `thrownSegments`).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{CodePathSegment[]} others Another destination array (`returnedSegments` or `thrownSegments`).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{CodePathSegment[]} all The unified destination array (`finalSegments`).</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{CodePathSegment[]} segments Segments to add.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">addToReturnedOrThrown(dest, others, all, segments) {</span>
	<span class="s4">for </span><span class="s2">(</span><span class="s4">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; segments.length; ++i) {</span>
		<span class="s4">const </span><span class="s2">segment = segments[i];</span>

		<span class="s2">dest.push(segment);</span>
		<span class="s4">if </span><span class="s2">(!others.includes(segment)) {</span>
			<span class="s2">all.push(segment);</span>
		<span class="s2">}</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Gets a loop context for a `continue` statement based on a given label.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{CodePathState} state The state to search within.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|null} label The label of a `continue` statement.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{LoopContext} A loop-context for a `continue` statement.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">getContinueContext(state, label) {</span>
	<span class="s4">if </span><span class="s2">(!label) {</span>
		<span class="s4">return </span><span class="s2">state.loopContext;</span>
	<span class="s2">}</span>

	<span class="s4">let </span><span class="s2">context = state.loopContext;</span>

	<span class="s4">while </span><span class="s2">(context) {</span>
		<span class="s4">if </span><span class="s2">(context.label === label) {</span>
			<span class="s4">return </span><span class="s2">context;</span>
		<span class="s2">}</span>
		<span class="s2">context = context.upper;</span>
	<span class="s2">}</span>

	<span class="s0">/* c8 ignore next */</span>
	<span class="s4">return null</span><span class="s2">;</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Gets a context for a `break` statement.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{CodePathState} state The state to search within.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|null} label The label of a `break` statement.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{BreakContext} A context for a `break` statement.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">getBreakContext(state, label) {</span>
	<span class="s4">let </span><span class="s2">context = state.breakContext;</span>

	<span class="s4">while </span><span class="s2">(context) {</span>
		<span class="s4">if </span><span class="s2">(label ? context.label === label : context.breakable) {</span>
			<span class="s4">return </span><span class="s2">context;</span>
		<span class="s2">}</span>
		<span class="s2">context = context.upper;</span>
	<span class="s2">}</span>

	<span class="s0">/* c8 ignore next */</span>
	<span class="s4">return null</span><span class="s2">;</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Gets a context for a `return` statement. There is just one special case:</span>
 <span class="s0">* if there is a `try` statement with a `finally` block, because that alters</span>
 <span class="s0">* how `return` behaves; otherwise, this just passes through the given state.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{CodePathState} state The state to search within</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{TryContext|CodePathState} A context for a `return` statement.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">getReturnContext(state) {</span>
	<span class="s4">let </span><span class="s2">context = state.tryContext;</span>

	<span class="s4">while </span><span class="s2">(context) {</span>
		<span class="s4">if </span><span class="s2">(context.hasFinalizer &amp;&amp; context.position !== </span><span class="s3">&quot;finally&quot;</span><span class="s2">) {</span>
			<span class="s4">return </span><span class="s2">context;</span>
		<span class="s2">}</span>
		<span class="s2">context = context.upper;</span>
	<span class="s2">}</span>

	<span class="s4">return </span><span class="s2">state;</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Gets a context for a `throw` statement. There is just one special case:</span>
 <span class="s0">* if there is a `try` statement with a `finally` block and we are inside of</span>
 <span class="s0">* a `catch` because that changes how `throw` behaves; otherwise, this just</span>
 <span class="s0">* passes through the given state.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{CodePathState} state The state to search within.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{TryContext|CodePathState} A context for a `throw` statement.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">getThrowContext(state) {</span>
	<span class="s4">let </span><span class="s2">context = state.tryContext;</span>

	<span class="s4">while </span><span class="s2">(context) {</span>
		<span class="s4">if </span><span class="s2">(</span>
			<span class="s2">context.position === </span><span class="s3">&quot;try&quot; </span><span class="s2">||</span>
			<span class="s2">(context.hasFinalizer &amp;&amp; context.position === </span><span class="s3">&quot;catch&quot;</span><span class="s2">)</span>
		<span class="s2">) {</span>
			<span class="s4">return </span><span class="s2">context;</span>
		<span class="s2">}</span>
		<span class="s2">context = context.upper;</span>
	<span class="s2">}</span>

	<span class="s4">return </span><span class="s2">state;</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Removes a given value from a given array.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{any[]} elements An array to remove the specific element.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{any} value The value to be removed.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">removeFromArray(elements, value) {</span>
	<span class="s2">elements.splice(elements.indexOf(value), </span><span class="s5">1</span><span class="s2">);</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Disconnect given segments.</span>
 <span class="s0">*</span>
 <span class="s0">* This is used in a process for switch statements.</span>
 <span class="s0">* If there is the &quot;default&quot; chunk before other cases, the order is different</span>
 <span class="s0">* between node's and running's.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{CodePathSegment[]} prevSegments Forward segments to disconnect.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{CodePathSegment[]} nextSegments Backward segments to disconnect.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">disconnectSegments(prevSegments, nextSegments) {</span>
	<span class="s4">for </span><span class="s2">(</span><span class="s4">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; prevSegments.length; ++i) {</span>
		<span class="s4">const </span><span class="s2">prevSegment = prevSegments[i];</span>
		<span class="s4">const </span><span class="s2">nextSegment = nextSegments[i];</span>

		<span class="s2">removeFromArray(prevSegment.nextSegments, nextSegment);</span>
		<span class="s2">removeFromArray(prevSegment.allNextSegments, nextSegment);</span>
		<span class="s2">removeFromArray(nextSegment.prevSegments, prevSegment);</span>
		<span class="s2">removeFromArray(nextSegment.allPrevSegments, prevSegment);</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Creates looping path between two arrays of segments, ensuring that there are</span>
 <span class="s0">* paths going between matching segments in the arrays.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{CodePathState} state The state to operate on.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{CodePathSegment[]} unflattenedFromSegments Segments which are source.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{CodePathSegment[]} unflattenedToSegments Segments which are destination.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">makeLooped(state, unflattenedFromSegments, unflattenedToSegments) {</span>
	<span class="s4">const </span><span class="s2">fromSegments = CodePathSegment.flattenUnusedSegments(</span>
		<span class="s2">unflattenedFromSegments,</span>
	<span class="s2">);</span>
	<span class="s4">const </span><span class="s2">toSegments = CodePathSegment.flattenUnusedSegments(</span>
		<span class="s2">unflattenedToSegments,</span>
	<span class="s2">);</span>
	<span class="s4">const </span><span class="s2">end = Math.min(fromSegments.length, toSegments.length);</span>

	<span class="s0">/* 
     * This loop effectively updates a doubly-linked list between two collections 
     * of segments making sure that segments in the same array indices are 
     * combined to create a path. 
     */</span>
	<span class="s4">for </span><span class="s2">(</span><span class="s4">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; end; ++i) {</span>
		<span class="s0">// get the segments in matching array indices</span>
		<span class="s4">const </span><span class="s2">fromSegment = fromSegments[i];</span>
		<span class="s4">const </span><span class="s2">toSegment = toSegments[i];</span>

		<span class="s0">/* 
         * If the destination segment is reachable, then create a path from the 
         * source segment to the destination segment. 
         */</span>
		<span class="s4">if </span><span class="s2">(toSegment.reachable) {</span>
			<span class="s2">fromSegment.nextSegments.push(toSegment);</span>
		<span class="s2">}</span>

		<span class="s0">/* 
         * If the source segment is reachable, then create a path from the 
         * destination segment back to the source segment. 
         */</span>
		<span class="s4">if </span><span class="s2">(fromSegment.reachable) {</span>
			<span class="s2">toSegment.prevSegments.push(fromSegment);</span>
		<span class="s2">}</span>

		<span class="s0">/* 
         * Also update the arrays that don't care if the segments are reachable 
         * or not. This should always happen regardless of anything else. 
         */</span>
		<span class="s2">fromSegment.allNextSegments.push(toSegment);</span>
		<span class="s2">toSegment.allPrevSegments.push(fromSegment);</span>

		<span class="s0">/* 
         * If the destination segment has at least two previous segments in its 
         * path then that means there was one previous segment before this iteration 
         * of the loop was executed. So, we need to mark the source segment as 
         * looped. 
         */</span>
		<span class="s4">if </span><span class="s2">(toSegment.allPrevSegments.length &gt;= </span><span class="s5">2</span><span class="s2">) {</span>
			<span class="s2">CodePathSegment.markPrevSegmentAsLooped(toSegment, fromSegment);</span>
		<span class="s2">}</span>

		<span class="s0">// let the code path analyzer know that there's been a loop created</span>
		<span class="s2">state.notifyLooped(fromSegment, toSegment);</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Finalizes segments of `test` chunk of a ForStatement.</span>
 <span class="s0">*</span>
 <span class="s0">* - Adds `false` paths to paths which are leaving from the loop.</span>
 <span class="s0">* - Sets `true` paths to paths which go to the body.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{LoopContext} context A loop context to modify.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ChoiceContext} choiceContext A choice context of this loop.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{CodePathSegment[]} head The current head paths.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">finalizeTestSegmentsOfFor(context, choiceContext, head) {</span>
	<span class="s0">/* 
     * If this choice context doesn't already contain paths from a 
     * child context, then add the current head to each potential path. 
     */</span>
	<span class="s4">if </span><span class="s2">(!choiceContext.processed) {</span>
		<span class="s2">choiceContext.trueForkContext.add(head);</span>
		<span class="s2">choiceContext.falseForkContext.add(head);</span>
		<span class="s2">choiceContext.nullishForkContext.add(head);</span>
	<span class="s2">}</span>

	<span class="s0">/* 
     * If the test condition isn't a hardcoded truthy value, then `break` 
     * must follow the same path as if the test condition is false. To represent 
     * that, we append the path for when the loop test is false (represented by 
     * `falseForkContext`) to the `brokenForkContext`. 
     */</span>
	<span class="s4">if </span><span class="s2">(context.test !== </span><span class="s4">true</span><span class="s2">) {</span>
		<span class="s2">context.brokenForkContext.addAll(choiceContext.falseForkContext);</span>
	<span class="s2">}</span>

	<span class="s2">context.endOfTestSegments = choiceContext.trueForkContext.makeNext(</span><span class="s5">0</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">);</span>
<span class="s2">}</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Public Interface</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s0">/**</span>
 <span class="s0">* A class which manages state to analyze code paths.</span>
 <span class="s0">*/</span>
<span class="s4">class </span><span class="s2">CodePathState {</span>
	<span class="s0">/**</span>
	 <span class="s0">* Creates a new instance.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{IdGenerator} idGenerator An id generator to generate id for code</span>
	 <span class="s0">*   path segments.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Function} onLooped A callback function to notify looping.</span>
	 <span class="s0">*/</span>
	<span class="s2">constructor(idGenerator, onLooped) {</span>
		<span class="s0">/**</span>
		 <span class="s0">* The ID generator to use when creating new segments.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{IdGenerator}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.idGenerator = idGenerator;</span>

		<span class="s0">/**</span>
		 <span class="s0">* A callback function to call when there is a loop.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Function}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.notifyLooped = onLooped;</span>

		<span class="s0">/**</span>
		 <span class="s0">* The root fork context for this state.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{ForkContext}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.forkContext = ForkContext.newRoot(idGenerator);</span>

		<span class="s0">/**</span>
		 <span class="s0">* Context for logical expressions, conditional expressions, `if` statements,</span>
		 <span class="s0">* and loops.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{ChoiceContext}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.choiceContext = </span><span class="s4">null</span><span class="s2">;</span>

		<span class="s0">/**</span>
		 <span class="s0">* Context for `switch` statements.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{SwitchContext}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.switchContext = </span><span class="s4">null</span><span class="s2">;</span>

		<span class="s0">/**</span>
		 <span class="s0">* Context for `try` statements.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{TryContext}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.tryContext = </span><span class="s4">null</span><span class="s2">;</span>

		<span class="s0">/**</span>
		 <span class="s0">* Context for loop statements.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{LoopContext}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.loopContext = </span><span class="s4">null</span><span class="s2">;</span>

		<span class="s0">/**</span>
		 <span class="s0">* Context for `break` statements.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{BreakContext}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.breakContext = </span><span class="s4">null</span><span class="s2">;</span>

		<span class="s0">/**</span>
		 <span class="s0">* Context for `ChainExpression` nodes.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{ChainContext}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.chainContext = </span><span class="s4">null</span><span class="s2">;</span>

		<span class="s0">/**</span>
		 <span class="s0">* An array that tracks the current segments in the state. The array</span>
		 <span class="s0">* starts empty and segments are added with each `onCodePathSegmentStart`</span>
		 <span class="s0">* event and removed with each `onCodePathSegmentEnd` event. Effectively,</span>
		 <span class="s0">* this is tracking the code path segment traversal as the state is</span>
		 <span class="s0">* modified.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.currentSegments = [];</span>

		<span class="s0">/**</span>
		 <span class="s0">* Tracks the starting segment for this path. This value never changes.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{CodePathSegment}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.initialSegment = </span><span class="s4">this</span><span class="s2">.forkContext.head[</span><span class="s5">0</span><span class="s2">];</span>

		<span class="s0">/**</span>
		 <span class="s0">* The final segments of the code path which are either `return` or `throw`.</span>
		 <span class="s0">* This is a union of the segments in `returnedForkContext` and `thrownForkContext`.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.finalSegments = [];</span>

		<span class="s0">/**</span>
		 <span class="s0">* The final segments of the code path which are `return`. These</span>
		 <span class="s0">* segments are also contained in `finalSegments`.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.returnedForkContext = [];</span>

		<span class="s0">/**</span>
		 <span class="s0">* The final segments of the code path which are `throw`. These</span>
		 <span class="s0">* segments are also contained in `finalSegments`.</span>
		 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Array&lt;CodePathSegment&gt;}</span>
		 <span class="s0">*/</span>
		<span class="s4">this</span><span class="s2">.thrownForkContext = [];</span>

		<span class="s0">/* 
         * We add an `add` method so that these look more like fork contexts and 
         * can be used interchangeably when a fork context is needed to add more 
         * segments to a path. 
         * 
         * Ultimately, we want anything added to `returned` or `thrown` to also 
         * be added to `final`. We only add reachable and used segments to these 
         * arrays. 
         */</span>
		<span class="s4">const </span><span class="s2">final = </span><span class="s4">this</span><span class="s2">.finalSegments;</span>
		<span class="s4">const </span><span class="s2">returned = </span><span class="s4">this</span><span class="s2">.returnedForkContext;</span>
		<span class="s4">const </span><span class="s2">thrown = </span><span class="s4">this</span><span class="s2">.thrownForkContext;</span>

		<span class="s2">returned.add = addToReturnedOrThrown.bind(</span>
			<span class="s4">null</span><span class="s2">,</span>
			<span class="s2">returned,</span>
			<span class="s2">thrown,</span>
			<span class="s2">final,</span>
		<span class="s2">);</span>
		<span class="s2">thrown.add = addToReturnedOrThrown.bind(</span><span class="s4">null</span><span class="s2">, thrown, returned, final);</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* A passthrough property exposing the current pointer as part of the API.</span>
	 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{CodePathSegment[]}</span>
	 <span class="s0">*/</span>
	<span class="s2">get headSegments() {</span>
		<span class="s4">return this</span><span class="s2">.forkContext.head;</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* The parent forking context.</span>
	 <span class="s0">* This is used for the root of new forks.</span>
	 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{ForkContext}</span>
	 <span class="s0">*/</span>
	<span class="s2">get parentForkContext() {</span>
		<span class="s4">const </span><span class="s2">current = </span><span class="s4">this</span><span class="s2">.forkContext;</span>

		<span class="s4">return </span><span class="s2">current &amp;&amp; current.upper;</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Creates and stacks new forking context.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean} forkLeavingPath A flag which shows being in a</span>
	 <span class="s0">*   &quot;finally&quot; block.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ForkContext} The created context.</span>
	 <span class="s0">*/</span>
	<span class="s2">pushForkContext(forkLeavingPath) {</span>
		<span class="s4">this</span><span class="s2">.forkContext = ForkContext.newEmpty(</span>
			<span class="s4">this</span><span class="s2">.forkContext,</span>
			<span class="s2">forkLeavingPath,</span>
		<span class="s2">);</span>

		<span class="s4">return this</span><span class="s2">.forkContext;</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Pops and merges the last forking context.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ForkContext} The last context.</span>
	 <span class="s0">*/</span>
	<span class="s2">popForkContext() {</span>
		<span class="s4">const </span><span class="s2">lastContext = </span><span class="s4">this</span><span class="s2">.forkContext;</span>

		<span class="s4">this</span><span class="s2">.forkContext = lastContext.upper;</span>
		<span class="s4">this</span><span class="s2">.forkContext.replaceHead(lastContext.makeNext(</span><span class="s5">0</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">));</span>

		<span class="s4">return </span><span class="s2">lastContext;</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Creates a new path.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s2">forkPath() {</span>
		<span class="s4">this</span><span class="s2">.forkContext.add(</span><span class="s4">this</span><span class="s2">.parentForkContext.makeNext(-</span><span class="s5">1</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">));</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Creates a bypass path.</span>
	 <span class="s0">* This is used for such as IfStatement which does not have &quot;else&quot; chunk.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s2">forkBypassPath() {</span>
		<span class="s4">this</span><span class="s2">.forkContext.add(</span><span class="s4">this</span><span class="s2">.parentForkContext.head);</span>
	<span class="s2">}</span>

	<span class="s0">//--------------------------------------------------------------------------</span>
	<span class="s0">// ConditionalExpression, LogicalExpression, IfStatement</span>
	<span class="s0">//--------------------------------------------------------------------------</span>

	<span class="s0">/**</span>
	 <span class="s0">* Creates a context for ConditionalExpression, LogicalExpression, AssignmentExpression (logical assignments only),</span>
	 <span class="s0">* IfStatement, WhileStatement, DoWhileStatement, or ForStatement.</span>
	 <span class="s0">*</span>
	 <span class="s0">* LogicalExpressions have cases that it goes different paths between the</span>
	 <span class="s0">* `true` case and the `false` case.</span>
	 <span class="s0">*</span>
	 <span class="s0">* For Example:</span>
	 <span class="s0">*</span>
	 <span class="s0">*     if (a || b) {</span>
	 <span class="s0">*         foo();</span>
	 <span class="s0">*     } else {</span>
	 <span class="s0">*         bar();</span>
	 <span class="s0">*     }</span>
	 <span class="s0">*</span>
	 <span class="s0">* In this case, `b` is evaluated always in the code path of the `else`</span>
	 <span class="s0">* block, but it's not so in the code path of the `if` block.</span>
	 <span class="s0">* So there are 3 paths.</span>
	 <span class="s0">*</span>
	 <span class="s0">*     a -&gt; foo();</span>
	 <span class="s0">*     a -&gt; b -&gt; foo();</span>
	 <span class="s0">*     a -&gt; b -&gt; bar();</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} kind A kind string.</span>
	 <span class="s0">*   If the new context is LogicalExpression's or AssignmentExpression's, this is `&quot;&amp;&amp;&quot;` or `&quot;||&quot;` or `&quot;??&quot;`.</span>
	 <span class="s0">*   If it's IfStatement's or ConditionalExpression's, this is `&quot;test&quot;`.</span>
	 <span class="s0">*   Otherwise, this is `&quot;loop&quot;`.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean} isForkingAsResult Indicates if the result of the choice</span>
	 <span class="s0">*      creates a fork.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s2">pushChoiceContext(kind, isForkingAsResult) {</span>
		<span class="s4">this</span><span class="s2">.choiceContext = </span><span class="s4">new </span><span class="s2">ChoiceContext(</span>
			<span class="s4">this</span><span class="s2">.choiceContext,</span>
			<span class="s2">kind,</span>
			<span class="s2">isForkingAsResult,</span>
			<span class="s4">this</span><span class="s2">.forkContext,</span>
		<span class="s2">);</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Pops the last choice context and finalizes it.</span>
	 <span class="s0">* This is called upon leaving a node that represents a choice.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} (Unreachable.)</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ChoiceContext} The popped context.</span>
	 <span class="s0">*/</span>
	<span class="s2">popChoiceContext() {</span>
		<span class="s4">const </span><span class="s2">poppedChoiceContext = </span><span class="s4">this</span><span class="s2">.choiceContext;</span>
		<span class="s4">const </span><span class="s2">forkContext = </span><span class="s4">this</span><span class="s2">.forkContext;</span>
		<span class="s4">const </span><span class="s2">head = forkContext.head;</span>

		<span class="s4">this</span><span class="s2">.choiceContext = poppedChoiceContext.upper;</span>

		<span class="s4">switch </span><span class="s2">(poppedChoiceContext.kind) {</span>
			<span class="s4">case </span><span class="s3">&quot;&amp;&amp;&quot;</span><span class="s2">:</span>
			<span class="s4">case </span><span class="s3">&quot;||&quot;</span><span class="s2">:</span>
			<span class="s4">case </span><span class="s3">&quot;??&quot;</span><span class="s2">:</span>
				<span class="s0">/* 
                 * The `head` are the path of the right-hand operand. 
                 * If we haven't previously added segments from child contexts, 
                 * then we add these segments to all possible forks. 
                 */</span>
				<span class="s4">if </span><span class="s2">(!poppedChoiceContext.processed) {</span>
					<span class="s2">poppedChoiceContext.trueForkContext.add(head);</span>
					<span class="s2">poppedChoiceContext.falseForkContext.add(head);</span>
					<span class="s2">poppedChoiceContext.nullishForkContext.add(head);</span>
				<span class="s2">}</span>

				<span class="s0">/* 
                 * If this context is the left (test) expression for another choice 
                 * context, such as `a || b` in the expression `a || b || c`, 
                 * then we take the segments for this context and move them up 
                 * to the parent context. 
                 */</span>
				<span class="s4">if </span><span class="s2">(poppedChoiceContext.isForkingAsResult) {</span>
					<span class="s4">const </span><span class="s2">parentContext = </span><span class="s4">this</span><span class="s2">.choiceContext;</span>

					<span class="s2">parentContext.trueForkContext.addAll(</span>
						<span class="s2">poppedChoiceContext.trueForkContext,</span>
					<span class="s2">);</span>
					<span class="s2">parentContext.falseForkContext.addAll(</span>
						<span class="s2">poppedChoiceContext.falseForkContext,</span>
					<span class="s2">);</span>
					<span class="s2">parentContext.nullishForkContext.addAll(</span>
						<span class="s2">poppedChoiceContext.nullishForkContext,</span>
					<span class="s2">);</span>
					<span class="s2">parentContext.processed = </span><span class="s4">true</span><span class="s2">;</span>

					<span class="s0">// Exit early so we don't collapse all paths into one.</span>
					<span class="s4">return </span><span class="s2">poppedChoiceContext;</span>
				<span class="s2">}</span>

				<span class="s4">break</span><span class="s2">;</span>

			<span class="s4">case </span><span class="s3">&quot;test&quot;</span><span class="s2">:</span>
				<span class="s4">if </span><span class="s2">(!poppedChoiceContext.processed) {</span>
					<span class="s0">/* 
                     * The head segments are the path of the `if` block here. 
                     * Updates the `true` path with the end of the `if` block. 
                     */</span>
					<span class="s2">poppedChoiceContext.trueForkContext.clear();</span>
					<span class="s2">poppedChoiceContext.trueForkContext.add(head);</span>
				<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
					<span class="s0">/* 
                     * The head segments are the path of the `else` block here. 
                     * Updates the `false` path with the end of the `else` 
                     * block. 
                     */</span>
					<span class="s2">poppedChoiceContext.falseForkContext.clear();</span>
					<span class="s2">poppedChoiceContext.falseForkContext.add(head);</span>
				<span class="s2">}</span>

				<span class="s4">break</span><span class="s2">;</span>

			<span class="s4">case </span><span class="s3">&quot;loop&quot;</span><span class="s2">:</span>
				<span class="s0">/* 
                 * Loops are addressed in `popLoopContext()` so just return 
                 * the context without modification. 
                 */</span>
				<span class="s4">return </span><span class="s2">poppedChoiceContext;</span>

			<span class="s0">/* c8 ignore next */</span>
			<span class="s4">default</span><span class="s2">:</span>
				<span class="s4">throw new </span><span class="s2">Error(</span><span class="s3">&quot;unreachable&quot;</span><span class="s2">);</span>
		<span class="s2">}</span>

		<span class="s0">/* 
         * Merge the true path with the false path to create a single path. 
         */</span>
		<span class="s4">const </span><span class="s2">combinedForkContext = poppedChoiceContext.trueForkContext;</span>

		<span class="s2">combinedForkContext.addAll(poppedChoiceContext.falseForkContext);</span>
		<span class="s2">forkContext.replaceHead(combinedForkContext.makeNext(</span><span class="s5">0</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">));</span>

		<span class="s4">return </span><span class="s2">poppedChoiceContext;</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Creates a code path segment to represent right-hand operand of a logical</span>
	 <span class="s0">* expression.</span>
	 <span class="s0">* This is called in the preprocessing phase when entering a node.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} (Unreachable.)</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s2">makeLogicalRight() {</span>
		<span class="s4">const </span><span class="s2">currentChoiceContext = </span><span class="s4">this</span><span class="s2">.choiceContext;</span>
		<span class="s4">const </span><span class="s2">forkContext = </span><span class="s4">this</span><span class="s2">.forkContext;</span>

		<span class="s4">if </span><span class="s2">(currentChoiceContext.processed) {</span>
			<span class="s0">/* 
             * This context was already assigned segments from a child 
             * choice context. In this case, we are concerned only about 
             * the path that does not short-circuit and so ends up on the 
             * right-hand operand of the logical expression. 
             */</span>
			<span class="s4">let </span><span class="s2">prevForkContext;</span>

			<span class="s4">switch </span><span class="s2">(currentChoiceContext.kind) {</span>
				<span class="s4">case </span><span class="s3">&quot;&amp;&amp;&quot;</span><span class="s2">: </span><span class="s0">// if true then go to the right-hand side.</span>
					<span class="s2">prevForkContext = currentChoiceContext.trueForkContext;</span>
					<span class="s4">break</span><span class="s2">;</span>
				<span class="s4">case </span><span class="s3">&quot;||&quot;</span><span class="s2">: </span><span class="s0">// if false then go to the right-hand side.</span>
					<span class="s2">prevForkContext = currentChoiceContext.falseForkContext;</span>
					<span class="s4">break</span><span class="s2">;</span>
				<span class="s4">case </span><span class="s3">&quot;??&quot;</span><span class="s2">: </span><span class="s0">// Both true/false can short-circuit, so needs the third path to go to the right-hand side. That's nullishForkContext.</span>
					<span class="s2">prevForkContext = currentChoiceContext.nullishForkContext;</span>
					<span class="s4">break</span><span class="s2">;</span>
				<span class="s4">default</span><span class="s2">:</span>
					<span class="s4">throw new </span><span class="s2">Error(</span><span class="s3">&quot;unreachable&quot;</span><span class="s2">);</span>
			<span class="s2">}</span>

			<span class="s0">/* 
             * Create the segment for the right-hand operand of the logical expression 
             * and adjust the fork context pointer to point there. The right-hand segment 
             * is added at the end of all segments in `prevForkContext`. 
             */</span>
			<span class="s2">forkContext.replaceHead(prevForkContext.makeNext(</span><span class="s5">0</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">));</span>

			<span class="s0">/* 
             * We no longer need this list of segments. 
             * 
             * Reset `processed` because we've removed the segments from the child 
             * choice context. This allows `popChoiceContext()` to continue adding 
             * segments later. 
             */</span>
			<span class="s2">prevForkContext.clear();</span>
			<span class="s2">currentChoiceContext.processed = </span><span class="s4">false</span><span class="s2">;</span>
		<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
			<span class="s0">/* 
             * This choice context was not assigned segments from a child 
             * choice context, which means that it's a terminal logical 
             * expression. 
             * 
             * `head` is the segments for the left-hand operand of the 
             * logical expression. 
             * 
             * Each of the fork contexts below are empty at this point. We choose 
             * the path(s) that will short-circuit and add the segment for the 
             * left-hand operand to it. Ultimately, this will be the only segment 
             * in that path due to the short-circuting, so we are just seeding 
             * these paths to start. 
             */</span>
			<span class="s4">switch </span><span class="s2">(currentChoiceContext.kind) {</span>
				<span class="s4">case </span><span class="s3">&quot;&amp;&amp;&quot;</span><span class="s2">:</span>
					<span class="s0">/* 
                     * In most contexts, when a &amp;&amp; expression evaluates to false, 
                     * it short circuits, so we need to account for that by setting 
                     * the `falseForkContext` to the left operand. 
                     * 
                     * When a &amp;&amp; expression is the left-hand operand for a ?? 
                     * expression, such as `(a &amp;&amp; b) ?? c`, a nullish value will 
                     * also short-circuit in a different way than a false value, 
                     * so we also set the `nullishForkContext` to the left operand. 
                     * This path is only used with a ?? expression and is thrown 
                     * away for any other type of logical expression, so it's safe 
                     * to always add. 
                     */</span>
					<span class="s2">currentChoiceContext.falseForkContext.add(forkContext.head);</span>
					<span class="s2">currentChoiceContext.nullishForkContext.add(</span>
						<span class="s2">forkContext.head,</span>
					<span class="s2">);</span>
					<span class="s4">break</span><span class="s2">;</span>
				<span class="s4">case </span><span class="s3">&quot;||&quot;</span><span class="s2">: </span><span class="s0">// the true path can short-circuit.</span>
					<span class="s2">currentChoiceContext.trueForkContext.add(forkContext.head);</span>
					<span class="s4">break</span><span class="s2">;</span>
				<span class="s4">case </span><span class="s3">&quot;??&quot;</span><span class="s2">: </span><span class="s0">// both can short-circuit.</span>
					<span class="s2">currentChoiceContext.trueForkContext.add(forkContext.head);</span>
					<span class="s2">currentChoiceContext.falseForkContext.add(forkContext.head);</span>
					<span class="s4">break</span><span class="s2">;</span>
				<span class="s4">default</span><span class="s2">:</span>
					<span class="s4">throw new </span><span class="s2">Error(</span><span class="s3">&quot;unreachable&quot;</span><span class="s2">);</span>
			<span class="s2">}</span>

			<span class="s0">/* 
             * Create the segment for the right-hand operand of the logical expression 
             * and adjust the fork context pointer to point there. 
             */</span>
			<span class="s2">forkContext.replaceHead(forkContext.makeNext(-</span><span class="s5">1</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">));</span>
		<span class="s2">}</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Makes a code path segment of the `if` block.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s2">makeIfConsequent() {</span>
		<span class="s4">const </span><span class="s2">context = </span><span class="s4">this</span><span class="s2">.choiceContext;</span>
		<span class="s4">const </span><span class="s2">forkContext = </span><span class="s4">this</span><span class="s2">.forkContext;</span>

		<span class="s0">/* 
         * If any result were not transferred from child contexts, 
         * this sets the head segments to both cases. 
         * The head segments are the path of the test expression. 
         */</span>
		<span class="s4">if </span><span class="s2">(!context.processed) {</span>
			<span class="s2">context.trueForkContext.add(forkContext.head);</span>
			<span class="s2">context.falseForkContext.add(forkContext.head);</span>
			<span class="s2">context.nullishForkContext.add(forkContext.head);</span>
		<span class="s2">}</span>

		<span class="s2">context.processed = </span><span class="s4">false</span><span class="s2">;</span>

		<span class="s0">// Creates new path from the `true` case.</span>
		<span class="s2">forkContext.replaceHead(context.trueForkContext.makeNext(</span><span class="s5">0</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">));</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Makes a code path segment of the `else` block.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s2">makeIfAlternate() {</span>
		<span class="s4">const </span><span class="s2">context = </span><span class="s4">this</span><span class="s2">.choiceContext;</span>
		<span class="s4">const </span><span class="s2">forkContext = </span><span class="s4">this</span><span class="s2">.forkContext;</span>

		<span class="s0">/* 
         * The head segments are the path of the `if` block. 
         * Updates the `true` path with the end of the `if` block. 
         */</span>
		<span class="s2">context.trueForkContext.clear();</span>
		<span class="s2">context.trueForkContext.add(forkContext.head);</span>
		<span class="s2">context.processed = </span><span class="s4">true</span><span class="s2">;</span>

		<span class="s0">// Creates new path from the `false` case.</span>
		<span class="s2">forkContext.replaceHead(context.falseForkContext.makeNext(</span><span class="s5">0</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">));</span>
	<span class="s2">}</span>

	<span class="s0">//--------------------------------------------------------------------------</span>
	<span class="s0">// ChainExpression</span>
	<span class="s0">//--------------------------------------------------------------------------</span>

	<span class="s0">/**</span>
	 <span class="s0">* Pushes a new `ChainExpression` context to the stack. This method is</span>
	 <span class="s0">* called when entering a `ChainExpression` node. A chain context is used to</span>
	 <span class="s0">* count forking in the optional chain then merge them on the exiting from the</span>
	 <span class="s0">* `ChainExpression` node.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s2">pushChainContext() {</span>
		<span class="s4">this</span><span class="s2">.chainContext = </span><span class="s4">new </span><span class="s2">ChainContext(</span><span class="s4">this</span><span class="s2">.chainContext);</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Pop a `ChainExpression` context from the stack. This method is called on</span>
	 <span class="s0">* exiting from each `ChainExpression` node. This merges all forks of the</span>
	 <span class="s0">* last optional chaining.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s2">popChainContext() {</span>
		<span class="s4">const </span><span class="s2">context = </span><span class="s4">this</span><span class="s2">.chainContext;</span>

		<span class="s4">this</span><span class="s2">.chainContext = context.upper;</span>

		<span class="s0">// pop all choice contexts of this.</span>
		<span class="s4">for </span><span class="s2">(</span><span class="s4">let </span><span class="s2">i = context.choiceContextCount; i &gt; </span><span class="s5">0</span><span class="s2">; --i) {</span>
			<span class="s4">this</span><span class="s2">.popChoiceContext();</span>
		<span class="s2">}</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Create a choice context for optional access.</span>
	 <span class="s0">* This method is called on entering to each `(Call|Member)Expression[optional=true]` node.</span>
	 <span class="s0">* This creates a choice context as similar to `LogicalExpression[operator=&quot;??&quot;]` node.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s2">makeOptionalNode() {</span>
		<span class="s4">if </span><span class="s2">(</span><span class="s4">this</span><span class="s2">.chainContext) {</span>
			<span class="s4">this</span><span class="s2">.chainContext.choiceContextCount += </span><span class="s5">1</span><span class="s2">;</span>
			<span class="s4">this</span><span class="s2">.pushChoiceContext(</span><span class="s3">&quot;??&quot;</span><span class="s2">, </span><span class="s4">false</span><span class="s2">);</span>
		<span class="s2">}</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Create a fork.</span>
	 <span class="s0">* This method is called on entering to the `arguments|property` property of each `(Call|Member)Expression` node.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s2">makeOptionalRight() {</span>
		<span class="s4">if </span><span class="s2">(</span><span class="s4">this</span><span class="s2">.chainContext) {</span>
			<span class="s4">this</span><span class="s2">.makeLogicalRight();</span>
		<span class="s2">}</span>
	<span class="s2">}</span>

	<span class="s0">//--------------------------------------------------------------------------</span>
	<span class="s0">// SwitchStatement</span>
	<span class="s0">//--------------------------------------------------------------------------</span>

	<span class="s0">/**</span>
	 <span class="s0">* Creates a context object of SwitchStatement and stacks it.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean} hasCase `true` if the switch statement has one or more</span>
	 <span class="s0">*   case parts.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|null} label The label text.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s2">pushSwitchContext(hasCase, label) {</span>
		<span class="s4">this</span><span class="s2">.switchContext = </span><span class="s4">new </span><span class="s2">SwitchContext(</span><span class="s4">this</span><span class="s2">.switchContext, hasCase);</span>
		<span class="s4">this</span><span class="s2">.pushBreakContext(</span><span class="s4">true</span><span class="s2">, label);</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Pops the last context of SwitchStatement and finalizes it.</span>
	 <span class="s0">*</span>
	 <span class="s0">* - Disposes all forking stack for `case` and `default`.</span>
	 <span class="s0">* - Creates the next code path segment from `context.brokenForkContext`.</span>
	 <span class="s0">* - If the last `SwitchCase` node is not a `default` part, creates a path</span>
	 <span class="s0">*   to the `default` body.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s2">popSwitchContext() {</span>
		<span class="s4">const </span><span class="s2">context = </span><span class="s4">this</span><span class="s2">.switchContext;</span>

		<span class="s4">this</span><span class="s2">.switchContext = context.upper;</span>

		<span class="s4">const </span><span class="s2">forkContext = </span><span class="s4">this</span><span class="s2">.forkContext;</span>
		<span class="s4">const </span><span class="s2">brokenForkContext = </span><span class="s4">this</span><span class="s2">.popBreakContext().brokenForkContext;</span>

		<span class="s4">if </span><span class="s2">(context.forkCount === </span><span class="s5">0</span><span class="s2">) {</span>
			<span class="s0">/* 
             * When there is only one `default` chunk and there is one or more 
             * `break` statements, even if forks are nothing, it needs to merge 
             * those. 
             */</span>
			<span class="s4">if </span><span class="s2">(!brokenForkContext.empty) {</span>
				<span class="s2">brokenForkContext.add(forkContext.makeNext(-</span><span class="s5">1</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">));</span>
				<span class="s2">forkContext.replaceHead(brokenForkContext.makeNext(</span><span class="s5">0</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">));</span>
			<span class="s2">}</span>

			<span class="s4">return</span><span class="s2">;</span>
		<span class="s2">}</span>

		<span class="s4">const </span><span class="s2">lastSegments = forkContext.head;</span>

		<span class="s4">this</span><span class="s2">.forkBypassPath();</span>
		<span class="s4">const </span><span class="s2">lastCaseSegments = forkContext.head;</span>

		<span class="s0">/* 
         * `brokenForkContext` is used to make the next segment. 
         * It must add the last segment into `brokenForkContext`. 
         */</span>
		<span class="s2">brokenForkContext.add(lastSegments);</span>

		<span class="s0">/* 
         * Any value that doesn't match a `case` test should flow to the default 
         * case. That happens normally when the default case is last in the `switch`, 
         * but if it's not, we need to rewire some of the paths to be correct. 
         */</span>
		<span class="s4">if </span><span class="s2">(!context.lastIsDefault) {</span>
			<span class="s4">if </span><span class="s2">(context.defaultBodySegments) {</span>
				<span class="s0">/* 
                 * There is a non-empty default case, so remove the path from the `default` 
                 * label to its body for an accurate representation. 
                 */</span>
				<span class="s2">disconnectSegments(</span>
					<span class="s2">context.defaultSegments,</span>
					<span class="s2">context.defaultBodySegments,</span>
				<span class="s2">);</span>

				<span class="s0">/* 
                 * Connect the path from the last non-default case to the body of the 
                 * default case. 
                 */</span>
				<span class="s2">makeLooped(</span><span class="s4">this</span><span class="s2">, lastCaseSegments, context.defaultBodySegments);</span>
			<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
				<span class="s0">/* 
                 * There is no default case, so we treat this as if the last case 
                 * had a `break` in it. 
                 */</span>
				<span class="s2">brokenForkContext.add(lastCaseSegments);</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s0">// Traverse up to the original fork context for the `switch` statement</span>
		<span class="s4">for </span><span class="s2">(</span><span class="s4">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; context.forkCount; ++i) {</span>
			<span class="s4">this</span><span class="s2">.forkContext = </span><span class="s4">this</span><span class="s2">.forkContext.upper;</span>
		<span class="s2">}</span>

		<span class="s0">/* 
         * Creates a path from all `brokenForkContext` paths. 
         * This is a path after `switch` statement. 
         */</span>
		<span class="s4">this</span><span class="s2">.forkContext.replaceHead(brokenForkContext.makeNext(</span><span class="s5">0</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">));</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Makes a code path segment for a `SwitchCase` node.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean} isCaseBodyEmpty `true` if the body is empty.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean} isDefaultCase `true` if the body is the default case.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s2">makeSwitchCaseBody(isCaseBodyEmpty, isDefaultCase) {</span>
		<span class="s4">const </span><span class="s2">context = </span><span class="s4">this</span><span class="s2">.switchContext;</span>

		<span class="s4">if </span><span class="s2">(!context.hasCase) {</span>
			<span class="s4">return</span><span class="s2">;</span>
		<span class="s2">}</span>

		<span class="s0">/* 
         * Merge forks. 
         * The parent fork context has two segments. 
         * Those are from the current `case` and the body of the previous case. 
         */</span>
		<span class="s4">const </span><span class="s2">parentForkContext = </span><span class="s4">this</span><span class="s2">.forkContext;</span>
		<span class="s4">const </span><span class="s2">forkContext = </span><span class="s4">this</span><span class="s2">.pushForkContext();</span>

		<span class="s2">forkContext.add(parentForkContext.makeNext(</span><span class="s5">0</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">));</span>

		<span class="s0">/* 
         * Add information about the default case. 
         * 
         * The purpose of this is to identify the starting segments for the 
         * default case to make sure there is a path there. 
         */</span>
		<span class="s4">if </span><span class="s2">(isDefaultCase) {</span>
			<span class="s0">/* 
             * This is the default case in the `switch`. 
             * 
             * We first save the current pointer as `defaultSegments` to point 
             * to the `default` keyword. 
             */</span>
			<span class="s2">context.defaultSegments = parentForkContext.head;</span>

			<span class="s0">/* 
             * If the body of the case is empty then we just set 
             * `foundEmptyDefault` to true; otherwise, we save a reference 
             * to the current pointer as `defaultBodySegments`. 
             */</span>
			<span class="s4">if </span><span class="s2">(isCaseBodyEmpty) {</span>
				<span class="s2">context.foundEmptyDefault = </span><span class="s4">true</span><span class="s2">;</span>
			<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
				<span class="s2">context.defaultBodySegments = forkContext.head;</span>
			<span class="s2">}</span>
		<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
			<span class="s0">/* 
             * This is not the default case in the `switch`. 
             * 
             * If it's not empty and there is already an empty default case found, 
             * that means the default case actually comes before this case, 
             * and that it will fall through to this case. So, we can now 
             * ignore the previous default case (reset `foundEmptyDefault` to false) 
             * and set `defaultBodySegments` to the current segments because this is 
             * effectively the new default case. 
             */</span>
			<span class="s4">if </span><span class="s2">(!isCaseBodyEmpty &amp;&amp; context.foundEmptyDefault) {</span>
				<span class="s2">context.foundEmptyDefault = </span><span class="s4">false</span><span class="s2">;</span>
				<span class="s2">context.defaultBodySegments = forkContext.head;</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s0">// keep track if the default case ends up last</span>
		<span class="s2">context.lastIsDefault = isDefaultCase;</span>
		<span class="s2">context.forkCount += </span><span class="s5">1</span><span class="s2">;</span>
	<span class="s2">}</span>

	<span class="s0">//--------------------------------------------------------------------------</span>
	<span class="s0">// TryStatement</span>
	<span class="s0">//--------------------------------------------------------------------------</span>

	<span class="s0">/**</span>
	 <span class="s0">* Creates a context object of TryStatement and stacks it.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean} hasFinalizer `true` if the try statement has a</span>
	 <span class="s0">*   `finally` block.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s2">pushTryContext(hasFinalizer) {</span>
		<span class="s4">this</span><span class="s2">.tryContext = </span><span class="s4">new </span><span class="s2">TryContext(</span>
			<span class="s4">this</span><span class="s2">.tryContext,</span>
			<span class="s2">hasFinalizer,</span>
			<span class="s4">this</span><span class="s2">.forkContext,</span>
		<span class="s2">);</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Pops the last context of TryStatement and finalizes it.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s2">popTryContext() {</span>
		<span class="s4">const </span><span class="s2">context = </span><span class="s4">this</span><span class="s2">.tryContext;</span>

		<span class="s4">this</span><span class="s2">.tryContext = context.upper;</span>

		<span class="s0">/* 
         * If we're inside the `catch` block, that means there is no `finally`, 
         * so we can process the `try` and `catch` blocks the simple way and 
         * merge their two paths. 
         */</span>
		<span class="s4">if </span><span class="s2">(context.position === </span><span class="s3">&quot;catch&quot;</span><span class="s2">) {</span>
			<span class="s4">this</span><span class="s2">.popForkContext();</span>
			<span class="s4">return</span><span class="s2">;</span>
		<span class="s2">}</span>

		<span class="s0">/* 
         * The following process is executed only when there is a `finally` 
         * block. 
         */</span>

		<span class="s4">const </span><span class="s2">originalReturnedForkContext = context.returnedForkContext;</span>
		<span class="s4">const </span><span class="s2">originalThrownForkContext = context.thrownForkContext;</span>

		<span class="s0">// no `return` or `throw` in `try` or `catch` so there's nothing left to do</span>
		<span class="s4">if </span><span class="s2">(</span>
			<span class="s2">originalReturnedForkContext.empty &amp;&amp;</span>
			<span class="s2">originalThrownForkContext.empty</span>
		<span class="s2">) {</span>
			<span class="s4">return</span><span class="s2">;</span>
		<span class="s2">}</span>

		<span class="s0">/* 
         * The following process is executed only when there is a `finally` 
         * block and there was a `return` or `throw` in the `try` or `catch` 
         * blocks. 
         */</span>

		<span class="s0">// Separate head to normal paths and leaving paths.</span>
		<span class="s4">const </span><span class="s2">headSegments = </span><span class="s4">this</span><span class="s2">.forkContext.head;</span>

		<span class="s4">this</span><span class="s2">.forkContext = </span><span class="s4">this</span><span class="s2">.forkContext.upper;</span>
		<span class="s4">const </span><span class="s2">normalSegments = headSegments.slice(</span>
			<span class="s5">0</span><span class="s2">,</span>
			<span class="s2">(headSegments.length / </span><span class="s5">2</span><span class="s2">) | </span><span class="s5">0</span><span class="s2">,</span>
		<span class="s2">);</span>
		<span class="s4">const </span><span class="s2">leavingSegments = headSegments.slice(</span>
			<span class="s2">(headSegments.length / </span><span class="s5">2</span><span class="s2">) | </span><span class="s5">0</span><span class="s2">,</span>
		<span class="s2">);</span>

		<span class="s0">// Forwards the leaving path to upper contexts.</span>
		<span class="s4">if </span><span class="s2">(!originalReturnedForkContext.empty) {</span>
			<span class="s2">getReturnContext(</span><span class="s4">this</span><span class="s2">).returnedForkContext.add(leavingSegments);</span>
		<span class="s2">}</span>
		<span class="s4">if </span><span class="s2">(!originalThrownForkContext.empty) {</span>
			<span class="s2">getThrowContext(</span><span class="s4">this</span><span class="s2">).thrownForkContext.add(leavingSegments);</span>
		<span class="s2">}</span>

		<span class="s0">// Sets the normal path as the next.</span>
		<span class="s4">this</span><span class="s2">.forkContext.replaceHead(normalSegments);</span>

		<span class="s0">/* 
         * If both paths of the `try` block and the `catch` block are 
         * unreachable, the next path becomes unreachable as well. 
         */</span>
		<span class="s4">if </span><span class="s2">(!context.lastOfTryIsReachable &amp;&amp; !context.lastOfCatchIsReachable) {</span>
			<span class="s4">this</span><span class="s2">.forkContext.makeUnreachable();</span>
		<span class="s2">}</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Makes a code path segment for a `catch` block.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s2">makeCatchBlock() {</span>
		<span class="s4">const </span><span class="s2">context = </span><span class="s4">this</span><span class="s2">.tryContext;</span>
		<span class="s4">const </span><span class="s2">forkContext = </span><span class="s4">this</span><span class="s2">.forkContext;</span>
		<span class="s4">const </span><span class="s2">originalThrownForkContext = context.thrownForkContext;</span>

		<span class="s0">/* 
         * We are now in a catch block so we need to update the context 
         * with that information. This includes creating a new fork 
         * context in case we encounter any `throw` statements here. 
         */</span>
		<span class="s2">context.position = </span><span class="s3">&quot;catch&quot;</span><span class="s2">;</span>
		<span class="s2">context.thrownForkContext = ForkContext.newEmpty(forkContext);</span>
		<span class="s2">context.lastOfTryIsReachable = forkContext.reachable;</span>

		<span class="s0">// Merge the thrown paths from the `try` and `catch` blocks</span>
		<span class="s2">originalThrownForkContext.add(forkContext.head);</span>
		<span class="s4">const </span><span class="s2">thrownSegments = originalThrownForkContext.makeNext(</span><span class="s5">0</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">);</span>

		<span class="s0">// Fork to a bypass and the merged thrown path.</span>
		<span class="s4">this</span><span class="s2">.pushForkContext();</span>
		<span class="s4">this</span><span class="s2">.forkBypassPath();</span>
		<span class="s4">this</span><span class="s2">.forkContext.add(thrownSegments);</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Makes a code path segment for a `finally` block.</span>
	 <span class="s0">*</span>
	 <span class="s0">* In the `finally` block, parallel paths are created. The parallel paths</span>
	 <span class="s0">* are used as leaving-paths. The leaving-paths are paths from `return`</span>
	 <span class="s0">* statements and `throw` statements in a `try` block or a `catch` block.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s2">makeFinallyBlock() {</span>
		<span class="s4">const </span><span class="s2">context = </span><span class="s4">this</span><span class="s2">.tryContext;</span>
		<span class="s4">let </span><span class="s2">forkContext = </span><span class="s4">this</span><span class="s2">.forkContext;</span>
		<span class="s4">const </span><span class="s2">originalReturnedForkContext = context.returnedForkContext;</span>
		<span class="s4">const </span><span class="s2">originalThrownForContext = context.thrownForkContext;</span>
		<span class="s4">const </span><span class="s2">headOfLeavingSegments = forkContext.head;</span>

		<span class="s0">// Update state.</span>
		<span class="s4">if </span><span class="s2">(context.position === </span><span class="s3">&quot;catch&quot;</span><span class="s2">) {</span>
			<span class="s0">// Merges two paths from the `try` block and `catch` block.</span>
			<span class="s4">this</span><span class="s2">.popForkContext();</span>
			<span class="s2">forkContext = </span><span class="s4">this</span><span class="s2">.forkContext;</span>

			<span class="s2">context.lastOfCatchIsReachable = forkContext.reachable;</span>
		<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
			<span class="s2">context.lastOfTryIsReachable = forkContext.reachable;</span>
		<span class="s2">}</span>

		<span class="s2">context.position = </span><span class="s3">&quot;finally&quot;</span><span class="s2">;</span>

		<span class="s0">/* 
         * If there was no `return` or `throw` in either the `try` or `catch` 
         * blocks, then there's no further code paths to create for `finally`. 
         */</span>
		<span class="s4">if </span><span class="s2">(</span>
			<span class="s2">originalReturnedForkContext.empty &amp;&amp;</span>
			<span class="s2">originalThrownForContext.empty</span>
		<span class="s2">) {</span>
			<span class="s0">// This path does not leave.</span>
			<span class="s4">return</span><span class="s2">;</span>
		<span class="s2">}</span>

		<span class="s0">/* 
         * Create a parallel segment from merging returned and thrown. 
         * This segment will leave at the end of this `finally` block. 
         */</span>
		<span class="s4">const </span><span class="s2">segments = forkContext.makeNext(-</span><span class="s5">1</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">);</span>

		<span class="s4">for </span><span class="s2">(</span><span class="s4">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; forkContext.count; ++i) {</span>
			<span class="s4">const </span><span class="s2">prevSegsOfLeavingSegment = [headOfLeavingSegments[i]];</span>

			<span class="s4">for </span><span class="s2">(</span>
				<span class="s4">let </span><span class="s2">j = </span><span class="s5">0</span><span class="s2">;</span>
				<span class="s2">j &lt; originalReturnedForkContext.segmentsList.length;</span>
				<span class="s2">++j</span>
			<span class="s2">) {</span>
				<span class="s2">prevSegsOfLeavingSegment.push(</span>
					<span class="s2">originalReturnedForkContext.segmentsList[j][i],</span>
				<span class="s2">);</span>
			<span class="s2">}</span>
			<span class="s4">for </span><span class="s2">(</span>
				<span class="s4">let </span><span class="s2">j = </span><span class="s5">0</span><span class="s2">;</span>
				<span class="s2">j &lt; originalThrownForContext.segmentsList.length;</span>
				<span class="s2">++j</span>
			<span class="s2">) {</span>
				<span class="s2">prevSegsOfLeavingSegment.push(</span>
					<span class="s2">originalThrownForContext.segmentsList[j][i],</span>
				<span class="s2">);</span>
			<span class="s2">}</span>

			<span class="s2">segments.push(</span>
				<span class="s2">CodePathSegment.newNext(</span>
					<span class="s4">this</span><span class="s2">.idGenerator.next(),</span>
					<span class="s2">prevSegsOfLeavingSegment,</span>
				<span class="s2">),</span>
			<span class="s2">);</span>
		<span class="s2">}</span>

		<span class="s4">this</span><span class="s2">.pushForkContext(</span><span class="s4">true</span><span class="s2">);</span>
		<span class="s4">this</span><span class="s2">.forkContext.add(segments);</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Makes a code path segment from the first throwable node to the `catch`</span>
	 <span class="s0">* block or the `finally` block.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s2">makeFirstThrowablePathInTryBlock() {</span>
		<span class="s4">const </span><span class="s2">forkContext = </span><span class="s4">this</span><span class="s2">.forkContext;</span>

		<span class="s4">if </span><span class="s2">(!forkContext.reachable) {</span>
			<span class="s4">return</span><span class="s2">;</span>
		<span class="s2">}</span>

		<span class="s4">const </span><span class="s2">context = getThrowContext(</span><span class="s4">this</span><span class="s2">);</span>

		<span class="s4">if </span><span class="s2">(</span>
			<span class="s2">context === </span><span class="s4">this </span><span class="s2">||</span>
			<span class="s2">context.position !== </span><span class="s3">&quot;try&quot; </span><span class="s2">||</span>
			<span class="s2">!context.thrownForkContext.empty</span>
		<span class="s2">) {</span>
			<span class="s4">return</span><span class="s2">;</span>
		<span class="s2">}</span>

		<span class="s2">context.thrownForkContext.add(forkContext.head);</span>
		<span class="s2">forkContext.replaceHead(forkContext.makeNext(-</span><span class="s5">1</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">));</span>
	<span class="s2">}</span>

	<span class="s0">//--------------------------------------------------------------------------</span>
	<span class="s0">// Loop Statements</span>
	<span class="s0">//--------------------------------------------------------------------------</span>

	<span class="s0">/**</span>
	 <span class="s0">* Creates a context object of a loop statement and stacks it.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} type The type of the node which was triggered. One of</span>
	 <span class="s0">*   `WhileStatement`, `DoWhileStatement`, `ForStatement`, `ForInStatement`,</span>
	 <span class="s0">*   and `ForStatement`.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|null} label A label of the node which was triggered.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} (Unreachable - unknown type.)</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s2">pushLoopContext(type, label) {</span>
		<span class="s4">const </span><span class="s2">forkContext = </span><span class="s4">this</span><span class="s2">.forkContext;</span>

		<span class="s0">// All loops need a path to account for `break` statements</span>
		<span class="s4">const </span><span class="s2">breakContext = </span><span class="s4">this</span><span class="s2">.pushBreakContext(</span><span class="s4">true</span><span class="s2">, label);</span>

		<span class="s4">switch </span><span class="s2">(type) {</span>
			<span class="s4">case </span><span class="s3">&quot;WhileStatement&quot;</span><span class="s2">:</span>
				<span class="s4">this</span><span class="s2">.pushChoiceContext(</span><span class="s3">&quot;loop&quot;</span><span class="s2">, </span><span class="s4">false</span><span class="s2">);</span>
				<span class="s4">this</span><span class="s2">.loopContext = </span><span class="s4">new </span><span class="s2">WhileLoopContext(</span>
					<span class="s4">this</span><span class="s2">.loopContext,</span>
					<span class="s2">label,</span>
					<span class="s2">breakContext,</span>
				<span class="s2">);</span>
				<span class="s4">break</span><span class="s2">;</span>

			<span class="s4">case </span><span class="s3">&quot;DoWhileStatement&quot;</span><span class="s2">:</span>
				<span class="s4">this</span><span class="s2">.pushChoiceContext(</span><span class="s3">&quot;loop&quot;</span><span class="s2">, </span><span class="s4">false</span><span class="s2">);</span>
				<span class="s4">this</span><span class="s2">.loopContext = </span><span class="s4">new </span><span class="s2">DoWhileLoopContext(</span>
					<span class="s4">this</span><span class="s2">.loopContext,</span>
					<span class="s2">label,</span>
					<span class="s2">breakContext,</span>
					<span class="s2">forkContext,</span>
				<span class="s2">);</span>
				<span class="s4">break</span><span class="s2">;</span>

			<span class="s4">case </span><span class="s3">&quot;ForStatement&quot;</span><span class="s2">:</span>
				<span class="s4">this</span><span class="s2">.pushChoiceContext(</span><span class="s3">&quot;loop&quot;</span><span class="s2">, </span><span class="s4">false</span><span class="s2">);</span>
				<span class="s4">this</span><span class="s2">.loopContext = </span><span class="s4">new </span><span class="s2">ForLoopContext(</span>
					<span class="s4">this</span><span class="s2">.loopContext,</span>
					<span class="s2">label,</span>
					<span class="s2">breakContext,</span>
				<span class="s2">);</span>
				<span class="s4">break</span><span class="s2">;</span>

			<span class="s4">case </span><span class="s3">&quot;ForInStatement&quot;</span><span class="s2">:</span>
				<span class="s4">this</span><span class="s2">.loopContext = </span><span class="s4">new </span><span class="s2">ForInLoopContext(</span>
					<span class="s4">this</span><span class="s2">.loopContext,</span>
					<span class="s2">label,</span>
					<span class="s2">breakContext,</span>
				<span class="s2">);</span>
				<span class="s4">break</span><span class="s2">;</span>

			<span class="s4">case </span><span class="s3">&quot;ForOfStatement&quot;</span><span class="s2">:</span>
				<span class="s4">this</span><span class="s2">.loopContext = </span><span class="s4">new </span><span class="s2">ForOfLoopContext(</span>
					<span class="s4">this</span><span class="s2">.loopContext,</span>
					<span class="s2">label,</span>
					<span class="s2">breakContext,</span>
				<span class="s2">);</span>
				<span class="s4">break</span><span class="s2">;</span>

			<span class="s0">/* c8 ignore next */</span>
			<span class="s4">default</span><span class="s2">:</span>
				<span class="s4">throw new </span><span class="s2">Error(</span><span class="s3">`unknown type: &quot;</span><span class="s2">${type}</span><span class="s3">&quot;`</span><span class="s2">);</span>
		<span class="s2">}</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Pops the last context of a loop statement and finalizes it.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} (Unreachable - unknown type.)</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s2">popLoopContext() {</span>
		<span class="s4">const </span><span class="s2">context = </span><span class="s4">this</span><span class="s2">.loopContext;</span>

		<span class="s4">this</span><span class="s2">.loopContext = context.upper;</span>

		<span class="s4">const </span><span class="s2">forkContext = </span><span class="s4">this</span><span class="s2">.forkContext;</span>
		<span class="s4">const </span><span class="s2">brokenForkContext = </span><span class="s4">this</span><span class="s2">.popBreakContext().brokenForkContext;</span>

		<span class="s0">// Creates a looped path.</span>
		<span class="s4">switch </span><span class="s2">(context.type) {</span>
			<span class="s4">case </span><span class="s3">&quot;WhileStatement&quot;</span><span class="s2">:</span>
			<span class="s4">case </span><span class="s3">&quot;ForStatement&quot;</span><span class="s2">:</span>
				<span class="s4">this</span><span class="s2">.popChoiceContext();</span>

				<span class="s0">/* 
                 * Creates the path from the end of the loop body up to the 
                 * location where `continue` would jump to. 
                 */</span>
				<span class="s2">makeLooped(</span>
					<span class="s4">this</span><span class="s2">,</span>
					<span class="s2">forkContext.head,</span>
					<span class="s2">context.continueDestSegments,</span>
				<span class="s2">);</span>
				<span class="s4">break</span><span class="s2">;</span>

			<span class="s4">case </span><span class="s3">&quot;DoWhileStatement&quot;</span><span class="s2">: {</span>
				<span class="s4">const </span><span class="s2">choiceContext = </span><span class="s4">this</span><span class="s2">.popChoiceContext();</span>

				<span class="s4">if </span><span class="s2">(!choiceContext.processed) {</span>
					<span class="s2">choiceContext.trueForkContext.add(forkContext.head);</span>
					<span class="s2">choiceContext.falseForkContext.add(forkContext.head);</span>
				<span class="s2">}</span>

				<span class="s0">/* 
                 * If this isn't a hardcoded `true` condition, then `break` 
                 * should continue down the path as if the condition evaluated 
                 * to false. 
                 */</span>
				<span class="s4">if </span><span class="s2">(context.test !== </span><span class="s4">true</span><span class="s2">) {</span>
					<span class="s2">brokenForkContext.addAll(choiceContext.falseForkContext);</span>
				<span class="s2">}</span>

				<span class="s0">/* 
                 * When the condition is true, the loop continues back to the top, 
                 * so create a path from each possible true condition back to the 
                 * top of the loop. 
                 */</span>
				<span class="s4">const </span><span class="s2">segmentsList = choiceContext.trueForkContext.segmentsList;</span>

				<span class="s4">for </span><span class="s2">(</span><span class="s4">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; segmentsList.length; ++i) {</span>
					<span class="s2">makeLooped(</span><span class="s4">this</span><span class="s2">, segmentsList[i], context.entrySegments);</span>
				<span class="s2">}</span>
				<span class="s4">break</span><span class="s2">;</span>
			<span class="s2">}</span>

			<span class="s4">case </span><span class="s3">&quot;ForInStatement&quot;</span><span class="s2">:</span>
			<span class="s4">case </span><span class="s3">&quot;ForOfStatement&quot;</span><span class="s2">:</span>
				<span class="s2">brokenForkContext.add(forkContext.head);</span>

				<span class="s0">/* 
                 * Creates the path from the end of the loop body up to the 
                 * left expression (left of `in` or `of`) of the loop. 
                 */</span>
				<span class="s2">makeLooped(</span><span class="s4">this</span><span class="s2">, forkContext.head, context.leftSegments);</span>
				<span class="s4">break</span><span class="s2">;</span>

			<span class="s0">/* c8 ignore next */</span>
			<span class="s4">default</span><span class="s2">:</span>
				<span class="s4">throw new </span><span class="s2">Error(</span><span class="s3">&quot;unreachable&quot;</span><span class="s2">);</span>
		<span class="s2">}</span>

		<span class="s0">/* 
         * If there wasn't a `break` statement in the loop, then we're at 
         * the end of the loop's path, so we make an unreachable segment 
         * to mark that. 
         * 
         * If there was a `break` statement, then we continue on into the 
         * `brokenForkContext`. 
         */</span>
		<span class="s4">if </span><span class="s2">(brokenForkContext.empty) {</span>
			<span class="s2">forkContext.replaceHead(forkContext.makeUnreachable(-</span><span class="s5">1</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">));</span>
		<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
			<span class="s2">forkContext.replaceHead(brokenForkContext.makeNext(</span><span class="s5">0</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">));</span>
		<span class="s2">}</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Makes a code path segment for the test part of a WhileStatement.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean|undefined} test The test value (only when constant).</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s2">makeWhileTest(test) {</span>
		<span class="s4">const </span><span class="s2">context = </span><span class="s4">this</span><span class="s2">.loopContext;</span>
		<span class="s4">const </span><span class="s2">forkContext = </span><span class="s4">this</span><span class="s2">.forkContext;</span>
		<span class="s4">const </span><span class="s2">testSegments = forkContext.makeNext(</span><span class="s5">0</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">);</span>

		<span class="s0">// Update state.</span>
		<span class="s2">context.test = test;</span>
		<span class="s2">context.continueDestSegments = testSegments;</span>
		<span class="s2">forkContext.replaceHead(testSegments);</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Makes a code path segment for the body part of a WhileStatement.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s2">makeWhileBody() {</span>
		<span class="s4">const </span><span class="s2">context = </span><span class="s4">this</span><span class="s2">.loopContext;</span>
		<span class="s4">const </span><span class="s2">choiceContext = </span><span class="s4">this</span><span class="s2">.choiceContext;</span>
		<span class="s4">const </span><span class="s2">forkContext = </span><span class="s4">this</span><span class="s2">.forkContext;</span>

		<span class="s4">if </span><span class="s2">(!choiceContext.processed) {</span>
			<span class="s2">choiceContext.trueForkContext.add(forkContext.head);</span>
			<span class="s2">choiceContext.falseForkContext.add(forkContext.head);</span>
		<span class="s2">}</span>

		<span class="s0">/* 
         * If this isn't a hardcoded `true` condition, then `break` 
         * should continue down the path as if the condition evaluated 
         * to false. 
         */</span>
		<span class="s4">if </span><span class="s2">(context.test !== </span><span class="s4">true</span><span class="s2">) {</span>
			<span class="s2">context.brokenForkContext.addAll(choiceContext.falseForkContext);</span>
		<span class="s2">}</span>
		<span class="s2">forkContext.replaceHead(choiceContext.trueForkContext.makeNext(</span><span class="s5">0</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">));</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Makes a code path segment for the body part of a DoWhileStatement.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s2">makeDoWhileBody() {</span>
		<span class="s4">const </span><span class="s2">context = </span><span class="s4">this</span><span class="s2">.loopContext;</span>
		<span class="s4">const </span><span class="s2">forkContext = </span><span class="s4">this</span><span class="s2">.forkContext;</span>
		<span class="s4">const </span><span class="s2">bodySegments = forkContext.makeNext(-</span><span class="s5">1</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">);</span>

		<span class="s0">// Update state.</span>
		<span class="s2">context.entrySegments = bodySegments;</span>
		<span class="s2">forkContext.replaceHead(bodySegments);</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Makes a code path segment for the test part of a DoWhileStatement.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean|undefined} test The test value (only when constant).</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s2">makeDoWhileTest(test) {</span>
		<span class="s4">const </span><span class="s2">context = </span><span class="s4">this</span><span class="s2">.loopContext;</span>
		<span class="s4">const </span><span class="s2">forkContext = </span><span class="s4">this</span><span class="s2">.forkContext;</span>

		<span class="s2">context.test = test;</span>

		<span class="s0">/* 
         * If there is a `continue` statement in the loop then `continueForkContext` 
         * won't be empty. We wire up the path from `continue` to the loop 
         * test condition and then continue the traversal in the root fork context. 
         */</span>
		<span class="s4">if </span><span class="s2">(!context.continueForkContext.empty) {</span>
			<span class="s2">context.continueForkContext.add(forkContext.head);</span>
			<span class="s4">const </span><span class="s2">testSegments = context.continueForkContext.makeNext(</span><span class="s5">0</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">);</span>

			<span class="s2">forkContext.replaceHead(testSegments);</span>
		<span class="s2">}</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Makes a code path segment for the test part of a ForStatement.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean|undefined} test The test value (only when constant).</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s2">makeForTest(test) {</span>
		<span class="s4">const </span><span class="s2">context = </span><span class="s4">this</span><span class="s2">.loopContext;</span>
		<span class="s4">const </span><span class="s2">forkContext = </span><span class="s4">this</span><span class="s2">.forkContext;</span>
		<span class="s4">const </span><span class="s2">endOfInitSegments = forkContext.head;</span>
		<span class="s4">const </span><span class="s2">testSegments = forkContext.makeNext(-</span><span class="s5">1</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">);</span>

		<span class="s0">/* 
         * Update the state. 
         * 
         * The `continueDestSegments` are set to `testSegments` because we 
         * don't yet know if there is an update expression in this loop. So, 
         * from what we already know at this point, a `continue` statement 
         * will jump back to the test expression. 
         */</span>
		<span class="s2">context.test = test;</span>
		<span class="s2">context.endOfInitSegments = endOfInitSegments;</span>
		<span class="s2">context.continueDestSegments = context.testSegments = testSegments;</span>
		<span class="s2">forkContext.replaceHead(testSegments);</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Makes a code path segment for the update part of a ForStatement.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s2">makeForUpdate() {</span>
		<span class="s4">const </span><span class="s2">context = </span><span class="s4">this</span><span class="s2">.loopContext;</span>
		<span class="s4">const </span><span class="s2">choiceContext = </span><span class="s4">this</span><span class="s2">.choiceContext;</span>
		<span class="s4">const </span><span class="s2">forkContext = </span><span class="s4">this</span><span class="s2">.forkContext;</span>

		<span class="s0">// Make the next paths of the test.</span>
		<span class="s4">if </span><span class="s2">(context.testSegments) {</span>
			<span class="s2">finalizeTestSegmentsOfFor(context, choiceContext, forkContext.head);</span>
		<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
			<span class="s2">context.endOfInitSegments = forkContext.head;</span>
		<span class="s2">}</span>

		<span class="s0">/* 
         * Update the state. 
         * 
         * The `continueDestSegments` are now set to `updateSegments` because we 
         * know there is an update expression in this loop. So, a `continue` statement 
         * in the loop will jump to the update expression first, and then to any 
         * test expression the loop might have. 
         */</span>
		<span class="s4">const </span><span class="s2">updateSegments = forkContext.makeDisconnected(-</span><span class="s5">1</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">);</span>

		<span class="s2">context.continueDestSegments = context.updateSegments = updateSegments;</span>
		<span class="s2">forkContext.replaceHead(updateSegments);</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Makes a code path segment for the body part of a ForStatement.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s2">makeForBody() {</span>
		<span class="s4">const </span><span class="s2">context = </span><span class="s4">this</span><span class="s2">.loopContext;</span>
		<span class="s4">const </span><span class="s2">choiceContext = </span><span class="s4">this</span><span class="s2">.choiceContext;</span>
		<span class="s4">const </span><span class="s2">forkContext = </span><span class="s4">this</span><span class="s2">.forkContext;</span>

		<span class="s0">/* 
         * Determine what to do based on which part of the `for` loop are present. 
         * 1. If there is an update expression, then `updateSegments` is not null and 
         *    we need to assign `endOfUpdateSegments`, and if there is a test 
         *    expression, we then need to create the looped path to get back to 
         *    the test condition. 
         * 2. If there is no update expression but there is a test expression, 
         *    then we only need to update the test segment information. 
         * 3. If there is no update expression and no test expression, then we 
         *    just save `endOfInitSegments`. 
         */</span>
		<span class="s4">if </span><span class="s2">(context.updateSegments) {</span>
			<span class="s2">context.endOfUpdateSegments = forkContext.head;</span>

			<span class="s0">/* 
             * In a `for` loop that has both an update expression and a test 
             * condition, execution flows from the test expression into the 
             * loop body, to the update expression, and then back to the test 
             * expression to determine if the loop should continue. 
             * 
             * To account for that, we need to make a path from the end of the 
             * update expression to the start of the test expression. This is 
             * effectively what creates the loop in the code path. 
             */</span>
			<span class="s4">if </span><span class="s2">(context.testSegments) {</span>
				<span class="s2">makeLooped(</span>
					<span class="s4">this</span><span class="s2">,</span>
					<span class="s2">context.endOfUpdateSegments,</span>
					<span class="s2">context.testSegments,</span>
				<span class="s2">);</span>
			<span class="s2">}</span>
		<span class="s2">} </span><span class="s4">else if </span><span class="s2">(context.testSegments) {</span>
			<span class="s2">finalizeTestSegmentsOfFor(context, choiceContext, forkContext.head);</span>
		<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
			<span class="s2">context.endOfInitSegments = forkContext.head;</span>
		<span class="s2">}</span>

		<span class="s4">let </span><span class="s2">bodySegments = context.endOfTestSegments;</span>

		<span class="s0">/* 
         * If there is a test condition, then there `endOfTestSegments` is also 
         * the start of the loop body. If there isn't a test condition then 
         * `bodySegments` will be null and we need to look elsewhere to find 
         * the start of the body. 
         * 
         * The body starts at the end of the init expression and ends at the end 
         * of the update expression, so we use those locations to determine the 
         * body segments. 
         */</span>
		<span class="s4">if </span><span class="s2">(!bodySegments) {</span>
			<span class="s4">const </span><span class="s2">prevForkContext = ForkContext.newEmpty(forkContext);</span>

			<span class="s2">prevForkContext.add(context.endOfInitSegments);</span>
			<span class="s4">if </span><span class="s2">(context.endOfUpdateSegments) {</span>
				<span class="s2">prevForkContext.add(context.endOfUpdateSegments);</span>
			<span class="s2">}</span>

			<span class="s2">bodySegments = prevForkContext.makeNext(</span><span class="s5">0</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">);</span>
		<span class="s2">}</span>

		<span class="s0">/* 
         * If there was no test condition and no update expression, then 
         * `continueDestSegments` will be null. In that case, a 
         * `continue` should skip directly to the body of the loop. 
         * Otherwise, we want to keep the current `continueDestSegments`. 
         */</span>
		<span class="s2">context.continueDestSegments =</span>
			<span class="s2">context.continueDestSegments || bodySegments;</span>

		<span class="s0">// move pointer to the body</span>
		<span class="s2">forkContext.replaceHead(bodySegments);</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Makes a code path segment for the left part of a ForInStatement and a</span>
	 <span class="s0">* ForOfStatement.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s2">makeForInOfLeft() {</span>
		<span class="s4">const </span><span class="s2">context = </span><span class="s4">this</span><span class="s2">.loopContext;</span>
		<span class="s4">const </span><span class="s2">forkContext = </span><span class="s4">this</span><span class="s2">.forkContext;</span>
		<span class="s4">const </span><span class="s2">leftSegments = forkContext.makeDisconnected(-</span><span class="s5">1</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">);</span>

		<span class="s0">// Update state.</span>
		<span class="s2">context.prevSegments = forkContext.head;</span>
		<span class="s2">context.leftSegments = context.continueDestSegments = leftSegments;</span>
		<span class="s2">forkContext.replaceHead(leftSegments);</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Makes a code path segment for the right part of a ForInStatement and a</span>
	 <span class="s0">* ForOfStatement.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s2">makeForInOfRight() {</span>
		<span class="s4">const </span><span class="s2">context = </span><span class="s4">this</span><span class="s2">.loopContext;</span>
		<span class="s4">const </span><span class="s2">forkContext = </span><span class="s4">this</span><span class="s2">.forkContext;</span>
		<span class="s4">const </span><span class="s2">temp = ForkContext.newEmpty(forkContext);</span>

		<span class="s2">temp.add(context.prevSegments);</span>
		<span class="s4">const </span><span class="s2">rightSegments = temp.makeNext(-</span><span class="s5">1</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">);</span>

		<span class="s0">// Update state.</span>
		<span class="s2">context.endOfLeftSegments = forkContext.head;</span>
		<span class="s2">forkContext.replaceHead(rightSegments);</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Makes a code path segment for the body part of a ForInStatement and a</span>
	 <span class="s0">* ForOfStatement.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s2">makeForInOfBody() {</span>
		<span class="s4">const </span><span class="s2">context = </span><span class="s4">this</span><span class="s2">.loopContext;</span>
		<span class="s4">const </span><span class="s2">forkContext = </span><span class="s4">this</span><span class="s2">.forkContext;</span>
		<span class="s4">const </span><span class="s2">temp = ForkContext.newEmpty(forkContext);</span>

		<span class="s2">temp.add(context.endOfLeftSegments);</span>
		<span class="s4">const </span><span class="s2">bodySegments = temp.makeNext(-</span><span class="s5">1</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">);</span>

		<span class="s0">// Make a path: `right` -&gt; `left`.</span>
		<span class="s2">makeLooped(</span><span class="s4">this</span><span class="s2">, forkContext.head, context.leftSegments);</span>

		<span class="s0">// Update state.</span>
		<span class="s2">context.brokenForkContext.add(forkContext.head);</span>
		<span class="s2">forkContext.replaceHead(bodySegments);</span>
	<span class="s2">}</span>

	<span class="s0">//--------------------------------------------------------------------------</span>
	<span class="s0">// Control Statements</span>
	<span class="s0">//--------------------------------------------------------------------------</span>

	<span class="s0">/**</span>
	 <span class="s0">* Creates new context in which a `break` statement can be used. This occurs inside of a loop,</span>
	 <span class="s0">* labeled statement, or switch statement.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean} breakable Indicates if we are inside a statement where</span>
	 <span class="s0">*      `break` without a label will exit the statement.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|null} label The label associated with the statement.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{BreakContext} The new context.</span>
	 <span class="s0">*/</span>
	<span class="s2">pushBreakContext(breakable, label) {</span>
		<span class="s4">this</span><span class="s2">.breakContext = </span><span class="s4">new </span><span class="s2">BreakContext(</span>
			<span class="s4">this</span><span class="s2">.breakContext,</span>
			<span class="s2">breakable,</span>
			<span class="s2">label,</span>
			<span class="s4">this</span><span class="s2">.forkContext,</span>
		<span class="s2">);</span>
		<span class="s4">return this</span><span class="s2">.breakContext;</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Removes the top item of the break context stack.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Object} The removed context.</span>
	 <span class="s0">*/</span>
	<span class="s2">popBreakContext() {</span>
		<span class="s4">const </span><span class="s2">context = </span><span class="s4">this</span><span class="s2">.breakContext;</span>
		<span class="s4">const </span><span class="s2">forkContext = </span><span class="s4">this</span><span class="s2">.forkContext;</span>

		<span class="s4">this</span><span class="s2">.breakContext = context.upper;</span>

		<span class="s0">// Process this context here for other than switches and loops.</span>
		<span class="s4">if </span><span class="s2">(!context.breakable) {</span>
			<span class="s4">const </span><span class="s2">brokenForkContext = context.brokenForkContext;</span>

			<span class="s4">if </span><span class="s2">(!brokenForkContext.empty) {</span>
				<span class="s2">brokenForkContext.add(forkContext.head);</span>
				<span class="s2">forkContext.replaceHead(brokenForkContext.makeNext(</span><span class="s5">0</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">));</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s4">return </span><span class="s2">context;</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Makes a path for a `break` statement.</span>
	 <span class="s0">*</span>
	 <span class="s0">* It registers the head segment to a context of `break`.</span>
	 <span class="s0">* It makes new unreachable segment, then it set the head with the segment.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|null} label A label of the break statement.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s2">makeBreak(label) {</span>
		<span class="s4">const </span><span class="s2">forkContext = </span><span class="s4">this</span><span class="s2">.forkContext;</span>

		<span class="s4">if </span><span class="s2">(!forkContext.reachable) {</span>
			<span class="s4">return</span><span class="s2">;</span>
		<span class="s2">}</span>

		<span class="s4">const </span><span class="s2">context = getBreakContext(</span><span class="s4">this</span><span class="s2">, label);</span>

		<span class="s4">if </span><span class="s2">(context) {</span>
			<span class="s2">context.brokenForkContext.add(forkContext.head);</span>
		<span class="s2">}</span>

		<span class="s0">/* c8 ignore next */</span>
		<span class="s2">forkContext.replaceHead(forkContext.makeUnreachable(-</span><span class="s5">1</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">));</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Makes a path for a `continue` statement.</span>
	 <span class="s0">*</span>
	 <span class="s0">* It makes a looping path.</span>
	 <span class="s0">* It makes new unreachable segment, then it set the head with the segment.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|null} label A label of the continue statement.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s2">makeContinue(label) {</span>
		<span class="s4">const </span><span class="s2">forkContext = </span><span class="s4">this</span><span class="s2">.forkContext;</span>

		<span class="s4">if </span><span class="s2">(!forkContext.reachable) {</span>
			<span class="s4">return</span><span class="s2">;</span>
		<span class="s2">}</span>

		<span class="s4">const </span><span class="s2">context = getContinueContext(</span><span class="s4">this</span><span class="s2">, label);</span>

		<span class="s4">if </span><span class="s2">(context) {</span>
			<span class="s4">if </span><span class="s2">(context.continueDestSegments) {</span>
				<span class="s2">makeLooped(</span>
					<span class="s4">this</span><span class="s2">,</span>
					<span class="s2">forkContext.head,</span>
					<span class="s2">context.continueDestSegments,</span>
				<span class="s2">);</span>

				<span class="s0">// If the context is a for-in/of loop, this affects a break also.</span>
				<span class="s4">if </span><span class="s2">(</span>
					<span class="s2">context.type === </span><span class="s3">&quot;ForInStatement&quot; </span><span class="s2">||</span>
					<span class="s2">context.type === </span><span class="s3">&quot;ForOfStatement&quot;</span>
				<span class="s2">) {</span>
					<span class="s2">context.brokenForkContext.add(forkContext.head);</span>
				<span class="s2">}</span>
			<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
				<span class="s2">context.continueForkContext.add(forkContext.head);</span>
			<span class="s2">}</span>
		<span class="s2">}</span>
		<span class="s2">forkContext.replaceHead(forkContext.makeUnreachable(-</span><span class="s5">1</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">));</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Makes a path for a `return` statement.</span>
	 <span class="s0">*</span>
	 <span class="s0">* It registers the head segment to a context of `return`.</span>
	 <span class="s0">* It makes new unreachable segment, then it set the head with the segment.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s2">makeReturn() {</span>
		<span class="s4">const </span><span class="s2">forkContext = </span><span class="s4">this</span><span class="s2">.forkContext;</span>

		<span class="s4">if </span><span class="s2">(forkContext.reachable) {</span>
			<span class="s2">getReturnContext(</span><span class="s4">this</span><span class="s2">).returnedForkContext.add(forkContext.head);</span>
			<span class="s2">forkContext.replaceHead(forkContext.makeUnreachable(-</span><span class="s5">1</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">));</span>
		<span class="s2">}</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Makes a path for a `throw` statement.</span>
	 <span class="s0">*</span>
	 <span class="s0">* It registers the head segment to a context of `throw`.</span>
	 <span class="s0">* It makes new unreachable segment, then it set the head with the segment.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s2">makeThrow() {</span>
		<span class="s4">const </span><span class="s2">forkContext = </span><span class="s4">this</span><span class="s2">.forkContext;</span>

		<span class="s4">if </span><span class="s2">(forkContext.reachable) {</span>
			<span class="s2">getThrowContext(</span><span class="s4">this</span><span class="s2">).thrownForkContext.add(forkContext.head);</span>
			<span class="s2">forkContext.replaceHead(forkContext.makeUnreachable(-</span><span class="s5">1</span><span class="s2">, -</span><span class="s5">1</span><span class="s2">));</span>
		<span class="s2">}</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Makes the final path.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s2">makeFinal() {</span>
		<span class="s4">const </span><span class="s2">segments = </span><span class="s4">this</span><span class="s2">.currentSegments;</span>

		<span class="s4">if </span><span class="s2">(segments.length &gt; </span><span class="s5">0 </span><span class="s2">&amp;&amp; segments[</span><span class="s5">0</span><span class="s2">].reachable) {</span>
			<span class="s4">this</span><span class="s2">.returnedForkContext.add(segments);</span>
		<span class="s2">}</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s2">module.exports = CodePathState;</span>
</pre>
</body>
</html>