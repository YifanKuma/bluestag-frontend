<html>
<head>
<title>pipeline.cc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #067d17;}
.s4 { color: #000000;}
.s5 { color: #00627a;}
.s6 { color: #871094; font-style: italic;}
.s7 { color: #1750eb; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
pipeline.cc</font>
</center></td></tr></table>
<pre><span class="s0">// Copyright 2013 Lovell Fuller and others.</span>
<span class="s0">// SPDX-License-Identifier: Apache-2.0</span>

<span class="s2">#include </span><span class="s3">&lt;algorithm&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;cmath&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;filesystem&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;map&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;memory&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;numeric&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;string&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;tuple&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;utility&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;vector&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;sys/types.h&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;sys/stat.h&gt;</span>

<span class="s2">#include </span><span class="s3">&lt;vips/vips8&gt;</span>
<span class="s2">#include </span><span class="s3">&lt;napi.h&gt;</span>

<span class="s2">#include </span><span class="s3">&quot;common.h&quot;</span>
<span class="s2">#include </span><span class="s3">&quot;operations.h&quot;</span>
<span class="s2">#include </span><span class="s3">&quot;pipeline.h&quot;</span>

<span class="s2">class </span>PipelineWorker <span class="s1">: </span><span class="s2">public </span>Napi<span class="s1">::AsyncWorker {</span>
 <span class="s2">public:</span>
  <span class="s5">PipelineWorker</span><span class="s1">(</span>Napi<span class="s1">::</span>Function callback<span class="s1">, </span>PipelineBaton <span class="s2">*</span>baton<span class="s1">,</span>
    Napi<span class="s1">::</span>Function debuglog<span class="s1">, </span>Napi<span class="s1">::</span>Function queueListener<span class="s1">) :</span>
    <span class="s1">Napi::</span><span class="s5">AsyncWorker</span><span class="s1">(callback),</span>
    <span class="s5">baton</span><span class="s1">(baton),</span>
    <span class="s5">debuglog</span><span class="s1">(</span>Napi<span class="s1">::</span><span class="s5">Persistent</span><span class="s1">(debuglog)),</span>
    <span class="s5">queueListener</span><span class="s1">(</span>Napi<span class="s1">::</span><span class="s5">Persistent</span><span class="s1">(queueListener)) {}</span>
  <span class="s5">~PipelineWorker</span><span class="s1">() {}</span>

  <span class="s0">// libuv worker</span>
  <span class="s1">void </span><span class="s5">Execute</span><span class="s1">() {</span>
    <span class="s0">// Decrement queued task counter</span>
    sharp<span class="s1">::counterQueue</span><span class="s2">--</span><span class="s1">;</span>
    <span class="s0">// Increment processing task counter</span>
    sharp<span class="s1">::counterProcess</span><span class="s2">++</span><span class="s1">;</span>

    <span class="s2">try </span><span class="s1">{</span>
      <span class="s0">// Open input</span>
      vips<span class="s1">::VImage image;</span>
      sharp<span class="s1">::ImageType inputImageType;</span>
      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>join<span class="s1">.</span><span class="s5">empty</span><span class="s1">()) {</span>
        std<span class="s1">::</span><span class="s5">tie</span><span class="s1">(image, inputImageType) </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">OpenInput</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>input<span class="s1">);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        std<span class="s1">::vector</span><span class="s2">&lt;</span><span class="s1">VImage</span><span class="s2">&gt; </span><span class="s1">images;</span>
        <span class="s2">bool </span><span class="s1">hasAlpha </span><span class="s2">= </span><span class="s6">false</span><span class="s1">;</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">auto &amp;</span><span class="s1">join : </span>baton<span class="s1">-&gt;</span>join<span class="s1">) {</span>
          std<span class="s1">::</span><span class="s5">tie</span><span class="s1">(image, inputImageType) </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">OpenInput</span><span class="s1">(join);</span>
          <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">EnsureColourspace</span><span class="s1">(image, </span>baton<span class="s1">-&gt;</span>colourspacePipeline<span class="s1">);</span>
          images<span class="s1">.</span><span class="s5">push_back</span><span class="s1">(image);</span>
          <span class="s1">hasAlpha </span><span class="s2">|= </span>image<span class="s1">.</span><span class="s5">has_alpha</span><span class="s1">();</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(hasAlpha) {</span>
          <span class="s2">for </span><span class="s1">(</span><span class="s2">auto &amp;</span><span class="s1">image : images) {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">!</span>image<span class="s1">.</span><span class="s5">has_alpha</span><span class="s1">()) {</span>
              <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">EnsureAlpha</span><span class="s1">(image, </span><span class="s7">1</span><span class="s1">);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          baton<span class="s1">-&gt;</span>input<span class="s1">-&gt;</span>joinBackground<span class="s1">.</span><span class="s5">pop_back</span><span class="s1">();</span>
        <span class="s1">}</span>
        <span class="s1">inputImageType </span><span class="s2">= </span>sharp<span class="s1">::</span>ImageType<span class="s1">::PNG;</span>
        <span class="s1">image </span><span class="s2">= </span>VImage<span class="s1">::</span><span class="s5">arrayjoin</span><span class="s1">(images, </span>VImage<span class="s1">::</span><span class="s5">option</span><span class="s1">()</span>
          <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;across&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>input<span class="s1">-&gt;</span>joinAcross<span class="s1">)</span>
          <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;shim&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>input<span class="s1">-&gt;</span>joinShim<span class="s1">)</span>
          <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;background&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>input<span class="s1">-&gt;</span>joinBackground<span class="s1">)</span>
          <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;halign&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>input<span class="s1">-&gt;</span>joinHalign<span class="s1">)</span>
          <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;valign&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>input<span class="s1">-&gt;</span>joinValign<span class="s1">));</span>
        <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>input<span class="s1">-&gt;</span>joinAnimated<span class="s1">) {</span>
          <span class="s1">image </span><span class="s2">= </span>image<span class="s1">.</span><span class="s5">copy</span><span class="s1">();</span>
          image<span class="s1">.</span><span class="s5">set</span><span class="s1">(VIPS_META_N_PAGES, </span><span class="s2">static_cast&lt;int&gt;</span><span class="s1">(</span>images<span class="s1">.</span><span class="s5">size</span><span class="s1">()));</span>
          image<span class="s1">.</span><span class="s5">set</span><span class="s1">(VIPS_META_PAGE_HEIGHT, </span><span class="s2">static_cast&lt;int&gt;</span><span class="s1">(</span>image<span class="s1">.</span><span class="s5">height</span><span class="s1">() </span><span class="s2">/ </span>images<span class="s1">.</span><span class="s5">size</span><span class="s1">()));</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s1">VipsAccess access </span><span class="s2">= </span>baton<span class="s1">-&gt;</span>input<span class="s1">-&gt;</span>access<span class="s1">;</span>
      <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">EnsureColourspace</span><span class="s1">(image, </span>baton<span class="s1">-&gt;</span>colourspacePipeline<span class="s1">);</span>

      <span class="s2">int </span><span class="s1">nPages </span><span class="s2">= </span>baton<span class="s1">-&gt;</span>input<span class="s1">-&gt;</span>pages<span class="s1">;</span>
      <span class="s2">if </span><span class="s1">(nPages </span><span class="s2">== -</span><span class="s7">1</span><span class="s1">) {</span>
        <span class="s0">// Resolve the number of pages if we need to render until the end of the document</span>
        <span class="s1">nPages </span><span class="s2">= </span>image<span class="s1">.</span><span class="s5">get_typeof</span><span class="s1">(VIPS_META_N_PAGES) </span><span class="s2">!= </span><span class="s7">0</span>
          <span class="s2">? </span>image<span class="s1">.</span><span class="s5">get_int</span><span class="s1">(VIPS_META_N_PAGES) </span><span class="s2">- </span>baton<span class="s1">-&gt;</span>input<span class="s1">-&gt;</span>page
          <span class="s2">: </span><span class="s7">1</span><span class="s1">;</span>
      <span class="s1">}</span>

      <span class="s0">// Get pre-resize page height</span>
      <span class="s2">int </span><span class="s1">pageHeight </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">GetPageHeight</span><span class="s1">(image);</span>

      <span class="s0">// Calculate angle of rotation</span>
      <span class="s1">VipsAngle rotation </span><span class="s2">= </span><span class="s1">VIPS_ANGLE_D0;</span>
      <span class="s1">VipsAngle autoRotation </span><span class="s2">= </span><span class="s1">VIPS_ANGLE_D0;</span>
      <span class="s2">bool </span><span class="s1">autoFlop </span><span class="s2">= </span><span class="s6">false</span><span class="s1">;</span>

      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>input<span class="s1">-&gt;</span>autoOrient<span class="s1">) {</span>
        <span class="s0">// Rotate and flip image according to Exif orientation</span>
        std<span class="s1">::</span><span class="s5">tie</span><span class="s1">(autoRotation, autoFlop) </span><span class="s2">= </span><span class="s5">CalculateExifRotationAndFlop</span><span class="s1">(</span>sharp<span class="s1">::</span><span class="s5">ExifOrientation</span><span class="s1">(image));</span>
      <span class="s1">}</span>

      <span class="s1">rotation </span><span class="s2">= </span><span class="s5">CalculateAngleRotation</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>angle<span class="s1">);</span>

      <span class="s2">bool const </span><span class="s1">shouldRotateBefore </span><span class="s2">= </span>baton<span class="s1">-&gt;</span>rotateBefore <span class="s2">&amp;&amp;</span>
        <span class="s1">(rotation </span><span class="s2">!= </span><span class="s1">VIPS_ANGLE_D0 </span><span class="s2">|| </span>baton<span class="s1">-&gt;</span>flip <span class="s2">|| </span>baton<span class="s1">-&gt;</span>flop <span class="s2">|| </span>baton<span class="s1">-&gt;</span>rotationAngle <span class="s2">!= </span><span class="s7">0.0</span><span class="s1">);</span>
      <span class="s2">bool const </span><span class="s1">shouldOrientBefore </span><span class="s2">= </span><span class="s1">(shouldRotateBefore </span><span class="s2">|| </span>baton<span class="s1">-&gt;</span>orientBefore<span class="s1">) </span><span class="s2">&amp;&amp;</span>
        <span class="s1">(autoRotation </span><span class="s2">!= </span><span class="s1">VIPS_ANGLE_D0 </span><span class="s2">|| </span><span class="s1">autoFlop);</span>

      <span class="s2">if </span><span class="s1">(shouldOrientBefore) {</span>
        <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">StaySequential</span><span class="s1">(image, autoRotation </span><span class="s2">!= </span><span class="s1">VIPS_ANGLE_D0);</span>
        <span class="s2">if </span><span class="s1">(autoRotation </span><span class="s2">!= </span><span class="s1">VIPS_ANGLE_D0) {</span>
          <span class="s2">if </span><span class="s1">(autoRotation </span><span class="s2">!= </span><span class="s1">VIPS_ANGLE_D180) {</span>
            <span class="s5">MultiPageUnsupported</span><span class="s1">(nPages, </span><span class="s3">&quot;Rotate&quot;</span><span class="s1">);</span>
          <span class="s1">}</span>
          <span class="s1">image </span><span class="s2">= </span>image<span class="s1">.</span><span class="s5">rot</span><span class="s1">(autoRotation);</span>
          <span class="s1">autoRotation </span><span class="s2">= </span><span class="s1">VIPS_ANGLE_D0;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(autoFlop) {</span>
          <span class="s1">image </span><span class="s2">= </span>image<span class="s1">.</span><span class="s5">flip</span><span class="s1">(VIPS_DIRECTION_HORIZONTAL);</span>
          <span class="s1">autoFlop </span><span class="s2">= </span><span class="s6">false</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(shouldRotateBefore) {</span>
        <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">StaySequential</span><span class="s1">(image, rotation </span><span class="s2">!= </span><span class="s1">VIPS_ANGLE_D0 </span><span class="s2">|| </span>baton<span class="s1">-&gt;</span>flip <span class="s2">|| </span>baton<span class="s1">-&gt;</span>rotationAngle <span class="s2">!= </span><span class="s7">0.0</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>flip<span class="s1">) {</span>
          <span class="s1">image </span><span class="s2">= </span>image<span class="s1">.</span><span class="s5">flip</span><span class="s1">(VIPS_DIRECTION_VERTICAL);</span>
          baton<span class="s1">-&gt;</span>flip <span class="s2">= </span><span class="s6">false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>flop<span class="s1">) {</span>
          <span class="s1">image </span><span class="s2">= </span>image<span class="s1">.</span><span class="s5">flip</span><span class="s1">(VIPS_DIRECTION_HORIZONTAL);</span>
          baton<span class="s1">-&gt;</span>flop <span class="s2">= </span><span class="s6">false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(rotation </span><span class="s2">!= </span><span class="s1">VIPS_ANGLE_D0) {</span>
          <span class="s2">if </span><span class="s1">(rotation </span><span class="s2">!= </span><span class="s1">VIPS_ANGLE_D180) {</span>
            <span class="s5">MultiPageUnsupported</span><span class="s1">(nPages, </span><span class="s3">&quot;Rotate&quot;</span><span class="s1">);</span>
          <span class="s1">}</span>
          <span class="s1">image </span><span class="s2">= </span>image<span class="s1">.</span><span class="s5">rot</span><span class="s1">(rotation);</span>
          <span class="s1">rotation </span><span class="s2">= </span><span class="s1">VIPS_ANGLE_D0;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>rotationAngle <span class="s2">!= </span><span class="s7">0.0</span><span class="s1">) {</span>
          <span class="s5">MultiPageUnsupported</span><span class="s1">(nPages, </span><span class="s3">&quot;Rotate&quot;</span><span class="s1">);</span>
          std<span class="s1">::vector</span><span class="s2">&lt;double&gt; </span><span class="s1">background;</span>
          std<span class="s1">::</span><span class="s5">tie</span><span class="s1">(image, background) </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">ApplyAlpha</span><span class="s1">(image, </span>baton<span class="s1">-&gt;</span>rotationBackground<span class="s1">, </span><span class="s6">false</span><span class="s1">);</span>
          <span class="s1">image </span><span class="s2">= </span>image<span class="s1">.</span><span class="s5">rotate</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>rotationAngle<span class="s1">, </span>VImage<span class="s1">::</span><span class="s5">option</span><span class="s1">()-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;background&quot;</span><span class="s1">, background)).</span><span class="s5">copy_memory</span><span class="s1">();</span>
          baton<span class="s1">-&gt;</span>rotationAngle <span class="s2">= </span><span class="s7">0.0</span><span class="s1">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s0">// Trim</span>
      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>trimThreshold <span class="s2">&gt;= </span><span class="s7">0.0</span><span class="s1">) {</span>
        <span class="s5">MultiPageUnsupported</span><span class="s1">(nPages, </span><span class="s3">&quot;Trim&quot;</span><span class="s1">);</span>
        <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">StaySequential</span><span class="s1">(image);</span>
        <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">Trim</span><span class="s1">(image, </span>baton<span class="s1">-&gt;</span>trimBackground<span class="s1">, </span>baton<span class="s1">-&gt;</span>trimThreshold<span class="s1">, </span>baton<span class="s1">-&gt;</span>trimLineArt<span class="s1">);</span>
        baton<span class="s1">-&gt;</span>trimOffsetLeft <span class="s2">= </span>image<span class="s1">.</span><span class="s5">xoffset</span><span class="s1">();</span>
        baton<span class="s1">-&gt;</span>trimOffsetTop <span class="s2">= </span>image<span class="s1">.</span><span class="s5">yoffset</span><span class="s1">();</span>
      <span class="s1">}</span>

      <span class="s0">// Pre extraction</span>
      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>topOffsetPre <span class="s2">!= -</span><span class="s7">1</span><span class="s1">) {</span>
        <span class="s1">image </span><span class="s2">= </span><span class="s1">nPages </span><span class="s2">&gt; </span><span class="s7">1</span>
          <span class="s2">? </span>sharp<span class="s1">::</span><span class="s5">CropMultiPage</span><span class="s1">(image,</span>
              baton<span class="s1">-&gt;</span>leftOffsetPre<span class="s1">, </span>baton<span class="s1">-&gt;</span>topOffsetPre<span class="s1">, </span>baton<span class="s1">-&gt;</span>widthPre<span class="s1">, </span>baton<span class="s1">-&gt;</span>heightPre<span class="s1">, nPages, </span><span class="s2">&amp;</span><span class="s1">pageHeight)</span>
          <span class="s2">: </span>image<span class="s1">.</span><span class="s5">extract_area</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>leftOffsetPre<span class="s1">, </span>baton<span class="s1">-&gt;</span>topOffsetPre<span class="s1">, </span>baton<span class="s1">-&gt;</span>widthPre<span class="s1">, </span>baton<span class="s1">-&gt;</span>heightPre<span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s0">// Get pre-resize image width and height</span>
      <span class="s2">int </span><span class="s1">inputWidth </span><span class="s2">= </span>image<span class="s1">.</span><span class="s5">width</span><span class="s1">();</span>
      <span class="s2">int </span><span class="s1">inputHeight </span><span class="s2">= </span>image<span class="s1">.</span><span class="s5">height</span><span class="s1">();</span>

      <span class="s0">// Is there just one page? Shrink to inputHeight instead</span>
      <span class="s2">if </span><span class="s1">(nPages </span><span class="s2">== </span><span class="s7">1</span><span class="s1">) {</span>
        <span class="s1">pageHeight </span><span class="s2">= </span><span class="s1">inputHeight;</span>
      <span class="s1">}</span>

      <span class="s0">// Scaling calculations</span>
      <span class="s2">double </span><span class="s1">hshrink;</span>
      <span class="s2">double </span><span class="s1">vshrink;</span>
      <span class="s2">int </span><span class="s1">targetResizeWidth </span><span class="s2">= </span>baton<span class="s1">-&gt;</span>width<span class="s1">;</span>
      <span class="s2">int </span><span class="s1">targetResizeHeight </span><span class="s2">= </span>baton<span class="s1">-&gt;</span>height<span class="s1">;</span>

      <span class="s0">// When auto-rotating by 90 or 270 degrees, swap the target width and</span>
      <span class="s0">// height to ensure the behavior aligns with how it would have been if</span>
      <span class="s0">// the rotation had taken place *before* resizing.</span>
      <span class="s2">if </span><span class="s1">(autoRotation </span><span class="s2">== </span><span class="s1">VIPS_ANGLE_D90 </span><span class="s2">|| </span><span class="s1">autoRotation </span><span class="s2">== </span><span class="s1">VIPS_ANGLE_D270) {</span>
        std<span class="s1">::</span><span class="s5">swap</span><span class="s1">(targetResizeWidth, targetResizeHeight);</span>
      <span class="s1">}</span>

      <span class="s0">// Shrink to pageHeight, so we work for multi-page images</span>
      std<span class="s1">::</span><span class="s5">tie</span><span class="s1">(hshrink, vshrink) </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">ResolveShrink</span><span class="s1">(</span>
        <span class="s1">inputWidth, pageHeight, targetResizeWidth, targetResizeHeight,</span>
        baton<span class="s1">-&gt;</span>canvas<span class="s1">, </span>baton<span class="s1">-&gt;</span>withoutEnlargement<span class="s1">, </span>baton<span class="s1">-&gt;</span>withoutReduction<span class="s1">);</span>

      <span class="s0">// The jpeg preload shrink.</span>
      <span class="s2">int </span><span class="s1">jpegShrinkOnLoad </span><span class="s2">= </span><span class="s7">1</span><span class="s1">;</span>

      <span class="s0">// WebP, PDF, SVG scale</span>
      <span class="s2">double </span><span class="s1">scale </span><span class="s2">= </span><span class="s7">1.0</span><span class="s1">;</span>

      <span class="s0">// Try to reload input using shrink-on-load for JPEG, WebP, SVG and PDF, when:</span>
      <span class="s0">//  - the width or height parameters are specified;</span>
      <span class="s0">//  - gamma correction doesn't need to be applied;</span>
      <span class="s0">//  - trimming or pre-resize extract isn't required;</span>
      <span class="s0">//  - input colourspace is not specified;</span>
      <span class="s2">bool const </span><span class="s1">shouldPreShrink </span><span class="s2">= </span><span class="s1">(targetResizeWidth </span><span class="s2">&gt; </span><span class="s7">0 </span><span class="s2">|| </span><span class="s1">targetResizeHeight </span><span class="s2">&gt; </span><span class="s7">0</span><span class="s1">) </span><span class="s2">&amp;&amp;</span>
        baton<span class="s1">-&gt;</span>gamma <span class="s2">== </span><span class="s7">0 </span><span class="s2">&amp;&amp; </span>baton<span class="s1">-&gt;</span>topOffsetPre <span class="s2">== -</span><span class="s7">1 </span><span class="s2">&amp;&amp; </span>baton<span class="s1">-&gt;</span>trimThreshold <span class="s2">&lt; </span><span class="s7">0.0 </span><span class="s2">&amp;&amp;</span>
        baton<span class="s1">-&gt;</span>colourspacePipeline <span class="s2">== </span><span class="s1">VIPS_INTERPRETATION_LAST </span><span class="s2">&amp;&amp; !</span><span class="s1">(shouldOrientBefore </span><span class="s2">|| </span><span class="s1">shouldRotateBefore);</span>

      <span class="s2">if </span><span class="s1">(shouldPreShrink) {</span>
        <span class="s0">// The common part of the shrink: the bit by which both axes must be shrunk</span>
        <span class="s2">double </span><span class="s1">shrink </span><span class="s2">= </span>std<span class="s1">::</span><span class="s5">min</span><span class="s1">(hshrink, vshrink);</span>

        <span class="s2">if </span><span class="s1">(inputImageType </span><span class="s2">== </span>sharp<span class="s1">::</span>ImageType<span class="s1">::JPEG) {</span>
          <span class="s0">// Leave at least a factor of two for the final resize step, when fastShrinkOnLoad: false</span>
          <span class="s0">// for more consistent results and to avoid extra sharpness to the image</span>
          <span class="s2">int </span><span class="s1">factor </span><span class="s2">= </span>baton<span class="s1">-&gt;</span>fastShrinkOnLoad <span class="s2">? </span><span class="s7">1 </span><span class="s2">: </span><span class="s7">2</span><span class="s1">;</span>
          <span class="s2">if </span><span class="s1">(shrink </span><span class="s2">&gt;= </span><span class="s7">8 </span><span class="s2">* </span><span class="s1">factor) {</span>
            <span class="s1">jpegShrinkOnLoad </span><span class="s2">= </span><span class="s7">8</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s2">else if </span><span class="s1">(shrink </span><span class="s2">&gt;= </span><span class="s7">4 </span><span class="s2">* </span><span class="s1">factor) {</span>
            <span class="s1">jpegShrinkOnLoad </span><span class="s2">= </span><span class="s7">4</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s2">else if </span><span class="s1">(shrink </span><span class="s2">&gt;= </span><span class="s7">2 </span><span class="s2">* </span><span class="s1">factor) {</span>
            <span class="s1">jpegShrinkOnLoad </span><span class="s2">= </span><span class="s7">2</span><span class="s1">;</span>
          <span class="s1">}</span>
          <span class="s0">// Lower shrink-on-load for known libjpeg rounding errors</span>
          <span class="s2">if </span><span class="s1">(jpegShrinkOnLoad </span><span class="s2">&gt; </span><span class="s7">1 </span><span class="s2">&amp;&amp; static_cast&lt;int&gt;</span><span class="s1">(shrink) </span><span class="s2">== </span><span class="s1">jpegShrinkOnLoad) {</span>
            <span class="s1">jpegShrinkOnLoad </span><span class="s2">/= </span><span class="s7">2</span><span class="s1">;</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(inputImageType </span><span class="s2">== </span>sharp<span class="s1">::</span>ImageType<span class="s1">::WEBP </span><span class="s2">&amp;&amp; </span>baton<span class="s1">-&gt;</span>fastShrinkOnLoad <span class="s2">&amp;&amp; </span><span class="s1">shrink </span><span class="s2">&gt; </span><span class="s7">1.0</span><span class="s1">) {</span>
          <span class="s0">// Avoid upscaling via webp</span>
          <span class="s1">scale </span><span class="s2">= </span><span class="s7">1.0 </span><span class="s2">/ </span><span class="s1">shrink;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(inputImageType </span><span class="s2">== </span>sharp<span class="s1">::</span>ImageType<span class="s1">::SVG </span><span class="s2">||</span>
                   <span class="s1">inputImageType </span><span class="s2">== </span>sharp<span class="s1">::</span>ImageType<span class="s1">::PDF) {</span>
          <span class="s1">scale </span><span class="s2">= </span><span class="s7">1.0 </span><span class="s2">/ </span><span class="s1">shrink;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s0">// Reload input using shrink-on-load, it'll be an integer shrink</span>
      <span class="s0">// factor for jpegload*, a double scale factor for webpload*,</span>
      <span class="s0">// pdfload* and svgload*</span>
      <span class="s2">if </span><span class="s1">(jpegShrinkOnLoad </span><span class="s2">&gt; </span><span class="s7">1</span><span class="s1">) {</span>
        vips<span class="s1">::VOption </span><span class="s2">*</span><span class="s1">option </span><span class="s2">= </span><span class="s5">GetOptionsForImageType</span><span class="s1">(inputImageType, </span>baton<span class="s1">-&gt;</span>input<span class="s1">)-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;shrink&quot;</span><span class="s1">, jpegShrinkOnLoad);</span>
        <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>input<span class="s1">-&gt;</span>buffer <span class="s2">!= </span><span class="s6">nullptr</span><span class="s1">) {</span>
          <span class="s0">// Reload JPEG buffer</span>
          <span class="s1">VipsBlob </span><span class="s2">*</span><span class="s1">blob </span><span class="s2">= </span><span class="s5">vips_blob_new</span><span class="s1">(</span><span class="s6">nullptr</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>input<span class="s1">-&gt;</span>buffer<span class="s1">, </span>baton<span class="s1">-&gt;</span>input<span class="s1">-&gt;</span>bufferLength<span class="s1">);</span>
          <span class="s1">image </span><span class="s2">= </span>VImage<span class="s1">::</span><span class="s5">jpegload_buffer</span><span class="s1">(blob, option);</span>
          <span class="s5">vips_area_unref</span><span class="s1">(</span><span class="s2">reinterpret_cast&lt;</span><span class="s1">VipsArea</span><span class="s2">*&gt;</span><span class="s1">(blob));</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s0">// Reload JPEG file</span>
          <span class="s1">image </span><span class="s2">= </span>VImage<span class="s1">::</span><span class="s5">jpegload</span><span class="s1">(</span><span class="s2">const_cast&lt;char*&gt;</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>input<span class="s1">-&gt;</span>file<span class="s1">.</span><span class="s5">data</span><span class="s1">()), option);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(scale </span><span class="s2">!= </span><span class="s7">1.0</span><span class="s1">) {</span>
        vips<span class="s1">::VOption </span><span class="s2">*</span><span class="s1">option </span><span class="s2">= </span><span class="s5">GetOptionsForImageType</span><span class="s1">(inputImageType, </span>baton<span class="s1">-&gt;</span>input<span class="s1">)-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;scale&quot;</span><span class="s1">, scale);</span>
        <span class="s2">if </span><span class="s1">(inputImageType </span><span class="s2">== </span>sharp<span class="s1">::</span>ImageType<span class="s1">::WEBP) {</span>
          <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>input<span class="s1">-&gt;</span>buffer <span class="s2">!= </span><span class="s6">nullptr</span><span class="s1">) {</span>
            <span class="s0">// Reload WebP buffer</span>
            <span class="s1">VipsBlob </span><span class="s2">*</span><span class="s1">blob </span><span class="s2">= </span><span class="s5">vips_blob_new</span><span class="s1">(</span><span class="s6">nullptr</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>input<span class="s1">-&gt;</span>buffer<span class="s1">, </span>baton<span class="s1">-&gt;</span>input<span class="s1">-&gt;</span>bufferLength<span class="s1">);</span>
            <span class="s1">image </span><span class="s2">= </span>VImage<span class="s1">::</span><span class="s5">webpload_buffer</span><span class="s1">(blob, option);</span>
            <span class="s5">vips_area_unref</span><span class="s1">(</span><span class="s2">reinterpret_cast&lt;</span><span class="s1">VipsArea</span><span class="s2">*&gt;</span><span class="s1">(blob));</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s0">// Reload WebP file</span>
            <span class="s1">image </span><span class="s2">= </span>VImage<span class="s1">::</span><span class="s5">webpload</span><span class="s1">(</span><span class="s2">const_cast&lt;char*&gt;</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>input<span class="s1">-&gt;</span>file<span class="s1">.</span><span class="s5">data</span><span class="s1">()), option);</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(inputImageType </span><span class="s2">== </span>sharp<span class="s1">::</span>ImageType<span class="s1">::SVG) {</span>
          <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>input<span class="s1">-&gt;</span>buffer <span class="s2">!= </span><span class="s6">nullptr</span><span class="s1">) {</span>
            <span class="s0">// Reload SVG buffer</span>
            <span class="s1">VipsBlob </span><span class="s2">*</span><span class="s1">blob </span><span class="s2">= </span><span class="s5">vips_blob_new</span><span class="s1">(</span><span class="s6">nullptr</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>input<span class="s1">-&gt;</span>buffer<span class="s1">, </span>baton<span class="s1">-&gt;</span>input<span class="s1">-&gt;</span>bufferLength<span class="s1">);</span>
            <span class="s1">image </span><span class="s2">= </span>VImage<span class="s1">::</span><span class="s5">svgload_buffer</span><span class="s1">(blob, option);</span>
            <span class="s5">vips_area_unref</span><span class="s1">(</span><span class="s2">reinterpret_cast&lt;</span><span class="s1">VipsArea</span><span class="s2">*&gt;</span><span class="s1">(blob));</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s0">// Reload SVG file</span>
            <span class="s1">image </span><span class="s2">= </span>VImage<span class="s1">::</span><span class="s5">svgload</span><span class="s1">(</span><span class="s2">const_cast&lt;char*&gt;</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>input<span class="s1">-&gt;</span>file<span class="s1">.</span><span class="s5">data</span><span class="s1">()), option);</span>
          <span class="s1">}</span>
          sharp<span class="s1">::</span><span class="s5">SetDensity</span><span class="s1">(image, </span>baton<span class="s1">-&gt;</span>input<span class="s1">-&gt;</span>density<span class="s1">);</span>
          <span class="s2">if </span><span class="s1">(</span>image<span class="s1">.</span><span class="s5">width</span><span class="s1">() </span><span class="s2">&gt; </span><span class="s7">32767 </span><span class="s2">|| </span>image<span class="s1">.</span><span class="s5">height</span><span class="s1">() </span><span class="s2">&gt; </span><span class="s7">32767</span><span class="s1">) {</span>
            <span class="s2">throw </span>vips<span class="s1">::</span><span class="s5">VError</span><span class="s1">(</span><span class="s3">&quot;Input SVG image will exceed 32767x32767 pixel limit when scaled&quot;</span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(inputImageType </span><span class="s2">== </span>sharp<span class="s1">::</span>ImageType<span class="s1">::PDF) {</span>
          <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>input<span class="s1">-&gt;</span>buffer <span class="s2">!= </span><span class="s6">nullptr</span><span class="s1">) {</span>
            <span class="s0">// Reload PDF buffer</span>
            <span class="s1">VipsBlob </span><span class="s2">*</span><span class="s1">blob </span><span class="s2">= </span><span class="s5">vips_blob_new</span><span class="s1">(</span><span class="s6">nullptr</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>input<span class="s1">-&gt;</span>buffer<span class="s1">, </span>baton<span class="s1">-&gt;</span>input<span class="s1">-&gt;</span>bufferLength<span class="s1">);</span>
            <span class="s1">image </span><span class="s2">= </span>VImage<span class="s1">::</span><span class="s5">pdfload_buffer</span><span class="s1">(blob, option);</span>
            <span class="s5">vips_area_unref</span><span class="s1">(</span><span class="s2">reinterpret_cast&lt;</span><span class="s1">VipsArea</span><span class="s2">*&gt;</span><span class="s1">(blob));</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s0">// Reload PDF file</span>
            <span class="s1">image </span><span class="s2">= </span>VImage<span class="s1">::</span><span class="s5">pdfload</span><span class="s1">(</span><span class="s2">const_cast&lt;char*&gt;</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>input<span class="s1">-&gt;</span>file<span class="s1">.</span><span class="s5">data</span><span class="s1">()), option);</span>
          <span class="s1">}</span>
          sharp<span class="s1">::</span><span class="s5">SetDensity</span><span class="s1">(image, </span>baton<span class="s1">-&gt;</span>input<span class="s1">-&gt;</span>density<span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">if </span><span class="s1">(inputImageType </span><span class="s2">== </span>sharp<span class="s1">::</span>ImageType<span class="s1">::SVG </span><span class="s2">&amp;&amp; </span><span class="s1">(</span>image<span class="s1">.</span><span class="s5">width</span><span class="s1">() </span><span class="s2">&gt; </span><span class="s7">32767 </span><span class="s2">|| </span>image<span class="s1">.</span><span class="s5">height</span><span class="s1">() </span><span class="s2">&gt; </span><span class="s7">32767</span><span class="s1">)) {</span>
          <span class="s2">throw </span>vips<span class="s1">::</span><span class="s5">VError</span><span class="s1">(</span><span class="s3">&quot;Input SVG image exceeds 32767x32767 pixel limit&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>input<span class="s1">-&gt;</span>autoOrient<span class="s1">) {</span>
        <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">RemoveExifOrientation</span><span class="s1">(image);</span>
      <span class="s1">}</span>

      <span class="s0">// Any pre-shrinking may already have been done</span>
      <span class="s1">inputWidth </span><span class="s2">= </span>image<span class="s1">.</span><span class="s5">width</span><span class="s1">();</span>
      <span class="s1">inputHeight </span><span class="s2">= </span>image<span class="s1">.</span><span class="s5">height</span><span class="s1">();</span>

      <span class="s0">// After pre-shrink, but before the main shrink stage</span>
      <span class="s0">// Reuse the initial pageHeight if we didn't pre-shrink</span>
      <span class="s2">if </span><span class="s1">(shouldPreShrink) {</span>
        <span class="s1">pageHeight </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">GetPageHeight</span><span class="s1">(image);</span>
      <span class="s1">}</span>

      <span class="s0">// Shrink to pageHeight, so we work for multi-page images</span>
      std<span class="s1">::</span><span class="s5">tie</span><span class="s1">(hshrink, vshrink) </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">ResolveShrink</span><span class="s1">(</span>
        <span class="s1">inputWidth, pageHeight, targetResizeWidth, targetResizeHeight,</span>
        baton<span class="s1">-&gt;</span>canvas<span class="s1">, </span>baton<span class="s1">-&gt;</span>withoutEnlargement<span class="s1">, </span>baton<span class="s1">-&gt;</span>withoutReduction<span class="s1">);</span>

      <span class="s2">int </span><span class="s1">targetHeight </span><span class="s2">= static_cast&lt;int&gt;</span><span class="s1">(</span>std<span class="s1">::</span><span class="s5">rint</span><span class="s1">(</span><span class="s2">static_cast&lt;double&gt;</span><span class="s1">(pageHeight) </span><span class="s2">/ </span><span class="s1">vshrink));</span>
      <span class="s2">int </span><span class="s1">targetPageHeight </span><span class="s2">= </span><span class="s1">targetHeight;</span>

      <span class="s0">// In toilet-roll mode, we must adjust vshrink so that we exactly hit</span>
      <span class="s0">// pageHeight or we'll have pixels straddling pixel boundaries</span>
      <span class="s2">if </span><span class="s1">(inputHeight </span><span class="s2">&gt; </span><span class="s1">pageHeight) {</span>
        <span class="s1">targetHeight </span><span class="s2">*= </span><span class="s1">nPages;</span>
        <span class="s1">vshrink </span><span class="s2">= static_cast&lt;double&gt;</span><span class="s1">(inputHeight) </span><span class="s2">/ </span><span class="s1">targetHeight;</span>
      <span class="s1">}</span>

      <span class="s0">// Ensure we're using a device-independent colour space</span>
      std<span class="s1">::pair</span><span class="s2">&lt;char*</span><span class="s1">, </span><span class="s2">size_t&gt; </span><span class="s5">inputProfile</span><span class="s1">(</span><span class="s6">nullptr</span><span class="s1">, </span><span class="s7">0</span><span class="s1">);</span>
      <span class="s2">if </span><span class="s1">((</span>baton<span class="s1">-&gt;</span>keepMetadata <span class="s2">&amp; </span><span class="s1">VIPS_FOREIGN_KEEP_ICC) </span><span class="s2">&amp;&amp; </span>baton<span class="s1">-&gt;</span>withIccProfile<span class="s1">.</span><span class="s5">empty</span><span class="s1">()) {</span>
        <span class="s0">// Cache input profile for use with output</span>
        <span class="s1">inputProfile </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">GetProfile</span><span class="s1">(image);</span>
        baton<span class="s1">-&gt;</span>input<span class="s1">-&gt;</span>ignoreIcc <span class="s2">= </span><span class="s6">true</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">char const *</span><span class="s1">processingProfile </span><span class="s2">= </span>image<span class="s1">.</span><span class="s5">interpretation</span><span class="s1">() </span><span class="s2">== </span><span class="s1">VIPS_INTERPRETATION_RGB16 </span><span class="s2">? </span><span class="s3">&quot;p3&quot; </span><span class="s2">: </span><span class="s3">&quot;srgb&quot;</span><span class="s1">;</span>
      <span class="s2">if </span><span class="s1">(</span>
        sharp<span class="s1">::</span><span class="s5">HasProfile</span><span class="s1">(image) </span><span class="s2">&amp;&amp;</span>
        image<span class="s1">.</span><span class="s5">interpretation</span><span class="s1">() </span><span class="s2">!= </span><span class="s1">VIPS_INTERPRETATION_LABS </span><span class="s2">&amp;&amp;</span>
        image<span class="s1">.</span><span class="s5">interpretation</span><span class="s1">() </span><span class="s2">!= </span><span class="s1">VIPS_INTERPRETATION_GREY16 </span><span class="s2">&amp;&amp;</span>
        baton<span class="s1">-&gt;</span>colourspacePipeline <span class="s2">!= </span><span class="s1">VIPS_INTERPRETATION_CMYK </span><span class="s2">&amp;&amp;</span>
        <span class="s2">!</span>baton<span class="s1">-&gt;</span>input<span class="s1">-&gt;</span>ignoreIcc
      <span class="s1">) {</span>
        <span class="s0">// Convert to sRGB/P3 using embedded profile</span>
        <span class="s2">try </span><span class="s1">{</span>
          <span class="s1">image </span><span class="s2">= </span>image<span class="s1">.</span><span class="s5">icc_transform</span><span class="s1">(processingProfile, </span>VImage<span class="s1">::</span><span class="s5">option</span><span class="s1">()</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;embedded&quot;</span><span class="s1">, </span><span class="s6">true</span><span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;depth&quot;</span><span class="s1">, </span>sharp<span class="s1">::</span><span class="s5">Is16Bit</span><span class="s1">(</span>image<span class="s1">.</span><span class="s5">interpretation</span><span class="s1">()) </span><span class="s2">? </span><span class="s7">16 </span><span class="s2">: </span><span class="s7">8</span><span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;intent&quot;</span><span class="s1">, VIPS_INTENT_PERCEPTUAL));</span>
        <span class="s1">} </span><span class="s2">catch</span><span class="s1">(...) {</span>
          sharp<span class="s1">::</span><span class="s5">VipsWarningCallback</span><span class="s1">(</span><span class="s6">nullptr</span><span class="s1">, G_LOG_LEVEL_WARNING, </span><span class="s3">&quot;Invalid embedded profile&quot;</span><span class="s1">, </span><span class="s6">nullptr</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span>
        image<span class="s1">.</span><span class="s5">interpretation</span><span class="s1">() </span><span class="s2">== </span><span class="s1">VIPS_INTERPRETATION_CMYK </span><span class="s2">&amp;&amp;</span>
        baton<span class="s1">-&gt;</span>colourspacePipeline <span class="s2">!= </span><span class="s1">VIPS_INTERPRETATION_CMYK 
      ) {</span>
        <span class="s1">image </span><span class="s2">= </span>image<span class="s1">.</span><span class="s5">icc_transform</span><span class="s1">(processingProfile, </span>VImage<span class="s1">::</span><span class="s5">option</span><span class="s1">()</span>
          <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;input_profile&quot;</span><span class="s1">, </span><span class="s3">&quot;cmyk&quot;</span><span class="s1">)</span>
          <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;intent&quot;</span><span class="s1">, VIPS_INTENT_PERCEPTUAL));</span>
      <span class="s1">}</span>

      <span class="s0">// Flatten image to remove alpha channel</span>
      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>flatten <span class="s2">&amp;&amp; </span>image<span class="s1">.</span><span class="s5">has_alpha</span><span class="s1">()) {</span>
        <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">Flatten</span><span class="s1">(image, </span>baton<span class="s1">-&gt;</span>flattenBackground<span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s0">// Gamma encoding (darken)</span>
      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>gamma <span class="s2">&gt;= </span><span class="s7">1 </span><span class="s2">&amp;&amp; </span>baton<span class="s1">-&gt;</span>gamma <span class="s2">&lt;= </span><span class="s7">3</span><span class="s1">) {</span>
        <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">Gamma</span><span class="s1">(image, </span><span class="s7">1.0 </span><span class="s2">/ </span>baton<span class="s1">-&gt;</span>gamma<span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s0">// Convert to greyscale (linear, therefore after gamma encoding, if any)</span>
      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>greyscale<span class="s1">) {</span>
        <span class="s1">image </span><span class="s2">= </span>image<span class="s1">.</span><span class="s5">colourspace</span><span class="s1">(VIPS_INTERPRETATION_B_W);</span>
      <span class="s1">}</span>

      <span class="s2">bool const </span><span class="s1">shouldResize </span><span class="s2">= </span><span class="s1">hshrink </span><span class="s2">!= </span><span class="s7">1.0 </span><span class="s2">|| </span><span class="s1">vshrink </span><span class="s2">!= </span><span class="s7">1.0</span><span class="s1">;</span>
      <span class="s2">bool const </span><span class="s1">shouldBlur </span><span class="s2">= </span>baton<span class="s1">-&gt;</span>blurSigma <span class="s2">!= </span><span class="s7">0.0</span><span class="s1">;</span>
      <span class="s2">bool const </span><span class="s1">shouldConv </span><span class="s2">= </span>baton<span class="s1">-&gt;</span>convKernelWidth <span class="s2">* </span>baton<span class="s1">-&gt;</span>convKernelHeight <span class="s2">&gt; </span><span class="s7">0</span><span class="s1">;</span>
      <span class="s2">bool const </span><span class="s1">shouldSharpen </span><span class="s2">= </span>baton<span class="s1">-&gt;</span>sharpenSigma <span class="s2">!= </span><span class="s7">0.0</span><span class="s1">;</span>
      <span class="s2">bool const </span><span class="s1">shouldComposite </span><span class="s2">= !</span>baton<span class="s1">-&gt;</span>composite<span class="s1">.</span><span class="s5">empty</span><span class="s1">();</span>

      <span class="s2">if </span><span class="s1">(shouldComposite </span><span class="s2">&amp;&amp; !</span>image<span class="s1">.</span><span class="s5">has_alpha</span><span class="s1">()) {</span>
        <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">EnsureAlpha</span><span class="s1">(image, </span><span class="s7">1</span><span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s1">VipsBandFormat premultiplyFormat </span><span class="s2">= </span>image<span class="s1">.</span><span class="s5">format</span><span class="s1">();</span>
      <span class="s2">bool const </span><span class="s1">shouldPremultiplyAlpha </span><span class="s2">= </span>image<span class="s1">.</span><span class="s5">has_alpha</span><span class="s1">() </span><span class="s2">&amp;&amp;</span>
        <span class="s1">(shouldResize </span><span class="s2">|| </span><span class="s1">shouldBlur </span><span class="s2">|| </span><span class="s1">shouldConv </span><span class="s2">|| </span><span class="s1">shouldSharpen);</span>

      <span class="s2">if </span><span class="s1">(shouldPremultiplyAlpha) {</span>
        <span class="s1">image </span><span class="s2">= </span>image<span class="s1">.</span><span class="s5">premultiply</span><span class="s1">().</span><span class="s5">cast</span><span class="s1">(premultiplyFormat);</span>
      <span class="s1">}</span>

      <span class="s0">// Resize</span>
      <span class="s2">if </span><span class="s1">(shouldResize) {</span>
        <span class="s1">image </span><span class="s2">= </span>image<span class="s1">.</span><span class="s5">resize</span><span class="s1">(</span><span class="s7">1.0 </span><span class="s2">/ </span><span class="s1">hshrink, </span>VImage<span class="s1">::</span><span class="s5">option</span><span class="s1">()</span>
          <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;vscale&quot;</span><span class="s1">, </span><span class="s7">1.0 </span><span class="s2">/ </span><span class="s1">vshrink)</span>
          <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;kernel&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>kernel<span class="s1">));</span>
      <span class="s1">}</span>

      <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">StaySequential</span><span class="s1">(image,</span>
        <span class="s1">autoRotation </span><span class="s2">!= </span><span class="s1">VIPS_ANGLE_D0 </span><span class="s2">||</span>
        baton<span class="s1">-&gt;</span>flip <span class="s2">||</span>
        <span class="s1">rotation </span><span class="s2">!= </span><span class="s1">VIPS_ANGLE_D0);</span>
      <span class="s0">// Auto-rotate post-extract</span>
      <span class="s2">if </span><span class="s1">(autoRotation </span><span class="s2">!= </span><span class="s1">VIPS_ANGLE_D0) {</span>
        <span class="s2">if </span><span class="s1">(autoRotation </span><span class="s2">!= </span><span class="s1">VIPS_ANGLE_D180) {</span>
          <span class="s5">MultiPageUnsupported</span><span class="s1">(nPages, </span><span class="s3">&quot;Rotate&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s1">image </span><span class="s2">= </span>image<span class="s1">.</span><span class="s5">rot</span><span class="s1">(autoRotation);</span>
      <span class="s1">}</span>
      <span class="s0">// Mirror vertically (up-down) about the x-axis</span>
      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>flip<span class="s1">) {</span>
        <span class="s1">image </span><span class="s2">= </span>image<span class="s1">.</span><span class="s5">flip</span><span class="s1">(VIPS_DIRECTION_VERTICAL);</span>
      <span class="s1">}</span>
      <span class="s0">// Mirror horizontally (left-right) about the y-axis</span>
      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>flop <span class="s2">!= </span><span class="s1">autoFlop) {</span>
        <span class="s1">image </span><span class="s2">= </span>image<span class="s1">.</span><span class="s5">flip</span><span class="s1">(VIPS_DIRECTION_HORIZONTAL);</span>
      <span class="s1">}</span>
      <span class="s0">// Rotate post-extract 90-angle</span>
      <span class="s2">if </span><span class="s1">(rotation </span><span class="s2">!= </span><span class="s1">VIPS_ANGLE_D0) {</span>
        <span class="s2">if </span><span class="s1">(rotation </span><span class="s2">!= </span><span class="s1">VIPS_ANGLE_D180) {</span>
          <span class="s5">MultiPageUnsupported</span><span class="s1">(nPages, </span><span class="s3">&quot;Rotate&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s1">image </span><span class="s2">= </span>image<span class="s1">.</span><span class="s5">rot</span><span class="s1">(rotation);</span>
      <span class="s1">}</span>

      <span class="s0">// Join additional color channels to the image</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">!</span>baton<span class="s1">-&gt;</span>joinChannelIn<span class="s1">.</span><span class="s5">empty</span><span class="s1">()) {</span>
        <span class="s1">VImage joinImage;</span>
        sharp<span class="s1">::ImageType joinImageType </span><span class="s2">= </span>sharp<span class="s1">::</span>ImageType<span class="s1">::UNKNOWN;</span>

        <span class="s2">for </span><span class="s1">(</span><span class="s2">unsigned int </span><span class="s1">i </span><span class="s2">= </span><span class="s7">0</span><span class="s1">; i </span><span class="s2">&lt; </span>baton<span class="s1">-&gt;</span>joinChannelIn<span class="s1">.</span><span class="s5">size</span><span class="s1">(); i</span><span class="s2">++</span><span class="s1">) {</span>
          baton<span class="s1">-&gt;</span>joinChannelIn<span class="s1">[i]-&gt;</span>access <span class="s2">= </span><span class="s1">access;</span>
          std<span class="s1">::</span><span class="s5">tie</span><span class="s1">(joinImage, joinImageType) </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">OpenInput</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>joinChannelIn<span class="s1">[i]);</span>
          <span class="s1">joinImage </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">EnsureColourspace</span><span class="s1">(joinImage, </span>baton<span class="s1">-&gt;</span>colourspacePipeline<span class="s1">);</span>
          <span class="s1">image </span><span class="s2">= </span>image<span class="s1">.</span><span class="s5">bandjoin</span><span class="s1">(joinImage);</span>
        <span class="s1">}</span>
        <span class="s1">image </span><span class="s2">= </span>image<span class="s1">.</span><span class="s5">copy</span><span class="s1">(</span>VImage<span class="s1">::</span><span class="s5">option</span><span class="s1">()-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;interpretation&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>colourspace<span class="s1">));</span>
        <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">RemoveGifPalette</span><span class="s1">(image);</span>
      <span class="s1">}</span>

      <span class="s1">inputWidth </span><span class="s2">= </span>image<span class="s1">.</span><span class="s5">width</span><span class="s1">();</span>
      <span class="s1">inputHeight </span><span class="s2">= </span><span class="s1">nPages </span><span class="s2">&gt; </span><span class="s7">1 </span><span class="s2">? </span><span class="s1">targetPageHeight </span><span class="s2">: </span>image<span class="s1">.</span><span class="s5">height</span><span class="s1">();</span>

      <span class="s0">// Resolve dimensions</span>
      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>width <span class="s2">&lt;= </span><span class="s7">0</span><span class="s1">) {</span>
        baton<span class="s1">-&gt;</span>width <span class="s2">= </span><span class="s1">inputWidth;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>height <span class="s2">&lt;= </span><span class="s7">0</span><span class="s1">) {</span>
        baton<span class="s1">-&gt;</span>height <span class="s2">= </span><span class="s1">inputHeight;</span>
      <span class="s1">}</span>

      <span class="s0">// Crop/embed</span>
      <span class="s2">if </span><span class="s1">(inputWidth </span><span class="s2">!= </span>baton<span class="s1">-&gt;</span>width <span class="s2">|| </span><span class="s1">inputHeight </span><span class="s2">!= </span>baton<span class="s1">-&gt;</span>height<span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>canvas <span class="s2">== </span>sharp<span class="s1">::</span>Canvas<span class="s1">::EMBED) {</span>
          std<span class="s1">::vector</span><span class="s2">&lt;double&gt; </span><span class="s1">background;</span>
          std<span class="s1">::</span><span class="s5">tie</span><span class="s1">(image, background) </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">ApplyAlpha</span><span class="s1">(image, </span>baton<span class="s1">-&gt;</span>resizeBackground<span class="s1">, shouldPremultiplyAlpha);</span>

          <span class="s0">// Embed</span>
          <span class="s2">int </span><span class="s1">left;</span>
          <span class="s2">int </span><span class="s1">top;</span>
          std<span class="s1">::</span><span class="s5">tie</span><span class="s1">(left, top) </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">CalculateEmbedPosition</span><span class="s1">(</span>
            <span class="s1">inputWidth, inputHeight, </span>baton<span class="s1">-&gt;</span>width<span class="s1">, </span>baton<span class="s1">-&gt;</span>height<span class="s1">, </span>baton<span class="s1">-&gt;</span>position<span class="s1">);</span>
          <span class="s2">int </span><span class="s1">width </span><span class="s2">= </span>std<span class="s1">::</span><span class="s5">max</span><span class="s1">(inputWidth, </span>baton<span class="s1">-&gt;</span>width<span class="s1">);</span>
          <span class="s2">int </span><span class="s1">height </span><span class="s2">= </span>std<span class="s1">::</span><span class="s5">max</span><span class="s1">(inputHeight, </span>baton<span class="s1">-&gt;</span>height<span class="s1">);</span>

          <span class="s1">image </span><span class="s2">= </span><span class="s1">nPages </span><span class="s2">&gt; </span><span class="s7">1</span>
            <span class="s2">? </span>sharp<span class="s1">::</span><span class="s5">EmbedMultiPage</span><span class="s1">(image,</span>
                <span class="s1">left, top, width, height, VIPS_EXTEND_BACKGROUND, background, nPages, </span><span class="s2">&amp;</span><span class="s1">targetPageHeight)</span>
            <span class="s2">: </span>image<span class="s1">.</span><span class="s5">embed</span><span class="s1">(left, top, width, height, </span>VImage<span class="s1">::</span><span class="s5">option</span><span class="s1">()</span>
              <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;extend&quot;</span><span class="s1">, VIPS_EXTEND_BACKGROUND)</span>
              <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;background&quot;</span><span class="s1">, background));</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>canvas <span class="s2">== </span>sharp<span class="s1">::</span>Canvas<span class="s1">::CROP) {</span>
          <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>width <span class="s2">&gt; </span><span class="s1">inputWidth) {</span>
            baton<span class="s1">-&gt;</span>width <span class="s2">= </span><span class="s1">inputWidth;</span>
          <span class="s1">}</span>
          <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>height <span class="s2">&gt; </span><span class="s1">inputHeight) {</span>
            baton<span class="s1">-&gt;</span>height <span class="s2">= </span><span class="s1">inputHeight;</span>
          <span class="s1">}</span>

          <span class="s0">// Crop</span>
          <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>position <span class="s2">&lt; </span><span class="s7">9</span><span class="s1">) {</span>
            <span class="s0">// Gravity-based crop</span>
            <span class="s2">int </span><span class="s1">left;</span>
            <span class="s2">int </span><span class="s1">top;</span>

            std<span class="s1">::</span><span class="s5">tie</span><span class="s1">(left, top) </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">CalculateCrop</span><span class="s1">(</span>
              <span class="s1">inputWidth, inputHeight, </span>baton<span class="s1">-&gt;</span>width<span class="s1">, </span>baton<span class="s1">-&gt;</span>height<span class="s1">, </span>baton<span class="s1">-&gt;</span>position<span class="s1">);</span>
            <span class="s2">int </span><span class="s1">width </span><span class="s2">= </span>std<span class="s1">::</span><span class="s5">min</span><span class="s1">(inputWidth, </span>baton<span class="s1">-&gt;</span>width<span class="s1">);</span>
            <span class="s2">int </span><span class="s1">height </span><span class="s2">= </span>std<span class="s1">::</span><span class="s5">min</span><span class="s1">(inputHeight, </span>baton<span class="s1">-&gt;</span>height<span class="s1">);</span>

            <span class="s1">image </span><span class="s2">= </span><span class="s1">nPages </span><span class="s2">&gt; </span><span class="s7">1</span>
              <span class="s2">? </span>sharp<span class="s1">::</span><span class="s5">CropMultiPage</span><span class="s1">(image,</span>
                  <span class="s1">left, top, width, height, nPages, </span><span class="s2">&amp;</span><span class="s1">targetPageHeight)</span>
              <span class="s2">: </span>image<span class="s1">.</span><span class="s5">extract_area</span><span class="s1">(left, top, width, height);</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s2">int </span><span class="s1">attention_x;</span>
            <span class="s2">int </span><span class="s1">attention_y;</span>

            <span class="s0">// Attention-based or Entropy-based crop</span>
            <span class="s5">MultiPageUnsupported</span><span class="s1">(nPages, </span><span class="s3">&quot;Resize strategy&quot;</span><span class="s1">);</span>
            <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">StaySequential</span><span class="s1">(image);</span>
            <span class="s1">image </span><span class="s2">= </span>image<span class="s1">.</span><span class="s5">smartcrop</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>width<span class="s1">, </span>baton<span class="s1">-&gt;</span>height<span class="s1">, </span>VImage<span class="s1">::</span><span class="s5">option</span><span class="s1">()</span>
              <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;interesting&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>position <span class="s2">== </span><span class="s7">16 </span><span class="s2">? </span><span class="s1">VIPS_INTERESTING_ENTROPY </span><span class="s2">: </span><span class="s1">VIPS_INTERESTING_ATTENTION)</span>
              <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;premultiplied&quot;</span><span class="s1">, shouldPremultiplyAlpha)</span>
              <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;attention_x&quot;</span><span class="s1">, </span><span class="s2">&amp;</span><span class="s1">attention_x)</span>
              <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;attention_y&quot;</span><span class="s1">, </span><span class="s2">&amp;</span><span class="s1">attention_y));</span>
            baton<span class="s1">-&gt;</span>hasCropOffset <span class="s2">= </span><span class="s6">true</span><span class="s1">;</span>
            baton<span class="s1">-&gt;</span>cropOffsetLeft <span class="s2">= static_cast&lt;int&gt;</span><span class="s1">(</span>image<span class="s1">.</span><span class="s5">xoffset</span><span class="s1">());</span>
            baton<span class="s1">-&gt;</span>cropOffsetTop <span class="s2">= static_cast&lt;int&gt;</span><span class="s1">(</span>image<span class="s1">.</span><span class="s5">yoffset</span><span class="s1">());</span>
            baton<span class="s1">-&gt;</span>hasAttentionCenter <span class="s2">= </span><span class="s6">true</span><span class="s1">;</span>
            baton<span class="s1">-&gt;</span>attentionX <span class="s2">= static_cast&lt;int&gt;</span><span class="s1">(attention_x </span><span class="s2">* </span><span class="s1">jpegShrinkOnLoad </span><span class="s2">/ </span><span class="s1">scale);</span>
            baton<span class="s1">-&gt;</span>attentionY <span class="s2">= static_cast&lt;int&gt;</span><span class="s1">(attention_y </span><span class="s2">* </span><span class="s1">jpegShrinkOnLoad </span><span class="s2">/ </span><span class="s1">scale);</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s0">// Rotate post-extract non-90 angle</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">!</span>baton<span class="s1">-&gt;</span>rotateBefore <span class="s2">&amp;&amp; </span>baton<span class="s1">-&gt;</span>rotationAngle <span class="s2">!= </span><span class="s7">0.0</span><span class="s1">) {</span>
        <span class="s5">MultiPageUnsupported</span><span class="s1">(nPages, </span><span class="s3">&quot;Rotate&quot;</span><span class="s1">);</span>
        <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">StaySequential</span><span class="s1">(image);</span>
        std<span class="s1">::vector</span><span class="s2">&lt;double&gt; </span><span class="s1">background;</span>
        std<span class="s1">::</span><span class="s5">tie</span><span class="s1">(image, background) </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">ApplyAlpha</span><span class="s1">(image, </span>baton<span class="s1">-&gt;</span>rotationBackground<span class="s1">, shouldPremultiplyAlpha);</span>
        <span class="s1">image </span><span class="s2">= </span>image<span class="s1">.</span><span class="s5">rotate</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>rotationAngle<span class="s1">, </span>VImage<span class="s1">::</span><span class="s5">option</span><span class="s1">()-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;background&quot;</span><span class="s1">, background));</span>
      <span class="s1">}</span>

      <span class="s0">// Post extraction</span>
      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>topOffsetPost <span class="s2">!= -</span><span class="s7">1</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(nPages </span><span class="s2">&gt; </span><span class="s7">1</span><span class="s1">) {</span>
          <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">CropMultiPage</span><span class="s1">(image,</span>
            baton<span class="s1">-&gt;</span>leftOffsetPost<span class="s1">, </span>baton<span class="s1">-&gt;</span>topOffsetPost<span class="s1">, </span>baton<span class="s1">-&gt;</span>widthPost<span class="s1">, </span>baton<span class="s1">-&gt;</span>heightPost<span class="s1">,</span>
            <span class="s1">nPages, </span><span class="s2">&amp;</span><span class="s1">targetPageHeight);</span>

          <span class="s0">// heightPost is used in the info object, so update to reflect the number of pages</span>
          baton<span class="s1">-&gt;</span>heightPost <span class="s2">*= </span><span class="s1">nPages;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s1">image </span><span class="s2">= </span>image<span class="s1">.</span><span class="s5">extract_area</span><span class="s1">(</span>
            baton<span class="s1">-&gt;</span>leftOffsetPost<span class="s1">, </span>baton<span class="s1">-&gt;</span>topOffsetPost<span class="s1">, </span>baton<span class="s1">-&gt;</span>widthPost<span class="s1">, </span>baton<span class="s1">-&gt;</span>heightPost<span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s0">// Affine transform</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">!</span>baton<span class="s1">-&gt;</span>affineMatrix<span class="s1">.</span><span class="s5">empty</span><span class="s1">()) {</span>
        <span class="s5">MultiPageUnsupported</span><span class="s1">(nPages, </span><span class="s3">&quot;Affine&quot;</span><span class="s1">);</span>
        <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">StaySequential</span><span class="s1">(image);</span>
        std<span class="s1">::vector</span><span class="s2">&lt;double&gt; </span><span class="s1">background;</span>
        std<span class="s1">::</span><span class="s5">tie</span><span class="s1">(image, background) </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">ApplyAlpha</span><span class="s1">(image, </span>baton<span class="s1">-&gt;</span>affineBackground<span class="s1">, shouldPremultiplyAlpha);</span>
        vips<span class="s1">::VInterpolate interp </span><span class="s2">= </span>vips<span class="s1">::</span>VInterpolate<span class="s1">::</span><span class="s5">new_from_name</span><span class="s1">(</span>
          <span class="s2">const_cast&lt;char*&gt;</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>affineInterpolator<span class="s1">.</span><span class="s5">data</span><span class="s1">()));</span>
        <span class="s1">image </span><span class="s2">= </span>image<span class="s1">.</span><span class="s5">affine</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>affineMatrix<span class="s1">, </span>VImage<span class="s1">::</span><span class="s5">option</span><span class="s1">()-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;background&quot;</span><span class="s1">, background)</span>
          <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;idx&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>affineIdx<span class="s1">)</span>
          <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;idy&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>affineIdy<span class="s1">)</span>
          <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;odx&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>affineOdx<span class="s1">)</span>
          <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;ody&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>affineOdy<span class="s1">)</span>
          <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;interpolate&quot;</span><span class="s1">, interp));</span>
      <span class="s1">}</span>

      <span class="s0">// Extend edges</span>
      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>extendTop <span class="s2">&gt; </span><span class="s7">0 </span><span class="s2">|| </span>baton<span class="s1">-&gt;</span>extendBottom <span class="s2">&gt; </span><span class="s7">0 </span><span class="s2">|| </span>baton<span class="s1">-&gt;</span>extendLeft <span class="s2">&gt; </span><span class="s7">0 </span><span class="s2">|| </span>baton<span class="s1">-&gt;</span>extendRight <span class="s2">&gt; </span><span class="s7">0</span><span class="s1">) {</span>
        <span class="s0">// Embed</span>
        baton<span class="s1">-&gt;</span>width <span class="s2">= </span>image<span class="s1">.</span><span class="s5">width</span><span class="s1">() </span><span class="s2">+ </span>baton<span class="s1">-&gt;</span>extendLeft <span class="s2">+ </span>baton<span class="s1">-&gt;</span>extendRight<span class="s1">;</span>
        baton<span class="s1">-&gt;</span>height <span class="s2">= </span><span class="s1">(nPages </span><span class="s2">&gt; </span><span class="s7">1 </span><span class="s2">? </span><span class="s1">targetPageHeight </span><span class="s2">: </span>image<span class="s1">.</span><span class="s5">height</span><span class="s1">()) </span><span class="s2">+ </span>baton<span class="s1">-&gt;</span>extendTop <span class="s2">+ </span>baton<span class="s1">-&gt;</span>extendBottom<span class="s1">;</span>

        <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>extendWith <span class="s2">== </span><span class="s1">VIPS_EXTEND_BACKGROUND) {</span>
          std<span class="s1">::vector</span><span class="s2">&lt;double&gt; </span><span class="s1">background;</span>
          std<span class="s1">::</span><span class="s5">tie</span><span class="s1">(image, background) </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">ApplyAlpha</span><span class="s1">(image, </span>baton<span class="s1">-&gt;</span>extendBackground<span class="s1">, shouldPremultiplyAlpha);</span>

          <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">StaySequential</span><span class="s1">(image, nPages </span><span class="s2">&gt; </span><span class="s7">1</span><span class="s1">);</span>
          <span class="s1">image </span><span class="s2">= </span><span class="s1">nPages </span><span class="s2">&gt; </span><span class="s7">1</span>
            <span class="s2">? </span>sharp<span class="s1">::</span><span class="s5">EmbedMultiPage</span><span class="s1">(image,</span>
                baton<span class="s1">-&gt;</span>extendLeft<span class="s1">, </span>baton<span class="s1">-&gt;</span>extendTop<span class="s1">, </span>baton<span class="s1">-&gt;</span>width<span class="s1">, </span>baton<span class="s1">-&gt;</span>height<span class="s1">,</span>
                baton<span class="s1">-&gt;</span>extendWith<span class="s1">, background, nPages, </span><span class="s2">&amp;</span><span class="s1">targetPageHeight)</span>
            <span class="s2">: </span>image<span class="s1">.</span><span class="s5">embed</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>extendLeft<span class="s1">, </span>baton<span class="s1">-&gt;</span>extendTop<span class="s1">, </span>baton<span class="s1">-&gt;</span>width<span class="s1">, </span>baton<span class="s1">-&gt;</span>height<span class="s1">,</span>
                VImage<span class="s1">::</span><span class="s5">option</span><span class="s1">()-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;extend&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>extendWith<span class="s1">)-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;background&quot;</span><span class="s1">, background));</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          std<span class="s1">::vector</span><span class="s2">&lt;double&gt; </span><span class="s5">ignoredBackground</span><span class="s1">(</span><span class="s7">1</span><span class="s1">);</span>
          <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">StaySequential</span><span class="s1">(image);</span>
          <span class="s1">image </span><span class="s2">= </span><span class="s1">nPages </span><span class="s2">&gt; </span><span class="s7">1</span>
            <span class="s2">? </span>sharp<span class="s1">::</span><span class="s5">EmbedMultiPage</span><span class="s1">(image,</span>
                baton<span class="s1">-&gt;</span>extendLeft<span class="s1">, </span>baton<span class="s1">-&gt;</span>extendTop<span class="s1">, </span>baton<span class="s1">-&gt;</span>width<span class="s1">, </span>baton<span class="s1">-&gt;</span>height<span class="s1">,</span>
                baton<span class="s1">-&gt;</span>extendWith<span class="s1">, ignoredBackground, nPages, </span><span class="s2">&amp;</span><span class="s1">targetPageHeight)</span>
            <span class="s2">: </span>image<span class="s1">.</span><span class="s5">embed</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>extendLeft<span class="s1">, </span>baton<span class="s1">-&gt;</span>extendTop<span class="s1">, </span>baton<span class="s1">-&gt;</span>width<span class="s1">, </span>baton<span class="s1">-&gt;</span>height<span class="s1">,</span>
                VImage<span class="s1">::</span><span class="s5">option</span><span class="s1">()-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;extend&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>extendWith<span class="s1">));</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">// Median - must happen before blurring, due to the utility of blurring after thresholding</span>
      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>medianSize <span class="s2">&gt; </span><span class="s7">0</span><span class="s1">) {</span>
        <span class="s1">image </span><span class="s2">= </span>image<span class="s1">.</span><span class="s5">median</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>medianSize<span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s0">// Threshold - must happen before blurring, due to the utility of blurring after thresholding</span>
      <span class="s0">// Threshold - must happen before unflatten to enable non-white unflattening</span>
      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>threshold <span class="s2">!= </span><span class="s7">0</span><span class="s1">) {</span>
        <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">Threshold</span><span class="s1">(image, </span>baton<span class="s1">-&gt;</span>threshold<span class="s1">, </span>baton<span class="s1">-&gt;</span>thresholdGrayscale<span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s0">// Dilate - must happen before blurring, due to the utility of dilating after thresholding</span>
      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>dilateWidth <span class="s2">!= </span><span class="s7">0</span><span class="s1">) {</span>
        <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">Dilate</span><span class="s1">(image, </span>baton<span class="s1">-&gt;</span>dilateWidth<span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s0">// Erode - must happen before blurring, due to the utility of eroding after thresholding</span>
      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>erodeWidth <span class="s2">!= </span><span class="s7">0</span><span class="s1">) {</span>
        <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">Erode</span><span class="s1">(image, </span>baton<span class="s1">-&gt;</span>erodeWidth<span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s0">// Blur</span>
      <span class="s2">if </span><span class="s1">(shouldBlur) {</span>
        <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">Blur</span><span class="s1">(image, </span>baton<span class="s1">-&gt;</span>blurSigma<span class="s1">, </span>baton<span class="s1">-&gt;</span>precision<span class="s1">, </span>baton<span class="s1">-&gt;</span>minAmpl<span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s0">// Unflatten the image</span>
      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>unflatten<span class="s1">) {</span>
        <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">Unflatten</span><span class="s1">(image);</span>
      <span class="s1">}</span>

      <span class="s0">// Convolve</span>
      <span class="s2">if </span><span class="s1">(shouldConv) {</span>
        <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">Convolve</span><span class="s1">(image,</span>
          baton<span class="s1">-&gt;</span>convKernelWidth<span class="s1">, </span>baton<span class="s1">-&gt;</span>convKernelHeight<span class="s1">,</span>
          baton<span class="s1">-&gt;</span>convKernelScale<span class="s1">, </span>baton<span class="s1">-&gt;</span>convKernelOffset<span class="s1">,</span>
          baton<span class="s1">-&gt;</span>convKernel<span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s0">// Recomb</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">!</span>baton<span class="s1">-&gt;</span>recombMatrix<span class="s1">.</span><span class="s5">empty</span><span class="s1">()) {</span>
        <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">Recomb</span><span class="s1">(image, </span>baton<span class="s1">-&gt;</span>recombMatrix<span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s0">// Modulate</span>
      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>brightness <span class="s2">!= </span><span class="s7">1.0 </span><span class="s2">|| </span>baton<span class="s1">-&gt;</span>saturation <span class="s2">!= </span><span class="s7">1.0 </span><span class="s2">|| </span>baton<span class="s1">-&gt;</span>hue <span class="s2">!= </span><span class="s7">0.0 </span><span class="s2">|| </span>baton<span class="s1">-&gt;</span>lightness <span class="s2">!= </span><span class="s7">0.0</span><span class="s1">) {</span>
        <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">Modulate</span><span class="s1">(image, </span>baton<span class="s1">-&gt;</span>brightness<span class="s1">, </span>baton<span class="s1">-&gt;</span>saturation<span class="s1">, </span>baton<span class="s1">-&gt;</span>hue<span class="s1">, </span>baton<span class="s1">-&gt;</span>lightness<span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s0">// Sharpen</span>
      <span class="s2">if </span><span class="s1">(shouldSharpen) {</span>
        <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">Sharpen</span><span class="s1">(image, </span>baton<span class="s1">-&gt;</span>sharpenSigma<span class="s1">, </span>baton<span class="s1">-&gt;</span>sharpenM1<span class="s1">, </span>baton<span class="s1">-&gt;</span>sharpenM2<span class="s1">,</span>
          baton<span class="s1">-&gt;</span>sharpenX1<span class="s1">, </span>baton<span class="s1">-&gt;</span>sharpenY2<span class="s1">, </span>baton<span class="s1">-&gt;</span>sharpenY3<span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s0">// Reverse premultiplication after all transformations</span>
      <span class="s2">if </span><span class="s1">(shouldPremultiplyAlpha) {</span>
        <span class="s1">image </span><span class="s2">= </span>image<span class="s1">.</span><span class="s5">unpremultiply</span><span class="s1">().</span><span class="s5">cast</span><span class="s1">(premultiplyFormat);</span>
      <span class="s1">}</span>
      baton<span class="s1">-&gt;</span>premultiplied <span class="s2">= </span><span class="s1">shouldPremultiplyAlpha;</span>

      <span class="s0">// Composite</span>
      <span class="s2">if </span><span class="s1">(shouldComposite) {</span>
        std<span class="s1">::vector</span><span class="s2">&lt;</span><span class="s1">VImage</span><span class="s2">&gt; </span><span class="s1">images </span><span class="s2">= </span><span class="s1">{ image };</span>
        std<span class="s1">::vector</span><span class="s2">&lt;int&gt; </span><span class="s1">modes, xs, ys;</span>
        <span class="s2">for </span><span class="s1">(Composite </span><span class="s2">*</span><span class="s1">composite : </span>baton<span class="s1">-&gt;</span>composite<span class="s1">) {</span>
          <span class="s1">VImage compositeImage;</span>
          sharp<span class="s1">::ImageType compositeImageType </span><span class="s2">= </span>sharp<span class="s1">::</span>ImageType<span class="s1">::UNKNOWN;</span>
          composite<span class="s1">-&gt;</span>input<span class="s1">-&gt;</span>access <span class="s2">= </span><span class="s1">access;</span>
          std<span class="s1">::</span><span class="s5">tie</span><span class="s1">(compositeImage, compositeImageType) </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">OpenInput</span><span class="s1">(</span>composite<span class="s1">-&gt;</span>input<span class="s1">);</span>

          <span class="s2">if </span><span class="s1">(</span>composite<span class="s1">-&gt;</span>input<span class="s1">-&gt;</span>autoOrient<span class="s1">) {</span>
            <span class="s0">// Respect EXIF Orientation</span>
            <span class="s1">VipsAngle compositeAutoRotation </span><span class="s2">= </span><span class="s1">VIPS_ANGLE_D0;</span>
            <span class="s2">bool </span><span class="s1">compositeAutoFlop </span><span class="s2">= </span><span class="s6">false</span><span class="s1">;</span>
            std<span class="s1">::</span><span class="s5">tie</span><span class="s1">(compositeAutoRotation, compositeAutoFlop) </span><span class="s2">=</span>
              <span class="s5">CalculateExifRotationAndFlop</span><span class="s1">(</span>sharp<span class="s1">::</span><span class="s5">ExifOrientation</span><span class="s1">(compositeImage));</span>

            <span class="s1">compositeImage </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">RemoveExifOrientation</span><span class="s1">(compositeImage);</span>
            <span class="s1">compositeImage </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">StaySequential</span><span class="s1">(compositeImage, compositeAutoRotation </span><span class="s2">!= </span><span class="s1">VIPS_ANGLE_D0);</span>

            <span class="s2">if </span><span class="s1">(compositeAutoRotation </span><span class="s2">!= </span><span class="s1">VIPS_ANGLE_D0) {</span>
              <span class="s1">compositeImage </span><span class="s2">= </span>compositeImage<span class="s1">.</span><span class="s5">rot</span><span class="s1">(compositeAutoRotation);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(compositeAutoFlop) {</span>
              <span class="s1">compositeImage </span><span class="s2">= </span>compositeImage<span class="s1">.</span><span class="s5">flip</span><span class="s1">(VIPS_DIRECTION_HORIZONTAL);</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s0">// Verify within current dimensions</span>
          <span class="s2">if </span><span class="s1">(</span>compositeImage<span class="s1">.</span><span class="s5">width</span><span class="s1">() </span><span class="s2">&gt; </span>image<span class="s1">.</span><span class="s5">width</span><span class="s1">() </span><span class="s2">|| </span>compositeImage<span class="s1">.</span><span class="s5">height</span><span class="s1">() </span><span class="s2">&gt; </span>image<span class="s1">.</span><span class="s5">height</span><span class="s1">()) {</span>
            <span class="s2">throw </span>vips<span class="s1">::</span><span class="s5">VError</span><span class="s1">(</span><span class="s3">&quot;Image to composite must have same dimensions or smaller&quot;</span><span class="s1">);</span>
          <span class="s1">}</span>
          <span class="s0">// Check if overlay is tiled</span>
          <span class="s2">if </span><span class="s1">(</span>composite<span class="s1">-&gt;</span>tile<span class="s1">) {</span>
            <span class="s2">int </span><span class="s1">across </span><span class="s2">= </span><span class="s7">0</span><span class="s1">;</span>
            <span class="s2">int </span><span class="s1">down </span><span class="s2">= </span><span class="s7">0</span><span class="s1">;</span>
            <span class="s0">// Use gravity in overlay</span>
            <span class="s2">if </span><span class="s1">(</span>compositeImage<span class="s1">.</span><span class="s5">width</span><span class="s1">() </span><span class="s2">&lt;= </span>image<span class="s1">.</span><span class="s5">width</span><span class="s1">()) {</span>
              <span class="s1">across </span><span class="s2">= static_cast&lt;int&gt;</span><span class="s1">(</span><span class="s5">ceil</span><span class="s1">(</span><span class="s2">static_cast&lt;double&gt;</span><span class="s1">(</span>image<span class="s1">.</span><span class="s5">width</span><span class="s1">()) </span><span class="s2">/ </span>compositeImage<span class="s1">.</span><span class="s5">width</span><span class="s1">()));</span>
              <span class="s0">// Ensure odd number of tiles across when gravity is centre, north or south</span>
              <span class="s2">if </span><span class="s1">(</span>composite<span class="s1">-&gt;</span>gravity <span class="s2">== </span><span class="s7">0 </span><span class="s2">|| </span>composite<span class="s1">-&gt;</span>gravity <span class="s2">== </span><span class="s7">1 </span><span class="s2">|| </span>composite<span class="s1">-&gt;</span>gravity <span class="s2">== </span><span class="s7">3</span><span class="s1">) {</span>
                <span class="s1">across </span><span class="s2">|= </span><span class="s7">1</span><span class="s1">;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(</span>compositeImage<span class="s1">.</span><span class="s5">height</span><span class="s1">() </span><span class="s2">&lt;= </span>image<span class="s1">.</span><span class="s5">height</span><span class="s1">()) {</span>
              <span class="s1">down </span><span class="s2">= static_cast&lt;int&gt;</span><span class="s1">(</span><span class="s5">ceil</span><span class="s1">(</span><span class="s2">static_cast&lt;double&gt;</span><span class="s1">(</span>image<span class="s1">.</span><span class="s5">height</span><span class="s1">()) </span><span class="s2">/ </span>compositeImage<span class="s1">.</span><span class="s5">height</span><span class="s1">()));</span>
              <span class="s0">// Ensure odd number of tiles down when gravity is centre, east or west</span>
              <span class="s2">if </span><span class="s1">(</span>composite<span class="s1">-&gt;</span>gravity <span class="s2">== </span><span class="s7">0 </span><span class="s2">|| </span>composite<span class="s1">-&gt;</span>gravity <span class="s2">== </span><span class="s7">2 </span><span class="s2">|| </span>composite<span class="s1">-&gt;</span>gravity <span class="s2">== </span><span class="s7">4</span><span class="s1">) {</span>
                <span class="s1">down </span><span class="s2">|= </span><span class="s7">1</span><span class="s1">;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(across </span><span class="s2">!= </span><span class="s7">0 </span><span class="s2">|| </span><span class="s1">down </span><span class="s2">!= </span><span class="s7">0</span><span class="s1">) {</span>
              <span class="s2">int </span><span class="s1">left;</span>
              <span class="s2">int </span><span class="s1">top;</span>
              <span class="s1">compositeImage </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">StaySequential</span><span class="s1">(compositeImage).</span><span class="s5">replicate</span><span class="s1">(across, down);</span>
              <span class="s2">if </span><span class="s1">(</span>composite<span class="s1">-&gt;</span>hasOffset<span class="s1">) {</span>
                std<span class="s1">::</span><span class="s5">tie</span><span class="s1">(left, top) </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">CalculateCrop</span><span class="s1">(</span>
                  compositeImage<span class="s1">.</span><span class="s5">width</span><span class="s1">(), </span>compositeImage<span class="s1">.</span><span class="s5">height</span><span class="s1">(), </span>image<span class="s1">.</span><span class="s5">width</span><span class="s1">(), </span>image<span class="s1">.</span><span class="s5">height</span><span class="s1">(),</span>
                  composite<span class="s1">-&gt;</span>left<span class="s1">, </span>composite<span class="s1">-&gt;</span>top<span class="s1">);</span>
              <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                std<span class="s1">::</span><span class="s5">tie</span><span class="s1">(left, top) </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">CalculateCrop</span><span class="s1">(</span>
                  compositeImage<span class="s1">.</span><span class="s5">width</span><span class="s1">(), </span>compositeImage<span class="s1">.</span><span class="s5">height</span><span class="s1">(), </span>image<span class="s1">.</span><span class="s5">width</span><span class="s1">(), </span>image<span class="s1">.</span><span class="s5">height</span><span class="s1">(), </span>composite<span class="s1">-&gt;</span>gravity<span class="s1">);</span>
              <span class="s1">}</span>
              <span class="s1">compositeImage </span><span class="s2">= </span>compositeImage<span class="s1">.</span><span class="s5">extract_area</span><span class="s1">(left, top, </span>image<span class="s1">.</span><span class="s5">width</span><span class="s1">(), </span>image<span class="s1">.</span><span class="s5">height</span><span class="s1">());</span>
            <span class="s1">}</span>
            <span class="s0">// gravity was used for extract_area, set it back to its default value of 0</span>
            composite<span class="s1">-&gt;</span>gravity <span class="s2">= </span><span class="s7">0</span><span class="s1">;</span>
          <span class="s1">}</span>
          <span class="s0">// Ensure image to composite is with unpremultiplied alpha</span>
          <span class="s1">compositeImage </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">EnsureAlpha</span><span class="s1">(compositeImage, </span><span class="s7">1</span><span class="s1">);</span>
          <span class="s2">if </span><span class="s1">(</span>composite<span class="s1">-&gt;</span>premultiplied<span class="s1">) compositeImage </span><span class="s2">= </span>compositeImage<span class="s1">.</span><span class="s5">unpremultiply</span><span class="s1">();</span>
          <span class="s0">// Calculate position</span>
          <span class="s2">int </span><span class="s1">left;</span>
          <span class="s2">int </span><span class="s1">top;</span>
          <span class="s2">if </span><span class="s1">(</span>composite<span class="s1">-&gt;</span>hasOffset<span class="s1">) {</span>
            <span class="s0">// Composite image at given offsets</span>
            <span class="s2">if </span><span class="s1">(</span>composite<span class="s1">-&gt;</span>tile<span class="s1">) {</span>
              std<span class="s1">::</span><span class="s5">tie</span><span class="s1">(left, top) </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">CalculateCrop</span><span class="s1">(</span>image<span class="s1">.</span><span class="s5">width</span><span class="s1">(), </span>image<span class="s1">.</span><span class="s5">height</span><span class="s1">(),</span>
                compositeImage<span class="s1">.</span><span class="s5">width</span><span class="s1">(), </span>compositeImage<span class="s1">.</span><span class="s5">height</span><span class="s1">(), </span>composite<span class="s1">-&gt;</span>left<span class="s1">, </span>composite<span class="s1">-&gt;</span>top<span class="s1">);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
              <span class="s1">left </span><span class="s2">= </span>composite<span class="s1">-&gt;</span>left<span class="s1">;</span>
              <span class="s1">top </span><span class="s2">= </span>composite<span class="s1">-&gt;</span>top<span class="s1">;</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s0">// Composite image with given gravity</span>
            std<span class="s1">::</span><span class="s5">tie</span><span class="s1">(left, top) </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">CalculateCrop</span><span class="s1">(</span>image<span class="s1">.</span><span class="s5">width</span><span class="s1">(), </span>image<span class="s1">.</span><span class="s5">height</span><span class="s1">(),</span>
              compositeImage<span class="s1">.</span><span class="s5">width</span><span class="s1">(), </span>compositeImage<span class="s1">.</span><span class="s5">height</span><span class="s1">(), </span>composite<span class="s1">-&gt;</span>gravity<span class="s1">);</span>
          <span class="s1">}</span>
          images<span class="s1">.</span><span class="s5">push_back</span><span class="s1">(compositeImage);</span>
          modes<span class="s1">.</span><span class="s5">push_back</span><span class="s1">(</span>composite<span class="s1">-&gt;</span>mode<span class="s1">);</span>
          xs<span class="s1">.</span><span class="s5">push_back</span><span class="s1">(left);</span>
          ys<span class="s1">.</span><span class="s5">push_back</span><span class="s1">(top);</span>
        <span class="s1">}</span>
        <span class="s1">image </span><span class="s2">= </span>VImage<span class="s1">::</span><span class="s5">composite</span><span class="s1">(images, modes, </span>VImage<span class="s1">::</span><span class="s5">option</span><span class="s1">()</span>
          <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;compositing_space&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>colourspacePipeline <span class="s2">== </span><span class="s1">VIPS_INTERPRETATION_LAST 
            </span><span class="s2">? </span><span class="s1">VIPS_INTERPRETATION_sRGB 
            </span><span class="s2">: </span>baton<span class="s1">-&gt;</span>colourspacePipeline<span class="s1">)</span>
          <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;x&quot;</span><span class="s1">, xs)</span>
          <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;y&quot;</span><span class="s1">, ys));</span>
        <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">RemoveGifPalette</span><span class="s1">(image);</span>
      <span class="s1">}</span>

      <span class="s0">// Gamma decoding (brighten)</span>
      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>gammaOut <span class="s2">&gt;= </span><span class="s7">1 </span><span class="s2">&amp;&amp; </span>baton<span class="s1">-&gt;</span>gammaOut <span class="s2">&lt;= </span><span class="s7">3</span><span class="s1">) {</span>
        <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">Gamma</span><span class="s1">(image, </span>baton<span class="s1">-&gt;</span>gammaOut<span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s0">// Linear adjustment (a * in + b)</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">!</span>baton<span class="s1">-&gt;</span>linearA<span class="s1">.</span><span class="s5">empty</span><span class="s1">()) {</span>
        <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">Linear</span><span class="s1">(image, </span>baton<span class="s1">-&gt;</span>linearA<span class="s1">, </span>baton<span class="s1">-&gt;</span>linearB<span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s0">// Apply normalisation - stretch luminance to cover full dynamic range</span>
      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>normalise<span class="s1">) {</span>
        <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">StaySequential</span><span class="s1">(image);</span>
        <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">Normalise</span><span class="s1">(image, </span>baton<span class="s1">-&gt;</span>normaliseLower<span class="s1">, </span>baton<span class="s1">-&gt;</span>normaliseUpper<span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s0">// Apply contrast limiting adaptive histogram equalization (CLAHE)</span>
      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>claheWidth <span class="s2">!= </span><span class="s7">0 </span><span class="s2">&amp;&amp; </span>baton<span class="s1">-&gt;</span>claheHeight <span class="s2">!= </span><span class="s7">0</span><span class="s1">) {</span>
        <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">StaySequential</span><span class="s1">(image);</span>
        <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">Clahe</span><span class="s1">(image, </span>baton<span class="s1">-&gt;</span>claheWidth<span class="s1">, </span>baton<span class="s1">-&gt;</span>claheHeight<span class="s1">, </span>baton<span class="s1">-&gt;</span>claheMaxSlope<span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s0">// Apply bitwise boolean operation between images</span>
      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>boolean <span class="s2">!= </span><span class="s6">nullptr</span><span class="s1">) {</span>
        <span class="s1">VImage booleanImage;</span>
        sharp<span class="s1">::ImageType booleanImageType </span><span class="s2">= </span>sharp<span class="s1">::</span>ImageType<span class="s1">::UNKNOWN;</span>
        baton<span class="s1">-&gt;</span>boolean<span class="s1">-&gt;</span>access <span class="s2">= </span><span class="s1">access;</span>
        std<span class="s1">::</span><span class="s5">tie</span><span class="s1">(booleanImage, booleanImageType) </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">OpenInput</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>boolean<span class="s1">);</span>
        <span class="s1">booleanImage </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">EnsureColourspace</span><span class="s1">(booleanImage, </span>baton<span class="s1">-&gt;</span>colourspacePipeline<span class="s1">);</span>
        <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">Boolean</span><span class="s1">(image, booleanImage, </span>baton<span class="s1">-&gt;</span>booleanOp<span class="s1">);</span>
        <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">RemoveGifPalette</span><span class="s1">(image);</span>
      <span class="s1">}</span>

      <span class="s0">// Apply per-channel Bandbool bitwise operations after all other operations</span>
      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>bandBoolOp <span class="s2">&gt;= </span><span class="s1">VIPS_OPERATION_BOOLEAN_AND </span><span class="s2">&amp;&amp; </span>baton<span class="s1">-&gt;</span>bandBoolOp <span class="s2">&lt; </span><span class="s1">VIPS_OPERATION_BOOLEAN_LAST) {</span>
        <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">Bandbool</span><span class="s1">(image, </span>baton<span class="s1">-&gt;</span>bandBoolOp<span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s0">// Tint the image</span>
      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>tint<span class="s1">[</span><span class="s7">0</span><span class="s1">] </span><span class="s2">&gt;= </span><span class="s7">0.0</span><span class="s1">) {</span>
        <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">Tint</span><span class="s1">(image, </span>baton<span class="s1">-&gt;</span>tint<span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s0">// Remove alpha channel, if any</span>
      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>removeAlpha<span class="s1">) {</span>
        <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">RemoveAlpha</span><span class="s1">(image);</span>
      <span class="s1">}</span>

      <span class="s0">// Ensure alpha channel, if missing</span>
      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>ensureAlpha <span class="s2">!= -</span><span class="s7">1</span><span class="s1">) {</span>
        <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">EnsureAlpha</span><span class="s1">(image, </span>baton<span class="s1">-&gt;</span>ensureAlpha<span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s0">// Convert image to sRGB, if not already</span>
      <span class="s2">if </span><span class="s1">(</span>sharp<span class="s1">::</span><span class="s5">Is16Bit</span><span class="s1">(</span>image<span class="s1">.</span><span class="s5">interpretation</span><span class="s1">())) {</span>
        <span class="s1">image </span><span class="s2">= </span>image<span class="s1">.</span><span class="s5">cast</span><span class="s1">(VIPS_FORMAT_USHORT);</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(</span>image<span class="s1">.</span><span class="s5">interpretation</span><span class="s1">() </span><span class="s2">!= </span>baton<span class="s1">-&gt;</span>colourspace<span class="s1">) {</span>
        <span class="s0">// Convert colourspace, pass the current known interpretation so libvips doesn't have to guess</span>
        <span class="s1">image </span><span class="s2">= </span>image<span class="s1">.</span><span class="s5">colourspace</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>colourspace<span class="s1">, </span>VImage<span class="s1">::</span><span class="s5">option</span><span class="s1">()-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;source_space&quot;</span><span class="s1">, </span>image<span class="s1">.</span><span class="s5">interpretation</span><span class="s1">()));</span>
        <span class="s0">// Transform colours from embedded profile to output profile</span>
        <span class="s2">if </span><span class="s1">((</span>baton<span class="s1">-&gt;</span>keepMetadata <span class="s2">&amp; </span><span class="s1">VIPS_FOREIGN_KEEP_ICC) </span><span class="s2">&amp;&amp; </span>baton<span class="s1">-&gt;</span>colourspacePipeline <span class="s2">!= </span><span class="s1">VIPS_INTERPRETATION_CMYK </span><span class="s2">&amp;&amp;</span>
          baton<span class="s1">-&gt;</span>withIccProfile<span class="s1">.</span><span class="s5">empty</span><span class="s1">() </span><span class="s2">&amp;&amp; </span>sharp<span class="s1">::</span><span class="s5">HasProfile</span><span class="s1">(image)) {</span>
          <span class="s1">image </span><span class="s2">= </span>image<span class="s1">.</span><span class="s5">icc_transform</span><span class="s1">(processingProfile, </span>VImage<span class="s1">::</span><span class="s5">option</span><span class="s1">()</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;embedded&quot;</span><span class="s1">, </span><span class="s6">true</span><span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;depth&quot;</span><span class="s1">, </span>sharp<span class="s1">::</span><span class="s5">Is16Bit</span><span class="s1">(</span>image<span class="s1">.</span><span class="s5">interpretation</span><span class="s1">()) </span><span class="s2">? </span><span class="s7">16 </span><span class="s2">: </span><span class="s7">8</span><span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;intent&quot;</span><span class="s1">, VIPS_INTENT_PERCEPTUAL));</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s0">// Extract channel</span>
      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>extractChannel <span class="s2">&gt; -</span><span class="s7">1</span><span class="s1">) {</span>
        <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>extractChannel <span class="s2">&gt;= </span>image<span class="s1">.</span><span class="s5">bands</span><span class="s1">()) {</span>
          <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>extractChannel <span class="s2">== </span><span class="s7">3 </span><span class="s2">&amp;&amp; </span>image<span class="s1">.</span><span class="s5">has_alpha</span><span class="s1">()) {</span>
            baton<span class="s1">-&gt;</span>extractChannel <span class="s2">= </span>image<span class="s1">.</span><span class="s5">bands</span><span class="s1">() </span><span class="s2">- </span><span class="s7">1</span><span class="s1">;</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">(</span>baton<span class="s1">-&gt;</span>err<span class="s1">)</span>
              <span class="s1">.</span><span class="s5">append</span><span class="s1">(</span><span class="s3">&quot;Cannot extract channel &quot;</span><span class="s1">).</span><span class="s5">append</span><span class="s1">(</span>std<span class="s1">::</span><span class="s5">to_string</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>extractChannel<span class="s1">))</span>
              <span class="s1">.</span><span class="s5">append</span><span class="s1">(</span><span class="s3">&quot; from image with channels 0-&quot;</span><span class="s1">).</span><span class="s5">append</span><span class="s1">(</span>std<span class="s1">::</span><span class="s5">to_string</span><span class="s1">(</span>image<span class="s1">.</span><span class="s5">bands</span><span class="s1">() </span><span class="s2">- </span><span class="s7">1</span><span class="s1">));</span>
            <span class="s2">return </span><span class="s5">Error</span><span class="s1">();</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s1">VipsInterpretation colourspace </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">Is16Bit</span><span class="s1">(</span>image<span class="s1">.</span><span class="s5">interpretation</span><span class="s1">())</span>
          <span class="s2">? </span><span class="s1">VIPS_INTERPRETATION_GREY16 
          </span><span class="s2">: </span><span class="s1">VIPS_INTERPRETATION_B_W;</span>
        <span class="s1">image </span><span class="s2">= </span><span class="s1">image 
          .</span><span class="s5">extract_band</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>extractChannel<span class="s1">)</span>
          <span class="s1">.</span><span class="s5">copy</span><span class="s1">(</span>VImage<span class="s1">::</span><span class="s5">option</span><span class="s1">()-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;interpretation&quot;</span><span class="s1">, colourspace));</span>
      <span class="s1">}</span>

      <span class="s0">// Apply output ICC profile</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">!</span>baton<span class="s1">-&gt;</span>withIccProfile<span class="s1">.</span><span class="s5">empty</span><span class="s1">()) {</span>
        <span class="s2">try </span><span class="s1">{</span>
          <span class="s1">image </span><span class="s2">= </span>image<span class="s1">.</span><span class="s5">icc_transform</span><span class="s1">(</span><span class="s2">const_cast&lt;char*&gt;</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>withIccProfile<span class="s1">.</span><span class="s5">data</span><span class="s1">()), </span>VImage<span class="s1">::</span><span class="s5">option</span><span class="s1">()</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;input_profile&quot;</span><span class="s1">, processingProfile)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;embedded&quot;</span><span class="s1">, </span><span class="s6">true</span><span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;depth&quot;</span><span class="s1">, </span>sharp<span class="s1">::</span><span class="s5">Is16Bit</span><span class="s1">(</span>image<span class="s1">.</span><span class="s5">interpretation</span><span class="s1">()) </span><span class="s2">? </span><span class="s7">16 </span><span class="s2">: </span><span class="s7">8</span><span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;intent&quot;</span><span class="s1">, VIPS_INTENT_PERCEPTUAL));</span>
        <span class="s1">} </span><span class="s2">catch</span><span class="s1">(...) {</span>
          sharp<span class="s1">::</span><span class="s5">VipsWarningCallback</span><span class="s1">(</span><span class="s6">nullptr</span><span class="s1">, G_LOG_LEVEL_WARNING, </span><span class="s3">&quot;Invalid profile&quot;</span><span class="s1">, </span><span class="s6">nullptr</span><span class="s1">);</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>keepMetadata <span class="s2">&amp; </span><span class="s1">VIPS_FOREIGN_KEEP_ICC) {</span>
        <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">SetProfile</span><span class="s1">(image, inputProfile);</span>
      <span class="s1">}</span>

      <span class="s0">// Negate the colours in the image</span>
      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>negate<span class="s1">) {</span>
        <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">Negate</span><span class="s1">(image, </span>baton<span class="s1">-&gt;</span>negateAlpha<span class="s1">);</span>
      <span class="s1">}</span>

      <span class="s0">// Override EXIF Orientation tag</span>
      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>withMetadataOrientation <span class="s2">!= -</span><span class="s7">1</span><span class="s1">) {</span>
        <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">SetExifOrientation</span><span class="s1">(image, </span>baton<span class="s1">-&gt;</span>withMetadataOrientation<span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s0">// Override pixel density</span>
      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>withMetadataDensity <span class="s2">&gt; </span><span class="s7">0</span><span class="s1">) {</span>
        <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">SetDensity</span><span class="s1">(image, </span>baton<span class="s1">-&gt;</span>withMetadataDensity<span class="s1">);</span>
      <span class="s1">}</span>
      <span class="s0">// EXIF key/value pairs</span>
      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>keepMetadata <span class="s2">&amp; </span><span class="s1">VIPS_FOREIGN_KEEP_EXIF) {</span>
        <span class="s1">image </span><span class="s2">= </span>image<span class="s1">.</span><span class="s5">copy</span><span class="s1">();</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">!</span>baton<span class="s1">-&gt;</span>withExifMerge<span class="s1">) {</span>
          <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">RemoveExif</span><span class="s1">(image);</span>
        <span class="s1">}</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const auto&amp; </span><span class="s1">s : </span>baton<span class="s1">-&gt;</span>withExif<span class="s1">) {</span>
          image<span class="s1">.</span><span class="s5">set</span><span class="s1">(</span>s<span class="s1">.</span>first<span class="s1">.</span><span class="s5">data</span><span class="s1">(), </span>s<span class="s1">.</span>second<span class="s1">.</span><span class="s5">data</span><span class="s1">());</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
      <span class="s0">// XMP buffer</span>
      <span class="s2">if </span><span class="s1">((</span>baton<span class="s1">-&gt;</span>keepMetadata <span class="s2">&amp; </span><span class="s1">VIPS_FOREIGN_KEEP_XMP) </span><span class="s2">&amp;&amp; !</span>baton<span class="s1">-&gt;</span>withXmp<span class="s1">.</span><span class="s5">empty</span><span class="s1">()) {</span>
        <span class="s1">image </span><span class="s2">= </span>image<span class="s1">.</span><span class="s5">copy</span><span class="s1">();</span>
        image<span class="s1">.</span><span class="s5">set</span><span class="s1">(VIPS_META_XMP_NAME, </span><span class="s6">nullptr</span><span class="s1">,</span>
          <span class="s2">const_cast&lt;void*&gt;</span><span class="s1">(</span><span class="s2">static_cast&lt;void const*&gt;</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>withXmp<span class="s1">.</span><span class="s5">c_str</span><span class="s1">())), </span>baton<span class="s1">-&gt;</span>withXmp<span class="s1">.</span><span class="s5">size</span><span class="s1">());</span>
      <span class="s1">}</span>
      <span class="s0">// Number of channels used in output image</span>
      baton<span class="s1">-&gt;</span>channels <span class="s2">= </span>image<span class="s1">.</span><span class="s5">bands</span><span class="s1">();</span>
      baton<span class="s1">-&gt;</span>width <span class="s2">= </span>image<span class="s1">.</span><span class="s5">width</span><span class="s1">();</span>
      baton<span class="s1">-&gt;</span>height <span class="s2">= </span>image<span class="s1">.</span><span class="s5">height</span><span class="s1">();</span>

      <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">SetAnimationProperties</span><span class="s1">(</span>
        <span class="s1">image, nPages, targetPageHeight, </span>baton<span class="s1">-&gt;</span>delay<span class="s1">, </span>baton<span class="s1">-&gt;</span>loop<span class="s1">);</span>

      <span class="s2">if </span><span class="s1">(</span>image<span class="s1">.</span><span class="s5">get_typeof</span><span class="s1">(VIPS_META_PAGE_HEIGHT) </span><span class="s2">== </span><span class="s1">G_TYPE_INT) {</span>
        baton<span class="s1">-&gt;</span>pageHeightOut <span class="s2">= </span>image<span class="s1">.</span><span class="s5">get_int</span><span class="s1">(VIPS_META_PAGE_HEIGHT);</span>
        baton<span class="s1">-&gt;</span>pagesOut <span class="s2">= </span>image<span class="s1">.</span><span class="s5">get_int</span><span class="s1">(VIPS_META_N_PAGES);</span>
      <span class="s1">}</span>

      <span class="s0">// Output</span>
      sharp<span class="s1">::</span><span class="s5">SetTimeout</span><span class="s1">(image, </span>baton<span class="s1">-&gt;</span>timeoutSeconds<span class="s1">);</span>
      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>fileOut<span class="s1">.</span><span class="s5">empty</span><span class="s1">()) {</span>
        <span class="s0">// Buffer output</span>
        <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>formatOut <span class="s2">== </span><span class="s3">&quot;jpeg&quot; </span><span class="s2">|| </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>formatOut <span class="s2">== </span><span class="s3">&quot;input&quot; </span><span class="s2">&amp;&amp; </span><span class="s1">inputImageType </span><span class="s2">== </span>sharp<span class="s1">::</span>ImageType<span class="s1">::JPEG)) {</span>
          <span class="s0">// Write JPEG to buffer</span>
          sharp<span class="s1">::</span><span class="s5">AssertImageTypeDimensions</span><span class="s1">(image, </span>sharp<span class="s1">::</span>ImageType<span class="s1">::JPEG);</span>
          <span class="s1">VipsArea </span><span class="s2">*</span><span class="s1">area </span><span class="s2">= reinterpret_cast&lt;</span><span class="s1">VipsArea</span><span class="s2">*&gt;</span><span class="s1">(</span>image<span class="s1">.</span><span class="s5">jpegsave_buffer</span><span class="s1">(</span>VImage<span class="s1">::</span><span class="s5">option</span><span class="s1">()</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;keep&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>keepMetadata<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;Q&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>jpegQuality<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;interlace&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>jpegProgressive<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;subsample_mode&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>jpegChromaSubsampling <span class="s2">== </span><span class="s3">&quot;4:4:4&quot;</span>
              <span class="s2">? </span><span class="s1">VIPS_FOREIGN_SUBSAMPLE_OFF 
              </span><span class="s2">: </span><span class="s1">VIPS_FOREIGN_SUBSAMPLE_ON)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;trellis_quant&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>jpegTrellisQuantisation<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;quant_table&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>jpegQuantisationTable<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;overshoot_deringing&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>jpegOvershootDeringing<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;optimize_scans&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>jpegOptimiseScans<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;optimize_coding&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>jpegOptimiseCoding<span class="s1">)));</span>
          baton<span class="s1">-&gt;</span>bufferOut <span class="s2">= static_cast&lt;char*&gt;</span><span class="s1">(</span>area<span class="s1">-&gt;</span>data<span class="s1">);</span>
          baton<span class="s1">-&gt;</span>bufferOutLength <span class="s2">= </span>area<span class="s1">-&gt;</span>length<span class="s1">;</span>
          area<span class="s1">-&gt;</span>free_fn <span class="s2">= </span><span class="s6">nullptr</span><span class="s1">;</span>
          <span class="s5">vips_area_unref</span><span class="s1">(area);</span>
          baton<span class="s1">-&gt;</span>formatOut <span class="s2">= </span><span class="s3">&quot;jpeg&quot;</span><span class="s1">;</span>
          <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>colourspace <span class="s2">== </span><span class="s1">VIPS_INTERPRETATION_CMYK) {</span>
            baton<span class="s1">-&gt;</span>channels <span class="s2">= </span>std<span class="s1">::</span><span class="s5">min</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>channels<span class="s1">, </span><span class="s7">4</span><span class="s1">);</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            baton<span class="s1">-&gt;</span>channels <span class="s2">= </span>std<span class="s1">::</span><span class="s5">min</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>channels<span class="s1">, </span><span class="s7">3</span><span class="s1">);</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>formatOut <span class="s2">== </span><span class="s3">&quot;jp2&quot; </span><span class="s2">|| </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>formatOut <span class="s2">== </span><span class="s3">&quot;input&quot;</span>
          <span class="s2">&amp;&amp; </span><span class="s1">inputImageType </span><span class="s2">== </span>sharp<span class="s1">::</span>ImageType<span class="s1">::JP2)) {</span>
          <span class="s0">// Write JP2 to Buffer</span>
          sharp<span class="s1">::</span><span class="s5">AssertImageTypeDimensions</span><span class="s1">(image, </span>sharp<span class="s1">::</span>ImageType<span class="s1">::JP2);</span>
          <span class="s1">VipsArea </span><span class="s2">*</span><span class="s1">area </span><span class="s2">= reinterpret_cast&lt;</span><span class="s1">VipsArea</span><span class="s2">*&gt;</span><span class="s1">(</span>image<span class="s1">.</span><span class="s5">jp2ksave_buffer</span><span class="s1">(</span>VImage<span class="s1">::</span><span class="s5">option</span><span class="s1">()</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;Q&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>jp2Quality<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;lossless&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>jp2Lossless<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;subsample_mode&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>jp2ChromaSubsampling <span class="s2">== </span><span class="s3">&quot;4:4:4&quot;</span>
              <span class="s2">? </span><span class="s1">VIPS_FOREIGN_SUBSAMPLE_OFF </span><span class="s2">: </span><span class="s1">VIPS_FOREIGN_SUBSAMPLE_ON)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;tile_height&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>jp2TileHeight<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;tile_width&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>jp2TileWidth<span class="s1">)));</span>
          baton<span class="s1">-&gt;</span>bufferOut <span class="s2">= static_cast&lt;char*&gt;</span><span class="s1">(</span>area<span class="s1">-&gt;</span>data<span class="s1">);</span>
          baton<span class="s1">-&gt;</span>bufferOutLength <span class="s2">= </span>area<span class="s1">-&gt;</span>length<span class="s1">;</span>
          area<span class="s1">-&gt;</span>free_fn <span class="s2">= </span><span class="s6">nullptr</span><span class="s1">;</span>
          <span class="s5">vips_area_unref</span><span class="s1">(area);</span>
          baton<span class="s1">-&gt;</span>formatOut <span class="s2">= </span><span class="s3">&quot;jp2&quot;</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>formatOut <span class="s2">== </span><span class="s3">&quot;png&quot; </span><span class="s2">|| </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>formatOut <span class="s2">== </span><span class="s3">&quot;input&quot; </span><span class="s2">&amp;&amp;</span>
          <span class="s1">(inputImageType </span><span class="s2">== </span>sharp<span class="s1">::</span>ImageType<span class="s1">::PNG </span><span class="s2">|| </span><span class="s1">inputImageType </span><span class="s2">== </span>sharp<span class="s1">::</span>ImageType<span class="s1">::SVG))) {</span>
          <span class="s0">// Write PNG to buffer</span>
          sharp<span class="s1">::</span><span class="s5">AssertImageTypeDimensions</span><span class="s1">(image, </span>sharp<span class="s1">::</span>ImageType<span class="s1">::PNG);</span>
          <span class="s1">VipsArea </span><span class="s2">*</span><span class="s1">area </span><span class="s2">= reinterpret_cast&lt;</span><span class="s1">VipsArea</span><span class="s2">*&gt;</span><span class="s1">(</span>image<span class="s1">.</span><span class="s5">pngsave_buffer</span><span class="s1">(</span>VImage<span class="s1">::</span><span class="s5">option</span><span class="s1">()</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;keep&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>keepMetadata<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;interlace&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>pngProgressive<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;compression&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>pngCompressionLevel<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;filter&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>pngAdaptiveFiltering <span class="s2">? </span><span class="s1">VIPS_FOREIGN_PNG_FILTER_ALL </span><span class="s2">: </span><span class="s1">VIPS_FOREIGN_PNG_FILTER_NONE)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;palette&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>pngPalette<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;Q&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>pngQuality<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;effort&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>pngEffort<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">, </span>sharp<span class="s1">::</span><span class="s5">Is16Bit</span><span class="s1">(</span>image<span class="s1">.</span><span class="s5">interpretation</span><span class="s1">()) </span><span class="s2">? </span><span class="s7">16 </span><span class="s2">: </span>baton<span class="s1">-&gt;</span>pngBitdepth<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;dither&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>pngDither<span class="s1">)));</span>
          baton<span class="s1">-&gt;</span>bufferOut <span class="s2">= static_cast&lt;char*&gt;</span><span class="s1">(</span>area<span class="s1">-&gt;</span>data<span class="s1">);</span>
          baton<span class="s1">-&gt;</span>bufferOutLength <span class="s2">= </span>area<span class="s1">-&gt;</span>length<span class="s1">;</span>
          area<span class="s1">-&gt;</span>free_fn <span class="s2">= </span><span class="s6">nullptr</span><span class="s1">;</span>
          <span class="s5">vips_area_unref</span><span class="s1">(area);</span>
          baton<span class="s1">-&gt;</span>formatOut <span class="s2">= </span><span class="s3">&quot;png&quot;</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>formatOut <span class="s2">== </span><span class="s3">&quot;webp&quot; </span><span class="s2">||</span>
          <span class="s1">(</span>baton<span class="s1">-&gt;</span>formatOut <span class="s2">== </span><span class="s3">&quot;input&quot; </span><span class="s2">&amp;&amp; </span><span class="s1">inputImageType </span><span class="s2">== </span>sharp<span class="s1">::</span>ImageType<span class="s1">::WEBP)) {</span>
          <span class="s0">// Write WEBP to buffer</span>
          sharp<span class="s1">::</span><span class="s5">AssertImageTypeDimensions</span><span class="s1">(image, </span>sharp<span class="s1">::</span>ImageType<span class="s1">::WEBP);</span>
          <span class="s1">VipsArea </span><span class="s2">*</span><span class="s1">area </span><span class="s2">= reinterpret_cast&lt;</span><span class="s1">VipsArea</span><span class="s2">*&gt;</span><span class="s1">(</span>image<span class="s1">.</span><span class="s5">webpsave_buffer</span><span class="s1">(</span>VImage<span class="s1">::</span><span class="s5">option</span><span class="s1">()</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;keep&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>keepMetadata<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;Q&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>webpQuality<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;lossless&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>webpLossless<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;near_lossless&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>webpNearLossless<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;smart_subsample&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>webpSmartSubsample<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;smart_deblock&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>webpSmartDeblock<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;preset&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>webpPreset<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;effort&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>webpEffort<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;min_size&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>webpMinSize<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;mixed&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>webpMixed<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;alpha_q&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>webpAlphaQuality<span class="s1">)));</span>
          baton<span class="s1">-&gt;</span>bufferOut <span class="s2">= static_cast&lt;char*&gt;</span><span class="s1">(</span>area<span class="s1">-&gt;</span>data<span class="s1">);</span>
          baton<span class="s1">-&gt;</span>bufferOutLength <span class="s2">= </span>area<span class="s1">-&gt;</span>length<span class="s1">;</span>
          area<span class="s1">-&gt;</span>free_fn <span class="s2">= </span><span class="s6">nullptr</span><span class="s1">;</span>
          <span class="s5">vips_area_unref</span><span class="s1">(area);</span>
          baton<span class="s1">-&gt;</span>formatOut <span class="s2">= </span><span class="s3">&quot;webp&quot;</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>formatOut <span class="s2">== </span><span class="s3">&quot;gif&quot; </span><span class="s2">||</span>
          <span class="s1">(</span>baton<span class="s1">-&gt;</span>formatOut <span class="s2">== </span><span class="s3">&quot;input&quot; </span><span class="s2">&amp;&amp; </span><span class="s1">inputImageType </span><span class="s2">== </span>sharp<span class="s1">::</span>ImageType<span class="s1">::GIF)) {</span>
          <span class="s0">// Write GIF to buffer</span>
          sharp<span class="s1">::</span><span class="s5">AssertImageTypeDimensions</span><span class="s1">(image, </span>sharp<span class="s1">::</span>ImageType<span class="s1">::GIF);</span>
          <span class="s1">VipsArea </span><span class="s2">*</span><span class="s1">area </span><span class="s2">= reinterpret_cast&lt;</span><span class="s1">VipsArea</span><span class="s2">*&gt;</span><span class="s1">(</span>image<span class="s1">.</span><span class="s5">gifsave_buffer</span><span class="s1">(</span>VImage<span class="s1">::</span><span class="s5">option</span><span class="s1">()</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;keep&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>keepMetadata<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>gifBitdepth<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;effort&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>gifEffort<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;reuse&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>gifReuse<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;interlace&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>gifProgressive<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;interframe_maxerror&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>gifInterFrameMaxError<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;interpalette_maxerror&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>gifInterPaletteMaxError<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;keep_duplicate_frames&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>gifKeepDuplicateFrames<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;dither&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>gifDither<span class="s1">)));</span>
          baton<span class="s1">-&gt;</span>bufferOut <span class="s2">= static_cast&lt;char*&gt;</span><span class="s1">(</span>area<span class="s1">-&gt;</span>data<span class="s1">);</span>
          baton<span class="s1">-&gt;</span>bufferOutLength <span class="s2">= </span>area<span class="s1">-&gt;</span>length<span class="s1">;</span>
          area<span class="s1">-&gt;</span>free_fn <span class="s2">= </span><span class="s6">nullptr</span><span class="s1">;</span>
          <span class="s5">vips_area_unref</span><span class="s1">(area);</span>
          baton<span class="s1">-&gt;</span>formatOut <span class="s2">= </span><span class="s3">&quot;gif&quot;</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>formatOut <span class="s2">== </span><span class="s3">&quot;tiff&quot; </span><span class="s2">||</span>
          <span class="s1">(</span>baton<span class="s1">-&gt;</span>formatOut <span class="s2">== </span><span class="s3">&quot;input&quot; </span><span class="s2">&amp;&amp; </span><span class="s1">inputImageType </span><span class="s2">== </span>sharp<span class="s1">::</span>ImageType<span class="s1">::TIFF)) {</span>
          <span class="s0">// Write TIFF to buffer</span>
          <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>tiffCompression <span class="s2">== </span><span class="s1">VIPS_FOREIGN_TIFF_COMPRESSION_JPEG) {</span>
            sharp<span class="s1">::</span><span class="s5">AssertImageTypeDimensions</span><span class="s1">(image, </span>sharp<span class="s1">::</span>ImageType<span class="s1">::JPEG);</span>
            baton<span class="s1">-&gt;</span>channels <span class="s2">= </span>std<span class="s1">::</span><span class="s5">min</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>channels<span class="s1">, </span><span class="s7">3</span><span class="s1">);</span>
          <span class="s1">}</span>
          <span class="s0">// Cast pixel values to float, if required</span>
          <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>tiffPredictor <span class="s2">== </span><span class="s1">VIPS_FOREIGN_TIFF_PREDICTOR_FLOAT) {</span>
            <span class="s1">image </span><span class="s2">= </span>image<span class="s1">.</span><span class="s5">cast</span><span class="s1">(VIPS_FORMAT_FLOAT);</span>
          <span class="s1">}</span>
          <span class="s1">VipsArea </span><span class="s2">*</span><span class="s1">area </span><span class="s2">= reinterpret_cast&lt;</span><span class="s1">VipsArea</span><span class="s2">*&gt;</span><span class="s1">(</span>image<span class="s1">.</span><span class="s5">tiffsave_buffer</span><span class="s1">(</span>VImage<span class="s1">::</span><span class="s5">option</span><span class="s1">()</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;keep&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>keepMetadata<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;Q&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>tiffQuality<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>tiffBitdepth<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;compression&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>tiffCompression<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;miniswhite&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>tiffMiniswhite<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;predictor&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>tiffPredictor<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;pyramid&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>tiffPyramid<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;tile&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>tiffTile<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;tile_height&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>tiffTileHeight<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;tile_width&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>tiffTileWidth<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;xres&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>tiffXres<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;yres&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>tiffYres<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;resunit&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>tiffResolutionUnit<span class="s1">)));</span>
          baton<span class="s1">-&gt;</span>bufferOut <span class="s2">= static_cast&lt;char*&gt;</span><span class="s1">(</span>area<span class="s1">-&gt;</span>data<span class="s1">);</span>
          baton<span class="s1">-&gt;</span>bufferOutLength <span class="s2">= </span>area<span class="s1">-&gt;</span>length<span class="s1">;</span>
          area<span class="s1">-&gt;</span>free_fn <span class="s2">= </span><span class="s6">nullptr</span><span class="s1">;</span>
          <span class="s5">vips_area_unref</span><span class="s1">(area);</span>
          baton<span class="s1">-&gt;</span>formatOut <span class="s2">= </span><span class="s3">&quot;tiff&quot;</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>formatOut <span class="s2">== </span><span class="s3">&quot;heif&quot; </span><span class="s2">||</span>
          <span class="s1">(</span>baton<span class="s1">-&gt;</span>formatOut <span class="s2">== </span><span class="s3">&quot;input&quot; </span><span class="s2">&amp;&amp; </span><span class="s1">inputImageType </span><span class="s2">== </span>sharp<span class="s1">::</span>ImageType<span class="s1">::HEIF)) {</span>
          <span class="s0">// Write HEIF to buffer</span>
          sharp<span class="s1">::</span><span class="s5">AssertImageTypeDimensions</span><span class="s1">(image, </span>sharp<span class="s1">::</span>ImageType<span class="s1">::HEIF);</span>
          <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">RemoveAnimationProperties</span><span class="s1">(image);</span>
          <span class="s1">VipsArea </span><span class="s2">*</span><span class="s1">area </span><span class="s2">= reinterpret_cast&lt;</span><span class="s1">VipsArea</span><span class="s2">*&gt;</span><span class="s1">(</span>image<span class="s1">.</span><span class="s5">heifsave_buffer</span><span class="s1">(</span>VImage<span class="s1">::</span><span class="s5">option</span><span class="s1">()</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;keep&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>keepMetadata<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;Q&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>heifQuality<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;compression&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>heifCompression<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;effort&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>heifEffort<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>heifBitdepth<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;subsample_mode&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>heifChromaSubsampling <span class="s2">== </span><span class="s3">&quot;4:4:4&quot;</span>
              <span class="s2">? </span><span class="s1">VIPS_FOREIGN_SUBSAMPLE_OFF </span><span class="s2">: </span><span class="s1">VIPS_FOREIGN_SUBSAMPLE_ON)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;lossless&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>heifLossless<span class="s1">)));</span>
          baton<span class="s1">-&gt;</span>bufferOut <span class="s2">= static_cast&lt;char*&gt;</span><span class="s1">(</span>area<span class="s1">-&gt;</span>data<span class="s1">);</span>
          baton<span class="s1">-&gt;</span>bufferOutLength <span class="s2">= </span>area<span class="s1">-&gt;</span>length<span class="s1">;</span>
          area<span class="s1">-&gt;</span>free_fn <span class="s2">= </span><span class="s6">nullptr</span><span class="s1">;</span>
          <span class="s5">vips_area_unref</span><span class="s1">(area);</span>
          baton<span class="s1">-&gt;</span>formatOut <span class="s2">= </span><span class="s3">&quot;heif&quot;</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>formatOut <span class="s2">== </span><span class="s3">&quot;dz&quot;</span><span class="s1">) {</span>
          <span class="s0">// Write DZ to buffer</span>
          baton<span class="s1">-&gt;</span>tileContainer <span class="s2">= </span><span class="s1">VIPS_FOREIGN_DZ_CONTAINER_ZIP;</span>
          <span class="s2">if </span><span class="s1">(</span><span class="s2">!</span>image<span class="s1">.</span><span class="s5">has_alpha</span><span class="s1">()) {</span>
            baton<span class="s1">-&gt;</span>tileBackground<span class="s1">.</span><span class="s5">pop_back</span><span class="s1">();</span>
          <span class="s1">}</span>
          <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">StaySequential</span><span class="s1">(image, </span>baton<span class="s1">-&gt;</span>tileAngle <span class="s2">!= </span><span class="s7">0</span><span class="s1">);</span>
          vips<span class="s1">::VOption </span><span class="s2">*</span><span class="s1">options </span><span class="s2">= </span><span class="s5">BuildOptionsDZ</span><span class="s1">(baton);</span>
          <span class="s1">VipsArea </span><span class="s2">*</span><span class="s1">area </span><span class="s2">= reinterpret_cast&lt;</span><span class="s1">VipsArea</span><span class="s2">*&gt;</span><span class="s1">(</span>image<span class="s1">.</span><span class="s5">dzsave_buffer</span><span class="s1">(options));</span>
          baton<span class="s1">-&gt;</span>bufferOut <span class="s2">= static_cast&lt;char*&gt;</span><span class="s1">(</span>area<span class="s1">-&gt;</span>data<span class="s1">);</span>
          baton<span class="s1">-&gt;</span>bufferOutLength <span class="s2">= </span>area<span class="s1">-&gt;</span>length<span class="s1">;</span>
          area<span class="s1">-&gt;</span>free_fn <span class="s2">= </span><span class="s6">nullptr</span><span class="s1">;</span>
          <span class="s5">vips_area_unref</span><span class="s1">(area);</span>
          baton<span class="s1">-&gt;</span>formatOut <span class="s2">= </span><span class="s3">&quot;dz&quot;</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>formatOut <span class="s2">== </span><span class="s3">&quot;jxl&quot; </span><span class="s2">||</span>
          <span class="s1">(</span>baton<span class="s1">-&gt;</span>formatOut <span class="s2">== </span><span class="s3">&quot;input&quot; </span><span class="s2">&amp;&amp; </span><span class="s1">inputImageType </span><span class="s2">== </span>sharp<span class="s1">::</span>ImageType<span class="s1">::JXL)) {</span>
          <span class="s0">// Write JXL to buffer</span>
          <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">RemoveAnimationProperties</span><span class="s1">(image);</span>
          <span class="s1">VipsArea </span><span class="s2">*</span><span class="s1">area </span><span class="s2">= reinterpret_cast&lt;</span><span class="s1">VipsArea</span><span class="s2">*&gt;</span><span class="s1">(</span>image<span class="s1">.</span><span class="s5">jxlsave_buffer</span><span class="s1">(</span>VImage<span class="s1">::</span><span class="s5">option</span><span class="s1">()</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;keep&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>keepMetadata<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;distance&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>jxlDistance<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;tier&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>jxlDecodingTier<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;effort&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>jxlEffort<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;lossless&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>jxlLossless<span class="s1">)));</span>
          baton<span class="s1">-&gt;</span>bufferOut <span class="s2">= static_cast&lt;char*&gt;</span><span class="s1">(</span>area<span class="s1">-&gt;</span>data<span class="s1">);</span>
          baton<span class="s1">-&gt;</span>bufferOutLength <span class="s2">= </span>area<span class="s1">-&gt;</span>length<span class="s1">;</span>
          area<span class="s1">-&gt;</span>free_fn <span class="s2">= </span><span class="s6">nullptr</span><span class="s1">;</span>
          <span class="s5">vips_area_unref</span><span class="s1">(area);</span>
          baton<span class="s1">-&gt;</span>formatOut <span class="s2">= </span><span class="s3">&quot;jxl&quot;</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>formatOut <span class="s2">== </span><span class="s3">&quot;raw&quot; </span><span class="s2">||</span>
          <span class="s1">(</span>baton<span class="s1">-&gt;</span>formatOut <span class="s2">== </span><span class="s3">&quot;input&quot; </span><span class="s2">&amp;&amp; </span><span class="s1">inputImageType </span><span class="s2">== </span>sharp<span class="s1">::</span>ImageType<span class="s1">::RAW)) {</span>
          <span class="s0">// Write raw, uncompressed image data to buffer</span>
          <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>greyscale <span class="s2">|| </span>image<span class="s1">.</span><span class="s5">interpretation</span><span class="s1">() </span><span class="s2">== </span><span class="s1">VIPS_INTERPRETATION_B_W) {</span>
            <span class="s0">// Extract first band for greyscale image</span>
            <span class="s1">image </span><span class="s2">= </span>image<span class="s1">[</span><span class="s7">0</span><span class="s1">];</span>
            baton<span class="s1">-&gt;</span>channels <span class="s2">= </span><span class="s7">1</span><span class="s1">;</span>
          <span class="s1">}</span>
          <span class="s2">if </span><span class="s1">(</span>image<span class="s1">.</span><span class="s5">format</span><span class="s1">() </span><span class="s2">!= </span>baton<span class="s1">-&gt;</span>rawDepth<span class="s1">) {</span>
            <span class="s0">// Cast pixels to requested format</span>
            <span class="s1">image </span><span class="s2">= </span>image<span class="s1">.</span><span class="s5">cast</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>rawDepth<span class="s1">);</span>
          <span class="s1">}</span>
          <span class="s0">// Get raw image data</span>
          baton<span class="s1">-&gt;</span>bufferOut <span class="s2">= static_cast&lt;char*&gt;</span><span class="s1">(</span>image<span class="s1">.</span><span class="s5">write_to_memory</span><span class="s1">(</span><span class="s2">&amp;</span>baton<span class="s1">-&gt;</span>bufferOutLength<span class="s1">));</span>
          <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>bufferOut <span class="s2">== </span><span class="s6">nullptr</span><span class="s1">) {</span>
            <span class="s1">(</span>baton<span class="s1">-&gt;</span>err<span class="s1">).</span><span class="s5">append</span><span class="s1">(</span><span class="s3">&quot;Could not allocate enough memory for raw output&quot;</span><span class="s1">);</span>
            <span class="s2">return </span><span class="s5">Error</span><span class="s1">();</span>
          <span class="s1">}</span>
          baton<span class="s1">-&gt;</span>formatOut <span class="s2">= </span><span class="s3">&quot;raw&quot;</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s0">// Unsupported output format</span>
          <span class="s1">(</span>baton<span class="s1">-&gt;</span>err<span class="s1">).</span><span class="s5">append</span><span class="s1">(</span><span class="s3">&quot;Unsupported output format &quot;</span><span class="s1">);</span>
          <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>formatOut <span class="s2">== </span><span class="s3">&quot;input&quot;</span><span class="s1">) {</span>
            <span class="s1">(</span>baton<span class="s1">-&gt;</span>err<span class="s1">).</span><span class="s5">append</span><span class="s1">(</span><span class="s3">&quot;when trying to match input format of &quot;</span><span class="s1">);</span>
            <span class="s1">(</span>baton<span class="s1">-&gt;</span>err<span class="s1">).</span><span class="s5">append</span><span class="s1">(</span><span class="s5">ImageTypeId</span><span class="s1">(inputImageType));</span>
          <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">(</span>baton<span class="s1">-&gt;</span>err<span class="s1">).</span><span class="s5">append</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>formatOut<span class="s1">);</span>
          <span class="s1">}</span>
          <span class="s2">return </span><span class="s5">Error</span><span class="s1">();</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// File output</span>
        <span class="s2">bool const </span><span class="s1">isJpeg </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">IsJpeg</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>fileOut<span class="s1">);</span>
        <span class="s2">bool const </span><span class="s1">isPng </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">IsPng</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>fileOut<span class="s1">);</span>
        <span class="s2">bool const </span><span class="s1">isWebp </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">IsWebp</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>fileOut<span class="s1">);</span>
        <span class="s2">bool const </span><span class="s1">isGif </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">IsGif</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>fileOut<span class="s1">);</span>
        <span class="s2">bool const </span><span class="s1">isTiff </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">IsTiff</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>fileOut<span class="s1">);</span>
        <span class="s2">bool const </span><span class="s1">isJp2 </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">IsJp2</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>fileOut<span class="s1">);</span>
        <span class="s2">bool const </span><span class="s1">isHeif </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">IsHeif</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>fileOut<span class="s1">);</span>
        <span class="s2">bool const </span><span class="s1">isJxl </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">IsJxl</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>fileOut<span class="s1">);</span>
        <span class="s2">bool const </span><span class="s1">isDz </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">IsDz</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>fileOut<span class="s1">);</span>
        <span class="s2">bool const </span><span class="s1">isDzZip </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">IsDzZip</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>fileOut<span class="s1">);</span>
        <span class="s2">bool const </span><span class="s1">isV </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">IsV</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>fileOut<span class="s1">);</span>
        <span class="s2">bool const </span><span class="s1">mightMatchInput </span><span class="s2">= </span>baton<span class="s1">-&gt;</span>formatOut <span class="s2">== </span><span class="s3">&quot;input&quot;</span><span class="s1">;</span>
        <span class="s2">bool const </span><span class="s1">willMatchInput </span><span class="s2">= </span><span class="s1">mightMatchInput </span><span class="s2">&amp;&amp;</span>
         <span class="s2">!</span><span class="s1">(isJpeg </span><span class="s2">|| </span><span class="s1">isPng </span><span class="s2">|| </span><span class="s1">isWebp </span><span class="s2">|| </span><span class="s1">isGif </span><span class="s2">|| </span><span class="s1">isTiff </span><span class="s2">|| </span><span class="s1">isJp2 </span><span class="s2">|| </span><span class="s1">isHeif </span><span class="s2">|| </span><span class="s1">isDz </span><span class="s2">|| </span><span class="s1">isDzZip </span><span class="s2">|| </span><span class="s1">isV);</span>

        <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>formatOut <span class="s2">== </span><span class="s3">&quot;jpeg&quot; </span><span class="s2">|| </span><span class="s1">(mightMatchInput </span><span class="s2">&amp;&amp; </span><span class="s1">isJpeg) </span><span class="s2">||</span>
          <span class="s1">(willMatchInput </span><span class="s2">&amp;&amp; </span><span class="s1">inputImageType </span><span class="s2">== </span>sharp<span class="s1">::</span>ImageType<span class="s1">::JPEG)) {</span>
          <span class="s0">// Write JPEG to file</span>
          sharp<span class="s1">::</span><span class="s5">AssertImageTypeDimensions</span><span class="s1">(image, </span>sharp<span class="s1">::</span>ImageType<span class="s1">::JPEG);</span>
          image<span class="s1">.</span><span class="s5">jpegsave</span><span class="s1">(</span><span class="s2">const_cast&lt;char*&gt;</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>fileOut<span class="s1">.</span><span class="s5">data</span><span class="s1">()), </span>VImage<span class="s1">::</span><span class="s5">option</span><span class="s1">()</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;keep&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>keepMetadata<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;Q&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>jpegQuality<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;interlace&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>jpegProgressive<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;subsample_mode&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>jpegChromaSubsampling <span class="s2">== </span><span class="s3">&quot;4:4:4&quot;</span>
              <span class="s2">? </span><span class="s1">VIPS_FOREIGN_SUBSAMPLE_OFF 
              </span><span class="s2">: </span><span class="s1">VIPS_FOREIGN_SUBSAMPLE_ON)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;trellis_quant&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>jpegTrellisQuantisation<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;quant_table&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>jpegQuantisationTable<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;overshoot_deringing&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>jpegOvershootDeringing<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;optimize_scans&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>jpegOptimiseScans<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;optimize_coding&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>jpegOptimiseCoding<span class="s1">));</span>
          baton<span class="s1">-&gt;</span>formatOut <span class="s2">= </span><span class="s3">&quot;jpeg&quot;</span><span class="s1">;</span>
          baton<span class="s1">-&gt;</span>channels <span class="s2">= </span>std<span class="s1">::</span><span class="s5">min</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>channels<span class="s1">, </span><span class="s7">3</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>formatOut <span class="s2">== </span><span class="s3">&quot;jp2&quot; </span><span class="s2">|| </span><span class="s1">(mightMatchInput </span><span class="s2">&amp;&amp; </span><span class="s1">isJp2) </span><span class="s2">||</span>
          <span class="s1">(willMatchInput </span><span class="s2">&amp;&amp; </span><span class="s1">(inputImageType </span><span class="s2">== </span>sharp<span class="s1">::</span>ImageType<span class="s1">::JP2))) {</span>
          <span class="s0">// Write JP2 to file</span>
          sharp<span class="s1">::</span><span class="s5">AssertImageTypeDimensions</span><span class="s1">(image, </span>sharp<span class="s1">::</span>ImageType<span class="s1">::JP2);</span>
          image<span class="s1">.</span><span class="s5">jp2ksave</span><span class="s1">(</span><span class="s2">const_cast&lt;char*&gt;</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>fileOut<span class="s1">.</span><span class="s5">data</span><span class="s1">()), </span>VImage<span class="s1">::</span><span class="s5">option</span><span class="s1">()</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;Q&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>jp2Quality<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;lossless&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>jp2Lossless<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;subsample_mode&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>jp2ChromaSubsampling <span class="s2">== </span><span class="s3">&quot;4:4:4&quot;</span>
              <span class="s2">? </span><span class="s1">VIPS_FOREIGN_SUBSAMPLE_OFF </span><span class="s2">: </span><span class="s1">VIPS_FOREIGN_SUBSAMPLE_ON)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;tile_height&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>jp2TileHeight<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;tile_width&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>jp2TileWidth<span class="s1">));</span>
            baton<span class="s1">-&gt;</span>formatOut <span class="s2">= </span><span class="s3">&quot;jp2&quot;</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>formatOut <span class="s2">== </span><span class="s3">&quot;png&quot; </span><span class="s2">|| </span><span class="s1">(mightMatchInput </span><span class="s2">&amp;&amp; </span><span class="s1">isPng) </span><span class="s2">|| </span><span class="s1">(willMatchInput </span><span class="s2">&amp;&amp;</span>
          <span class="s1">(inputImageType </span><span class="s2">== </span>sharp<span class="s1">::</span>ImageType<span class="s1">::PNG </span><span class="s2">|| </span><span class="s1">inputImageType </span><span class="s2">== </span>sharp<span class="s1">::</span>ImageType<span class="s1">::SVG))) {</span>
          <span class="s0">// Write PNG to file</span>
          sharp<span class="s1">::</span><span class="s5">AssertImageTypeDimensions</span><span class="s1">(image, </span>sharp<span class="s1">::</span>ImageType<span class="s1">::PNG);</span>
          image<span class="s1">.</span><span class="s5">pngsave</span><span class="s1">(</span><span class="s2">const_cast&lt;char*&gt;</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>fileOut<span class="s1">.</span><span class="s5">data</span><span class="s1">()), </span>VImage<span class="s1">::</span><span class="s5">option</span><span class="s1">()</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;keep&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>keepMetadata<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;interlace&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>pngProgressive<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;compression&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>pngCompressionLevel<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;filter&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>pngAdaptiveFiltering <span class="s2">? </span><span class="s1">VIPS_FOREIGN_PNG_FILTER_ALL </span><span class="s2">: </span><span class="s1">VIPS_FOREIGN_PNG_FILTER_NONE)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;palette&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>pngPalette<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;Q&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>pngQuality<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">, </span>sharp<span class="s1">::</span><span class="s5">Is16Bit</span><span class="s1">(</span>image<span class="s1">.</span><span class="s5">interpretation</span><span class="s1">()) </span><span class="s2">? </span><span class="s7">16 </span><span class="s2">: </span>baton<span class="s1">-&gt;</span>pngBitdepth<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;effort&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>pngEffort<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;dither&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>pngDither<span class="s1">));</span>
          baton<span class="s1">-&gt;</span>formatOut <span class="s2">= </span><span class="s3">&quot;png&quot;</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>formatOut <span class="s2">== </span><span class="s3">&quot;webp&quot; </span><span class="s2">|| </span><span class="s1">(mightMatchInput </span><span class="s2">&amp;&amp; </span><span class="s1">isWebp) </span><span class="s2">||</span>
          <span class="s1">(willMatchInput </span><span class="s2">&amp;&amp; </span><span class="s1">inputImageType </span><span class="s2">== </span>sharp<span class="s1">::</span>ImageType<span class="s1">::WEBP)) {</span>
          <span class="s0">// Write WEBP to file</span>
          sharp<span class="s1">::</span><span class="s5">AssertImageTypeDimensions</span><span class="s1">(image, </span>sharp<span class="s1">::</span>ImageType<span class="s1">::WEBP);</span>
          image<span class="s1">.</span><span class="s5">webpsave</span><span class="s1">(</span><span class="s2">const_cast&lt;char*&gt;</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>fileOut<span class="s1">.</span><span class="s5">data</span><span class="s1">()), </span>VImage<span class="s1">::</span><span class="s5">option</span><span class="s1">()</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;keep&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>keepMetadata<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;Q&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>webpQuality<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;lossless&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>webpLossless<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;near_lossless&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>webpNearLossless<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;smart_subsample&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>webpSmartSubsample<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;smart_deblock&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>webpSmartDeblock<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;preset&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>webpPreset<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;effort&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>webpEffort<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;min_size&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>webpMinSize<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;mixed&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>webpMixed<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;alpha_q&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>webpAlphaQuality<span class="s1">));</span>
          baton<span class="s1">-&gt;</span>formatOut <span class="s2">= </span><span class="s3">&quot;webp&quot;</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>formatOut <span class="s2">== </span><span class="s3">&quot;gif&quot; </span><span class="s2">|| </span><span class="s1">(mightMatchInput </span><span class="s2">&amp;&amp; </span><span class="s1">isGif) </span><span class="s2">||</span>
          <span class="s1">(willMatchInput </span><span class="s2">&amp;&amp; </span><span class="s1">inputImageType </span><span class="s2">== </span>sharp<span class="s1">::</span>ImageType<span class="s1">::GIF)) {</span>
          <span class="s0">// Write GIF to file</span>
          sharp<span class="s1">::</span><span class="s5">AssertImageTypeDimensions</span><span class="s1">(image, </span>sharp<span class="s1">::</span>ImageType<span class="s1">::GIF);</span>
          image<span class="s1">.</span><span class="s5">gifsave</span><span class="s1">(</span><span class="s2">const_cast&lt;char*&gt;</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>fileOut<span class="s1">.</span><span class="s5">data</span><span class="s1">()), </span>VImage<span class="s1">::</span><span class="s5">option</span><span class="s1">()</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;keep&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>keepMetadata<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>gifBitdepth<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;effort&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>gifEffort<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;reuse&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>gifReuse<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;interlace&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>gifProgressive<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;interframe_maxerror&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>gifInterFrameMaxError<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;interpalette_maxerror&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>gifInterPaletteMaxError<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;keep_duplicate_frames&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>gifKeepDuplicateFrames<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;dither&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>gifDither<span class="s1">));</span>
          baton<span class="s1">-&gt;</span>formatOut <span class="s2">= </span><span class="s3">&quot;gif&quot;</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>formatOut <span class="s2">== </span><span class="s3">&quot;tiff&quot; </span><span class="s2">|| </span><span class="s1">(mightMatchInput </span><span class="s2">&amp;&amp; </span><span class="s1">isTiff) </span><span class="s2">||</span>
          <span class="s1">(willMatchInput </span><span class="s2">&amp;&amp; </span><span class="s1">inputImageType </span><span class="s2">== </span>sharp<span class="s1">::</span>ImageType<span class="s1">::TIFF)) {</span>
          <span class="s0">// Write TIFF to file</span>
          <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>tiffCompression <span class="s2">== </span><span class="s1">VIPS_FOREIGN_TIFF_COMPRESSION_JPEG) {</span>
            sharp<span class="s1">::</span><span class="s5">AssertImageTypeDimensions</span><span class="s1">(image, </span>sharp<span class="s1">::</span>ImageType<span class="s1">::JPEG);</span>
            baton<span class="s1">-&gt;</span>channels <span class="s2">= </span>std<span class="s1">::</span><span class="s5">min</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>channels<span class="s1">, </span><span class="s7">3</span><span class="s1">);</span>
          <span class="s1">}</span>
          <span class="s0">// Cast pixel values to float, if required</span>
          <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>tiffPredictor <span class="s2">== </span><span class="s1">VIPS_FOREIGN_TIFF_PREDICTOR_FLOAT) {</span>
            <span class="s1">image </span><span class="s2">= </span>image<span class="s1">.</span><span class="s5">cast</span><span class="s1">(VIPS_FORMAT_FLOAT);</span>
          <span class="s1">}</span>
          image<span class="s1">.</span><span class="s5">tiffsave</span><span class="s1">(</span><span class="s2">const_cast&lt;char*&gt;</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>fileOut<span class="s1">.</span><span class="s5">data</span><span class="s1">()), </span>VImage<span class="s1">::</span><span class="s5">option</span><span class="s1">()</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;keep&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>keepMetadata<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;Q&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>tiffQuality<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>tiffBitdepth<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;compression&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>tiffCompression<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;miniswhite&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>tiffMiniswhite<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;predictor&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>tiffPredictor<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;pyramid&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>tiffPyramid<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;tile&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>tiffTile<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;tile_height&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>tiffTileHeight<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;tile_width&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>tiffTileWidth<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;xres&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>tiffXres<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;yres&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>tiffYres<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;resunit&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>tiffResolutionUnit<span class="s1">));</span>
          baton<span class="s1">-&gt;</span>formatOut <span class="s2">= </span><span class="s3">&quot;tiff&quot;</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>formatOut <span class="s2">== </span><span class="s3">&quot;heif&quot; </span><span class="s2">|| </span><span class="s1">(mightMatchInput </span><span class="s2">&amp;&amp; </span><span class="s1">isHeif) </span><span class="s2">||</span>
          <span class="s1">(willMatchInput </span><span class="s2">&amp;&amp; </span><span class="s1">inputImageType </span><span class="s2">== </span>sharp<span class="s1">::</span>ImageType<span class="s1">::HEIF)) {</span>
          <span class="s0">// Write HEIF to file</span>
          sharp<span class="s1">::</span><span class="s5">AssertImageTypeDimensions</span><span class="s1">(image, </span>sharp<span class="s1">::</span>ImageType<span class="s1">::HEIF);</span>
          <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">RemoveAnimationProperties</span><span class="s1">(image);</span>
          image<span class="s1">.</span><span class="s5">heifsave</span><span class="s1">(</span><span class="s2">const_cast&lt;char*&gt;</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>fileOut<span class="s1">.</span><span class="s5">data</span><span class="s1">()), </span>VImage<span class="s1">::</span><span class="s5">option</span><span class="s1">()</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;keep&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>keepMetadata<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;Q&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>heifQuality<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;compression&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>heifCompression<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;effort&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>heifEffort<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;bitdepth&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>heifBitdepth<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;subsample_mode&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>heifChromaSubsampling <span class="s2">== </span><span class="s3">&quot;4:4:4&quot;</span>
              <span class="s2">? </span><span class="s1">VIPS_FOREIGN_SUBSAMPLE_OFF </span><span class="s2">: </span><span class="s1">VIPS_FOREIGN_SUBSAMPLE_ON)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;lossless&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>heifLossless<span class="s1">));</span>
          baton<span class="s1">-&gt;</span>formatOut <span class="s2">= </span><span class="s3">&quot;heif&quot;</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>formatOut <span class="s2">== </span><span class="s3">&quot;jxl&quot; </span><span class="s2">|| </span><span class="s1">(mightMatchInput </span><span class="s2">&amp;&amp; </span><span class="s1">isJxl) </span><span class="s2">||</span>
          <span class="s1">(willMatchInput </span><span class="s2">&amp;&amp; </span><span class="s1">inputImageType </span><span class="s2">== </span>sharp<span class="s1">::</span>ImageType<span class="s1">::JXL)) {</span>
          <span class="s0">// Write JXL to file</span>
          <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">RemoveAnimationProperties</span><span class="s1">(image);</span>
          image<span class="s1">.</span><span class="s5">jxlsave</span><span class="s1">(</span><span class="s2">const_cast&lt;char*&gt;</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>fileOut<span class="s1">.</span><span class="s5">data</span><span class="s1">()), </span>VImage<span class="s1">::</span><span class="s5">option</span><span class="s1">()</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;keep&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>keepMetadata<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;distance&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>jxlDistance<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;tier&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>jxlDecodingTier<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;effort&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>jxlEffort<span class="s1">)</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;lossless&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>jxlLossless<span class="s1">));</span>
          baton<span class="s1">-&gt;</span>formatOut <span class="s2">= </span><span class="s3">&quot;jxl&quot;</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>formatOut <span class="s2">== </span><span class="s3">&quot;dz&quot; </span><span class="s2">|| </span><span class="s1">isDz </span><span class="s2">|| </span><span class="s1">isDzZip) {</span>
          <span class="s0">// Write DZ to file</span>
          <span class="s2">if </span><span class="s1">(isDzZip) {</span>
            baton<span class="s1">-&gt;</span>tileContainer <span class="s2">= </span><span class="s1">VIPS_FOREIGN_DZ_CONTAINER_ZIP;</span>
          <span class="s1">}</span>
          <span class="s2">if </span><span class="s1">(</span><span class="s2">!</span>image<span class="s1">.</span><span class="s5">has_alpha</span><span class="s1">()) {</span>
            baton<span class="s1">-&gt;</span>tileBackground<span class="s1">.</span><span class="s5">pop_back</span><span class="s1">();</span>
          <span class="s1">}</span>
          <span class="s1">image </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">StaySequential</span><span class="s1">(image, </span>baton<span class="s1">-&gt;</span>tileAngle <span class="s2">!= </span><span class="s7">0</span><span class="s1">);</span>
          vips<span class="s1">::VOption </span><span class="s2">*</span><span class="s1">options </span><span class="s2">= </span><span class="s5">BuildOptionsDZ</span><span class="s1">(baton);</span>
          image<span class="s1">.</span><span class="s5">dzsave</span><span class="s1">(</span><span class="s2">const_cast&lt;char*&gt;</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>fileOut<span class="s1">.</span><span class="s5">data</span><span class="s1">()), options);</span>
          baton<span class="s1">-&gt;</span>formatOut <span class="s2">= </span><span class="s3">&quot;dz&quot;</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>formatOut <span class="s2">== </span><span class="s3">&quot;v&quot; </span><span class="s2">|| </span><span class="s1">(mightMatchInput </span><span class="s2">&amp;&amp; </span><span class="s1">isV) </span><span class="s2">||</span>
          <span class="s1">(willMatchInput </span><span class="s2">&amp;&amp; </span><span class="s1">inputImageType </span><span class="s2">== </span>sharp<span class="s1">::</span>ImageType<span class="s1">::VIPS)) {</span>
          <span class="s0">// Write V to file</span>
          image<span class="s1">.</span><span class="s5">vipssave</span><span class="s1">(</span><span class="s2">const_cast&lt;char*&gt;</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>fileOut<span class="s1">.</span><span class="s5">data</span><span class="s1">()), </span>VImage<span class="s1">::</span><span class="s5">option</span><span class="s1">()</span>
            <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;keep&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>keepMetadata<span class="s1">));</span>
          baton<span class="s1">-&gt;</span>formatOut <span class="s2">= </span><span class="s3">&quot;v&quot;</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
          <span class="s0">// Unsupported output format</span>
          <span class="s1">(</span>baton<span class="s1">-&gt;</span>err<span class="s1">).</span><span class="s5">append</span><span class="s1">(</span><span class="s3">&quot;Unsupported output format &quot; </span><span class="s2">+ </span>baton<span class="s1">-&gt;</span>fileOut<span class="s1">);</span>
          <span class="s2">return </span><span class="s5">Error</span><span class="s1">();</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(</span>vips<span class="s1">::VError </span><span class="s2">const &amp;</span><span class="s1">err) {</span>
      <span class="s2">char const *</span><span class="s1">what </span><span class="s2">= </span>err<span class="s1">.</span><span class="s5">what</span><span class="s1">();</span>
      <span class="s2">if </span><span class="s1">(what </span><span class="s2">&amp;&amp; </span>what<span class="s1">[</span><span class="s7">0</span><span class="s1">]) {</span>
        <span class="s1">(</span>baton<span class="s1">-&gt;</span>err<span class="s1">).</span><span class="s5">append</span><span class="s1">(what);</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">(</span>baton<span class="s1">-&gt;</span>err<span class="s1">).</span><span class="s5">append</span><span class="s1">(</span><span class="s3">&quot;Unknown error&quot;</span><span class="s1">);</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">// Clean up libvips' per-request data and threads</span>
    <span class="s5">vips_error_clear</span><span class="s1">();</span>
    <span class="s5">vips_thread_shutdown</span><span class="s1">();</span>
  <span class="s1">}</span>

  <span class="s1">void </span><span class="s5">OnOK</span><span class="s1">() {</span>
    Napi<span class="s1">::Env env </span><span class="s2">= </span><span class="s5">Env</span><span class="s1">();</span>
    Napi<span class="s1">::HandleScope </span><span class="s5">scope</span><span class="s1">(env);</span>

    <span class="s0">// Handle warnings</span>
    std<span class="s1">::string warning </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">VipsWarningPop</span><span class="s1">();</span>
    <span class="s2">while </span><span class="s1">(</span><span class="s2">!</span>warning<span class="s1">.</span><span class="s5">empty</span><span class="s1">()) {</span>
      debuglog<span class="s1">.</span><span class="s5">Call</span><span class="s1">(</span><span class="s5">Receiver</span><span class="s1">().</span><span class="s5">Value</span><span class="s1">(), { </span>Napi<span class="s1">::</span>String<span class="s1">::</span><span class="s5">New</span><span class="s1">(env, warning) });</span>
      <span class="s1">warning </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">VipsWarningPop</span><span class="s1">();</span>
    <span class="s1">}</span>

    <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>err<span class="s1">.</span><span class="s5">empty</span><span class="s1">()) {</span>
      <span class="s2">int </span><span class="s1">width </span><span class="s2">= </span>baton<span class="s1">-&gt;</span>width<span class="s1">;</span>
      <span class="s2">int </span><span class="s1">height </span><span class="s2">= </span>baton<span class="s1">-&gt;</span>height<span class="s1">;</span>
      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>topOffsetPre <span class="s2">!= -</span><span class="s7">1 </span><span class="s2">&amp;&amp; </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>width <span class="s2">== -</span><span class="s7">1 </span><span class="s2">|| </span>baton<span class="s1">-&gt;</span>height <span class="s2">== -</span><span class="s7">1</span><span class="s1">)) {</span>
        <span class="s1">width </span><span class="s2">= </span>baton<span class="s1">-&gt;</span>widthPre<span class="s1">;</span>
        <span class="s1">height </span><span class="s2">= </span>baton<span class="s1">-&gt;</span>heightPre<span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>topOffsetPost <span class="s2">!= -</span><span class="s7">1</span><span class="s1">) {</span>
        <span class="s1">width </span><span class="s2">= </span>baton<span class="s1">-&gt;</span>widthPost<span class="s1">;</span>
        <span class="s1">height </span><span class="s2">= </span>baton<span class="s1">-&gt;</span>heightPost<span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s0">// Info Object</span>
      Napi<span class="s1">::Object info </span><span class="s2">= </span>Napi<span class="s1">::</span>Object<span class="s1">::</span><span class="s5">New</span><span class="s1">(env);</span>
      info<span class="s1">.</span><span class="s5">Set</span><span class="s1">(</span><span class="s3">&quot;format&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>formatOut<span class="s1">);</span>
      info<span class="s1">.</span><span class="s5">Set</span><span class="s1">(</span><span class="s3">&quot;width&quot;</span><span class="s1">, </span><span class="s2">static_cast&lt;uint32_t&gt;</span><span class="s1">(width));</span>
      info<span class="s1">.</span><span class="s5">Set</span><span class="s1">(</span><span class="s3">&quot;height&quot;</span><span class="s1">, </span><span class="s2">static_cast&lt;uint32_t&gt;</span><span class="s1">(height));</span>
      info<span class="s1">.</span><span class="s5">Set</span><span class="s1">(</span><span class="s3">&quot;channels&quot;</span><span class="s1">, </span><span class="s2">static_cast&lt;uint32_t&gt;</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>channels<span class="s1">));</span>
      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>formatOut <span class="s2">== </span><span class="s3">&quot;raw&quot;</span><span class="s1">) {</span>
        info<span class="s1">.</span><span class="s5">Set</span><span class="s1">(</span><span class="s3">&quot;depth&quot;</span><span class="s1">, </span><span class="s5">vips_enum_nick</span><span class="s1">(VIPS_TYPE_BAND_FORMAT, </span>baton<span class="s1">-&gt;</span>rawDepth<span class="s1">));</span>
      <span class="s1">}</span>
      info<span class="s1">.</span><span class="s5">Set</span><span class="s1">(</span><span class="s3">&quot;premultiplied&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>premultiplied<span class="s1">);</span>
      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>hasCropOffset<span class="s1">) {</span>
        info<span class="s1">.</span><span class="s5">Set</span><span class="s1">(</span><span class="s3">&quot;cropOffsetLeft&quot;</span><span class="s1">, </span><span class="s2">static_cast&lt;int32_t&gt;</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>cropOffsetLeft<span class="s1">));</span>
        info<span class="s1">.</span><span class="s5">Set</span><span class="s1">(</span><span class="s3">&quot;cropOffsetTop&quot;</span><span class="s1">, </span><span class="s2">static_cast&lt;int32_t&gt;</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>cropOffsetTop<span class="s1">));</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>hasAttentionCenter<span class="s1">) {</span>
        info<span class="s1">.</span><span class="s5">Set</span><span class="s1">(</span><span class="s3">&quot;attentionX&quot;</span><span class="s1">, </span><span class="s2">static_cast&lt;int32_t&gt;</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>attentionX<span class="s1">));</span>
        info<span class="s1">.</span><span class="s5">Set</span><span class="s1">(</span><span class="s3">&quot;attentionY&quot;</span><span class="s1">, </span><span class="s2">static_cast&lt;int32_t&gt;</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>attentionY<span class="s1">));</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>trimThreshold <span class="s2">&gt;= </span><span class="s7">0.0</span><span class="s1">) {</span>
        info<span class="s1">.</span><span class="s5">Set</span><span class="s1">(</span><span class="s3">&quot;trimOffsetLeft&quot;</span><span class="s1">, </span><span class="s2">static_cast&lt;int32_t&gt;</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>trimOffsetLeft<span class="s1">));</span>
        info<span class="s1">.</span><span class="s5">Set</span><span class="s1">(</span><span class="s3">&quot;trimOffsetTop&quot;</span><span class="s1">, </span><span class="s2">static_cast&lt;int32_t&gt;</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>trimOffsetTop<span class="s1">));</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>input<span class="s1">-&gt;</span>textAutofitDpi<span class="s1">) {</span>
        info<span class="s1">.</span><span class="s5">Set</span><span class="s1">(</span><span class="s3">&quot;textAutofitDpi&quot;</span><span class="s1">, </span><span class="s2">static_cast&lt;uint32_t&gt;</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>input<span class="s1">-&gt;</span>textAutofitDpi<span class="s1">));</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>pageHeightOut<span class="s1">) {</span>
        info<span class="s1">.</span><span class="s5">Set</span><span class="s1">(</span><span class="s3">&quot;pageHeight&quot;</span><span class="s1">, </span><span class="s2">static_cast&lt;int32_t&gt;</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>pageHeightOut<span class="s1">));</span>
        info<span class="s1">.</span><span class="s5">Set</span><span class="s1">(</span><span class="s3">&quot;pages&quot;</span><span class="s1">, </span><span class="s2">static_cast&lt;int32_t&gt;</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>pagesOut<span class="s1">));</span>
      <span class="s1">}</span>

      <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>bufferOutLength <span class="s2">&gt; </span><span class="s7">0</span><span class="s1">) {</span>
        <span class="s0">// Add buffer size to info</span>
        info<span class="s1">.</span><span class="s5">Set</span><span class="s1">(</span><span class="s3">&quot;size&quot;</span><span class="s1">, </span><span class="s2">static_cast&lt;uint32_t&gt;</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>bufferOutLength<span class="s1">));</span>
        <span class="s0">// Pass ownership of output data to Buffer instance</span>
        Napi<span class="s1">::Buffer</span><span class="s2">&lt;char&gt; </span><span class="s1">data </span><span class="s2">= </span>Napi<span class="s1">::</span>Buffer<span class="s1">&lt;char&gt;::</span><span class="s5">NewOrCopy</span><span class="s1">(env, </span><span class="s2">static_cast&lt;char*&gt;</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>bufferOut<span class="s1">),</span>
          baton<span class="s1">-&gt;</span>bufferOutLength<span class="s1">, </span>sharp<span class="s1">::FreeCallback);</span>
        <span class="s5">Callback</span><span class="s1">().</span><span class="s5">Call</span><span class="s1">(</span><span class="s5">Receiver</span><span class="s1">().</span><span class="s5">Value</span><span class="s1">(), { </span>env<span class="s1">.</span><span class="s5">Null</span><span class="s1">(), data, info });</span>
      <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s0">// Add file size to info</span>
        <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>formatOut <span class="s2">!= </span><span class="s3">&quot;dz&quot; </span><span class="s2">|| </span>sharp<span class="s1">::</span><span class="s5">IsDzZip</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>fileOut<span class="s1">)) {</span>
          <span class="s2">try </span><span class="s1">{</span>
            <span class="s2">uint32_t const </span><span class="s1">size </span><span class="s2">= static_cast&lt;uint32_t&gt;</span><span class="s1">(</span>
              std<span class="s1">::</span>filesystem<span class="s1">::</span><span class="s5">file_size</span><span class="s1">(</span>std<span class="s1">::</span>filesystem<span class="s1">::</span><span class="s5">u8path</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>fileOut<span class="s1">)));</span>
            info<span class="s1">.</span><span class="s5">Set</span><span class="s1">(</span><span class="s3">&quot;size&quot;</span><span class="s1">, size);</span>
          <span class="s1">} </span><span class="s2">catch </span><span class="s1">(...) {}</span>
        <span class="s1">}</span>
        <span class="s5">Callback</span><span class="s1">().</span><span class="s5">Call</span><span class="s1">(</span><span class="s5">Receiver</span><span class="s1">().</span><span class="s5">Value</span><span class="s1">(), { </span>env<span class="s1">.</span><span class="s5">Null</span><span class="s1">(), info });</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s5">Callback</span><span class="s1">().</span><span class="s5">Call</span><span class="s1">(</span><span class="s5">Receiver</span><span class="s1">().</span><span class="s5">Value</span><span class="s1">(), { </span>Napi<span class="s1">::</span>Error<span class="s1">::</span><span class="s5">New</span><span class="s1">(env, </span>sharp<span class="s1">::</span><span class="s5">TrimEnd</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>err<span class="s1">)).</span><span class="s5">Value</span><span class="s1">() });</span>
    <span class="s1">}</span>

    <span class="s0">// Delete baton</span>
    <span class="s2">delete </span>baton<span class="s1">-&gt;</span>input<span class="s1">;</span>
    <span class="s2">delete </span>baton<span class="s1">-&gt;</span>boolean<span class="s1">;</span>
    <span class="s2">for </span><span class="s1">(Composite </span><span class="s2">*</span><span class="s1">composite : </span>baton<span class="s1">-&gt;</span>composite<span class="s1">) {</span>
      <span class="s2">delete </span>composite<span class="s1">-&gt;</span>input<span class="s1">;</span>
      <span class="s2">delete </span><span class="s1">composite;</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span>sharp<span class="s1">::InputDescriptor </span><span class="s2">*</span><span class="s1">input : </span>baton<span class="s1">-&gt;</span>joinChannelIn<span class="s1">) {</span>
      <span class="s2">delete </span><span class="s1">input;</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span>sharp<span class="s1">::InputDescriptor </span><span class="s2">*</span><span class="s1">input : </span>baton<span class="s1">-&gt;</span>join<span class="s1">) {</span>
      <span class="s2">delete </span><span class="s1">input;</span>
    <span class="s1">}</span>
    <span class="s2">delete </span><span class="s1">baton;</span>

    <span class="s0">// Decrement processing task counter</span>
    sharp<span class="s1">::counterProcess</span><span class="s2">--</span><span class="s1">;</span>
    Napi<span class="s1">::Number queueLength </span><span class="s2">= </span>Napi<span class="s1">::</span>Number<span class="s1">::</span><span class="s5">New</span><span class="s1">(env, </span><span class="s2">static_cast&lt;int&gt;</span><span class="s1">(</span>sharp<span class="s1">::counterQueue));</span>
    queueListener<span class="s1">.</span><span class="s5">Call</span><span class="s1">(</span><span class="s5">Receiver</span><span class="s1">().</span><span class="s5">Value</span><span class="s1">(), { queueLength });</span>
  <span class="s1">}</span>

 <span class="s2">private:</span>
  <span class="s1">PipelineBaton </span><span class="s2">*</span><span class="s1">baton;</span>
  Napi<span class="s1">::FunctionReference debuglog;</span>
  Napi<span class="s1">::FunctionReference queueListener;</span>

  <span class="s1">void </span><span class="s5">MultiPageUnsupported</span><span class="s1">(</span><span class="s2">int const </span>pages<span class="s1">, </span>std<span class="s1">::</span>string op<span class="s1">) {</span>
    <span class="s2">if </span><span class="s1">(pages </span><span class="s2">&gt; </span><span class="s7">1</span><span class="s1">) {</span>
      <span class="s2">throw </span>vips<span class="s1">::</span><span class="s5">VError</span><span class="s1">(op </span><span class="s2">+ </span><span class="s3">&quot; is not supported for multi-page images&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">/*</span>
    <span class="s0">Calculate the angle of rotation and need-to-flip for the given Exif orientation 
    By default, returns zero, i.e. no rotation. 
  */</span>
  std<span class="s1">::tuple</span><span class="s2">&lt;</span><span class="s1">VipsAngle, </span><span class="s2">bool&gt;</span>
  <span class="s5">CalculateExifRotationAndFlop</span><span class="s1">(</span><span class="s2">int const </span>exifOrientation<span class="s1">) {</span>
    <span class="s1">VipsAngle rotate </span><span class="s2">= </span><span class="s1">VIPS_ANGLE_D0;</span>
    <span class="s2">bool </span><span class="s1">flop </span><span class="s2">= </span><span class="s6">false</span><span class="s1">;</span>
    <span class="s2">switch </span><span class="s1">(exifOrientation) {</span>
      <span class="s2">case </span><span class="s7">6</span><span class="s1">: rotate </span><span class="s2">= </span><span class="s1">VIPS_ANGLE_D90; </span><span class="s2">break</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s7">3</span><span class="s1">: rotate </span><span class="s2">= </span><span class="s1">VIPS_ANGLE_D180; </span><span class="s2">break</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s7">8</span><span class="s1">: rotate </span><span class="s2">= </span><span class="s1">VIPS_ANGLE_D270; </span><span class="s2">break</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s7">2</span><span class="s1">: flop </span><span class="s2">= </span><span class="s6">true</span><span class="s1">; </span><span class="s2">break</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s7">7</span><span class="s1">: flop </span><span class="s2">= </span><span class="s6">true</span><span class="s1">; rotate </span><span class="s2">= </span><span class="s1">VIPS_ANGLE_D270; </span><span class="s2">break</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s7">4</span><span class="s1">: flop </span><span class="s2">= </span><span class="s6">true</span><span class="s1">; rotate </span><span class="s2">= </span><span class="s1">VIPS_ANGLE_D180; </span><span class="s2">break</span><span class="s1">;</span>
      <span class="s2">case </span><span class="s7">5</span><span class="s1">: flop </span><span class="s2">= </span><span class="s6">true</span><span class="s1">; rotate </span><span class="s2">= </span><span class="s1">VIPS_ANGLE_D90; </span><span class="s2">break</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span>std<span class="s1">::</span><span class="s5">make_tuple</span><span class="s1">(rotate, flop);</span>
  <span class="s1">}</span>

  <span class="s0">/*</span>
    <span class="s0">Calculate the rotation for the given angle. 
    Supports any positive or negative angle that is a multiple of 90. 
  */</span>
  <span class="s1">VipsAngle 
  </span><span class="s5">CalculateAngleRotation</span><span class="s1">(</span><span class="s2">int </span>angle<span class="s1">) {</span>
    <span class="s1">angle </span><span class="s2">= </span><span class="s1">angle </span><span class="s2">% </span><span class="s7">360</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(angle </span><span class="s2">&lt; </span><span class="s7">0</span><span class="s1">)</span>
      <span class="s1">angle </span><span class="s2">= </span><span class="s7">360 </span><span class="s2">+ </span><span class="s1">angle;</span>
    <span class="s2">switch </span><span class="s1">(angle) {</span>
      <span class="s2">case </span><span class="s7">90</span><span class="s1">: </span><span class="s2">return </span><span class="s1">VIPS_ANGLE_D90;</span>
      <span class="s2">case </span><span class="s7">180</span><span class="s1">: </span><span class="s2">return </span><span class="s1">VIPS_ANGLE_D180;</span>
      <span class="s2">case </span><span class="s7">270</span><span class="s1">: </span><span class="s2">return </span><span class="s1">VIPS_ANGLE_D270;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">VIPS_ANGLE_D0;</span>
  <span class="s1">}</span>

  <span class="s0">/*</span>
    <span class="s0">Assemble the suffix argument to dzsave, which is the format (by extname) 
    alongside comma-separated arguments to the corresponding `formatsave` vips 
    action. 
  */</span>
  std<span class="s1">::string 
  </span><span class="s5">AssembleSuffixString</span><span class="s1">(</span>std<span class="s1">::</span>string extname<span class="s1">, </span>std<span class="s1">::</span>vector<span class="s1">&lt;</span>std<span class="s1">::</span>pair<span class="s1">&lt;</span>std<span class="s1">::</span>string<span class="s1">, </span>std<span class="s1">::</span>string<span class="s1">&gt;&gt; </span>options<span class="s1">) {</span>
    std<span class="s1">::string argument;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">auto const &amp;</span><span class="s1">option : options) {</span>
      <span class="s2">if </span><span class="s1">(</span><span class="s2">!</span>argument<span class="s1">.</span><span class="s5">empty</span><span class="s1">()) {</span>
        <span class="s1">argument </span><span class="s2">+= </span><span class="s3">&quot;,&quot;</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s1">argument </span><span class="s2">+= </span>option<span class="s1">.</span>first <span class="s2">+ </span><span class="s3">&quot;=&quot; </span><span class="s2">+ </span>option<span class="s1">.</span>second<span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">extname </span><span class="s2">+ </span><span class="s3">&quot;[&quot; </span><span class="s2">+ </span><span class="s1">argument </span><span class="s2">+ </span><span class="s3">&quot;]&quot;</span><span class="s1">;</span>
  <span class="s1">}</span>

  <span class="s0">/*</span>
    <span class="s0">Build VOption for dzsave 
  */</span>
  vips<span class="s1">::VOption</span><span class="s2">*</span>
  <span class="s5">BuildOptionsDZ</span><span class="s1">(</span>PipelineBaton <span class="s2">*</span>baton<span class="s1">) {</span>
    <span class="s0">// Forward format options through suffix</span>
    std<span class="s1">::string suffix;</span>
    <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>tileFormat <span class="s2">== </span><span class="s3">&quot;png&quot;</span><span class="s1">) {</span>
      std<span class="s1">::vector</span><span class="s2">&lt;</span>std<span class="s1">::pair</span><span class="s2">&lt;</span>std<span class="s1">::string, </span>std<span class="s1">::string</span><span class="s2">&gt;&gt; </span><span class="s1">options {</span>
        <span class="s1">{</span><span class="s3">&quot;interlace&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>pngProgressive <span class="s2">? </span><span class="s3">&quot;true&quot; </span><span class="s2">: </span><span class="s3">&quot;false&quot;</span><span class="s1">},</span>
        <span class="s1">{</span><span class="s3">&quot;compression&quot;</span><span class="s1">, </span>std<span class="s1">::</span><span class="s5">to_string</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>pngCompressionLevel<span class="s1">)},</span>
        <span class="s1">{</span><span class="s3">&quot;filter&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>pngAdaptiveFiltering <span class="s2">? </span><span class="s3">&quot;all&quot; </span><span class="s2">: </span><span class="s3">&quot;none&quot;</span><span class="s1">}</span>
      <span class="s1">};</span>
      <span class="s1">suffix </span><span class="s2">= </span><span class="s5">AssembleSuffixString</span><span class="s1">(</span><span class="s3">&quot;.png&quot;</span><span class="s1">, options);</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>tileFormat <span class="s2">== </span><span class="s3">&quot;webp&quot;</span><span class="s1">) {</span>
      std<span class="s1">::vector</span><span class="s2">&lt;</span>std<span class="s1">::pair</span><span class="s2">&lt;</span>std<span class="s1">::string, </span>std<span class="s1">::string</span><span class="s2">&gt;&gt; </span><span class="s1">options {</span>
        <span class="s1">{</span><span class="s3">&quot;Q&quot;</span><span class="s1">, </span>std<span class="s1">::</span><span class="s5">to_string</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>webpQuality<span class="s1">)},</span>
        <span class="s1">{</span><span class="s3">&quot;alpha_q&quot;</span><span class="s1">, </span>std<span class="s1">::</span><span class="s5">to_string</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>webpAlphaQuality<span class="s1">)},</span>
        <span class="s1">{</span><span class="s3">&quot;lossless&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>webpLossless <span class="s2">? </span><span class="s3">&quot;true&quot; </span><span class="s2">: </span><span class="s3">&quot;false&quot;</span><span class="s1">},</span>
        <span class="s1">{</span><span class="s3">&quot;near_lossless&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>webpNearLossless <span class="s2">? </span><span class="s3">&quot;true&quot; </span><span class="s2">: </span><span class="s3">&quot;false&quot;</span><span class="s1">},</span>
        <span class="s1">{</span><span class="s3">&quot;smart_subsample&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>webpSmartSubsample <span class="s2">? </span><span class="s3">&quot;true&quot; </span><span class="s2">: </span><span class="s3">&quot;false&quot;</span><span class="s1">},</span>
        <span class="s1">{</span><span class="s3">&quot;smart_deblock&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>webpSmartDeblock <span class="s2">? </span><span class="s3">&quot;true&quot; </span><span class="s2">: </span><span class="s3">&quot;false&quot;</span><span class="s1">},</span>
        <span class="s1">{</span><span class="s3">&quot;preset&quot;</span><span class="s1">, </span><span class="s5">vips_enum_nick</span><span class="s1">(VIPS_TYPE_FOREIGN_WEBP_PRESET, </span>baton<span class="s1">-&gt;</span>webpPreset<span class="s1">)},</span>
        <span class="s1">{</span><span class="s3">&quot;min_size&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>webpMinSize <span class="s2">? </span><span class="s3">&quot;true&quot; </span><span class="s2">: </span><span class="s3">&quot;false&quot;</span><span class="s1">},</span>
        <span class="s1">{</span><span class="s3">&quot;mixed&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>webpMixed <span class="s2">? </span><span class="s3">&quot;true&quot; </span><span class="s2">: </span><span class="s3">&quot;false&quot;</span><span class="s1">},</span>
        <span class="s1">{</span><span class="s3">&quot;effort&quot;</span><span class="s1">, </span>std<span class="s1">::</span><span class="s5">to_string</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>webpEffort<span class="s1">)}</span>
      <span class="s1">};</span>
      <span class="s1">suffix </span><span class="s2">= </span><span class="s5">AssembleSuffixString</span><span class="s1">(</span><span class="s3">&quot;.webp&quot;</span><span class="s1">, options);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      std<span class="s1">::vector</span><span class="s2">&lt;</span>std<span class="s1">::pair</span><span class="s2">&lt;</span>std<span class="s1">::string, </span>std<span class="s1">::string</span><span class="s2">&gt;&gt; </span><span class="s1">options {</span>
        <span class="s1">{</span><span class="s3">&quot;Q&quot;</span><span class="s1">, </span>std<span class="s1">::</span><span class="s5">to_string</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>jpegQuality<span class="s1">)},</span>
        <span class="s1">{</span><span class="s3">&quot;interlace&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>jpegProgressive <span class="s2">? </span><span class="s3">&quot;true&quot; </span><span class="s2">: </span><span class="s3">&quot;false&quot;</span><span class="s1">},</span>
        <span class="s1">{</span><span class="s3">&quot;subsample_mode&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>jpegChromaSubsampling <span class="s2">== </span><span class="s3">&quot;4:4:4&quot; </span><span class="s2">? </span><span class="s3">&quot;off&quot; </span><span class="s2">: </span><span class="s3">&quot;on&quot;</span><span class="s1">},</span>
        <span class="s1">{</span><span class="s3">&quot;trellis_quant&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>jpegTrellisQuantisation <span class="s2">? </span><span class="s3">&quot;true&quot; </span><span class="s2">: </span><span class="s3">&quot;false&quot;</span><span class="s1">},</span>
        <span class="s1">{</span><span class="s3">&quot;quant_table&quot;</span><span class="s1">, </span>std<span class="s1">::</span><span class="s5">to_string</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>jpegQuantisationTable<span class="s1">)},</span>
        <span class="s1">{</span><span class="s3">&quot;overshoot_deringing&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>jpegOvershootDeringing <span class="s2">? </span><span class="s3">&quot;true&quot;</span><span class="s2">: </span><span class="s3">&quot;false&quot;</span><span class="s1">},</span>
        <span class="s1">{</span><span class="s3">&quot;optimize_scans&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>jpegOptimiseScans <span class="s2">? </span><span class="s3">&quot;true&quot;</span><span class="s2">: </span><span class="s3">&quot;false&quot;</span><span class="s1">},</span>
        <span class="s1">{</span><span class="s3">&quot;optimize_coding&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>jpegOptimiseCoding <span class="s2">? </span><span class="s3">&quot;true&quot;</span><span class="s2">: </span><span class="s3">&quot;false&quot;</span><span class="s1">}</span>
      <span class="s1">};</span>
      std<span class="s1">::string extname </span><span class="s2">= </span>baton<span class="s1">-&gt;</span>tileLayout <span class="s2">== </span><span class="s1">VIPS_FOREIGN_DZ_LAYOUT_DZ </span><span class="s2">? </span><span class="s3">&quot;.jpeg&quot; </span><span class="s2">: </span><span class="s3">&quot;.jpg&quot;</span><span class="s1">;</span>
      <span class="s1">suffix </span><span class="s2">= </span><span class="s5">AssembleSuffixString</span><span class="s1">(extname, options);</span>
    <span class="s1">}</span>
    vips<span class="s1">::VOption </span><span class="s2">*</span><span class="s1">options </span><span class="s2">= </span>VImage<span class="s1">::</span><span class="s5">option</span><span class="s1">()</span>
      <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;keep&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>keepMetadata<span class="s1">)</span>
      <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;tile_size&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>tileSize<span class="s1">)</span>
      <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;overlap&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>tileOverlap<span class="s1">)</span>
      <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;container&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>tileContainer<span class="s1">)</span>
      <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;layout&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>tileLayout<span class="s1">)</span>
      <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;suffix&quot;</span><span class="s1">, </span><span class="s2">const_cast&lt;char*&gt;</span><span class="s1">(</span>suffix<span class="s1">.</span><span class="s5">data</span><span class="s1">()))</span>
      <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;angle&quot;</span><span class="s1">, </span><span class="s5">CalculateAngleRotation</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>tileAngle<span class="s1">))</span>
      <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;background&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>tileBackground<span class="s1">)</span>
      <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;centre&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>tileCentre<span class="s1">)</span>
      <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;id&quot;</span><span class="s1">, </span><span class="s2">const_cast&lt;char*&gt;</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>tileId<span class="s1">.</span><span class="s5">data</span><span class="s1">()))</span>
      <span class="s2">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;skip_blanks&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>tileSkipBlanks<span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>tileDepth <span class="s2">&lt; </span><span class="s1">VIPS_FOREIGN_DZ_DEPTH_LAST) {</span>
      options<span class="s1">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;depth&quot;</span><span class="s1">, </span>baton<span class="s1">-&gt;</span>tileDepth<span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">!</span>baton<span class="s1">-&gt;</span>tileBasename<span class="s1">.</span><span class="s5">empty</span><span class="s1">()) {</span>
      options<span class="s1">-&gt;</span><span class="s5">set</span><span class="s1">(</span><span class="s3">&quot;basename&quot;</span><span class="s1">, </span><span class="s2">const_cast&lt;char*&gt;</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>tileBasename<span class="s1">.</span><span class="s5">data</span><span class="s1">()));</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">options;</span>
  <span class="s1">}</span>

  <span class="s0">/*</span>
    <span class="s0">Clear all thread-local data. 
  */</span>
  <span class="s1">void </span><span class="s5">Error</span><span class="s1">() {</span>
    <span class="s0">// Clean up libvips' per-request data and threads</span>
    <span class="s5">vips_error_clear</span><span class="s1">();</span>
    <span class="s5">vips_thread_shutdown</span><span class="s1">();</span>
  <span class="s1">}</span>
<span class="s1">};</span>

<span class="s0">/*</span>
  <span class="s0">pipeline(options, output, callback) 
*/</span>
Napi<span class="s1">::Value </span><span class="s5">pipeline</span><span class="s1">(</span><span class="s2">const </span>Napi<span class="s1">::</span>CallbackInfo<span class="s2">&amp; </span>info<span class="s1">) {</span>
  <span class="s0">// V8 objects are converted to non-V8 types held in the baton struct</span>
  <span class="s1">PipelineBaton </span><span class="s2">*</span><span class="s1">baton </span><span class="s2">= new </span><span class="s1">PipelineBaton;</span>
  Napi<span class="s1">::Object options </span><span class="s2">= </span>info<span class="s1">[</span><span class="s2">size_t</span><span class="s1">(</span><span class="s7">0</span><span class="s1">)].</span>As<span class="s2">&lt;</span>Napi<span class="s1">::Object</span><span class="s2">&gt;</span><span class="s1">();</span>

  <span class="s0">// Input</span>
  baton<span class="s1">-&gt;</span>input <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">CreateInputDescriptor</span><span class="s1">(</span>options<span class="s1">.</span><span class="s5">Get</span><span class="s1">(</span><span class="s3">&quot;input&quot;</span><span class="s1">).</span>As<span class="s2">&lt;</span>Napi<span class="s1">::Object</span><span class="s2">&gt;</span><span class="s1">());</span>
  <span class="s0">// Join images together</span>
  <span class="s2">if </span><span class="s1">(</span>sharp<span class="s1">::</span><span class="s5">HasAttr</span><span class="s1">(options, </span><span class="s3">&quot;join&quot;</span><span class="s1">)) {</span>
    Napi<span class="s1">::Array join </span><span class="s2">= </span>options<span class="s1">.</span><span class="s5">Get</span><span class="s1">(</span><span class="s3">&quot;join&quot;</span><span class="s1">).</span>As<span class="s2">&lt;</span>Napi<span class="s1">::Array</span><span class="s2">&gt;</span><span class="s1">();</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">unsigned int </span><span class="s1">i </span><span class="s2">= </span><span class="s7">0</span><span class="s1">; i </span><span class="s2">&lt; </span>join<span class="s1">.</span><span class="s5">Length</span><span class="s1">(); i</span><span class="s2">++</span><span class="s1">) {</span>
      baton<span class="s1">-&gt;</span>join<span class="s1">.</span><span class="s5">push_back</span><span class="s1">(</span>
        sharp<span class="s1">::</span><span class="s5">CreateInputDescriptor</span><span class="s1">(</span>join<span class="s1">.</span><span class="s5">Get</span><span class="s1">(i).</span>As<span class="s2">&lt;</span>Napi<span class="s1">::Object</span><span class="s2">&gt;</span><span class="s1">()));</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">// Extract image options</span>
  baton<span class="s1">-&gt;</span>topOffsetPre <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsInt32</span><span class="s1">(options, </span><span class="s3">&quot;topOffsetPre&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>leftOffsetPre <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsInt32</span><span class="s1">(options, </span><span class="s3">&quot;leftOffsetPre&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>widthPre <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsInt32</span><span class="s1">(options, </span><span class="s3">&quot;widthPre&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>heightPre <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsInt32</span><span class="s1">(options, </span><span class="s3">&quot;heightPre&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>topOffsetPost <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsInt32</span><span class="s1">(options, </span><span class="s3">&quot;topOffsetPost&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>leftOffsetPost <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsInt32</span><span class="s1">(options, </span><span class="s3">&quot;leftOffsetPost&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>widthPost <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsInt32</span><span class="s1">(options, </span><span class="s3">&quot;widthPost&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>heightPost <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsInt32</span><span class="s1">(options, </span><span class="s3">&quot;heightPost&quot;</span><span class="s1">);</span>
  <span class="s0">// Output image dimensions</span>
  baton<span class="s1">-&gt;</span>width <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsInt32</span><span class="s1">(options, </span><span class="s3">&quot;width&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>height <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsInt32</span><span class="s1">(options, </span><span class="s3">&quot;height&quot;</span><span class="s1">);</span>
  <span class="s0">// Canvas option</span>
  std<span class="s1">::string canvas </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsStr</span><span class="s1">(options, </span><span class="s3">&quot;canvas&quot;</span><span class="s1">);</span>
  <span class="s2">if </span><span class="s1">(canvas </span><span class="s2">== </span><span class="s3">&quot;crop&quot;</span><span class="s1">) {</span>
    baton<span class="s1">-&gt;</span>canvas <span class="s2">= </span>sharp<span class="s1">::</span>Canvas<span class="s1">::CROP;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(canvas </span><span class="s2">== </span><span class="s3">&quot;embed&quot;</span><span class="s1">) {</span>
    baton<span class="s1">-&gt;</span>canvas <span class="s2">= </span>sharp<span class="s1">::</span>Canvas<span class="s1">::EMBED;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(canvas </span><span class="s2">== </span><span class="s3">&quot;max&quot;</span><span class="s1">) {</span>
    baton<span class="s1">-&gt;</span>canvas <span class="s2">= </span>sharp<span class="s1">::</span>Canvas<span class="s1">::MAX;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(canvas </span><span class="s2">== </span><span class="s3">&quot;min&quot;</span><span class="s1">) {</span>
    baton<span class="s1">-&gt;</span>canvas <span class="s2">= </span>sharp<span class="s1">::</span>Canvas<span class="s1">::MIN;</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(canvas </span><span class="s2">== </span><span class="s3">&quot;ignore_aspect&quot;</span><span class="s1">) {</span>
    baton<span class="s1">-&gt;</span>canvas <span class="s2">= </span>sharp<span class="s1">::</span>Canvas<span class="s1">::IGNORE_ASPECT;</span>
  <span class="s1">}</span>
  <span class="s0">// Composite</span>
  Napi<span class="s1">::Array compositeArray </span><span class="s2">= </span>options<span class="s1">.</span><span class="s5">Get</span><span class="s1">(</span><span class="s3">&quot;composite&quot;</span><span class="s1">).</span>As<span class="s2">&lt;</span>Napi<span class="s1">::Array</span><span class="s2">&gt;</span><span class="s1">();</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">unsigned int </span><span class="s1">i </span><span class="s2">= </span><span class="s7">0</span><span class="s1">; i </span><span class="s2">&lt; </span>compositeArray<span class="s1">.</span><span class="s5">Length</span><span class="s1">(); i</span><span class="s2">++</span><span class="s1">) {</span>
    Napi<span class="s1">::Object compositeObject </span><span class="s2">= </span>compositeArray<span class="s1">.</span><span class="s5">Get</span><span class="s1">(i).</span>As<span class="s2">&lt;</span>Napi<span class="s1">::Object</span><span class="s2">&gt;</span><span class="s1">();</span>
    <span class="s1">Composite </span><span class="s2">*</span><span class="s1">composite </span><span class="s2">= new </span><span class="s1">Composite;</span>
    composite<span class="s1">-&gt;</span>input <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">CreateInputDescriptor</span><span class="s1">(</span>compositeObject<span class="s1">.</span><span class="s5">Get</span><span class="s1">(</span><span class="s3">&quot;input&quot;</span><span class="s1">).</span>As<span class="s2">&lt;</span>Napi<span class="s1">::Object</span><span class="s2">&gt;</span><span class="s1">());</span>
    composite<span class="s1">-&gt;</span>mode <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsEnum</span><span class="s1">&lt;VipsBlendMode&gt;(compositeObject, </span><span class="s3">&quot;blend&quot;</span><span class="s1">, VIPS_TYPE_BLEND_MODE);</span>
    composite<span class="s1">-&gt;</span>gravity <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsUint32</span><span class="s1">(compositeObject, </span><span class="s3">&quot;gravity&quot;</span><span class="s1">);</span>
    composite<span class="s1">-&gt;</span>left <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsInt32</span><span class="s1">(compositeObject, </span><span class="s3">&quot;left&quot;</span><span class="s1">);</span>
    composite<span class="s1">-&gt;</span>top <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsInt32</span><span class="s1">(compositeObject, </span><span class="s3">&quot;top&quot;</span><span class="s1">);</span>
    composite<span class="s1">-&gt;</span>hasOffset <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(compositeObject, </span><span class="s3">&quot;hasOffset&quot;</span><span class="s1">);</span>
    composite<span class="s1">-&gt;</span>tile <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(compositeObject, </span><span class="s3">&quot;tile&quot;</span><span class="s1">);</span>
    composite<span class="s1">-&gt;</span>premultiplied <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(compositeObject, </span><span class="s3">&quot;premultiplied&quot;</span><span class="s1">);</span>
    baton<span class="s1">-&gt;</span>composite<span class="s1">.</span><span class="s5">push_back</span><span class="s1">(composite);</span>
  <span class="s1">}</span>
  <span class="s0">// Resize options</span>
  baton<span class="s1">-&gt;</span>withoutEnlargement <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(options, </span><span class="s3">&quot;withoutEnlargement&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>withoutReduction <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(options, </span><span class="s3">&quot;withoutReduction&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>position <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsInt32</span><span class="s1">(options, </span><span class="s3">&quot;position&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>resizeBackground <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsVectorOfDouble</span><span class="s1">(options, </span><span class="s3">&quot;resizeBackground&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>kernel <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsEnum</span><span class="s1">&lt;VipsKernel&gt;(options, </span><span class="s3">&quot;kernel&quot;</span><span class="s1">, VIPS_TYPE_KERNEL);</span>
  baton<span class="s1">-&gt;</span>fastShrinkOnLoad <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(options, </span><span class="s3">&quot;fastShrinkOnLoad&quot;</span><span class="s1">);</span>
  <span class="s0">// Join Channel Options</span>
  <span class="s2">if </span><span class="s1">(</span>options<span class="s1">.</span><span class="s5">Has</span><span class="s1">(</span><span class="s3">&quot;joinChannelIn&quot;</span><span class="s1">)) {</span>
    Napi<span class="s1">::Array joinChannelArray </span><span class="s2">= </span>options<span class="s1">.</span><span class="s5">Get</span><span class="s1">(</span><span class="s3">&quot;joinChannelIn&quot;</span><span class="s1">).</span>As<span class="s2">&lt;</span>Napi<span class="s1">::Array</span><span class="s2">&gt;</span><span class="s1">();</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">unsigned int </span><span class="s1">i </span><span class="s2">= </span><span class="s7">0</span><span class="s1">; i </span><span class="s2">&lt; </span>joinChannelArray<span class="s1">.</span><span class="s5">Length</span><span class="s1">(); i</span><span class="s2">++</span><span class="s1">) {</span>
      baton<span class="s1">-&gt;</span>joinChannelIn<span class="s1">.</span><span class="s5">push_back</span><span class="s1">(</span>
        sharp<span class="s1">::</span><span class="s5">CreateInputDescriptor</span><span class="s1">(</span>joinChannelArray<span class="s1">.</span><span class="s5">Get</span><span class="s1">(i).</span>As<span class="s2">&lt;</span>Napi<span class="s1">::Object</span><span class="s2">&gt;</span><span class="s1">()));</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s0">// Operators</span>
  baton<span class="s1">-&gt;</span>flatten <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(options, </span><span class="s3">&quot;flatten&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>flattenBackground <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsVectorOfDouble</span><span class="s1">(options, </span><span class="s3">&quot;flattenBackground&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>unflatten <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(options, </span><span class="s3">&quot;unflatten&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>negate <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(options, </span><span class="s3">&quot;negate&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>negateAlpha <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(options, </span><span class="s3">&quot;negateAlpha&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>blurSigma <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsDouble</span><span class="s1">(options, </span><span class="s3">&quot;blurSigma&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>precision <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsEnum</span><span class="s1">&lt;VipsPrecision&gt;(options, </span><span class="s3">&quot;precision&quot;</span><span class="s1">, VIPS_TYPE_PRECISION);</span>
  baton<span class="s1">-&gt;</span>minAmpl <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsDouble</span><span class="s1">(options, </span><span class="s3">&quot;minAmpl&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>brightness <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsDouble</span><span class="s1">(options, </span><span class="s3">&quot;brightness&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>saturation <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsDouble</span><span class="s1">(options, </span><span class="s3">&quot;saturation&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>hue <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsInt32</span><span class="s1">(options, </span><span class="s3">&quot;hue&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>lightness <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsDouble</span><span class="s1">(options, </span><span class="s3">&quot;lightness&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>medianSize <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsUint32</span><span class="s1">(options, </span><span class="s3">&quot;medianSize&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>sharpenSigma <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsDouble</span><span class="s1">(options, </span><span class="s3">&quot;sharpenSigma&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>sharpenM1 <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsDouble</span><span class="s1">(options, </span><span class="s3">&quot;sharpenM1&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>sharpenM2 <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsDouble</span><span class="s1">(options, </span><span class="s3">&quot;sharpenM2&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>sharpenX1 <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsDouble</span><span class="s1">(options, </span><span class="s3">&quot;sharpenX1&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>sharpenY2 <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsDouble</span><span class="s1">(options, </span><span class="s3">&quot;sharpenY2&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>sharpenY3 <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsDouble</span><span class="s1">(options, </span><span class="s3">&quot;sharpenY3&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>threshold <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsInt32</span><span class="s1">(options, </span><span class="s3">&quot;threshold&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>thresholdGrayscale <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(options, </span><span class="s3">&quot;thresholdGrayscale&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>trimBackground <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsVectorOfDouble</span><span class="s1">(options, </span><span class="s3">&quot;trimBackground&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>trimThreshold <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsDouble</span><span class="s1">(options, </span><span class="s3">&quot;trimThreshold&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>trimLineArt <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(options, </span><span class="s3">&quot;trimLineArt&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>gamma <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsDouble</span><span class="s1">(options, </span><span class="s3">&quot;gamma&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>gammaOut <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsDouble</span><span class="s1">(options, </span><span class="s3">&quot;gammaOut&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>linearA <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsVectorOfDouble</span><span class="s1">(options, </span><span class="s3">&quot;linearA&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>linearB <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsVectorOfDouble</span><span class="s1">(options, </span><span class="s3">&quot;linearB&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>dilateWidth <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsUint32</span><span class="s1">(options, </span><span class="s3">&quot;dilateWidth&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>erodeWidth <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsUint32</span><span class="s1">(options, </span><span class="s3">&quot;erodeWidth&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>greyscale <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(options, </span><span class="s3">&quot;greyscale&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>normalise <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(options, </span><span class="s3">&quot;normalise&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>normaliseLower <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsUint32</span><span class="s1">(options, </span><span class="s3">&quot;normaliseLower&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>normaliseUpper <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsUint32</span><span class="s1">(options, </span><span class="s3">&quot;normaliseUpper&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>tint <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsVectorOfDouble</span><span class="s1">(options, </span><span class="s3">&quot;tint&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>claheWidth <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsUint32</span><span class="s1">(options, </span><span class="s3">&quot;claheWidth&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>claheHeight <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsUint32</span><span class="s1">(options, </span><span class="s3">&quot;claheHeight&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>claheMaxSlope <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsUint32</span><span class="s1">(options, </span><span class="s3">&quot;claheMaxSlope&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>angle <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsInt32</span><span class="s1">(options, </span><span class="s3">&quot;angle&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>rotationAngle <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsDouble</span><span class="s1">(options, </span><span class="s3">&quot;rotationAngle&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>rotationBackground <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsVectorOfDouble</span><span class="s1">(options, </span><span class="s3">&quot;rotationBackground&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>rotateBefore <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(options, </span><span class="s3">&quot;rotateBefore&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>orientBefore <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(options, </span><span class="s3">&quot;orientBefore&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>flip <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(options, </span><span class="s3">&quot;flip&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>flop <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(options, </span><span class="s3">&quot;flop&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>extendTop <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsInt32</span><span class="s1">(options, </span><span class="s3">&quot;extendTop&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>extendBottom <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsInt32</span><span class="s1">(options, </span><span class="s3">&quot;extendBottom&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>extendLeft <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsInt32</span><span class="s1">(options, </span><span class="s3">&quot;extendLeft&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>extendRight <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsInt32</span><span class="s1">(options, </span><span class="s3">&quot;extendRight&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>extendBackground <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsVectorOfDouble</span><span class="s1">(options, </span><span class="s3">&quot;extendBackground&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>extendWith <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsEnum</span><span class="s1">&lt;VipsExtend&gt;(options, </span><span class="s3">&quot;extendWith&quot;</span><span class="s1">, VIPS_TYPE_EXTEND);</span>
  baton<span class="s1">-&gt;</span>extractChannel <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsInt32</span><span class="s1">(options, </span><span class="s3">&quot;extractChannel&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>affineMatrix <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsVectorOfDouble</span><span class="s1">(options, </span><span class="s3">&quot;affineMatrix&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>affineBackground <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsVectorOfDouble</span><span class="s1">(options, </span><span class="s3">&quot;affineBackground&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>affineIdx <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsDouble</span><span class="s1">(options, </span><span class="s3">&quot;affineIdx&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>affineIdy <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsDouble</span><span class="s1">(options, </span><span class="s3">&quot;affineIdy&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>affineOdx <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsDouble</span><span class="s1">(options, </span><span class="s3">&quot;affineOdx&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>affineOdy <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsDouble</span><span class="s1">(options, </span><span class="s3">&quot;affineOdy&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>affineInterpolator <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsStr</span><span class="s1">(options, </span><span class="s3">&quot;affineInterpolator&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>removeAlpha <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(options, </span><span class="s3">&quot;removeAlpha&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>ensureAlpha <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsDouble</span><span class="s1">(options, </span><span class="s3">&quot;ensureAlpha&quot;</span><span class="s1">);</span>
  <span class="s2">if </span><span class="s1">(</span>options<span class="s1">.</span><span class="s5">Has</span><span class="s1">(</span><span class="s3">&quot;boolean&quot;</span><span class="s1">)) {</span>
    baton<span class="s1">-&gt;</span>boolean <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">CreateInputDescriptor</span><span class="s1">(</span>options<span class="s1">.</span><span class="s5">Get</span><span class="s1">(</span><span class="s3">&quot;boolean&quot;</span><span class="s1">).</span>As<span class="s2">&lt;</span>Napi<span class="s1">::Object</span><span class="s2">&gt;</span><span class="s1">());</span>
    baton<span class="s1">-&gt;</span>booleanOp <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsEnum</span><span class="s1">&lt;VipsOperationBoolean&gt;(options, </span><span class="s3">&quot;booleanOp&quot;</span><span class="s1">, VIPS_TYPE_OPERATION_BOOLEAN);</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span>options<span class="s1">.</span><span class="s5">Has</span><span class="s1">(</span><span class="s3">&quot;bandBoolOp&quot;</span><span class="s1">)) {</span>
    baton<span class="s1">-&gt;</span>bandBoolOp <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsEnum</span><span class="s1">&lt;VipsOperationBoolean&gt;(options, </span><span class="s3">&quot;bandBoolOp&quot;</span><span class="s1">, VIPS_TYPE_OPERATION_BOOLEAN);</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span>options<span class="s1">.</span><span class="s5">Has</span><span class="s1">(</span><span class="s3">&quot;convKernel&quot;</span><span class="s1">)) {</span>
    Napi<span class="s1">::Object kernel </span><span class="s2">= </span>options<span class="s1">.</span><span class="s5">Get</span><span class="s1">(</span><span class="s3">&quot;convKernel&quot;</span><span class="s1">).</span>As<span class="s2">&lt;</span>Napi<span class="s1">::Object</span><span class="s2">&gt;</span><span class="s1">();</span>
    baton<span class="s1">-&gt;</span>convKernelWidth <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsUint32</span><span class="s1">(kernel, </span><span class="s3">&quot;width&quot;</span><span class="s1">);</span>
    baton<span class="s1">-&gt;</span>convKernelHeight <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsUint32</span><span class="s1">(kernel, </span><span class="s3">&quot;height&quot;</span><span class="s1">);</span>
    baton<span class="s1">-&gt;</span>convKernelScale <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsDouble</span><span class="s1">(kernel, </span><span class="s3">&quot;scale&quot;</span><span class="s1">);</span>
    baton<span class="s1">-&gt;</span>convKernelOffset <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsDouble</span><span class="s1">(kernel, </span><span class="s3">&quot;offset&quot;</span><span class="s1">);</span>
    <span class="s2">size_t const </span><span class="s1">kernelSize </span><span class="s2">= static_cast&lt;size_t&gt;</span><span class="s1">(</span>baton<span class="s1">-&gt;</span>convKernelWidth <span class="s2">* </span>baton<span class="s1">-&gt;</span>convKernelHeight<span class="s1">);</span>
    baton<span class="s1">-&gt;</span>convKernel<span class="s1">.</span><span class="s5">resize</span><span class="s1">(kernelSize);</span>
    Napi<span class="s1">::Array kdata </span><span class="s2">= </span>kernel<span class="s1">.</span><span class="s5">Get</span><span class="s1">(</span><span class="s3">&quot;kernel&quot;</span><span class="s1">).</span>As<span class="s2">&lt;</span>Napi<span class="s1">::Array</span><span class="s2">&gt;</span><span class="s1">();</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">unsigned int </span><span class="s1">i </span><span class="s2">= </span><span class="s7">0</span><span class="s1">; i </span><span class="s2">&lt; </span><span class="s1">kernelSize; i</span><span class="s2">++</span><span class="s1">) {</span>
      baton<span class="s1">-&gt;</span>convKernel<span class="s1">[i] </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsDouble</span><span class="s1">(kdata, i);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">if </span><span class="s1">(</span>options<span class="s1">.</span><span class="s5">Has</span><span class="s1">(</span><span class="s3">&quot;recombMatrix&quot;</span><span class="s1">)) {</span>
    Napi<span class="s1">::Array recombMatrix </span><span class="s2">= </span>options<span class="s1">.</span><span class="s5">Get</span><span class="s1">(</span><span class="s3">&quot;recombMatrix&quot;</span><span class="s1">).</span>As<span class="s2">&lt;</span>Napi<span class="s1">::Array</span><span class="s2">&gt;</span><span class="s1">();</span>
    <span class="s2">unsigned int </span><span class="s1">matrixElements </span><span class="s2">= </span>recombMatrix<span class="s1">.</span><span class="s5">Length</span><span class="s1">();</span>
    baton<span class="s1">-&gt;</span>recombMatrix<span class="s1">.</span><span class="s5">resize</span><span class="s1">(matrixElements);</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">unsigned int </span><span class="s1">i </span><span class="s2">= </span><span class="s7">0</span><span class="s1">; i </span><span class="s2">&lt; </span><span class="s1">matrixElements; i</span><span class="s2">++</span><span class="s1">) {</span>
      baton<span class="s1">-&gt;</span>recombMatrix<span class="s1">[i] </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsDouble</span><span class="s1">(recombMatrix, i);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  baton<span class="s1">-&gt;</span>colourspacePipeline <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsEnum</span><span class="s1">&lt;VipsInterpretation&gt;(</span>
    <span class="s1">options, </span><span class="s3">&quot;colourspacePipeline&quot;</span><span class="s1">, VIPS_TYPE_INTERPRETATION);</span>
  <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>colourspacePipeline <span class="s2">== </span><span class="s1">VIPS_INTERPRETATION_ERROR) {</span>
    baton<span class="s1">-&gt;</span>colourspacePipeline <span class="s2">= </span><span class="s1">VIPS_INTERPRETATION_LAST;</span>
  <span class="s1">}</span>
  baton<span class="s1">-&gt;</span>colourspace <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsEnum</span><span class="s1">&lt;VipsInterpretation&gt;(options, </span><span class="s3">&quot;colourspace&quot;</span><span class="s1">, VIPS_TYPE_INTERPRETATION);</span>
  <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>colourspace <span class="s2">== </span><span class="s1">VIPS_INTERPRETATION_ERROR) {</span>
    baton<span class="s1">-&gt;</span>colourspace <span class="s2">= </span><span class="s1">VIPS_INTERPRETATION_sRGB;</span>
  <span class="s1">}</span>
  <span class="s0">// Output</span>
  baton<span class="s1">-&gt;</span>formatOut <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsStr</span><span class="s1">(options, </span><span class="s3">&quot;formatOut&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>fileOut <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsStr</span><span class="s1">(options, </span><span class="s3">&quot;fileOut&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>keepMetadata <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsUint32</span><span class="s1">(options, </span><span class="s3">&quot;keepMetadata&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>withMetadataOrientation <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsUint32</span><span class="s1">(options, </span><span class="s3">&quot;withMetadataOrientation&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>withMetadataDensity <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsDouble</span><span class="s1">(options, </span><span class="s3">&quot;withMetadataDensity&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>withIccProfile <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsStr</span><span class="s1">(options, </span><span class="s3">&quot;withIccProfile&quot;</span><span class="s1">);</span>
  Napi<span class="s1">::Object withExif </span><span class="s2">= </span>options<span class="s1">.</span><span class="s5">Get</span><span class="s1">(</span><span class="s3">&quot;withExif&quot;</span><span class="s1">).</span>As<span class="s2">&lt;</span>Napi<span class="s1">::Object</span><span class="s2">&gt;</span><span class="s1">();</span>
  Napi<span class="s1">::Array withExifKeys </span><span class="s2">= </span>withExif<span class="s1">.</span><span class="s5">GetPropertyNames</span><span class="s1">();</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">unsigned int </span><span class="s1">i </span><span class="s2">= </span><span class="s7">0</span><span class="s1">; i </span><span class="s2">&lt; </span>withExifKeys<span class="s1">.</span><span class="s5">Length</span><span class="s1">(); i</span><span class="s2">++</span><span class="s1">) {</span>
    std<span class="s1">::string k </span><span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsStr</span><span class="s1">(withExifKeys, i);</span>
    <span class="s2">if </span><span class="s1">(</span>withExif<span class="s1">.</span><span class="s5">HasOwnProperty</span><span class="s1">(k)) {</span>
      baton<span class="s1">-&gt;</span>withExif<span class="s1">.</span><span class="s5">insert</span><span class="s1">(</span>std<span class="s1">::</span><span class="s5">make_pair</span><span class="s1">(k, </span>sharp<span class="s1">::</span><span class="s5">AttrAsStr</span><span class="s1">(withExif, k)));</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  baton<span class="s1">-&gt;</span>withExifMerge <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(options, </span><span class="s3">&quot;withExifMerge&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>withXmp <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsStr</span><span class="s1">(options, </span><span class="s3">&quot;withXmp&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>timeoutSeconds <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsUint32</span><span class="s1">(options, </span><span class="s3">&quot;timeoutSeconds&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>loop <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsUint32</span><span class="s1">(options, </span><span class="s3">&quot;loop&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>delay <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsInt32Vector</span><span class="s1">(options, </span><span class="s3">&quot;delay&quot;</span><span class="s1">);</span>
  <span class="s0">// Format-specific</span>
  baton<span class="s1">-&gt;</span>jpegQuality <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsUint32</span><span class="s1">(options, </span><span class="s3">&quot;jpegQuality&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>jpegProgressive <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(options, </span><span class="s3">&quot;jpegProgressive&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>jpegChromaSubsampling <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsStr</span><span class="s1">(options, </span><span class="s3">&quot;jpegChromaSubsampling&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>jpegTrellisQuantisation <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(options, </span><span class="s3">&quot;jpegTrellisQuantisation&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>jpegQuantisationTable <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsUint32</span><span class="s1">(options, </span><span class="s3">&quot;jpegQuantisationTable&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>jpegOvershootDeringing <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(options, </span><span class="s3">&quot;jpegOvershootDeringing&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>jpegOptimiseScans <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(options, </span><span class="s3">&quot;jpegOptimiseScans&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>jpegOptimiseCoding <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(options, </span><span class="s3">&quot;jpegOptimiseCoding&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>pngProgressive <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(options, </span><span class="s3">&quot;pngProgressive&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>pngCompressionLevel <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsUint32</span><span class="s1">(options, </span><span class="s3">&quot;pngCompressionLevel&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>pngAdaptiveFiltering <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(options, </span><span class="s3">&quot;pngAdaptiveFiltering&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>pngPalette <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(options, </span><span class="s3">&quot;pngPalette&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>pngQuality <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsUint32</span><span class="s1">(options, </span><span class="s3">&quot;pngQuality&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>pngEffort <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsUint32</span><span class="s1">(options, </span><span class="s3">&quot;pngEffort&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>pngBitdepth <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsUint32</span><span class="s1">(options, </span><span class="s3">&quot;pngBitdepth&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>pngDither <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsDouble</span><span class="s1">(options, </span><span class="s3">&quot;pngDither&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>jp2Quality <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsUint32</span><span class="s1">(options, </span><span class="s3">&quot;jp2Quality&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>jp2Lossless <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(options, </span><span class="s3">&quot;jp2Lossless&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>jp2TileHeight <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsUint32</span><span class="s1">(options, </span><span class="s3">&quot;jp2TileHeight&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>jp2TileWidth <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsUint32</span><span class="s1">(options, </span><span class="s3">&quot;jp2TileWidth&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>jp2ChromaSubsampling <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsStr</span><span class="s1">(options, </span><span class="s3">&quot;jp2ChromaSubsampling&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>webpQuality <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsUint32</span><span class="s1">(options, </span><span class="s3">&quot;webpQuality&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>webpAlphaQuality <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsUint32</span><span class="s1">(options, </span><span class="s3">&quot;webpAlphaQuality&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>webpLossless <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(options, </span><span class="s3">&quot;webpLossless&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>webpNearLossless <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(options, </span><span class="s3">&quot;webpNearLossless&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>webpSmartSubsample <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(options, </span><span class="s3">&quot;webpSmartSubsample&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>webpSmartDeblock <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(options, </span><span class="s3">&quot;webpSmartDeblock&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>webpPreset <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsEnum</span><span class="s1">&lt;VipsForeignWebpPreset&gt;(options, </span><span class="s3">&quot;webpPreset&quot;</span><span class="s1">, VIPS_TYPE_FOREIGN_WEBP_PRESET);</span>
  baton<span class="s1">-&gt;</span>webpEffort <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsUint32</span><span class="s1">(options, </span><span class="s3">&quot;webpEffort&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>webpMinSize <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(options, </span><span class="s3">&quot;webpMinSize&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>webpMixed <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(options, </span><span class="s3">&quot;webpMixed&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>gifBitdepth <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsUint32</span><span class="s1">(options, </span><span class="s3">&quot;gifBitdepth&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>gifEffort <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsUint32</span><span class="s1">(options, </span><span class="s3">&quot;gifEffort&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>gifDither <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsDouble</span><span class="s1">(options, </span><span class="s3">&quot;gifDither&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>gifInterFrameMaxError <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsDouble</span><span class="s1">(options, </span><span class="s3">&quot;gifInterFrameMaxError&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>gifInterPaletteMaxError <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsDouble</span><span class="s1">(options, </span><span class="s3">&quot;gifInterPaletteMaxError&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>gifKeepDuplicateFrames <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(options, </span><span class="s3">&quot;gifKeepDuplicateFrames&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>gifReuse <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(options, </span><span class="s3">&quot;gifReuse&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>gifProgressive <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(options, </span><span class="s3">&quot;gifProgressive&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>tiffQuality <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsUint32</span><span class="s1">(options, </span><span class="s3">&quot;tiffQuality&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>tiffPyramid <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(options, </span><span class="s3">&quot;tiffPyramid&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>tiffMiniswhite <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(options, </span><span class="s3">&quot;tiffMiniswhite&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>tiffBitdepth <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsUint32</span><span class="s1">(options, </span><span class="s3">&quot;tiffBitdepth&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>tiffTile <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(options, </span><span class="s3">&quot;tiffTile&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>tiffTileWidth <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsUint32</span><span class="s1">(options, </span><span class="s3">&quot;tiffTileWidth&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>tiffTileHeight <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsUint32</span><span class="s1">(options, </span><span class="s3">&quot;tiffTileHeight&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>tiffXres <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsDouble</span><span class="s1">(options, </span><span class="s3">&quot;tiffXres&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>tiffYres <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsDouble</span><span class="s1">(options, </span><span class="s3">&quot;tiffYres&quot;</span><span class="s1">);</span>
  <span class="s2">if </span><span class="s1">(</span>baton<span class="s1">-&gt;</span>tiffXres <span class="s2">== </span><span class="s7">1.0 </span><span class="s2">&amp;&amp; </span>baton<span class="s1">-&gt;</span>tiffYres <span class="s2">== </span><span class="s7">1.0 </span><span class="s2">&amp;&amp; </span>baton<span class="s1">-&gt;</span>withMetadataDensity <span class="s2">&gt; </span><span class="s7">0</span><span class="s1">) {</span>
    baton<span class="s1">-&gt;</span>tiffXres <span class="s2">= </span>baton<span class="s1">-&gt;</span>tiffYres <span class="s2">= </span>baton<span class="s1">-&gt;</span>withMetadataDensity <span class="s2">/ </span><span class="s7">25.4</span><span class="s1">;</span>
  <span class="s1">}</span>
  baton<span class="s1">-&gt;</span>tiffCompression <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsEnum</span><span class="s1">&lt;VipsForeignTiffCompression&gt;(</span>
    <span class="s1">options, </span><span class="s3">&quot;tiffCompression&quot;</span><span class="s1">, VIPS_TYPE_FOREIGN_TIFF_COMPRESSION);</span>
  baton<span class="s1">-&gt;</span>tiffPredictor <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsEnum</span><span class="s1">&lt;VipsForeignTiffPredictor&gt;(</span>
    <span class="s1">options, </span><span class="s3">&quot;tiffPredictor&quot;</span><span class="s1">, VIPS_TYPE_FOREIGN_TIFF_PREDICTOR);</span>
  baton<span class="s1">-&gt;</span>tiffResolutionUnit <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsEnum</span><span class="s1">&lt;VipsForeignTiffResunit&gt;(</span>
    <span class="s1">options, </span><span class="s3">&quot;tiffResolutionUnit&quot;</span><span class="s1">, VIPS_TYPE_FOREIGN_TIFF_RESUNIT);</span>
  baton<span class="s1">-&gt;</span>heifQuality <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsUint32</span><span class="s1">(options, </span><span class="s3">&quot;heifQuality&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>heifLossless <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(options, </span><span class="s3">&quot;heifLossless&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>heifCompression <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsEnum</span><span class="s1">&lt;VipsForeignHeifCompression&gt;(</span>
    <span class="s1">options, </span><span class="s3">&quot;heifCompression&quot;</span><span class="s1">, VIPS_TYPE_FOREIGN_HEIF_COMPRESSION);</span>
  baton<span class="s1">-&gt;</span>heifEffort <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsUint32</span><span class="s1">(options, </span><span class="s3">&quot;heifEffort&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>heifChromaSubsampling <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsStr</span><span class="s1">(options, </span><span class="s3">&quot;heifChromaSubsampling&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>heifBitdepth <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsUint32</span><span class="s1">(options, </span><span class="s3">&quot;heifBitdepth&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>jxlDistance <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsDouble</span><span class="s1">(options, </span><span class="s3">&quot;jxlDistance&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>jxlDecodingTier <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsUint32</span><span class="s1">(options, </span><span class="s3">&quot;jxlDecodingTier&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>jxlEffort <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsUint32</span><span class="s1">(options, </span><span class="s3">&quot;jxlEffort&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>jxlLossless <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(options, </span><span class="s3">&quot;jxlLossless&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>rawDepth <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsEnum</span><span class="s1">&lt;VipsBandFormat&gt;(options, </span><span class="s3">&quot;rawDepth&quot;</span><span class="s1">, VIPS_TYPE_BAND_FORMAT);</span>
  baton<span class="s1">-&gt;</span>tileSize <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsUint32</span><span class="s1">(options, </span><span class="s3">&quot;tileSize&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>tileOverlap <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsUint32</span><span class="s1">(options, </span><span class="s3">&quot;tileOverlap&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>tileAngle <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsInt32</span><span class="s1">(options, </span><span class="s3">&quot;tileAngle&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>tileBackground <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsVectorOfDouble</span><span class="s1">(options, </span><span class="s3">&quot;tileBackground&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>tileSkipBlanks <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsInt32</span><span class="s1">(options, </span><span class="s3">&quot;tileSkipBlanks&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>tileContainer <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsEnum</span><span class="s1">&lt;VipsForeignDzContainer&gt;(</span>
    <span class="s1">options, </span><span class="s3">&quot;tileContainer&quot;</span><span class="s1">, VIPS_TYPE_FOREIGN_DZ_CONTAINER);</span>
  baton<span class="s1">-&gt;</span>tileLayout <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsEnum</span><span class="s1">&lt;VipsForeignDzLayout&gt;(options, </span><span class="s3">&quot;tileLayout&quot;</span><span class="s1">, VIPS_TYPE_FOREIGN_DZ_LAYOUT);</span>
  baton<span class="s1">-&gt;</span>tileFormat <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsStr</span><span class="s1">(options, </span><span class="s3">&quot;tileFormat&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>tileDepth <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsEnum</span><span class="s1">&lt;VipsForeignDzDepth&gt;(options, </span><span class="s3">&quot;tileDepth&quot;</span><span class="s1">, VIPS_TYPE_FOREIGN_DZ_DEPTH);</span>
  baton<span class="s1">-&gt;</span>tileCentre <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsBool</span><span class="s1">(options, </span><span class="s3">&quot;tileCentre&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>tileId <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsStr</span><span class="s1">(options, </span><span class="s3">&quot;tileId&quot;</span><span class="s1">);</span>
  baton<span class="s1">-&gt;</span>tileBasename <span class="s2">= </span>sharp<span class="s1">::</span><span class="s5">AttrAsStr</span><span class="s1">(options, </span><span class="s3">&quot;tileBasename&quot;</span><span class="s1">);</span>

  <span class="s0">// Function to notify of libvips warnings</span>
  Napi<span class="s1">::Function debuglog </span><span class="s2">= </span>options<span class="s1">.</span><span class="s5">Get</span><span class="s1">(</span><span class="s3">&quot;debuglog&quot;</span><span class="s1">).</span>As<span class="s2">&lt;</span>Napi<span class="s1">::Function</span><span class="s2">&gt;</span><span class="s1">();</span>

  <span class="s0">// Function to notify of queue length changes</span>
  Napi<span class="s1">::Function queueListener </span><span class="s2">= </span>options<span class="s1">.</span><span class="s5">Get</span><span class="s1">(</span><span class="s3">&quot;queueListener&quot;</span><span class="s1">).</span>As<span class="s2">&lt;</span>Napi<span class="s1">::Function</span><span class="s2">&gt;</span><span class="s1">();</span>

  <span class="s0">// Join queue for worker thread</span>
  Napi<span class="s1">::Function callback </span><span class="s2">= </span>info<span class="s1">[</span><span class="s2">size_t</span><span class="s1">(</span><span class="s7">1</span><span class="s1">)].</span>As<span class="s2">&lt;</span>Napi<span class="s1">::Function</span><span class="s2">&gt;</span><span class="s1">();</span>
  <span class="s1">PipelineWorker </span><span class="s2">*</span><span class="s1">worker </span><span class="s2">= new </span><span class="s5">PipelineWorker</span><span class="s1">(callback, baton, debuglog, queueListener);</span>
  worker<span class="s1">-&gt;</span><span class="s5">Receiver</span><span class="s1">().</span><span class="s5">Set</span><span class="s1">(</span><span class="s3">&quot;options&quot;</span><span class="s1">, options);</span>
  worker<span class="s1">-&gt;</span><span class="s5">Queue</span><span class="s1">();</span>

  <span class="s0">// Increment queued task counter</span>
  Napi<span class="s1">::Number queueLength </span><span class="s2">= </span>Napi<span class="s1">::</span>Number<span class="s1">::</span><span class="s5">New</span><span class="s1">(</span>info<span class="s1">.</span><span class="s5">Env</span><span class="s1">(), </span><span class="s2">static_cast&lt;int&gt;</span><span class="s1">(</span><span class="s2">++</span>sharp<span class="s1">::counterQueue));</span>
  queueListener<span class="s1">.</span><span class="s5">Call</span><span class="s1">(</span>info<span class="s1">.</span><span class="s5">This</span><span class="s1">(), { queueLength });</span>

  <span class="s2">return </span>info<span class="s1">.</span><span class="s5">Env</span><span class="s1">().</span><span class="s5">Undefined</span><span class="s1">();</span>
<span class="s1">}</span>
</pre>
</body>
</html>