<html>
<head>
<title>pages.runtime.prod.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
pages.runtime.prod.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;pages.runtime.prod.js&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://next/./dist/compiled/@edge-runtime/cookies/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/compiled/cookie/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/compiled/path-to-regexp/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/compiled/react-is/cjs/react-is.production.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/compiled/react-is/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/compiled/strip-ansi/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/picocolors.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/lru-cache.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/build/output/log.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/constants.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/format-dynamic-import-path.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/api-utils/index.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/api-utils/node/try-get-preview-data.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/crypto-utils.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/node-fs-methods.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/optimize-amp.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/non-nullable.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/post-process.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/web/spec-extension/adapters/reflect.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/web/spec-extension/adapters/headers.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/isomorphic/path.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/modern-browserslist-target.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./src/server/ReactDOMServerPages.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/compiled/superstruct/index.cjs&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/webpack/runtime/compat_get_default_export&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/webpack/runtime/create_fake_namespace_object&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/webpack/runtime/define_property_getters&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/webpack/runtime/has_own_property&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/webpack/runtime/make_namespace_object&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/render.tsx&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/constants.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/url.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/i18n/normalize-locale-path.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/page-path/ensure-leading-slash.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/app-paths.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/segment.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/interception-routes.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/is-dynamic.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/parse-path.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/path-has-prefix.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/remove-path-prefix.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/escape-regexp.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/remove-trailing-slash.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/get-dynamic-param.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/route-regex.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/utils.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/route-pattern-normalizer.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/route-match-utils.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/route-matcher.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/querystring.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/api-utils/get-cookie-parser.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/prepare-destination.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/web/utils.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/decode-query-path-parameter.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/format-url.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/app-render/types.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/generate-interception-routes-rewrites.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/client/components/app-router-headers.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/server-utils.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/i18n/detect-domain-locale.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/get-hostname.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/page-path/normalize-data-path.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/request-meta.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/page-path/normalize-page-path.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/page-path/normalize-path-sep.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/metadata/is-metadata-route.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/detached-promise.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/batcher.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/scheduler.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/response-cache/types.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/trace/constants.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/stream-utils/node-web-streams-helper.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/stream-utils/encoded-tags.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/add-path-prefix.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/add-path-suffix.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/web/next-url.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/get-next-pathname-info.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/format-next-pathname-info.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/add-locale.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/web/spec-extension/request.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/web/spec-extension/adapters/next-request.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/client-component-renderer-logger.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/pipe-readable.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/invariant-error.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/render-result.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/route-kind.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/response-cache/utils.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/response-cache/index.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/multi-file-writer.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/incremental-cache/file-system-cache.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/to-route.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/incremental-cache/index.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/use-cache/handlers.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/app-render/interop-default.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/router-utils/router-server-context.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/route-modules/route-module.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/is-app-route-route.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/path-match.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/client/components/router-reducer/compute-changed-path.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/app-render/parse-and-validate-flight-router-state.tsx&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/parse-url.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/parse-relative-url.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/router-utils/decode-path-params.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/escape-path-delimiters.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/is-plain-object.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/is-serializable-props.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/amp-context.shared-runtime.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/head-manager-context.shared-runtime.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/loadable-context.shared-runtime.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/loadable.shared-runtime.tsx&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router-context.shared-runtime.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/html-context.shared-runtime.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/client/components/redirect-status-code.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/redirect-status.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/image-config-context.shared-runtime.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/image-config.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/internal-utils.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/hooks-client-context.shared-runtime.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/adapters.tsx&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/app-router-context.shared-runtime.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/error-source.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/htmlescape.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/lib/cache-control.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/amp-mode.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/head.tsx&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/app-render/get-script-nonce-from-header.tsx&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/router/utils/as-path-to-search-params.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/lib/is-error.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/page-path/denormalize-page-path.ts&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/shared/lib/server-inserted-html.shared-runtime.tsx&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://next/./dist/src/server/route-modules/pages/module.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">var __defProp = Object.defineProperty;</span><span class="s3">\n</span><span class="s1">var __getOwnPropDesc = Object.getOwnPropertyDescriptor;</span><span class="s3">\n</span><span class="s1">var __getOwnPropNames = Object.getOwnPropertyNames;</span><span class="s3">\n</span><span class="s1">var __hasOwnProp = Object.prototype.hasOwnProperty;</span><span class="s3">\n</span><span class="s1">var __export = (target, all) =&gt; {</span><span class="s3">\n  </span><span class="s1">for (var name in all)</span><span class="s3">\n    </span><span class="s1">__defProp(target, name, { get: all[name], enumerable: true });</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var __copyProps = (to, from, except, desc) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (from &amp;&amp; typeof from === </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">|| typeof from === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">for (let key of __getOwnPropNames(from))</span><span class="s3">\n      </span><span class="s1">if (!__hasOwnProp.call(to, key) &amp;&amp; key !== except)</span><span class="s3">\n        </span><span class="s1">__defProp(to, key, { get: () =&gt; from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return to;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var __toCommonJS = (mod) =&gt; __copyProps(__defProp({}, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true }), mod);</span><span class="s3">\n\n</span><span class="s1">// src/index.ts</span><span class="s3">\n</span><span class="s1">var src_exports = {};</span><span class="s3">\n</span><span class="s1">__export(src_exports, {</span><span class="s3">\n  </span><span class="s1">RequestCookies: () =&gt; RequestCookies,</span><span class="s3">\n  </span><span class="s1">ResponseCookies: () =&gt; ResponseCookies,</span><span class="s3">\n  </span><span class="s1">parseCookie: () =&gt; parseCookie,</span><span class="s3">\n  </span><span class="s1">parseSetCookie: () =&gt; parseSetCookie,</span><span class="s3">\n  </span><span class="s1">stringifyCookie: () =&gt; stringifyCookie</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">module.exports = __toCommonJS(src_exports);</span><span class="s3">\n\n</span><span class="s1">// src/serialize.ts</span><span class="s3">\n</span><span class="s1">function stringifyCookie(c) {</span><span class="s3">\n  </span><span class="s1">var _a;</span><span class="s3">\n  </span><span class="s1">const attrs = [</span><span class="s3">\n    \&quot;</span><span class="s1">path</span><span class="s3">\&quot; </span><span class="s1">in c &amp;&amp; c.path &amp;&amp; `Path=${c.path}`,</span><span class="s3">\n    \&quot;</span><span class="s1">expires</span><span class="s3">\&quot; </span><span class="s1">in c &amp;&amp; (c.expires || c.expires === 0) &amp;&amp; `Expires=${(typeof c.expires === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">? new Date(c.expires) : c.expires).toUTCString()}`,</span><span class="s3">\n    \&quot;</span><span class="s1">maxAge</span><span class="s3">\&quot; </span><span class="s1">in c &amp;&amp; typeof c.maxAge === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; `Max-Age=${c.maxAge}`,</span><span class="s3">\n    \&quot;</span><span class="s1">domain</span><span class="s3">\&quot; </span><span class="s1">in c &amp;&amp; c.domain &amp;&amp; `Domain=${c.domain}`,</span><span class="s3">\n    \&quot;</span><span class="s1">secure</span><span class="s3">\&quot; </span><span class="s1">in c &amp;&amp; c.secure &amp;&amp; </span><span class="s3">\&quot;</span><span class="s1">Secure</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">httpOnly</span><span class="s3">\&quot; </span><span class="s1">in c &amp;&amp; c.httpOnly &amp;&amp; </span><span class="s3">\&quot;</span><span class="s1">HttpOnly</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">sameSite</span><span class="s3">\&quot; </span><span class="s1">in c &amp;&amp; c.sameSite &amp;&amp; `SameSite=${c.sameSite}`,</span><span class="s3">\n    \&quot;</span><span class="s1">partitioned</span><span class="s3">\&quot; </span><span class="s1">in c &amp;&amp; c.partitioned &amp;&amp; </span><span class="s3">\&quot;</span><span class="s1">Partitioned</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    \&quot;</span><span class="s1">priority</span><span class="s3">\&quot; </span><span class="s1">in c &amp;&amp; c.priority &amp;&amp; `Priority=${c.priority}`</span><span class="s3">\n  </span><span class="s1">].filter(Boolean);</span><span class="s3">\n  </span><span class="s1">const stringified = `${c.name}=${encodeURIComponent((_a = c.value) != null ? _a : </span><span class="s3">\&quot;\&quot;</span><span class="s1">)}`;</span><span class="s3">\n  </span><span class="s1">return attrs.length === 0 ? stringified : `${stringified}; ${attrs.join(</span><span class="s3">\&quot;</span><span class="s1">; </span><span class="s3">\&quot;</span><span class="s1">)}`;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function parseCookie(cookie) {</span><span class="s3">\n  </span><span class="s1">const map = /* @__PURE__ */ new Map();</span><span class="s3">\n  </span><span class="s1">for (const pair of cookie.split(/; */)) {</span><span class="s3">\n    </span><span class="s1">if (!pair)</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">const splitAt = pair.indexOf(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (splitAt === -1) {</span><span class="s3">\n      </span><span class="s1">map.set(pair, </span><span class="s3">\&quot;</span><span class="s1">true</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const [key, value] = [pair.slice(0, splitAt), pair.slice(splitAt + 1)];</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">map.set(key, decodeURIComponent(value != null ? value : </span><span class="s3">\&quot;</span><span class="s1">true</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n    </span><span class="s1">} catch {</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return map;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function parseSetCookie(setCookie) {</span><span class="s3">\n  </span><span class="s1">if (!setCookie) {</span><span class="s3">\n    </span><span class="s1">return void 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const [[name, value], ...attributes] = parseCookie(setCookie);</span><span class="s3">\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">domain,</span><span class="s3">\n    </span><span class="s1">expires,</span><span class="s3">\n    </span><span class="s1">httponly,</span><span class="s3">\n    </span><span class="s1">maxage,</span><span class="s3">\n    </span><span class="s1">path,</span><span class="s3">\n    </span><span class="s1">samesite,</span><span class="s3">\n    </span><span class="s1">secure,</span><span class="s3">\n    </span><span class="s1">partitioned,</span><span class="s3">\n    </span><span class="s1">priority</span><span class="s3">\n  </span><span class="s1">} = Object.fromEntries(</span><span class="s3">\n    </span><span class="s1">attributes.map(([key, value2]) =&gt; [</span><span class="s3">\n      </span><span class="s1">key.toLowerCase().replace(/-/g, </span><span class="s3">\&quot;\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">value2</span><span class="s3">\n    </span><span class="s1">])</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const cookie = {</span><span class="s3">\n    </span><span class="s1">name,</span><span class="s3">\n    </span><span class="s1">value: decodeURIComponent(value),</span><span class="s3">\n    </span><span class="s1">domain,</span><span class="s3">\n    </span><span class="s1">...expires &amp;&amp; { expires: new Date(expires) },</span><span class="s3">\n    </span><span class="s1">...httponly &amp;&amp; { httpOnly: true },</span><span class="s3">\n    </span><span class="s1">...typeof maxage === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; { maxAge: Number(maxage) },</span><span class="s3">\n    </span><span class="s1">path,</span><span class="s3">\n    </span><span class="s1">...samesite &amp;&amp; { sameSite: parseSameSite(samesite) },</span><span class="s3">\n    </span><span class="s1">...secure &amp;&amp; { secure: true },</span><span class="s3">\n    </span><span class="s1">...priority &amp;&amp; { priority: parsePriority(priority) },</span><span class="s3">\n    </span><span class="s1">...partitioned &amp;&amp; { partitioned: true }</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">return compact(cookie);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function compact(t) {</span><span class="s3">\n  </span><span class="s1">const newT = {};</span><span class="s3">\n  </span><span class="s1">for (const key in t) {</span><span class="s3">\n    </span><span class="s1">if (t[key]) {</span><span class="s3">\n      </span><span class="s1">newT[key] = t[key];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return newT;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">var SAME_SITE = [</span><span class="s3">\&quot;</span><span class="s1">strict</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">lax</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">function parseSameSite(string) {</span><span class="s3">\n  </span><span class="s1">string = string.toLowerCase();</span><span class="s3">\n  </span><span class="s1">return SAME_SITE.includes(string) ? string : void 0;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">var PRIORITY = [</span><span class="s3">\&quot;</span><span class="s1">low</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">medium</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">high</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">function parsePriority(string) {</span><span class="s3">\n  </span><span class="s1">string = string.toLowerCase();</span><span class="s3">\n  </span><span class="s1">return PRIORITY.includes(string) ? string : void 0;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function splitCookiesString(cookiesString) {</span><span class="s3">\n  </span><span class="s1">if (!cookiesString)</span><span class="s3">\n    </span><span class="s1">return [];</span><span class="s3">\n  </span><span class="s1">var cookiesStrings = [];</span><span class="s3">\n  </span><span class="s1">var pos = 0;</span><span class="s3">\n  </span><span class="s1">var start;</span><span class="s3">\n  </span><span class="s1">var ch;</span><span class="s3">\n  </span><span class="s1">var lastComma;</span><span class="s3">\n  </span><span class="s1">var nextStart;</span><span class="s3">\n  </span><span class="s1">var cookiesSeparatorFound;</span><span class="s3">\n  </span><span class="s1">function skipWhitespace() {</span><span class="s3">\n    </span><span class="s1">while (pos &lt; cookiesString.length &amp;&amp; /</span><span class="s3">\\</span><span class="s1">s/.test(cookiesString.charAt(pos))) {</span><span class="s3">\n      </span><span class="s1">pos += 1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return pos &lt; cookiesString.length;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function notSpecialChar() {</span><span class="s3">\n    </span><span class="s1">ch = cookiesString.charAt(pos);</span><span class="s3">\n    </span><span class="s1">return ch !== </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; ch !== </span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; ch !== </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">while (pos &lt; cookiesString.length) {</span><span class="s3">\n    </span><span class="s1">start = pos;</span><span class="s3">\n    </span><span class="s1">cookiesSeparatorFound = false;</span><span class="s3">\n    </span><span class="s1">while (skipWhitespace()) {</span><span class="s3">\n      </span><span class="s1">ch = cookiesString.charAt(pos);</span><span class="s3">\n      </span><span class="s1">if (ch === </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">lastComma = pos;</span><span class="s3">\n        </span><span class="s1">pos += 1;</span><span class="s3">\n        </span><span class="s1">skipWhitespace();</span><span class="s3">\n        </span><span class="s1">nextStart = pos;</span><span class="s3">\n        </span><span class="s1">while (pos &lt; cookiesString.length &amp;&amp; notSpecialChar()) {</span><span class="s3">\n          </span><span class="s1">pos += 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (pos &lt; cookiesString.length &amp;&amp; cookiesString.charAt(pos) === </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">cookiesSeparatorFound = true;</span><span class="s3">\n          </span><span class="s1">pos = nextStart;</span><span class="s3">\n          </span><span class="s1">cookiesStrings.push(cookiesString.substring(start, lastComma));</span><span class="s3">\n          </span><span class="s1">start = pos;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">pos = lastComma + 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">pos += 1;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!cookiesSeparatorFound || pos &gt;= cookiesString.length) {</span><span class="s3">\n      </span><span class="s1">cookiesStrings.push(cookiesString.substring(start, cookiesString.length));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return cookiesStrings;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// src/request-cookies.ts</span><span class="s3">\n</span><span class="s1">var RequestCookies = class {</span><span class="s3">\n  </span><span class="s1">constructor(requestHeaders) {</span><span class="s3">\n    </span><span class="s1">/** @internal */</span><span class="s3">\n    </span><span class="s1">this._parsed = /* @__PURE__ */ new Map();</span><span class="s3">\n    </span><span class="s1">this._headers = requestHeaders;</span><span class="s3">\n    </span><span class="s1">const header = requestHeaders.get(</span><span class="s3">\&quot;</span><span class="s1">cookie</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (header) {</span><span class="s3">\n      </span><span class="s1">const parsed = parseCookie(header);</span><span class="s3">\n      </span><span class="s1">for (const [name, value] of parsed) {</span><span class="s3">\n        </span><span class="s1">this._parsed.set(name, { name, value });</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">[Symbol.iterator]() {</span><span class="s3">\n    </span><span class="s1">return this._parsed[Symbol.iterator]();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The amount of cookies received from the client</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">get size() {</span><span class="s3">\n    </span><span class="s1">return this._parsed.size;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">get(...args) {</span><span class="s3">\n    </span><span class="s1">const name = typeof args[0] === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">? args[0] : args[0].name;</span><span class="s3">\n    </span><span class="s1">return this._parsed.get(name);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">getAll(...args) {</span><span class="s3">\n    </span><span class="s1">var _a;</span><span class="s3">\n    </span><span class="s1">const all = Array.from(this._parsed);</span><span class="s3">\n    </span><span class="s1">if (!args.length) {</span><span class="s3">\n      </span><span class="s1">return all.map(([_, value]) =&gt; value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const name = typeof args[0] === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">? args[0] : (_a = args[0]) == null ? void 0 : _a.name;</span><span class="s3">\n    </span><span class="s1">return all.filter(([n]) =&gt; n === name).map(([_, value]) =&gt; value);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">has(name) {</span><span class="s3">\n    </span><span class="s1">return this._parsed.has(name);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">set(...args) {</span><span class="s3">\n    </span><span class="s1">const [name, value] = args.length === 1 ? [args[0].name, args[0].value] : args;</span><span class="s3">\n    </span><span class="s1">const map = this._parsed;</span><span class="s3">\n    </span><span class="s1">map.set(name, { name, value });</span><span class="s3">\n    </span><span class="s1">this._headers.set(</span><span class="s3">\n      \&quot;</span><span class="s1">cookie</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">Array.from(map).map(([_, value2]) =&gt; stringifyCookie(value2)).join(</span><span class="s3">\&quot;</span><span class="s1">; </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Delete the cookies matching the passed name or names in the request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">delete(names) {</span><span class="s3">\n    </span><span class="s1">const map = this._parsed;</span><span class="s3">\n    </span><span class="s1">const result = !Array.isArray(names) ? map.delete(names) : names.map((name) =&gt; map.delete(name));</span><span class="s3">\n    </span><span class="s1">this._headers.set(</span><span class="s3">\n      \&quot;</span><span class="s1">cookie</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">Array.from(map).map(([_, value]) =&gt; stringifyCookie(value)).join(</span><span class="s3">\&quot;</span><span class="s1">; </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Delete all the cookies in the cookies in the request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">clear() {</span><span class="s3">\n    </span><span class="s1">this.delete(Array.from(this._parsed.keys()));</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Format the cookies in the request as a string for logging</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">[Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">edge-runtime.inspect.custom</span><span class="s3">\&quot;</span><span class="s1">)]() {</span><span class="s3">\n    </span><span class="s1">return `RequestCookies ${JSON.stringify(Object.fromEntries(this._parsed))}`;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">toString() {</span><span class="s3">\n    </span><span class="s1">return [...this._parsed.values()].map((v) =&gt; `${v.name}=${encodeURIComponent(v.value)}`).join(</span><span class="s3">\&quot;</span><span class="s1">; </span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// src/response-cookies.ts</span><span class="s3">\n</span><span class="s1">var ResponseCookies = class {</span><span class="s3">\n  </span><span class="s1">constructor(responseHeaders) {</span><span class="s3">\n    </span><span class="s1">/** @internal */</span><span class="s3">\n    </span><span class="s1">this._parsed = /* @__PURE__ */ new Map();</span><span class="s3">\n    </span><span class="s1">var _a, _b, _c;</span><span class="s3">\n    </span><span class="s1">this._headers = responseHeaders;</span><span class="s3">\n    </span><span class="s1">const setCookie = (_c = (_b = (_a = responseHeaders.getSetCookie) == null ? void 0 : _a.call(responseHeaders)) != null ? _b : responseHeaders.get(</span><span class="s3">\&quot;</span><span class="s1">set-cookie</span><span class="s3">\&quot;</span><span class="s1">)) != null ? _c : [];</span><span class="s3">\n    </span><span class="s1">const cookieStrings = Array.isArray(setCookie) ? setCookie : splitCookiesString(setCookie);</span><span class="s3">\n    </span><span class="s1">for (const cookieString of cookieStrings) {</span><span class="s3">\n      </span><span class="s1">const parsed = parseSetCookie(cookieString);</span><span class="s3">\n      </span><span class="s1">if (parsed)</span><span class="s3">\n        </span><span class="s1">this._parsed.set(parsed.name, parsed);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* {@link https://wicg.github.io/cookie-store/#CookieStore-get CookieStore#get} without the Promise.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">get(...args) {</span><span class="s3">\n    </span><span class="s1">const key = typeof args[0] === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">? args[0] : args[0].name;</span><span class="s3">\n    </span><span class="s1">return this._parsed.get(key);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* {@link https://wicg.github.io/cookie-store/#CookieStore-getAll CookieStore#getAll} without the Promise.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getAll(...args) {</span><span class="s3">\n    </span><span class="s1">var _a;</span><span class="s3">\n    </span><span class="s1">const all = Array.from(this._parsed.values());</span><span class="s3">\n    </span><span class="s1">if (!args.length) {</span><span class="s3">\n      </span><span class="s1">return all;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const key = typeof args[0] === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">? args[0] : (_a = args[0]) == null ? void 0 : _a.name;</span><span class="s3">\n    </span><span class="s1">return all.filter((c) =&gt; c.name === key);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">has(name) {</span><span class="s3">\n    </span><span class="s1">return this._parsed.has(name);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* {@link https://wicg.github.io/cookie-store/#CookieStore-set CookieStore#set} without the Promise.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">set(...args) {</span><span class="s3">\n    </span><span class="s1">const [name, value, cookie] = args.length === 1 ? [args[0].name, args[0].value, args[0]] : args;</span><span class="s3">\n    </span><span class="s1">const map = this._parsed;</span><span class="s3">\n    </span><span class="s1">map.set(name, normalizeCookie({ name, value, ...cookie }));</span><span class="s3">\n    </span><span class="s1">replace(map, this._headers);</span><span class="s3">\n    </span><span class="s1">return this;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* {@link https://wicg.github.io/cookie-store/#CookieStore-delete CookieStore#delete} without the Promise.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">delete(...args) {</span><span class="s3">\n    </span><span class="s1">const [name, options] = typeof args[0] === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">? [args[0]] : [args[0].name, args[0]];</span><span class="s3">\n    </span><span class="s1">return this.set({ ...options, name, value: </span><span class="s3">\&quot;\&quot;</span><span class="s1">, expires: /* @__PURE__ */ new Date(0) });</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">[Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">edge-runtime.inspect.custom</span><span class="s3">\&quot;</span><span class="s1">)]() {</span><span class="s3">\n    </span><span class="s1">return `ResponseCookies ${JSON.stringify(Object.fromEntries(this._parsed))}`;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">toString() {</span><span class="s3">\n    </span><span class="s1">return [...this._parsed.values()].map(stringifyCookie).join(</span><span class="s3">\&quot;</span><span class="s1">; </span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function replace(bag, headers) {</span><span class="s3">\n  </span><span class="s1">headers.delete(</span><span class="s3">\&quot;</span><span class="s1">set-cookie</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">for (const [, value] of bag) {</span><span class="s3">\n    </span><span class="s1">const serialized = stringifyCookie(value);</span><span class="s3">\n    </span><span class="s1">headers.append(</span><span class="s3">\&quot;</span><span class="s1">set-cookie</span><span class="s3">\&quot;</span><span class="s1">, serialized);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function normalizeCookie(cookie = { name: </span><span class="s3">\&quot;\&quot;</span><span class="s1">, value: </span><span class="s3">\&quot;\&quot; </span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">if (typeof cookie.expires === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">cookie.expires = new Date(cookie.expires);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (cookie.maxAge) {</span><span class="s3">\n    </span><span class="s1">cookie.expires = new Date(Date.now() + cookie.maxAge * 1e3);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (cookie.path === null || cookie.path === void 0) {</span><span class="s3">\n    </span><span class="s1">cookie.path = </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return cookie;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Annotate the CommonJS export names for ESM import in node:</span><span class="s3">\n</span><span class="s1">0 &amp;&amp; (module.exports = {</span><span class="s3">\n  </span><span class="s1">RequestCookies,</span><span class="s3">\n  </span><span class="s1">ResponseCookies,</span><span class="s3">\n  </span><span class="s1">parseCookie,</span><span class="s3">\n  </span><span class="s1">parseSetCookie,</span><span class="s3">\n  </span><span class="s1">stringifyCookie</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;(()=&gt;{</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;if(typeof __nccwpck_require__!==</span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">)__nccwpck_require__.ab=__dirname+</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">;var e={};(()=&gt;{var r=e;</span><span class="s3">\n</span><span class="s1">/*!</span><span class="s3">\n </span><span class="s1">* cookie</span><span class="s3">\n </span><span class="s1">* Copyright(c) 2012-2014 Roman Shtylman</span><span class="s3">\n </span><span class="s1">* Copyright(c) 2015 Douglas Christopher Wilson</span><span class="s3">\n </span><span class="s1">* MIT Licensed</span><span class="s3">\n </span><span class="s1">*/r.parse=parse;r.serialize=serialize;var i=decodeURIComponent;var t=encodeURIComponent;var a=/; */;var n=/^[</span><span class="s3">\\</span><span class="s1">u0009</span><span class="s3">\\</span><span class="s1">u0020-</span><span class="s3">\\</span><span class="s1">u007e</span><span class="s3">\\</span><span class="s1">u0080-</span><span class="s3">\\</span><span class="s1">u00ff]+$/;function parse(e,r){if(typeof e!==</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">argument str must be a string</span><span class="s3">\&quot;</span><span class="s1">)}var t={};var n=r||{};var o=e.split(a);var s=n.decode||i;for(var p=0;p&lt;o.length;p++){var f=o[p];var u=f.indexOf(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">);if(u&lt;0){continue}var v=f.substr(0,u).trim();var c=f.substr(++u,f.length).trim();if('</span><span class="s3">\&quot;</span><span class="s1">'==c[0]){c=c.slice(1,-1)}if(undefined==t[v]){t[v]=tryDecode(c,s)}}return t}function serialize(e,r,i){var a=i||{};var o=a.encode||t;if(typeof o!==</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">option encode is invalid</span><span class="s3">\&quot;</span><span class="s1">)}if(!n.test(e)){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">argument name is invalid</span><span class="s3">\&quot;</span><span class="s1">)}var s=o(r);if(s&amp;&amp;!n.test(s)){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">argument val is invalid</span><span class="s3">\&quot;</span><span class="s1">)}var p=e+</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">+s;if(null!=a.maxAge){var f=a.maxAge-0;if(isNaN(f)||!isFinite(f)){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">option maxAge is invalid</span><span class="s3">\&quot;</span><span class="s1">)}p+=</span><span class="s3">\&quot;</span><span class="s1">; Max-Age=</span><span class="s3">\&quot;</span><span class="s1">+Math.floor(f)}if(a.domain){if(!n.test(a.domain)){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">option domain is invalid</span><span class="s3">\&quot;</span><span class="s1">)}p+=</span><span class="s3">\&quot;</span><span class="s1">; Domain=</span><span class="s3">\&quot;</span><span class="s1">+a.domain}if(a.path){if(!n.test(a.path)){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">option path is invalid</span><span class="s3">\&quot;</span><span class="s1">)}p+=</span><span class="s3">\&quot;</span><span class="s1">; Path=</span><span class="s3">\&quot;</span><span class="s1">+a.path}if(a.expires){if(typeof a.expires.toUTCString!==</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">option expires is invalid</span><span class="s3">\&quot;</span><span class="s1">)}p+=</span><span class="s3">\&quot;</span><span class="s1">; Expires=</span><span class="s3">\&quot;</span><span class="s1">+a.expires.toUTCString()}if(a.httpOnly){p+=</span><span class="s3">\&quot;</span><span class="s1">; HttpOnly</span><span class="s3">\&quot;</span><span class="s1">}if(a.secure){p+=</span><span class="s3">\&quot;</span><span class="s1">; Secure</span><span class="s3">\&quot;</span><span class="s1">}if(a.sameSite){var u=typeof a.sameSite===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">?a.sameSite.toLowerCase():a.sameSite;switch(u){case true:p+=</span><span class="s3">\&quot;</span><span class="s1">; SameSite=Strict</span><span class="s3">\&quot;</span><span class="s1">;break;case</span><span class="s3">\&quot;</span><span class="s1">lax</span><span class="s3">\&quot;</span><span class="s1">:p+=</span><span class="s3">\&quot;</span><span class="s1">; SameSite=Lax</span><span class="s3">\&quot;</span><span class="s1">;break;case</span><span class="s3">\&quot;</span><span class="s1">strict</span><span class="s3">\&quot;</span><span class="s1">:p+=</span><span class="s3">\&quot;</span><span class="s1">; SameSite=Strict</span><span class="s3">\&quot;</span><span class="s1">;break;case</span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;</span><span class="s1">:p+=</span><span class="s3">\&quot;</span><span class="s1">; SameSite=None</span><span class="s3">\&quot;</span><span class="s1">;break;default:throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">option sameSite is invalid</span><span class="s3">\&quot;</span><span class="s1">)}}return p}function tryDecode(e,r){try{return r(e)}catch(r){return e}}})();module.exports=e})();&quot;</span><span class="s0">,</span><span class="s1">&quot;(()=&gt;{</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;if(typeof __nccwpck_require__!==</span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">)__nccwpck_require__.ab=__dirname+</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">;var e={};(()=&gt;{var n=e;Object.defineProperty(n,</span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">,{value:true});n.pathToRegexp=n.tokensToRegexp=n.regexpToFunction=n.match=n.tokensToFunction=n.compile=n.parse=void 0;function lexer(e){var n=[];var r=0;while(r&lt;e.length){var t=e[r];if(t===</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">||t===</span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">||t===</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">){n.push({type:</span><span class="s3">\&quot;</span><span class="s1">MODIFIER</span><span class="s3">\&quot;</span><span class="s1">,index:r,value:e[r++]});continue}if(t===</span><span class="s3">\&quot;\\\\\&quot;</span><span class="s1">){n.push({type:</span><span class="s3">\&quot;</span><span class="s1">ESCAPED_CHAR</span><span class="s3">\&quot;</span><span class="s1">,index:r++,value:e[r++]});continue}if(t===</span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">){n.push({type:</span><span class="s3">\&quot;</span><span class="s1">OPEN</span><span class="s3">\&quot;</span><span class="s1">,index:r,value:e[r++]});continue}if(t===</span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">){n.push({type:</span><span class="s3">\&quot;</span><span class="s1">CLOSE</span><span class="s3">\&quot;</span><span class="s1">,index:r,value:e[r++]});continue}if(t===</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">){var a=</span><span class="s3">\&quot;\&quot;</span><span class="s1">;var i=r+1;while(i&lt;e.length){var o=e.charCodeAt(i);if(o&gt;=48&amp;&amp;o&lt;=57||o&gt;=65&amp;&amp;o&lt;=90||o&gt;=97&amp;&amp;o&lt;=122||o===95){a+=e[i++];continue}break}if(!a)throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Missing parameter name at </span><span class="s3">\&quot;</span><span class="s1">.concat(r));n.push({type:</span><span class="s3">\&quot;</span><span class="s1">NAME</span><span class="s3">\&quot;</span><span class="s1">,index:r,value:a});r=i;continue}if(t===</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">){var c=1;var f=</span><span class="s3">\&quot;\&quot;</span><span class="s1">;var i=r+1;if(e[i]===</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">){throw new TypeError('Pattern cannot start with </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot; </span><span class="s1">at '.concat(i))}while(i&lt;e.length){if(e[i]===</span><span class="s3">\&quot;\\\\\&quot;</span><span class="s1">){f+=e[i++]+e[i++];continue}if(e[i]===</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">){c--;if(c===0){i++;break}}else if(e[i]===</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">){c++;if(e[i+1]!==</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">){throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Capturing groups are not allowed at </span><span class="s3">\&quot;</span><span class="s1">.concat(i))}}f+=e[i++]}if(c)throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Unbalanced pattern at </span><span class="s3">\&quot;</span><span class="s1">.concat(r));if(!f)throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Missing pattern at </span><span class="s3">\&quot;</span><span class="s1">.concat(r));n.push({type:</span><span class="s3">\&quot;</span><span class="s1">PATTERN</span><span class="s3">\&quot;</span><span class="s1">,index:r,value:f});r=i;continue}n.push({type:</span><span class="s3">\&quot;</span><span class="s1">CHAR</span><span class="s3">\&quot;</span><span class="s1">,index:r,value:e[r++]})}n.push({type:</span><span class="s3">\&quot;</span><span class="s1">END</span><span class="s3">\&quot;</span><span class="s1">,index:r,value:</span><span class="s3">\&quot;\&quot;</span><span class="s1">});return n}function parse(e,n){if(n===void 0){n={}}var r=lexer(e);var t=n.prefixes,a=t===void 0?</span><span class="s3">\&quot;</span><span class="s1">./</span><span class="s3">\&quot;</span><span class="s1">:t,i=n.delimiter,o=i===void 0?</span><span class="s3">\&quot;</span><span class="s1">/#?</span><span class="s3">\&quot;</span><span class="s1">:i;var c=[];var f=0;var u=0;var p=</span><span class="s3">\&quot;\&quot;</span><span class="s1">;var tryConsume=function(e){if(u&lt;r.length&amp;&amp;r[u].type===e)return r[u++].value};var mustConsume=function(e){var n=tryConsume(e);if(n!==undefined)return n;var t=r[u],a=t.type,i=t.index;throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Unexpected </span><span class="s3">\&quot;</span><span class="s1">.concat(a,</span><span class="s3">\&quot; </span><span class="s1">at </span><span class="s3">\&quot;</span><span class="s1">).concat(i,</span><span class="s3">\&quot;</span><span class="s1">, expected </span><span class="s3">\&quot;</span><span class="s1">).concat(e))};var consumeText=function(){var e=</span><span class="s3">\&quot;\&quot;</span><span class="s1">;var n;while(n=tryConsume(</span><span class="s3">\&quot;</span><span class="s1">CHAR</span><span class="s3">\&quot;</span><span class="s1">)||tryConsume(</span><span class="s3">\&quot;</span><span class="s1">ESCAPED_CHAR</span><span class="s3">\&quot;</span><span class="s1">)){e+=n}return e};var isSafe=function(e){for(var n=0,r=o;n&lt;r.length;n++){var t=r[n];if(e.indexOf(t)&gt;-1)return true}return false};var safePattern=function(e){var n=c[c.length-1];var r=e||(n&amp;&amp;typeof n===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">?n:</span><span class="s3">\&quot;\&quot;</span><span class="s1">);if(n&amp;&amp;!r){throw new TypeError('Must have text between two parameters, missing text after </span><span class="s3">\&quot;</span><span class="s1">'.concat(n.name,'</span><span class="s3">\&quot;</span><span class="s1">'))}if(!r||isSafe(r))return</span><span class="s3">\&quot;</span><span class="s1">[^</span><span class="s3">\&quot;</span><span class="s1">.concat(escapeString(o),</span><span class="s3">\&quot;</span><span class="s1">]+?</span><span class="s3">\&quot;</span><span class="s1">);return</span><span class="s3">\&quot;</span><span class="s1">(?:(?!</span><span class="s3">\&quot;</span><span class="s1">.concat(escapeString(r),</span><span class="s3">\&quot;</span><span class="s1">)[^</span><span class="s3">\&quot;</span><span class="s1">).concat(escapeString(o),</span><span class="s3">\&quot;</span><span class="s1">])+?</span><span class="s3">\&quot;</span><span class="s1">)};while(u&lt;r.length){var v=tryConsume(</span><span class="s3">\&quot;</span><span class="s1">CHAR</span><span class="s3">\&quot;</span><span class="s1">);var s=tryConsume(</span><span class="s3">\&quot;</span><span class="s1">NAME</span><span class="s3">\&quot;</span><span class="s1">);var d=tryConsume(</span><span class="s3">\&quot;</span><span class="s1">PATTERN</span><span class="s3">\&quot;</span><span class="s1">);if(s||d){var g=v||</span><span class="s3">\&quot;\&quot;</span><span class="s1">;if(a.indexOf(g)===-1){p+=g;g=</span><span class="s3">\&quot;\&quot;</span><span class="s1">}if(p){c.push(p);p=</span><span class="s3">\&quot;\&quot;</span><span class="s1">}c.push({name:s||f++,prefix:g,suffix:</span><span class="s3">\&quot;\&quot;</span><span class="s1">,pattern:d||safePattern(g),modifier:tryConsume(</span><span class="s3">\&quot;</span><span class="s1">MODIFIER</span><span class="s3">\&quot;</span><span class="s1">)||</span><span class="s3">\&quot;\&quot;</span><span class="s1">});continue}var x=v||tryConsume(</span><span class="s3">\&quot;</span><span class="s1">ESCAPED_CHAR</span><span class="s3">\&quot;</span><span class="s1">);if(x){p+=x;continue}if(p){c.push(p);p=</span><span class="s3">\&quot;\&quot;</span><span class="s1">}var h=tryConsume(</span><span class="s3">\&quot;</span><span class="s1">OPEN</span><span class="s3">\&quot;</span><span class="s1">);if(h){var g=consumeText();var l=tryConsume(</span><span class="s3">\&quot;</span><span class="s1">NAME</span><span class="s3">\&quot;</span><span class="s1">)||</span><span class="s3">\&quot;\&quot;</span><span class="s1">;var m=tryConsume(</span><span class="s3">\&quot;</span><span class="s1">PATTERN</span><span class="s3">\&quot;</span><span class="s1">)||</span><span class="s3">\&quot;\&quot;</span><span class="s1">;var T=consumeText();mustConsume(</span><span class="s3">\&quot;</span><span class="s1">CLOSE</span><span class="s3">\&quot;</span><span class="s1">);c.push({name:l||(m?f++:</span><span class="s3">\&quot;\&quot;</span><span class="s1">),pattern:l&amp;&amp;!m?safePattern(g):m,prefix:g,suffix:T,modifier:tryConsume(</span><span class="s3">\&quot;</span><span class="s1">MODIFIER</span><span class="s3">\&quot;</span><span class="s1">)||</span><span class="s3">\&quot;\&quot;</span><span class="s1">});continue}mustConsume(</span><span class="s3">\&quot;</span><span class="s1">END</span><span class="s3">\&quot;</span><span class="s1">)}return c}n.parse=parse;function compile(e,n){return tokensToFunction(parse(e,n),n)}n.compile=compile;function tokensToFunction(e,n){if(n===void 0){n={}}var r=flags(n);var t=n.encode,a=t===void 0?function(e){return e}:t,i=n.validate,o=i===void 0?true:i;var c=e.map((function(e){if(typeof e===</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">){return new RegExp(</span><span class="s3">\&quot;</span><span class="s1">^(?:</span><span class="s3">\&quot;</span><span class="s1">.concat(e.pattern,</span><span class="s3">\&quot;</span><span class="s1">)$</span><span class="s3">\&quot;</span><span class="s1">),r)}}));return function(n){var r=</span><span class="s3">\&quot;\&quot;</span><span class="s1">;for(var t=0;t&lt;e.length;t++){var i=e[t];if(typeof i===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">){r+=i;continue}var f=n?n[i.name]:undefined;var u=i.modifier===</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">||i.modifier===</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">;var p=i.modifier===</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">||i.modifier===</span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">;if(Array.isArray(f)){if(!p){throw new TypeError('Expected </span><span class="s3">\&quot;</span><span class="s1">'.concat(i.name,'</span><span class="s3">\&quot; </span><span class="s1">to not repeat, but got an array'))}if(f.length===0){if(u)continue;throw new TypeError('Expected </span><span class="s3">\&quot;</span><span class="s1">'.concat(i.name,'</span><span class="s3">\&quot; </span><span class="s1">to not be empty'))}for(var v=0;v&lt;f.length;v++){var s=a(f[v],i);if(o&amp;&amp;!c[t].test(s)){throw new TypeError('Expected all </span><span class="s3">\&quot;</span><span class="s1">'.concat(i.name,'</span><span class="s3">\&quot; </span><span class="s1">to match </span><span class="s3">\&quot;</span><span class="s1">').concat(i.pattern,'</span><span class="s3">\&quot;</span><span class="s1">, but got </span><span class="s3">\&quot;</span><span class="s1">').concat(s,'</span><span class="s3">\&quot;</span><span class="s1">'))}r+=i.prefix+s+i.suffix}continue}if(typeof f===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">||typeof f===</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">){var s=a(String(f),i);if(o&amp;&amp;!c[t].test(s)){throw new TypeError('Expected </span><span class="s3">\&quot;</span><span class="s1">'.concat(i.name,'</span><span class="s3">\&quot; </span><span class="s1">to match </span><span class="s3">\&quot;</span><span class="s1">').concat(i.pattern,'</span><span class="s3">\&quot;</span><span class="s1">, but got </span><span class="s3">\&quot;</span><span class="s1">').concat(s,'</span><span class="s3">\&quot;</span><span class="s1">'))}r+=i.prefix+s+i.suffix;continue}if(u)continue;var d=p?</span><span class="s3">\&quot;</span><span class="s1">an array</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">a string</span><span class="s3">\&quot;</span><span class="s1">;throw new TypeError('Expected </span><span class="s3">\&quot;</span><span class="s1">'.concat(i.name,'</span><span class="s3">\&quot; </span><span class="s1">to be ').concat(d))}return r}}n.tokensToFunction=tokensToFunction;function match(e,n){var r=[];var t=pathToRegexp(e,r,n);return regexpToFunction(t,r,n)}n.match=match;function regexpToFunction(e,n,r){if(r===void 0){r={}}var t=r.decode,a=t===void 0?function(e){return e}:t;return function(r){var t=e.exec(r);if(!t)return false;var i=t[0],o=t.index;var c=Object.create(null);var _loop_1=function(e){if(t[e]===undefined)return</span><span class="s3">\&quot;</span><span class="s1">continue</span><span class="s3">\&quot;</span><span class="s1">;var r=n[e-1];if(r.modifier===</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">||r.modifier===</span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">){c[r.name]=t[e].split(r.prefix+r.suffix).map((function(e){return a(e,r)}))}else{c[r.name]=a(t[e],r)}};for(var f=1;f&lt;t.length;f++){_loop_1(f)}return{path:i,index:o,params:c}}}n.regexpToFunction=regexpToFunction;function escapeString(e){return e.replace(/([.+*?=^!:${}()[</span><span class="s3">\\</span><span class="s1">]|/</span><span class="s3">\\\\</span><span class="s1">])/g,</span><span class="s3">\&quot;\\\\</span><span class="s1">$1</span><span class="s3">\&quot;</span><span class="s1">)}function flags(e){return e&amp;&amp;e.sensitive?</span><span class="s3">\&quot;\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">i</span><span class="s3">\&quot;</span><span class="s1">}function regexpToRegexp(e,n){if(!n)return e;var r=/</span><span class="s3">\\</span><span class="s1">((?:</span><span class="s3">\\</span><span class="s1">?&lt;(.*?)&gt;)?(?!</span><span class="s3">\\</span><span class="s1">?)/g;var t=0;var a=r.exec(e.source);while(a){n.push({name:a[1]||t++,prefix:</span><span class="s3">\&quot;\&quot;</span><span class="s1">,suffix:</span><span class="s3">\&quot;\&quot;</span><span class="s1">,modifier:</span><span class="s3">\&quot;\&quot;</span><span class="s1">,pattern:</span><span class="s3">\&quot;\&quot;</span><span class="s1">});a=r.exec(e.source)}return e}function arrayToRegexp(e,n,r){var t=e.map((function(e){return pathToRegexp(e,n,r).source}));return new RegExp(</span><span class="s3">\&quot;</span><span class="s1">(?:</span><span class="s3">\&quot;</span><span class="s1">.concat(t.join(</span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">),flags(r))}function stringToRegexp(e,n,r){return tokensToRegexp(parse(e,r),n,r)}function tokensToRegexp(e,n,r){if(r===void 0){r={}}var t=r.strict,a=t===void 0?false:t,i=r.start,o=i===void 0?true:i,c=r.end,f=c===void 0?true:c,u=r.encode,p=u===void 0?function(e){return e}:u,v=r.delimiter,s=v===void 0?</span><span class="s3">\&quot;</span><span class="s1">/#?</span><span class="s3">\&quot;</span><span class="s1">:v,d=r.endsWith,g=d===void 0?</span><span class="s3">\&quot;\&quot;</span><span class="s1">:d;var x=</span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">.concat(escapeString(g),</span><span class="s3">\&quot;</span><span class="s1">]|$</span><span class="s3">\&quot;</span><span class="s1">);var h=</span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">.concat(escapeString(s),</span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">);var l=o?</span><span class="s3">\&quot;</span><span class="s1">^</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;\&quot;</span><span class="s1">;for(var m=0,T=e;m&lt;T.length;m++){var E=T[m];if(typeof E===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">){l+=escapeString(p(E))}else{var w=escapeString(p(E.prefix));var y=escapeString(p(E.suffix));if(E.pattern){if(n)n.push(E);if(w||y){if(E.modifier===</span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">||E.modifier===</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">){var R=E.modifier===</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;\&quot;</span><span class="s1">;l+=</span><span class="s3">\&quot;</span><span class="s1">(?:</span><span class="s3">\&quot;</span><span class="s1">.concat(w,</span><span class="s3">\&quot;</span><span class="s1">((?:</span><span class="s3">\&quot;</span><span class="s1">).concat(E.pattern,</span><span class="s3">\&quot;</span><span class="s1">)(?:</span><span class="s3">\&quot;</span><span class="s1">).concat(y).concat(w,</span><span class="s3">\&quot;</span><span class="s1">(?:</span><span class="s3">\&quot;</span><span class="s1">).concat(E.pattern,</span><span class="s3">\&quot;</span><span class="s1">))*)</span><span class="s3">\&quot;</span><span class="s1">).concat(y,</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">).concat(R)}else{l+=</span><span class="s3">\&quot;</span><span class="s1">(?:</span><span class="s3">\&quot;</span><span class="s1">.concat(w,</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">).concat(E.pattern,</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">).concat(y,</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">).concat(E.modifier)}}else{if(E.modifier===</span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">||E.modifier===</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">){throw new TypeError('Can not repeat </span><span class="s3">\&quot;</span><span class="s1">'.concat(E.name,'</span><span class="s3">\&quot; </span><span class="s1">without a prefix and suffix'))}l+=</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">.concat(E.pattern,</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">).concat(E.modifier)}}else{l+=</span><span class="s3">\&quot;</span><span class="s1">(?:</span><span class="s3">\&quot;</span><span class="s1">.concat(w).concat(y,</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">).concat(E.modifier)}}}if(f){if(!a)l+=</span><span class="s3">\&quot;\&quot;</span><span class="s1">.concat(h,</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">);l+=!r.endsWith?</span><span class="s3">\&quot;</span><span class="s1">$</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">(?=</span><span class="s3">\&quot;</span><span class="s1">.concat(x,</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">)}else{var A=e[e.length-1];var _=typeof A===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">?h.indexOf(A[A.length-1])&gt;-1:A===undefined;if(!a){l+=</span><span class="s3">\&quot;</span><span class="s1">(?:</span><span class="s3">\&quot;</span><span class="s1">.concat(h,</span><span class="s3">\&quot;</span><span class="s1">(?=</span><span class="s3">\&quot;</span><span class="s1">).concat(x,</span><span class="s3">\&quot;</span><span class="s1">))?</span><span class="s3">\&quot;</span><span class="s1">)}if(!_){l+=</span><span class="s3">\&quot;</span><span class="s1">(?=</span><span class="s3">\&quot;</span><span class="s1">.concat(h,</span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot;</span><span class="s1">).concat(x,</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">)}}return new RegExp(l,flags(r))}n.tokensToRegexp=tokensToRegexp;function pathToRegexp(e,n,r){if(e instanceof RegExp)return regexpToRegexp(e,n);if(Array.isArray(e))return arrayToRegexp(e,n,r);return stringToRegexp(e,n,r)}n.pathToRegexp=pathToRegexp})();module.exports=e})();&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* @license React</span><span class="s3">\n </span><span class="s1">* react-is.production.js</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Copyright (c) Meta Platforms, Inc. and affiliates.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This source code is licensed under the MIT license found in the</span><span class="s3">\n </span><span class="s1">* LICENSE file in the root directory of this source tree.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">var REACT_ELEMENT_TYPE = Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.transitional.element</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">REACT_PORTAL_TYPE = Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.portal</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">REACT_FRAGMENT_TYPE = Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.fragment</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">REACT_STRICT_MODE_TYPE = Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.strict_mode</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">REACT_PROFILER_TYPE = Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.profiler</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">REACT_CONSUMER_TYPE = Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.consumer</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">REACT_CONTEXT_TYPE = Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.context</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">REACT_FORWARD_REF_TYPE = Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.forward_ref</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">REACT_SUSPENSE_TYPE = Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.suspense</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">REACT_SUSPENSE_LIST_TYPE = Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.suspense_list</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">REACT_MEMO_TYPE = Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.memo</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">REACT_LAZY_TYPE = Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.lazy</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">REACT_VIEW_TRANSITION_TYPE = Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.view_transition</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">REACT_CLIENT_REFERENCE = Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.client.reference</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">function typeOf(object) {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">=== typeof object &amp;&amp; null !== object) {</span><span class="s3">\n    </span><span class="s1">var $$typeof = object.$$typeof;</span><span class="s3">\n    </span><span class="s1">switch ($$typeof) {</span><span class="s3">\n      </span><span class="s1">case REACT_ELEMENT_TYPE:</span><span class="s3">\n        </span><span class="s1">switch (((object = object.type), object)) {</span><span class="s3">\n          </span><span class="s1">case REACT_FRAGMENT_TYPE:</span><span class="s3">\n          </span><span class="s1">case REACT_PROFILER_TYPE:</span><span class="s3">\n          </span><span class="s1">case REACT_STRICT_MODE_TYPE:</span><span class="s3">\n          </span><span class="s1">case REACT_SUSPENSE_TYPE:</span><span class="s3">\n          </span><span class="s1">case REACT_SUSPENSE_LIST_TYPE:</span><span class="s3">\n          </span><span class="s1">case REACT_VIEW_TRANSITION_TYPE:</span><span class="s3">\n            </span><span class="s1">return object;</span><span class="s3">\n          </span><span class="s1">default:</span><span class="s3">\n            </span><span class="s1">switch (((object = object &amp;&amp; object.$$typeof), object)) {</span><span class="s3">\n              </span><span class="s1">case REACT_CONTEXT_TYPE:</span><span class="s3">\n              </span><span class="s1">case REACT_FORWARD_REF_TYPE:</span><span class="s3">\n              </span><span class="s1">case REACT_LAZY_TYPE:</span><span class="s3">\n              </span><span class="s1">case REACT_MEMO_TYPE:</span><span class="s3">\n                </span><span class="s1">return object;</span><span class="s3">\n              </span><span class="s1">case REACT_CONSUMER_TYPE:</span><span class="s3">\n                </span><span class="s1">return object;</span><span class="s3">\n              </span><span class="s1">default:</span><span class="s3">\n                </span><span class="s1">return $$typeof;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case REACT_PORTAL_TYPE:</span><span class="s3">\n        </span><span class="s1">return $$typeof;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.ContextConsumer = REACT_CONSUMER_TYPE;</span><span class="s3">\n</span><span class="s1">exports.ContextProvider = REACT_CONTEXT_TYPE;</span><span class="s3">\n</span><span class="s1">exports.Element = REACT_ELEMENT_TYPE;</span><span class="s3">\n</span><span class="s1">exports.ForwardRef = REACT_FORWARD_REF_TYPE;</span><span class="s3">\n</span><span class="s1">exports.Fragment = REACT_FRAGMENT_TYPE;</span><span class="s3">\n</span><span class="s1">exports.Lazy = REACT_LAZY_TYPE;</span><span class="s3">\n</span><span class="s1">exports.Memo = REACT_MEMO_TYPE;</span><span class="s3">\n</span><span class="s1">exports.Portal = REACT_PORTAL_TYPE;</span><span class="s3">\n</span><span class="s1">exports.Profiler = REACT_PROFILER_TYPE;</span><span class="s3">\n</span><span class="s1">exports.StrictMode = REACT_STRICT_MODE_TYPE;</span><span class="s3">\n</span><span class="s1">exports.Suspense = REACT_SUSPENSE_TYPE;</span><span class="s3">\n</span><span class="s1">exports.SuspenseList = REACT_SUSPENSE_LIST_TYPE;</span><span class="s3">\n</span><span class="s1">exports.isContextConsumer = function (object) {</span><span class="s3">\n  </span><span class="s1">return typeOf(object) === REACT_CONSUMER_TYPE;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.isContextProvider = function (object) {</span><span class="s3">\n  </span><span class="s1">return typeOf(object) === REACT_CONTEXT_TYPE;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.isElement = function (object) {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    \&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">=== typeof object &amp;&amp;</span><span class="s3">\n    </span><span class="s1">null !== object &amp;&amp;</span><span class="s3">\n    </span><span class="s1">object.$$typeof === REACT_ELEMENT_TYPE</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.isForwardRef = function (object) {</span><span class="s3">\n  </span><span class="s1">return typeOf(object) === REACT_FORWARD_REF_TYPE;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.isFragment = function (object) {</span><span class="s3">\n  </span><span class="s1">return typeOf(object) === REACT_FRAGMENT_TYPE;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.isLazy = function (object) {</span><span class="s3">\n  </span><span class="s1">return typeOf(object) === REACT_LAZY_TYPE;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.isMemo = function (object) {</span><span class="s3">\n  </span><span class="s1">return typeOf(object) === REACT_MEMO_TYPE;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.isPortal = function (object) {</span><span class="s3">\n  </span><span class="s1">return typeOf(object) === REACT_PORTAL_TYPE;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.isProfiler = function (object) {</span><span class="s3">\n  </span><span class="s1">return typeOf(object) === REACT_PROFILER_TYPE;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.isStrictMode = function (object) {</span><span class="s3">\n  </span><span class="s1">return typeOf(object) === REACT_STRICT_MODE_TYPE;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.isSuspense = function (object) {</span><span class="s3">\n  </span><span class="s1">return typeOf(object) === REACT_SUSPENSE_TYPE;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.isSuspenseList = function (object) {</span><span class="s3">\n  </span><span class="s1">return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.isValidElementType = function (type) {</span><span class="s3">\n  </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">=== typeof type ||</span><span class="s3">\n    \&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">=== typeof type ||</span><span class="s3">\n    </span><span class="s1">type === REACT_FRAGMENT_TYPE ||</span><span class="s3">\n    </span><span class="s1">type === REACT_PROFILER_TYPE ||</span><span class="s3">\n    </span><span class="s1">type === REACT_STRICT_MODE_TYPE ||</span><span class="s3">\n    </span><span class="s1">type === REACT_SUSPENSE_TYPE ||</span><span class="s3">\n    </span><span class="s1">type === REACT_SUSPENSE_LIST_TYPE ||</span><span class="s3">\n    </span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">=== typeof type &amp;&amp;</span><span class="s3">\n      </span><span class="s1">null !== type &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(type.$$typeof === REACT_LAZY_TYPE ||</span><span class="s3">\n        </span><span class="s1">type.$$typeof === REACT_MEMO_TYPE ||</span><span class="s3">\n        </span><span class="s1">type.$$typeof === REACT_CONTEXT_TYPE ||</span><span class="s3">\n        </span><span class="s1">type.$$typeof === REACT_CONSUMER_TYPE ||</span><span class="s3">\n        </span><span class="s1">type.$$typeof === REACT_FORWARD_REF_TYPE ||</span><span class="s3">\n        </span><span class="s1">type.$$typeof === REACT_CLIENT_REFERENCE ||</span><span class="s3">\n        </span><span class="s1">void 0 !== type.getModuleId))</span><span class="s3">\n    </span><span class="s1">? !0</span><span class="s3">\n    </span><span class="s1">: !1;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">exports.typeOf = typeOf;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;'use strict';</span><span class="s3">\n\n</span><span class="s1">if (process.env.NODE_ENV === 'production') {</span><span class="s3">\n  </span><span class="s1">module.exports = require('./cjs/react-is.production.js');</span><span class="s3">\n</span><span class="s1">} else {</span><span class="s3">\n  </span><span class="s1">module.exports = require('./cjs/react-is.development.js');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;(()=&gt;{</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;var e={511:e=&gt;{e.exports=({onlyFirst:e=false}={})=&gt;{const r=[</span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">u001B</span><span class="s3">\\\\</span><span class="s1">u009B][[</span><span class="s3">\\\\</span><span class="s1">]()#;?]*(?:(?:(?:(?:;[-a-zA-Z</span><span class="s3">\\\\</span><span class="s1">d</span><span class="s3">\\\\</span><span class="s1">/#&amp;.:=?%@~_]+)*|[a-zA-Z</span><span class="s3">\\\\</span><span class="s1">d]+(?:;[-a-zA-Z</span><span class="s3">\\\\</span><span class="s1">d</span><span class="s3">\\\\</span><span class="s1">/#&amp;.:=?%@~_]*)*)?</span><span class="s3">\\\\</span><span class="s1">u0007)</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">(?:(?:</span><span class="s3">\\\\</span><span class="s1">d{1,4}(?:;</span><span class="s3">\\\\</span><span class="s1">d{0,4})*)?[</span><span class="s3">\\\\</span><span class="s1">dA-PR-TZcf-ntqry=&gt;&lt;~]))</span><span class="s3">\&quot;</span><span class="s1">].join(</span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot;</span><span class="s1">);return new RegExp(r,e?undefined:</span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">)}},532:(e,r,_)=&gt;{const t=_(511);e.exports=e=&gt;typeof e===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">?e.replace(t(),</span><span class="s3">\&quot;\&quot;</span><span class="s1">):e}};var r={};function __nccwpck_require__(_){var t=r[_];if(t!==undefined){return t.exports}var a=r[_]={exports:{}};var n=true;try{e[_](a,a.exports,__nccwpck_require__);n=false}finally{if(n)delete r[_]}return a.exports}if(typeof __nccwpck_require__!==</span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">)__nccwpck_require__.ab=__dirname+</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">;var _=__nccwpck_require__(532);module.exports=_})();&quot;</span><span class="s0">,</span><span class="s1">&quot;// ISC License</span><span class="s3">\n\n</span><span class="s1">// Copyright (c) 2021 Alexey Raspopov, Kostiantyn Denysov, Anton Verinov</span><span class="s3">\n\n</span><span class="s1">// Permission to use, copy, modify, and/or distribute this software for any</span><span class="s3">\n</span><span class="s1">// purpose with or without fee is hereby granted, provided that the above</span><span class="s3">\n</span><span class="s1">// copyright notice and this permission notice appear in all copies.</span><span class="s3">\n\n</span><span class="s1">// THE SOFTWARE IS PROVIDED </span><span class="s3">\&quot;</span><span class="s1">AS IS</span><span class="s3">\&quot; </span><span class="s1">AND THE AUTHOR DISCLAIMS ALL WARRANTIES</span><span class="s3">\n</span><span class="s1">// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF</span><span class="s3">\n</span><span class="s1">// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR</span><span class="s3">\n</span><span class="s1">// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES</span><span class="s3">\n</span><span class="s1">// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</span><span class="s3">\n</span><span class="s1">// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</span><span class="s3">\n</span><span class="s1">// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// https://github.com/alexeyraspopov/picocolors/blob/b6261487e7b81aaab2440e397a356732cad9e342/picocolors.js#L1</span><span class="s3">\n\n</span><span class="s1">const { env, stdout } = globalThis?.process ?? {}</span><span class="s3">\n\n</span><span class="s1">const enabled =</span><span class="s3">\n  </span><span class="s1">env &amp;&amp;</span><span class="s3">\n  </span><span class="s1">!env.NO_COLOR &amp;&amp;</span><span class="s3">\n  </span><span class="s1">(env.FORCE_COLOR || (stdout?.isTTY &amp;&amp; !env.CI &amp;&amp; env.TERM !== 'dumb'))</span><span class="s3">\n\n</span><span class="s1">const replaceClose = (</span><span class="s3">\n  </span><span class="s1">str: string,</span><span class="s3">\n  </span><span class="s1">close: string,</span><span class="s3">\n  </span><span class="s1">replace: string,</span><span class="s3">\n  </span><span class="s1">index: number</span><span class="s3">\n</span><span class="s1">): string =&gt; {</span><span class="s3">\n  </span><span class="s1">const start = str.substring(0, index) + replace</span><span class="s3">\n  </span><span class="s1">const end = str.substring(index + close.length)</span><span class="s3">\n  </span><span class="s1">const nextIndex = end.indexOf(close)</span><span class="s3">\n  </span><span class="s1">return ~nextIndex</span><span class="s3">\n    </span><span class="s1">? start + replaceClose(end, close, replace, nextIndex)</span><span class="s3">\n    </span><span class="s1">: start + end</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const formatter = (open: string, close: string, replace = open) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (!enabled) return String</span><span class="s3">\n  </span><span class="s1">return (input: string) =&gt; {</span><span class="s3">\n    </span><span class="s1">const string = '' + input</span><span class="s3">\n    </span><span class="s1">const index = string.indexOf(close, open.length)</span><span class="s3">\n    </span><span class="s1">return ~index</span><span class="s3">\n      </span><span class="s1">? open + replaceClose(string, close, replace, index) + close</span><span class="s3">\n      </span><span class="s1">: open + string + close</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const reset = enabled ? (s: string) =&gt; `</span><span class="s3">\\</span><span class="s1">x1b[0m${s}</span><span class="s3">\\</span><span class="s1">x1b[0m` : String</span><span class="s3">\n</span><span class="s1">export const bold = formatter('</span><span class="s3">\\</span><span class="s1">x1b[1m', '</span><span class="s3">\\</span><span class="s1">x1b[22m', '</span><span class="s3">\\</span><span class="s1">x1b[22m</span><span class="s3">\\</span><span class="s1">x1b[1m')</span><span class="s3">\n</span><span class="s1">export const dim = formatter('</span><span class="s3">\\</span><span class="s1">x1b[2m', '</span><span class="s3">\\</span><span class="s1">x1b[22m', '</span><span class="s3">\\</span><span class="s1">x1b[22m</span><span class="s3">\\</span><span class="s1">x1b[2m')</span><span class="s3">\n</span><span class="s1">export const italic = formatter('</span><span class="s3">\\</span><span class="s1">x1b[3m', '</span><span class="s3">\\</span><span class="s1">x1b[23m')</span><span class="s3">\n</span><span class="s1">export const underline = formatter('</span><span class="s3">\\</span><span class="s1">x1b[4m', '</span><span class="s3">\\</span><span class="s1">x1b[24m')</span><span class="s3">\n</span><span class="s1">export const inverse = formatter('</span><span class="s3">\\</span><span class="s1">x1b[7m', '</span><span class="s3">\\</span><span class="s1">x1b[27m')</span><span class="s3">\n</span><span class="s1">export const hidden = formatter('</span><span class="s3">\\</span><span class="s1">x1b[8m', '</span><span class="s3">\\</span><span class="s1">x1b[28m')</span><span class="s3">\n</span><span class="s1">export const strikethrough = formatter('</span><span class="s3">\\</span><span class="s1">x1b[9m', '</span><span class="s3">\\</span><span class="s1">x1b[29m')</span><span class="s3">\n</span><span class="s1">export const black = formatter('</span><span class="s3">\\</span><span class="s1">x1b[30m', '</span><span class="s3">\\</span><span class="s1">x1b[39m')</span><span class="s3">\n</span><span class="s1">export const red = formatter('</span><span class="s3">\\</span><span class="s1">x1b[31m', '</span><span class="s3">\\</span><span class="s1">x1b[39m')</span><span class="s3">\n</span><span class="s1">export const green = formatter('</span><span class="s3">\\</span><span class="s1">x1b[32m', '</span><span class="s3">\\</span><span class="s1">x1b[39m')</span><span class="s3">\n</span><span class="s1">export const yellow = formatter('</span><span class="s3">\\</span><span class="s1">x1b[33m', '</span><span class="s3">\\</span><span class="s1">x1b[39m')</span><span class="s3">\n</span><span class="s1">export const blue = formatter('</span><span class="s3">\\</span><span class="s1">x1b[34m', '</span><span class="s3">\\</span><span class="s1">x1b[39m')</span><span class="s3">\n</span><span class="s1">export const magenta = formatter('</span><span class="s3">\\</span><span class="s1">x1b[35m', '</span><span class="s3">\\</span><span class="s1">x1b[39m')</span><span class="s3">\n</span><span class="s1">export const purple = formatter('</span><span class="s3">\\</span><span class="s1">x1b[38;2;173;127;168m', '</span><span class="s3">\\</span><span class="s1">x1b[39m')</span><span class="s3">\n</span><span class="s1">export const cyan = formatter('</span><span class="s3">\\</span><span class="s1">x1b[36m', '</span><span class="s3">\\</span><span class="s1">x1b[39m')</span><span class="s3">\n</span><span class="s1">export const white = formatter('</span><span class="s3">\\</span><span class="s1">x1b[37m', '</span><span class="s3">\\</span><span class="s1">x1b[39m')</span><span class="s3">\n</span><span class="s1">export const gray = formatter('</span><span class="s3">\\</span><span class="s1">x1b[90m', '</span><span class="s3">\\</span><span class="s1">x1b[39m')</span><span class="s3">\n</span><span class="s1">export const bgBlack = formatter('</span><span class="s3">\\</span><span class="s1">x1b[40m', '</span><span class="s3">\\</span><span class="s1">x1b[49m')</span><span class="s3">\n</span><span class="s1">export const bgRed = formatter('</span><span class="s3">\\</span><span class="s1">x1b[41m', '</span><span class="s3">\\</span><span class="s1">x1b[49m')</span><span class="s3">\n</span><span class="s1">export const bgGreen = formatter('</span><span class="s3">\\</span><span class="s1">x1b[42m', '</span><span class="s3">\\</span><span class="s1">x1b[49m')</span><span class="s3">\n</span><span class="s1">export const bgYellow = formatter('</span><span class="s3">\\</span><span class="s1">x1b[43m', '</span><span class="s3">\\</span><span class="s1">x1b[49m')</span><span class="s3">\n</span><span class="s1">export const bgBlue = formatter('</span><span class="s3">\\</span><span class="s1">x1b[44m', '</span><span class="s3">\\</span><span class="s1">x1b[49m')</span><span class="s3">\n</span><span class="s1">export const bgMagenta = formatter('</span><span class="s3">\\</span><span class="s1">x1b[45m', '</span><span class="s3">\\</span><span class="s1">x1b[49m')</span><span class="s3">\n</span><span class="s1">export const bgCyan = formatter('</span><span class="s3">\\</span><span class="s1">x1b[46m', '</span><span class="s3">\\</span><span class="s1">x1b[49m')</span><span class="s3">\n</span><span class="s1">export const bgWhite = formatter('</span><span class="s3">\\</span><span class="s1">x1b[47m', '</span><span class="s3">\\</span><span class="s1">x1b[49m')</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Node in the doubly-linked list used for LRU tracking.</span><span class="s3">\n </span><span class="s1">* Each node represents a cache entry with bidirectional pointers.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class LRUNode&lt;T&gt; {</span><span class="s3">\n  </span><span class="s1">public readonly key: string</span><span class="s3">\n  </span><span class="s1">public data: T</span><span class="s3">\n  </span><span class="s1">public size: number</span><span class="s3">\n  </span><span class="s1">public prev: LRUNode&lt;T&gt; | SentinelNode&lt;T&gt; | null = null</span><span class="s3">\n  </span><span class="s1">public next: LRUNode&lt;T&gt; | SentinelNode&lt;T&gt; | null = null</span><span class="s3">\n\n  </span><span class="s1">constructor(key: string, data: T, size: number) {</span><span class="s3">\n    </span><span class="s1">this.key = key</span><span class="s3">\n    </span><span class="s1">this.data = data</span><span class="s3">\n    </span><span class="s1">this.size = size</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Sentinel node used for head/tail boundaries.</span><span class="s3">\n </span><span class="s1">* These nodes don't contain actual cache data but simplify list operations.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class SentinelNode&lt;T&gt; {</span><span class="s3">\n  </span><span class="s1">public prev: LRUNode&lt;T&gt; | SentinelNode&lt;T&gt; | null = null</span><span class="s3">\n  </span><span class="s1">public next: LRUNode&lt;T&gt; | SentinelNode&lt;T&gt; | null = null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* LRU (Least Recently Used) Cache implementation using a doubly-linked list</span><span class="s3">\n </span><span class="s1">* and hash map for O(1) operations.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Algorithm:</span><span class="s3">\n </span><span class="s1">* - Uses a doubly-linked list to maintain access order (most recent at head)</span><span class="s3">\n </span><span class="s1">* - Hash map provides O(1) key-to-node lookup</span><span class="s3">\n </span><span class="s1">* - Sentinel head/tail nodes simplify edge case handling</span><span class="s3">\n </span><span class="s1">* - Size-based eviction supports custom size calculation functions</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Data Structure Layout:</span><span class="s3">\n </span><span class="s1">* HEAD &lt;-&gt; [most recent] &lt;-&gt; ... &lt;-&gt; [least recent] &lt;-&gt; TAIL</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Operations:</span><span class="s3">\n </span><span class="s1">* - get(): Move accessed node to head (mark as most recent)</span><span class="s3">\n </span><span class="s1">* - set(): Add new node at head, evict from tail if over capacity</span><span class="s3">\n </span><span class="s1">* - Eviction: Remove least recent node (tail.prev) when size exceeds limit</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class LRUCache&lt;T&gt; {</span><span class="s3">\n  </span><span class="s1">private readonly cache: Map&lt;string, LRUNode&lt;T&gt;&gt; = new Map()</span><span class="s3">\n  </span><span class="s1">private readonly head: SentinelNode&lt;T&gt;</span><span class="s3">\n  </span><span class="s1">private readonly tail: SentinelNode&lt;T&gt;</span><span class="s3">\n  </span><span class="s1">private totalSize: number = 0</span><span class="s3">\n  </span><span class="s1">private readonly maxSize: number</span><span class="s3">\n  </span><span class="s1">private readonly calculateSize: ((value: T) =&gt; number) | undefined</span><span class="s3">\n\n  </span><span class="s1">constructor(maxSize: number, calculateSize?: (value: T) =&gt; number) {</span><span class="s3">\n    </span><span class="s1">this.maxSize = maxSize</span><span class="s3">\n    </span><span class="s1">this.calculateSize = calculateSize</span><span class="s3">\n\n    </span><span class="s1">// Create sentinel nodes to simplify doubly-linked list operations</span><span class="s3">\n    </span><span class="s1">// HEAD &lt;-&gt; TAIL (empty list)</span><span class="s3">\n    </span><span class="s1">this.head = new SentinelNode&lt;T&gt;()</span><span class="s3">\n    </span><span class="s1">this.tail = new SentinelNode&lt;T&gt;()</span><span class="s3">\n    </span><span class="s1">this.head.next = this.tail</span><span class="s3">\n    </span><span class="s1">this.tail.prev = this.head</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Adds a node immediately after the head (marks as most recently used).</span><span class="s3">\n   </span><span class="s1">* Used when inserting new items or when an item is accessed.</span><span class="s3">\n   </span><span class="s1">* PRECONDITION: node must be disconnected (prev/next should be null)</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private addToHead(node: LRUNode&lt;T&gt;): void {</span><span class="s3">\n    </span><span class="s1">node.prev = this.head</span><span class="s3">\n    </span><span class="s1">node.next = this.head.next</span><span class="s3">\n    </span><span class="s1">// head.next is always non-null (points to tail or another node)</span><span class="s3">\n    </span><span class="s1">this.head.next!.prev = node</span><span class="s3">\n    </span><span class="s1">this.head.next = node</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Removes a node from its current position in the doubly-linked list.</span><span class="s3">\n   </span><span class="s1">* Updates the prev/next pointers of adjacent nodes to maintain list integrity.</span><span class="s3">\n   </span><span class="s1">* PRECONDITION: node must be connected (prev/next are non-null)</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private removeNode(node: LRUNode&lt;T&gt;): void {</span><span class="s3">\n    </span><span class="s1">// Connected nodes always have non-null prev/next</span><span class="s3">\n    </span><span class="s1">node.prev!.next = node.next</span><span class="s3">\n    </span><span class="s1">node.next!.prev = node.prev</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Moves an existing node to the head position (marks as most recently used).</span><span class="s3">\n   </span><span class="s1">* This is the core LRU operation - accessed items become most recent.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private moveToHead(node: LRUNode&lt;T&gt;): void {</span><span class="s3">\n    </span><span class="s1">this.removeNode(node)</span><span class="s3">\n    </span><span class="s1">this.addToHead(node)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Removes and returns the least recently used node (the one before tail).</span><span class="s3">\n   </span><span class="s1">* This is called during eviction when the cache exceeds capacity.</span><span class="s3">\n   </span><span class="s1">* PRECONDITION: cache is not empty (ensured by caller)</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private removeTail(): LRUNode&lt;T&gt; {</span><span class="s3">\n    </span><span class="s1">const lastNode = this.tail.prev as LRUNode&lt;T&gt;</span><span class="s3">\n    </span><span class="s1">// tail.prev is always non-null and always LRUNode when cache is not empty</span><span class="s3">\n    </span><span class="s1">this.removeNode(lastNode)</span><span class="s3">\n    </span><span class="s1">return lastNode</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Sets a key-value pair in the cache.</span><span class="s3">\n   </span><span class="s1">* If the key exists, updates the value and moves to head.</span><span class="s3">\n   </span><span class="s1">* If new, adds at head and evicts from tail if necessary.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* Time Complexity:</span><span class="s3">\n   </span><span class="s1">* - O(1) for uniform item sizes</span><span class="s3">\n   </span><span class="s1">* - O(k) where k is the number of items evicted (can be O(N) for variable sizes)</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public set(key: string, value: T): void {</span><span class="s3">\n    </span><span class="s1">const size = this.calculateSize?.(value) ?? 1</span><span class="s3">\n    </span><span class="s1">if (size &gt; this.maxSize) {</span><span class="s3">\n      </span><span class="s1">console.warn('Single item size exceeds maxSize')</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const existing = this.cache.get(key)</span><span class="s3">\n    </span><span class="s1">if (existing) {</span><span class="s3">\n      </span><span class="s1">// Update existing node: adjust size and move to head (most recent)</span><span class="s3">\n      </span><span class="s1">existing.data = value</span><span class="s3">\n      </span><span class="s1">this.totalSize = this.totalSize - existing.size + size</span><span class="s3">\n      </span><span class="s1">existing.size = size</span><span class="s3">\n      </span><span class="s1">this.moveToHead(existing)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// Add new node at head (most recent position)</span><span class="s3">\n      </span><span class="s1">const newNode = new LRUNode(key, value, size)</span><span class="s3">\n      </span><span class="s1">this.cache.set(key, newNode)</span><span class="s3">\n      </span><span class="s1">this.addToHead(newNode)</span><span class="s3">\n      </span><span class="s1">this.totalSize += size</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Evict least recently used items until under capacity</span><span class="s3">\n    </span><span class="s1">while (this.totalSize &gt; this.maxSize &amp;&amp; this.cache.size &gt; 0) {</span><span class="s3">\n      </span><span class="s1">const tail = this.removeTail()</span><span class="s3">\n      </span><span class="s1">this.cache.delete(tail.key)</span><span class="s3">\n      </span><span class="s1">this.totalSize -= tail.size</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Checks if a key exists in the cache.</span><span class="s3">\n   </span><span class="s1">* This is a pure query operation - does NOT update LRU order.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* Time Complexity: O(1)</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public has(key: string): boolean {</span><span class="s3">\n    </span><span class="s1">return this.cache.has(key)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Retrieves a value by key and marks it as most recently used.</span><span class="s3">\n   </span><span class="s1">* Moving to head maintains the LRU property for future evictions.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* Time Complexity: O(1)</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public get(key: string): T | undefined {</span><span class="s3">\n    </span><span class="s1">const node = this.cache.get(key)</span><span class="s3">\n    </span><span class="s1">if (!node) return undefined</span><span class="s3">\n\n    </span><span class="s1">// Mark as most recently used by moving to head</span><span class="s3">\n    </span><span class="s1">this.moveToHead(node)</span><span class="s3">\n\n    </span><span class="s1">return node.data</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns an iterator over the cache entries. The order is outputted in the</span><span class="s3">\n   </span><span class="s1">* order of most recently used to least recently used.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public *[Symbol.iterator](): IterableIterator&lt;[string, T]&gt; {</span><span class="s3">\n    </span><span class="s1">let current = this.head.next</span><span class="s3">\n    </span><span class="s1">while (current &amp;&amp; current !== this.tail) {</span><span class="s3">\n      </span><span class="s1">// Between head and tail, current is always LRUNode</span><span class="s3">\n      </span><span class="s1">const node = current as LRUNode&lt;T&gt;</span><span class="s3">\n      </span><span class="s1">yield [node.key, node.data]</span><span class="s3">\n      </span><span class="s1">current = current.next</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Removes a specific key from the cache.</span><span class="s3">\n   </span><span class="s1">* Updates both the hash map and doubly-linked list.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* Time Complexity: O(1)</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public remove(key: string): void {</span><span class="s3">\n    </span><span class="s1">const node = this.cache.get(key)</span><span class="s3">\n    </span><span class="s1">if (!node) return</span><span class="s3">\n\n    </span><span class="s1">this.removeNode(node)</span><span class="s3">\n    </span><span class="s1">this.cache.delete(key)</span><span class="s3">\n    </span><span class="s1">this.totalSize -= node.size</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns the number of items in the cache.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public get size(): number {</span><span class="s3">\n    </span><span class="s1">return this.cache.size</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns the current total size of all cached items.</span><span class="s3">\n   </span><span class="s1">* This uses the custom size calculation if provided.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public get currentSize(): number {</span><span class="s3">\n    </span><span class="s1">return this.totalSize</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { bold, green, magenta, red, yellow, white } from '../../lib/picocolors'</span><span class="s3">\n</span><span class="s1">import { LRUCache } from '../../server/lib/lru-cache'</span><span class="s3">\n\n</span><span class="s1">export const prefixes = {</span><span class="s3">\n  </span><span class="s1">wait: white(bold('')),</span><span class="s3">\n  </span><span class="s1">error: red(bold('')),</span><span class="s3">\n  </span><span class="s1">warn: yellow(bold('')),</span><span class="s3">\n  </span><span class="s1">ready: '', // no color</span><span class="s3">\n  </span><span class="s1">info: white(bold(' ')),</span><span class="s3">\n  </span><span class="s1">event: green(bold('')),</span><span class="s3">\n  </span><span class="s1">trace: magenta(bold('')),</span><span class="s3">\n</span><span class="s1">} as const</span><span class="s3">\n\n</span><span class="s1">const LOGGING_METHOD = {</span><span class="s3">\n  </span><span class="s1">log: 'log',</span><span class="s3">\n  </span><span class="s1">warn: 'warn',</span><span class="s3">\n  </span><span class="s1">error: 'error',</span><span class="s3">\n</span><span class="s1">} as const</span><span class="s3">\n\n</span><span class="s1">function prefixedLog(prefixType: keyof typeof prefixes, ...message: any[]) {</span><span class="s3">\n  </span><span class="s1">if ((message[0] === '' || message[0] === undefined) &amp;&amp; message.length === 1) {</span><span class="s3">\n    </span><span class="s1">message.shift()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const consoleMethod: keyof typeof LOGGING_METHOD =</span><span class="s3">\n    </span><span class="s1">prefixType in LOGGING_METHOD</span><span class="s3">\n      </span><span class="s1">? LOGGING_METHOD[prefixType as keyof typeof LOGGING_METHOD]</span><span class="s3">\n      </span><span class="s1">: 'log'</span><span class="s3">\n\n  </span><span class="s1">const prefix = prefixes[prefixType]</span><span class="s3">\n  </span><span class="s1">// If there's no message, don't print the prefix but a new line</span><span class="s3">\n  </span><span class="s1">if (message.length === 0) {</span><span class="s3">\n    </span><span class="s1">console[consoleMethod]('')</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// Ensure if there's ANSI escape codes it's concatenated into one string.</span><span class="s3">\n    </span><span class="s1">// Chrome DevTool can only handle color if it's in one string.</span><span class="s3">\n    </span><span class="s1">if (message.length === 1 &amp;&amp; typeof message[0] === 'string') {</span><span class="s3">\n      </span><span class="s1">console[consoleMethod](' ' + prefix + ' ' + message[0])</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">console[consoleMethod](' ' + prefix, ...message)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function bootstrap(...message: string[]) {</span><span class="s3">\n  </span><span class="s1">// logging format: ' &lt;prefix&gt; &lt;message&gt;'</span><span class="s3">\n  </span><span class="s1">// e.g. '  Compiled successfully'</span><span class="s3">\n  </span><span class="s1">// Add spaces to align with the indent of other logs</span><span class="s3">\n  </span><span class="s1">console.log('   ' + message.join(' '))</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function wait(...message: any[]) {</span><span class="s3">\n  </span><span class="s1">prefixedLog('wait', ...message)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function error(...message: any[]) {</span><span class="s3">\n  </span><span class="s1">prefixedLog('error', ...message)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function warn(...message: any[]) {</span><span class="s3">\n  </span><span class="s1">prefixedLog('warn', ...message)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function ready(...message: any[]) {</span><span class="s3">\n  </span><span class="s1">prefixedLog('ready', ...message)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function info(...message: any[]) {</span><span class="s3">\n  </span><span class="s1">prefixedLog('info', ...message)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function event(...message: any[]) {</span><span class="s3">\n  </span><span class="s1">prefixedLog('event', ...message)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function trace(...message: any[]) {</span><span class="s3">\n  </span><span class="s1">prefixedLog('trace', ...message)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const warnOnceCache = new LRUCache&lt;string&gt;(10_000, (value) =&gt; value.length)</span><span class="s3">\n</span><span class="s1">export function warnOnce(...message: any[]) {</span><span class="s3">\n  </span><span class="s1">const key = message.join(' ')</span><span class="s3">\n  </span><span class="s1">if (!warnOnceCache.has(key)) {</span><span class="s3">\n    </span><span class="s1">warnOnceCache.set(key, key)</span><span class="s3">\n    </span><span class="s1">warn(...message)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { ServerRuntime } from '../types'</span><span class="s3">\n\n</span><span class="s1">export const TEXT_PLAIN_CONTENT_TYPE_HEADER = 'text/plain'</span><span class="s3">\n</span><span class="s1">export const HTML_CONTENT_TYPE_HEADER = 'text/html; charset=utf-8'</span><span class="s3">\n</span><span class="s1">export const JSON_CONTENT_TYPE_HEADER = 'application/json; charset=utf-8'</span><span class="s3">\n</span><span class="s1">export const NEXT_QUERY_PARAM_PREFIX = 'nxtP'</span><span class="s3">\n</span><span class="s1">export const NEXT_INTERCEPTION_MARKER_PREFIX = 'nxtI'</span><span class="s3">\n\n</span><span class="s1">export const MATCHED_PATH_HEADER = 'x-matched-path'</span><span class="s3">\n</span><span class="s1">export const PRERENDER_REVALIDATE_HEADER = 'x-prerender-revalidate'</span><span class="s3">\n</span><span class="s1">export const PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER =</span><span class="s3">\n  </span><span class="s1">'x-prerender-revalidate-if-generated'</span><span class="s3">\n\n</span><span class="s1">export const RSC_PREFETCH_SUFFIX = '.prefetch.rsc'</span><span class="s3">\n</span><span class="s1">export const RSC_SEGMENTS_DIR_SUFFIX = '.segments'</span><span class="s3">\n</span><span class="s1">export const RSC_SEGMENT_SUFFIX = '.segment.rsc'</span><span class="s3">\n</span><span class="s1">export const RSC_SUFFIX = '.rsc'</span><span class="s3">\n</span><span class="s1">export const ACTION_SUFFIX = '.action'</span><span class="s3">\n</span><span class="s1">export const NEXT_DATA_SUFFIX = '.json'</span><span class="s3">\n</span><span class="s1">export const NEXT_META_SUFFIX = '.meta'</span><span class="s3">\n</span><span class="s1">export const NEXT_BODY_SUFFIX = '.body'</span><span class="s3">\n\n</span><span class="s1">export const NEXT_CACHE_TAGS_HEADER = 'x-next-cache-tags'</span><span class="s3">\n</span><span class="s1">export const NEXT_CACHE_REVALIDATED_TAGS_HEADER = 'x-next-revalidated-tags'</span><span class="s3">\n</span><span class="s1">export const NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER =</span><span class="s3">\n  </span><span class="s1">'x-next-revalidate-tag-token'</span><span class="s3">\n\n</span><span class="s1">export const NEXT_RESUME_HEADER = 'next-resume'</span><span class="s3">\n\n</span><span class="s1">// if these change make sure we update the related</span><span class="s3">\n</span><span class="s1">// documentation as well</span><span class="s3">\n</span><span class="s1">export const NEXT_CACHE_TAG_MAX_ITEMS = 128</span><span class="s3">\n</span><span class="s1">export const NEXT_CACHE_TAG_MAX_LENGTH = 256</span><span class="s3">\n</span><span class="s1">export const NEXT_CACHE_SOFT_TAG_MAX_LENGTH = 1024</span><span class="s3">\n</span><span class="s1">export const NEXT_CACHE_IMPLICIT_TAG_ID = '_N_T_'</span><span class="s3">\n\n</span><span class="s1">// in seconds</span><span class="s3">\n</span><span class="s1">export const CACHE_ONE_YEAR = 31536000</span><span class="s3">\n\n</span><span class="s1">// in seconds, represents revalidate=false. I.e. never revaliate.</span><span class="s3">\n</span><span class="s1">// We use this value since it can be represented as a V8 SMI for optimal performance.</span><span class="s3">\n</span><span class="s1">// It can also be serialized as JSON if it ever leaks accidentally as an actual value.</span><span class="s3">\n</span><span class="s1">export const INFINITE_CACHE = 0xfffffffe</span><span class="s3">\n\n</span><span class="s1">// Patterns to detect middleware files</span><span class="s3">\n</span><span class="s1">export const MIDDLEWARE_FILENAME = 'middleware'</span><span class="s3">\n</span><span class="s1">export const MIDDLEWARE_LOCATION_REGEXP = `(?:src/)?${MIDDLEWARE_FILENAME}`</span><span class="s3">\n\n</span><span class="s1">// Pattern to detect instrumentation hooks file</span><span class="s3">\n</span><span class="s1">export const INSTRUMENTATION_HOOK_FILENAME = 'instrumentation'</span><span class="s3">\n\n</span><span class="s1">// Because on Windows absolute paths in the generated code can break because of numbers, eg 1 in the path,</span><span class="s3">\n</span><span class="s1">// we have to use a private alias</span><span class="s3">\n</span><span class="s1">export const PAGES_DIR_ALIAS = 'private-next-pages'</span><span class="s3">\n</span><span class="s1">export const DOT_NEXT_ALIAS = 'private-dot-next'</span><span class="s3">\n</span><span class="s1">export const ROOT_DIR_ALIAS = 'private-next-root-dir'</span><span class="s3">\n</span><span class="s1">export const APP_DIR_ALIAS = 'private-next-app-dir'</span><span class="s3">\n</span><span class="s1">export const RSC_MOD_REF_PROXY_ALIAS = 'private-next-rsc-mod-ref-proxy'</span><span class="s3">\n</span><span class="s1">export const RSC_ACTION_VALIDATE_ALIAS = 'private-next-rsc-action-validate'</span><span class="s3">\n</span><span class="s1">export const RSC_ACTION_PROXY_ALIAS = 'private-next-rsc-server-reference'</span><span class="s3">\n</span><span class="s1">export const RSC_CACHE_WRAPPER_ALIAS = 'private-next-rsc-cache-wrapper'</span><span class="s3">\n</span><span class="s1">export const RSC_DYNAMIC_IMPORT_WRAPPER_ALIAS =</span><span class="s3">\n  </span><span class="s1">'private-next-rsc-track-dynamic-import'</span><span class="s3">\n</span><span class="s1">export const RSC_ACTION_ENCRYPTION_ALIAS = 'private-next-rsc-action-encryption'</span><span class="s3">\n</span><span class="s1">export const RSC_ACTION_CLIENT_WRAPPER_ALIAS =</span><span class="s3">\n  </span><span class="s1">'private-next-rsc-action-client-wrapper'</span><span class="s3">\n\n</span><span class="s1">export const PUBLIC_DIR_MIDDLEWARE_CONFLICT = `You can not have a '_next' folder inside of your public folder. This conflicts with the internal '/_next' route. https://nextjs.org/docs/messages/public-next-folder-conflict`</span><span class="s3">\n\n</span><span class="s1">export const SSG_GET_INITIAL_PROPS_CONFLICT = `You can not use getInitialProps with getStaticProps. To use SSG, please remove your getInitialProps`</span><span class="s3">\n\n</span><span class="s1">export const SERVER_PROPS_GET_INIT_PROPS_CONFLICT = `You can not use getInitialProps with getServerSideProps. Please remove getInitialProps.`</span><span class="s3">\n\n</span><span class="s1">export const SERVER_PROPS_SSG_CONFLICT = `You can not use getStaticProps or getStaticPaths with getServerSideProps. To use SSG, please remove getServerSideProps`</span><span class="s3">\n\n</span><span class="s1">export const STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR = `can not have getInitialProps/getServerSideProps, https://nextjs.org/docs/messages/404-get-initial-props`</span><span class="s3">\n\n</span><span class="s1">export const SERVER_PROPS_EXPORT_ERROR = `pages with </span><span class="s3">\\</span><span class="s1">`getServerSideProps</span><span class="s3">\\</span><span class="s1">` can not be exported. See more info here: https://nextjs.org/docs/messages/gssp-export`</span><span class="s3">\n\n</span><span class="s1">export const GSP_NO_RETURNED_VALUE =</span><span class="s3">\n  </span><span class="s1">'Your `getStaticProps` function did not return an object. Did you forget to add a `return`?'</span><span class="s3">\n</span><span class="s1">export const GSSP_NO_RETURNED_VALUE =</span><span class="s3">\n  </span><span class="s1">'Your `getServerSideProps` function did not return an object. Did you forget to add a `return`?'</span><span class="s3">\n\n</span><span class="s1">export const UNSTABLE_REVALIDATE_RENAME_ERROR =</span><span class="s3">\n  </span><span class="s1">'The `unstable_revalidate` property is available for general use.</span><span class="s3">\\</span><span class="s1">n' +</span><span class="s3">\n  </span><span class="s1">'Please use `revalidate` instead.'</span><span class="s3">\n\n</span><span class="s1">export const GSSP_COMPONENT_MEMBER_ERROR = `can not be attached to a page's component and must be exported from the page. See more info here: https://nextjs.org/docs/messages/gssp-component-member`</span><span class="s3">\n\n</span><span class="s1">export const NON_STANDARD_NODE_ENV = `You are using a non-standard </span><span class="s3">\&quot;</span><span class="s1">NODE_ENV</span><span class="s3">\&quot; </span><span class="s1">value in your environment. This creates inconsistencies in the project and is strongly advised against. Read more: https://nextjs.org/docs/messages/non-standard-node-env`</span><span class="s3">\n\n</span><span class="s1">export const SSG_FALLBACK_EXPORT_ERROR = `Pages with </span><span class="s3">\\</span><span class="s1">`fallback</span><span class="s3">\\</span><span class="s1">` enabled in </span><span class="s3">\\</span><span class="s1">`getStaticPaths</span><span class="s3">\\</span><span class="s1">` can not be exported. See more info here: https://nextjs.org/docs/messages/ssg-fallback-true-export`</span><span class="s3">\n\n</span><span class="s1">export const ESLINT_DEFAULT_DIRS = ['app', 'pages', 'components', 'lib', 'src']</span><span class="s3">\n\n</span><span class="s1">export const SERVER_RUNTIME: Record&lt;string, ServerRuntime&gt; = {</span><span class="s3">\n  </span><span class="s1">edge: 'edge',</span><span class="s3">\n  </span><span class="s1">experimentalEdge: 'experimental-edge',</span><span class="s3">\n  </span><span class="s1">nodejs: 'nodejs',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The names of the webpack layers. These layers are the primitives for the</span><span class="s3">\n </span><span class="s1">* webpack chunks.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const WEBPACK_LAYERS_NAMES = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The layer for the shared code between the client and server bundles.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">shared: 'shared',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The layer for server-only runtime and picking up `react-server` export conditions.</span><span class="s3">\n   </span><span class="s1">* Including app router RSC pages and app router custom routes and metadata routes.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">reactServerComponents: 'rsc',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Server Side Rendering layer for app (ssr).</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">serverSideRendering: 'ssr',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The browser client bundle layer for actions.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">actionBrowser: 'action-browser',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The Node.js bundle layer for the API routes.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">apiNode: 'api-node',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The Edge Lite bundle layer for the API routes.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">apiEdge: 'api-edge',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The layer for the middleware code.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">middleware: 'middleware',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The layer for the instrumentation hooks.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">instrument: 'instrument',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The layer for assets on the edge.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">edgeAsset: 'edge-asset',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The browser client bundle layer for App directory.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">appPagesBrowser: 'app-pages-browser',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The browser client bundle layer for Pages directory.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">pagesDirBrowser: 'pages-dir-browser',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The Edge Lite bundle layer for Pages directory.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">pagesDirEdge: 'pages-dir-edge',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The Node.js bundle layer for Pages directory.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">pagesDirNode: 'pages-dir-node',</span><span class="s3">\n</span><span class="s1">} as const</span><span class="s3">\n\n</span><span class="s1">export type WebpackLayerName =</span><span class="s3">\n  </span><span class="s1">(typeof WEBPACK_LAYERS_NAMES)[keyof typeof WEBPACK_LAYERS_NAMES]</span><span class="s3">\n\n</span><span class="s1">const WEBPACK_LAYERS = {</span><span class="s3">\n  </span><span class="s1">...WEBPACK_LAYERS_NAMES,</span><span class="s3">\n  </span><span class="s1">GROUP: {</span><span class="s3">\n    </span><span class="s1">builtinReact: [</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.reactServerComponents,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.actionBrowser,</span><span class="s3">\n    </span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">serverOnly: [</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.reactServerComponents,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.actionBrowser,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.instrument,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.middleware,</span><span class="s3">\n    </span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">neutralTarget: [</span><span class="s3">\n      </span><span class="s1">// pages api</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.apiNode,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.apiEdge,</span><span class="s3">\n    </span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">clientOnly: [</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.serverSideRendering,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.appPagesBrowser,</span><span class="s3">\n    </span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">bundled: [</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.reactServerComponents,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.actionBrowser,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.serverSideRendering,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.appPagesBrowser,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.shared,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.instrument,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.middleware,</span><span class="s3">\n    </span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">appPages: [</span><span class="s3">\n      </span><span class="s1">// app router pages and layouts</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.reactServerComponents,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.serverSideRendering,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.appPagesBrowser,</span><span class="s3">\n      </span><span class="s1">WEBPACK_LAYERS_NAMES.actionBrowser,</span><span class="s3">\n    </span><span class="s1">],</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const WEBPACK_RESOURCE_QUERIES = {</span><span class="s3">\n  </span><span class="s1">edgeSSREntry: '__next_edge_ssr_entry__',</span><span class="s3">\n  </span><span class="s1">metadata: '__next_metadata__',</span><span class="s3">\n  </span><span class="s1">metadataRoute: '__next_metadata_route__',</span><span class="s3">\n  </span><span class="s1">metadataImageMeta: '__next_metadata_image_meta__',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { WEBPACK_LAYERS, WEBPACK_RESOURCE_QUERIES }</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import path from 'path'</span><span class="s3">\n</span><span class="s1">import { pathToFileURL } from 'url'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The path for a dynamic route must be URLs with a valid scheme.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* When an absolute Windows path is passed to it, it interprets the beginning of the path as a protocol (`C:`).</span><span class="s3">\n </span><span class="s1">* Therefore, it is important to always construct a complete path.</span><span class="s3">\n </span><span class="s1">* @param dir File directory</span><span class="s3">\n </span><span class="s1">* @param filePath Absolute or relative path</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const formatDynamicImportPath = (dir: string, filePath: string) =&gt; {</span><span class="s3">\n  </span><span class="s1">const absoluteFilePath = path.isAbsolute(filePath)</span><span class="s3">\n    </span><span class="s1">? filePath</span><span class="s3">\n    </span><span class="s1">: path.join(dir, filePath)</span><span class="s3">\n  </span><span class="s1">const formattedFilePath = pathToFileURL(absoluteFilePath).toString()</span><span class="s3">\n\n  </span><span class="s1">return formattedFilePath</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { IncomingMessage } from 'http'</span><span class="s3">\n</span><span class="s1">import type { BaseNextRequest } from '../base-http'</span><span class="s3">\n</span><span class="s1">import type { CookieSerializeOptions } from 'next/dist/compiled/cookie'</span><span class="s3">\n</span><span class="s1">import type { NextApiResponse } from '../../shared/lib/utils'</span><span class="s3">\n\n</span><span class="s1">import { HeadersAdapter } from '../web/spec-extension/adapters/headers'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">PRERENDER_REVALIDATE_HEADER,</span><span class="s3">\n  </span><span class="s1">PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER,</span><span class="s3">\n</span><span class="s1">} from '../../lib/constants'</span><span class="s3">\n</span><span class="s1">import { getTracer } from '../lib/trace/tracer'</span><span class="s3">\n</span><span class="s1">import { NodeSpan } from '../lib/trace/constants'</span><span class="s3">\n\n</span><span class="s1">export type NextApiRequestCookies = Partial&lt;{ [key: string]: string }&gt;</span><span class="s3">\n</span><span class="s1">export type NextApiRequestQuery = Partial&lt;{ [key: string]: string | string[] }&gt;</span><span class="s3">\n\n</span><span class="s1">export type __ApiPreviewProps = {</span><span class="s3">\n  </span><span class="s1">previewModeId: string</span><span class="s3">\n  </span><span class="s1">previewModeEncryptionKey: string</span><span class="s3">\n  </span><span class="s1">previewModeSigningKey: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function wrapApiHandler&lt;T extends (...args: any[]) =&gt; any&gt;(</span><span class="s3">\n  </span><span class="s1">page: string,</span><span class="s3">\n  </span><span class="s1">handler: T</span><span class="s3">\n</span><span class="s1">): T {</span><span class="s3">\n  </span><span class="s1">return ((...args) =&gt; {</span><span class="s3">\n    </span><span class="s1">getTracer().setRootSpanAttribute('next.route', page)</span><span class="s3">\n    </span><span class="s1">// Call API route method</span><span class="s3">\n    </span><span class="s1">return getTracer().trace(</span><span class="s3">\n      </span><span class="s1">NodeSpan.runHandler,</span><span class="s3">\n      </span><span class="s1">{</span><span class="s3">\n        </span><span class="s1">spanName: `executing api route (pages) ${page}`,</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">() =&gt; handler(...args)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}) as T</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param res response object</span><span class="s3">\n </span><span class="s1">* @param statusCode `HTTP` status code of response</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function sendStatusCode(</span><span class="s3">\n  </span><span class="s1">res: NextApiResponse,</span><span class="s3">\n  </span><span class="s1">statusCode: number</span><span class="s3">\n</span><span class="s1">): NextApiResponse&lt;any&gt; {</span><span class="s3">\n  </span><span class="s1">res.statusCode = statusCode</span><span class="s3">\n  </span><span class="s1">return res</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param res response object</span><span class="s3">\n </span><span class="s1">* @param [statusOrUrl] `HTTP` status code of redirect</span><span class="s3">\n </span><span class="s1">* @param url URL of redirect</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function redirect(</span><span class="s3">\n  </span><span class="s1">res: NextApiResponse,</span><span class="s3">\n  </span><span class="s1">statusOrUrl: string | number,</span><span class="s3">\n  </span><span class="s1">url?: string</span><span class="s3">\n</span><span class="s1">): NextApiResponse&lt;any&gt; {</span><span class="s3">\n  </span><span class="s1">if (typeof statusOrUrl === 'string') {</span><span class="s3">\n    </span><span class="s1">url = statusOrUrl</span><span class="s3">\n    </span><span class="s1">statusOrUrl = 307</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (typeof statusOrUrl !== 'number' || typeof url !== 'string') {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`Invalid redirect arguments. Please use a single argument URL, e.g. res.redirect('/destination') or use a status code and URL, e.g. res.redirect(307, '/destination').`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">res.writeHead(statusOrUrl, { Location: url })</span><span class="s3">\n  </span><span class="s1">res.write(url)</span><span class="s3">\n  </span><span class="s1">res.end()</span><span class="s3">\n  </span><span class="s1">return res</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function checkIsOnDemandRevalidate(</span><span class="s3">\n  </span><span class="s1">req: Request | IncomingMessage | BaseNextRequest,</span><span class="s3">\n  </span><span class="s1">previewProps: __ApiPreviewProps</span><span class="s3">\n</span><span class="s1">): {</span><span class="s3">\n  </span><span class="s1">isOnDemandRevalidate: boolean</span><span class="s3">\n  </span><span class="s1">revalidateOnlyGenerated: boolean</span><span class="s3">\n</span><span class="s1">} {</span><span class="s3">\n  </span><span class="s1">const headers = HeadersAdapter.from(req.headers)</span><span class="s3">\n\n  </span><span class="s1">const previewModeId = headers.get(PRERENDER_REVALIDATE_HEADER)</span><span class="s3">\n  </span><span class="s1">const isOnDemandRevalidate = previewModeId === previewProps.previewModeId</span><span class="s3">\n\n  </span><span class="s1">const revalidateOnlyGenerated = headers.has(</span><span class="s3">\n    </span><span class="s1">PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">return { isOnDemandRevalidate, revalidateOnlyGenerated }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const COOKIE_NAME_PRERENDER_BYPASS = `__prerender_bypass`</span><span class="s3">\n</span><span class="s1">export const COOKIE_NAME_PRERENDER_DATA = `__next_preview_data`</span><span class="s3">\n\n</span><span class="s1">export const RESPONSE_LIMIT_DEFAULT = 4 * 1024 * 1024</span><span class="s3">\n\n</span><span class="s1">export const SYMBOL_PREVIEW_DATA = Symbol(COOKIE_NAME_PRERENDER_DATA)</span><span class="s3">\n</span><span class="s1">export const SYMBOL_CLEARED_COOKIES = Symbol(COOKIE_NAME_PRERENDER_BYPASS)</span><span class="s3">\n\n</span><span class="s1">export function clearPreviewData&lt;T&gt;(</span><span class="s3">\n  </span><span class="s1">res: NextApiResponse&lt;T&gt;,</span><span class="s3">\n  </span><span class="s1">options: {</span><span class="s3">\n    </span><span class="s1">path?: string</span><span class="s3">\n  </span><span class="s1">} = {}</span><span class="s3">\n</span><span class="s1">): NextApiResponse&lt;T&gt; {</span><span class="s3">\n  </span><span class="s1">if (SYMBOL_CLEARED_COOKIES in res) {</span><span class="s3">\n    </span><span class="s1">return res</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { serialize } =</span><span class="s3">\n    </span><span class="s1">require('next/dist/compiled/cookie') as typeof import('next/dist/compiled/cookie')</span><span class="s3">\n  </span><span class="s1">const previous = res.getHeader('Set-Cookie')</span><span class="s3">\n  </span><span class="s1">res.setHeader(`Set-Cookie`, [</span><span class="s3">\n    </span><span class="s1">...(typeof previous === 'string'</span><span class="s3">\n      </span><span class="s1">? [previous]</span><span class="s3">\n      </span><span class="s1">: Array.isArray(previous)</span><span class="s3">\n        </span><span class="s1">? previous</span><span class="s3">\n        </span><span class="s1">: []),</span><span class="s3">\n    </span><span class="s1">serialize(COOKIE_NAME_PRERENDER_BYPASS, '', {</span><span class="s3">\n      </span><span class="s1">// To delete a cookie, set `expires` to a date in the past:</span><span class="s3">\n      </span><span class="s1">// https://tools.ietf.org/html/rfc6265#section-4.1.1</span><span class="s3">\n      </span><span class="s1">// `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.</span><span class="s3">\n      </span><span class="s1">expires: new Date(0),</span><span class="s3">\n      </span><span class="s1">httpOnly: true,</span><span class="s3">\n      </span><span class="s1">sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',</span><span class="s3">\n      </span><span class="s1">secure: process.env.NODE_ENV !== 'development',</span><span class="s3">\n      </span><span class="s1">path: '/',</span><span class="s3">\n      </span><span class="s1">...(options.path !== undefined</span><span class="s3">\n        </span><span class="s1">? ({ path: options.path } as CookieSerializeOptions)</span><span class="s3">\n        </span><span class="s1">: undefined),</span><span class="s3">\n    </span><span class="s1">}),</span><span class="s3">\n    </span><span class="s1">serialize(COOKIE_NAME_PRERENDER_DATA, '', {</span><span class="s3">\n      </span><span class="s1">// To delete a cookie, set `expires` to a date in the past:</span><span class="s3">\n      </span><span class="s1">// https://tools.ietf.org/html/rfc6265#section-4.1.1</span><span class="s3">\n      </span><span class="s1">// `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.</span><span class="s3">\n      </span><span class="s1">expires: new Date(0),</span><span class="s3">\n      </span><span class="s1">httpOnly: true,</span><span class="s3">\n      </span><span class="s1">sameSite: process.env.NODE_ENV !== 'development' ? 'none' : 'lax',</span><span class="s3">\n      </span><span class="s1">secure: process.env.NODE_ENV !== 'development',</span><span class="s3">\n      </span><span class="s1">path: '/',</span><span class="s3">\n      </span><span class="s1">...(options.path !== undefined</span><span class="s3">\n        </span><span class="s1">? ({ path: options.path } as CookieSerializeOptions)</span><span class="s3">\n        </span><span class="s1">: undefined),</span><span class="s3">\n    </span><span class="s1">}),</span><span class="s3">\n  </span><span class="s1">])</span><span class="s3">\n\n  </span><span class="s1">Object.defineProperty(res, SYMBOL_CLEARED_COOKIES, {</span><span class="s3">\n    </span><span class="s1">value: true,</span><span class="s3">\n    </span><span class="s1">enumerable: false,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">return res</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Custom error class</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class ApiError extends Error {</span><span class="s3">\n  </span><span class="s1">readonly statusCode: number</span><span class="s3">\n\n  </span><span class="s1">constructor(statusCode: number, message: string) {</span><span class="s3">\n    </span><span class="s1">super(message)</span><span class="s3">\n    </span><span class="s1">this.statusCode = statusCode</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Sends error in `response`</span><span class="s3">\n </span><span class="s1">* @param res response object</span><span class="s3">\n </span><span class="s1">* @param statusCode of response</span><span class="s3">\n </span><span class="s1">* @param message of response</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function sendError(</span><span class="s3">\n  </span><span class="s1">res: NextApiResponse,</span><span class="s3">\n  </span><span class="s1">statusCode: number,</span><span class="s3">\n  </span><span class="s1">message: string</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">res.statusCode = statusCode</span><span class="s3">\n  </span><span class="s1">res.statusMessage = message</span><span class="s3">\n  </span><span class="s1">res.end(message)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface LazyProps {</span><span class="s3">\n  </span><span class="s1">req: IncomingMessage</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Execute getter function only if its needed</span><span class="s3">\n </span><span class="s1">* @param LazyProps `req` and `params` for lazyProp</span><span class="s3">\n </span><span class="s1">* @param prop name of property</span><span class="s3">\n </span><span class="s1">* @param getter function to get data</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function setLazyProp&lt;T&gt;(</span><span class="s3">\n  </span><span class="s1">{ req }: LazyProps,</span><span class="s3">\n  </span><span class="s1">prop: string,</span><span class="s3">\n  </span><span class="s1">getter: () =&gt; T</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">const opts = { configurable: true, enumerable: true }</span><span class="s3">\n  </span><span class="s1">const optsReset = { ...opts, writable: true }</span><span class="s3">\n\n  </span><span class="s1">Object.defineProperty(req, prop, {</span><span class="s3">\n    </span><span class="s1">...opts,</span><span class="s3">\n    </span><span class="s1">get: () =&gt; {</span><span class="s3">\n      </span><span class="s1">const value = getter()</span><span class="s3">\n      </span><span class="s1">// we set the property on the object to avoid recalculating it</span><span class="s3">\n      </span><span class="s1">Object.defineProperty(req, prop, { ...optsReset, value })</span><span class="s3">\n      </span><span class="s1">return value</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">set: (value) =&gt; {</span><span class="s3">\n      </span><span class="s1">Object.defineProperty(req, prop, { ...optsReset, value })</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { IncomingMessage, ServerResponse } from 'http'</span><span class="s3">\n</span><span class="s1">import type { NextApiResponse } from '../../../shared/lib/utils'</span><span class="s3">\n</span><span class="s1">import { checkIsOnDemandRevalidate } from '../.'</span><span class="s3">\n</span><span class="s1">import type { __ApiPreviewProps } from '../.'</span><span class="s3">\n</span><span class="s1">import type { BaseNextRequest, BaseNextResponse } from '../../base-http'</span><span class="s3">\n</span><span class="s1">import type { PreviewData } from '../../../types'</span><span class="s3">\n\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">clearPreviewData,</span><span class="s3">\n  </span><span class="s1">COOKIE_NAME_PRERENDER_BYPASS,</span><span class="s3">\n  </span><span class="s1">COOKIE_NAME_PRERENDER_DATA,</span><span class="s3">\n  </span><span class="s1">SYMBOL_PREVIEW_DATA,</span><span class="s3">\n</span><span class="s1">} from '../index'</span><span class="s3">\n</span><span class="s1">import { RequestCookies } from '../../web/spec-extension/cookies'</span><span class="s3">\n</span><span class="s1">import { HeadersAdapter } from '../../web/spec-extension/adapters/headers'</span><span class="s3">\n\n</span><span class="s1">export function tryGetPreviewData(</span><span class="s3">\n  </span><span class="s1">req: IncomingMessage | BaseNextRequest | Request,</span><span class="s3">\n  </span><span class="s1">res: ServerResponse | BaseNextResponse,</span><span class="s3">\n  </span><span class="s1">options: __ApiPreviewProps,</span><span class="s3">\n  </span><span class="s1">multiZoneDraftMode: boolean</span><span class="s3">\n</span><span class="s1">): PreviewData {</span><span class="s3">\n  </span><span class="s1">// if an On-Demand revalidation is being done preview mode</span><span class="s3">\n  </span><span class="s1">// is disabled</span><span class="s3">\n  </span><span class="s1">if (options &amp;&amp; checkIsOnDemandRevalidate(req, options).isOnDemandRevalidate) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Read cached preview data if present</span><span class="s3">\n  </span><span class="s1">// TODO: use request metadata instead of a symbol</span><span class="s3">\n  </span><span class="s1">if (SYMBOL_PREVIEW_DATA in req) {</span><span class="s3">\n    </span><span class="s1">return (req as any)[SYMBOL_PREVIEW_DATA] as any</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const headers = HeadersAdapter.from(req.headers)</span><span class="s3">\n  </span><span class="s1">const cookies = new RequestCookies(headers)</span><span class="s3">\n\n  </span><span class="s1">const previewModeId = cookies.get(COOKIE_NAME_PRERENDER_BYPASS)?.value</span><span class="s3">\n  </span><span class="s1">const tokenPreviewData = cookies.get(COOKIE_NAME_PRERENDER_DATA)?.value</span><span class="s3">\n\n  </span><span class="s1">// Case: preview mode cookie set but data cookie is not set</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">previewModeId &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!tokenPreviewData &amp;&amp;</span><span class="s3">\n    </span><span class="s1">previewModeId === options.previewModeId</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">// This is </span><span class="s3">\&quot;</span><span class="s1">Draft Mode</span><span class="s3">\&quot; </span><span class="s1">which doesn't use</span><span class="s3">\n    </span><span class="s1">// previewData, so we return an empty object</span><span class="s3">\n    </span><span class="s1">// for backwards compat with </span><span class="s3">\&quot;</span><span class="s1">Preview Mode</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n    </span><span class="s1">const data = {}</span><span class="s3">\n    </span><span class="s1">Object.defineProperty(req, SYMBOL_PREVIEW_DATA, {</span><span class="s3">\n      </span><span class="s1">value: data,</span><span class="s3">\n      </span><span class="s1">enumerable: false,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">return data</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Case: neither cookie is set.</span><span class="s3">\n  </span><span class="s1">if (!previewModeId &amp;&amp; !tokenPreviewData) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Case: one cookie is set, but not the other.</span><span class="s3">\n  </span><span class="s1">if (!previewModeId || !tokenPreviewData) {</span><span class="s3">\n    </span><span class="s1">if (!multiZoneDraftMode) {</span><span class="s3">\n      </span><span class="s1">clearPreviewData(res as NextApiResponse)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Case: preview session is for an old build.</span><span class="s3">\n  </span><span class="s1">if (previewModeId !== options.previewModeId) {</span><span class="s3">\n    </span><span class="s1">if (!multiZoneDraftMode) {</span><span class="s3">\n      </span><span class="s1">clearPreviewData(res as NextApiResponse)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let encryptedPreviewData: {</span><span class="s3">\n    </span><span class="s1">data: string</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">const jsonwebtoken =</span><span class="s3">\n      </span><span class="s1">require('next/dist/compiled/jsonwebtoken') as typeof import('next/dist/compiled/jsonwebtoken')</span><span class="s3">\n    </span><span class="s1">encryptedPreviewData = jsonwebtoken.verify(</span><span class="s3">\n      </span><span class="s1">tokenPreviewData,</span><span class="s3">\n      </span><span class="s1">options.previewModeSigningKey</span><span class="s3">\n    </span><span class="s1">) as typeof encryptedPreviewData</span><span class="s3">\n  </span><span class="s1">} catch {</span><span class="s3">\n    </span><span class="s1">// TODO: warn</span><span class="s3">\n    </span><span class="s1">clearPreviewData(res as NextApiResponse)</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { decryptWithSecret } =</span><span class="s3">\n    </span><span class="s1">require('../../crypto-utils') as typeof import('../../crypto-utils')</span><span class="s3">\n  </span><span class="s1">const decryptedPreviewData = decryptWithSecret(</span><span class="s3">\n    </span><span class="s1">Buffer.from(options.previewModeEncryptionKey),</span><span class="s3">\n    </span><span class="s1">encryptedPreviewData.data</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">// TODO: strict runtime type checking</span><span class="s3">\n    </span><span class="s1">const data = JSON.parse(decryptedPreviewData)</span><span class="s3">\n    </span><span class="s1">// Cache lookup</span><span class="s3">\n    </span><span class="s1">Object.defineProperty(req, SYMBOL_PREVIEW_DATA, {</span><span class="s3">\n      </span><span class="s1">value: data,</span><span class="s3">\n      </span><span class="s1">enumerable: false,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">return data</span><span class="s3">\n  </span><span class="s1">} catch {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import crypto from 'crypto'</span><span class="s3">\n\n</span><span class="s1">// Background:</span><span class="s3">\n</span><span class="s1">// https://security.stackexchange.com/questions/184305/why-would-i-ever-use-aes-256-cbc-if-aes-256-gcm-is-more-secure</span><span class="s3">\n\n</span><span class="s1">const CIPHER_ALGORITHM = `aes-256-gcm`,</span><span class="s3">\n  </span><span class="s1">CIPHER_KEY_LENGTH = 32, // https://stackoverflow.com/a/28307668/4397028</span><span class="s3">\n  </span><span class="s1">CIPHER_IV_LENGTH = 16, // https://stackoverflow.com/a/28307668/4397028</span><span class="s3">\n  </span><span class="s1">CIPHER_TAG_LENGTH = 16,</span><span class="s3">\n  </span><span class="s1">CIPHER_SALT_LENGTH = 64</span><span class="s3">\n\n</span><span class="s1">const PBKDF2_ITERATIONS = 100_000 // https://support.1password.com/pbkdf2/</span><span class="s3">\n\n</span><span class="s1">export function encryptWithSecret(secret: Buffer, data: string): string {</span><span class="s3">\n  </span><span class="s1">const iv = crypto.randomBytes(CIPHER_IV_LENGTH)</span><span class="s3">\n  </span><span class="s1">const salt = crypto.randomBytes(CIPHER_SALT_LENGTH)</span><span class="s3">\n\n  </span><span class="s1">// https://nodejs.org/api/crypto.html#crypto_crypto_pbkdf2sync_password_salt_iterations_keylen_digest</span><span class="s3">\n  </span><span class="s1">const key = crypto.pbkdf2Sync(</span><span class="s3">\n    </span><span class="s1">secret,</span><span class="s3">\n    </span><span class="s1">salt,</span><span class="s3">\n    </span><span class="s1">PBKDF2_ITERATIONS,</span><span class="s3">\n    </span><span class="s1">CIPHER_KEY_LENGTH,</span><span class="s3">\n    </span><span class="s1">`sha512`</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const cipher = crypto.createCipheriv(CIPHER_ALGORITHM, key, iv)</span><span class="s3">\n  </span><span class="s1">const encrypted = Buffer.concat([cipher.update(data, `utf8`), cipher.final()])</span><span class="s3">\n\n  </span><span class="s1">// https://nodejs.org/api/crypto.html#crypto_cipher_getauthtag</span><span class="s3">\n  </span><span class="s1">const tag = cipher.getAuthTag()</span><span class="s3">\n\n  </span><span class="s1">return Buffer.concat([</span><span class="s3">\n    </span><span class="s1">// Data as required by:</span><span class="s3">\n    </span><span class="s1">// Salt for Key: https://nodejs.org/api/crypto.html#crypto_crypto_pbkdf2sync_password_salt_iterations_keylen_digest</span><span class="s3">\n    </span><span class="s1">// IV: https://nodejs.org/api/crypto.html#crypto_class_decipher</span><span class="s3">\n    </span><span class="s1">// Tag: https://nodejs.org/api/crypto.html#crypto_decipher_setauthtag_buffer</span><span class="s3">\n    </span><span class="s1">salt,</span><span class="s3">\n    </span><span class="s1">iv,</span><span class="s3">\n    </span><span class="s1">tag,</span><span class="s3">\n    </span><span class="s1">encrypted,</span><span class="s3">\n  </span><span class="s1">]).toString(`hex`)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function decryptWithSecret(</span><span class="s3">\n  </span><span class="s1">secret: Buffer,</span><span class="s3">\n  </span><span class="s1">encryptedData: string</span><span class="s3">\n</span><span class="s1">): string {</span><span class="s3">\n  </span><span class="s1">const buffer = Buffer.from(encryptedData, `hex`)</span><span class="s3">\n\n  </span><span class="s1">const salt = buffer.slice(0, CIPHER_SALT_LENGTH)</span><span class="s3">\n  </span><span class="s1">const iv = buffer.slice(</span><span class="s3">\n    </span><span class="s1">CIPHER_SALT_LENGTH,</span><span class="s3">\n    </span><span class="s1">CIPHER_SALT_LENGTH + CIPHER_IV_LENGTH</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">const tag = buffer.slice(</span><span class="s3">\n    </span><span class="s1">CIPHER_SALT_LENGTH + CIPHER_IV_LENGTH,</span><span class="s3">\n    </span><span class="s1">CIPHER_SALT_LENGTH + CIPHER_IV_LENGTH + CIPHER_TAG_LENGTH</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">const encrypted = buffer.slice(</span><span class="s3">\n    </span><span class="s1">CIPHER_SALT_LENGTH + CIPHER_IV_LENGTH + CIPHER_TAG_LENGTH</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">// https://nodejs.org/api/crypto.html#crypto_crypto_pbkdf2sync_password_salt_iterations_keylen_digest</span><span class="s3">\n  </span><span class="s1">const key = crypto.pbkdf2Sync(</span><span class="s3">\n    </span><span class="s1">secret,</span><span class="s3">\n    </span><span class="s1">salt,</span><span class="s3">\n    </span><span class="s1">PBKDF2_ITERATIONS,</span><span class="s3">\n    </span><span class="s1">CIPHER_KEY_LENGTH,</span><span class="s3">\n    </span><span class="s1">`sha512`</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const decipher = crypto.createDecipheriv(CIPHER_ALGORITHM, key, iv)</span><span class="s3">\n  </span><span class="s1">decipher.setAuthTag(tag)</span><span class="s3">\n\n  </span><span class="s1">return decipher.update(encrypted) + decipher.final(`utf8`)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { CacheFs } from '../../shared/lib/utils'</span><span class="s3">\n\n</span><span class="s1">import fs from 'fs'</span><span class="s3">\n\n</span><span class="s1">export const nodeFs: CacheFs = {</span><span class="s3">\n  </span><span class="s1">existsSync: fs.existsSync,</span><span class="s3">\n  </span><span class="s1">readFile: fs.promises.readFile,</span><span class="s3">\n  </span><span class="s1">readFileSync: fs.readFileSync,</span><span class="s3">\n  </span><span class="s1">writeFile: (f, d) =&gt; fs.promises.writeFile(f, d),</span><span class="s3">\n  </span><span class="s1">mkdir: (dir) =&gt; fs.promises.mkdir(dir, { recursive: true }),</span><span class="s3">\n  </span><span class="s1">stat: (f) =&gt; fs.promises.stat(f),</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export default async function optimize(</span><span class="s3">\n  </span><span class="s1">html: string,</span><span class="s3">\n  </span><span class="s1">config: any</span><span class="s3">\n</span><span class="s1">): Promise&lt;string&gt; {</span><span class="s3">\n  </span><span class="s1">let AmpOptimizer</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">AmpOptimizer =</span><span class="s3">\n      </span><span class="s1">require('next/dist/compiled/@ampproject/toolbox-optimizer') as typeof import('next/dist/compiled/@ampproject/toolbox-optimizer')</span><span class="s3">\n  </span><span class="s1">} catch (_) {</span><span class="s3">\n    </span><span class="s1">return html</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const optimizer = AmpOptimizer.create(config)</span><span class="s3">\n  </span><span class="s1">return optimizer.transformHtml(html, config)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export function nonNullable&lt;T&gt;(value: T): value is NonNullable&lt;T&gt; {</span><span class="s3">\n  </span><span class="s1">return value !== null &amp;&amp; value !== undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { RenderOpts } from './render'</span><span class="s3">\n\n</span><span class="s1">import { nonNullable } from '../lib/non-nullable'</span><span class="s3">\n\n</span><span class="s1">type PostProcessorFunction =</span><span class="s3">\n  </span><span class="s1">| ((html: string) =&gt; Promise&lt;string&gt;)</span><span class="s3">\n  </span><span class="s1">| ((html: string) =&gt; string)</span><span class="s3">\n\n</span><span class="s1">async function postProcessHTML(</span><span class="s3">\n  </span><span class="s1">pathname: string,</span><span class="s3">\n  </span><span class="s1">content: string,</span><span class="s3">\n  </span><span class="s1">renderOpts: Pick&lt;</span><span class="s3">\n    </span><span class="s1">RenderOpts,</span><span class="s3">\n    </span><span class="s1">| 'ampOptimizerConfig'</span><span class="s3">\n    </span><span class="s1">| 'ampValidator'</span><span class="s3">\n    </span><span class="s1">| 'ampSkipValidation'</span><span class="s3">\n    </span><span class="s1">| 'optimizeCss'</span><span class="s3">\n    </span><span class="s1">| 'distDir'</span><span class="s3">\n    </span><span class="s1">| 'assetPrefix'</span><span class="s3">\n  </span><span class="s1">&gt;,</span><span class="s3">\n  </span><span class="s1">{ inAmpMode, hybridAmp }: { inAmpMode: boolean; hybridAmp: boolean }</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const postProcessors: Array&lt;PostProcessorFunction&gt; = [</span><span class="s3">\n    </span><span class="s1">process.env.NEXT_RUNTIME !== 'edge' &amp;&amp; inAmpMode &amp;&amp; !process.env.TURBOPACK</span><span class="s3">\n      </span><span class="s1">? async (html: string) =&gt; {</span><span class="s3">\n          </span><span class="s1">const optimizeAmp = (</span><span class="s3">\n            </span><span class="s1">require('./optimize-amp') as typeof import('./optimize-amp')</span><span class="s3">\n          </span><span class="s1">).default as typeof import('./optimize-amp').default</span><span class="s3">\n          </span><span class="s1">html = await optimizeAmp!(html, renderOpts.ampOptimizerConfig)</span><span class="s3">\n          </span><span class="s1">if (!renderOpts.ampSkipValidation &amp;&amp; renderOpts.ampValidator) {</span><span class="s3">\n            </span><span class="s1">await renderOpts.ampValidator(html, pathname)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">return html</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">: null,</span><span class="s3">\n    </span><span class="s1">process.env.NEXT_RUNTIME !== 'edge' &amp;&amp; renderOpts.optimizeCss</span><span class="s3">\n      </span><span class="s1">? async (html: string) =&gt; {</span><span class="s3">\n          </span><span class="s1">// eslint-disable-next-line import/no-extraneous-dependencies</span><span class="s3">\n          </span><span class="s1">const Critters = require('critters') as typeof import('critters')</span><span class="s3">\n          </span><span class="s1">// @ts-expect-error -- interopRequireDefault</span><span class="s3">\n          </span><span class="s1">const cssOptimizer = new Critters({</span><span class="s3">\n            </span><span class="s1">ssrMode: true,</span><span class="s3">\n            </span><span class="s1">reduceInlineStyles: false,</span><span class="s3">\n            </span><span class="s1">path: renderOpts.distDir,</span><span class="s3">\n            </span><span class="s1">publicPath: `${renderOpts.assetPrefix}/_next/`,</span><span class="s3">\n            </span><span class="s1">preload: 'media',</span><span class="s3">\n            </span><span class="s1">fonts: false,</span><span class="s3">\n            </span><span class="s1">logLevel:</span><span class="s3">\n              </span><span class="s1">process.env.CRITTERS_LOG_LEVEL ||</span><span class="s3">\n              </span><span class="s1">(process.env.NODE_ENV === 'production' ? 'warn' : 'info'),</span><span class="s3">\n            </span><span class="s1">...renderOpts.optimizeCss,</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n          </span><span class="s1">return await cssOptimizer.process(html)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">: null,</span><span class="s3">\n    </span><span class="s1">inAmpMode || hybridAmp</span><span class="s3">\n      </span><span class="s1">? (html: string) =&gt; {</span><span class="s3">\n          </span><span class="s1">return html.replace(/&amp;amp;amp=1/g, '&amp;amp=1')</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">: null,</span><span class="s3">\n  </span><span class="s1">].filter(nonNullable)</span><span class="s3">\n\n  </span><span class="s1">for (const postProcessor of postProcessors) {</span><span class="s3">\n    </span><span class="s1">if (postProcessor) {</span><span class="s3">\n      </span><span class="s1">content = await postProcessor(content)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return content</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { postProcessHTML }</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export class ReflectAdapter {</span><span class="s3">\n  </span><span class="s1">static get&lt;T extends object&gt;(</span><span class="s3">\n    </span><span class="s1">target: T,</span><span class="s3">\n    </span><span class="s1">prop: string | symbol,</span><span class="s3">\n    </span><span class="s1">receiver: unknown</span><span class="s3">\n  </span><span class="s1">): any {</span><span class="s3">\n    </span><span class="s1">const value = Reflect.get(target, prop, receiver)</span><span class="s3">\n    </span><span class="s1">if (typeof value === 'function') {</span><span class="s3">\n      </span><span class="s1">return value.bind(target)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">static set&lt;T extends object&gt;(</span><span class="s3">\n    </span><span class="s1">target: T,</span><span class="s3">\n    </span><span class="s1">prop: string | symbol,</span><span class="s3">\n    </span><span class="s1">value: any,</span><span class="s3">\n    </span><span class="s1">receiver: any</span><span class="s3">\n  </span><span class="s1">): boolean {</span><span class="s3">\n    </span><span class="s1">return Reflect.set(target, prop, value, receiver)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">static has&lt;T extends object&gt;(target: T, prop: string | symbol): boolean {</span><span class="s3">\n    </span><span class="s1">return Reflect.has(target, prop)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">static deleteProperty&lt;T extends object&gt;(</span><span class="s3">\n    </span><span class="s1">target: T,</span><span class="s3">\n    </span><span class="s1">prop: string | symbol</span><span class="s3">\n  </span><span class="s1">): boolean {</span><span class="s3">\n    </span><span class="s1">return Reflect.deleteProperty(target, prop)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { IncomingHttpHeaders } from 'http'</span><span class="s3">\n\n</span><span class="s1">import { ReflectAdapter } from './reflect'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @internal</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class ReadonlyHeadersError extends Error {</span><span class="s3">\n  </span><span class="s1">constructor() {</span><span class="s3">\n    </span><span class="s1">super(</span><span class="s3">\n      </span><span class="s1">'Headers cannot be modified. Read more: https://nextjs.org/docs/app/api-reference/functions/headers'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public static callable() {</span><span class="s3">\n    </span><span class="s1">throw new ReadonlyHeadersError()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type ReadonlyHeaders = Headers &amp; {</span><span class="s3">\n  </span><span class="s1">/** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */</span><span class="s3">\n  </span><span class="s1">append(...args: any[]): void</span><span class="s3">\n  </span><span class="s1">/** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */</span><span class="s3">\n  </span><span class="s1">set(...args: any[]): void</span><span class="s3">\n  </span><span class="s1">/** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */</span><span class="s3">\n  </span><span class="s1">delete(...args: any[]): void</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class HeadersAdapter extends Headers {</span><span class="s3">\n  </span><span class="s1">private readonly headers: IncomingHttpHeaders</span><span class="s3">\n\n  </span><span class="s1">constructor(headers: IncomingHttpHeaders) {</span><span class="s3">\n    </span><span class="s1">// We've already overridden the methods that would be called, so we're just</span><span class="s3">\n    </span><span class="s1">// calling the super constructor to ensure that the instanceof check works.</span><span class="s3">\n    </span><span class="s1">super()</span><span class="s3">\n\n    </span><span class="s1">this.headers = new Proxy(headers, {</span><span class="s3">\n      </span><span class="s1">get(target, prop, receiver) {</span><span class="s3">\n        </span><span class="s1">// Because this is just an object, we expect that all </span><span class="s3">\&quot;</span><span class="s1">get</span><span class="s3">\&quot; </span><span class="s1">operations</span><span class="s3">\n        </span><span class="s1">// are for properties. If it's a </span><span class="s3">\&quot;</span><span class="s1">get</span><span class="s3">\&quot; </span><span class="s1">for a symbol, we'll just return</span><span class="s3">\n        </span><span class="s1">// the symbol.</span><span class="s3">\n        </span><span class="s1">if (typeof prop === 'symbol') {</span><span class="s3">\n          </span><span class="s1">return ReflectAdapter.get(target, prop, receiver)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const lowercased = prop.toLowerCase()</span><span class="s3">\n\n        </span><span class="s1">// Let's find the original casing of the key. This assumes that there is</span><span class="s3">\n        </span><span class="s1">// no mixed case keys (e.g. </span><span class="s3">\&quot;</span><span class="s1">Content-Type</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">content-type</span><span class="s3">\&quot;</span><span class="s1">) in the</span><span class="s3">\n        </span><span class="s1">// headers object.</span><span class="s3">\n        </span><span class="s1">const original = Object.keys(headers).find(</span><span class="s3">\n          </span><span class="s1">(o) =&gt; o.toLowerCase() === lowercased</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">// If the original casing doesn't exist, return undefined.</span><span class="s3">\n        </span><span class="s1">if (typeof original === 'undefined') return</span><span class="s3">\n\n        </span><span class="s1">// If the original casing exists, return the value.</span><span class="s3">\n        </span><span class="s1">return ReflectAdapter.get(target, original, receiver)</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">set(target, prop, value, receiver) {</span><span class="s3">\n        </span><span class="s1">if (typeof prop === 'symbol') {</span><span class="s3">\n          </span><span class="s1">return ReflectAdapter.set(target, prop, value, receiver)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const lowercased = prop.toLowerCase()</span><span class="s3">\n\n        </span><span class="s1">// Let's find the original casing of the key. This assumes that there is</span><span class="s3">\n        </span><span class="s1">// no mixed case keys (e.g. </span><span class="s3">\&quot;</span><span class="s1">Content-Type</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">content-type</span><span class="s3">\&quot;</span><span class="s1">) in the</span><span class="s3">\n        </span><span class="s1">// headers object.</span><span class="s3">\n        </span><span class="s1">const original = Object.keys(headers).find(</span><span class="s3">\n          </span><span class="s1">(o) =&gt; o.toLowerCase() === lowercased</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">// If the original casing doesn't exist, use the prop as the key.</span><span class="s3">\n        </span><span class="s1">return ReflectAdapter.set(target, original ?? prop, value, receiver)</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">has(target, prop) {</span><span class="s3">\n        </span><span class="s1">if (typeof prop === 'symbol') return ReflectAdapter.has(target, prop)</span><span class="s3">\n\n        </span><span class="s1">const lowercased = prop.toLowerCase()</span><span class="s3">\n\n        </span><span class="s1">// Let's find the original casing of the key. This assumes that there is</span><span class="s3">\n        </span><span class="s1">// no mixed case keys (e.g. </span><span class="s3">\&quot;</span><span class="s1">Content-Type</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">content-type</span><span class="s3">\&quot;</span><span class="s1">) in the</span><span class="s3">\n        </span><span class="s1">// headers object.</span><span class="s3">\n        </span><span class="s1">const original = Object.keys(headers).find(</span><span class="s3">\n          </span><span class="s1">(o) =&gt; o.toLowerCase() === lowercased</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">// If the original casing doesn't exist, return false.</span><span class="s3">\n        </span><span class="s1">if (typeof original === 'undefined') return false</span><span class="s3">\n\n        </span><span class="s1">// If the original casing exists, return true.</span><span class="s3">\n        </span><span class="s1">return ReflectAdapter.has(target, original)</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">deleteProperty(target, prop) {</span><span class="s3">\n        </span><span class="s1">if (typeof prop === 'symbol')</span><span class="s3">\n          </span><span class="s1">return ReflectAdapter.deleteProperty(target, prop)</span><span class="s3">\n\n        </span><span class="s1">const lowercased = prop.toLowerCase()</span><span class="s3">\n\n        </span><span class="s1">// Let's find the original casing of the key. This assumes that there is</span><span class="s3">\n        </span><span class="s1">// no mixed case keys (e.g. </span><span class="s3">\&quot;</span><span class="s1">Content-Type</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">content-type</span><span class="s3">\&quot;</span><span class="s1">) in the</span><span class="s3">\n        </span><span class="s1">// headers object.</span><span class="s3">\n        </span><span class="s1">const original = Object.keys(headers).find(</span><span class="s3">\n          </span><span class="s1">(o) =&gt; o.toLowerCase() === lowercased</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">// If the original casing doesn't exist, return true.</span><span class="s3">\n        </span><span class="s1">if (typeof original === 'undefined') return true</span><span class="s3">\n\n        </span><span class="s1">// If the original casing exists, delete the property.</span><span class="s3">\n        </span><span class="s1">return ReflectAdapter.deleteProperty(target, original)</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Seals a Headers instance to prevent modification by throwing an error when</span><span class="s3">\n   </span><span class="s1">* any mutating method is called.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public static seal(headers: Headers): ReadonlyHeaders {</span><span class="s3">\n    </span><span class="s1">return new Proxy&lt;ReadonlyHeaders&gt;(headers, {</span><span class="s3">\n      </span><span class="s1">get(target, prop, receiver) {</span><span class="s3">\n        </span><span class="s1">switch (prop) {</span><span class="s3">\n          </span><span class="s1">case 'append':</span><span class="s3">\n          </span><span class="s1">case 'delete':</span><span class="s3">\n          </span><span class="s1">case 'set':</span><span class="s3">\n            </span><span class="s1">return ReadonlyHeadersError.callable</span><span class="s3">\n          </span><span class="s1">default:</span><span class="s3">\n            </span><span class="s1">return ReflectAdapter.get(target, prop, receiver)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Merges a header value into a string. This stores multiple values as an</span><span class="s3">\n   </span><span class="s1">* array, so we need to merge them into a string.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param value a header value</span><span class="s3">\n   </span><span class="s1">* @returns a merged header value (a string)</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private merge(value: string | string[]): string {</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(value)) return value.join(', ')</span><span class="s3">\n\n    </span><span class="s1">return value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Creates a Headers instance from a plain object or a Headers instance.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param headers a plain object or a Headers instance</span><span class="s3">\n   </span><span class="s1">* @returns a headers instance</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public static from(headers: IncomingHttpHeaders | Headers): Headers {</span><span class="s3">\n    </span><span class="s1">if (headers instanceof Headers) return headers</span><span class="s3">\n\n    </span><span class="s1">return new HeadersAdapter(headers)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public append(name: string, value: string): void {</span><span class="s3">\n    </span><span class="s1">const existing = this.headers[name]</span><span class="s3">\n    </span><span class="s1">if (typeof existing === 'string') {</span><span class="s3">\n      </span><span class="s1">this.headers[name] = [existing, value]</span><span class="s3">\n    </span><span class="s1">} else if (Array.isArray(existing)) {</span><span class="s3">\n      </span><span class="s1">existing.push(value)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this.headers[name] = value</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public delete(name: string): void {</span><span class="s3">\n    </span><span class="s1">delete this.headers[name]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get(name: string): string | null {</span><span class="s3">\n    </span><span class="s1">const value = this.headers[name]</span><span class="s3">\n    </span><span class="s1">if (typeof value !== 'undefined') return this.merge(value)</span><span class="s3">\n\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public has(name: string): boolean {</span><span class="s3">\n    </span><span class="s1">return typeof this.headers[name] !== 'undefined'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public set(name: string, value: string): void {</span><span class="s3">\n    </span><span class="s1">this.headers[name] = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public forEach(</span><span class="s3">\n    </span><span class="s1">callbackfn: (value: string, name: string, parent: Headers) =&gt; void,</span><span class="s3">\n    </span><span class="s1">thisArg?: any</span><span class="s3">\n  </span><span class="s1">): void {</span><span class="s3">\n    </span><span class="s1">for (const [name, value] of this.entries()) {</span><span class="s3">\n      </span><span class="s1">callbackfn.call(thisArg, value, name, this)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public *entries(): HeadersIterator&lt;[string, string]&gt; {</span><span class="s3">\n    </span><span class="s1">for (const key of Object.keys(this.headers)) {</span><span class="s3">\n      </span><span class="s1">const name = key.toLowerCase()</span><span class="s3">\n      </span><span class="s1">// We assert here that this is a string because we got it from the</span><span class="s3">\n      </span><span class="s1">// Object.keys() call above.</span><span class="s3">\n      </span><span class="s1">const value = this.get(name) as string</span><span class="s3">\n\n      </span><span class="s1">yield [name, value] as [string, string]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public *keys(): HeadersIterator&lt;string&gt; {</span><span class="s3">\n    </span><span class="s1">for (const key of Object.keys(this.headers)) {</span><span class="s3">\n      </span><span class="s1">const name = key.toLowerCase()</span><span class="s3">\n      </span><span class="s1">yield name</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public *values(): HeadersIterator&lt;string&gt; {</span><span class="s3">\n    </span><span class="s1">for (const key of Object.keys(this.headers)) {</span><span class="s3">\n      </span><span class="s1">// We assert here that this is a string because we got it from the</span><span class="s3">\n      </span><span class="s1">// Object.keys() call above.</span><span class="s3">\n      </span><span class="s1">const value = this.get(key) as string</span><span class="s3">\n\n      </span><span class="s1">yield value</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public [Symbol.iterator](): HeadersIterator&lt;[string, string]&gt; {</span><span class="s3">\n    </span><span class="s1">return this.entries()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* This module is for next.js server internal usage of path module.</span><span class="s3">\n </span><span class="s1">* It will use native path module for nodejs runtime.</span><span class="s3">\n </span><span class="s1">* It will use path-browserify polyfill for edge runtime.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">let path</span><span class="s3">\n\n</span><span class="s1">if (process.env.NEXT_RUNTIME === 'edge') {</span><span class="s3">\n  </span><span class="s1">path = require('next/dist/compiled/path-browserify')</span><span class="s3">\n</span><span class="s1">} else {</span><span class="s3">\n  </span><span class="s1">path = require('path')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = path</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// Note: This file is JS because it's used by the taskfile-swc.js file, which is JS.</span><span class="s3">\n</span><span class="s1">// Keep file changes in sync with the corresponding `.d.ts` files.</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* These are the browser versions that support all of the following:</span><span class="s3">\n </span><span class="s1">* static import: https://caniuse.com/es6-module</span><span class="s3">\n </span><span class="s1">* dynamic import: https://caniuse.com/es6-module-dynamic-import</span><span class="s3">\n </span><span class="s1">* import.meta: https://caniuse.com/mdn-javascript_operators_import_meta</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const MODERN_BROWSERSLIST_TARGET = [</span><span class="s3">\n  </span><span class="s1">'chrome 64',</span><span class="s3">\n  </span><span class="s1">'edge 79',</span><span class="s3">\n  </span><span class="s1">'firefox 67',</span><span class="s3">\n  </span><span class="s1">'opera 51',</span><span class="s3">\n  </span><span class="s1">'safari 12',</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">module.exports = MODERN_BROWSERSLIST_TARGET</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;let ReactDOMServer</span><span class="s3">\n\n</span><span class="s1">try {</span><span class="s3">\n  </span><span class="s1">// TODO: Use Node.js build unless we're in an Edge runtime.</span><span class="s3">\n  </span><span class="s1">ReactDOMServer = require('react-dom/server.edge')</span><span class="s3">\n</span><span class="s1">} catch (error) {</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">error.code !== 'MODULE_NOT_FOUND' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">error.code !== 'ERR_PACKAGE_PATH_NOT_EXPORTED'</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">throw error</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// In React versions without react-dom/server.edge, the browser build works in Node.js.</span><span class="s3">\n  </span><span class="s1">// The Node.js build does not support renderToReadableStream.</span><span class="s3">\n  </span><span class="s1">ReactDOMServer = require('react-dom/server.browser')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = ReactDOMServer</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;(()=&gt;{var e={318:function(e,t){(function(e,n){true?n(t):0})(this,(function(e){</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;class StructError extends TypeError{constructor(e,t){let n;const{message:r,explanation:i,...c}=e;const{path:o}=e;const a=o.length===0?r:`At path: ${o.join(</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">)} -- ${r}`;super(i??a);if(i!=null)this.cause=a;Object.assign(this,c);this.name=this.constructor.name;this.failures=()=&gt;n??(n=[e,...t()])}}function isIterable(e){return isObject(e)&amp;&amp;typeof e[Symbol.iterator]===</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">}function isObject(e){return typeof e===</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">&amp;&amp;e!=null}function isPlainObject(e){if(Object.prototype.toString.call(e)!==</span><span class="s3">\&quot;</span><span class="s1">[object Object]</span><span class="s3">\&quot;</span><span class="s1">){return false}const t=Object.getPrototypeOf(e);return t===null||t===Object.prototype}function print(e){if(typeof e===</span><span class="s3">\&quot;</span><span class="s1">symbol</span><span class="s3">\&quot;</span><span class="s1">){return e.toString()}return typeof e===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">?JSON.stringify(e):`${e}`}function shiftIterator(e){const{done:t,value:n}=e.next();return t?undefined:n}function toFailure(e,t,n,r){if(e===true){return}else if(e===false){e={}}else if(typeof e===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">){e={message:e}}const{path:i,branch:c}=t;const{type:o}=n;const{refinement:a,message:s=`Expected a value of type </span><span class="s3">\\</span><span class="s1">`${o}</span><span class="s3">\\</span><span class="s1">`${a?` with refinement </span><span class="s3">\\</span><span class="s1">`${a}</span><span class="s3">\\</span><span class="s1">``:</span><span class="s3">\&quot;\&quot;</span><span class="s1">}, but received: </span><span class="s3">\\</span><span class="s1">`${print(r)}</span><span class="s3">\\</span><span class="s1">``}=e;return{value:r,type:o,refinement:a,key:i[i.length-1],path:i,branch:c,...e,message:s}}function*toFailures(e,t,n,r){if(!isIterable(e)){e=[e]}for(const i of e){const e=toFailure(i,t,n,r);if(e){yield e}}}function*run(e,t,n={}){const{path:r=[],branch:i=[e],coerce:c=false,mask:o=false}=n;const a={path:r,branch:i};if(c){e=t.coercer(e,a);if(o&amp;&amp;t.type!==</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">&amp;&amp;isObject(t.schema)&amp;&amp;isObject(e)&amp;&amp;!Array.isArray(e)){for(const n in e){if(t.schema[n]===undefined){delete e[n]}}}}let s=</span><span class="s3">\&quot;</span><span class="s1">valid</span><span class="s3">\&quot;</span><span class="s1">;for(const r of t.validator(e,a)){r.explanation=n.message;s=</span><span class="s3">\&quot;</span><span class="s1">not_valid</span><span class="s3">\&quot;</span><span class="s1">;yield[r,undefined]}for(let[u,f,l]of t.entries(e,a)){const t=run(f,l,{path:u===undefined?r:[...r,u],branch:u===undefined?i:[...i,f],coerce:c,mask:o,message:n.message});for(const n of t){if(n[0]){s=n[0].refinement!=null?</span><span class="s3">\&quot;</span><span class="s1">not_refined</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">not_valid</span><span class="s3">\&quot;</span><span class="s1">;yield[n[0],undefined]}else if(c){f=n[1];if(u===undefined){e=f}else if(e instanceof Map){e.set(u,f)}else if(e instanceof Set){e.add(f)}else if(isObject(e)){if(f!==undefined||u in e)e[u]=f}}}}if(s!==</span><span class="s3">\&quot;</span><span class="s1">not_valid</span><span class="s3">\&quot;</span><span class="s1">){for(const r of t.refiner(e,a)){r.explanation=n.message;s=</span><span class="s3">\&quot;</span><span class="s1">not_refined</span><span class="s3">\&quot;</span><span class="s1">;yield[r,undefined]}}if(s===</span><span class="s3">\&quot;</span><span class="s1">valid</span><span class="s3">\&quot;</span><span class="s1">){yield[undefined,e]}}class Struct{constructor(e){const{type:t,schema:n,validator:r,refiner:i,coercer:c=(e=&gt;e),entries:o=function*(){}}=e;this.type=t;this.schema=n;this.entries=o;this.coercer=c;if(r){this.validator=(e,t)=&gt;{const n=r(e,t);return toFailures(n,t,this,e)}}else{this.validator=()=&gt;[]}if(i){this.refiner=(e,t)=&gt;{const n=i(e,t);return toFailures(n,t,this,e)}}else{this.refiner=()=&gt;[]}}assert(e,t){return assert(e,this,t)}create(e,t){return create(e,this,t)}is(e){return is(e,this)}mask(e,t){return mask(e,this,t)}validate(e,t={}){return validate(e,this,t)}}function assert(e,t,n){const r=validate(e,t,{message:n});if(r[0]){throw r[0]}}function create(e,t,n){const r=validate(e,t,{coerce:true,message:n});if(r[0]){throw r[0]}else{return r[1]}}function mask(e,t,n){const r=validate(e,t,{coerce:true,mask:true,message:n});if(r[0]){throw r[0]}else{return r[1]}}function is(e,t){const n=validate(e,t);return!n[0]}function validate(e,t,n={}){const r=run(e,t,n);const i=shiftIterator(r);if(i[0]){const e=new StructError(i[0],(function*(){for(const e of r){if(e[0]){yield e[0]}}}));return[e,undefined]}else{const e=i[1];return[undefined,e]}}function assign(...e){const t=e[0].type===</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">;const n=e.map((e=&gt;e.schema));const r=Object.assign({},...n);return t?type(r):object(r)}function define(e,t){return new Struct({type:e,schema:null,validator:t})}function deprecated(e,t){return new Struct({...e,refiner:(t,n)=&gt;t===undefined||e.refiner(t,n),validator(n,r){if(n===undefined){return true}else{t(n,r);return e.validator(n,r)}}})}function dynamic(e){return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">dynamic</span><span class="s3">\&quot;</span><span class="s1">,schema:null,*entries(t,n){const r=e(t,n);yield*r.entries(t,n)},validator(t,n){const r=e(t,n);return r.validator(t,n)},coercer(t,n){const r=e(t,n);return r.coercer(t,n)},refiner(t,n){const r=e(t,n);return r.refiner(t,n)}})}function lazy(e){let t;return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">lazy</span><span class="s3">\&quot;</span><span class="s1">,schema:null,*entries(n,r){t??(t=e());yield*t.entries(n,r)},validator(n,r){t??(t=e());return t.validator(n,r)},coercer(n,r){t??(t=e());return t.coercer(n,r)},refiner(n,r){t??(t=e());return t.refiner(n,r)}})}function omit(e,t){const{schema:n}=e;const r={...n};for(const e of t){delete r[e]}switch(e.type){case</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">:return type(r);default:return object(r)}}function partial(e){const t=e instanceof Struct?{...e.schema}:{...e};for(const e in t){t[e]=optional(t[e])}return object(t)}function pick(e,t){const{schema:n}=e;const r={};for(const e of t){r[e]=n[e]}return object(r)}function struct(e,t){console.warn(</span><span class="s3">\&quot;</span><span class="s1">superstruct@0.11 - The `struct` helper has been renamed to `define`.</span><span class="s3">\&quot;</span><span class="s1">);return define(e,t)}function any(){return define(</span><span class="s3">\&quot;</span><span class="s1">any</span><span class="s3">\&quot;</span><span class="s1">,(()=&gt;true))}function array(e){return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">array</span><span class="s3">\&quot;</span><span class="s1">,schema:e,*entries(t){if(e&amp;&amp;Array.isArray(t)){for(const[n,r]of t.entries()){yield[n,r,e]}}},coercer(e){return Array.isArray(e)?e.slice():e},validator(e){return Array.isArray(e)||`Expected an array value, but received: ${print(e)}`}})}function bigint(){return define(</span><span class="s3">\&quot;</span><span class="s1">bigint</span><span class="s3">\&quot;</span><span class="s1">,(e=&gt;typeof e===</span><span class="s3">\&quot;</span><span class="s1">bigint</span><span class="s3">\&quot;</span><span class="s1">))}function boolean(){return define(</span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">,(e=&gt;typeof e===</span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">))}function date(){return define(</span><span class="s3">\&quot;</span><span class="s1">date</span><span class="s3">\&quot;</span><span class="s1">,(e=&gt;e instanceof Date&amp;&amp;!isNaN(e.getTime())||`Expected a valid </span><span class="s3">\\</span><span class="s1">`Date</span><span class="s3">\\</span><span class="s1">` object, but received: ${print(e)}`))}function enums(e){const t={};const n=e.map((e=&gt;print(e))).join();for(const n of e){t[n]=n}return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">enums</span><span class="s3">\&quot;</span><span class="s1">,schema:t,validator(t){return e.includes(t)||`Expected one of </span><span class="s3">\\</span><span class="s1">`${n}</span><span class="s3">\\</span><span class="s1">`, but received: ${print(t)}`}})}function func(){return define(</span><span class="s3">\&quot;</span><span class="s1">func</span><span class="s3">\&quot;</span><span class="s1">,(e=&gt;typeof e===</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">||`Expected a function, but received: ${print(e)}`))}function instance(e){return define(</span><span class="s3">\&quot;</span><span class="s1">instance</span><span class="s3">\&quot;</span><span class="s1">,(t=&gt;t instanceof e||`Expected a </span><span class="s3">\\</span><span class="s1">`${e.name}</span><span class="s3">\\</span><span class="s1">` instance, but received: ${print(t)}`))}function integer(){return define(</span><span class="s3">\&quot;</span><span class="s1">integer</span><span class="s3">\&quot;</span><span class="s1">,(e=&gt;typeof e===</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">&amp;&amp;!isNaN(e)&amp;&amp;Number.isInteger(e)||`Expected an integer, but received: ${print(e)}`))}function intersection(e){return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">intersection</span><span class="s3">\&quot;</span><span class="s1">,schema:null,*entries(t,n){for(const r of e){yield*r.entries(t,n)}},*validator(t,n){for(const r of e){yield*r.validator(t,n)}},*refiner(t,n){for(const r of e){yield*r.refiner(t,n)}}})}function literal(e){const t=print(e);const n=typeof e;return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">literal</span><span class="s3">\&quot;</span><span class="s1">,schema:n===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">||n===</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">||n===</span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">?e:null,validator(n){return n===e||`Expected the literal </span><span class="s3">\\</span><span class="s1">`${t}</span><span class="s3">\\</span><span class="s1">`, but received: ${print(n)}`}})}function map(e,t){return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">map</span><span class="s3">\&quot;</span><span class="s1">,schema:null,*entries(n){if(e&amp;&amp;t&amp;&amp;n instanceof Map){for(const[r,i]of n.entries()){yield[r,r,e];yield[r,i,t]}}},coercer(e){return e instanceof Map?new Map(e):e},validator(e){return e instanceof Map||`Expected a </span><span class="s3">\\</span><span class="s1">`Map</span><span class="s3">\\</span><span class="s1">` object, but received: ${print(e)}`}})}function never(){return define(</span><span class="s3">\&quot;</span><span class="s1">never</span><span class="s3">\&quot;</span><span class="s1">,(()=&gt;false))}function nullable(e){return new Struct({...e,validator:(t,n)=&gt;t===null||e.validator(t,n),refiner:(t,n)=&gt;t===null||e.refiner(t,n)})}function number(){return define(</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">,(e=&gt;typeof e===</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">&amp;&amp;!isNaN(e)||`Expected a number, but received: ${print(e)}`))}function object(e){const t=e?Object.keys(e):[];const n=never();return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">,schema:e?e:null,*entries(r){if(e&amp;&amp;isObject(r)){const i=new Set(Object.keys(r));for(const n of t){i.delete(n);yield[n,r[n],e[n]]}for(const e of i){yield[e,r[e],n]}}},validator(e){return isObject(e)||`Expected an object, but received: ${print(e)}`},coercer(e){return isObject(e)?{...e}:e}})}function optional(e){return new Struct({...e,validator:(t,n)=&gt;t===undefined||e.validator(t,n),refiner:(t,n)=&gt;t===undefined||e.refiner(t,n)})}function record(e,t){return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">record</span><span class="s3">\&quot;</span><span class="s1">,schema:null,*entries(n){if(isObject(n)){for(const r in n){const i=n[r];yield[r,r,e];yield[r,i,t]}}},validator(e){return isObject(e)||`Expected an object, but received: ${print(e)}`}})}function regexp(){return define(</span><span class="s3">\&quot;</span><span class="s1">regexp</span><span class="s3">\&quot;</span><span class="s1">,(e=&gt;e instanceof RegExp))}function set(e){return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">set</span><span class="s3">\&quot;</span><span class="s1">,schema:null,*entries(t){if(e&amp;&amp;t instanceof Set){for(const n of t){yield[n,n,e]}}},coercer(e){return e instanceof Set?new Set(e):e},validator(e){return e instanceof Set||`Expected a </span><span class="s3">\\</span><span class="s1">`Set</span><span class="s3">\\</span><span class="s1">` object, but received: ${print(e)}`}})}function string(){return define(</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">,(e=&gt;typeof e===</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">||`Expected a string, but received: ${print(e)}`))}function tuple(e){const t=never();return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">tuple</span><span class="s3">\&quot;</span><span class="s1">,schema:null,*entries(n){if(Array.isArray(n)){const r=Math.max(e.length,n.length);for(let i=0;i&lt;r;i++){yield[i,n[i],e[i]||t]}}},validator(e){return Array.isArray(e)||`Expected an array, but received: ${print(e)}`}})}function type(e){const t=Object.keys(e);return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">,schema:e,*entries(n){if(isObject(n)){for(const r of t){yield[r,n[r],e[r]]}}},validator(e){return isObject(e)||`Expected an object, but received: ${print(e)}`},coercer(e){return isObject(e)?{...e}:e}})}function union(e){const t=e.map((e=&gt;e.type)).join(</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">);return new Struct({type:</span><span class="s3">\&quot;</span><span class="s1">union</span><span class="s3">\&quot;</span><span class="s1">,schema:null,coercer(t){for(const n of e){const[e,r]=n.validate(t,{coerce:true});if(!e){return r}}return t},validator(n,r){const i=[];for(const t of e){const[...e]=run(n,t,r);const[c]=e;if(!c[0]){return[]}else{for(const[t]of e){if(t){i.push(t)}}}}return[`Expected the value to satisfy a union of </span><span class="s3">\\</span><span class="s1">`${t}</span><span class="s3">\\</span><span class="s1">`, but received: ${print(n)}`,...i]}})}function unknown(){return define(</span><span class="s3">\&quot;</span><span class="s1">unknown</span><span class="s3">\&quot;</span><span class="s1">,(()=&gt;true))}function coerce(e,t,n){return new Struct({...e,coercer:(r,i)=&gt;is(r,t)?e.coercer(n(r,i),i):e.coercer(r,i)})}function defaulted(e,t,n={}){return coerce(e,unknown(),(e=&gt;{const r=typeof t===</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">?t():t;if(e===undefined){return r}if(!n.strict&amp;&amp;isPlainObject(e)&amp;&amp;isPlainObject(r)){const t={...e};let n=false;for(const e in r){if(t[e]===undefined){t[e]=r[e];n=true}}if(n){return t}}return e}))}function trimmed(e){return coerce(e,string(),(e=&gt;e.trim()))}function empty(e){return refine(e,</span><span class="s3">\&quot;</span><span class="s1">empty</span><span class="s3">\&quot;</span><span class="s1">,(t=&gt;{const n=getSize(t);return n===0||`Expected an empty ${e.type} but received one with a size of </span><span class="s3">\\</span><span class="s1">`${n}</span><span class="s3">\\</span><span class="s1">``}))}function getSize(e){if(e instanceof Map||e instanceof Set){return e.size}else{return e.length}}function max(e,t,n={}){const{exclusive:r}=n;return refine(e,</span><span class="s3">\&quot;</span><span class="s1">max</span><span class="s3">\&quot;</span><span class="s1">,(n=&gt;r?n&lt;t:n&lt;=t||`Expected a ${e.type} less than ${r?</span><span class="s3">\&quot;\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">or equal to </span><span class="s3">\&quot;</span><span class="s1">}${t} but received </span><span class="s3">\\</span><span class="s1">`${n}</span><span class="s3">\\</span><span class="s1">``))}function min(e,t,n={}){const{exclusive:r}=n;return refine(e,</span><span class="s3">\&quot;</span><span class="s1">min</span><span class="s3">\&quot;</span><span class="s1">,(n=&gt;r?n&gt;t:n&gt;=t||`Expected a ${e.type} greater than ${r?</span><span class="s3">\&quot;\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">or equal to </span><span class="s3">\&quot;</span><span class="s1">}${t} but received </span><span class="s3">\\</span><span class="s1">`${n}</span><span class="s3">\\</span><span class="s1">``))}function nonempty(e){return refine(e,</span><span class="s3">\&quot;</span><span class="s1">nonempty</span><span class="s3">\&quot;</span><span class="s1">,(t=&gt;{const n=getSize(t);return n&gt;0||`Expected a nonempty ${e.type} but received an empty one`}))}function pattern(e,t){return refine(e,</span><span class="s3">\&quot;</span><span class="s1">pattern</span><span class="s3">\&quot;</span><span class="s1">,(n=&gt;t.test(n)||`Expected a ${e.type} matching </span><span class="s3">\\</span><span class="s1">`/${t.source}/</span><span class="s3">\\</span><span class="s1">` but received </span><span class="s3">\&quot;</span><span class="s1">${n}</span><span class="s3">\&quot;</span><span class="s1">`))}function size(e,t,n=t){const r=`Expected a ${e.type}`;const i=t===n?`of </span><span class="s3">\\</span><span class="s1">`${t}</span><span class="s3">\\</span><span class="s1">``:`between </span><span class="s3">\\</span><span class="s1">`${t}</span><span class="s3">\\</span><span class="s1">` and </span><span class="s3">\\</span><span class="s1">`${n}</span><span class="s3">\\</span><span class="s1">``;return refine(e,</span><span class="s3">\&quot;</span><span class="s1">size</span><span class="s3">\&quot;</span><span class="s1">,(e=&gt;{if(typeof e===</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">||e instanceof Date){return t&lt;=e&amp;&amp;e&lt;=n||`${r} ${i} but received </span><span class="s3">\\</span><span class="s1">`${e}</span><span class="s3">\\</span><span class="s1">``}else if(e instanceof Map||e instanceof Set){const{size:c}=e;return t&lt;=c&amp;&amp;c&lt;=n||`${r} with a size ${i} but received one with a size of </span><span class="s3">\\</span><span class="s1">`${c}</span><span class="s3">\\</span><span class="s1">``}else{const{length:c}=e;return t&lt;=c&amp;&amp;c&lt;=n||`${r} with a length ${i} but received one with a length of </span><span class="s3">\\</span><span class="s1">`${c}</span><span class="s3">\\</span><span class="s1">``}}))}function refine(e,t,n){return new Struct({...e,*refiner(r,i){yield*e.refiner(r,i);const c=n(r,i);const o=toFailures(c,i,e,r);for(const e of o){yield{...e,refinement:t}}}})}e.Struct=Struct;e.StructError=StructError;e.any=any;e.array=array;e.assert=assert;e.assign=assign;e.bigint=bigint;e.boolean=boolean;e.coerce=coerce;e.create=create;e.date=date;e.defaulted=defaulted;e.define=define;e.deprecated=deprecated;e.dynamic=dynamic;e.empty=empty;e.enums=enums;e.func=func;e.instance=instance;e.integer=integer;e.intersection=intersection;e.is=is;e.lazy=lazy;e.literal=literal;e.map=map;e.mask=mask;e.max=max;e.min=min;e.never=never;e.nonempty=nonempty;e.nullable=nullable;e.number=number;e.object=object;e.omit=omit;e.optional=optional;e.partial=partial;e.pattern=pattern;e.pick=pick;e.record=record;e.refine=refine;e.regexp=regexp;e.set=set;e.size=size;e.string=string;e.struct=struct;e.trimmed=trimmed;e.tuple=tuple;e.type=type;e.union=union;e.unknown=unknown;e.validate=validate}))}};if(typeof __nccwpck_require__!==</span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">)__nccwpck_require__.ab=__dirname+</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">;var t={};e[318](0,t);module.exports=t})();&quot;</span><span class="s0">,</span><span class="s1">&quot;// getDefaultExport function for compatibility with non-ESM modules</span><span class="s3">\n</span><span class="s1">__webpack_require__.n = (module) =&gt; {</span><span class="s3">\n\t</span><span class="s1">var getter = module &amp;&amp; module.__esModule ?</span><span class="s3">\n\t\t</span><span class="s1">() =&gt; (module['default']) :</span><span class="s3">\n\t\t</span><span class="s1">() =&gt; (module);</span><span class="s3">\n\t</span><span class="s1">__webpack_require__.d(getter, { a: getter });</span><span class="s3">\n\t</span><span class="s1">return getter;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var getProto = Object.getPrototypeOf ? (obj) =&gt; (Object.getPrototypeOf(obj)) : (obj) =&gt; (obj.__proto__);</span><span class="s3">\n</span><span class="s1">var leafPrototypes;</span><span class="s3">\n</span><span class="s1">// create a fake namespace object</span><span class="s3">\n</span><span class="s1">// mode &amp; 1: value is a module id, require it</span><span class="s3">\n</span><span class="s1">// mode &amp; 2: merge all properties of value into the ns</span><span class="s3">\n</span><span class="s1">// mode &amp; 4: return value when already ns object</span><span class="s3">\n</span><span class="s1">// mode &amp; 16: return value when it's Promise-like</span><span class="s3">\n</span><span class="s1">// mode &amp; 8|1: behave like require</span><span class="s3">\n</span><span class="s1">__webpack_require__.t = function(value, mode) {</span><span class="s3">\n\t</span><span class="s1">if(mode &amp; 1) value = this(value);</span><span class="s3">\n\t</span><span class="s1">if(mode &amp; 8) return value;</span><span class="s3">\n\t</span><span class="s1">if(typeof value === 'object' &amp;&amp; value) {</span><span class="s3">\n\t\t</span><span class="s1">if((mode &amp; 4) &amp;&amp; value.__esModule) return value;</span><span class="s3">\n\t\t</span><span class="s1">if((mode &amp; 16) &amp;&amp; typeof value.then === 'function') return value;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">var ns = Object.create(null);</span><span class="s3">\n  </span><span class="s1">__webpack_require__.r(ns);</span><span class="s3">\n\t</span><span class="s1">var def = {};</span><span class="s3">\n\t</span><span class="s1">leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];</span><span class="s3">\n\t</span><span class="s1">for(var current = mode &amp; 2 &amp;&amp; value; typeof current == 'object' &amp;&amp; !~leafPrototypes.indexOf(current); current = getProto(current)) {</span><span class="s3">\n\t\t</span><span class="s1">Object.getOwnPropertyNames(current).forEach((key) =&gt; { def[key] = () =&gt; (value[key]) });</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">def['default'] = () =&gt; (value);</span><span class="s3">\n\t</span><span class="s1">__webpack_require__.d(ns, def);</span><span class="s3">\n\t</span><span class="s1">return ns;</span><span class="s3">\n</span><span class="s1">};&quot;</span><span class="s0">,</span><span class="s1">&quot;__webpack_require__.d = (exports, definition) =&gt; {</span><span class="s3">\n\t</span><span class="s1">for(var key in definition) {</span><span class="s3">\n        </span><span class="s1">if(__webpack_require__.o(definition, key) &amp;&amp; !__webpack_require__.o(exports, key)) {</span><span class="s3">\n            </span><span class="s1">Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};&quot;</span><span class="s0">,</span><span class="s1">&quot;__webpack_require__.o = (obj, prop) =&gt; (Object.prototype.hasOwnProperty.call(obj, prop))&quot;</span><span class="s0">,</span><span class="s1">&quot;// define __esModule on exports</span><span class="s3">\n</span><span class="s1">__webpack_require__.r = (exports) =&gt; {</span><span class="s3">\n\t</span><span class="s1">if(typeof Symbol !== 'undefined' &amp;&amp; Symbol.toStringTag) {</span><span class="s3">\n\t\t</span><span class="s1">Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">Object.defineProperty(exports, '__esModule', { value: true });</span><span class="s3">\n</span><span class="s1">};&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { IncomingMessage, ServerResponse } from 'http'</span><span class="s3">\n</span><span class="s1">import type { ParsedUrlQuery } from 'querystring'</span><span class="s3">\n</span><span class="s1">import type { ReactDOMServerReadableStream } from 'react-dom/server'</span><span class="s3">\n</span><span class="s1">import type { NextRouter } from '../shared/lib/router/router'</span><span class="s3">\n</span><span class="s1">import type { HtmlProps } from '../shared/lib/html-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import type { DomainLocale } from './config'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">AppType,</span><span class="s3">\n  </span><span class="s1">DocumentInitialProps,</span><span class="s3">\n  </span><span class="s1">DocumentType,</span><span class="s3">\n  </span><span class="s1">DocumentProps,</span><span class="s3">\n  </span><span class="s1">DocumentContext,</span><span class="s3">\n  </span><span class="s1">NextComponentType,</span><span class="s3">\n  </span><span class="s1">RenderPage,</span><span class="s3">\n  </span><span class="s1">RenderPageResult,</span><span class="s3">\n</span><span class="s1">} from '../shared/lib/utils'</span><span class="s3">\n</span><span class="s1">import type { ImageConfigComplete } from '../shared/lib/image-config'</span><span class="s3">\n</span><span class="s1">import type { Redirect } from '../lib/load-custom-routes'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">type NextApiRequestCookies,</span><span class="s3">\n  </span><span class="s1">type __ApiPreviewProps,</span><span class="s3">\n  </span><span class="s1">setLazyProp,</span><span class="s3">\n</span><span class="s1">} from './api-utils'</span><span class="s3">\n</span><span class="s1">import { getCookieParser } from './api-utils/get-cookie-parser'</span><span class="s3">\n</span><span class="s1">import type { LoadComponentsReturnType } from './load-components'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">GetServerSideProps,</span><span class="s3">\n  </span><span class="s1">GetStaticProps,</span><span class="s3">\n  </span><span class="s1">PreviewData,</span><span class="s3">\n  </span><span class="s1">ServerRuntime,</span><span class="s3">\n  </span><span class="s1">SizeLimit,</span><span class="s3">\n</span><span class="s1">} from '../types'</span><span class="s3">\n</span><span class="s1">import type { UnwrapPromise } from '../lib/coalesced-function'</span><span class="s3">\n</span><span class="s1">import type { ClientReferenceManifest } from '../build/webpack/plugins/flight-manifest-plugin'</span><span class="s3">\n</span><span class="s1">import type { NextFontManifest } from '../build/webpack/plugins/next-font-manifest-plugin'</span><span class="s3">\n</span><span class="s1">import type { PagesModule } from './route-modules/pages/module'</span><span class="s3">\n</span><span class="s1">import type { ComponentsEnhancer } from '../shared/lib/utils'</span><span class="s3">\n</span><span class="s1">import type { NextParsedUrlQuery } from './request-meta'</span><span class="s3">\n</span><span class="s1">import type { Revalidate } from './lib/cache-control'</span><span class="s3">\n</span><span class="s1">import type { COMPILER_NAMES } from '../shared/lib/constants'</span><span class="s3">\n\n</span><span class="s1">import React, { type JSX } from 'react'</span><span class="s3">\n</span><span class="s1">import ReactDOMServerPages from 'next/dist/server/ReactDOMServerPages'</span><span class="s3">\n</span><span class="s1">import { StyleRegistry, createStyleRegistry } from 'styled-jsx'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">GSP_NO_RETURNED_VALUE,</span><span class="s3">\n  </span><span class="s1">GSSP_COMPONENT_MEMBER_ERROR,</span><span class="s3">\n  </span><span class="s1">GSSP_NO_RETURNED_VALUE,</span><span class="s3">\n  </span><span class="s1">STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR,</span><span class="s3">\n  </span><span class="s1">SERVER_PROPS_GET_INIT_PROPS_CONFLICT,</span><span class="s3">\n  </span><span class="s1">SERVER_PROPS_SSG_CONFLICT,</span><span class="s3">\n  </span><span class="s1">SSG_GET_INITIAL_PROPS_CONFLICT,</span><span class="s3">\n  </span><span class="s1">UNSTABLE_REVALIDATE_RENAME_ERROR,</span><span class="s3">\n  </span><span class="s1">HTML_CONTENT_TYPE_HEADER,</span><span class="s3">\n  </span><span class="s1">JSON_CONTENT_TYPE_HEADER,</span><span class="s3">\n</span><span class="s1">} from '../lib/constants'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">NEXT_BUILTIN_DOCUMENT,</span><span class="s3">\n  </span><span class="s1">SERVER_PROPS_ID,</span><span class="s3">\n  </span><span class="s1">STATIC_PROPS_ID,</span><span class="s3">\n  </span><span class="s1">STATIC_STATUS_PAGES,</span><span class="s3">\n</span><span class="s1">} from '../shared/lib/constants'</span><span class="s3">\n</span><span class="s1">import { isSerializableProps } from '../lib/is-serializable-props'</span><span class="s3">\n</span><span class="s1">import { isInAmpMode } from '../shared/lib/amp-mode'</span><span class="s3">\n</span><span class="s1">import { AmpStateContext } from '../shared/lib/amp-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import { defaultHead } from '../shared/lib/head'</span><span class="s3">\n</span><span class="s1">import { HeadManagerContext } from '../shared/lib/head-manager-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import Loadable from '../shared/lib/loadable.shared-runtime'</span><span class="s3">\n</span><span class="s1">import { LoadableContext } from '../shared/lib/loadable-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import { RouterContext } from '../shared/lib/router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import { isDynamicRoute } from '../shared/lib/router/utils/is-dynamic'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">getDisplayName,</span><span class="s3">\n  </span><span class="s1">isResSent,</span><span class="s3">\n  </span><span class="s1">loadGetInitialProps,</span><span class="s3">\n</span><span class="s1">} from '../shared/lib/utils'</span><span class="s3">\n</span><span class="s1">import { HtmlContext } from '../shared/lib/html-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import { normalizePagePath } from '../shared/lib/page-path/normalize-page-path'</span><span class="s3">\n</span><span class="s1">import { denormalizePagePath } from '../shared/lib/page-path/denormalize-page-path'</span><span class="s3">\n</span><span class="s1">import { getRequestMeta } from './request-meta'</span><span class="s3">\n</span><span class="s1">import { allowedStatusCodes, getRedirectStatus } from '../lib/redirect-status'</span><span class="s3">\n</span><span class="s1">import RenderResult, { type PagesRenderResultMetadata } from './render-result'</span><span class="s3">\n</span><span class="s1">import isError from '../lib/is-error'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">streamToString,</span><span class="s3">\n  </span><span class="s1">renderToInitialFizzStream,</span><span class="s3">\n</span><span class="s1">} from './stream-utils/node-web-streams-helper'</span><span class="s3">\n</span><span class="s1">import { ImageConfigContext } from '../shared/lib/image-config-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import stripAnsi from 'next/dist/compiled/strip-ansi'</span><span class="s3">\n</span><span class="s1">import { stripInternalQueries } from './internal-utils'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">adaptForAppRouterInstance,</span><span class="s3">\n  </span><span class="s1">adaptForPathParams,</span><span class="s3">\n  </span><span class="s1">adaptForSearchParams,</span><span class="s3">\n  </span><span class="s1">PathnameContextProviderAdapter,</span><span class="s3">\n</span><span class="s1">} from '../shared/lib/router/adapters'</span><span class="s3">\n</span><span class="s1">import { AppRouterContext } from '../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">SearchParamsContext,</span><span class="s3">\n  </span><span class="s1">PathParamsContext,</span><span class="s3">\n</span><span class="s1">} from '../shared/lib/hooks-client-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import { getTracer } from './lib/trace/tracer'</span><span class="s3">\n</span><span class="s1">import { RenderSpan } from './lib/trace/constants'</span><span class="s3">\n</span><span class="s1">import { ReflectAdapter } from './web/spec-extension/adapters/reflect'</span><span class="s3">\n</span><span class="s1">import { getCacheControlHeader } from './lib/cache-control'</span><span class="s3">\n</span><span class="s1">import { getErrorSource } from '../shared/lib/error-source'</span><span class="s3">\n</span><span class="s1">import type { DeepReadonly } from '../shared/lib/deep-readonly'</span><span class="s3">\n</span><span class="s1">import type { PagesDevOverlayBridgeType } from '../next-devtools/userspace/pages/pages-dev-overlay-setup'</span><span class="s3">\n</span><span class="s1">import { getScriptNonceFromHeader } from './app-render/get-script-nonce-from-header'</span><span class="s3">\n\n</span><span class="s1">let tryGetPreviewData: typeof import('./api-utils/node/try-get-preview-data').tryGetPreviewData</span><span class="s3">\n</span><span class="s1">let warn: typeof import('../build/output/log').warn</span><span class="s3">\n</span><span class="s1">let postProcessHTML: typeof import('./post-process').postProcessHTML</span><span class="s3">\n\n</span><span class="s1">const DOCTYPE = '&lt;!DOCTYPE html&gt;'</span><span class="s3">\n\n</span><span class="s1">if (process.env.NEXT_RUNTIME !== 'edge') {</span><span class="s3">\n  </span><span class="s1">tryGetPreviewData = (</span><span class="s3">\n    </span><span class="s1">require('./api-utils/node/try-get-preview-data') as typeof import('./api-utils/node/try-get-preview-data')</span><span class="s3">\n  </span><span class="s1">).tryGetPreviewData</span><span class="s3">\n  </span><span class="s1">warn = (</span><span class="s3">\n    </span><span class="s1">require('../build/output/log') as typeof import('../build/output/log')</span><span class="s3">\n  </span><span class="s1">).warn</span><span class="s3">\n  </span><span class="s1">postProcessHTML = (</span><span class="s3">\n    </span><span class="s1">require('./post-process') as typeof import('./post-process')</span><span class="s3">\n  </span><span class="s1">).postProcessHTML</span><span class="s3">\n</span><span class="s1">} else {</span><span class="s3">\n  </span><span class="s1">warn = console.warn.bind(console)</span><span class="s3">\n  </span><span class="s1">postProcessHTML = async (_pathname: string, html: string) =&gt; html</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function noRouter() {</span><span class="s3">\n  </span><span class="s1">const message =</span><span class="s3">\n    </span><span class="s1">'No router instance found. you should only use </span><span class="s3">\&quot;</span><span class="s1">next/router</span><span class="s3">\&quot; </span><span class="s1">inside the client side of your app. https://nextjs.org/docs/messages/no-router-instance'</span><span class="s3">\n  </span><span class="s1">throw new Error(message)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">async function renderToString(element: React.ReactElement) {</span><span class="s3">\n  </span><span class="s1">const renderStream = await ReactDOMServerPages.renderToReadableStream(element)</span><span class="s3">\n  </span><span class="s1">await renderStream.allReady</span><span class="s3">\n  </span><span class="s1">return streamToString(renderStream)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">class ServerRouter implements NextRouter {</span><span class="s3">\n  </span><span class="s1">route: string</span><span class="s3">\n  </span><span class="s1">pathname: string</span><span class="s3">\n  </span><span class="s1">query: ParsedUrlQuery</span><span class="s3">\n  </span><span class="s1">asPath: string</span><span class="s3">\n  </span><span class="s1">basePath: string</span><span class="s3">\n  </span><span class="s1">events: any</span><span class="s3">\n  </span><span class="s1">isFallback: boolean</span><span class="s3">\n  </span><span class="s1">locale?: string</span><span class="s3">\n  </span><span class="s1">isReady: boolean</span><span class="s3">\n  </span><span class="s1">locales?: readonly string[]</span><span class="s3">\n  </span><span class="s1">defaultLocale?: string</span><span class="s3">\n  </span><span class="s1">domainLocales?: readonly DomainLocale[]</span><span class="s3">\n  </span><span class="s1">isPreview: boolean</span><span class="s3">\n  </span><span class="s1">isLocaleDomain: boolean</span><span class="s3">\n\n  </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">query: ParsedUrlQuery,</span><span class="s3">\n    </span><span class="s1">as: string,</span><span class="s3">\n    </span><span class="s1">{ isFallback }: { isFallback: boolean },</span><span class="s3">\n    </span><span class="s1">isReady: boolean,</span><span class="s3">\n    </span><span class="s1">basePath: string,</span><span class="s3">\n    </span><span class="s1">locale?: string,</span><span class="s3">\n    </span><span class="s1">locales?: readonly string[],</span><span class="s3">\n    </span><span class="s1">defaultLocale?: string,</span><span class="s3">\n    </span><span class="s1">domainLocales?: readonly DomainLocale[],</span><span class="s3">\n    </span><span class="s1">isPreview?: boolean,</span><span class="s3">\n    </span><span class="s1">isLocaleDomain?: boolean</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">this.route = pathname.replace(/</span><span class="s3">\\</span><span class="s1">/$/, '') || '/'</span><span class="s3">\n    </span><span class="s1">this.pathname = pathname</span><span class="s3">\n    </span><span class="s1">this.query = query</span><span class="s3">\n    </span><span class="s1">this.asPath = as</span><span class="s3">\n    </span><span class="s1">this.isFallback = isFallback</span><span class="s3">\n    </span><span class="s1">this.basePath = basePath</span><span class="s3">\n    </span><span class="s1">this.locale = locale</span><span class="s3">\n    </span><span class="s1">this.locales = locales</span><span class="s3">\n    </span><span class="s1">this.defaultLocale = defaultLocale</span><span class="s3">\n    </span><span class="s1">this.isReady = isReady</span><span class="s3">\n    </span><span class="s1">this.domainLocales = domainLocales</span><span class="s3">\n    </span><span class="s1">this.isPreview = !!isPreview</span><span class="s3">\n    </span><span class="s1">this.isLocaleDomain = !!isLocaleDomain</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">push(): any {</span><span class="s3">\n    </span><span class="s1">noRouter()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">replace(): any {</span><span class="s3">\n    </span><span class="s1">noRouter()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">reload() {</span><span class="s3">\n    </span><span class="s1">noRouter()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">back() {</span><span class="s3">\n    </span><span class="s1">noRouter()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">forward(): void {</span><span class="s3">\n    </span><span class="s1">noRouter()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">prefetch(): any {</span><span class="s3">\n    </span><span class="s1">noRouter()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">beforePopState() {</span><span class="s3">\n    </span><span class="s1">noRouter()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function enhanceComponents(</span><span class="s3">\n  </span><span class="s1">options: ComponentsEnhancer,</span><span class="s3">\n  </span><span class="s1">App: AppType,</span><span class="s3">\n  </span><span class="s1">Component: NextComponentType</span><span class="s3">\n</span><span class="s1">): {</span><span class="s3">\n  </span><span class="s1">App: AppType</span><span class="s3">\n  </span><span class="s1">Component: NextComponentType</span><span class="s3">\n</span><span class="s1">} {</span><span class="s3">\n  </span><span class="s1">// For backwards compatibility</span><span class="s3">\n  </span><span class="s1">if (typeof options === 'function') {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">App,</span><span class="s3">\n      </span><span class="s1">Component: options(Component),</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">App: options.enhanceApp ? options.enhanceApp(App) : App,</span><span class="s3">\n    </span><span class="s1">Component: options.enhanceComponent</span><span class="s3">\n      </span><span class="s1">? options.enhanceComponent(Component)</span><span class="s3">\n      </span><span class="s1">: Component,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function renderPageTree(</span><span class="s3">\n  </span><span class="s1">App: AppType,</span><span class="s3">\n  </span><span class="s1">Component: NextComponentType,</span><span class="s3">\n  </span><span class="s1">props: any</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return &lt;App Component={Component} {...props} /&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type RenderOptsPartial = {</span><span class="s3">\n  </span><span class="s1">canonicalBase: string</span><span class="s3">\n  </span><span class="s1">runtimeConfig?: { [key: string]: any }</span><span class="s3">\n  </span><span class="s1">assetPrefix?: string</span><span class="s3">\n  </span><span class="s1">err?: Error | null</span><span class="s3">\n  </span><span class="s1">nextExport?: boolean</span><span class="s3">\n  </span><span class="s1">dev?: boolean</span><span class="s3">\n  </span><span class="s1">ampPath?: string</span><span class="s3">\n  </span><span class="s1">ErrorDebug?: PagesDevOverlayBridgeType</span><span class="s3">\n  </span><span class="s1">ampValidator?: (html: string, pathname: string) =&gt; Promise&lt;void&gt;</span><span class="s3">\n  </span><span class="s1">ampSkipValidation?: boolean</span><span class="s3">\n  </span><span class="s1">ampOptimizerConfig?: { [key: string]: any }</span><span class="s3">\n  </span><span class="s1">isNextDataRequest?: boolean</span><span class="s3">\n  </span><span class="s1">params?: ParsedUrlQuery</span><span class="s3">\n  </span><span class="s1">previewProps: __ApiPreviewProps | undefined</span><span class="s3">\n  </span><span class="s1">basePath: string</span><span class="s3">\n  </span><span class="s1">unstable_runtimeJS?: false</span><span class="s3">\n  </span><span class="s1">unstable_JsPreload?: false</span><span class="s3">\n  </span><span class="s1">optimizeCss: any</span><span class="s3">\n  </span><span class="s1">nextConfigOutput?: 'standalone' | 'export'</span><span class="s3">\n  </span><span class="s1">nextScriptWorkers: any</span><span class="s3">\n  </span><span class="s1">assetQueryString?: string</span><span class="s3">\n  </span><span class="s1">resolvedUrl?: string</span><span class="s3">\n  </span><span class="s1">resolvedAsPath?: string</span><span class="s3">\n  </span><span class="s1">setIsrStatus?: (key: string, value: boolean | null) =&gt; void</span><span class="s3">\n  </span><span class="s1">clientReferenceManifest?: DeepReadonly&lt;ClientReferenceManifest&gt;</span><span class="s3">\n  </span><span class="s1">nextFontManifest?: DeepReadonly&lt;NextFontManifest&gt;</span><span class="s3">\n  </span><span class="s1">distDir?: string</span><span class="s3">\n  </span><span class="s1">locale?: string</span><span class="s3">\n  </span><span class="s1">locales?: readonly string[]</span><span class="s3">\n  </span><span class="s1">defaultLocale?: string</span><span class="s3">\n  </span><span class="s1">domainLocales?: readonly DomainLocale[]</span><span class="s3">\n  </span><span class="s1">disableOptimizedLoading?: boolean</span><span class="s3">\n  </span><span class="s1">supportsDynamicResponse: boolean</span><span class="s3">\n  </span><span class="s1">botType?: 'dom' | 'html' | undefined</span><span class="s3">\n  </span><span class="s1">serveStreamingMetadata?: boolean</span><span class="s3">\n  </span><span class="s1">runtime?: ServerRuntime</span><span class="s3">\n  </span><span class="s1">serverComponents?: boolean</span><span class="s3">\n  </span><span class="s1">serverActions?: {</span><span class="s3">\n    </span><span class="s1">bodySizeLimit?: SizeLimit</span><span class="s3">\n    </span><span class="s1">allowedOrigins?: string[]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">crossOrigin?: 'anonymous' | 'use-credentials' | '' | undefined</span><span class="s3">\n  </span><span class="s1">images: ImageConfigComplete</span><span class="s3">\n  </span><span class="s1">largePageDataBytes?: number</span><span class="s3">\n  </span><span class="s1">isOnDemandRevalidate?: boolean</span><span class="s3">\n  </span><span class="s1">isPossibleServerAction?: boolean</span><span class="s3">\n  </span><span class="s1">isExperimentalCompile?: boolean</span><span class="s3">\n  </span><span class="s1">isPrefetch?: boolean</span><span class="s3">\n  </span><span class="s1">isBot?: boolean</span><span class="s3">\n  </span><span class="s1">expireTime?: number</span><span class="s3">\n  </span><span class="s1">experimental: {</span><span class="s3">\n    </span><span class="s1">clientTraceMetadata?: string[]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type RenderOpts = LoadComponentsReturnType&lt;PagesModule&gt; &amp;</span><span class="s3">\n  </span><span class="s1">RenderOptsPartial</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Shared context used for all page renders.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type PagesSharedContext = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Used to facilitate caching of page bundles, we send it to the client so</span><span class="s3">\n   </span><span class="s1">* that pageloader knows where to load bundles.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">buildId: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The deployment ID if the user is deploying to a platform that provides one.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">deploymentId: string | undefined</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True if the user is using a custom server.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">customServer: true | undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The context for the given request.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type PagesRenderContext = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether this should be rendered as a fallback page.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isFallback: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether this is in draft mode.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isDraftMode: boolean | undefined</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* In development, the original source page that returned a 404.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">developmentNotFoundSourcePage: string | undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* RenderOptsExtra is being used to split away functionality that's within the</span><span class="s3">\n </span><span class="s1">* renderOpts. Eventually we can have more explicit render options for each</span><span class="s3">\n </span><span class="s1">* route kind.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type RenderOptsExtra = {</span><span class="s3">\n  </span><span class="s1">App: AppType</span><span class="s3">\n  </span><span class="s1">Document: DocumentType</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const invalidKeysMsg = (</span><span class="s3">\n  </span><span class="s1">methodName: 'getServerSideProps' | 'getStaticProps',</span><span class="s3">\n  </span><span class="s1">invalidKeys: string[]</span><span class="s3">\n</span><span class="s1">) =&gt; {</span><span class="s3">\n  </span><span class="s1">const docsPathname = `invalid-${methodName.toLocaleLowerCase()}-value`</span><span class="s3">\n\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">`Additional keys were returned from </span><span class="s3">\\</span><span class="s1">`${methodName}</span><span class="s3">\\</span><span class="s1">`. Properties intended for your component must be nested under the </span><span class="s3">\\</span><span class="s1">`props</span><span class="s3">\\</span><span class="s1">` key, e.g.:` +</span><span class="s3">\n    </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">treturn { props: { title: 'My Title', content: '...' } }` +</span><span class="s3">\n    </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">nKeys that need to be moved: ${invalidKeys.join(', ')}.` +</span><span class="s3">\n    </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">nRead more: https://nextjs.org/docs/messages/${docsPathname}`</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function checkRedirectValues(</span><span class="s3">\n  </span><span class="s1">redirect: Redirect,</span><span class="s3">\n  </span><span class="s1">req: IncomingMessage,</span><span class="s3">\n  </span><span class="s1">method: 'getStaticProps' | 'getServerSideProps'</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const { destination, permanent, statusCode, basePath } = redirect</span><span class="s3">\n  </span><span class="s1">let errors: string[] = []</span><span class="s3">\n\n  </span><span class="s1">const hasStatusCode = typeof statusCode !== 'undefined'</span><span class="s3">\n  </span><span class="s1">const hasPermanent = typeof permanent !== 'undefined'</span><span class="s3">\n\n  </span><span class="s1">if (hasPermanent &amp;&amp; hasStatusCode) {</span><span class="s3">\n    </span><span class="s1">errors.push(`</span><span class="s3">\\</span><span class="s1">`permanent</span><span class="s3">\\</span><span class="s1">` and </span><span class="s3">\\</span><span class="s1">`statusCode</span><span class="s3">\\</span><span class="s1">` can not both be provided`)</span><span class="s3">\n  </span><span class="s1">} else if (hasPermanent &amp;&amp; typeof permanent !== 'boolean') {</span><span class="s3">\n    </span><span class="s1">errors.push(`</span><span class="s3">\\</span><span class="s1">`permanent</span><span class="s3">\\</span><span class="s1">` must be </span><span class="s3">\\</span><span class="s1">`true</span><span class="s3">\\</span><span class="s1">` or </span><span class="s3">\\</span><span class="s1">`false</span><span class="s3">\\</span><span class="s1">``)</span><span class="s3">\n  </span><span class="s1">} else if (hasStatusCode &amp;&amp; !allowedStatusCodes.has(statusCode!)) {</span><span class="s3">\n    </span><span class="s1">errors.push(</span><span class="s3">\n      </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">`statusCode</span><span class="s3">\\</span><span class="s1">` must undefined or one of ${[...allowedStatusCodes].join(</span><span class="s3">\n        </span><span class="s1">', '</span><span class="s3">\n      </span><span class="s1">)}`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const destinationType = typeof destination</span><span class="s3">\n\n  </span><span class="s1">if (destinationType !== 'string') {</span><span class="s3">\n    </span><span class="s1">errors.push(</span><span class="s3">\n      </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">`destination</span><span class="s3">\\</span><span class="s1">` should be string but received ${destinationType}`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const basePathType = typeof basePath</span><span class="s3">\n\n  </span><span class="s1">if (basePathType !== 'undefined' &amp;&amp; basePathType !== 'boolean') {</span><span class="s3">\n    </span><span class="s1">errors.push(</span><span class="s3">\n      </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">`basePath</span><span class="s3">\\</span><span class="s1">` should be undefined or a false, received ${basePathType}`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (errors.length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`Invalid redirect object returned from ${method} for ${req.url}</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n        </span><span class="s1">errors.join(' and ') +</span><span class="s3">\n        </span><span class="s1">'</span><span class="s3">\\</span><span class="s1">n' +</span><span class="s3">\n        </span><span class="s1">`See more info here: https://nextjs.org/docs/messages/invalid-redirect-gssp`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function errorToJSON(err: Error) {</span><span class="s3">\n  </span><span class="s1">let source: typeof COMPILER_NAMES.server | typeof COMPILER_NAMES.edgeServer =</span><span class="s3">\n    </span><span class="s1">'server'</span><span class="s3">\n\n  </span><span class="s1">if (process.env.NEXT_RUNTIME !== 'edge') {</span><span class="s3">\n    </span><span class="s1">source = getErrorSource(err) || 'server'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">name: err.name,</span><span class="s3">\n    </span><span class="s1">source,</span><span class="s3">\n    </span><span class="s1">message: stripAnsi(err.message),</span><span class="s3">\n    </span><span class="s1">stack: err.stack,</span><span class="s3">\n    </span><span class="s1">digest: (err as any).digest,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function serializeError(</span><span class="s3">\n  </span><span class="s1">dev: boolean | undefined,</span><span class="s3">\n  </span><span class="s1">err: Error</span><span class="s3">\n</span><span class="s1">): Error &amp; {</span><span class="s3">\n  </span><span class="s1">statusCode?: number</span><span class="s3">\n  </span><span class="s1">source?: typeof COMPILER_NAMES.server | typeof COMPILER_NAMES.edgeServer</span><span class="s3">\n</span><span class="s1">} {</span><span class="s3">\n  </span><span class="s1">if (dev) {</span><span class="s3">\n    </span><span class="s1">return errorToJSON(err)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">name: 'Internal Server Error.',</span><span class="s3">\n    </span><span class="s1">message: '500 - Internal Server Error.',</span><span class="s3">\n    </span><span class="s1">statusCode: 500,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function renderToHTMLImpl(</span><span class="s3">\n  </span><span class="s1">req: IncomingMessage,</span><span class="s3">\n  </span><span class="s1">res: ServerResponse,</span><span class="s3">\n  </span><span class="s1">pathname: string,</span><span class="s3">\n  </span><span class="s1">query: NextParsedUrlQuery,</span><span class="s3">\n  </span><span class="s1">renderOpts: Omit&lt;RenderOpts, keyof RenderOptsExtra&gt;,</span><span class="s3">\n  </span><span class="s1">extra: RenderOptsExtra,</span><span class="s3">\n  </span><span class="s1">sharedContext: PagesSharedContext,</span><span class="s3">\n  </span><span class="s1">renderContext: PagesRenderContext</span><span class="s3">\n</span><span class="s1">): Promise&lt;RenderResult&gt; {</span><span class="s3">\n  </span><span class="s1">// Adds support for reading `cookies` in `getServerSideProps` when SSR.</span><span class="s3">\n  </span><span class="s1">setLazyProp({ req: req as any }, 'cookies', getCookieParser(req.headers))</span><span class="s3">\n\n  </span><span class="s1">const metadata: PagesRenderResultMetadata = {}</span><span class="s3">\n\n  </span><span class="s1">metadata.assetQueryString =</span><span class="s3">\n    </span><span class="s1">(renderOpts.dev &amp;&amp; renderOpts.assetQueryString) || ''</span><span class="s3">\n\n  </span><span class="s1">if (renderOpts.dev &amp;&amp; !metadata.assetQueryString) {</span><span class="s3">\n    </span><span class="s1">const userAgent = (req.headers['user-agent'] || '').toLowerCase()</span><span class="s3">\n    </span><span class="s1">if (userAgent.includes('safari') &amp;&amp; !userAgent.includes('chrome')) {</span><span class="s3">\n      </span><span class="s1">// In dev we invalidate the cache by appending a timestamp to the resource URL.</span><span class="s3">\n      </span><span class="s1">// This is a workaround to fix https://github.com/vercel/next.js/issues/5860</span><span class="s3">\n      </span><span class="s1">// TODO: remove this workaround when https://bugs.webkit.org/show_bug.cgi?id=187726 is fixed.</span><span class="s3">\n      </span><span class="s1">// Note: The workaround breaks breakpoints on reload since the script url always changes,</span><span class="s3">\n      </span><span class="s1">// so we only apply it to Safari.</span><span class="s3">\n      </span><span class="s1">metadata.assetQueryString = `?ts=${Date.now()}`</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// if deploymentId is provided we append it to all asset requests</span><span class="s3">\n  </span><span class="s1">if (sharedContext.deploymentId) {</span><span class="s3">\n    </span><span class="s1">metadata.assetQueryString += `${metadata.assetQueryString ? '&amp;' : '?'}dpl=${</span><span class="s3">\n      </span><span class="s1">sharedContext.deploymentId</span><span class="s3">\n    </span><span class="s1">}`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// don't modify original query object</span><span class="s3">\n  </span><span class="s1">query = Object.assign({}, query)</span><span class="s3">\n\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">err,</span><span class="s3">\n    </span><span class="s1">dev = false,</span><span class="s3">\n    </span><span class="s1">ampPath = '',</span><span class="s3">\n    </span><span class="s1">pageConfig = {},</span><span class="s3">\n    </span><span class="s1">buildManifest,</span><span class="s3">\n    </span><span class="s1">reactLoadableManifest,</span><span class="s3">\n    </span><span class="s1">ErrorDebug,</span><span class="s3">\n    </span><span class="s1">getStaticProps,</span><span class="s3">\n    </span><span class="s1">getStaticPaths,</span><span class="s3">\n    </span><span class="s1">getServerSideProps,</span><span class="s3">\n    </span><span class="s1">isNextDataRequest,</span><span class="s3">\n    </span><span class="s1">params,</span><span class="s3">\n    </span><span class="s1">previewProps,</span><span class="s3">\n    </span><span class="s1">basePath,</span><span class="s3">\n    </span><span class="s1">images,</span><span class="s3">\n    </span><span class="s1">runtime: globalRuntime,</span><span class="s3">\n    </span><span class="s1">isExperimentalCompile,</span><span class="s3">\n    </span><span class="s1">expireTime,</span><span class="s3">\n  </span><span class="s1">} = renderOpts</span><span class="s3">\n  </span><span class="s1">const { App } = extra</span><span class="s3">\n\n  </span><span class="s1">const assetQueryString = metadata.assetQueryString</span><span class="s3">\n\n  </span><span class="s1">let Document = extra.Document</span><span class="s3">\n\n  </span><span class="s1">let Component: React.ComponentType&lt;{}&gt; | ((props: any) =&gt; JSX.Element) =</span><span class="s3">\n    </span><span class="s1">renderOpts.Component</span><span class="s3">\n  </span><span class="s1">const OriginComponent = Component</span><span class="s3">\n\n  </span><span class="s1">const isFallback = renderContext.isFallback ?? false</span><span class="s3">\n  </span><span class="s1">const notFoundSrcPage = renderContext.developmentNotFoundSourcePage</span><span class="s3">\n\n  </span><span class="s1">// next internal queries should be stripped out</span><span class="s3">\n  </span><span class="s1">stripInternalQueries(query)</span><span class="s3">\n\n  </span><span class="s1">const isSSG = !!getStaticProps</span><span class="s3">\n  </span><span class="s1">const isBuildTimeSSG = isSSG &amp;&amp; renderOpts.nextExport</span><span class="s3">\n  </span><span class="s1">const defaultAppGetInitialProps =</span><span class="s3">\n    </span><span class="s1">App.getInitialProps === (App as any).origGetInitialProps</span><span class="s3">\n\n  </span><span class="s1">const hasPageGetInitialProps = !!(Component as any)?.getInitialProps</span><span class="s3">\n  </span><span class="s1">const hasPageScripts = (Component as any)?.unstable_scriptLoader</span><span class="s3">\n\n  </span><span class="s1">const pageIsDynamic = isDynamicRoute(pathname)</span><span class="s3">\n\n  </span><span class="s1">const defaultErrorGetInitialProps =</span><span class="s3">\n    </span><span class="s1">pathname === '/_error' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">(Component as any).getInitialProps ===</span><span class="s3">\n      </span><span class="s1">(Component as any).origGetInitialProps</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">renderOpts.nextExport &amp;&amp;</span><span class="s3">\n    </span><span class="s1">hasPageGetInitialProps &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!defaultErrorGetInitialProps</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">warn(</span><span class="s3">\n      </span><span class="s1">`Detected getInitialProps on page '${pathname}'` +</span><span class="s3">\n        </span><span class="s1">` while running export. It's recommended to use getStaticProps` +</span><span class="s3">\n        </span><span class="s1">` which has a more correct behavior for static exporting.` +</span><span class="s3">\n        </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">nRead more: https://nextjs.org/docs/messages/get-initial-props-export`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let isAutoExport =</span><span class="s3">\n    </span><span class="s1">!hasPageGetInitialProps &amp;&amp;</span><span class="s3">\n    </span><span class="s1">defaultAppGetInitialProps &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!isSSG &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!getServerSideProps</span><span class="s3">\n\n  </span><span class="s1">// if we are running from experimental compile and the page</span><span class="s3">\n  </span><span class="s1">// would normally be automatically statically optimized</span><span class="s3">\n  </span><span class="s1">// ensure we set cache header so it's not rendered on-demand</span><span class="s3">\n  </span><span class="s1">// every request</span><span class="s3">\n  </span><span class="s1">if (isAutoExport &amp;&amp; !dev &amp;&amp; isExperimentalCompile) {</span><span class="s3">\n    </span><span class="s1">res.setHeader(</span><span class="s3">\n      </span><span class="s1">'Cache-Control',</span><span class="s3">\n      </span><span class="s1">getCacheControlHeader({ revalidate: false, expire: expireTime })</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">isAutoExport = false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (hasPageGetInitialProps &amp;&amp; isSSG) {</span><span class="s3">\n    </span><span class="s1">throw new Error(SSG_GET_INITIAL_PROPS_CONFLICT + ` ${pathname}`)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (hasPageGetInitialProps &amp;&amp; getServerSideProps) {</span><span class="s3">\n    </span><span class="s1">throw new Error(SERVER_PROPS_GET_INIT_PROPS_CONFLICT + ` ${pathname}`)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (getServerSideProps &amp;&amp; isSSG) {</span><span class="s3">\n    </span><span class="s1">throw new Error(SERVER_PROPS_SSG_CONFLICT + ` ${pathname}`)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (getServerSideProps &amp;&amp; renderOpts.nextConfigOutput === 'export') {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">'getServerSideProps cannot be used with </span><span class="s3">\&quot;</span><span class="s1">output: export</span><span class="s3">\&quot;</span><span class="s1">. See more info here: https://nextjs.org/docs/advanced-features/static-html-export'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (getStaticPaths &amp;&amp; !pageIsDynamic) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`getStaticPaths is only allowed for dynamic SSG pages and was found on '${pathname}'.` +</span><span class="s3">\n        </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">nRead more: https://nextjs.org/docs/messages/non-dynamic-getstaticpaths-usage`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!!getStaticPaths &amp;&amp; !isSSG) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`getStaticPaths was added without a getStaticProps in ${pathname}. Without getStaticProps, getStaticPaths does nothing`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (isSSG &amp;&amp; pageIsDynamic &amp;&amp; !getStaticPaths) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`getStaticPaths is required for dynamic SSG pages and is missing for '${pathname}'.` +</span><span class="s3">\n        </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">nRead more: https://nextjs.org/docs/messages/invalid-getstaticpaths-value`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let asPath: string = renderOpts.resolvedAsPath || (req.url as string)</span><span class="s3">\n\n  </span><span class="s1">if (dev) {</span><span class="s3">\n    </span><span class="s1">const { isValidElementType } =</span><span class="s3">\n      </span><span class="s1">require('next/dist/compiled/react-is') as typeof import('next/dist/compiled/react-is')</span><span class="s3">\n    </span><span class="s1">if (!isValidElementType(Component)) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">`The default export is not a React Component in page: </span><span class="s3">\&quot;</span><span class="s1">${pathname}</span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!isValidElementType(App)) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">`The default export is not a React Component in page: </span><span class="s3">\&quot;</span><span class="s1">/_app</span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!isValidElementType(Document)) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">`The default export is not a React Component in page: </span><span class="s3">\&quot;</span><span class="s1">/_document</span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (isAutoExport || isFallback) {</span><span class="s3">\n      </span><span class="s1">// remove query values except ones that will be set during export</span><span class="s3">\n      </span><span class="s1">query = {</span><span class="s3">\n        </span><span class="s1">...(query.amp</span><span class="s3">\n          </span><span class="s1">? {</span><span class="s3">\n              </span><span class="s1">amp: query.amp,</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">: {}),</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">asPath = `${pathname}${</span><span class="s3">\n        </span><span class="s1">// ensure trailing slash is present for non-dynamic auto-export pages</span><span class="s3">\n        </span><span class="s1">req.url!.endsWith('/') &amp;&amp; pathname !== '/' &amp;&amp; !pageIsDynamic ? '/' : ''</span><span class="s3">\n      </span><span class="s1">}`</span><span class="s3">\n      </span><span class="s1">req.url = pathname</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (pathname === '/404' &amp;&amp; (hasPageGetInitialProps || getServerSideProps)) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">`pages/404</span><span class="s3">\\</span><span class="s1">` ${STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR}`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">STATIC_STATUS_PAGES.includes(pathname) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(hasPageGetInitialProps || getServerSideProps)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">`pages${pathname}</span><span class="s3">\\</span><span class="s1">` ${STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR}`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (renderOpts?.setIsrStatus) {</span><span class="s3">\n      </span><span class="s1">renderOpts.setIsrStatus(asPath, isSSG || isAutoExport ? true : null)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const methodName of [</span><span class="s3">\n    </span><span class="s1">'getStaticProps',</span><span class="s3">\n    </span><span class="s1">'getServerSideProps',</span><span class="s3">\n    </span><span class="s1">'getStaticPaths',</span><span class="s3">\n  </span><span class="s1">]) {</span><span class="s3">\n    </span><span class="s1">if ((Component as any)?.[methodName]) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">`page ${pathname} ${methodName} ${GSSP_COMPONENT_MEMBER_ERROR}`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">await Loadable.preloadAll() // Make sure all dynamic imports are loaded</span><span class="s3">\n\n  </span><span class="s1">let isPreview: boolean | undefined = undefined</span><span class="s3">\n  </span><span class="s1">let previewData: PreviewData</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">(isSSG || getServerSideProps) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!isFallback &amp;&amp;</span><span class="s3">\n    </span><span class="s1">process.env.NEXT_RUNTIME !== 'edge' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">previewProps</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">// Reads of this are cached on the `req` object, so this should resolve</span><span class="s3">\n    </span><span class="s1">// instantly. There's no need to pass this data down from a previous</span><span class="s3">\n    </span><span class="s1">// invoke.</span><span class="s3">\n    </span><span class="s1">previewData = tryGetPreviewData(</span><span class="s3">\n      </span><span class="s1">req,</span><span class="s3">\n      </span><span class="s1">res,</span><span class="s3">\n      </span><span class="s1">previewProps,</span><span class="s3">\n      </span><span class="s1">!!renderOpts.multiZoneDraftMode</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">isPreview = previewData !== false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// url will always be set</span><span class="s3">\n  </span><span class="s1">const routerIsReady = !!(</span><span class="s3">\n    </span><span class="s1">getServerSideProps ||</span><span class="s3">\n    </span><span class="s1">hasPageGetInitialProps ||</span><span class="s3">\n    </span><span class="s1">(!defaultAppGetInitialProps &amp;&amp; !isSSG) ||</span><span class="s3">\n    </span><span class="s1">isExperimentalCompile</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">const router = new ServerRouter(</span><span class="s3">\n    </span><span class="s1">pathname,</span><span class="s3">\n    </span><span class="s1">query,</span><span class="s3">\n    </span><span class="s1">asPath,</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">isFallback: isFallback,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">routerIsReady,</span><span class="s3">\n    </span><span class="s1">basePath,</span><span class="s3">\n    </span><span class="s1">renderOpts.locale,</span><span class="s3">\n    </span><span class="s1">renderOpts.locales,</span><span class="s3">\n    </span><span class="s1">renderOpts.defaultLocale,</span><span class="s3">\n    </span><span class="s1">renderOpts.domainLocales,</span><span class="s3">\n    </span><span class="s1">isPreview,</span><span class="s3">\n    </span><span class="s1">getRequestMeta(req, 'isLocaleDomain')</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const appRouter = adaptForAppRouterInstance(router)</span><span class="s3">\n\n  </span><span class="s1">let scriptLoader: any = {}</span><span class="s3">\n  </span><span class="s1">const jsxStyleRegistry = createStyleRegistry()</span><span class="s3">\n  </span><span class="s1">const ampState = {</span><span class="s3">\n    </span><span class="s1">ampFirst: pageConfig.amp === true,</span><span class="s3">\n    </span><span class="s1">hasQuery: Boolean(query.amp),</span><span class="s3">\n    </span><span class="s1">hybrid: pageConfig.amp === 'hybrid',</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Disable AMP under the web environment</span><span class="s3">\n  </span><span class="s1">const inAmpMode = process.env.NEXT_RUNTIME !== 'edge' &amp;&amp; isInAmpMode(ampState)</span><span class="s3">\n  </span><span class="s1">let head: JSX.Element[] = defaultHead(inAmpMode)</span><span class="s3">\n  </span><span class="s1">const reactLoadableModules: string[] = []</span><span class="s3">\n\n  </span><span class="s1">let initialScripts: any = {}</span><span class="s3">\n  </span><span class="s1">if (hasPageScripts) {</span><span class="s3">\n    </span><span class="s1">initialScripts.beforeInteractive = []</span><span class="s3">\n      </span><span class="s1">.concat(hasPageScripts())</span><span class="s3">\n      </span><span class="s1">.filter((script: any) =&gt; script.props.strategy === 'beforeInteractive')</span><span class="s3">\n      </span><span class="s1">.map((script: any) =&gt; script.props)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const csp =</span><span class="s3">\n    </span><span class="s1">req.headers['content-security-policy'] ||</span><span class="s3">\n    </span><span class="s1">req.headers['content-security-policy-report-only']</span><span class="s3">\n\n  </span><span class="s1">const nonce =</span><span class="s3">\n    </span><span class="s1">typeof csp === 'string' ? getScriptNonceFromHeader(csp) : undefined</span><span class="s3">\n\n  </span><span class="s1">const AppContainer = ({ children }: { children: JSX.Element }) =&gt; (</span><span class="s3">\n    </span><span class="s1">&lt;AppRouterContext.Provider value={appRouter}&gt;</span><span class="s3">\n      </span><span class="s1">&lt;SearchParamsContext.Provider value={adaptForSearchParams(router)}&gt;</span><span class="s3">\n        </span><span class="s1">&lt;PathnameContextProviderAdapter</span><span class="s3">\n          </span><span class="s1">router={router}</span><span class="s3">\n          </span><span class="s1">isAutoExport={isAutoExport}</span><span class="s3">\n        </span><span class="s1">&gt;</span><span class="s3">\n          </span><span class="s1">&lt;PathParamsContext.Provider value={adaptForPathParams(router)}&gt;</span><span class="s3">\n            </span><span class="s1">&lt;RouterContext.Provider value={router}&gt;</span><span class="s3">\n              </span><span class="s1">&lt;AmpStateContext.Provider value={ampState}&gt;</span><span class="s3">\n                </span><span class="s1">&lt;HeadManagerContext.Provider</span><span class="s3">\n                  </span><span class="s1">value={{</span><span class="s3">\n                    </span><span class="s1">updateHead: (state) =&gt; {</span><span class="s3">\n                      </span><span class="s1">head = state</span><span class="s3">\n                    </span><span class="s1">},</span><span class="s3">\n                    </span><span class="s1">updateScripts: (scripts) =&gt; {</span><span class="s3">\n                      </span><span class="s1">scriptLoader = scripts</span><span class="s3">\n                    </span><span class="s1">},</span><span class="s3">\n                    </span><span class="s1">scripts: initialScripts,</span><span class="s3">\n                    </span><span class="s1">mountedInstances: new Set(),</span><span class="s3">\n                    </span><span class="s1">nonce,</span><span class="s3">\n                  </span><span class="s1">}}</span><span class="s3">\n                </span><span class="s1">&gt;</span><span class="s3">\n                  </span><span class="s1">&lt;LoadableContext.Provider</span><span class="s3">\n                    </span><span class="s1">value={(moduleName) =&gt;</span><span class="s3">\n                      </span><span class="s1">reactLoadableModules.push(moduleName)</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                  </span><span class="s1">&gt;</span><span class="s3">\n                    </span><span class="s1">&lt;StyleRegistry registry={jsxStyleRegistry}&gt;</span><span class="s3">\n                      </span><span class="s1">&lt;ImageConfigContext.Provider value={images}&gt;</span><span class="s3">\n                        </span><span class="s1">{children}</span><span class="s3">\n                      </span><span class="s1">&lt;/ImageConfigContext.Provider&gt;</span><span class="s3">\n                    </span><span class="s1">&lt;/StyleRegistry&gt;</span><span class="s3">\n                  </span><span class="s1">&lt;/LoadableContext.Provider&gt;</span><span class="s3">\n                </span><span class="s1">&lt;/HeadManagerContext.Provider&gt;</span><span class="s3">\n              </span><span class="s1">&lt;/AmpStateContext.Provider&gt;</span><span class="s3">\n            </span><span class="s1">&lt;/RouterContext.Provider&gt;</span><span class="s3">\n          </span><span class="s1">&lt;/PathParamsContext.Provider&gt;</span><span class="s3">\n        </span><span class="s1">&lt;/PathnameContextProviderAdapter&gt;</span><span class="s3">\n      </span><span class="s1">&lt;/SearchParamsContext.Provider&gt;</span><span class="s3">\n    </span><span class="s1">&lt;/AppRouterContext.Provider&gt;</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">// The `useId` API uses the path indexes to generate an ID for each node.</span><span class="s3">\n  </span><span class="s1">// To guarantee the match of hydration, we need to ensure that the structure</span><span class="s3">\n  </span><span class="s1">// of wrapper nodes is isomorphic in server and client.</span><span class="s3">\n  </span><span class="s1">// TODO: With `enhanceApp` and `enhanceComponents` options, this approach may</span><span class="s3">\n  </span><span class="s1">// not be useful.</span><span class="s3">\n  </span><span class="s1">// https://github.com/facebook/react/pull/22644</span><span class="s3">\n  </span><span class="s1">const Noop = () =&gt; null</span><span class="s3">\n  </span><span class="s1">const AppContainerWithIsomorphicFiberStructure: React.FC&lt;{</span><span class="s3">\n    </span><span class="s1">children: JSX.Element</span><span class="s3">\n  </span><span class="s1">}&gt; = ({ children }) =&gt; {</span><span class="s3">\n    </span><span class="s1">return (</span><span class="s3">\n      </span><span class="s1">&lt;&gt;</span><span class="s3">\n        </span><span class="s1">{/* &lt;Head/&gt; */}</span><span class="s3">\n        </span><span class="s1">&lt;Noop /&gt;</span><span class="s3">\n        </span><span class="s1">&lt;AppContainer&gt;</span><span class="s3">\n          </span><span class="s1">&lt;&gt;</span><span class="s3">\n            </span><span class="s1">{children}</span><span class="s3">\n            </span><span class="s1">{/* &lt;RouteAnnouncer/&gt; */}</span><span class="s3">\n            </span><span class="s1">&lt;Noop /&gt;</span><span class="s3">\n          </span><span class="s1">&lt;/&gt;</span><span class="s3">\n        </span><span class="s1">&lt;/AppContainer&gt;</span><span class="s3">\n      </span><span class="s1">&lt;/&gt;</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const ctx = {</span><span class="s3">\n    </span><span class="s1">err,</span><span class="s3">\n    </span><span class="s1">req: isAutoExport ? undefined : req,</span><span class="s3">\n    </span><span class="s1">res: isAutoExport ? undefined : res,</span><span class="s3">\n    </span><span class="s1">pathname,</span><span class="s3">\n    </span><span class="s1">query,</span><span class="s3">\n    </span><span class="s1">asPath,</span><span class="s3">\n    </span><span class="s1">locale: renderOpts.locale,</span><span class="s3">\n    </span><span class="s1">locales: renderOpts.locales,</span><span class="s3">\n    </span><span class="s1">defaultLocale: renderOpts.defaultLocale,</span><span class="s3">\n    </span><span class="s1">AppTree: (props: any) =&gt; {</span><span class="s3">\n      </span><span class="s1">return (</span><span class="s3">\n        </span><span class="s1">&lt;AppContainerWithIsomorphicFiberStructure&gt;</span><span class="s3">\n          </span><span class="s1">{renderPageTree(App, OriginComponent, { ...props, router })}</span><span class="s3">\n        </span><span class="s1">&lt;/AppContainerWithIsomorphicFiberStructure&gt;</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">defaultGetInitialProps: async (</span><span class="s3">\n      </span><span class="s1">docCtx: DocumentContext,</span><span class="s3">\n      </span><span class="s1">options: { nonce?: string } = {}</span><span class="s3">\n    </span><span class="s1">): Promise&lt;DocumentInitialProps&gt; =&gt; {</span><span class="s3">\n      </span><span class="s1">const enhanceApp = (AppComp: any) =&gt; {</span><span class="s3">\n        </span><span class="s1">return (props: any) =&gt; &lt;AppComp {...props} /&gt;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const { html, head: renderPageHead } = await docCtx.renderPage({</span><span class="s3">\n        </span><span class="s1">enhanceApp,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">const styles = jsxStyleRegistry.styles({ nonce: options.nonce || nonce })</span><span class="s3">\n      </span><span class="s1">jsxStyleRegistry.flush()</span><span class="s3">\n      </span><span class="s1">return { html, head: renderPageHead, styles }</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">let props: any</span><span class="s3">\n\n  </span><span class="s1">const nextExport =</span><span class="s3">\n    </span><span class="s1">!isSSG &amp;&amp; (renderOpts.nextExport || (dev &amp;&amp; (isAutoExport || isFallback)))</span><span class="s3">\n\n  </span><span class="s1">const styledJsxInsertedHTML = () =&gt; {</span><span class="s3">\n    </span><span class="s1">const styles = jsxStyleRegistry.styles()</span><span class="s3">\n    </span><span class="s1">jsxStyleRegistry.flush()</span><span class="s3">\n    </span><span class="s1">return &lt;&gt;{styles}&lt;/&gt;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">props = await loadGetInitialProps(App, {</span><span class="s3">\n    </span><span class="s1">AppTree: ctx.AppTree,</span><span class="s3">\n    </span><span class="s1">Component,</span><span class="s3">\n    </span><span class="s1">router,</span><span class="s3">\n    </span><span class="s1">ctx,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">if ((isSSG || getServerSideProps) &amp;&amp; isPreview) {</span><span class="s3">\n    </span><span class="s1">props.__N_PREVIEW = true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (isSSG) {</span><span class="s3">\n    </span><span class="s1">props[STATIC_PROPS_ID] = true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (isSSG &amp;&amp; !isFallback) {</span><span class="s3">\n    </span><span class="s1">let data: Readonly&lt;UnwrapPromise&lt;ReturnType&lt;GetStaticProps&gt;&gt;&gt;</span><span class="s3">\n\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">data = await getTracer().trace(</span><span class="s3">\n        </span><span class="s1">RenderSpan.getStaticProps,</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">spanName: `getStaticProps ${pathname}`,</span><span class="s3">\n          </span><span class="s1">attributes: {</span><span class="s3">\n            </span><span class="s1">'next.route': pathname,</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">() =&gt;</span><span class="s3">\n          </span><span class="s1">getStaticProps({</span><span class="s3">\n            </span><span class="s1">...(pageIsDynamic ? { params } : undefined),</span><span class="s3">\n            </span><span class="s1">...(isPreview</span><span class="s3">\n              </span><span class="s1">? { draftMode: true, preview: true, previewData: previewData }</span><span class="s3">\n              </span><span class="s1">: undefined),</span><span class="s3">\n            </span><span class="s1">locales: [...(renderOpts.locales ?? [])],</span><span class="s3">\n            </span><span class="s1">locale: renderOpts.locale,</span><span class="s3">\n            </span><span class="s1">defaultLocale: renderOpts.defaultLocale,</span><span class="s3">\n            </span><span class="s1">revalidateReason: renderOpts.isOnDemandRevalidate</span><span class="s3">\n              </span><span class="s1">? 'on-demand'</span><span class="s3">\n              </span><span class="s1">: isBuildTimeSSG</span><span class="s3">\n                </span><span class="s1">? 'build'</span><span class="s3">\n                </span><span class="s1">: 'stale',</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} catch (staticPropsError: any) {</span><span class="s3">\n      </span><span class="s1">// remove not found error code to prevent triggering legacy</span><span class="s3">\n      </span><span class="s1">// 404 rendering</span><span class="s3">\n      </span><span class="s1">if (staticPropsError &amp;&amp; staticPropsError.code === 'ENOENT') {</span><span class="s3">\n        </span><span class="s1">delete staticPropsError.code</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">throw staticPropsError</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (data == null) {</span><span class="s3">\n      </span><span class="s1">throw new Error(GSP_NO_RETURNED_VALUE)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const invalidKeys = Object.keys(data).filter(</span><span class="s3">\n      </span><span class="s1">(key) =&gt;</span><span class="s3">\n        </span><span class="s1">key !== 'revalidate' &amp;&amp;</span><span class="s3">\n        </span><span class="s1">key !== 'props' &amp;&amp;</span><span class="s3">\n        </span><span class="s1">key !== 'redirect' &amp;&amp;</span><span class="s3">\n        </span><span class="s1">key !== 'notFound'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">if (invalidKeys.includes('unstable_revalidate')) {</span><span class="s3">\n      </span><span class="s1">throw new Error(UNSTABLE_REVALIDATE_RENAME_ERROR)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (invalidKeys.length) {</span><span class="s3">\n      </span><span class="s1">throw new Error(invalidKeysMsg('getStaticProps', invalidKeys))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">typeof (data as any).notFound !== 'undefined' &amp;&amp;</span><span class="s3">\n        </span><span class="s1">typeof (data as any).redirect !== 'undefined'</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">`redirect</span><span class="s3">\\</span><span class="s1">` and </span><span class="s3">\\</span><span class="s1">`notFound</span><span class="s3">\\</span><span class="s1">` can not both be returned from ${</span><span class="s3">\n            </span><span class="s1">isSSG ? 'getStaticProps' : 'getServerSideProps'</span><span class="s3">\n          </span><span class="s1">} at the same time. Page: ${pathname}</span><span class="s3">\\</span><span class="s1">nSee more info here: https://nextjs.org/docs/messages/gssp-mixed-not-found-redirect`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if ('notFound' in data &amp;&amp; data.notFound) {</span><span class="s3">\n      </span><span class="s1">if (pathname === '/404') {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">`The /404 page can not return notFound in </span><span class="s3">\&quot;</span><span class="s1">getStaticProps</span><span class="s3">\&quot;</span><span class="s1">, please remove it to continue!`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">metadata.isNotFound = true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">'redirect' in data &amp;&amp;</span><span class="s3">\n      </span><span class="s1">data.redirect &amp;&amp;</span><span class="s3">\n      </span><span class="s1">typeof data.redirect === 'object'</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">checkRedirectValues(data.redirect as Redirect, req, 'getStaticProps')</span><span class="s3">\n\n      </span><span class="s1">if (isBuildTimeSSG) {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">`redirect</span><span class="s3">\\</span><span class="s1">` can not be returned from getStaticProps during prerendering (${req.url})</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n            </span><span class="s1">`See more info here: https://nextjs.org/docs/messages/gsp-redirect-during-prerender`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">;(data as any).props = {</span><span class="s3">\n        </span><span class="s1">__N_REDIRECT: data.redirect.destination,</span><span class="s3">\n        </span><span class="s1">__N_REDIRECT_STATUS: getRedirectStatus(data.redirect),</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (typeof data.redirect.basePath !== 'undefined') {</span><span class="s3">\n        </span><span class="s1">;(data as any).props.__N_REDIRECT_BASE_PATH = data.redirect.basePath</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">metadata.isRedirect = true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">(dev || isBuildTimeSSG) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!metadata.isNotFound &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!isSerializableProps(pathname, 'getStaticProps', (data as any).props)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// this fn should throw an error instead of ever returning `false`</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">'invariant: getStaticProps did not return valid props. Please report this.'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let revalidate: Revalidate</span><span class="s3">\n    </span><span class="s1">if ('revalidate' in data) {</span><span class="s3">\n      </span><span class="s1">if (data.revalidate &amp;&amp; renderOpts.nextConfigOutput === 'export') {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">'ISR cannot be used with </span><span class="s3">\&quot;</span><span class="s1">output: export</span><span class="s3">\&quot;</span><span class="s1">. See more info here: https://nextjs.org/docs/advanced-features/static-html-export'</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (typeof data.revalidate === 'number') {</span><span class="s3">\n        </span><span class="s1">if (!Number.isInteger(data.revalidate)) {</span><span class="s3">\n          </span><span class="s1">throw new Error(</span><span class="s3">\n            </span><span class="s1">`A page's revalidate option must be seconds expressed as a natural number for ${req.url}. Mixed numbers, such as '${data.revalidate}', cannot be used.` +</span><span class="s3">\n              </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">nTry changing the value to '${Math.ceil(</span><span class="s3">\n                </span><span class="s1">data.revalidate</span><span class="s3">\n              </span><span class="s1">)}' or using </span><span class="s3">\\</span><span class="s1">`Math.ceil()</span><span class="s3">\\</span><span class="s1">` if you're computing the value.`</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">} else if (data.revalidate &lt;= 0) {</span><span class="s3">\n          </span><span class="s1">throw new Error(</span><span class="s3">\n            </span><span class="s1">`A page's revalidate option can not be less than or equal to zero for ${req.url}. A revalidate option of zero means to revalidate after _every_ request, and implies stale data cannot be tolerated.` +</span><span class="s3">\n              </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">nTo never revalidate, you can set revalidate to </span><span class="s3">\\</span><span class="s1">`false</span><span class="s3">\\</span><span class="s1">` (only ran once at build-time).` +</span><span class="s3">\n              </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">nTo revalidate as soon as possible, you can set the value to </span><span class="s3">\\</span><span class="s1">`1</span><span class="s3">\\</span><span class="s1">`.`</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">if (data.revalidate &gt; 31536000) {</span><span class="s3">\n            </span><span class="s1">// if it's greater than a year for some reason error</span><span class="s3">\n            </span><span class="s1">console.warn(</span><span class="s3">\n              </span><span class="s1">`Warning: A page's revalidate option was set to more than a year for ${req.url}. This may have been done in error.` +</span><span class="s3">\n                </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">nTo only run getStaticProps at build-time and not revalidate at runtime, you can set </span><span class="s3">\\</span><span class="s1">`revalidate</span><span class="s3">\\</span><span class="s1">` to </span><span class="s3">\\</span><span class="s1">`false</span><span class="s3">\\</span><span class="s1">`!`</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">revalidate = data.revalidate</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else if (data.revalidate === true) {</span><span class="s3">\n        </span><span class="s1">// When enabled, revalidate after 1 second. This value is optimal for</span><span class="s3">\n        </span><span class="s1">// the most up-to-date page possible, but without a 1-to-1</span><span class="s3">\n        </span><span class="s1">// request-refresh ratio.</span><span class="s3">\n        </span><span class="s1">revalidate = 1</span><span class="s3">\n      </span><span class="s1">} else if (</span><span class="s3">\n        </span><span class="s1">data.revalidate === false ||</span><span class="s3">\n        </span><span class="s1">typeof data.revalidate === 'undefined'</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">// By default, we never revalidate.</span><span class="s3">\n        </span><span class="s1">revalidate = false</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">`A page's revalidate option must be seconds expressed as a natural number. Mixed numbers and strings cannot be used. Received '${JSON.stringify(</span><span class="s3">\n            </span><span class="s1">data.revalidate</span><span class="s3">\n          </span><span class="s1">)}' for ${req.url}`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// By default, we never revalidate.</span><span class="s3">\n      </span><span class="s1">revalidate = false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">props.pageProps = Object.assign(</span><span class="s3">\n      </span><span class="s1">{},</span><span class="s3">\n      </span><span class="s1">props.pageProps,</span><span class="s3">\n      </span><span class="s1">'props' in data ? data.props : undefined</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">// pass up cache control and props for export</span><span class="s3">\n    </span><span class="s1">metadata.cacheControl = { revalidate, expire: undefined }</span><span class="s3">\n    </span><span class="s1">metadata.pageData = props</span><span class="s3">\n\n    </span><span class="s1">// this must come after revalidate is added to renderResultMeta</span><span class="s3">\n    </span><span class="s1">if (metadata.isNotFound) {</span><span class="s3">\n      </span><span class="s1">return new RenderResult(null, {</span><span class="s3">\n        </span><span class="s1">metadata,</span><span class="s3">\n        </span><span class="s1">contentType: null,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (getServerSideProps) {</span><span class="s3">\n    </span><span class="s1">props[SERVER_PROPS_ID] = true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (getServerSideProps &amp;&amp; !isFallback) {</span><span class="s3">\n    </span><span class="s1">let data: UnwrapPromise&lt;ReturnType&lt;GetServerSideProps&gt;&gt;</span><span class="s3">\n\n    </span><span class="s1">let canAccessRes = true</span><span class="s3">\n    </span><span class="s1">let resOrProxy = res</span><span class="s3">\n    </span><span class="s1">let deferredContent = false</span><span class="s3">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n      </span><span class="s1">resOrProxy = new Proxy&lt;ServerResponse&gt;(res, {</span><span class="s3">\n        </span><span class="s1">get: function (obj, prop) {</span><span class="s3">\n          </span><span class="s1">if (!canAccessRes) {</span><span class="s3">\n            </span><span class="s1">const message =</span><span class="s3">\n              </span><span class="s1">`You should not access 'res' after getServerSideProps resolves.` +</span><span class="s3">\n              </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">nRead more: https://nextjs.org/docs/messages/gssp-no-mutating-res`</span><span class="s3">\n\n            </span><span class="s1">if (deferredContent) {</span><span class="s3">\n              </span><span class="s1">throw new Error(message)</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">warn(message)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">if (typeof prop === 'symbol') {</span><span class="s3">\n            </span><span class="s1">return ReflectAdapter.get(obj, prop, res)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">return ReflectAdapter.get(obj, prop, res)</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">data = await getTracer().trace(</span><span class="s3">\n        </span><span class="s1">RenderSpan.getServerSideProps,</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">spanName: `getServerSideProps ${pathname}`,</span><span class="s3">\n          </span><span class="s1">attributes: {</span><span class="s3">\n            </span><span class="s1">'next.route': pathname,</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">async () =&gt;</span><span class="s3">\n          </span><span class="s1">getServerSideProps({</span><span class="s3">\n            </span><span class="s1">req: req as IncomingMessage &amp; {</span><span class="s3">\n              </span><span class="s1">cookies: NextApiRequestCookies</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">res: resOrProxy,</span><span class="s3">\n            </span><span class="s1">query,</span><span class="s3">\n            </span><span class="s1">resolvedUrl: renderOpts.resolvedUrl as string,</span><span class="s3">\n            </span><span class="s1">...(pageIsDynamic ? { params } : undefined),</span><span class="s3">\n            </span><span class="s1">...(previewData !== false</span><span class="s3">\n              </span><span class="s1">? { draftMode: true, preview: true, previewData: previewData }</span><span class="s3">\n              </span><span class="s1">: undefined),</span><span class="s3">\n            </span><span class="s1">// We create a copy here to avoid having the types of</span><span class="s3">\n            </span><span class="s1">// `getServerSideProps` change. This ensures that users can't</span><span class="s3">\n            </span><span class="s1">// mutate this array and have it poison the reference.</span><span class="s3">\n            </span><span class="s1">locales: [...(renderOpts.locales ?? [])],</span><span class="s3">\n            </span><span class="s1">locale: renderOpts.locale,</span><span class="s3">\n            </span><span class="s1">defaultLocale: renderOpts.defaultLocale,</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">canAccessRes = false</span><span class="s3">\n      </span><span class="s1">metadata.cacheControl = { revalidate: 0, expire: undefined }</span><span class="s3">\n    </span><span class="s1">} catch (serverSidePropsError: any) {</span><span class="s3">\n      </span><span class="s1">// remove not found error code to prevent triggering legacy</span><span class="s3">\n      </span><span class="s1">// 404 rendering</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">isError(serverSidePropsError) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">serverSidePropsError.code === 'ENOENT'</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">delete serverSidePropsError.code</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">throw serverSidePropsError</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (data == null) {</span><span class="s3">\n      </span><span class="s1">throw new Error(GSSP_NO_RETURNED_VALUE)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if ((data as any).props instanceof Promise) {</span><span class="s3">\n      </span><span class="s1">deferredContent = true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const invalidKeys = Object.keys(data).filter(</span><span class="s3">\n      </span><span class="s1">(key) =&gt; key !== 'props' &amp;&amp; key !== 'redirect' &amp;&amp; key !== 'notFound'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">if ((data as any).unstable_notFound) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">`unstable_notFound has been renamed to notFound, please update the field to continue. Page: ${pathname}`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if ((data as any).unstable_redirect) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">`unstable_redirect has been renamed to redirect, please update the field to continue. Page: ${pathname}`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (invalidKeys.length) {</span><span class="s3">\n      </span><span class="s1">throw new Error(invalidKeysMsg('getServerSideProps', invalidKeys))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if ('notFound' in data &amp;&amp; data.notFound) {</span><span class="s3">\n      </span><span class="s1">if (pathname === '/404') {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">`The /404 page can not return notFound in </span><span class="s3">\&quot;</span><span class="s1">getStaticProps</span><span class="s3">\&quot;</span><span class="s1">, please remove it to continue!`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">metadata.isNotFound = true</span><span class="s3">\n      </span><span class="s1">return new RenderResult(null, {</span><span class="s3">\n        </span><span class="s1">metadata,</span><span class="s3">\n        </span><span class="s1">contentType: null,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if ('redirect' in data &amp;&amp; typeof data.redirect === 'object') {</span><span class="s3">\n      </span><span class="s1">checkRedirectValues(data.redirect as Redirect, req, 'getServerSideProps')</span><span class="s3">\n      </span><span class="s1">;(data as any).props = {</span><span class="s3">\n        </span><span class="s1">__N_REDIRECT: data.redirect.destination,</span><span class="s3">\n        </span><span class="s1">__N_REDIRECT_STATUS: getRedirectStatus(data.redirect),</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (typeof data.redirect.basePath !== 'undefined') {</span><span class="s3">\n        </span><span class="s1">;(data as any).props.__N_REDIRECT_BASE_PATH = data.redirect.basePath</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">metadata.isRedirect = true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (deferredContent) {</span><span class="s3">\n      </span><span class="s1">;(data as any).props = await (data as any).props</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">(dev || isBuildTimeSSG) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!isSerializableProps(pathname, 'getServerSideProps', (data as any).props)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// this fn should throw an error instead of ever returning `false`</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">'invariant: getServerSideProps did not return valid props. Please report this.'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">props.pageProps = Object.assign({}, props.pageProps, (data as any).props)</span><span class="s3">\n    </span><span class="s1">metadata.pageData = props</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">!isSSG &amp;&amp; // we only show this warning for legacy pages</span><span class="s3">\n    </span><span class="s1">!getServerSideProps &amp;&amp;</span><span class="s3">\n    </span><span class="s1">process.env.NODE_ENV !== 'production' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">Object.keys(props?.pageProps || {}).includes('url')</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">console.warn(</span><span class="s3">\n      </span><span class="s1">`The prop </span><span class="s3">\\</span><span class="s1">`url</span><span class="s3">\\</span><span class="s1">` is a reserved prop in Next.js for legacy reasons and will be overridden on page ${pathname}</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n        </span><span class="s1">`See more info here: https://nextjs.org/docs/messages/reserved-page-prop`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Avoid rendering page un-necessarily for getServerSideProps data request</span><span class="s3">\n  </span><span class="s1">// and getServerSideProps/getStaticProps redirects</span><span class="s3">\n  </span><span class="s1">if ((isNextDataRequest &amp;&amp; !isSSG) || metadata.isRedirect) {</span><span class="s3">\n    </span><span class="s1">return new RenderResult(JSON.stringify(props), {</span><span class="s3">\n      </span><span class="s1">metadata,</span><span class="s3">\n      </span><span class="s1">contentType: JSON_CONTENT_TYPE_HEADER,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// We don't call getStaticProps or getServerSideProps while generating</span><span class="s3">\n  </span><span class="s1">// the fallback so make sure to set pageProps to an empty object</span><span class="s3">\n  </span><span class="s1">if (isFallback) {</span><span class="s3">\n    </span><span class="s1">props.pageProps = {}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// the response might be finished on the getInitialProps call</span><span class="s3">\n  </span><span class="s1">if (isResSent(res) &amp;&amp; !isSSG) return RenderResult.EMPTY</span><span class="s3">\n\n  </span><span class="s1">// we preload the buildManifest for auto-export dynamic pages</span><span class="s3">\n  </span><span class="s1">// to speed up hydrating query values</span><span class="s3">\n  </span><span class="s1">let filteredBuildManifest = buildManifest</span><span class="s3">\n  </span><span class="s1">if (isAutoExport &amp;&amp; pageIsDynamic) {</span><span class="s3">\n    </span><span class="s1">const page = denormalizePagePath(normalizePagePath(pathname))</span><span class="s3">\n    </span><span class="s1">// This code would be much cleaner using `immer` and directly pushing into</span><span class="s3">\n    </span><span class="s1">// the result from `getPageFiles`, we could maybe consider that in the</span><span class="s3">\n    </span><span class="s1">// future.</span><span class="s3">\n    </span><span class="s1">if (page in filteredBuildManifest.pages) {</span><span class="s3">\n      </span><span class="s1">filteredBuildManifest = {</span><span class="s3">\n        </span><span class="s1">...filteredBuildManifest,</span><span class="s3">\n        </span><span class="s1">pages: {</span><span class="s3">\n          </span><span class="s1">...filteredBuildManifest.pages,</span><span class="s3">\n          </span><span class="s1">[page]: [</span><span class="s3">\n            </span><span class="s1">...filteredBuildManifest.pages[page],</span><span class="s3">\n            </span><span class="s1">...filteredBuildManifest.lowPriorityFiles.filter((f) =&gt;</span><span class="s3">\n              </span><span class="s1">f.includes('_buildManifest')</span><span class="s3">\n            </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">],</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">lowPriorityFiles: filteredBuildManifest.lowPriorityFiles.filter(</span><span class="s3">\n          </span><span class="s1">(f) =&gt; !f.includes('_buildManifest')</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const Body = ({ children }: { children: JSX.Element }) =&gt; {</span><span class="s3">\n    </span><span class="s1">return inAmpMode ? children : &lt;div id=</span><span class="s3">\&quot;</span><span class="s1">__next</span><span class="s3">\&quot;</span><span class="s1">&gt;{children}&lt;/div&gt;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const renderDocument = async () =&gt; {</span><span class="s3">\n    </span><span class="s1">// For `Document`, there are two cases that we don't support:</span><span class="s3">\n    </span><span class="s1">// 1. Using `Document.getInitialProps` in the Edge runtime.</span><span class="s3">\n    </span><span class="s1">// 2. Using the class component `Document` with concurrent features.</span><span class="s3">\n\n    </span><span class="s1">const BuiltinFunctionalDocument: DocumentType | undefined = (</span><span class="s3">\n      </span><span class="s1">Document as any</span><span class="s3">\n    </span><span class="s1">)[NEXT_BUILTIN_DOCUMENT]</span><span class="s3">\n\n    </span><span class="s1">if (process.env.NEXT_RUNTIME === 'edge' &amp;&amp; Document.getInitialProps) {</span><span class="s3">\n      </span><span class="s1">// In the Edge runtime, `Document.getInitialProps` isn't supported.</span><span class="s3">\n      </span><span class="s1">// We throw an error here if it's customized.</span><span class="s3">\n      </span><span class="s1">if (BuiltinFunctionalDocument) {</span><span class="s3">\n        </span><span class="s1">Document = BuiltinFunctionalDocument</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">'`getInitialProps` in Document component is not supported with the Edge Runtime.'</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">async function loadDocumentInitialProps(</span><span class="s3">\n      </span><span class="s1">renderShell: (</span><span class="s3">\n        </span><span class="s1">_App: AppType,</span><span class="s3">\n        </span><span class="s1">_Component: NextComponentType</span><span class="s3">\n      </span><span class="s1">) =&gt; Promise&lt;ReactDOMServerReadableStream&gt;</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">const renderPage: RenderPage = async (</span><span class="s3">\n        </span><span class="s1">options: ComponentsEnhancer = {}</span><span class="s3">\n      </span><span class="s1">): Promise&lt;RenderPageResult&gt; =&gt; {</span><span class="s3">\n        </span><span class="s1">if (ctx.err &amp;&amp; ErrorDebug) {</span><span class="s3">\n          </span><span class="s1">// Always start rendering the shell even if there's an error.</span><span class="s3">\n          </span><span class="s1">if (renderShell) {</span><span class="s3">\n            </span><span class="s1">renderShell(App, Component)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">const html = await renderToString(</span><span class="s3">\n            </span><span class="s1">&lt;Body&gt;</span><span class="s3">\n              </span><span class="s1">&lt;ErrorDebug /&gt;</span><span class="s3">\n            </span><span class="s1">&lt;/Body&gt;</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">return { html, head }</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (dev &amp;&amp; (props.router || props.Component)) {</span><span class="s3">\n          </span><span class="s1">throw new Error(</span><span class="s3">\n            </span><span class="s1">`'router' and 'Component' can not be returned in getInitialProps from _app.js https://nextjs.org/docs/messages/cant-override-next-props`</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const { App: EnhancedApp, Component: EnhancedComponent } =</span><span class="s3">\n          </span><span class="s1">enhanceComponents(options, App, Component)</span><span class="s3">\n\n        </span><span class="s1">const stream = await renderShell(EnhancedApp, EnhancedComponent)</span><span class="s3">\n        </span><span class="s1">await stream.allReady</span><span class="s3">\n        </span><span class="s1">const html = await streamToString(stream)</span><span class="s3">\n\n        </span><span class="s1">return { html, head }</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const documentCtx = { ...ctx, renderPage }</span><span class="s3">\n      </span><span class="s1">const docProps: DocumentInitialProps = await loadGetInitialProps(</span><span class="s3">\n        </span><span class="s1">Document,</span><span class="s3">\n        </span><span class="s1">documentCtx</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">// the response might be finished on the getInitialProps call</span><span class="s3">\n      </span><span class="s1">if (isResSent(res) &amp;&amp; !isSSG) return null</span><span class="s3">\n\n      </span><span class="s1">if (!docProps || typeof docProps.html !== 'string') {</span><span class="s3">\n        </span><span class="s1">const message = `</span><span class="s3">\&quot;</span><span class="s1">${getDisplayName(</span><span class="s3">\n          </span><span class="s1">Document</span><span class="s3">\n        </span><span class="s1">)}.getInitialProps()</span><span class="s3">\&quot; </span><span class="s1">should resolve to an object with a </span><span class="s3">\&quot;</span><span class="s1">html</span><span class="s3">\&quot; </span><span class="s1">prop set with a valid html string`</span><span class="s3">\n        </span><span class="s1">throw new Error(message)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return { docProps, documentCtx }</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const renderContent = (_App: AppType, _Component: NextComponentType) =&gt; {</span><span class="s3">\n      </span><span class="s1">const EnhancedApp = _App || App</span><span class="s3">\n      </span><span class="s1">const EnhancedComponent = _Component || Component</span><span class="s3">\n\n      </span><span class="s1">return ctx.err &amp;&amp; ErrorDebug ? (</span><span class="s3">\n        </span><span class="s1">&lt;Body&gt;</span><span class="s3">\n          </span><span class="s1">&lt;ErrorDebug /&gt;</span><span class="s3">\n        </span><span class="s1">&lt;/Body&gt;</span><span class="s3">\n      </span><span class="s1">) : (</span><span class="s3">\n        </span><span class="s1">&lt;Body&gt;</span><span class="s3">\n          </span><span class="s1">&lt;AppContainerWithIsomorphicFiberStructure&gt;</span><span class="s3">\n            </span><span class="s1">{renderPageTree(EnhancedApp, EnhancedComponent, {</span><span class="s3">\n              </span><span class="s1">...props,</span><span class="s3">\n              </span><span class="s1">router,</span><span class="s3">\n            </span><span class="s1">})}</span><span class="s3">\n          </span><span class="s1">&lt;/AppContainerWithIsomorphicFiberStructure&gt;</span><span class="s3">\n        </span><span class="s1">&lt;/Body&gt;</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Always using react concurrent rendering mode with required react version 18.x</span><span class="s3">\n    </span><span class="s1">const renderShell = async (</span><span class="s3">\n      </span><span class="s1">EnhancedApp: AppType,</span><span class="s3">\n      </span><span class="s1">EnhancedComponent: NextComponentType</span><span class="s3">\n    </span><span class="s1">) =&gt; {</span><span class="s3">\n      </span><span class="s1">const content = renderContent(EnhancedApp, EnhancedComponent)</span><span class="s3">\n      </span><span class="s1">return await renderToInitialFizzStream({</span><span class="s3">\n        </span><span class="s1">ReactDOMServer: ReactDOMServerPages,</span><span class="s3">\n        </span><span class="s1">element: content,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const hasDocumentGetInitialProps =</span><span class="s3">\n      </span><span class="s1">process.env.NEXT_RUNTIME !== 'edge' &amp;&amp; !!Document.getInitialProps</span><span class="s3">\n\n    </span><span class="s1">// If it has getInitialProps, we will render the shell in `renderPage`.</span><span class="s3">\n    </span><span class="s1">// Otherwise we do it right now.</span><span class="s3">\n    </span><span class="s1">let documentInitialPropsRes:</span><span class="s3">\n      </span><span class="s1">| {}</span><span class="s3">\n      </span><span class="s1">| Awaited&lt;ReturnType&lt;typeof loadDocumentInitialProps&gt;&gt;</span><span class="s3">\n\n    </span><span class="s1">const [rawStyledJsxInsertedHTML, content] = await Promise.all([</span><span class="s3">\n      </span><span class="s1">renderToString(styledJsxInsertedHTML()),</span><span class="s3">\n      </span><span class="s1">(async () =&gt; {</span><span class="s3">\n        </span><span class="s1">if (hasDocumentGetInitialProps) {</span><span class="s3">\n          </span><span class="s1">documentInitialPropsRes = await loadDocumentInitialProps(renderShell)</span><span class="s3">\n          </span><span class="s1">if (documentInitialPropsRes === null) return null</span><span class="s3">\n          </span><span class="s1">const { docProps } = documentInitialPropsRes as any</span><span class="s3">\n          </span><span class="s1">return docProps.html</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">documentInitialPropsRes = {}</span><span class="s3">\n          </span><span class="s1">const stream = await renderShell(App, Component)</span><span class="s3">\n          </span><span class="s1">await stream.allReady</span><span class="s3">\n          </span><span class="s1">return streamToString(stream)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">})(),</span><span class="s3">\n    </span><span class="s1">])</span><span class="s3">\n\n    </span><span class="s1">if (content === null) {</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const contentHTML = rawStyledJsxInsertedHTML + content</span><span class="s3">\n\n    </span><span class="s1">// @ts-ignore: documentInitialPropsRes is set</span><span class="s3">\n    </span><span class="s1">const { docProps } = (documentInitialPropsRes as any) || {}</span><span class="s3">\n    </span><span class="s1">const documentElement = (htmlProps: any) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (process.env.NEXT_RUNTIME === 'edge') {</span><span class="s3">\n        </span><span class="s1">return (Document as any)()</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return &lt;Document {...htmlProps} {...docProps} /&gt;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let styles</span><span class="s3">\n    </span><span class="s1">if (hasDocumentGetInitialProps) {</span><span class="s3">\n      </span><span class="s1">styles = docProps.styles</span><span class="s3">\n      </span><span class="s1">head = docProps.head</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">styles = jsxStyleRegistry.styles()</span><span class="s3">\n      </span><span class="s1">jsxStyleRegistry.flush()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">contentHTML,</span><span class="s3">\n      </span><span class="s1">documentElement,</span><span class="s3">\n      </span><span class="s1">head,</span><span class="s3">\n      </span><span class="s1">headTags: [],</span><span class="s3">\n      </span><span class="s1">styles,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">getTracer().setRootSpanAttribute('next.route', renderOpts.page)</span><span class="s3">\n  </span><span class="s1">const documentResult = await getTracer().trace(</span><span class="s3">\n    </span><span class="s1">RenderSpan.renderDocument,</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">spanName: `render route (pages) ${renderOpts.page}`,</span><span class="s3">\n      </span><span class="s1">attributes: {</span><span class="s3">\n        </span><span class="s1">'next.route': renderOpts.page,</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">async () =&gt; renderDocument()</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">if (!documentResult) {</span><span class="s3">\n    </span><span class="s1">return new RenderResult(null, {</span><span class="s3">\n      </span><span class="s1">metadata,</span><span class="s3">\n      </span><span class="s1">contentType: HTML_CONTENT_TYPE_HEADER,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const dynamicImportsIds = new Set&lt;string | number&gt;()</span><span class="s3">\n  </span><span class="s1">const dynamicImports = new Set&lt;string&gt;()</span><span class="s3">\n\n  </span><span class="s1">for (const mod of reactLoadableModules) {</span><span class="s3">\n    </span><span class="s1">const manifestItem = reactLoadableManifest[mod]</span><span class="s3">\n\n    </span><span class="s1">if (manifestItem) {</span><span class="s3">\n      </span><span class="s1">dynamicImportsIds.add(manifestItem.id)</span><span class="s3">\n      </span><span class="s1">manifestItem.files.forEach((item) =&gt; {</span><span class="s3">\n        </span><span class="s1">dynamicImports.add(item)</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const hybridAmp = ampState.hybrid</span><span class="s3">\n  </span><span class="s1">const docComponentsRendered: DocumentProps['docComponentsRendered'] = {}</span><span class="s3">\n\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">assetPrefix,</span><span class="s3">\n    </span><span class="s1">defaultLocale,</span><span class="s3">\n    </span><span class="s1">disableOptimizedLoading,</span><span class="s3">\n    </span><span class="s1">domainLocales,</span><span class="s3">\n    </span><span class="s1">locale,</span><span class="s3">\n    </span><span class="s1">locales,</span><span class="s3">\n    </span><span class="s1">runtimeConfig,</span><span class="s3">\n  </span><span class="s1">} = renderOpts</span><span class="s3">\n  </span><span class="s1">const htmlProps: HtmlProps = {</span><span class="s3">\n    </span><span class="s1">__NEXT_DATA__: {</span><span class="s3">\n      </span><span class="s1">props, // The result of getInitialProps</span><span class="s3">\n      </span><span class="s1">page: pathname, // The rendered page</span><span class="s3">\n      </span><span class="s1">query, // querystring parsed / passed by the user</span><span class="s3">\n      </span><span class="s1">buildId: sharedContext.buildId,</span><span class="s3">\n      </span><span class="s1">assetPrefix: assetPrefix === '' ? undefined : assetPrefix, // send assetPrefix to the client side when configured, otherwise don't sent in the resulting HTML</span><span class="s3">\n      </span><span class="s1">runtimeConfig, // runtimeConfig if provided, otherwise don't sent in the resulting HTML</span><span class="s3">\n      </span><span class="s1">nextExport: nextExport === true ? true : undefined, // If this is a page exported by `next export`</span><span class="s3">\n      </span><span class="s1">autoExport: isAutoExport === true ? true : undefined, // If this is an auto exported page</span><span class="s3">\n      </span><span class="s1">isFallback,</span><span class="s3">\n      </span><span class="s1">isExperimentalCompile,</span><span class="s3">\n      </span><span class="s1">dynamicIds:</span><span class="s3">\n        </span><span class="s1">dynamicImportsIds.size === 0</span><span class="s3">\n          </span><span class="s1">? undefined</span><span class="s3">\n          </span><span class="s1">: Array.from(dynamicImportsIds),</span><span class="s3">\n      </span><span class="s1">err: renderOpts.err ? serializeError(dev, renderOpts.err) : undefined, // Error if one happened, otherwise don't sent in the resulting HTML</span><span class="s3">\n      </span><span class="s1">gsp: !!getStaticProps ? true : undefined, // whether the page is getStaticProps</span><span class="s3">\n      </span><span class="s1">gssp: !!getServerSideProps ? true : undefined, // whether the page is getServerSideProps</span><span class="s3">\n      </span><span class="s1">customServer: sharedContext.customServer,</span><span class="s3">\n      </span><span class="s1">gip: hasPageGetInitialProps ? true : undefined, // whether the page has getInitialProps</span><span class="s3">\n      </span><span class="s1">appGip: !defaultAppGetInitialProps ? true : undefined, // whether the _app has getInitialProps</span><span class="s3">\n      </span><span class="s1">locale,</span><span class="s3">\n      </span><span class="s1">locales,</span><span class="s3">\n      </span><span class="s1">defaultLocale,</span><span class="s3">\n      </span><span class="s1">domainLocales,</span><span class="s3">\n      </span><span class="s1">isPreview: isPreview === true ? true : undefined,</span><span class="s3">\n      </span><span class="s1">notFoundSrcPage: notFoundSrcPage &amp;&amp; dev ? notFoundSrcPage : undefined,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">nonce,</span><span class="s3">\n    </span><span class="s1">buildManifest: filteredBuildManifest,</span><span class="s3">\n    </span><span class="s1">docComponentsRendered,</span><span class="s3">\n    </span><span class="s1">dangerousAsPath: router.asPath,</span><span class="s3">\n    </span><span class="s1">canonicalBase:</span><span class="s3">\n      </span><span class="s1">!renderOpts.ampPath &amp;&amp; getRequestMeta(req, 'didStripLocale')</span><span class="s3">\n        </span><span class="s1">? `${renderOpts.canonicalBase || ''}/${renderOpts.locale}`</span><span class="s3">\n        </span><span class="s1">: renderOpts.canonicalBase,</span><span class="s3">\n    </span><span class="s1">ampPath,</span><span class="s3">\n    </span><span class="s1">inAmpMode,</span><span class="s3">\n    </span><span class="s1">isDevelopment: !!dev,</span><span class="s3">\n    </span><span class="s1">hybridAmp,</span><span class="s3">\n    </span><span class="s1">dynamicImports: Array.from(dynamicImports),</span><span class="s3">\n    </span><span class="s1">dynamicCssManifest: new Set(renderOpts.dynamicCssManifest || []),</span><span class="s3">\n    </span><span class="s1">assetPrefix,</span><span class="s3">\n    </span><span class="s1">// Only enabled in production as development mode has features relying on HMR (style injection for example)</span><span class="s3">\n    </span><span class="s1">unstable_runtimeJS:</span><span class="s3">\n      </span><span class="s1">process.env.NODE_ENV === 'production'</span><span class="s3">\n        </span><span class="s1">? pageConfig.unstable_runtimeJS</span><span class="s3">\n        </span><span class="s1">: undefined,</span><span class="s3">\n    </span><span class="s1">unstable_JsPreload: pageConfig.unstable_JsPreload,</span><span class="s3">\n    </span><span class="s1">assetQueryString,</span><span class="s3">\n    </span><span class="s1">scriptLoader,</span><span class="s3">\n    </span><span class="s1">locale,</span><span class="s3">\n    </span><span class="s1">disableOptimizedLoading,</span><span class="s3">\n    </span><span class="s1">head: documentResult.head,</span><span class="s3">\n    </span><span class="s1">headTags: documentResult.headTags,</span><span class="s3">\n    </span><span class="s1">styles: documentResult.styles,</span><span class="s3">\n    </span><span class="s1">crossOrigin: renderOpts.crossOrigin,</span><span class="s3">\n    </span><span class="s1">optimizeCss: renderOpts.optimizeCss,</span><span class="s3">\n    </span><span class="s1">nextConfigOutput: renderOpts.nextConfigOutput,</span><span class="s3">\n    </span><span class="s1">nextScriptWorkers: renderOpts.nextScriptWorkers,</span><span class="s3">\n    </span><span class="s1">runtime: globalRuntime,</span><span class="s3">\n    </span><span class="s1">largePageDataBytes: renderOpts.largePageDataBytes,</span><span class="s3">\n    </span><span class="s1">nextFontManifest: renderOpts.nextFontManifest,</span><span class="s3">\n    </span><span class="s1">experimentalClientTraceMetadata:</span><span class="s3">\n      </span><span class="s1">renderOpts.experimental.clientTraceMetadata,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const document = (</span><span class="s3">\n    </span><span class="s1">&lt;AmpStateContext.Provider value={ampState}&gt;</span><span class="s3">\n      </span><span class="s1">&lt;HtmlContext.Provider value={htmlProps}&gt;</span><span class="s3">\n        </span><span class="s1">{documentResult.documentElement(htmlProps)}</span><span class="s3">\n      </span><span class="s1">&lt;/HtmlContext.Provider&gt;</span><span class="s3">\n    </span><span class="s1">&lt;/AmpStateContext.Provider&gt;</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const documentHTML = await getTracer().trace(</span><span class="s3">\n    </span><span class="s1">RenderSpan.renderToString,</span><span class="s3">\n    </span><span class="s1">async () =&gt; renderToString(document)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n    </span><span class="s1">const nonRenderedComponents = []</span><span class="s3">\n    </span><span class="s1">const expectedDocComponents = ['Main', 'Head', 'NextScript', 'Html']</span><span class="s3">\n\n    </span><span class="s1">for (const comp of expectedDocComponents) {</span><span class="s3">\n      </span><span class="s1">if (!(docComponentsRendered as any)[comp]) {</span><span class="s3">\n        </span><span class="s1">nonRenderedComponents.push(comp)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (nonRenderedComponents.length) {</span><span class="s3">\n      </span><span class="s1">const missingComponentList = nonRenderedComponents</span><span class="s3">\n        </span><span class="s1">.map((e) =&gt; `&lt;${e} /&gt;`)</span><span class="s3">\n        </span><span class="s1">.join(', ')</span><span class="s3">\n      </span><span class="s1">const plural = nonRenderedComponents.length !== 1 ? 's' : ''</span><span class="s3">\n      </span><span class="s1">console.warn(</span><span class="s3">\n        </span><span class="s1">`Your custom Document (pages/_document) did not render all the required subcomponent${plural}.</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n          </span><span class="s1">`Missing component${plural}: ${missingComponentList}</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n          </span><span class="s1">'Read how to fix here: https://nextjs.org/docs/messages/missing-document-component'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const [renderTargetPrefix, renderTargetSuffix] = documentHTML.split(</span><span class="s3">\n    </span><span class="s1">'&lt;next-js-internal-body-render-target&gt;&lt;/next-js-internal-body-render-target&gt;',</span><span class="s3">\n    </span><span class="s1">2</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">let prefix = ''</span><span class="s3">\n  </span><span class="s1">if (!documentHTML.startsWith(DOCTYPE)) {</span><span class="s3">\n    </span><span class="s1">prefix += DOCTYPE</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">prefix += renderTargetPrefix</span><span class="s3">\n  </span><span class="s1">if (inAmpMode) {</span><span class="s3">\n    </span><span class="s1">prefix += '&lt;!-- __NEXT_DATA__ --&gt;'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const content = prefix + documentResult.contentHTML + renderTargetSuffix</span><span class="s3">\n\n  </span><span class="s1">const optimizedHtml = await postProcessHTML(pathname, content, renderOpts, {</span><span class="s3">\n    </span><span class="s1">inAmpMode,</span><span class="s3">\n    </span><span class="s1">hybridAmp,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">return new RenderResult(optimizedHtml, {</span><span class="s3">\n    </span><span class="s1">metadata,</span><span class="s3">\n    </span><span class="s1">contentType: HTML_CONTENT_TYPE_HEADER,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type PagesRender = (</span><span class="s3">\n  </span><span class="s1">req: IncomingMessage,</span><span class="s3">\n  </span><span class="s1">res: ServerResponse,</span><span class="s3">\n  </span><span class="s1">pathname: string,</span><span class="s3">\n  </span><span class="s1">query: NextParsedUrlQuery,</span><span class="s3">\n  </span><span class="s1">renderOpts: RenderOpts,</span><span class="s3">\n  </span><span class="s1">sharedContext: PagesSharedContext,</span><span class="s3">\n  </span><span class="s1">renderContext: PagesRenderContext</span><span class="s3">\n</span><span class="s1">) =&gt; Promise&lt;RenderResult&gt;</span><span class="s3">\n\n</span><span class="s1">export const renderToHTML: PagesRender = (</span><span class="s3">\n  </span><span class="s1">req,</span><span class="s3">\n  </span><span class="s1">res,</span><span class="s3">\n  </span><span class="s1">pathname,</span><span class="s3">\n  </span><span class="s1">query,</span><span class="s3">\n  </span><span class="s1">renderOpts,</span><span class="s3">\n  </span><span class="s1">sharedContext,</span><span class="s3">\n  </span><span class="s1">renderContext</span><span class="s3">\n</span><span class="s1">) =&gt; {</span><span class="s3">\n  </span><span class="s1">return renderToHTMLImpl(</span><span class="s3">\n    </span><span class="s1">req,</span><span class="s3">\n    </span><span class="s1">res,</span><span class="s3">\n    </span><span class="s1">pathname,</span><span class="s3">\n    </span><span class="s1">query,</span><span class="s3">\n    </span><span class="s1">renderOpts,</span><span class="s3">\n    </span><span class="s1">renderOpts,</span><span class="s3">\n    </span><span class="s1">sharedContext,</span><span class="s3">\n    </span><span class="s1">renderContext</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import MODERN_BROWSERSLIST_TARGET from './modern-browserslist-target'</span><span class="s3">\n\n</span><span class="s1">export { MODERN_BROWSERSLIST_TARGET }</span><span class="s3">\n\n</span><span class="s1">export type ValueOf&lt;T&gt; = Required&lt;T&gt;[keyof T]</span><span class="s3">\n\n</span><span class="s1">export const COMPILER_NAMES = {</span><span class="s3">\n  </span><span class="s1">client: 'client',</span><span class="s3">\n  </span><span class="s1">server: 'server',</span><span class="s3">\n  </span><span class="s1">edgeServer: 'edge-server',</span><span class="s3">\n</span><span class="s1">} as const</span><span class="s3">\n\n</span><span class="s1">export type CompilerNameValues = ValueOf&lt;typeof COMPILER_NAMES&gt;</span><span class="s3">\n\n</span><span class="s1">export enum AdapterOutputType {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `PAGES` represents all the React pages that are under `pages/`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">PAGES = 'PAGES',</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `PAGES_API` represents all the API routes under `pages/api/`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">PAGES_API = 'PAGES_API',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `APP_PAGE` represents all the React pages that are under `app/` with the</span><span class="s3">\n   </span><span class="s1">* filename of `page.{j,t}s{,x}`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">APP_PAGE = 'APP_PAGE',</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `APP_ROUTE` represents all the API routes and metadata routes that are under `app/` with the</span><span class="s3">\n   </span><span class="s1">* filename of `route.{j,t}s{,x}`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">APP_ROUTE = 'APP_ROUTE',</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `PRERENDER` represents an ISR enabled route that might</span><span class="s3">\n   </span><span class="s1">* have a seeded cache entry or fallback generated during build</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">PRERENDER = 'PRERENDER',</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `STATIC_FILE` represents a static file (ie /_next/static)</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">STATIC_FILE = 'STATIC_FILE',</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `MIDDLEWARE` represents the middleware output if present</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">MIDDLEWARE = 'MIDDLEWARE',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const COMPILER_INDEXES: {</span><span class="s3">\n  </span><span class="s1">[compilerKey in CompilerNameValues]: number</span><span class="s3">\n</span><span class="s1">} = {</span><span class="s3">\n  </span><span class="s1">[COMPILER_NAMES.client]: 0,</span><span class="s3">\n  </span><span class="s1">[COMPILER_NAMES.server]: 1,</span><span class="s3">\n  </span><span class="s1">[COMPILER_NAMES.edgeServer]: 2,</span><span class="s3">\n</span><span class="s1">} as const</span><span class="s3">\n\n</span><span class="s1">export const UNDERSCORE_NOT_FOUND_ROUTE = '/_not-found'</span><span class="s3">\n</span><span class="s1">export const UNDERSCORE_NOT_FOUND_ROUTE_ENTRY = `${UNDERSCORE_NOT_FOUND_ROUTE}/page`</span><span class="s3">\n</span><span class="s1">export const PHASE_EXPORT = 'phase-export'</span><span class="s3">\n</span><span class="s1">export const PHASE_PRODUCTION_BUILD = 'phase-production-build'</span><span class="s3">\n</span><span class="s1">export const PHASE_PRODUCTION_SERVER = 'phase-production-server'</span><span class="s3">\n</span><span class="s1">export const PHASE_DEVELOPMENT_SERVER = 'phase-development-server'</span><span class="s3">\n</span><span class="s1">export const PHASE_TEST = 'phase-test'</span><span class="s3">\n</span><span class="s1">export const PHASE_INFO = 'phase-info'</span><span class="s3">\n</span><span class="s1">export const PAGES_MANIFEST = 'pages-manifest.json'</span><span class="s3">\n</span><span class="s1">export const WEBPACK_STATS = 'webpack-stats.json'</span><span class="s3">\n</span><span class="s1">export const APP_PATHS_MANIFEST = 'app-paths-manifest.json'</span><span class="s3">\n</span><span class="s1">export const APP_PATH_ROUTES_MANIFEST = 'app-path-routes-manifest.json'</span><span class="s3">\n</span><span class="s1">export const BUILD_MANIFEST = 'build-manifest.json'</span><span class="s3">\n</span><span class="s1">export const APP_BUILD_MANIFEST = 'app-build-manifest.json'</span><span class="s3">\n</span><span class="s1">export const FUNCTIONS_CONFIG_MANIFEST = 'functions-config-manifest.json'</span><span class="s3">\n</span><span class="s1">export const SUBRESOURCE_INTEGRITY_MANIFEST = 'subresource-integrity-manifest'</span><span class="s3">\n</span><span class="s1">export const NEXT_FONT_MANIFEST = 'next-font-manifest'</span><span class="s3">\n</span><span class="s1">export const EXPORT_MARKER = 'export-marker.json'</span><span class="s3">\n</span><span class="s1">export const EXPORT_DETAIL = 'export-detail.json'</span><span class="s3">\n</span><span class="s1">export const PRERENDER_MANIFEST = 'prerender-manifest.json'</span><span class="s3">\n</span><span class="s1">export const ROUTES_MANIFEST = 'routes-manifest.json'</span><span class="s3">\n</span><span class="s1">export const IMAGES_MANIFEST = 'images-manifest.json'</span><span class="s3">\n</span><span class="s1">export const SERVER_FILES_MANIFEST = 'required-server-files.json'</span><span class="s3">\n</span><span class="s1">export const DEV_CLIENT_PAGES_MANIFEST = '_devPagesManifest.json'</span><span class="s3">\n</span><span class="s1">export const MIDDLEWARE_MANIFEST = 'middleware-manifest.json'</span><span class="s3">\n</span><span class="s1">export const TURBOPACK_CLIENT_MIDDLEWARE_MANIFEST =</span><span class="s3">\n  </span><span class="s1">'_clientMiddlewareManifest.json'</span><span class="s3">\n</span><span class="s1">export const TURBOPACK_CLIENT_BUILD_MANIFEST = 'client-build-manifest.json'</span><span class="s3">\n</span><span class="s1">export const DEV_CLIENT_MIDDLEWARE_MANIFEST = '_devMiddlewareManifest.json'</span><span class="s3">\n</span><span class="s1">export const REACT_LOADABLE_MANIFEST = 'react-loadable-manifest.json'</span><span class="s3">\n</span><span class="s1">export const SERVER_DIRECTORY = 'server'</span><span class="s3">\n</span><span class="s1">export const CONFIG_FILES = [</span><span class="s3">\n  </span><span class="s1">'next.config.js',</span><span class="s3">\n  </span><span class="s1">'next.config.mjs',</span><span class="s3">\n  </span><span class="s1">'next.config.ts',</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n</span><span class="s1">export const BUILD_ID_FILE = 'BUILD_ID'</span><span class="s3">\n</span><span class="s1">export const BLOCKED_PAGES = ['/_document', '/_app', '/_error']</span><span class="s3">\n</span><span class="s1">export const CLIENT_PUBLIC_FILES_PATH = 'public'</span><span class="s3">\n</span><span class="s1">export const CLIENT_STATIC_FILES_PATH = 'static'</span><span class="s3">\n</span><span class="s1">export const STRING_LITERAL_DROP_BUNDLE = '__NEXT_DROP_CLIENT_FILE__'</span><span class="s3">\n</span><span class="s1">export const NEXT_BUILTIN_DOCUMENT = '__NEXT_BUILTIN_DOCUMENT__'</span><span class="s3">\n</span><span class="s1">export const BARREL_OPTIMIZATION_PREFIX = '__barrel_optimize__'</span><span class="s3">\n\n</span><span class="s1">// server/[entry]/page_client-reference-manifest.js</span><span class="s3">\n</span><span class="s1">export const CLIENT_REFERENCE_MANIFEST = 'client-reference-manifest'</span><span class="s3">\n</span><span class="s1">// server/server-reference-manifest</span><span class="s3">\n</span><span class="s1">export const SERVER_REFERENCE_MANIFEST = 'server-reference-manifest'</span><span class="s3">\n</span><span class="s1">// server/middleware-build-manifest.js</span><span class="s3">\n</span><span class="s1">export const MIDDLEWARE_BUILD_MANIFEST = 'middleware-build-manifest'</span><span class="s3">\n</span><span class="s1">// server/middleware-react-loadable-manifest.js</span><span class="s3">\n</span><span class="s1">export const MIDDLEWARE_REACT_LOADABLE_MANIFEST =</span><span class="s3">\n  </span><span class="s1">'middleware-react-loadable-manifest'</span><span class="s3">\n</span><span class="s1">// server/interception-route-rewrite-manifest.js</span><span class="s3">\n</span><span class="s1">export const INTERCEPTION_ROUTE_REWRITE_MANIFEST =</span><span class="s3">\n  </span><span class="s1">'interception-route-rewrite-manifest'</span><span class="s3">\n</span><span class="s1">// server/dynamic-css-manifest.js</span><span class="s3">\n</span><span class="s1">export const DYNAMIC_CSS_MANIFEST = 'dynamic-css-manifest'</span><span class="s3">\n\n</span><span class="s1">// static/runtime/main.js</span><span class="s3">\n</span><span class="s1">export const CLIENT_STATIC_FILES_RUNTIME_MAIN = `main`</span><span class="s3">\n</span><span class="s1">export const CLIENT_STATIC_FILES_RUNTIME_MAIN_APP = `${CLIENT_STATIC_FILES_RUNTIME_MAIN}-app`</span><span class="s3">\n</span><span class="s1">// next internal client components chunk for layouts</span><span class="s3">\n</span><span class="s1">export const APP_CLIENT_INTERNALS = 'app-pages-internals'</span><span class="s3">\n</span><span class="s1">// static/runtime/react-refresh.js</span><span class="s3">\n</span><span class="s1">export const CLIENT_STATIC_FILES_RUNTIME_REACT_REFRESH = `react-refresh`</span><span class="s3">\n</span><span class="s1">// static/runtime/amp.js</span><span class="s3">\n</span><span class="s1">export const CLIENT_STATIC_FILES_RUNTIME_AMP = `amp`</span><span class="s3">\n</span><span class="s1">// static/runtime/webpack.js</span><span class="s3">\n</span><span class="s1">export const CLIENT_STATIC_FILES_RUNTIME_WEBPACK = `webpack`</span><span class="s3">\n</span><span class="s1">// static/runtime/polyfills.js</span><span class="s3">\n</span><span class="s1">export const CLIENT_STATIC_FILES_RUNTIME_POLYFILLS = 'polyfills'</span><span class="s3">\n</span><span class="s1">export const CLIENT_STATIC_FILES_RUNTIME_POLYFILLS_SYMBOL = Symbol(</span><span class="s3">\n  </span><span class="s1">CLIENT_STATIC_FILES_RUNTIME_POLYFILLS</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">export const DEFAULT_RUNTIME_WEBPACK = 'webpack-runtime'</span><span class="s3">\n</span><span class="s1">export const EDGE_RUNTIME_WEBPACK = 'edge-runtime-webpack'</span><span class="s3">\n</span><span class="s1">export const STATIC_PROPS_ID = '__N_SSG'</span><span class="s3">\n</span><span class="s1">export const SERVER_PROPS_ID = '__N_SSP'</span><span class="s3">\n</span><span class="s1">export const DEFAULT_SERIF_FONT = {</span><span class="s3">\n  </span><span class="s1">name: 'Times New Roman',</span><span class="s3">\n  </span><span class="s1">xAvgCharWidth: 821,</span><span class="s3">\n  </span><span class="s1">azAvgWidth: 854.3953488372093,</span><span class="s3">\n  </span><span class="s1">unitsPerEm: 2048,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const DEFAULT_SANS_SERIF_FONT = {</span><span class="s3">\n  </span><span class="s1">name: 'Arial',</span><span class="s3">\n  </span><span class="s1">xAvgCharWidth: 904,</span><span class="s3">\n  </span><span class="s1">azAvgWidth: 934.5116279069767,</span><span class="s3">\n  </span><span class="s1">unitsPerEm: 2048,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const STATIC_STATUS_PAGES = ['/500']</span><span class="s3">\n</span><span class="s1">export const TRACE_OUTPUT_VERSION = 1</span><span class="s3">\n</span><span class="s1">// in `MB`</span><span class="s3">\n</span><span class="s1">export const TURBO_TRACE_DEFAULT_MEMORY_LIMIT = 6000</span><span class="s3">\n\n</span><span class="s1">export const RSC_MODULE_TYPES = {</span><span class="s3">\n  </span><span class="s1">client: 'client',</span><span class="s3">\n  </span><span class="s1">server: 'server',</span><span class="s3">\n</span><span class="s1">} as const</span><span class="s3">\n\n</span><span class="s1">// comparing</span><span class="s3">\n</span><span class="s1">// https://nextjs.org/docs/api-reference/edge-runtime</span><span class="s3">\n</span><span class="s1">// with</span><span class="s3">\n</span><span class="s1">// https://nodejs.org/docs/latest/api/globals.html</span><span class="s3">\n</span><span class="s1">export const EDGE_UNSUPPORTED_NODE_APIS = [</span><span class="s3">\n  </span><span class="s1">'clearImmediate',</span><span class="s3">\n  </span><span class="s1">'setImmediate',</span><span class="s3">\n  </span><span class="s1">'BroadcastChannel',</span><span class="s3">\n  </span><span class="s1">'ByteLengthQueuingStrategy',</span><span class="s3">\n  </span><span class="s1">'CompressionStream',</span><span class="s3">\n  </span><span class="s1">'CountQueuingStrategy',</span><span class="s3">\n  </span><span class="s1">'DecompressionStream',</span><span class="s3">\n  </span><span class="s1">'DomException',</span><span class="s3">\n  </span><span class="s1">'MessageChannel',</span><span class="s3">\n  </span><span class="s1">'MessageEvent',</span><span class="s3">\n  </span><span class="s1">'MessagePort',</span><span class="s3">\n  </span><span class="s1">'ReadableByteStreamController',</span><span class="s3">\n  </span><span class="s1">'ReadableStreamBYOBRequest',</span><span class="s3">\n  </span><span class="s1">'ReadableStreamDefaultController',</span><span class="s3">\n  </span><span class="s1">'TransformStreamDefaultController',</span><span class="s3">\n  </span><span class="s1">'WritableStreamDefaultController',</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">export const SYSTEM_ENTRYPOINTS = new Set&lt;string&gt;([</span><span class="s3">\n  </span><span class="s1">CLIENT_STATIC_FILES_RUNTIME_MAIN,</span><span class="s3">\n  </span><span class="s1">CLIENT_STATIC_FILES_RUNTIME_REACT_REFRESH,</span><span class="s3">\n  </span><span class="s1">CLIENT_STATIC_FILES_RUNTIME_AMP,</span><span class="s3">\n  </span><span class="s1">CLIENT_STATIC_FILES_RUNTIME_MAIN_APP,</span><span class="s3">\n</span><span class="s1">])</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { UrlWithParsedQuery } from 'url'</span><span class="s3">\n</span><span class="s1">import { NEXT_RSC_UNION_QUERY } from '../client/components/app-router-headers'</span><span class="s3">\n\n</span><span class="s1">const DUMMY_ORIGIN = 'http://n'</span><span class="s3">\n\n</span><span class="s1">export function isFullStringUrl(url: string) {</span><span class="s3">\n  </span><span class="s1">return /https?:</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">//.test(url)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function parseUrl(url: string): URL | undefined {</span><span class="s3">\n  </span><span class="s1">let parsed: URL | undefined = undefined</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">parsed = new URL(url, DUMMY_ORIGIN)</span><span class="s3">\n  </span><span class="s1">} catch {}</span><span class="s3">\n  </span><span class="s1">return parsed</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function parseReqUrl(url: string): UrlWithParsedQuery | undefined {</span><span class="s3">\n  </span><span class="s1">const parsedUrl: URL | undefined = parseUrl(url)</span><span class="s3">\n\n  </span><span class="s1">if (!parsedUrl) {</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const query: Record&lt;string, string | string[]&gt; = {}</span><span class="s3">\n\n  </span><span class="s1">for (const key of parsedUrl.searchParams.keys()) {</span><span class="s3">\n    </span><span class="s1">const values = parsedUrl.searchParams.getAll(key)</span><span class="s3">\n    </span><span class="s1">query[key] = values.length &gt; 1 ? values : values[0]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const legacyUrl: UrlWithParsedQuery = {</span><span class="s3">\n    </span><span class="s1">query,</span><span class="s3">\n    </span><span class="s1">hash: parsedUrl.hash,</span><span class="s3">\n    </span><span class="s1">search: parsedUrl.search,</span><span class="s3">\n    </span><span class="s1">path: parsedUrl.pathname,</span><span class="s3">\n    </span><span class="s1">pathname: parsedUrl.pathname,</span><span class="s3">\n    </span><span class="s1">href: `${parsedUrl.pathname}${parsedUrl.search}${parsedUrl.hash}`,</span><span class="s3">\n    </span><span class="s1">host: '',</span><span class="s3">\n    </span><span class="s1">hostname: '',</span><span class="s3">\n    </span><span class="s1">auth: '',</span><span class="s3">\n    </span><span class="s1">protocol: '',</span><span class="s3">\n    </span><span class="s1">slashes: null,</span><span class="s3">\n    </span><span class="s1">port: '',</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return legacyUrl</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function stripNextRscUnionQuery(relativeUrl: string): string {</span><span class="s3">\n  </span><span class="s1">const urlInstance = new URL(relativeUrl, DUMMY_ORIGIN)</span><span class="s3">\n  </span><span class="s1">urlInstance.searchParams.delete(NEXT_RSC_UNION_QUERY)</span><span class="s3">\n\n  </span><span class="s1">return urlInstance.pathname + urlInstance.search</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export interface PathLocale {</span><span class="s3">\n  </span><span class="s1">detectedLocale?: string</span><span class="s3">\n  </span><span class="s1">pathname: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A cache of lowercased locales for each list of locales. This is stored as a</span><span class="s3">\n </span><span class="s1">* WeakMap so if the locales are garbage collected, the cache entry will be</span><span class="s3">\n </span><span class="s1">* removed as well.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const cache = new WeakMap&lt;readonly string[], readonly string[]&gt;()</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* For a pathname that may include a locale from a list of locales, it</span><span class="s3">\n </span><span class="s1">* removes the locale from the pathname returning it alongside with the</span><span class="s3">\n </span><span class="s1">* detected locale.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param pathname A pathname that may include a locale.</span><span class="s3">\n </span><span class="s1">* @param locales A list of locales.</span><span class="s3">\n </span><span class="s1">* @returns The detected locale and pathname without locale</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function normalizeLocalePath(</span><span class="s3">\n  </span><span class="s1">pathname: string,</span><span class="s3">\n  </span><span class="s1">locales?: readonly string[]</span><span class="s3">\n</span><span class="s1">): PathLocale {</span><span class="s3">\n  </span><span class="s1">// If locales is undefined, return the pathname as is.</span><span class="s3">\n  </span><span class="s1">if (!locales) return { pathname }</span><span class="s3">\n\n  </span><span class="s1">// Get the cached lowercased locales or create a new cache entry.</span><span class="s3">\n  </span><span class="s1">let lowercasedLocales = cache.get(locales)</span><span class="s3">\n  </span><span class="s1">if (!lowercasedLocales) {</span><span class="s3">\n    </span><span class="s1">lowercasedLocales = locales.map((locale) =&gt; locale.toLowerCase())</span><span class="s3">\n    </span><span class="s1">cache.set(locales, lowercasedLocales)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let detectedLocale: string | undefined</span><span class="s3">\n\n  </span><span class="s1">// The first segment will be empty, because it has a leading `/`. If</span><span class="s3">\n  </span><span class="s1">// there is no further segment, there is no locale (or it's the default).</span><span class="s3">\n  </span><span class="s1">const segments = pathname.split('/', 2)</span><span class="s3">\n\n  </span><span class="s1">// If there's no second segment (ie, the pathname is just `/`), there's no</span><span class="s3">\n  </span><span class="s1">// locale.</span><span class="s3">\n  </span><span class="s1">if (!segments[1]) return { pathname }</span><span class="s3">\n\n  </span><span class="s1">// The second segment will contain the locale part if any.</span><span class="s3">\n  </span><span class="s1">const segment = segments[1].toLowerCase()</span><span class="s3">\n\n  </span><span class="s1">// See if the segment matches one of the locales. If it doesn't, there is</span><span class="s3">\n  </span><span class="s1">// no locale (or it's the default).</span><span class="s3">\n  </span><span class="s1">const index = lowercasedLocales.indexOf(segment)</span><span class="s3">\n  </span><span class="s1">if (index &lt; 0) return { pathname }</span><span class="s3">\n\n  </span><span class="s1">// Return the case-sensitive locale.</span><span class="s3">\n  </span><span class="s1">detectedLocale = locales[index]</span><span class="s3">\n\n  </span><span class="s1">// Remove the `/${locale}` part of the pathname.</span><span class="s3">\n  </span><span class="s1">pathname = pathname.slice(detectedLocale.length + 1) || '/'</span><span class="s3">\n\n  </span><span class="s1">return { pathname, detectedLocale }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* For a given page path, this function ensures that there is a leading slash.</span><span class="s3">\n </span><span class="s1">* If there is not a leading slash, one is added, otherwise it is noop.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function ensureLeadingSlash(path: string) {</span><span class="s3">\n  </span><span class="s1">return path.startsWith('/') ? path : `/${path}`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { ensureLeadingSlash } from '../../page-path/ensure-leading-slash'</span><span class="s3">\n</span><span class="s1">import { isGroupSegment } from '../../segment'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Normalizes an app route so it represents the actual request path. Essentially</span><span class="s3">\n </span><span class="s1">* performing the following transformations:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* - `/(dashboard)/user/[id]/page` to `/user/[id]`</span><span class="s3">\n </span><span class="s1">* - `/(dashboard)/account/page` to `/account`</span><span class="s3">\n </span><span class="s1">* - `/user/[id]/page` to `/user/[id]`</span><span class="s3">\n </span><span class="s1">* - `/account/page` to `/account`</span><span class="s3">\n </span><span class="s1">* - `/page` to `/`</span><span class="s3">\n </span><span class="s1">* - `/(dashboard)/user/[id]/route` to `/user/[id]`</span><span class="s3">\n </span><span class="s1">* - `/(dashboard)/account/route` to `/account`</span><span class="s3">\n </span><span class="s1">* - `/user/[id]/route` to `/user/[id]`</span><span class="s3">\n </span><span class="s1">* - `/account/route` to `/account`</span><span class="s3">\n </span><span class="s1">* - `/route` to `/`</span><span class="s3">\n </span><span class="s1">* - `/` to `/`</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param route the app route to normalize</span><span class="s3">\n </span><span class="s1">* @returns the normalized pathname</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function normalizeAppPath(route: string) {</span><span class="s3">\n  </span><span class="s1">return ensureLeadingSlash(</span><span class="s3">\n    </span><span class="s1">route.split('/').reduce((pathname, segment, index, segments) =&gt; {</span><span class="s3">\n      </span><span class="s1">// Empty segments are ignored.</span><span class="s3">\n      </span><span class="s1">if (!segment) {</span><span class="s3">\n        </span><span class="s1">return pathname</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Groups are ignored.</span><span class="s3">\n      </span><span class="s1">if (isGroupSegment(segment)) {</span><span class="s3">\n        </span><span class="s1">return pathname</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Parallel segments are ignored.</span><span class="s3">\n      </span><span class="s1">if (segment[0] === '@') {</span><span class="s3">\n        </span><span class="s1">return pathname</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// The last segment (if it's a leaf) should be ignored.</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">(segment === 'page' || segment === 'route') &amp;&amp;</span><span class="s3">\n        </span><span class="s1">index === segments.length - 1</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return pathname</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return `${pathname}/${segment}`</span><span class="s3">\n    </span><span class="s1">}, '')</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Strips the `.rsc` extension if it's in the pathname.</span><span class="s3">\n </span><span class="s1">* Since this function is used on full urls it checks `?` for searchParams handling.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function normalizeRscURL(url: string) {</span><span class="s3">\n  </span><span class="s1">return url.replace(</span><span class="s3">\n    </span><span class="s1">/</span><span class="s3">\\</span><span class="s1">.rsc($|</span><span class="s3">\\</span><span class="s1">?)/,</span><span class="s3">\n    </span><span class="s1">// $1 ensures `?` is preserved</span><span class="s3">\n    </span><span class="s1">'$1'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { Segment } from '../../server/app-render/types'</span><span class="s3">\n\n</span><span class="s1">export function isGroupSegment(segment: string) {</span><span class="s3">\n  </span><span class="s1">// Use array[0] for performant purpose</span><span class="s3">\n  </span><span class="s1">return segment[0] === '(' &amp;&amp; segment.endsWith(')')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isParallelRouteSegment(segment: string) {</span><span class="s3">\n  </span><span class="s1">return segment.startsWith('@') &amp;&amp; segment !== '@children'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function addSearchParamsIfPageSegment(</span><span class="s3">\n  </span><span class="s1">segment: Segment,</span><span class="s3">\n  </span><span class="s1">searchParams: Record&lt;string, string | string[] | undefined&gt;</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const isPageSegment = segment.includes(PAGE_SEGMENT_KEY)</span><span class="s3">\n\n  </span><span class="s1">if (isPageSegment) {</span><span class="s3">\n    </span><span class="s1">const stringifiedQuery = JSON.stringify(searchParams)</span><span class="s3">\n    </span><span class="s1">return stringifiedQuery !== '{}'</span><span class="s3">\n      </span><span class="s1">? PAGE_SEGMENT_KEY + '?' + stringifiedQuery</span><span class="s3">\n      </span><span class="s1">: PAGE_SEGMENT_KEY</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return segment</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const PAGE_SEGMENT_KEY = '__PAGE__'</span><span class="s3">\n</span><span class="s1">export const DEFAULT_SEGMENT_KEY = '__DEFAULT__'</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { normalizeAppPath } from './app-paths'</span><span class="s3">\n\n</span><span class="s1">// order matters here, the first match will be used</span><span class="s3">\n</span><span class="s1">export const INTERCEPTION_ROUTE_MARKERS = [</span><span class="s3">\n  </span><span class="s1">'(..)(..)',</span><span class="s3">\n  </span><span class="s1">'(.)',</span><span class="s3">\n  </span><span class="s1">'(..)',</span><span class="s3">\n  </span><span class="s1">'(...)',</span><span class="s3">\n</span><span class="s1">] as const</span><span class="s3">\n\n</span><span class="s1">export function isInterceptionRouteAppPath(path: string): boolean {</span><span class="s3">\n  </span><span class="s1">// TODO-APP: add more serious validation</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">path</span><span class="s3">\n      </span><span class="s1">.split('/')</span><span class="s3">\n      </span><span class="s1">.find((segment) =&gt;</span><span class="s3">\n        </span><span class="s1">INTERCEPTION_ROUTE_MARKERS.find((m) =&gt; segment.startsWith(m))</span><span class="s3">\n      </span><span class="s1">) !== undefined</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function extractInterceptionRouteInformation(path: string) {</span><span class="s3">\n  </span><span class="s1">let interceptingRoute: string | undefined,</span><span class="s3">\n    </span><span class="s1">marker: (typeof INTERCEPTION_ROUTE_MARKERS)[number] | undefined,</span><span class="s3">\n    </span><span class="s1">interceptedRoute: string | undefined</span><span class="s3">\n\n  </span><span class="s1">for (const segment of path.split('/')) {</span><span class="s3">\n    </span><span class="s1">marker = INTERCEPTION_ROUTE_MARKERS.find((m) =&gt; segment.startsWith(m))</span><span class="s3">\n    </span><span class="s1">if (marker) {</span><span class="s3">\n      </span><span class="s1">;[interceptingRoute, interceptedRoute] = path.split(marker, 2)</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!interceptingRoute || !marker || !interceptedRoute) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`Invalid interception route: ${path}. Must be in the format /&lt;intercepting route&gt;/(..|...|..)(..)/&lt;intercepted route&gt;`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">interceptingRoute = normalizeAppPath(interceptingRoute) // normalize the path, e.g. /(blog)/feed -&gt; /feed</span><span class="s3">\n\n  </span><span class="s1">switch (marker) {</span><span class="s3">\n    </span><span class="s1">case '(.)':</span><span class="s3">\n      </span><span class="s1">// (.) indicates that we should match with sibling routes, so we just need to append the intercepted route to the intercepting route</span><span class="s3">\n      </span><span class="s1">if (interceptingRoute === '/') {</span><span class="s3">\n        </span><span class="s1">interceptedRoute = `/${interceptedRoute}`</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">interceptedRoute = interceptingRoute + '/' + interceptedRoute</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">case '(..)':</span><span class="s3">\n      </span><span class="s1">// (..) indicates that we should match at one level up, so we need to remove the last segment of the intercepting route</span><span class="s3">\n      </span><span class="s1">if (interceptingRoute === '/') {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">`Invalid interception route: ${path}. Cannot use (..) marker at the root level, use (.) instead.`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">interceptedRoute = interceptingRoute</span><span class="s3">\n        </span><span class="s1">.split('/')</span><span class="s3">\n        </span><span class="s1">.slice(0, -1)</span><span class="s3">\n        </span><span class="s1">.concat(interceptedRoute)</span><span class="s3">\n        </span><span class="s1">.join('/')</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">case '(...)':</span><span class="s3">\n      </span><span class="s1">// (...) will match the route segment in the root directory, so we need to use the root directory to prepend the intercepted route</span><span class="s3">\n      </span><span class="s1">interceptedRoute = '/' + interceptedRoute</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">case '(..)(..)':</span><span class="s3">\n      </span><span class="s1">// (..)(..) indicates that we should match at two levels up, so we need to remove the last two segments of the intercepting route</span><span class="s3">\n\n      </span><span class="s1">const splitInterceptingRoute = interceptingRoute.split('/')</span><span class="s3">\n      </span><span class="s1">if (splitInterceptingRoute.length &lt;= 2) {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\n          </span><span class="s1">`Invalid interception route: ${path}. Cannot use (..)(..) marker at the root level or one level up.`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">interceptedRoute = splitInterceptingRoute</span><span class="s3">\n        </span><span class="s1">.slice(0, -2)</span><span class="s3">\n        </span><span class="s1">.concat(interceptedRoute)</span><span class="s3">\n        </span><span class="s1">.join('/')</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">throw new Error('Invariant: unexpected marker')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return { interceptingRoute, interceptedRoute }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">extractInterceptionRouteInformation,</span><span class="s3">\n  </span><span class="s1">isInterceptionRouteAppPath,</span><span class="s3">\n</span><span class="s1">} from './interception-routes'</span><span class="s3">\n\n</span><span class="s1">// Identify /.*[param].*/ in route string</span><span class="s3">\n</span><span class="s1">const TEST_ROUTE = /</span><span class="s3">\\</span><span class="s1">/[^/]*</span><span class="s3">\\</span><span class="s1">[[^/]+</span><span class="s3">\\</span><span class="s1">][^/]*(?=</span><span class="s3">\\</span><span class="s1">/|$)/</span><span class="s3">\n\n</span><span class="s1">// Identify /[param]/ in route string</span><span class="s3">\n</span><span class="s1">const TEST_STRICT_ROUTE = /</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">[[^/]+</span><span class="s3">\\</span><span class="s1">](?=</span><span class="s3">\\</span><span class="s1">/|$)/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Check if a route is dynamic.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param route - The route to check.</span><span class="s3">\n </span><span class="s1">* @param strict - Whether to use strict mode which prohibits segments with prefixes/suffixes (default: true).</span><span class="s3">\n </span><span class="s1">* @returns Whether the route is dynamic.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isDynamicRoute(route: string, strict: boolean = true): boolean {</span><span class="s3">\n  </span><span class="s1">if (isInterceptionRouteAppPath(route)) {</span><span class="s3">\n    </span><span class="s1">route = extractInterceptionRouteInformation(route).interceptedRoute</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (strict) {</span><span class="s3">\n    </span><span class="s1">return TEST_STRICT_ROUTE.test(route)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return TEST_ROUTE.test(route)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Given a path this function will find the pathname, query and hash and return</span><span class="s3">\n </span><span class="s1">* them. This is useful to parse full paths on the client side.</span><span class="s3">\n </span><span class="s1">* @param path A path to parse e.g. /foo/bar?id=1#hash</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function parsePath(path: string) {</span><span class="s3">\n  </span><span class="s1">const hashIndex = path.indexOf('#')</span><span class="s3">\n  </span><span class="s1">const queryIndex = path.indexOf('?')</span><span class="s3">\n  </span><span class="s1">const hasQuery = queryIndex &gt; -1 &amp;&amp; (hashIndex &lt; 0 || queryIndex &lt; hashIndex)</span><span class="s3">\n\n  </span><span class="s1">if (hasQuery || hashIndex &gt; -1) {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">pathname: path.substring(0, hasQuery ? queryIndex : hashIndex),</span><span class="s3">\n      </span><span class="s1">query: hasQuery</span><span class="s3">\n        </span><span class="s1">? path.substring(queryIndex, hashIndex &gt; -1 ? hashIndex : undefined)</span><span class="s3">\n        </span><span class="s1">: '',</span><span class="s3">\n      </span><span class="s1">hash: hashIndex &gt; -1 ? path.slice(hashIndex) : '',</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return { pathname: path, query: '', hash: '' }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { parsePath } from './parse-path'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if a given path starts with a given prefix. It ensures it matches</span><span class="s3">\n </span><span class="s1">* exactly without containing extra chars. e.g. prefix /docs should replace</span><span class="s3">\n </span><span class="s1">* for /docs, /docs/, /docs/a but not /docsss</span><span class="s3">\n </span><span class="s1">* @param path The path to check.</span><span class="s3">\n </span><span class="s1">* @param prefix The prefix to check against.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function pathHasPrefix(path: string, prefix: string) {</span><span class="s3">\n  </span><span class="s1">if (typeof path !== 'string') {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { pathname } = parsePath(path)</span><span class="s3">\n  </span><span class="s1">return pathname === prefix || pathname.startsWith(prefix + '/')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { pathHasPrefix } from './path-has-prefix'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Given a path and a prefix it will remove the prefix when it exists in the</span><span class="s3">\n </span><span class="s1">* given path. It ensures it matches exactly without containing extra chars</span><span class="s3">\n </span><span class="s1">* and if the prefix is not there it will be noop.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param path The path to remove the prefix from.</span><span class="s3">\n </span><span class="s1">* @param prefix The prefix to be removed.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function removePathPrefix(path: string, prefix: string): string {</span><span class="s3">\n  </span><span class="s1">// If the path doesn't start with the prefix we can return it as is. This</span><span class="s3">\n  </span><span class="s1">// protects us from situations where the prefix is a substring of the path</span><span class="s3">\n  </span><span class="s1">// prefix such as:</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// For prefix: /blog</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">//   /blog -&gt; true</span><span class="s3">\n  </span><span class="s1">//   /blog/ -&gt; true</span><span class="s3">\n  </span><span class="s1">//   /blog/1 -&gt; true</span><span class="s3">\n  </span><span class="s1">//   /blogging -&gt; false</span><span class="s3">\n  </span><span class="s1">//   /blogging/ -&gt; false</span><span class="s3">\n  </span><span class="s1">//   /blogging/1 -&gt; false</span><span class="s3">\n  </span><span class="s1">if (!pathHasPrefix(path, prefix)) {</span><span class="s3">\n    </span><span class="s1">return path</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Remove the prefix from the path via slicing.</span><span class="s3">\n  </span><span class="s1">const withoutPrefix = path.slice(prefix.length)</span><span class="s3">\n\n  </span><span class="s1">// If the path without the prefix starts with a `/` we can return it as is.</span><span class="s3">\n  </span><span class="s1">if (withoutPrefix.startsWith('/')) {</span><span class="s3">\n    </span><span class="s1">return withoutPrefix</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// If the path without the prefix doesn't start with a `/` we need to add it</span><span class="s3">\n  </span><span class="s1">// back to the path to make sure it's a valid path.</span><span class="s3">\n  </span><span class="s1">return `/${withoutPrefix}`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// regexp is based on https://github.com/sindresorhus/escape-string-regexp</span><span class="s3">\n</span><span class="s1">const reHasRegExp = /[|</span><span class="s3">\\\\</span><span class="s1">{}()[</span><span class="s3">\\</span><span class="s1">]^$+*?.-]/</span><span class="s3">\n</span><span class="s1">const reReplaceRegExp = /[|</span><span class="s3">\\\\</span><span class="s1">{}()[</span><span class="s3">\\</span><span class="s1">]^$+*?.-]/g</span><span class="s3">\n\n</span><span class="s1">export function escapeStringRegexp(str: string) {</span><span class="s3">\n  </span><span class="s1">// see also: https://github.com/lodash/lodash/blob/2da024c3b4f9947a48517639de7560457cd4ec6c/escapeRegExp.js#L23</span><span class="s3">\n  </span><span class="s1">if (reHasRegExp.test(str)) {</span><span class="s3">\n    </span><span class="s1">return str.replace(reReplaceRegExp, '</span><span class="s3">\\\\</span><span class="s1">$&amp;')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return str</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Removes the trailing slash for a given route or page path. Preserves the</span><span class="s3">\n </span><span class="s1">* root page. Examples:</span><span class="s3">\n </span><span class="s1">*   - `/foo/bar/` -&gt; `/foo/bar`</span><span class="s3">\n </span><span class="s1">*   - `/foo/bar` -&gt; `/foo/bar`</span><span class="s3">\n </span><span class="s1">*   - `/` -&gt; `/`</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function removeTrailingSlash(route: string) {</span><span class="s3">\n  </span><span class="s1">return route.replace(/</span><span class="s3">\\</span><span class="s1">/$/, '') || '/'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { DynamicParam } from '../../../../server/app-render/app-render'</span><span class="s3">\n</span><span class="s1">import type { DynamicParamTypesShort } from '../../../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import type { FallbackRouteParams } from '../../../../server/request/fallback-params'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Shared logic on client and server for creating a dynamic param value.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This code needs to be shared with the client so it can extract dynamic route</span><span class="s3">\n </span><span class="s1">* params from the URL without a server request.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Because everything in this module is sent to the client, we should aim to</span><span class="s3">\n </span><span class="s1">* keep this code as simple as possible. The special case handling for catchall</span><span class="s3">\n </span><span class="s1">* and optional is, alas, unfortunate.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getDynamicParam(</span><span class="s3">\n  </span><span class="s1">params: { [key: string]: any },</span><span class="s3">\n  </span><span class="s1">segmentKey: string,</span><span class="s3">\n  </span><span class="s1">dynamicParamType: DynamicParamTypesShort,</span><span class="s3">\n  </span><span class="s1">pagePath: string,</span><span class="s3">\n  </span><span class="s1">fallbackRouteParams: FallbackRouteParams | null</span><span class="s3">\n</span><span class="s1">): DynamicParam {</span><span class="s3">\n  </span><span class="s1">let value = params[segmentKey]</span><span class="s3">\n\n  </span><span class="s1">if (fallbackRouteParams &amp;&amp; fallbackRouteParams.has(segmentKey)) {</span><span class="s3">\n    </span><span class="s1">value = fallbackRouteParams.get(segmentKey)</span><span class="s3">\n  </span><span class="s1">} else if (Array.isArray(value)) {</span><span class="s3">\n    </span><span class="s1">value = value.map((i) =&gt; encodeURIComponent(i))</span><span class="s3">\n  </span><span class="s1">} else if (typeof value === 'string') {</span><span class="s3">\n    </span><span class="s1">value = encodeURIComponent(value)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!value) {</span><span class="s3">\n    </span><span class="s1">const isCatchall = dynamicParamType === 'c'</span><span class="s3">\n    </span><span class="s1">const isOptionalCatchall = dynamicParamType === 'oc'</span><span class="s3">\n\n    </span><span class="s1">if (isCatchall || isOptionalCatchall) {</span><span class="s3">\n      </span><span class="s1">// handle the case where an optional catchall does not have a value,</span><span class="s3">\n      </span><span class="s1">// e.g. `/dashboard/[[...slug]]` when requesting `/dashboard`</span><span class="s3">\n      </span><span class="s1">if (isOptionalCatchall) {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">param: segmentKey,</span><span class="s3">\n          </span><span class="s1">value: null,</span><span class="s3">\n          </span><span class="s1">type: dynamicParamType,</span><span class="s3">\n          </span><span class="s1">treeSegment: [segmentKey, '', dynamicParamType],</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// handle the case where a catchall or optional catchall does not have a value,</span><span class="s3">\n      </span><span class="s1">// e.g. `/foo/bar/hello` and `@slot/[...catchall]` or `@slot/[[...catchall]]` is matched</span><span class="s3">\n      </span><span class="s1">value = pagePath</span><span class="s3">\n        </span><span class="s1">.split('/')</span><span class="s3">\n        </span><span class="s1">// remove the first empty string</span><span class="s3">\n        </span><span class="s1">.slice(1)</span><span class="s3">\n        </span><span class="s1">// replace any dynamic params with the actual values</span><span class="s3">\n        </span><span class="s1">.flatMap((pathSegment) =&gt; {</span><span class="s3">\n          </span><span class="s1">const param = parseParameter(pathSegment)</span><span class="s3">\n          </span><span class="s1">// if the segment matches a param, return the param value</span><span class="s3">\n          </span><span class="s1">// otherwise, it's a static segment, so just return that</span><span class="s3">\n          </span><span class="s1">return params[param.key] ?? param.key</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">param: segmentKey,</span><span class="s3">\n        </span><span class="s1">value,</span><span class="s3">\n        </span><span class="s1">type: dynamicParamType,</span><span class="s3">\n        </span><span class="s1">// This value always has to be a string.</span><span class="s3">\n        </span><span class="s1">treeSegment: [segmentKey, value.join('/'), dynamicParamType],</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">param: segmentKey,</span><span class="s3">\n    </span><span class="s1">// The value that is passed to user code.</span><span class="s3">\n    </span><span class="s1">value: value,</span><span class="s3">\n    </span><span class="s1">// The value that is rendered in the router tree.</span><span class="s3">\n    </span><span class="s1">treeSegment: [</span><span class="s3">\n      </span><span class="s1">segmentKey,</span><span class="s3">\n      </span><span class="s1">Array.isArray(value) ? value.join('/') : value,</span><span class="s3">\n      </span><span class="s1">dynamicParamType,</span><span class="s3">\n    </span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">type: dynamicParamType,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Regular expression pattern used to match route parameters.</span><span class="s3">\n </span><span class="s1">* Matches both single parameters and parameter groups.</span><span class="s3">\n </span><span class="s1">* Examples:</span><span class="s3">\n </span><span class="s1">*   - `[[...slug]]` matches parameter group with key 'slug', repeat: true, optional: true</span><span class="s3">\n </span><span class="s1">*   - `[...slug]` matches parameter group with key 'slug', repeat: true, optional: false</span><span class="s3">\n </span><span class="s1">*   - `[[foo]]` matches parameter with key 'foo', repeat: false, optional: true</span><span class="s3">\n </span><span class="s1">*   - `[bar]` matches parameter with key 'bar', repeat: false, optional: false</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const PARAMETER_PATTERN = /^([^[]*)</span><span class="s3">\\</span><span class="s1">[((?:</span><span class="s3">\\</span><span class="s1">[[^</span><span class="s3">\\</span><span class="s1">]]*</span><span class="s3">\\</span><span class="s1">])|[^</span><span class="s3">\\</span><span class="s1">]]+)</span><span class="s3">\\</span><span class="s1">](.*)$/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Parses a given parameter from a route to a data structure that can be used</span><span class="s3">\n </span><span class="s1">* to generate the parametrized route.</span><span class="s3">\n </span><span class="s1">* Examples:</span><span class="s3">\n </span><span class="s1">*   - `[[...slug]]` -&gt; `{ key: 'slug', repeat: true, optional: true }`</span><span class="s3">\n </span><span class="s1">*   - `[...slug]` -&gt; `{ key: 'slug', repeat: true, optional: false }`</span><span class="s3">\n </span><span class="s1">*   - `[[foo]]` -&gt; `{ key: 'foo', repeat: false, optional: true }`</span><span class="s3">\n </span><span class="s1">*   - `[bar]` -&gt; `{ key: 'bar', repeat: false, optional: false }`</span><span class="s3">\n </span><span class="s1">*   - `fizz` -&gt; `{ key: 'fizz', repeat: false, optional: false }`</span><span class="s3">\n </span><span class="s1">* @param param - The parameter to parse.</span><span class="s3">\n </span><span class="s1">* @returns The parsed parameter as a data structure.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function parseParameter(param: string) {</span><span class="s3">\n  </span><span class="s1">const match = param.match(PARAMETER_PATTERN)</span><span class="s3">\n\n  </span><span class="s1">if (!match) {</span><span class="s3">\n    </span><span class="s1">return parseMatchedParameter(param)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return parseMatchedParameter(match[2])</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Parses a matched parameter from the PARAMETER_PATTERN regex to a data structure that can be used</span><span class="s3">\n </span><span class="s1">* to generate the parametrized route.</span><span class="s3">\n </span><span class="s1">* Examples:</span><span class="s3">\n </span><span class="s1">*   - `[...slug]` -&gt; `{ key: 'slug', repeat: true, optional: true }`</span><span class="s3">\n </span><span class="s1">*   - `...slug` -&gt; `{ key: 'slug', repeat: true, optional: false }`</span><span class="s3">\n </span><span class="s1">*   - `[foo]` -&gt; `{ key: 'foo', repeat: false, optional: true }`</span><span class="s3">\n </span><span class="s1">*   - `bar` -&gt; `{ key: 'bar', repeat: false, optional: false }`</span><span class="s3">\n </span><span class="s1">* @param param - The matched parameter to parse.</span><span class="s3">\n </span><span class="s1">* @returns The parsed parameter as a data structure.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function parseMatchedParameter(param: string) {</span><span class="s3">\n  </span><span class="s1">const optional = param.startsWith('[') &amp;&amp; param.endsWith(']')</span><span class="s3">\n  </span><span class="s1">if (optional) {</span><span class="s3">\n    </span><span class="s1">param = param.slice(1, -1)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const repeat = param.startsWith('...')</span><span class="s3">\n  </span><span class="s1">if (repeat) {</span><span class="s3">\n    </span><span class="s1">param = param.slice(3)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return { key: param, repeat, optional }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">NEXT_INTERCEPTION_MARKER_PREFIX,</span><span class="s3">\n  </span><span class="s1">NEXT_QUERY_PARAM_PREFIX,</span><span class="s3">\n</span><span class="s1">} from '../../../../lib/constants'</span><span class="s3">\n</span><span class="s1">import { INTERCEPTION_ROUTE_MARKERS } from './interception-routes'</span><span class="s3">\n</span><span class="s1">import { escapeStringRegexp } from '../../escape-regexp'</span><span class="s3">\n</span><span class="s1">import { removeTrailingSlash } from './remove-trailing-slash'</span><span class="s3">\n</span><span class="s1">import { PARAMETER_PATTERN, parseMatchedParameter } from './get-dynamic-param'</span><span class="s3">\n\n</span><span class="s1">export interface Group {</span><span class="s3">\n  </span><span class="s1">pos: number</span><span class="s3">\n  </span><span class="s1">repeat: boolean</span><span class="s3">\n  </span><span class="s1">optional: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface RouteRegex {</span><span class="s3">\n  </span><span class="s1">groups: { [groupName: string]: Group }</span><span class="s3">\n  </span><span class="s1">re: RegExp</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type GetNamedRouteRegexOptions = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to prefix the route keys with the NEXT_INTERCEPTION_MARKER_PREFIX</span><span class="s3">\n   </span><span class="s1">* or NEXT_QUERY_PARAM_PREFIX. This is only relevant when creating the</span><span class="s3">\n   </span><span class="s1">* routes-manifest during the build.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">prefixRouteKeys: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to include the suffix in the route regex. This means that when you</span><span class="s3">\n   </span><span class="s1">* have something like `/[...slug].json` the `.json` part will be included</span><span class="s3">\n   </span><span class="s1">* in the regex, yielding `/(.*).json` as the regex.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">includeSuffix?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to include the prefix in the route regex. This means that when you</span><span class="s3">\n   </span><span class="s1">* have something like `/[...slug].json` the `/` part will be included</span><span class="s3">\n   </span><span class="s1">* in the regex, yielding `^/(.*).json$` as the regex.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* Note that interception markers will already be included without the need</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">includePrefix?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to exclude the optional trailing slash from the route regex.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">excludeOptionalTrailingSlash?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to backtrack duplicate keys. This is only relevant when creating</span><span class="s3">\n   </span><span class="s1">* the routes-manifest during the build.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">backreferenceDuplicateKeys?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type GetRouteRegexOptions = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to include extra parts in the route regex. This means that when you</span><span class="s3">\n   </span><span class="s1">* have something like `/[...slug].json` the `.json` part will be included</span><span class="s3">\n   </span><span class="s1">* in the regex, yielding `/(.*).json` as the regex.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">includeSuffix?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to include the prefix in the route regex. This means that when you</span><span class="s3">\n   </span><span class="s1">* have something like `/[...slug].json` the `/` part will be included</span><span class="s3">\n   </span><span class="s1">* in the regex, yielding `^/(.*).json$` as the regex.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* Note that interception markers will already be included without the need</span><span class="s3">\n   </span><span class="s1">* of adding this option.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">includePrefix?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to exclude the optional trailing slash from the route regex.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">excludeOptionalTrailingSlash?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getParametrizedRoute(</span><span class="s3">\n  </span><span class="s1">route: string,</span><span class="s3">\n  </span><span class="s1">includeSuffix: boolean,</span><span class="s3">\n  </span><span class="s1">includePrefix: boolean</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const groups: { [groupName: string]: Group } = {}</span><span class="s3">\n  </span><span class="s1">let groupIndex = 1</span><span class="s3">\n\n  </span><span class="s1">const segments: string[] = []</span><span class="s3">\n  </span><span class="s1">for (const segment of removeTrailingSlash(route).slice(1).split('/')) {</span><span class="s3">\n    </span><span class="s1">const markerMatch = INTERCEPTION_ROUTE_MARKERS.find((m) =&gt;</span><span class="s3">\n      </span><span class="s1">segment.startsWith(m)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">const paramMatches = segment.match(PARAMETER_PATTERN) // Check for parameters</span><span class="s3">\n\n    </span><span class="s1">if (markerMatch &amp;&amp; paramMatches &amp;&amp; paramMatches[2]) {</span><span class="s3">\n      </span><span class="s1">const { key, optional, repeat } = parseMatchedParameter(paramMatches[2])</span><span class="s3">\n      </span><span class="s1">groups[key] = { pos: groupIndex++, repeat, optional }</span><span class="s3">\n      </span><span class="s1">segments.push(`/${escapeStringRegexp(markerMatch)}([^/]+?)`)</span><span class="s3">\n    </span><span class="s1">} else if (paramMatches &amp;&amp; paramMatches[2]) {</span><span class="s3">\n      </span><span class="s1">const { key, repeat, optional } = parseMatchedParameter(paramMatches[2])</span><span class="s3">\n      </span><span class="s1">groups[key] = { pos: groupIndex++, repeat, optional }</span><span class="s3">\n\n      </span><span class="s1">if (includePrefix &amp;&amp; paramMatches[1]) {</span><span class="s3">\n        </span><span class="s1">segments.push(`/${escapeStringRegexp(paramMatches[1])}`)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">let s = repeat ? (optional ? '(?:/(.+?))?' : '/(.+?)') : '/([^/]+?)'</span><span class="s3">\n\n      </span><span class="s1">// Remove the leading slash if includePrefix already added it.</span><span class="s3">\n      </span><span class="s1">if (includePrefix &amp;&amp; paramMatches[1]) {</span><span class="s3">\n        </span><span class="s1">s = s.substring(1)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">segments.push(s)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">segments.push(`/${escapeStringRegexp(segment)}`)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If there's a suffix, add it to the segments if it's enabled.</span><span class="s3">\n    </span><span class="s1">if (includeSuffix &amp;&amp; paramMatches &amp;&amp; paramMatches[3]) {</span><span class="s3">\n      </span><span class="s1">segments.push(escapeStringRegexp(paramMatches[3]))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">parameterizedRoute: segments.join(''),</span><span class="s3">\n    </span><span class="s1">groups,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* From a normalized route this function generates a regular expression and</span><span class="s3">\n </span><span class="s1">* a corresponding groups object intended to be used to store matching groups</span><span class="s3">\n </span><span class="s1">* from the regular expression.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getRouteRegex(</span><span class="s3">\n  </span><span class="s1">normalizedRoute: string,</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">includeSuffix = false,</span><span class="s3">\n    </span><span class="s1">includePrefix = false,</span><span class="s3">\n    </span><span class="s1">excludeOptionalTrailingSlash = false,</span><span class="s3">\n  </span><span class="s1">}: GetRouteRegexOptions = {}</span><span class="s3">\n</span><span class="s1">): RouteRegex {</span><span class="s3">\n  </span><span class="s1">const { parameterizedRoute, groups } = getParametrizedRoute(</span><span class="s3">\n    </span><span class="s1">normalizedRoute,</span><span class="s3">\n    </span><span class="s1">includeSuffix,</span><span class="s3">\n    </span><span class="s1">includePrefix</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">let re = parameterizedRoute</span><span class="s3">\n  </span><span class="s1">if (!excludeOptionalTrailingSlash) {</span><span class="s3">\n    </span><span class="s1">re += '(?:/)?'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">re: new RegExp(`^${re}$`),</span><span class="s3">\n    </span><span class="s1">groups: groups,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Builds a function to generate a minimal routeKey using only a-z and minimal</span><span class="s3">\n </span><span class="s1">* number of characters.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function buildGetSafeRouteKey() {</span><span class="s3">\n  </span><span class="s1">let i = 0</span><span class="s3">\n\n  </span><span class="s1">return () =&gt; {</span><span class="s3">\n    </span><span class="s1">let routeKey = ''</span><span class="s3">\n    </span><span class="s1">let j = ++i</span><span class="s3">\n    </span><span class="s1">while (j &gt; 0) {</span><span class="s3">\n      </span><span class="s1">routeKey += String.fromCharCode(97 + ((j - 1) % 26))</span><span class="s3">\n      </span><span class="s1">j = Math.floor((j - 1) / 26)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return routeKey</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getSafeKeyFromSegment({</span><span class="s3">\n  </span><span class="s1">interceptionMarker,</span><span class="s3">\n  </span><span class="s1">getSafeRouteKey,</span><span class="s3">\n  </span><span class="s1">segment,</span><span class="s3">\n  </span><span class="s1">routeKeys,</span><span class="s3">\n  </span><span class="s1">keyPrefix,</span><span class="s3">\n  </span><span class="s1">backreferenceDuplicateKeys,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">interceptionMarker?: string</span><span class="s3">\n  </span><span class="s1">getSafeRouteKey: () =&gt; string</span><span class="s3">\n  </span><span class="s1">segment: string</span><span class="s3">\n  </span><span class="s1">routeKeys: Record&lt;string, string&gt;</span><span class="s3">\n  </span><span class="s1">keyPrefix?: string</span><span class="s3">\n  </span><span class="s1">backreferenceDuplicateKeys: boolean</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">const { key, optional, repeat } = parseMatchedParameter(segment)</span><span class="s3">\n\n  </span><span class="s1">// replace any non-word characters since they can break</span><span class="s3">\n  </span><span class="s1">// the named regex</span><span class="s3">\n  </span><span class="s1">let cleanedKey = key.replace(/</span><span class="s3">\\</span><span class="s1">W/g, '')</span><span class="s3">\n\n  </span><span class="s1">if (keyPrefix) {</span><span class="s3">\n    </span><span class="s1">cleanedKey = `${keyPrefix}${cleanedKey}`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">let invalidKey = false</span><span class="s3">\n\n  </span><span class="s1">// check if the key is still invalid and fallback to using a known</span><span class="s3">\n  </span><span class="s1">// safe key</span><span class="s3">\n  </span><span class="s1">if (cleanedKey.length === 0 || cleanedKey.length &gt; 30) {</span><span class="s3">\n    </span><span class="s1">invalidKey = true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {</span><span class="s3">\n    </span><span class="s1">invalidKey = true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (invalidKey) {</span><span class="s3">\n    </span><span class="s1">cleanedKey = getSafeRouteKey()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const duplicateKey = cleanedKey in routeKeys</span><span class="s3">\n\n  </span><span class="s1">if (keyPrefix) {</span><span class="s3">\n    </span><span class="s1">routeKeys[cleanedKey] = `${keyPrefix}${key}`</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">routeKeys[cleanedKey] = key</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// if the segment has an interception marker, make sure that's part of the regex pattern</span><span class="s3">\n  </span><span class="s1">// this is to ensure that the route with the interception marker doesn't incorrectly match</span><span class="s3">\n  </span><span class="s1">// the non-intercepted route (ie /app/(.)[username] should not match /app/[username])</span><span class="s3">\n  </span><span class="s1">const interceptionPrefix = interceptionMarker</span><span class="s3">\n    </span><span class="s1">? escapeStringRegexp(interceptionMarker)</span><span class="s3">\n    </span><span class="s1">: ''</span><span class="s3">\n\n  </span><span class="s1">let pattern: string</span><span class="s3">\n  </span><span class="s1">if (duplicateKey &amp;&amp; backreferenceDuplicateKeys) {</span><span class="s3">\n    </span><span class="s1">// Use a backreference to the key to ensure that the key is the same value</span><span class="s3">\n    </span><span class="s1">// in each of the placeholders.</span><span class="s3">\n    </span><span class="s1">pattern = `</span><span class="s3">\\\\</span><span class="s1">k&lt;${cleanedKey}&gt;`</span><span class="s3">\n  </span><span class="s1">} else if (repeat) {</span><span class="s3">\n    </span><span class="s1">pattern = `(?&lt;${cleanedKey}&gt;.+?)`</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">pattern = `(?&lt;${cleanedKey}&gt;[^/]+?)`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return optional</span><span class="s3">\n    </span><span class="s1">? `(?:/${interceptionPrefix}${pattern})?`</span><span class="s3">\n    </span><span class="s1">: `/${interceptionPrefix}${pattern}`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getNamedParametrizedRoute(</span><span class="s3">\n  </span><span class="s1">route: string,</span><span class="s3">\n  </span><span class="s1">prefixRouteKeys: boolean,</span><span class="s3">\n  </span><span class="s1">includeSuffix: boolean,</span><span class="s3">\n  </span><span class="s1">includePrefix: boolean,</span><span class="s3">\n  </span><span class="s1">backreferenceDuplicateKeys: boolean</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const getSafeRouteKey = buildGetSafeRouteKey()</span><span class="s3">\n  </span><span class="s1">const routeKeys: { [named: string]: string } = {}</span><span class="s3">\n\n  </span><span class="s1">const segments: string[] = []</span><span class="s3">\n  </span><span class="s1">for (const segment of removeTrailingSlash(route).slice(1).split('/')) {</span><span class="s3">\n    </span><span class="s1">const hasInterceptionMarker = INTERCEPTION_ROUTE_MARKERS.some((m) =&gt;</span><span class="s3">\n      </span><span class="s1">segment.startsWith(m)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">const paramMatches = segment.match(PARAMETER_PATTERN) // Check for parameters</span><span class="s3">\n\n    </span><span class="s1">if (hasInterceptionMarker &amp;&amp; paramMatches &amp;&amp; paramMatches[2]) {</span><span class="s3">\n      </span><span class="s1">// If there's an interception marker, add it to the segments.</span><span class="s3">\n      </span><span class="s1">segments.push(</span><span class="s3">\n        </span><span class="s1">getSafeKeyFromSegment({</span><span class="s3">\n          </span><span class="s1">getSafeRouteKey,</span><span class="s3">\n          </span><span class="s1">interceptionMarker: paramMatches[1],</span><span class="s3">\n          </span><span class="s1">segment: paramMatches[2],</span><span class="s3">\n          </span><span class="s1">routeKeys,</span><span class="s3">\n          </span><span class="s1">keyPrefix: prefixRouteKeys</span><span class="s3">\n            </span><span class="s1">? NEXT_INTERCEPTION_MARKER_PREFIX</span><span class="s3">\n            </span><span class="s1">: undefined,</span><span class="s3">\n          </span><span class="s1">backreferenceDuplicateKeys,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else if (paramMatches &amp;&amp; paramMatches[2]) {</span><span class="s3">\n      </span><span class="s1">// If there's a prefix, add it to the segments if it's enabled.</span><span class="s3">\n      </span><span class="s1">if (includePrefix &amp;&amp; paramMatches[1]) {</span><span class="s3">\n        </span><span class="s1">segments.push(`/${escapeStringRegexp(paramMatches[1])}`)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">let s = getSafeKeyFromSegment({</span><span class="s3">\n        </span><span class="s1">getSafeRouteKey,</span><span class="s3">\n        </span><span class="s1">segment: paramMatches[2],</span><span class="s3">\n        </span><span class="s1">routeKeys,</span><span class="s3">\n        </span><span class="s1">keyPrefix: prefixRouteKeys ? NEXT_QUERY_PARAM_PREFIX : undefined,</span><span class="s3">\n        </span><span class="s1">backreferenceDuplicateKeys,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n\n      </span><span class="s1">// Remove the leading slash if includePrefix already added it.</span><span class="s3">\n      </span><span class="s1">if (includePrefix &amp;&amp; paramMatches[1]) {</span><span class="s3">\n        </span><span class="s1">s = s.substring(1)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">segments.push(s)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">segments.push(`/${escapeStringRegexp(segment)}`)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If there's a suffix, add it to the segments if it's enabled.</span><span class="s3">\n    </span><span class="s1">if (includeSuffix &amp;&amp; paramMatches &amp;&amp; paramMatches[3]) {</span><span class="s3">\n      </span><span class="s1">segments.push(escapeStringRegexp(paramMatches[3]))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">namedParameterizedRoute: segments.join(''),</span><span class="s3">\n    </span><span class="s1">routeKeys,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This function extends `getRouteRegex` generating also a named regexp where</span><span class="s3">\n </span><span class="s1">* each group is named along with a routeKeys object that indexes the assigned</span><span class="s3">\n </span><span class="s1">* named group with its corresponding key. When the routeKeys need to be</span><span class="s3">\n </span><span class="s1">* prefixed to uniquely identify internally the </span><span class="s3">\&quot;</span><span class="s1">prefixRouteKey</span><span class="s3">\&quot; </span><span class="s1">arg should</span><span class="s3">\n </span><span class="s1">* be </span><span class="s3">\&quot;</span><span class="s1">true</span><span class="s3">\&quot; </span><span class="s1">currently this is only the case when creating the routes-manifest</span><span class="s3">\n </span><span class="s1">* during the build</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getNamedRouteRegex(</span><span class="s3">\n  </span><span class="s1">normalizedRoute: string,</span><span class="s3">\n  </span><span class="s1">options: GetNamedRouteRegexOptions</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const result = getNamedParametrizedRoute(</span><span class="s3">\n    </span><span class="s1">normalizedRoute,</span><span class="s3">\n    </span><span class="s1">options.prefixRouteKeys,</span><span class="s3">\n    </span><span class="s1">options.includeSuffix ?? false,</span><span class="s3">\n    </span><span class="s1">options.includePrefix ?? false,</span><span class="s3">\n    </span><span class="s1">options.backreferenceDuplicateKeys ?? false</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">let namedRegex = result.namedParameterizedRoute</span><span class="s3">\n  </span><span class="s1">if (!options.excludeOptionalTrailingSlash) {</span><span class="s3">\n    </span><span class="s1">namedRegex += '(?:/)?'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">...getRouteRegex(normalizedRoute, options),</span><span class="s3">\n    </span><span class="s1">namedRegex: `^${namedRegex}$`,</span><span class="s3">\n    </span><span class="s1">routeKeys: result.routeKeys,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Generates a named regexp.</span><span class="s3">\n </span><span class="s1">* This is intended to be using for build time only.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getNamedMiddlewareRegex(</span><span class="s3">\n  </span><span class="s1">normalizedRoute: string,</span><span class="s3">\n  </span><span class="s1">options: {</span><span class="s3">\n    </span><span class="s1">catchAll?: boolean</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const { parameterizedRoute } = getParametrizedRoute(</span><span class="s3">\n    </span><span class="s1">normalizedRoute,</span><span class="s3">\n    </span><span class="s1">false,</span><span class="s3">\n    </span><span class="s1">false</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">const { catchAll = true } = options</span><span class="s3">\n  </span><span class="s1">if (parameterizedRoute === '/') {</span><span class="s3">\n    </span><span class="s1">let catchAllRegex = catchAll ? '.*' : ''</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">namedRegex: `^/${catchAllRegex}$`,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { namedParameterizedRoute } = getNamedParametrizedRoute(</span><span class="s3">\n    </span><span class="s1">normalizedRoute,</span><span class="s3">\n    </span><span class="s1">false,</span><span class="s3">\n    </span><span class="s1">false,</span><span class="s3">\n    </span><span class="s1">false,</span><span class="s3">\n    </span><span class="s1">false</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">let catchAllGroupedRegex = catchAll ? '(?:(/.*)?)' : ''</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">namedRegex: `^${namedParameterizedRoute}${catchAllGroupedRegex}$`,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { HtmlProps } from './html-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import type { ComponentType, JSX } from 'react'</span><span class="s3">\n</span><span class="s1">import type { DomainLocale } from '../../server/config'</span><span class="s3">\n</span><span class="s1">import type { Env } from '@next/env'</span><span class="s3">\n</span><span class="s1">import type { IncomingMessage, ServerResponse } from 'http'</span><span class="s3">\n</span><span class="s1">import type { NextRouter } from './router/router'</span><span class="s3">\n</span><span class="s1">import type { ParsedUrlQuery } from 'querystring'</span><span class="s3">\n</span><span class="s1">import type { PreviewData } from '../../types'</span><span class="s3">\n</span><span class="s1">import type { COMPILER_NAMES } from './constants'</span><span class="s3">\n</span><span class="s1">import type fs from 'fs'</span><span class="s3">\n\n</span><span class="s1">export type NextComponentType&lt;</span><span class="s3">\n  </span><span class="s1">Context extends BaseContext = NextPageContext,</span><span class="s3">\n  </span><span class="s1">InitialProps = {},</span><span class="s3">\n  </span><span class="s1">Props = {},</span><span class="s3">\n</span><span class="s1">&gt; = ComponentType&lt;Props&gt; &amp; {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Used for initial page load data population. Data returned from `getInitialProps` is serialized when server rendered.</span><span class="s3">\n   </span><span class="s1">* Make sure to return plain `Object` without using `Date`, `Map`, `Set`.</span><span class="s3">\n   </span><span class="s1">* @param context Context of `page`</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getInitialProps?(context: Context): InitialProps | Promise&lt;InitialProps&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type DocumentType = NextComponentType&lt;</span><span class="s3">\n  </span><span class="s1">DocumentContext,</span><span class="s3">\n  </span><span class="s1">DocumentInitialProps,</span><span class="s3">\n  </span><span class="s1">DocumentProps</span><span class="s3">\n</span><span class="s1">&gt;</span><span class="s3">\n\n</span><span class="s1">export type AppType&lt;P = {}&gt; = NextComponentType&lt;</span><span class="s3">\n  </span><span class="s1">AppContextType,</span><span class="s3">\n  </span><span class="s1">P,</span><span class="s3">\n  </span><span class="s1">AppPropsType&lt;any, P&gt;</span><span class="s3">\n</span><span class="s1">&gt;</span><span class="s3">\n\n</span><span class="s1">export type AppTreeType = ComponentType&lt;</span><span class="s3">\n  </span><span class="s1">AppInitialProps &amp; { [name: string]: any }</span><span class="s3">\n</span><span class="s1">&gt;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Web vitals provided to _app.reportWebVitals by Core Web Vitals plugin developed by Google Chrome team.</span><span class="s3">\n </span><span class="s1">* https://nextjs.org/blog/next-9-4#integrated-web-vitals-reporting</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const WEB_VITALS = ['CLS', 'FCP', 'FID', 'INP', 'LCP', 'TTFB'] as const</span><span class="s3">\n</span><span class="s1">export type NextWebVitalsMetric = {</span><span class="s3">\n  </span><span class="s1">id: string</span><span class="s3">\n  </span><span class="s1">startTime: number</span><span class="s3">\n  </span><span class="s1">value: number</span><span class="s3">\n  </span><span class="s1">attribution?: { [key: string]: unknown }</span><span class="s3">\n</span><span class="s1">} &amp; (</span><span class="s3">\n  </span><span class="s1">| {</span><span class="s3">\n      </span><span class="s1">label: 'web-vital'</span><span class="s3">\n      </span><span class="s1">name: (typeof WEB_VITALS)[number]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">| {</span><span class="s3">\n      </span><span class="s1">label: 'custom'</span><span class="s3">\n      </span><span class="s1">name:</span><span class="s3">\n        </span><span class="s1">| 'Next.js-hydration'</span><span class="s3">\n        </span><span class="s1">| 'Next.js-route-change-to-render'</span><span class="s3">\n        </span><span class="s1">| 'Next.js-render'</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n\n</span><span class="s1">export type Enhancer&lt;C&gt; = (Component: C) =&gt; C</span><span class="s3">\n\n</span><span class="s1">export type ComponentsEnhancer =</span><span class="s3">\n  </span><span class="s1">| {</span><span class="s3">\n      </span><span class="s1">enhanceApp?: Enhancer&lt;AppType&gt;</span><span class="s3">\n      </span><span class="s1">enhanceComponent?: Enhancer&lt;NextComponentType&gt;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">| Enhancer&lt;NextComponentType&gt;</span><span class="s3">\n\n</span><span class="s1">export type RenderPageResult = {</span><span class="s3">\n  </span><span class="s1">html: string</span><span class="s3">\n  </span><span class="s1">head?: Array&lt;JSX.Element | null&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type RenderPage = (</span><span class="s3">\n  </span><span class="s1">options?: ComponentsEnhancer</span><span class="s3">\n</span><span class="s1">) =&gt; DocumentInitialProps | Promise&lt;DocumentInitialProps&gt;</span><span class="s3">\n\n</span><span class="s1">export type BaseContext = {</span><span class="s3">\n  </span><span class="s1">res?: ServerResponse</span><span class="s3">\n  </span><span class="s1">[k: string]: any</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type NEXT_DATA = {</span><span class="s3">\n  </span><span class="s1">props: Record&lt;string, any&gt;</span><span class="s3">\n  </span><span class="s1">page: string</span><span class="s3">\n  </span><span class="s1">query: ParsedUrlQuery</span><span class="s3">\n  </span><span class="s1">buildId: string</span><span class="s3">\n  </span><span class="s1">assetPrefix?: string</span><span class="s3">\n  </span><span class="s1">runtimeConfig?: { [key: string]: any }</span><span class="s3">\n  </span><span class="s1">nextExport?: boolean</span><span class="s3">\n  </span><span class="s1">autoExport?: boolean</span><span class="s3">\n  </span><span class="s1">isFallback?: boolean</span><span class="s3">\n  </span><span class="s1">isExperimentalCompile?: boolean</span><span class="s3">\n  </span><span class="s1">dynamicIds?: (string | number)[]</span><span class="s3">\n  </span><span class="s1">err?: Error &amp; {</span><span class="s3">\n    </span><span class="s1">statusCode?: number</span><span class="s3">\n    </span><span class="s1">source?: typeof COMPILER_NAMES.server | typeof COMPILER_NAMES.edgeServer</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">gsp?: boolean</span><span class="s3">\n  </span><span class="s1">gssp?: boolean</span><span class="s3">\n  </span><span class="s1">customServer?: boolean</span><span class="s3">\n  </span><span class="s1">gip?: boolean</span><span class="s3">\n  </span><span class="s1">appGip?: boolean</span><span class="s3">\n  </span><span class="s1">locale?: string</span><span class="s3">\n  </span><span class="s1">locales?: readonly string[]</span><span class="s3">\n  </span><span class="s1">defaultLocale?: string</span><span class="s3">\n  </span><span class="s1">domainLocales?: readonly DomainLocale[]</span><span class="s3">\n  </span><span class="s1">scriptLoader?: any[]</span><span class="s3">\n  </span><span class="s1">isPreview?: boolean</span><span class="s3">\n  </span><span class="s1">notFoundSrcPage?: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* `Next` context</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export interface NextPageContext {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Error object if encountered during rendering</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">err?: (Error &amp; { statusCode?: number }) | null</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `HTTP` request object.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">req?: IncomingMessage</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `HTTP` response object.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">res?: ServerResponse</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Path section of `URL`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">pathname: string</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Query string section of `URL` parsed as an object.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">query: ParsedUrlQuery</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `String` of the actual path including query.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">asPath?: string</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The currently active locale</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">locale?: string</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* All configured locales</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">locales?: readonly string[]</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The configured default locale</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">defaultLocale?: string</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `Component` the tree of the App to use if needing to render separately</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">AppTree: AppTreeType</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type AppContextType&lt;Router extends NextRouter = NextRouter&gt; = {</span><span class="s3">\n  </span><span class="s1">Component: NextComponentType&lt;NextPageContext&gt;</span><span class="s3">\n  </span><span class="s1">AppTree: AppTreeType</span><span class="s3">\n  </span><span class="s1">ctx: NextPageContext</span><span class="s3">\n  </span><span class="s1">router: Router</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type AppInitialProps&lt;PageProps = any&gt; = {</span><span class="s3">\n  </span><span class="s1">pageProps: PageProps</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type AppPropsType&lt;</span><span class="s3">\n  </span><span class="s1">Router extends NextRouter = NextRouter,</span><span class="s3">\n  </span><span class="s1">PageProps = {},</span><span class="s3">\n</span><span class="s1">&gt; = AppInitialProps&lt;PageProps&gt; &amp; {</span><span class="s3">\n  </span><span class="s1">Component: NextComponentType&lt;NextPageContext, any, any&gt;</span><span class="s3">\n  </span><span class="s1">router: Router</span><span class="s3">\n  </span><span class="s1">__N_SSG?: boolean</span><span class="s3">\n  </span><span class="s1">__N_SSP?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type DocumentContext = NextPageContext &amp; {</span><span class="s3">\n  </span><span class="s1">renderPage: RenderPage</span><span class="s3">\n  </span><span class="s1">defaultGetInitialProps(</span><span class="s3">\n    </span><span class="s1">ctx: DocumentContext,</span><span class="s3">\n    </span><span class="s1">options?: { nonce?: string }</span><span class="s3">\n  </span><span class="s1">): Promise&lt;DocumentInitialProps&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type DocumentInitialProps = RenderPageResult &amp; {</span><span class="s3">\n  </span><span class="s1">styles?: React.ReactElement[] | Iterable&lt;React.ReactNode&gt; | JSX.Element</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type DocumentProps = DocumentInitialProps &amp; HtmlProps</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Next `API` route request</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export interface NextApiRequest extends IncomingMessage {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Object of `query` values from url</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">query: Partial&lt;{</span><span class="s3">\n    </span><span class="s1">[key: string]: string | string[]</span><span class="s3">\n  </span><span class="s1">}&gt;</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Object of `cookies` from header</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">cookies: Partial&lt;{</span><span class="s3">\n    </span><span class="s1">[key: string]: string</span><span class="s3">\n  </span><span class="s1">}&gt;</span><span class="s3">\n\n  </span><span class="s1">body: any</span><span class="s3">\n\n  </span><span class="s1">env: Env</span><span class="s3">\n\n  </span><span class="s1">draftMode?: boolean</span><span class="s3">\n\n  </span><span class="s1">preview?: boolean</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Preview data set on the request, if any</span><span class="s3">\n   </span><span class="s1">* */</span><span class="s3">\n  </span><span class="s1">previewData?: PreviewData</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Send body of response</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">type Send&lt;T&gt; = (body: T) =&gt; void</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Next `API` route response</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type NextApiResponse&lt;Data = any&gt; = ServerResponse &amp; {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Send data `any` data in response</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">send: Send&lt;Data&gt;</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Send data `json` data in response</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">json: Send&lt;Data&gt;</span><span class="s3">\n  </span><span class="s1">status: (statusCode: number) =&gt; NextApiResponse&lt;Data&gt;</span><span class="s3">\n  </span><span class="s1">redirect(url: string): NextApiResponse&lt;Data&gt;</span><span class="s3">\n  </span><span class="s1">redirect(status: number, url: string): NextApiResponse&lt;Data&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Set draft mode</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">setDraftMode: (options: { enable: boolean }) =&gt; NextApiResponse&lt;Data&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Set preview data for Next.js' prerender mode</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">setPreviewData: (</span><span class="s3">\n    </span><span class="s1">data: object | string,</span><span class="s3">\n    </span><span class="s1">options?: {</span><span class="s3">\n      </span><span class="s1">/**</span><span class="s3">\n       </span><span class="s1">* Specifies the number (in seconds) for the preview session to last for.</span><span class="s3">\n       </span><span class="s1">* The given number will be converted to an integer by rounding down.</span><span class="s3">\n       </span><span class="s1">* By default, no maximum age is set and the preview session finishes</span><span class="s3">\n       </span><span class="s1">* when the client shuts down (browser is closed).</span><span class="s3">\n       </span><span class="s1">*/</span><span class="s3">\n      </span><span class="s1">maxAge?: number</span><span class="s3">\n      </span><span class="s1">/**</span><span class="s3">\n       </span><span class="s1">* Specifies the path for the preview session to work under. By default,</span><span class="s3">\n       </span><span class="s1">* the path is considered the </span><span class="s3">\&quot;</span><span class="s1">default path</span><span class="s3">\&quot;</span><span class="s1">, i.e., any pages under </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n       </span><span class="s1">*/</span><span class="s3">\n      </span><span class="s1">path?: string</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">) =&gt; NextApiResponse&lt;Data&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Clear preview data for Next.js' prerender mode</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">clearPreviewData: (options?: { path?: string }) =&gt; NextApiResponse&lt;Data&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Revalidate a specific page and regenerate it using On-Demand Incremental</span><span class="s3">\n   </span><span class="s1">* Static Regeneration.</span><span class="s3">\n   </span><span class="s1">* The path should be an actual path, not a rewritten path. E.g. for</span><span class="s3">\n   </span><span class="s1">* </span><span class="s3">\&quot;</span><span class="s1">/blog/[slug]</span><span class="s3">\&quot; </span><span class="s1">this should be </span><span class="s3">\&quot;</span><span class="s1">/blog/post-1</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n   </span><span class="s1">* @link https://nextjs.org/docs/app/building-your-application/data-fetching/incremental-static-regeneration#on-demand-revalidation-with-revalidatepath</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">revalidate: (</span><span class="s3">\n    </span><span class="s1">urlPath: string,</span><span class="s3">\n    </span><span class="s1">opts?: {</span><span class="s3">\n      </span><span class="s1">unstable_onlyGenerated?: boolean</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">) =&gt; Promise&lt;void&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Next `API` route handler</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type NextApiHandler&lt;T = any&gt; = (</span><span class="s3">\n  </span><span class="s1">req: NextApiRequest,</span><span class="s3">\n  </span><span class="s1">res: NextApiResponse&lt;T&gt;</span><span class="s3">\n</span><span class="s1">) =&gt; unknown | Promise&lt;unknown&gt;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Utils</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function execOnce&lt;T extends (...args: any[]) =&gt; ReturnType&lt;T&gt;&gt;(</span><span class="s3">\n  </span><span class="s1">fn: T</span><span class="s3">\n</span><span class="s1">): T {</span><span class="s3">\n  </span><span class="s1">let used = false</span><span class="s3">\n  </span><span class="s1">let result: ReturnType&lt;T&gt;</span><span class="s3">\n\n  </span><span class="s1">return ((...args: any[]) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (!used) {</span><span class="s3">\n      </span><span class="s1">used = true</span><span class="s3">\n      </span><span class="s1">result = fn(...args)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return result</span><span class="s3">\n  </span><span class="s1">}) as T</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1</span><span class="s3">\n</span><span class="s1">// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3</span><span class="s3">\n</span><span class="s1">const ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z</span><span class="s3">\\</span><span class="s1">d+</span><span class="s3">\\</span><span class="s1">-.]*?:/</span><span class="s3">\n</span><span class="s1">export const isAbsoluteUrl = (url: string) =&gt; ABSOLUTE_URL_REGEX.test(url)</span><span class="s3">\n\n</span><span class="s1">export function getLocationOrigin() {</span><span class="s3">\n  </span><span class="s1">const { protocol, hostname, port } = window.location</span><span class="s3">\n  </span><span class="s1">return `${protocol}//${hostname}${port ? ':' + port : ''}`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getURL() {</span><span class="s3">\n  </span><span class="s1">const { href } = window.location</span><span class="s3">\n  </span><span class="s1">const origin = getLocationOrigin()</span><span class="s3">\n  </span><span class="s1">return href.substring(origin.length)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getDisplayName&lt;P&gt;(Component: ComponentType&lt;P&gt;) {</span><span class="s3">\n  </span><span class="s1">return typeof Component === 'string'</span><span class="s3">\n    </span><span class="s1">? Component</span><span class="s3">\n    </span><span class="s1">: Component.displayName || Component.name || 'Unknown'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isResSent(res: ServerResponse) {</span><span class="s3">\n  </span><span class="s1">return res.finished || res.headersSent</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function normalizeRepeatedSlashes(url: string) {</span><span class="s3">\n  </span><span class="s1">const urlParts = url.split('?')</span><span class="s3">\n  </span><span class="s1">const urlNoQuery = urlParts[0]</span><span class="s3">\n\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">urlNoQuery</span><span class="s3">\n      </span><span class="s1">// first we replace any non-encoded backslashes with forward</span><span class="s3">\n      </span><span class="s1">// then normalize repeated forward slashes</span><span class="s3">\n      </span><span class="s1">.replace(/</span><span class="s3">\\\\</span><span class="s1">/g, '/')</span><span class="s3">\n      </span><span class="s1">.replace(/</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">/+/g, '/') +</span><span class="s3">\n    </span><span class="s1">(urlParts[1] ? `?${urlParts.slice(1).join('?')}` : '')</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function loadGetInitialProps&lt;</span><span class="s3">\n  </span><span class="s1">C extends BaseContext,</span><span class="s3">\n  </span><span class="s1">IP = {},</span><span class="s3">\n  </span><span class="s1">P = {},</span><span class="s3">\n</span><span class="s1">&gt;(App: NextComponentType&lt;C, IP, P&gt;, ctx: C): Promise&lt;IP&gt; {</span><span class="s3">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n    </span><span class="s1">if (App.prototype?.getInitialProps) {</span><span class="s3">\n      </span><span class="s1">const message = `</span><span class="s3">\&quot;</span><span class="s1">${getDisplayName(</span><span class="s3">\n        </span><span class="s1">App</span><span class="s3">\n      </span><span class="s1">)}.getInitialProps()</span><span class="s3">\&quot; </span><span class="s1">is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.`</span><span class="s3">\n      </span><span class="s1">throw new Error(message)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// when called from _app `ctx` is nested in `ctx`</span><span class="s3">\n  </span><span class="s1">const res = ctx.res || (ctx.ctx &amp;&amp; ctx.ctx.res)</span><span class="s3">\n\n  </span><span class="s1">if (!App.getInitialProps) {</span><span class="s3">\n    </span><span class="s1">if (ctx.ctx &amp;&amp; ctx.Component) {</span><span class="s3">\n      </span><span class="s1">// @ts-ignore pageProps default</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx),</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return {} as IP</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const props = await App.getInitialProps(ctx)</span><span class="s3">\n\n  </span><span class="s1">if (res &amp;&amp; isResSent(res)) {</span><span class="s3">\n    </span><span class="s1">return props</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!props) {</span><span class="s3">\n    </span><span class="s1">const message = `</span><span class="s3">\&quot;</span><span class="s1">${getDisplayName(</span><span class="s3">\n      </span><span class="s1">App</span><span class="s3">\n    </span><span class="s1">)}.getInitialProps()</span><span class="s3">\&quot; </span><span class="s1">should resolve to an object. But found </span><span class="s3">\&quot;</span><span class="s1">${props}</span><span class="s3">\&quot; </span><span class="s1">instead.`</span><span class="s3">\n    </span><span class="s1">throw new Error(message)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n    </span><span class="s1">if (Object.keys(props).length === 0 &amp;&amp; !ctx.ctx) {</span><span class="s3">\n      </span><span class="s1">console.warn(</span><span class="s3">\n        </span><span class="s1">`${getDisplayName(</span><span class="s3">\n          </span><span class="s1">App</span><span class="s3">\n        </span><span class="s1">)} returned an empty object from </span><span class="s3">\\</span><span class="s1">`getInitialProps</span><span class="s3">\\</span><span class="s1">`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return props</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const SP = typeof performance !== 'undefined'</span><span class="s3">\n</span><span class="s1">export const ST =</span><span class="s3">\n  </span><span class="s1">SP &amp;&amp;</span><span class="s3">\n  </span><span class="s1">(['mark', 'measure', 'getEntriesByName'] as const).every(</span><span class="s3">\n    </span><span class="s1">(method) =&gt; typeof performance[method] === 'function'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n</span><span class="s1">export class DecodeError extends Error {}</span><span class="s3">\n</span><span class="s1">export class NormalizeError extends Error {}</span><span class="s3">\n</span><span class="s1">export class PageNotFoundError extends Error {</span><span class="s3">\n  </span><span class="s1">code: string</span><span class="s3">\n\n  </span><span class="s1">constructor(page: string) {</span><span class="s3">\n    </span><span class="s1">super()</span><span class="s3">\n    </span><span class="s1">this.code = 'ENOENT'</span><span class="s3">\n    </span><span class="s1">this.name = 'PageNotFoundError'</span><span class="s3">\n    </span><span class="s1">this.message = `Cannot find module for page: ${page}`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class MissingStaticPage extends Error {</span><span class="s3">\n  </span><span class="s1">constructor(page: string, message: string) {</span><span class="s3">\n    </span><span class="s1">super()</span><span class="s3">\n    </span><span class="s1">this.message = `Failed to load static file for page: ${page} ${message}`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class MiddlewareNotFoundError extends Error {</span><span class="s3">\n  </span><span class="s1">code: string</span><span class="s3">\n  </span><span class="s1">constructor() {</span><span class="s3">\n    </span><span class="s1">super()</span><span class="s3">\n    </span><span class="s1">this.code = 'ENOENT'</span><span class="s3">\n    </span><span class="s1">this.message = `Cannot find the middleware module`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface CacheFs {</span><span class="s3">\n  </span><span class="s1">existsSync: typeof fs.existsSync</span><span class="s3">\n  </span><span class="s1">readFile: typeof fs.promises.readFile</span><span class="s3">\n  </span><span class="s1">readFileSync: typeof fs.readFileSync</span><span class="s3">\n  </span><span class="s1">writeFile(f: string, d: any): Promise&lt;void&gt;</span><span class="s3">\n  </span><span class="s1">mkdir(dir: string): Promise&lt;void | string&gt;</span><span class="s3">\n  </span><span class="s1">stat(f: string): Promise&lt;{ mtime: Date }&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function stringifyError(error: Error) {</span><span class="s3">\n  </span><span class="s1">return JSON.stringify({ message: error.message, stack: error.stack })</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { Token } from 'next/dist/compiled/path-to-regexp'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Route pattern normalization utilities for path-to-regexp compatibility.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* path-to-regexp 6.3.0+ introduced stricter validation that rejects certain</span><span class="s3">\n </span><span class="s1">* patterns commonly used in Next.js interception routes. This module provides</span><span class="s3">\n </span><span class="s1">* normalization functions to make Next.js route patterns compatible with the</span><span class="s3">\n </span><span class="s1">* updated library while preserving all functionality.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Internal separator used to normalize adjacent parameter patterns.</span><span class="s3">\n </span><span class="s1">* This unique marker is inserted between adjacent parameters and stripped out</span><span class="s3">\n </span><span class="s1">* during parameter extraction to avoid conflicts with real URL content.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const PARAM_SEPARATOR = '_NEXTSEP_'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Detects if a route pattern needs normalization for path-to-regexp compatibility.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function hasAdjacentParameterIssues(route: string): boolean {</span><span class="s3">\n  </span><span class="s1">if (typeof route !== 'string') return false</span><span class="s3">\n\n  </span><span class="s1">// Check for interception route markers followed immediately by parameters</span><span class="s3">\n  </span><span class="s1">// Pattern: /(.):param, /(..):param, /(...):param, /(.)(.):param etc.</span><span class="s3">\n  </span><span class="s1">// These patterns cause </span><span class="s3">\&quot;</span><span class="s1">Must have text between two parameters</span><span class="s3">\&quot; </span><span class="s1">errors</span><span class="s3">\n  </span><span class="s1">if (/</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">(</span><span class="s3">\\</span><span class="s1">.{1,3}</span><span class="s3">\\</span><span class="s1">):[^/</span><span class="s3">\\</span><span class="s1">s]+/.test(route)) {</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Check for basic adjacent parameters without separators</span><span class="s3">\n  </span><span class="s1">// Pattern: :param1:param2 (but not :param* or other URL patterns)</span><span class="s3">\n  </span><span class="s1">if (/:[a-zA-Z_][a-zA-Z0-9_]*:[a-zA-Z_][a-zA-Z0-9_]*/.test(route)) {</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return false</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Normalizes route patterns that have adjacent parameters without text between them.</span><span class="s3">\n </span><span class="s1">* Inserts a unique separator that can be safely stripped out later.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function normalizeAdjacentParameters(route: string): string {</span><span class="s3">\n  </span><span class="s1">let normalized = route</span><span class="s3">\n\n  </span><span class="s1">// Handle interception route patterns: (.):param -&gt; (.)_NEXTSEP_:param</span><span class="s3">\n  </span><span class="s1">normalized = normalized.replace(</span><span class="s3">\n    </span><span class="s1">/(</span><span class="s3">\\</span><span class="s1">([^)]*</span><span class="s3">\\</span><span class="s1">)):([^/</span><span class="s3">\\</span><span class="s1">s]+)/g,</span><span class="s3">\n    </span><span class="s1">`$1${PARAM_SEPARATOR}:$2`</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">// Handle other adjacent parameter patterns: :param1:param2 -&gt; :param1_NEXTSEP_:param2</span><span class="s3">\n  </span><span class="s1">normalized = normalized.replace(/:([^:/</span><span class="s3">\\</span><span class="s1">s)]+)(?=:)/g, `:$1${PARAM_SEPARATOR}`)</span><span class="s3">\n\n  </span><span class="s1">return normalized</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Normalizes tokens that have repeating modifiers (* or +) but empty prefix and suffix.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* path-to-regexp 6.3.0+ introduced validation that throws:</span><span class="s3">\n </span><span class="s1">* </span><span class="s3">\&quot;</span><span class="s1">Can not repeat without prefix/suffix</span><span class="s3">\&quot;\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This occurs when a token has modifier: '*' or '+' with both prefix: '' and suffix: ''</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function normalizeTokensForRegexp(tokens: Token[]): Token[] {</span><span class="s3">\n  </span><span class="s1">return tokens.map((token) =&gt; {</span><span class="s3">\n    </span><span class="s1">// Token union type: Token = string | TokenObject</span><span class="s3">\n    </span><span class="s1">// Literal path segments are strings, parameters/wildcards are objects</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">typeof token === 'object' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">token !== null &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// Not all token objects have 'modifier' property (e.g., simple text tokens)</span><span class="s3">\n      </span><span class="s1">'modifier' in token &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// Only repeating modifiers (* or +) cause the validation error</span><span class="s3">\n      </span><span class="s1">// Other modifiers like '?' (optional) are fine</span><span class="s3">\n      </span><span class="s1">(token.modifier === '*' || token.modifier === '+') &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// Token objects can have different shapes depending on route pattern</span><span class="s3">\n      </span><span class="s1">'prefix' in token &amp;&amp;</span><span class="s3">\n      </span><span class="s1">'suffix' in token &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// Both prefix and suffix must be empty strings</span><span class="s3">\n      </span><span class="s1">// This is what causes the validation error in path-to-regexp</span><span class="s3">\n      </span><span class="s1">token.prefix === '' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">token.suffix === ''</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// Add minimal prefix to satisfy path-to-regexp validation</span><span class="s3">\n      </span><span class="s1">// We use '/' as it's the most common path delimiter and won't break route matching</span><span class="s3">\n      </span><span class="s1">// The prefix gets used in regex generation but doesn't affect parameter extraction</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">...token,</span><span class="s3">\n        </span><span class="s1">prefix: '/',</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return token</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Strips normalization separators from extracted route parameters.</span><span class="s3">\n </span><span class="s1">* Used by both server and client code to clean up parameters after route matching.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function stripParameterSeparators(</span><span class="s3">\n  </span><span class="s1">params: Record&lt;string, any&gt;</span><span class="s3">\n</span><span class="s1">): Record&lt;string, any&gt; {</span><span class="s3">\n  </span><span class="s1">const cleaned: Record&lt;string, any&gt; = {}</span><span class="s3">\n\n  </span><span class="s1">for (const [key, value] of Object.entries(params)) {</span><span class="s3">\n    </span><span class="s1">if (typeof value === 'string') {</span><span class="s3">\n      </span><span class="s1">// Remove the separator if it appears at the start of parameter values</span><span class="s3">\n      </span><span class="s1">cleaned[key] = value.replace(new RegExp(`^${PARAM_SEPARATOR}`), '')</span><span class="s3">\n    </span><span class="s1">} else if (Array.isArray(value)) {</span><span class="s3">\n      </span><span class="s1">// Handle array parameters (from repeated route segments)</span><span class="s3">\n      </span><span class="s1">cleaned[key] = value.map((item) =&gt;</span><span class="s3">\n        </span><span class="s1">typeof item === 'string'</span><span class="s3">\n          </span><span class="s1">? item.replace(new RegExp(`^${PARAM_SEPARATOR}`), '')</span><span class="s3">\n          </span><span class="s1">: item</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">cleaned[key] = value</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return cleaned</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Client-safe utilities for route matching that don't import server-side</span><span class="s3">\n </span><span class="s1">* utilities to avoid bundling issues with Turbopack</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">Key,</span><span class="s3">\n  </span><span class="s1">TokensToRegexpOptions,</span><span class="s3">\n  </span><span class="s1">ParseOptions,</span><span class="s3">\n  </span><span class="s1">TokensToFunctionOptions,</span><span class="s3">\n</span><span class="s1">} from 'next/dist/compiled/path-to-regexp'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">pathToRegexp,</span><span class="s3">\n  </span><span class="s1">compile,</span><span class="s3">\n  </span><span class="s1">regexpToFunction,</span><span class="s3">\n</span><span class="s1">} from 'next/dist/compiled/path-to-regexp'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">hasAdjacentParameterIssues,</span><span class="s3">\n  </span><span class="s1">normalizeAdjacentParameters,</span><span class="s3">\n  </span><span class="s1">stripParameterSeparators,</span><span class="s3">\n</span><span class="s1">} from '../../../../lib/route-pattern-normalizer'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Client-safe wrapper around pathToRegexp that handles path-to-regexp 6.3.0+ validation errors.</span><span class="s3">\n </span><span class="s1">* This includes both </span><span class="s3">\&quot;</span><span class="s1">Can not repeat without prefix/suffix</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">Must have text between parameters</span><span class="s3">\&quot; </span><span class="s1">errors.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function safePathToRegexp(</span><span class="s3">\n  </span><span class="s1">route: string | RegExp | Array&lt;string | RegExp&gt;,</span><span class="s3">\n  </span><span class="s1">keys?: Key[],</span><span class="s3">\n  </span><span class="s1">options?: TokensToRegexpOptions &amp; ParseOptions</span><span class="s3">\n</span><span class="s1">): RegExp {</span><span class="s3">\n  </span><span class="s1">if (typeof route !== 'string') {</span><span class="s3">\n    </span><span class="s1">return pathToRegexp(route, keys, options)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Check if normalization is needed and cache the result</span><span class="s3">\n  </span><span class="s1">const needsNormalization = hasAdjacentParameterIssues(route)</span><span class="s3">\n  </span><span class="s1">const routeToUse = needsNormalization</span><span class="s3">\n    </span><span class="s1">? normalizeAdjacentParameters(route)</span><span class="s3">\n    </span><span class="s1">: route</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">return pathToRegexp(routeToUse, keys, options)</span><span class="s3">\n  </span><span class="s1">} catch (error) {</span><span class="s3">\n    </span><span class="s1">// Only try normalization if we haven't already normalized</span><span class="s3">\n    </span><span class="s1">if (!needsNormalization) {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">const normalizedRoute = normalizeAdjacentParameters(route)</span><span class="s3">\n        </span><span class="s1">return pathToRegexp(normalizedRoute, keys, options)</span><span class="s3">\n      </span><span class="s1">} catch (retryError) {</span><span class="s3">\n        </span><span class="s1">// If that doesn't work, fall back to original error</span><span class="s3">\n        </span><span class="s1">throw error</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">throw error</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Client-safe wrapper around compile that handles path-to-regexp 6.3.0+ validation errors.</span><span class="s3">\n </span><span class="s1">* No server-side error reporting to avoid bundling issues.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function safeCompile(</span><span class="s3">\n  </span><span class="s1">route: string,</span><span class="s3">\n  </span><span class="s1">options?: TokensToFunctionOptions &amp; ParseOptions</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// Check if normalization is needed and cache the result</span><span class="s3">\n  </span><span class="s1">const needsNormalization = hasAdjacentParameterIssues(route)</span><span class="s3">\n  </span><span class="s1">const routeToUse = needsNormalization</span><span class="s3">\n    </span><span class="s1">? normalizeAdjacentParameters(route)</span><span class="s3">\n    </span><span class="s1">: route</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">return compile(routeToUse, options)</span><span class="s3">\n  </span><span class="s1">} catch (error) {</span><span class="s3">\n    </span><span class="s1">// Only try normalization if we haven't already normalized</span><span class="s3">\n    </span><span class="s1">if (!needsNormalization) {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">const normalizedRoute = normalizeAdjacentParameters(route)</span><span class="s3">\n        </span><span class="s1">return compile(normalizedRoute, options)</span><span class="s3">\n      </span><span class="s1">} catch (retryError) {</span><span class="s3">\n        </span><span class="s1">// If that doesn't work, fall back to original error</span><span class="s3">\n        </span><span class="s1">throw error</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">throw error</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Client-safe wrapper around regexpToFunction that automatically cleans parameters.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function safeRegexpToFunction&lt;</span><span class="s3">\n  </span><span class="s1">T extends Record&lt;string, any&gt; = Record&lt;string, any&gt;,</span><span class="s3">\n</span><span class="s1">&gt;(regexp: RegExp, keys?: Key[]): (pathname: string) =&gt; { params: T } | false {</span><span class="s3">\n  </span><span class="s1">const originalMatcher = regexpToFunction&lt;T&gt;(regexp, keys || [])</span><span class="s3">\n\n  </span><span class="s1">return (pathname: string) =&gt; {</span><span class="s3">\n    </span><span class="s1">const result = originalMatcher(pathname)</span><span class="s3">\n    </span><span class="s1">if (!result) return false</span><span class="s3">\n\n    </span><span class="s1">// Clean parameters before returning</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">...result,</span><span class="s3">\n      </span><span class="s1">params: stripParameterSeparators(result.params as any) as T,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Safe wrapper for route matcher functions that automatically cleans parameters.</span><span class="s3">\n </span><span class="s1">* This is client-safe and doesn't import path-to-regexp.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function safeRouteMatcher&lt;T extends Record&lt;string, any&gt;&gt;(</span><span class="s3">\n  </span><span class="s1">matcherFn: (pathname: string) =&gt; false | T</span><span class="s3">\n</span><span class="s1">): (pathname: string) =&gt; false | T {</span><span class="s3">\n  </span><span class="s1">return (pathname: string) =&gt; {</span><span class="s3">\n    </span><span class="s1">const result = matcherFn(pathname)</span><span class="s3">\n    </span><span class="s1">if (!result) return false</span><span class="s3">\n\n    </span><span class="s1">// Clean parameters before returning</span><span class="s3">\n    </span><span class="s1">return stripParameterSeparators(result) as T</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { Group } from './route-regex'</span><span class="s3">\n</span><span class="s1">import { DecodeError } from '../../utils'</span><span class="s3">\n</span><span class="s1">import type { Params } from '../../../../server/request/params'</span><span class="s3">\n</span><span class="s1">import { safeRouteMatcher } from './route-match-utils'</span><span class="s3">\n\n</span><span class="s1">export interface RouteMatchFn {</span><span class="s3">\n  </span><span class="s1">(pathname: string): false | Params</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type RouteMatcherOptions = {</span><span class="s3">\n  </span><span class="s1">// We only use the exec method of the RegExp object. This helps us avoid using</span><span class="s3">\n  </span><span class="s1">// type assertions that the passed in properties are of the correct type.</span><span class="s3">\n  </span><span class="s1">re: Pick&lt;RegExp, 'exec'&gt;</span><span class="s3">\n  </span><span class="s1">groups: Record&lt;string, Group&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getRouteMatcher({</span><span class="s3">\n  </span><span class="s1">re,</span><span class="s3">\n  </span><span class="s1">groups,</span><span class="s3">\n</span><span class="s1">}: RouteMatcherOptions): RouteMatchFn {</span><span class="s3">\n  </span><span class="s1">const rawMatcher = (pathname: string) =&gt; {</span><span class="s3">\n    </span><span class="s1">const routeMatch = re.exec(pathname)</span><span class="s3">\n    </span><span class="s1">if (!routeMatch) return false</span><span class="s3">\n\n    </span><span class="s1">const decode = (param: string) =&gt; {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">return decodeURIComponent(param)</span><span class="s3">\n      </span><span class="s1">} catch {</span><span class="s3">\n        </span><span class="s1">throw new DecodeError('failed to decode param')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const params: Params = {}</span><span class="s3">\n    </span><span class="s1">for (const [key, group] of Object.entries(groups)) {</span><span class="s3">\n      </span><span class="s1">const match = routeMatch[group.pos]</span><span class="s3">\n      </span><span class="s1">if (match !== undefined) {</span><span class="s3">\n        </span><span class="s1">if (group.repeat) {</span><span class="s3">\n          </span><span class="s1">params[key] = match.split('/').map((entry) =&gt; decode(entry))</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">params[key] = decode(match)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return params</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Wrap with safe matcher to handle parameter cleaning</span><span class="s3">\n  </span><span class="s1">return safeRouteMatcher(rawMatcher)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { ParsedUrlQuery } from 'querystring'</span><span class="s3">\n\n</span><span class="s1">export function searchParamsToUrlQuery(</span><span class="s3">\n  </span><span class="s1">searchParams: URLSearchParams</span><span class="s3">\n</span><span class="s1">): ParsedUrlQuery {</span><span class="s3">\n  </span><span class="s1">const query: ParsedUrlQuery = {}</span><span class="s3">\n  </span><span class="s1">for (const [key, value] of searchParams.entries()) {</span><span class="s3">\n    </span><span class="s1">const existing = query[key]</span><span class="s3">\n    </span><span class="s1">if (typeof existing === 'undefined') {</span><span class="s3">\n      </span><span class="s1">query[key] = value</span><span class="s3">\n    </span><span class="s1">} else if (Array.isArray(existing)) {</span><span class="s3">\n      </span><span class="s1">existing.push(value)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">query[key] = [existing, value]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return query</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function stringifyUrlQueryParam(param: unknown): string {</span><span class="s3">\n  </span><span class="s1">if (typeof param === 'string') {</span><span class="s3">\n    </span><span class="s1">return param</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">(typeof param === 'number' &amp;&amp; !isNaN(param)) ||</span><span class="s3">\n    </span><span class="s1">typeof param === 'boolean'</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return String(param)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return ''</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function urlQueryToSearchParams(query: ParsedUrlQuery): URLSearchParams {</span><span class="s3">\n  </span><span class="s1">const searchParams = new URLSearchParams()</span><span class="s3">\n  </span><span class="s1">for (const [key, value] of Object.entries(query)) {</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(value)) {</span><span class="s3">\n      </span><span class="s1">for (const item of value) {</span><span class="s3">\n        </span><span class="s1">searchParams.append(key, stringifyUrlQueryParam(item))</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">searchParams.set(key, stringifyUrlQueryParam(value))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return searchParams</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function assign(</span><span class="s3">\n  </span><span class="s1">target: URLSearchParams,</span><span class="s3">\n  </span><span class="s1">...searchParamsList: URLSearchParams[]</span><span class="s3">\n</span><span class="s1">): URLSearchParams {</span><span class="s3">\n  </span><span class="s1">for (const searchParams of searchParamsList) {</span><span class="s3">\n    </span><span class="s1">for (const key of searchParams.keys()) {</span><span class="s3">\n      </span><span class="s1">target.delete(key)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const [key, value] of searchParams.entries()) {</span><span class="s3">\n      </span><span class="s1">target.append(key, value)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return target</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { NextApiRequestCookies } from '.'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Parse cookies from the `headers` of request</span><span class="s3">\n </span><span class="s1">* @param req request object</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export function getCookieParser(headers: {</span><span class="s3">\n  </span><span class="s1">[key: string]: string | string[] | null | undefined</span><span class="s3">\n</span><span class="s1">}): () =&gt; NextApiRequestCookies {</span><span class="s3">\n  </span><span class="s1">return function parseCookie(): NextApiRequestCookies {</span><span class="s3">\n    </span><span class="s1">const { cookie } = headers</span><span class="s3">\n\n    </span><span class="s1">if (!cookie) {</span><span class="s3">\n      </span><span class="s1">return {}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const { parse: parseCookieFn } =</span><span class="s3">\n      </span><span class="s1">require('next/dist/compiled/cookie') as typeof import('next/dist/compiled/cookie')</span><span class="s3">\n    </span><span class="s1">return parseCookieFn(Array.isArray(cookie) ? cookie.join('; ') : cookie)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { IncomingMessage } from 'http'</span><span class="s3">\n</span><span class="s1">import type { Key } from 'next/dist/compiled/path-to-regexp'</span><span class="s3">\n</span><span class="s1">import type { NextParsedUrlQuery } from '../../../../server/request-meta'</span><span class="s3">\n</span><span class="s1">import type { RouteHas } from '../../../../lib/load-custom-routes'</span><span class="s3">\n</span><span class="s1">import type { BaseNextRequest } from '../../../../server/base-http'</span><span class="s3">\n\n</span><span class="s1">import { escapeStringRegexp } from '../../escape-regexp'</span><span class="s3">\n</span><span class="s1">import { parseUrl } from './parse-url'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">INTERCEPTION_ROUTE_MARKERS,</span><span class="s3">\n  </span><span class="s1">isInterceptionRouteAppPath,</span><span class="s3">\n</span><span class="s1">} from './interception-routes'</span><span class="s3">\n</span><span class="s1">import { getCookieParser } from '../../../../server/api-utils/get-cookie-parser'</span><span class="s3">\n</span><span class="s1">import type { Params } from '../../../../server/request/params'</span><span class="s3">\n</span><span class="s1">import { safePathToRegexp, safeCompile } from './route-match-utils'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Ensure only a-zA-Z are used for param names for proper interpolating</span><span class="s3">\n </span><span class="s1">* with path-to-regexp</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getSafeParamName(paramName: string) {</span><span class="s3">\n  </span><span class="s1">let newParamName = ''</span><span class="s3">\n\n  </span><span class="s1">for (let i = 0; i &lt; paramName.length; i++) {</span><span class="s3">\n    </span><span class="s1">const charCode = paramName.charCodeAt(i)</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">(charCode &gt; 64 &amp;&amp; charCode &lt; 91) || // A-Z</span><span class="s3">\n      </span><span class="s1">(charCode &gt; 96 &amp;&amp; charCode &lt; 123) // a-z</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">newParamName += paramName[i]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return newParamName</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function escapeSegment(str: string, segmentName: string) {</span><span class="s3">\n  </span><span class="s1">return str.replace(</span><span class="s3">\n    </span><span class="s1">new RegExp(`:${escapeStringRegexp(segmentName)}`, 'g'),</span><span class="s3">\n    </span><span class="s1">`__ESC_COLON_${segmentName}`</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function unescapeSegments(str: string) {</span><span class="s3">\n  </span><span class="s1">return str.replace(/__ESC_COLON_/gi, ':')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function matchHas(</span><span class="s3">\n  </span><span class="s1">req: BaseNextRequest | IncomingMessage,</span><span class="s3">\n  </span><span class="s1">query: Params,</span><span class="s3">\n  </span><span class="s1">has: RouteHas[] = [],</span><span class="s3">\n  </span><span class="s1">missing: RouteHas[] = []</span><span class="s3">\n</span><span class="s1">): false | Params {</span><span class="s3">\n  </span><span class="s1">const params: Params = {}</span><span class="s3">\n\n  </span><span class="s1">const hasMatch = (hasItem: RouteHas) =&gt; {</span><span class="s3">\n    </span><span class="s1">let value</span><span class="s3">\n    </span><span class="s1">let key = hasItem.key</span><span class="s3">\n\n    </span><span class="s1">switch (hasItem.type) {</span><span class="s3">\n      </span><span class="s1">case 'header': {</span><span class="s3">\n        </span><span class="s1">key = key!.toLowerCase()</span><span class="s3">\n        </span><span class="s1">value = req.headers[key] as string</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case 'cookie': {</span><span class="s3">\n        </span><span class="s1">if ('cookies' in req) {</span><span class="s3">\n          </span><span class="s1">value = req.cookies[hasItem.key]</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">const cookies = getCookieParser(req.headers)()</span><span class="s3">\n          </span><span class="s1">value = cookies[hasItem.key]</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case 'query': {</span><span class="s3">\n        </span><span class="s1">value = query[key!]</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case 'host': {</span><span class="s3">\n        </span><span class="s1">const { host } = req?.headers || {}</span><span class="s3">\n        </span><span class="s1">// remove port from host if present</span><span class="s3">\n        </span><span class="s1">const hostname = host?.split(':', 1)[0].toLowerCase()</span><span class="s3">\n        </span><span class="s1">value = hostname</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">default: {</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!hasItem.value &amp;&amp; value) {</span><span class="s3">\n      </span><span class="s1">params[getSafeParamName(key!)] = value</span><span class="s3">\n      </span><span class="s1">return true</span><span class="s3">\n    </span><span class="s1">} else if (value) {</span><span class="s3">\n      </span><span class="s1">const matcher = new RegExp(`^${hasItem.value}$`)</span><span class="s3">\n      </span><span class="s1">const matches = Array.isArray(value)</span><span class="s3">\n        </span><span class="s1">? value.slice(-1)[0].match(matcher)</span><span class="s3">\n        </span><span class="s1">: value.match(matcher)</span><span class="s3">\n\n      </span><span class="s1">if (matches) {</span><span class="s3">\n        </span><span class="s1">if (Array.isArray(matches)) {</span><span class="s3">\n          </span><span class="s1">if (matches.groups) {</span><span class="s3">\n            </span><span class="s1">Object.keys(matches.groups).forEach((groupKey) =&gt; {</span><span class="s3">\n              </span><span class="s1">params[groupKey] = matches.groups![groupKey]</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n          </span><span class="s1">} else if (hasItem.type === 'host' &amp;&amp; matches[0]) {</span><span class="s3">\n            </span><span class="s1">params.host = matches[0]</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const allMatch =</span><span class="s3">\n    </span><span class="s1">has.every((item) =&gt; hasMatch(item)) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!missing.some((item) =&gt; hasMatch(item))</span><span class="s3">\n\n  </span><span class="s1">if (allMatch) {</span><span class="s3">\n    </span><span class="s1">return params</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return false</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function compileNonPath(value: string, params: Params): string {</span><span class="s3">\n  </span><span class="s1">if (!value.includes(':')) {</span><span class="s3">\n    </span><span class="s1">return value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const key of Object.keys(params)) {</span><span class="s3">\n    </span><span class="s1">if (value.includes(`:${key}`)) {</span><span class="s3">\n      </span><span class="s1">value = value</span><span class="s3">\n        </span><span class="s1">.replace(</span><span class="s3">\n          </span><span class="s1">new RegExp(`:${key}</span><span class="s3">\\\\</span><span class="s1">*`, 'g'),</span><span class="s3">\n          </span><span class="s1">`:${key}--ESCAPED_PARAM_ASTERISKS`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">.replace(</span><span class="s3">\n          </span><span class="s1">new RegExp(`:${key}</span><span class="s3">\\\\</span><span class="s1">?`, 'g'),</span><span class="s3">\n          </span><span class="s1">`:${key}--ESCAPED_PARAM_QUESTION`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">.replace(new RegExp(`:${key}</span><span class="s3">\\\\</span><span class="s1">+`, 'g'), `:${key}--ESCAPED_PARAM_PLUS`)</span><span class="s3">\n        </span><span class="s1">.replace(</span><span class="s3">\n          </span><span class="s1">new RegExp(`:${key}(?!</span><span class="s3">\\\\</span><span class="s1">w)`, 'g'),</span><span class="s3">\n          </span><span class="s1">`--ESCAPED_PARAM_COLON${key}`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">value = value</span><span class="s3">\n    </span><span class="s1">.replace(/(:|</span><span class="s3">\\</span><span class="s1">*|</span><span class="s3">\\</span><span class="s1">?|</span><span class="s3">\\</span><span class="s1">+|</span><span class="s3">\\</span><span class="s1">(|</span><span class="s3">\\</span><span class="s1">)|</span><span class="s3">\\</span><span class="s1">{|</span><span class="s3">\\</span><span class="s1">})/g, '</span><span class="s3">\\\\</span><span class="s1">$1')</span><span class="s3">\n    </span><span class="s1">.replace(/--ESCAPED_PARAM_PLUS/g, '+')</span><span class="s3">\n    </span><span class="s1">.replace(/--ESCAPED_PARAM_COLON/g, ':')</span><span class="s3">\n    </span><span class="s1">.replace(/--ESCAPED_PARAM_QUESTION/g, '?')</span><span class="s3">\n    </span><span class="s1">.replace(/--ESCAPED_PARAM_ASTERISKS/g, '*')</span><span class="s3">\n\n  </span><span class="s1">// the value needs to start with a forward-slash to be compiled</span><span class="s3">\n  </span><span class="s1">// correctly</span><span class="s3">\n  </span><span class="s1">return safeCompile(`/${value}`, { validate: false })(params).slice(1)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function parseDestination(args: {</span><span class="s3">\n  </span><span class="s1">destination: string</span><span class="s3">\n  </span><span class="s1">params: Readonly&lt;Params&gt;</span><span class="s3">\n  </span><span class="s1">query: Readonly&lt;NextParsedUrlQuery&gt;</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">let escaped = args.destination</span><span class="s3">\n  </span><span class="s1">for (const param of Object.keys({ ...args.params, ...args.query })) {</span><span class="s3">\n    </span><span class="s1">if (!param) continue</span><span class="s3">\n\n    </span><span class="s1">escaped = escapeSegment(escaped, param)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const parsed = parseUrl(escaped)</span><span class="s3">\n\n  </span><span class="s1">let pathname = parsed.pathname</span><span class="s3">\n  </span><span class="s1">if (pathname) {</span><span class="s3">\n    </span><span class="s1">pathname = unescapeSegments(pathname)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let href = parsed.href</span><span class="s3">\n  </span><span class="s1">if (href) {</span><span class="s3">\n    </span><span class="s1">href = unescapeSegments(href)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let hostname = parsed.hostname</span><span class="s3">\n  </span><span class="s1">if (hostname) {</span><span class="s3">\n    </span><span class="s1">hostname = unescapeSegments(hostname)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let hash = parsed.hash</span><span class="s3">\n  </span><span class="s1">if (hash) {</span><span class="s3">\n    </span><span class="s1">hash = unescapeSegments(hash)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let search = parsed.search</span><span class="s3">\n  </span><span class="s1">if (search) {</span><span class="s3">\n    </span><span class="s1">search = unescapeSegments(search)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">...parsed,</span><span class="s3">\n    </span><span class="s1">pathname,</span><span class="s3">\n    </span><span class="s1">hostname,</span><span class="s3">\n    </span><span class="s1">href,</span><span class="s3">\n    </span><span class="s1">hash,</span><span class="s3">\n    </span><span class="s1">search,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function prepareDestination(args: {</span><span class="s3">\n  </span><span class="s1">appendParamsToQuery: boolean</span><span class="s3">\n  </span><span class="s1">destination: string</span><span class="s3">\n  </span><span class="s1">params: Params</span><span class="s3">\n  </span><span class="s1">query: NextParsedUrlQuery</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">const parsedDestination = parseDestination(args)</span><span class="s3">\n\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">hostname: destHostname,</span><span class="s3">\n    </span><span class="s1">query: destQuery,</span><span class="s3">\n    </span><span class="s1">search: destSearch,</span><span class="s3">\n  </span><span class="s1">} = parsedDestination</span><span class="s3">\n\n  </span><span class="s1">// The following code assumes that the pathname here includes the hash if it's</span><span class="s3">\n  </span><span class="s1">// present.</span><span class="s3">\n  </span><span class="s1">let destPath = parsedDestination.pathname</span><span class="s3">\n  </span><span class="s1">if (parsedDestination.hash) {</span><span class="s3">\n    </span><span class="s1">destPath = `${destPath}${parsedDestination.hash}`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const destParams: (string | number)[] = []</span><span class="s3">\n\n  </span><span class="s1">const destPathParamKeys: Key[] = []</span><span class="s3">\n  </span><span class="s1">safePathToRegexp(destPath, destPathParamKeys)</span><span class="s3">\n  </span><span class="s1">for (const key of destPathParamKeys) {</span><span class="s3">\n    </span><span class="s1">destParams.push(key.name)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (destHostname) {</span><span class="s3">\n    </span><span class="s1">const destHostnameParamKeys: Key[] = []</span><span class="s3">\n    </span><span class="s1">safePathToRegexp(destHostname, destHostnameParamKeys)</span><span class="s3">\n    </span><span class="s1">for (const key of destHostnameParamKeys) {</span><span class="s3">\n      </span><span class="s1">destParams.push(key.name)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const destPathCompiler = safeCompile(</span><span class="s3">\n    </span><span class="s1">destPath,</span><span class="s3">\n    </span><span class="s1">// we don't validate while compiling the destination since we should</span><span class="s3">\n    </span><span class="s1">// have already validated before we got to this point and validating</span><span class="s3">\n    </span><span class="s1">// breaks compiling destinations with named pattern params from the source</span><span class="s3">\n    </span><span class="s1">// e.g. /something:hello(.*) -&gt; /another/:hello is broken with validation</span><span class="s3">\n    </span><span class="s1">// since compile validation is meant for reversing and not for inserting</span><span class="s3">\n    </span><span class="s1">// params from a separate path-regex into another</span><span class="s3">\n    </span><span class="s1">{ validate: false }</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">let destHostnameCompiler</span><span class="s3">\n  </span><span class="s1">if (destHostname) {</span><span class="s3">\n    </span><span class="s1">destHostnameCompiler = safeCompile(destHostname, { validate: false })</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// update any params in query values</span><span class="s3">\n  </span><span class="s1">for (const [key, strOrArray] of Object.entries(destQuery)) {</span><span class="s3">\n    </span><span class="s1">// the value needs to start with a forward-slash to be compiled</span><span class="s3">\n    </span><span class="s1">// correctly</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(strOrArray)) {</span><span class="s3">\n      </span><span class="s1">destQuery[key] = strOrArray.map((value) =&gt;</span><span class="s3">\n        </span><span class="s1">compileNonPath(unescapeSegments(value), args.params)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else if (typeof strOrArray === 'string') {</span><span class="s3">\n      </span><span class="s1">destQuery[key] = compileNonPath(unescapeSegments(strOrArray), args.params)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// add path params to query if it's not a redirect and not</span><span class="s3">\n  </span><span class="s1">// already defined in destination query or path</span><span class="s3">\n  </span><span class="s1">let paramKeys = Object.keys(args.params).filter(</span><span class="s3">\n    </span><span class="s1">(name) =&gt; name !== 'nextInternalLocale'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">args.appendParamsToQuery &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!paramKeys.some((key) =&gt; destParams.includes(key))</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">for (const key of paramKeys) {</span><span class="s3">\n      </span><span class="s1">if (!(key in destQuery)) {</span><span class="s3">\n        </span><span class="s1">destQuery[key] = args.params[key]</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let newUrl</span><span class="s3">\n\n  </span><span class="s1">// The compiler also that the interception route marker is an unnamed param, hence '0',</span><span class="s3">\n  </span><span class="s1">// so we need to add it to the params object.</span><span class="s3">\n  </span><span class="s1">if (isInterceptionRouteAppPath(destPath)) {</span><span class="s3">\n    </span><span class="s1">for (const segment of destPath.split('/')) {</span><span class="s3">\n      </span><span class="s1">const marker = INTERCEPTION_ROUTE_MARKERS.find((m) =&gt;</span><span class="s3">\n        </span><span class="s1">segment.startsWith(m)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">if (marker) {</span><span class="s3">\n        </span><span class="s1">if (marker === '(..)(..)') {</span><span class="s3">\n          </span><span class="s1">args.params['0'] = '(..)'</span><span class="s3">\n          </span><span class="s1">args.params['1'] = '(..)'</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">args.params['0'] = marker</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">newUrl = destPathCompiler(args.params)</span><span class="s3">\n\n    </span><span class="s1">const [pathname, hash] = newUrl.split('#', 2)</span><span class="s3">\n    </span><span class="s1">if (destHostnameCompiler) {</span><span class="s3">\n      </span><span class="s1">parsedDestination.hostname = destHostnameCompiler(args.params)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">parsedDestination.pathname = pathname</span><span class="s3">\n    </span><span class="s1">parsedDestination.hash = `${hash ? '#' : ''}${hash || ''}`</span><span class="s3">\n    </span><span class="s1">parsedDestination.search = destSearch</span><span class="s3">\n      </span><span class="s1">? compileNonPath(destSearch, args.params)</span><span class="s3">\n      </span><span class="s1">: ''</span><span class="s3">\n  </span><span class="s1">} catch (err: any) {</span><span class="s3">\n    </span><span class="s1">if (err.message.match(/Expected .*? to not repeat, but got an array/)) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">`To use a multi-match in the destination you must add </span><span class="s3">\\</span><span class="s1">`*</span><span class="s3">\\</span><span class="s1">` at the end of the param name to signify it should repeat. https://nextjs.org/docs/messages/invalid-multi-match`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">throw err</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Query merge order lowest priority to highest</span><span class="s3">\n  </span><span class="s1">// 1. initial URL query values</span><span class="s3">\n  </span><span class="s1">// 2. path segment values</span><span class="s3">\n  </span><span class="s1">// 3. destination specified query values</span><span class="s3">\n  </span><span class="s1">parsedDestination.query = {</span><span class="s3">\n    </span><span class="s1">...args.query,</span><span class="s3">\n    </span><span class="s1">...parsedDestination.query,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">newUrl,</span><span class="s3">\n    </span><span class="s1">destQuery,</span><span class="s3">\n    </span><span class="s1">parsedDestination,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { OutgoingHttpHeaders } from 'http'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">NEXT_INTERCEPTION_MARKER_PREFIX,</span><span class="s3">\n  </span><span class="s1">NEXT_QUERY_PARAM_PREFIX,</span><span class="s3">\n</span><span class="s1">} from '../../lib/constants'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts a Node.js IncomingHttpHeaders object to a Headers object. Any</span><span class="s3">\n </span><span class="s1">* headers with multiple values will be joined with a comma and space. Any</span><span class="s3">\n </span><span class="s1">* headers that have an undefined value will be ignored and others will be</span><span class="s3">\n </span><span class="s1">* coerced to strings.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param nodeHeaders the headers object to convert</span><span class="s3">\n </span><span class="s1">* @returns the converted headers object</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function fromNodeOutgoingHttpHeaders(</span><span class="s3">\n  </span><span class="s1">nodeHeaders: OutgoingHttpHeaders</span><span class="s3">\n</span><span class="s1">): Headers {</span><span class="s3">\n  </span><span class="s1">const headers = new Headers()</span><span class="s3">\n  </span><span class="s1">for (let [key, value] of Object.entries(nodeHeaders)) {</span><span class="s3">\n    </span><span class="s1">const values = Array.isArray(value) ? value : [value]</span><span class="s3">\n    </span><span class="s1">for (let v of values) {</span><span class="s3">\n      </span><span class="s1">if (typeof v === 'undefined') continue</span><span class="s3">\n      </span><span class="s1">if (typeof v === 'number') {</span><span class="s3">\n        </span><span class="s1">v = v.toString()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">headers.append(key, v)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return headers</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n  </span><span class="s1">Set-Cookie header field-values are sometimes comma joined in one string. This splits them without choking on commas</span><span class="s3">\n  </span><span class="s1">that are within a single set-cookie field-value, such as in the Expires portion.</span><span class="s3">\n  </span><span class="s1">This is uncommon, but explicitly allowed - see https://tools.ietf.org/html/rfc2616#section-4.2</span><span class="s3">\n  </span><span class="s1">Node.js does this for every header *except* set-cookie - see https://github.com/nodejs/node/blob/d5e363b77ebaf1caf67cd7528224b651c86815c1/lib/_http_incoming.js#L128</span><span class="s3">\n  </span><span class="s1">React Native's fetch does this for *every* header, including set-cookie.</span><span class="s3">\n  \n  </span><span class="s1">Based on: https://github.com/google/j2objc/commit/16820fdbc8f76ca0c33472810ce0cb03d20efe25</span><span class="s3">\n  </span><span class="s1">Credits to: https://github.com/tomball for original and https://github.com/chrusart for JavaScript implementation</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function splitCookiesString(cookiesString: string) {</span><span class="s3">\n  </span><span class="s1">var cookiesStrings = []</span><span class="s3">\n  </span><span class="s1">var pos = 0</span><span class="s3">\n  </span><span class="s1">var start</span><span class="s3">\n  </span><span class="s1">var ch</span><span class="s3">\n  </span><span class="s1">var lastComma</span><span class="s3">\n  </span><span class="s1">var nextStart</span><span class="s3">\n  </span><span class="s1">var cookiesSeparatorFound</span><span class="s3">\n\n  </span><span class="s1">function skipWhitespace() {</span><span class="s3">\n    </span><span class="s1">while (pos &lt; cookiesString.length &amp;&amp; /</span><span class="s3">\\</span><span class="s1">s/.test(cookiesString.charAt(pos))) {</span><span class="s3">\n      </span><span class="s1">pos += 1</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return pos &lt; cookiesString.length</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function notSpecialChar() {</span><span class="s3">\n    </span><span class="s1">ch = cookiesString.charAt(pos)</span><span class="s3">\n\n    </span><span class="s1">return ch !== '=' &amp;&amp; ch !== ';' &amp;&amp; ch !== ','</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">while (pos &lt; cookiesString.length) {</span><span class="s3">\n    </span><span class="s1">start = pos</span><span class="s3">\n    </span><span class="s1">cookiesSeparatorFound = false</span><span class="s3">\n\n    </span><span class="s1">while (skipWhitespace()) {</span><span class="s3">\n      </span><span class="s1">ch = cookiesString.charAt(pos)</span><span class="s3">\n      </span><span class="s1">if (ch === ',') {</span><span class="s3">\n        </span><span class="s1">// ',' is a cookie separator if we have later first '=', not ';' or ','</span><span class="s3">\n        </span><span class="s1">lastComma = pos</span><span class="s3">\n        </span><span class="s1">pos += 1</span><span class="s3">\n\n        </span><span class="s1">skipWhitespace()</span><span class="s3">\n        </span><span class="s1">nextStart = pos</span><span class="s3">\n\n        </span><span class="s1">while (pos &lt; cookiesString.length &amp;&amp; notSpecialChar()) {</span><span class="s3">\n          </span><span class="s1">pos += 1</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// currently special character</span><span class="s3">\n        </span><span class="s1">if (pos &lt; cookiesString.length &amp;&amp; cookiesString.charAt(pos) === '=') {</span><span class="s3">\n          </span><span class="s1">// we found cookies separator</span><span class="s3">\n          </span><span class="s1">cookiesSeparatorFound = true</span><span class="s3">\n          </span><span class="s1">// pos is inside the next cookie, so back up and return it.</span><span class="s3">\n          </span><span class="s1">pos = nextStart</span><span class="s3">\n          </span><span class="s1">cookiesStrings.push(cookiesString.substring(start, lastComma))</span><span class="s3">\n          </span><span class="s1">start = pos</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// in param ',' or param separator ';',</span><span class="s3">\n          </span><span class="s1">// we continue from that comma</span><span class="s3">\n          </span><span class="s1">pos = lastComma + 1</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">pos += 1</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!cookiesSeparatorFound || pos &gt;= cookiesString.length) {</span><span class="s3">\n      </span><span class="s1">cookiesStrings.push(cookiesString.substring(start, cookiesString.length))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return cookiesStrings</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts a Headers object to a Node.js OutgoingHttpHeaders object. This is</span><span class="s3">\n </span><span class="s1">* required to support the set-cookie header, which may have multiple values.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param headers the headers object to convert</span><span class="s3">\n </span><span class="s1">* @returns the converted headers object</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function toNodeOutgoingHttpHeaders(</span><span class="s3">\n  </span><span class="s1">headers: Headers</span><span class="s3">\n</span><span class="s1">): OutgoingHttpHeaders {</span><span class="s3">\n  </span><span class="s1">const nodeHeaders: OutgoingHttpHeaders = {}</span><span class="s3">\n  </span><span class="s1">const cookies: string[] = []</span><span class="s3">\n  </span><span class="s1">if (headers) {</span><span class="s3">\n    </span><span class="s1">for (const [key, value] of headers.entries()) {</span><span class="s3">\n      </span><span class="s1">if (key.toLowerCase() === 'set-cookie') {</span><span class="s3">\n        </span><span class="s1">// We may have gotten a comma joined string of cookies, or multiple</span><span class="s3">\n        </span><span class="s1">// set-cookie headers. We need to merge them into one header array</span><span class="s3">\n        </span><span class="s1">// to represent all the cookies.</span><span class="s3">\n        </span><span class="s1">cookies.push(...splitCookiesString(value))</span><span class="s3">\n        </span><span class="s1">nodeHeaders[key] = cookies.length === 1 ? cookies[0] : cookies</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">nodeHeaders[key] = value</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return nodeHeaders</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Validate the correctness of a user-provided URL.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function validateURL(url: string | URL): string {</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">return String(new URL(String(url)))</span><span class="s3">\n  </span><span class="s1">} catch (error: any) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`URL is malformed </span><span class="s3">\&quot;</span><span class="s1">${String(</span><span class="s3">\n        </span><span class="s1">url</span><span class="s3">\n      </span><span class="s1">)}</span><span class="s3">\&quot;</span><span class="s1">. Please use only absolute URLs - https://nextjs.org/docs/messages/middleware-relative-urls`,</span><span class="s3">\n      </span><span class="s1">{ cause: error }</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Normalizes `nxtP` and `nxtI` query param values to remove the prefix.</span><span class="s3">\n </span><span class="s1">* This function does not mutate the input key.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function normalizeNextQueryParam(key: string): null | string {</span><span class="s3">\n  </span><span class="s1">const prefixes = [NEXT_QUERY_PARAM_PREFIX, NEXT_INTERCEPTION_MARKER_PREFIX]</span><span class="s3">\n  </span><span class="s1">for (const prefix of prefixes) {</span><span class="s3">\n    </span><span class="s1">if (key !== prefix &amp;&amp; key.startsWith(prefix)) {</span><span class="s3">\n      </span><span class="s1">return key.substring(prefix.length)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Decodes a query path parameter.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param value - The value to decode.</span><span class="s3">\n </span><span class="s1">* @returns The decoded value.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function decodeQueryPathParameter(value: string) {</span><span class="s3">\n  </span><span class="s1">// When deployed to Vercel, the value may be encoded, so this attempts to</span><span class="s3">\n  </span><span class="s1">// decode it and returns the original value if it fails.</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">return decodeURIComponent(value)</span><span class="s3">\n  </span><span class="s1">} catch {</span><span class="s3">\n    </span><span class="s1">return value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// Format function modified from nodejs</span><span class="s3">\n</span><span class="s1">// Copyright Joyent, Inc. and other Node contributors.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// Permission is hereby granted, free of charge, to any person obtaining a</span><span class="s3">\n</span><span class="s1">// copy of this software and associated documentation files (the</span><span class="s3">\n</span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">Software</span><span class="s3">\&quot;</span><span class="s1">), to deal in the Software without restriction, including</span><span class="s3">\n</span><span class="s1">// without limitation the rights to use, copy, modify, merge, publish,</span><span class="s3">\n</span><span class="s1">// distribute, sublicense, and/or sell copies of the Software, and to permit</span><span class="s3">\n</span><span class="s1">// persons to whom the Software is furnished to do so, subject to the</span><span class="s3">\n</span><span class="s1">// following conditions:</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// The above copyright notice and this permission notice shall be included</span><span class="s3">\n</span><span class="s1">// in all copies or substantial portions of the Software.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// THE SOFTWARE IS PROVIDED </span><span class="s3">\&quot;</span><span class="s1">AS IS</span><span class="s3">\&quot;</span><span class="s1">, WITHOUT WARRANTY OF ANY KIND, EXPRESS</span><span class="s3">\n</span><span class="s1">// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span><span class="s3">\n</span><span class="s1">// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN</span><span class="s3">\n</span><span class="s1">// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,</span><span class="s3">\n</span><span class="s1">// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR</span><span class="s3">\n</span><span class="s1">// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE</span><span class="s3">\n</span><span class="s1">// USE OR OTHER DEALINGS IN THE SOFTWARE.</span><span class="s3">\n\n</span><span class="s1">import type { UrlObject } from 'url'</span><span class="s3">\n</span><span class="s1">import type { ParsedUrlQuery } from 'querystring'</span><span class="s3">\n</span><span class="s1">import * as querystring from './querystring'</span><span class="s3">\n\n</span><span class="s1">const slashedProtocols = /https?|ftp|gopher|file/</span><span class="s3">\n\n</span><span class="s1">export function formatUrl(urlObj: UrlObject) {</span><span class="s3">\n  </span><span class="s1">let { auth, hostname } = urlObj</span><span class="s3">\n  </span><span class="s1">let protocol = urlObj.protocol || ''</span><span class="s3">\n  </span><span class="s1">let pathname = urlObj.pathname || ''</span><span class="s3">\n  </span><span class="s1">let hash = urlObj.hash || ''</span><span class="s3">\n  </span><span class="s1">let query = urlObj.query || ''</span><span class="s3">\n  </span><span class="s1">let host: string | false = false</span><span class="s3">\n\n  </span><span class="s1">auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : ''</span><span class="s3">\n\n  </span><span class="s1">if (urlObj.host) {</span><span class="s3">\n    </span><span class="s1">host = auth + urlObj.host</span><span class="s3">\n  </span><span class="s1">} else if (hostname) {</span><span class="s3">\n    </span><span class="s1">host = auth + (~hostname.indexOf(':') ? `[${hostname}]` : hostname)</span><span class="s3">\n    </span><span class="s1">if (urlObj.port) {</span><span class="s3">\n      </span><span class="s1">host += ':' + urlObj.port</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (query &amp;&amp; typeof query === 'object') {</span><span class="s3">\n    </span><span class="s1">query = String(querystring.urlQueryToSearchParams(query as ParsedUrlQuery))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let search = urlObj.search || (query &amp;&amp; `?${query}`) || ''</span><span class="s3">\n\n  </span><span class="s1">if (protocol &amp;&amp; !protocol.endsWith(':')) protocol += ':'</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">urlObj.slashes ||</span><span class="s3">\n    </span><span class="s1">((!protocol || slashedProtocols.test(protocol)) &amp;&amp; host !== false)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">host = '//' + (host || '')</span><span class="s3">\n    </span><span class="s1">if (pathname &amp;&amp; pathname[0] !== '/') pathname = '/' + pathname</span><span class="s3">\n  </span><span class="s1">} else if (!host) {</span><span class="s3">\n    </span><span class="s1">host = ''</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (hash &amp;&amp; hash[0] !== '#') hash = '#' + hash</span><span class="s3">\n  </span><span class="s1">if (search &amp;&amp; search[0] !== '?') search = '?' + search</span><span class="s3">\n\n  </span><span class="s1">pathname = pathname.replace(/[?#]/g, encodeURIComponent)</span><span class="s3">\n  </span><span class="s1">search = search.replace('#', '%23')</span><span class="s3">\n\n  </span><span class="s1">return `${protocol}${host}${pathname}${search}${hash}`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const urlObjectKeys = [</span><span class="s3">\n  </span><span class="s1">'auth',</span><span class="s3">\n  </span><span class="s1">'hash',</span><span class="s3">\n  </span><span class="s1">'host',</span><span class="s3">\n  </span><span class="s1">'hostname',</span><span class="s3">\n  </span><span class="s1">'href',</span><span class="s3">\n  </span><span class="s1">'path',</span><span class="s3">\n  </span><span class="s1">'pathname',</span><span class="s3">\n  </span><span class="s1">'port',</span><span class="s3">\n  </span><span class="s1">'protocol',</span><span class="s3">\n  </span><span class="s1">'query',</span><span class="s3">\n  </span><span class="s1">'search',</span><span class="s3">\n  </span><span class="s1">'slashes',</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">export function formatWithValidation(url: UrlObject): string {</span><span class="s3">\n  </span><span class="s1">if (process.env.NODE_ENV === 'development') {</span><span class="s3">\n    </span><span class="s1">if (url !== null &amp;&amp; typeof url === 'object') {</span><span class="s3">\n      </span><span class="s1">Object.keys(url).forEach((key) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (!urlObjectKeys.includes(key)) {</span><span class="s3">\n          </span><span class="s1">console.warn(</span><span class="s3">\n            </span><span class="s1">`Unknown key passed via urlObject into url.format: ${key}`</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return formatUrl(url)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { LoadComponentsReturnType } from '../load-components'</span><span class="s3">\n</span><span class="s1">import type { ServerRuntime, SizeLimit } from '../../types'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">ExperimentalConfig,</span><span class="s3">\n  </span><span class="s1">NextConfigComplete,</span><span class="s3">\n</span><span class="s1">} from '../../server/config-shared'</span><span class="s3">\n</span><span class="s1">import type { ClientReferenceManifest } from '../../build/webpack/plugins/flight-manifest-plugin'</span><span class="s3">\n</span><span class="s1">import type { NextFontManifest } from '../../build/webpack/plugins/next-font-manifest-plugin'</span><span class="s3">\n</span><span class="s1">import type { ParsedUrlQuery } from 'querystring'</span><span class="s3">\n</span><span class="s1">import type { AppPageModule } from '../route-modules/app-page/module'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">HeadData,</span><span class="s3">\n  </span><span class="s1">LoadingModuleData,</span><span class="s3">\n</span><span class="s1">} from '../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import type { DeepReadonly } from '../../shared/lib/deep-readonly'</span><span class="s3">\n</span><span class="s1">import type { __ApiPreviewProps } from '../api-utils'</span><span class="s3">\n\n</span><span class="s1">import s from 'next/dist/compiled/superstruct'</span><span class="s3">\n</span><span class="s1">import type { RequestLifecycleOpts } from '../base-server'</span><span class="s3">\n</span><span class="s1">import type { InstrumentationOnRequestError } from '../instrumentation/types'</span><span class="s3">\n</span><span class="s1">import type { NextRequestHint } from '../web/adapter'</span><span class="s3">\n</span><span class="s1">import type { BaseNextRequest } from '../base-http'</span><span class="s3">\n</span><span class="s1">import type { IncomingMessage } from 'http'</span><span class="s3">\n</span><span class="s1">import type { RenderResumeDataCache } from '../resume-data-cache/resume-data-cache'</span><span class="s3">\n\n</span><span class="s1">export type DynamicParamTypes =</span><span class="s3">\n  </span><span class="s1">| 'catchall'</span><span class="s3">\n  </span><span class="s1">| 'catchall-intercepted'</span><span class="s3">\n  </span><span class="s1">| 'optional-catchall'</span><span class="s3">\n  </span><span class="s1">| 'dynamic'</span><span class="s3">\n  </span><span class="s1">| 'dynamic-intercepted'</span><span class="s3">\n\n</span><span class="s1">const dynamicParamTypesSchema = s.enums(['c', 'ci', 'oc', 'd', 'di'])</span><span class="s3">\n\n</span><span class="s1">export type DynamicParamTypesShort = s.Infer&lt;typeof dynamicParamTypesSchema&gt;</span><span class="s3">\n\n</span><span class="s1">const segmentSchema = s.union([</span><span class="s3">\n  </span><span class="s1">s.string(),</span><span class="s3">\n\n  </span><span class="s1">s.tuple([</span><span class="s3">\n    </span><span class="s1">// Param name</span><span class="s3">\n    </span><span class="s1">s.string(),</span><span class="s3">\n    </span><span class="s1">// Param cache key (almost the same as the value, but arrays are</span><span class="s3">\n    </span><span class="s1">// concatenated into strings)</span><span class="s3">\n    </span><span class="s1">// TODO: We should change this to just be the value. Currently we convert</span><span class="s3">\n    </span><span class="s1">// it back to a value when passing to useParams. It only needs to be</span><span class="s3">\n    </span><span class="s1">// a string when converted to a a cache key, but that doesn't mean we</span><span class="s3">\n    </span><span class="s1">// need to store it as that representation.</span><span class="s3">\n    </span><span class="s1">s.string(),</span><span class="s3">\n    </span><span class="s1">// Dynamic param type</span><span class="s3">\n    </span><span class="s1">dynamicParamTypesSchema,</span><span class="s3">\n  </span><span class="s1">]),</span><span class="s3">\n</span><span class="s1">])</span><span class="s3">\n\n</span><span class="s1">export type Segment = s.Infer&lt;typeof segmentSchema&gt;</span><span class="s3">\n\n</span><span class="s1">// unfortunately the tuple is not understood well by Describe so we have to</span><span class="s3">\n</span><span class="s1">// use any here. This does not have any impact on the runtime type since the validation</span><span class="s3">\n</span><span class="s1">// does work correctly.</span><span class="s3">\n</span><span class="s1">export const flightRouterStateSchema: s.Describe&lt;any&gt; = s.tuple([</span><span class="s3">\n  </span><span class="s1">segmentSchema,</span><span class="s3">\n  </span><span class="s1">s.record(</span><span class="s3">\n    </span><span class="s1">s.string(),</span><span class="s3">\n    </span><span class="s1">s.lazy(() =&gt; flightRouterStateSchema)</span><span class="s3">\n  </span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">s.optional(s.nullable(s.string())),</span><span class="s3">\n  </span><span class="s1">s.optional(</span><span class="s3">\n    </span><span class="s1">s.nullable(</span><span class="s3">\n      </span><span class="s1">s.union([</span><span class="s3">\n        </span><span class="s1">s.literal('refetch'),</span><span class="s3">\n        </span><span class="s1">s.literal('refresh'),</span><span class="s3">\n        </span><span class="s1">s.literal('inside-shared-layout'),</span><span class="s3">\n        </span><span class="s1">s.literal('metadata-only'),</span><span class="s3">\n      </span><span class="s1">])</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">s.optional(s.boolean()),</span><span class="s3">\n</span><span class="s1">])</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Router state</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type FlightRouterState = [</span><span class="s3">\n  </span><span class="s1">segment: Segment,</span><span class="s3">\n  </span><span class="s1">parallelRoutes: { [parallelRouterKey: string]: FlightRouterState },</span><span class="s3">\n  </span><span class="s1">url?: string | null,</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* </span><span class="s3">\&quot;</span><span class="s1">refresh</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">refetch</span><span class="s3">\&quot;</span><span class="s1">, despite being similarly named, have different</span><span class="s3">\n   </span><span class="s1">* semantics:</span><span class="s3">\n   </span><span class="s1">* - </span><span class="s3">\&quot;</span><span class="s1">refetch</span><span class="s3">\&quot; </span><span class="s1">is used during a request to inform the server where rendering</span><span class="s3">\n   </span><span class="s1">*   should start from.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* - </span><span class="s3">\&quot;</span><span class="s1">refresh</span><span class="s3">\&quot; </span><span class="s1">is used by the client to mark that a segment should re-fetch the</span><span class="s3">\n   </span><span class="s1">*   data from the server for the current segment. It uses the </span><span class="s3">\&quot;</span><span class="s1">url</span><span class="s3">\&quot; </span><span class="s1">property</span><span class="s3">\n   </span><span class="s1">*   above to determine where to fetch from.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* - </span><span class="s3">\&quot;</span><span class="s1">inside-shared-layout</span><span class="s3">\&quot; </span><span class="s1">is used during a prefetch request to inform the</span><span class="s3">\n   </span><span class="s1">*   server that even if the segment matches, it should be treated as if it's</span><span class="s3">\n   </span><span class="s1">*   within the </span><span class="s3">\&quot;</span><span class="s1">new</span><span class="s3">\&quot; </span><span class="s1">part of a navigation  inside the shared layout. If</span><span class="s3">\n   </span><span class="s1">*   the segment doesn't match, then it has no effect, since it would be</span><span class="s3">\n   </span><span class="s1">*   treated as new regardless. If it does match, though, the server does not</span><span class="s3">\n   </span><span class="s1">*   need to render it, because the client already has it.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* - </span><span class="s3">\&quot;</span><span class="s1">metadata-only</span><span class="s3">\&quot; </span><span class="s1">instructs the server to skip rendering the segments and</span><span class="s3">\n   </span><span class="s1">*   only send the head data.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">*   A bit confusing, but that's because it has only one extremely narrow use</span><span class="s3">\n   </span><span class="s1">*   case  during a non-PPR prefetch, the server uses it to find the first</span><span class="s3">\n   </span><span class="s1">*   loading boundary beneath a shared layout.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">*   TODO: We should rethink the protocol for dynamic requests. It might not</span><span class="s3">\n   </span><span class="s1">*   make sense for the client to send a FlightRouterState, since this type is</span><span class="s3">\n   </span><span class="s1">*   overloaded with concerns.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">refresh?:</span><span class="s3">\n    </span><span class="s1">| 'refetch'</span><span class="s3">\n    </span><span class="s1">| 'refresh'</span><span class="s3">\n    </span><span class="s1">| 'inside-shared-layout'</span><span class="s3">\n    </span><span class="s1">| 'metadata-only'</span><span class="s3">\n    </span><span class="s1">| null,</span><span class="s3">\n  </span><span class="s1">isRootLayout?: boolean,</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Only present when responding to a tree prefetch request. Indicates whether</span><span class="s3">\n   </span><span class="s1">* there is a loading boundary somewhere in the tree. The client cache uses</span><span class="s3">\n   </span><span class="s1">* this to determine if it can skip the data prefetch request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">hasLoadingBoundary?: HasLoadingBoundary,</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">export const enum HasLoadingBoundary {</span><span class="s3">\n  </span><span class="s1">// There is a loading boundary in this particular segment</span><span class="s3">\n  </span><span class="s1">SegmentHasLoadingBoundary = 1,</span><span class="s3">\n  </span><span class="s1">// There is a loading boundary somewhere in the subtree (but not in</span><span class="s3">\n  </span><span class="s1">// this segment)</span><span class="s3">\n  </span><span class="s1">SubtreeHasLoadingBoundary = 2,</span><span class="s3">\n  </span><span class="s1">// There is no loading boundary in this segment or any of its descendants</span><span class="s3">\n  </span><span class="s1">SubtreeHasNoLoadingBoundary = 3,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Individual Flight response path</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type FlightSegmentPath =</span><span class="s3">\n  </span><span class="s1">// Uses `any` as repeating pattern can't be typed.</span><span class="s3">\n  </span><span class="s1">| any[]</span><span class="s3">\n  </span><span class="s1">// Looks somewhat like this</span><span class="s3">\n  </span><span class="s1">| [</span><span class="s3">\n      </span><span class="s1">segment: Segment,</span><span class="s3">\n      </span><span class="s1">parallelRouterKey: string,</span><span class="s3">\n      </span><span class="s1">segment: Segment,</span><span class="s3">\n      </span><span class="s1">parallelRouterKey: string,</span><span class="s3">\n      </span><span class="s1">segment: Segment,</span><span class="s3">\n      </span><span class="s1">parallelRouterKey: string,</span><span class="s3">\n    </span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Represents a tree of segments and the Flight data (i.e. React nodes) that</span><span class="s3">\n </span><span class="s1">* correspond to each one. The tree is isomorphic to the FlightRouterState;</span><span class="s3">\n </span><span class="s1">* however in the future we want to be able to fetch arbitrary partial segments</span><span class="s3">\n </span><span class="s1">* without having to fetch all its children. So this response format will</span><span class="s3">\n </span><span class="s1">* likely change.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type CacheNodeSeedData = [</span><span class="s3">\n  </span><span class="s1">segment: Segment,</span><span class="s3">\n  </span><span class="s1">node: React.ReactNode | null,</span><span class="s3">\n  </span><span class="s1">parallelRoutes: {</span><span class="s3">\n    </span><span class="s1">[parallelRouterKey: string]: CacheNodeSeedData | null</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">loading: LoadingModuleData | Promise&lt;LoadingModuleData&gt;,</span><span class="s3">\n  </span><span class="s1">isPartial: boolean,</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">export type FlightDataSegment = [</span><span class="s3">\n  </span><span class="s1">/* segment of the rendered slice: */ Segment,</span><span class="s3">\n  </span><span class="s1">/* treePatch */ FlightRouterState,</span><span class="s3">\n  </span><span class="s1">/* cacheNodeSeedData */ CacheNodeSeedData | null, // Can be null during prefetch if there's no loading component</span><span class="s3">\n  </span><span class="s1">/* head: viewport */ HeadData,</span><span class="s3">\n  </span><span class="s1">/* isHeadPartial */ boolean,</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">export type FlightDataPath =</span><span class="s3">\n  </span><span class="s1">// Uses `any` as repeating pattern can't be typed.</span><span class="s3">\n  </span><span class="s1">| any[]</span><span class="s3">\n  </span><span class="s1">// Looks somewhat like this</span><span class="s3">\n  </span><span class="s1">| [</span><span class="s3">\n      </span><span class="s1">// Holds full path to the segment.</span><span class="s3">\n      </span><span class="s1">...FlightSegmentPath[],</span><span class="s3">\n      </span><span class="s1">...FlightDataSegment,</span><span class="s3">\n    </span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The Flight response data</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type FlightData = Array&lt;FlightDataPath&gt; | string</span><span class="s3">\n\n</span><span class="s1">export type ActionResult = Promise&lt;any&gt;</span><span class="s3">\n\n</span><span class="s1">export type ServerOnInstrumentationRequestError = (</span><span class="s3">\n  </span><span class="s1">error: unknown,</span><span class="s3">\n  </span><span class="s1">// The request could be middleware, node server or web server request,</span><span class="s3">\n  </span><span class="s1">// we normalized them into an aligned format to `onRequestError` API later.</span><span class="s3">\n  </span><span class="s1">request: NextRequestHint | BaseNextRequest | IncomingMessage,</span><span class="s3">\n  </span><span class="s1">errorContext: Parameters&lt;InstrumentationOnRequestError&gt;[2]</span><span class="s3">\n</span><span class="s1">) =&gt; void | Promise&lt;void&gt;</span><span class="s3">\n\n</span><span class="s1">export interface RenderOptsPartial {</span><span class="s3">\n  </span><span class="s1">dir?: string</span><span class="s3">\n  </span><span class="s1">previewProps: __ApiPreviewProps | undefined</span><span class="s3">\n  </span><span class="s1">err?: Error | null</span><span class="s3">\n  </span><span class="s1">dev?: boolean</span><span class="s3">\n  </span><span class="s1">basePath: string</span><span class="s3">\n  </span><span class="s1">trailingSlash: boolean</span><span class="s3">\n  </span><span class="s1">clientReferenceManifest?: DeepReadonly&lt;ClientReferenceManifest&gt;</span><span class="s3">\n  </span><span class="s1">supportsDynamicResponse: boolean</span><span class="s3">\n  </span><span class="s1">runtime?: ServerRuntime</span><span class="s3">\n  </span><span class="s1">serverComponents?: boolean</span><span class="s3">\n  </span><span class="s1">enableTainting?: boolean</span><span class="s3">\n  </span><span class="s1">assetPrefix?: string</span><span class="s3">\n  </span><span class="s1">crossOrigin?: '' | 'anonymous' | 'use-credentials' | undefined</span><span class="s3">\n  </span><span class="s1">nextFontManifest?: DeepReadonly&lt;NextFontManifest&gt;</span><span class="s3">\n  </span><span class="s1">botType?: 'dom' | 'html' | undefined</span><span class="s3">\n  </span><span class="s1">serveStreamingMetadata?: boolean</span><span class="s3">\n  </span><span class="s1">incrementalCache?: import('../lib/incremental-cache').IncrementalCache</span><span class="s3">\n  </span><span class="s1">cacheLifeProfiles?: {</span><span class="s3">\n    </span><span class="s1">[profile: string]: import('../use-cache/cache-life').CacheLife</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">isOnDemandRevalidate?: boolean</span><span class="s3">\n  </span><span class="s1">isPossibleServerAction?: boolean</span><span class="s3">\n  </span><span class="s1">setIsrStatus?: (key: string, value: boolean | null) =&gt; void</span><span class="s3">\n  </span><span class="s1">isRevalidate?: boolean</span><span class="s3">\n  </span><span class="s1">nextExport?: boolean</span><span class="s3">\n  </span><span class="s1">nextConfigOutput?: 'standalone' | 'export'</span><span class="s3">\n  </span><span class="s1">onInstrumentationRequestError?: ServerOnInstrumentationRequestError</span><span class="s3">\n  </span><span class="s1">isDraftMode?: boolean</span><span class="s3">\n  </span><span class="s1">deploymentId?: string</span><span class="s3">\n  </span><span class="s1">onUpdateCookies?: (cookies: string[]) =&gt; void</span><span class="s3">\n  </span><span class="s1">loadConfig?: (</span><span class="s3">\n    </span><span class="s1">phase: string,</span><span class="s3">\n    </span><span class="s1">dir: string,</span><span class="s3">\n    </span><span class="s1">customConfig?: object | null,</span><span class="s3">\n    </span><span class="s1">rawConfig?: boolean,</span><span class="s3">\n    </span><span class="s1">silent?: boolean</span><span class="s3">\n  </span><span class="s1">) =&gt; Promise&lt;NextConfigComplete&gt;</span><span class="s3">\n  </span><span class="s1">serverActions?: {</span><span class="s3">\n    </span><span class="s1">bodySizeLimit?: SizeLimit</span><span class="s3">\n    </span><span class="s1">allowedOrigins?: string[]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">params?: ParsedUrlQuery</span><span class="s3">\n  </span><span class="s1">isPrefetch?: boolean</span><span class="s3">\n  </span><span class="s1">htmlLimitedBots: string | undefined</span><span class="s3">\n  </span><span class="s1">experimental: {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* When true, it indicates that the current page supports partial</span><span class="s3">\n     </span><span class="s1">* prerendering.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">isRoutePPREnabled?: boolean</span><span class="s3">\n    </span><span class="s1">expireTime: number | undefined</span><span class="s3">\n    </span><span class="s1">staleTimes: ExperimentalConfig['staleTimes'] | undefined</span><span class="s3">\n    </span><span class="s1">clientTraceMetadata: string[] | undefined</span><span class="s3">\n    </span><span class="s1">cacheComponents: boolean</span><span class="s3">\n    </span><span class="s1">clientSegmentCache: boolean | 'client-only'</span><span class="s3">\n    </span><span class="s1">clientParamParsing: boolean</span><span class="s3">\n    </span><span class="s1">dynamicOnHover: boolean</span><span class="s3">\n    </span><span class="s1">inlineCss: boolean</span><span class="s3">\n    </span><span class="s1">authInterrupts: boolean</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">postponed?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Should wait for react stream allReady to resolve all suspense boundaries,</span><span class="s3">\n   </span><span class="s1">* in order to perform a full page render.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">shouldWaitOnAllReady?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A prefilled resume data cache. This was either generated for this page</span><span class="s3">\n   </span><span class="s1">* during dev warmup, or when a page with defined params was previously</span><span class="s3">\n   </span><span class="s1">* prerendered, and now its matching optional fallback shell is prerendered.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">renderResumeDataCache?: RenderResumeDataCache</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When true, the page will be rendered using the static rendering to detect</span><span class="s3">\n   </span><span class="s1">* any dynamic API's that would have stopped the page from being fully</span><span class="s3">\n   </span><span class="s1">* statically generated.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isDebugDynamicAccesses?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* This is true when:</span><span class="s3">\n   </span><span class="s1">* - source maps are generated</span><span class="s3">\n   </span><span class="s1">* - source maps are applied</span><span class="s3">\n   </span><span class="s1">* - minification is disabled</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">hasReadableErrorStacks?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The maximum length of the headers that are emitted by React and added to</span><span class="s3">\n   </span><span class="s1">* the response.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">reactMaxHeadersLength: number | undefined</span><span class="s3">\n\n  </span><span class="s1">isStaticGeneration?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When true, the page is prerendered as a fallback shell, while allowing any</span><span class="s3">\n   </span><span class="s1">* dynamic accesses to result in an empty shell. This is the case when there</span><span class="s3">\n   </span><span class="s1">* are also routes prerendered with a more complete set of params.</span><span class="s3">\n   </span><span class="s1">* Prerendering those routes would catch any invalid dynamic accesses.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">allowEmptyStaticShell?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* next config experimental.devtoolSegmentExplorer</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">devtoolSegmentExplorer?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type RenderOpts = LoadComponentsReturnType&lt;AppPageModule&gt; &amp;</span><span class="s3">\n  </span><span class="s1">RenderOptsPartial &amp;</span><span class="s3">\n  </span><span class="s1">RequestLifecycleOpts</span><span class="s3">\n\n</span><span class="s1">export type PreloadCallbacks = (() =&gt; void)[]</span><span class="s3">\n\n</span><span class="s1">export type InitialRSCPayload = {</span><span class="s3">\n  </span><span class="s1">/** buildId */</span><span class="s3">\n  </span><span class="s1">b: string</span><span class="s3">\n  </span><span class="s1">/** assetPrefix */</span><span class="s3">\n  </span><span class="s1">p: string</span><span class="s3">\n  </span><span class="s1">/** initialCanonicalUrlParts */</span><span class="s3">\n  </span><span class="s1">c: string[]</span><span class="s3">\n  </span><span class="s1">/** couldBeIntercepted */</span><span class="s3">\n  </span><span class="s1">i: boolean</span><span class="s3">\n  </span><span class="s1">/** initialFlightData */</span><span class="s3">\n  </span><span class="s1">f: FlightDataPath[]</span><span class="s3">\n  </span><span class="s1">/** missingSlots */</span><span class="s3">\n  </span><span class="s1">m: Set&lt;string&gt; | undefined</span><span class="s3">\n  </span><span class="s1">/** GlobalError */</span><span class="s3">\n  </span><span class="s1">G: [React.ComponentType&lt;any&gt;, React.ReactNode | undefined]</span><span class="s3">\n  </span><span class="s1">/** postponed */</span><span class="s3">\n  </span><span class="s1">s: boolean</span><span class="s3">\n  </span><span class="s1">/** prerendered */</span><span class="s3">\n  </span><span class="s1">S: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Response from `createFromFetch` for normal rendering</span><span class="s3">\n</span><span class="s1">export type NavigationFlightResponse = {</span><span class="s3">\n  </span><span class="s1">/** buildId */</span><span class="s3">\n  </span><span class="s1">b: string</span><span class="s3">\n  </span><span class="s1">/** flightData */</span><span class="s3">\n  </span><span class="s1">f: FlightData</span><span class="s3">\n  </span><span class="s1">/** prerendered */</span><span class="s3">\n  </span><span class="s1">S: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Response from `createFromFetch` for server actions. Action's flight data can be null</span><span class="s3">\n</span><span class="s1">export type ActionFlightResponse = {</span><span class="s3">\n  </span><span class="s1">/** actionResult */</span><span class="s3">\n  </span><span class="s1">a: ActionResult</span><span class="s3">\n  </span><span class="s1">/** buildId */</span><span class="s3">\n  </span><span class="s1">b: string</span><span class="s3">\n  </span><span class="s1">/** flightData */</span><span class="s3">\n  </span><span class="s1">f: FlightData</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type RSCPayload =</span><span class="s3">\n  </span><span class="s1">| InitialRSCPayload</span><span class="s3">\n  </span><span class="s1">| NavigationFlightResponse</span><span class="s3">\n  </span><span class="s1">| ActionFlightResponse</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { NEXT_URL } from '../client/components/app-router-headers'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">extractInterceptionRouteInformation,</span><span class="s3">\n  </span><span class="s1">isInterceptionRouteAppPath,</span><span class="s3">\n</span><span class="s1">} from '../shared/lib/router/utils/interception-routes'</span><span class="s3">\n</span><span class="s1">import type { Rewrite } from './load-custom-routes'</span><span class="s3">\n</span><span class="s1">import { safePathToRegexp } from '../shared/lib/router/utils/route-match-utils'</span><span class="s3">\n</span><span class="s1">import type { DeepReadonly } from '../shared/lib/deep-readonly'</span><span class="s3">\n\n</span><span class="s1">// a function that converts normalised paths (e.g. /foo/[bar]/[baz]) to the format expected by pathToRegexp (e.g. /foo/:bar/:baz)</span><span class="s3">\n</span><span class="s1">function toPathToRegexpPath(path: string): string {</span><span class="s3">\n  </span><span class="s1">return path.replace(/</span><span class="s3">\\</span><span class="s1">[</span><span class="s3">\\</span><span class="s1">[?([^</span><span class="s3">\\</span><span class="s1">]]+)</span><span class="s3">\\</span><span class="s1">]</span><span class="s3">\\</span><span class="s1">]?/g, (_, capture) =&gt; {</span><span class="s3">\n    </span><span class="s1">// path-to-regexp only supports word characters, so we replace any non-word characters with underscores</span><span class="s3">\n    </span><span class="s1">const paramName = capture.replace(/</span><span class="s3">\\</span><span class="s1">W+/g, '_')</span><span class="s3">\n\n    </span><span class="s1">// handle catch-all segments (e.g. /foo/bar/[...baz] or /foo/bar/[[...baz]])</span><span class="s3">\n    </span><span class="s1">if (capture.startsWith('...')) {</span><span class="s3">\n      </span><span class="s1">return `:${capture.slice(3)}*`</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return ':' + paramName</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function generateInterceptionRoutesRewrites(</span><span class="s3">\n  </span><span class="s1">appPaths: string[],</span><span class="s3">\n  </span><span class="s1">basePath = ''</span><span class="s3">\n</span><span class="s1">): Rewrite[] {</span><span class="s3">\n  </span><span class="s1">const rewrites: Rewrite[] = []</span><span class="s3">\n\n  </span><span class="s1">for (const appPath of appPaths) {</span><span class="s3">\n    </span><span class="s1">if (isInterceptionRouteAppPath(appPath)) {</span><span class="s3">\n      </span><span class="s1">const { interceptingRoute, interceptedRoute } =</span><span class="s3">\n        </span><span class="s1">extractInterceptionRouteInformation(appPath)</span><span class="s3">\n\n      </span><span class="s1">const normalizedInterceptingRoute = `${</span><span class="s3">\n        </span><span class="s1">interceptingRoute !== '/' ? toPathToRegexpPath(interceptingRoute) : ''</span><span class="s3">\n      </span><span class="s1">}/(.*)?`</span><span class="s3">\n\n      </span><span class="s1">const normalizedInterceptedRoute = toPathToRegexpPath(interceptedRoute)</span><span class="s3">\n      </span><span class="s1">const normalizedAppPath = toPathToRegexpPath(appPath)</span><span class="s3">\n\n      </span><span class="s1">// pathToRegexp returns a regex that matches the path, but we need to</span><span class="s3">\n      </span><span class="s1">// convert it to a string that can be used in a header value</span><span class="s3">\n      </span><span class="s1">// to the format that Next/the proxy expects</span><span class="s3">\n      </span><span class="s1">let interceptingRouteRegex = safePathToRegexp(normalizedInterceptingRoute)</span><span class="s3">\n        </span><span class="s1">.toString()</span><span class="s3">\n        </span><span class="s1">.slice(2, -3)</span><span class="s3">\n\n      </span><span class="s1">rewrites.push({</span><span class="s3">\n        </span><span class="s1">source: `${basePath}${normalizedInterceptedRoute}`,</span><span class="s3">\n        </span><span class="s1">destination: `${basePath}${normalizedAppPath}`,</span><span class="s3">\n        </span><span class="s1">has: [</span><span class="s3">\n          </span><span class="s1">{</span><span class="s3">\n            </span><span class="s1">type: 'header',</span><span class="s3">\n            </span><span class="s1">key: NEXT_URL,</span><span class="s3">\n            </span><span class="s1">value: interceptingRouteRegex,</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">],</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return rewrites</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isInterceptionRouteRewrite(route: DeepReadonly&lt;Rewrite&gt;) {</span><span class="s3">\n  </span><span class="s1">// When we generate interception rewrites in the above implementation, we always do so with only a single `has` condition.</span><span class="s3">\n  </span><span class="s1">return route.has?.[0]?.key === NEXT_URL</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export const RSC_HEADER = 'rsc' as const</span><span class="s3">\n</span><span class="s1">export const ACTION_HEADER = 'next-action' as const</span><span class="s3">\n</span><span class="s1">// TODO: Instead of sending the full router state, we only need to send the</span><span class="s3">\n</span><span class="s1">// segment path. Saves bytes. Then we could also use this field for segment</span><span class="s3">\n</span><span class="s1">// prefetches, which also need to specify a particular segment.</span><span class="s3">\n</span><span class="s1">export const NEXT_ROUTER_STATE_TREE_HEADER = 'next-router-state-tree' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_ROUTER_PREFETCH_HEADER = 'next-router-prefetch' as const</span><span class="s3">\n</span><span class="s1">// This contains the path to the segment being prefetched.</span><span class="s3">\n</span><span class="s1">// TODO: If we change next-router-state-tree to be a segment path, we can use</span><span class="s3">\n</span><span class="s1">// that instead. Then next-router-prefetch and next-router-segment-prefetch can</span><span class="s3">\n</span><span class="s1">// be merged into a single enum.</span><span class="s3">\n</span><span class="s1">export const NEXT_ROUTER_SEGMENT_PREFETCH_HEADER =</span><span class="s3">\n  </span><span class="s1">'next-router-segment-prefetch' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_HMR_REFRESH_HEADER = 'next-hmr-refresh' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_HMR_REFRESH_HASH_COOKIE = '__next_hmr_refresh_hash__' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_URL = 'next-url' as const</span><span class="s3">\n</span><span class="s1">export const RSC_CONTENT_TYPE_HEADER = 'text/x-component' as const</span><span class="s3">\n\n</span><span class="s1">export const FLIGHT_HEADERS = [</span><span class="s3">\n  </span><span class="s1">RSC_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_STATE_TREE_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_PREFETCH_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_HMR_REFRESH_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,</span><span class="s3">\n</span><span class="s1">] as const</span><span class="s3">\n\n</span><span class="s1">export const NEXT_RSC_UNION_QUERY = '_rsc' as const</span><span class="s3">\n\n</span><span class="s1">export const NEXT_ROUTER_STALE_TIME_HEADER = 'x-nextjs-stale-time' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_DID_POSTPONE_HEADER = 'x-nextjs-postponed' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_REWRITTEN_PATH_HEADER = 'x-nextjs-rewritten-path' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_REWRITTEN_QUERY_HEADER = 'x-nextjs-rewritten-query' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_IS_PRERENDER_HEADER = 'x-nextjs-prerender' as const</span><span class="s3">\n</span><span class="s1">export const NEXT_ACTION_NOT_FOUND_HEADER = 'x-nextjs-action-not-found' as const</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { Rewrite } from '../lib/load-custom-routes'</span><span class="s3">\n</span><span class="s1">import type { RouteMatchFn } from '../shared/lib/router/utils/route-matcher'</span><span class="s3">\n</span><span class="s1">import type { NextConfig } from './config'</span><span class="s3">\n</span><span class="s1">import type { BaseNextRequest } from './base-http'</span><span class="s3">\n</span><span class="s1">import type { ParsedUrlQuery } from 'querystring'</span><span class="s3">\n</span><span class="s1">import type { UrlWithParsedQuery } from 'url'</span><span class="s3">\n\n</span><span class="s1">import { normalizeLocalePath } from '../shared/lib/i18n/normalize-locale-path'</span><span class="s3">\n</span><span class="s1">import { getPathMatch } from '../shared/lib/router/utils/path-match'</span><span class="s3">\n</span><span class="s1">import { getNamedRouteRegex } from '../shared/lib/router/utils/route-regex'</span><span class="s3">\n</span><span class="s1">import { getRouteMatcher } from '../shared/lib/router/utils/route-matcher'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">matchHas,</span><span class="s3">\n  </span><span class="s1">prepareDestination,</span><span class="s3">\n</span><span class="s1">} from '../shared/lib/router/utils/prepare-destination'</span><span class="s3">\n</span><span class="s1">import { removeTrailingSlash } from '../shared/lib/router/utils/remove-trailing-slash'</span><span class="s3">\n</span><span class="s1">import { normalizeRscURL } from '../shared/lib/router/utils/app-paths'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_CACHE_REVALIDATED_TAGS_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_INTERCEPTION_MARKER_PREFIX,</span><span class="s3">\n  </span><span class="s1">NEXT_QUERY_PARAM_PREFIX,</span><span class="s3">\n</span><span class="s1">} from '../lib/constants'</span><span class="s3">\n</span><span class="s1">import { normalizeNextQueryParam } from './web/utils'</span><span class="s3">\n</span><span class="s1">import type { IncomingHttpHeaders, IncomingMessage } from 'http'</span><span class="s3">\n</span><span class="s1">import { decodeQueryPathParameter } from './lib/decode-query-path-parameter'</span><span class="s3">\n</span><span class="s1">import type { DeepReadonly } from '../shared/lib/deep-readonly'</span><span class="s3">\n</span><span class="s1">import { parseReqUrl } from '../lib/url'</span><span class="s3">\n</span><span class="s1">import { formatUrl } from '../shared/lib/router/utils/format-url'</span><span class="s3">\n</span><span class="s1">import { parseAndValidateFlightRouterState } from './app-render/parse-and-validate-flight-router-state'</span><span class="s3">\n</span><span class="s1">import { isInterceptionRouteRewrite } from '../lib/generate-interception-routes-rewrites'</span><span class="s3">\n</span><span class="s1">import { NEXT_ROUTER_STATE_TREE_HEADER } from '../client/components/app-router-headers'</span><span class="s3">\n</span><span class="s1">import { getSelectedParams } from '../client/components/router-reducer/compute-changed-path'</span><span class="s3">\n\n</span><span class="s1">function filterInternalQuery(</span><span class="s3">\n  </span><span class="s1">query: Record&lt;string, undefined | string | string[]&gt;,</span><span class="s3">\n  </span><span class="s1">paramKeys: string[]</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// this is used to pass query information in rewrites</span><span class="s3">\n  </span><span class="s1">// but should not be exposed in final query</span><span class="s3">\n  </span><span class="s1">delete query['nextInternalLocale']</span><span class="s3">\n\n  </span><span class="s1">for (const key in query) {</span><span class="s3">\n    </span><span class="s1">const isNextQueryPrefix =</span><span class="s3">\n      </span><span class="s1">key !== NEXT_QUERY_PARAM_PREFIX &amp;&amp; key.startsWith(NEXT_QUERY_PARAM_PREFIX)</span><span class="s3">\n\n    </span><span class="s1">const isNextInterceptionMarkerPrefix =</span><span class="s3">\n      </span><span class="s1">key !== NEXT_INTERCEPTION_MARKER_PREFIX &amp;&amp;</span><span class="s3">\n      </span><span class="s1">key.startsWith(NEXT_INTERCEPTION_MARKER_PREFIX)</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">isNextQueryPrefix ||</span><span class="s3">\n      </span><span class="s1">isNextInterceptionMarkerPrefix ||</span><span class="s3">\n      </span><span class="s1">paramKeys.includes(key)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">delete query[key]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function normalizeCdnUrl(</span><span class="s3">\n  </span><span class="s1">req: BaseNextRequest | IncomingMessage,</span><span class="s3">\n  </span><span class="s1">paramKeys: string[]</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// make sure to normalize req.url from CDNs to strip dynamic and rewrite</span><span class="s3">\n  </span><span class="s1">// params from the query which are added during routing</span><span class="s3">\n  </span><span class="s1">const _parsedUrl = parseReqUrl(req.url!)</span><span class="s3">\n\n  </span><span class="s1">// we can't normalize if we can't parse</span><span class="s3">\n  </span><span class="s1">if (!_parsedUrl) {</span><span class="s3">\n    </span><span class="s1">return req.url</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">delete (_parsedUrl as any).search</span><span class="s3">\n  </span><span class="s1">filterInternalQuery(_parsedUrl.query, paramKeys)</span><span class="s3">\n\n  </span><span class="s1">req.url = formatUrl(_parsedUrl)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function interpolateDynamicPath(</span><span class="s3">\n  </span><span class="s1">pathname: string,</span><span class="s3">\n  </span><span class="s1">params: ParsedUrlQuery,</span><span class="s3">\n  </span><span class="s1">defaultRouteRegex?: ReturnType&lt;typeof getNamedRouteRegex&gt; | undefined</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (!defaultRouteRegex) return pathname</span><span class="s3">\n\n  </span><span class="s1">for (const param of Object.keys(defaultRouteRegex.groups)) {</span><span class="s3">\n    </span><span class="s1">const { optional, repeat } = defaultRouteRegex.groups[param]</span><span class="s3">\n    </span><span class="s1">let builtParam = `[${repeat ? '...' : ''}${param}]`</span><span class="s3">\n\n    </span><span class="s1">if (optional) {</span><span class="s3">\n      </span><span class="s1">builtParam = `[${builtParam}]`</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let paramValue: string</span><span class="s3">\n    </span><span class="s1">const value = params[param]</span><span class="s3">\n\n    </span><span class="s1">if (Array.isArray(value)) {</span><span class="s3">\n      </span><span class="s1">paramValue = value.map((v) =&gt; v &amp;&amp; encodeURIComponent(v)).join('/')</span><span class="s3">\n    </span><span class="s1">} else if (value) {</span><span class="s3">\n      </span><span class="s1">paramValue = encodeURIComponent(value)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">paramValue = ''</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (paramValue || optional) {</span><span class="s3">\n      </span><span class="s1">pathname = pathname.replaceAll(builtParam, paramValue)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return pathname</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function normalizeDynamicRouteParams(</span><span class="s3">\n  </span><span class="s1">query: ParsedUrlQuery,</span><span class="s3">\n  </span><span class="s1">defaultRouteRegex: ReturnType&lt;typeof getNamedRouteRegex&gt;,</span><span class="s3">\n  </span><span class="s1">defaultRouteMatches: ParsedUrlQuery,</span><span class="s3">\n  </span><span class="s1">ignoreMissingOptional: boolean</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">let hasValidParams = true</span><span class="s3">\n  </span><span class="s1">let params: ParsedUrlQuery = {}</span><span class="s3">\n\n  </span><span class="s1">for (const key of Object.keys(defaultRouteRegex.groups)) {</span><span class="s3">\n    </span><span class="s1">let value: string | string[] | undefined = query[key]</span><span class="s3">\n\n    </span><span class="s1">if (typeof value === 'string') {</span><span class="s3">\n      </span><span class="s1">value = normalizeRscURL(value)</span><span class="s3">\n    </span><span class="s1">} else if (Array.isArray(value)) {</span><span class="s3">\n      </span><span class="s1">value = value.map(normalizeRscURL)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// if the value matches the default value we can't rely</span><span class="s3">\n    </span><span class="s1">// on the parsed params, this is used to signal if we need</span><span class="s3">\n    </span><span class="s1">// to parse x-now-route-matches or not</span><span class="s3">\n    </span><span class="s1">const defaultValue = defaultRouteMatches![key]</span><span class="s3">\n    </span><span class="s1">const isOptional = defaultRouteRegex!.groups[key].optional</span><span class="s3">\n\n    </span><span class="s1">const isDefaultValue = Array.isArray(defaultValue)</span><span class="s3">\n      </span><span class="s1">? defaultValue.some((defaultVal) =&gt; {</span><span class="s3">\n          </span><span class="s1">return Array.isArray(value)</span><span class="s3">\n            </span><span class="s1">? value.some((val) =&gt; val.includes(defaultVal))</span><span class="s3">\n            </span><span class="s1">: value?.includes(defaultVal)</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">: value?.includes(defaultValue as string)</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">isDefaultValue ||</span><span class="s3">\n      </span><span class="s1">(typeof value === 'undefined' &amp;&amp; !(isOptional &amp;&amp; ignoreMissingOptional))</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return { params: {}, hasValidParams: false }</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// non-provided optional values should be undefined so normalize</span><span class="s3">\n    </span><span class="s1">// them to undefined</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">isOptional &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(!value ||</span><span class="s3">\n        </span><span class="s1">(Array.isArray(value) &amp;&amp;</span><span class="s3">\n          </span><span class="s1">value.length === 1 &amp;&amp;</span><span class="s3">\n          </span><span class="s1">// fallback optional catch-all SSG pages have</span><span class="s3">\n          </span><span class="s1">// [[...paramName]] for the root path on Vercel</span><span class="s3">\n          </span><span class="s1">(value[0] === 'index' || value[0] === `[[...${key}]]`)))</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">value = undefined</span><span class="s3">\n      </span><span class="s1">delete query[key]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// query values from the proxy aren't already split into arrays</span><span class="s3">\n    </span><span class="s1">// so make sure to normalize catch-all values</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">value &amp;&amp;</span><span class="s3">\n      </span><span class="s1">typeof value === 'string' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">defaultRouteRegex!.groups[key].repeat</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">value = value.split('/')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (value) {</span><span class="s3">\n      </span><span class="s1">params[key] = value</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">params,</span><span class="s3">\n    </span><span class="s1">hasValidParams,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getServerUtils({</span><span class="s3">\n  </span><span class="s1">page,</span><span class="s3">\n  </span><span class="s1">i18n,</span><span class="s3">\n  </span><span class="s1">basePath,</span><span class="s3">\n  </span><span class="s1">rewrites,</span><span class="s3">\n  </span><span class="s1">pageIsDynamic,</span><span class="s3">\n  </span><span class="s1">trailingSlash,</span><span class="s3">\n  </span><span class="s1">caseSensitive,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">page: string</span><span class="s3">\n  </span><span class="s1">i18n?: NextConfig['i18n']</span><span class="s3">\n  </span><span class="s1">basePath: string</span><span class="s3">\n  </span><span class="s1">rewrites: DeepReadonly&lt;{</span><span class="s3">\n    </span><span class="s1">fallback?: ReadonlyArray&lt;Rewrite&gt;</span><span class="s3">\n    </span><span class="s1">afterFiles?: ReadonlyArray&lt;Rewrite&gt;</span><span class="s3">\n    </span><span class="s1">beforeFiles?: ReadonlyArray&lt;Rewrite&gt;</span><span class="s3">\n  </span><span class="s1">}&gt;</span><span class="s3">\n  </span><span class="s1">pageIsDynamic: boolean</span><span class="s3">\n  </span><span class="s1">trailingSlash?: boolean</span><span class="s3">\n  </span><span class="s1">caseSensitive: boolean</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">let defaultRouteRegex: ReturnType&lt;typeof getNamedRouteRegex&gt; | undefined</span><span class="s3">\n  </span><span class="s1">let dynamicRouteMatcher: RouteMatchFn | undefined</span><span class="s3">\n  </span><span class="s1">let defaultRouteMatches: ParsedUrlQuery | undefined</span><span class="s3">\n\n  </span><span class="s1">if (pageIsDynamic) {</span><span class="s3">\n    </span><span class="s1">defaultRouteRegex = getNamedRouteRegex(page, {</span><span class="s3">\n      </span><span class="s1">prefixRouteKeys: false,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">dynamicRouteMatcher = getRouteMatcher(defaultRouteRegex)</span><span class="s3">\n    </span><span class="s1">defaultRouteMatches = dynamicRouteMatcher(page) as ParsedUrlQuery</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function handleRewrites(</span><span class="s3">\n    </span><span class="s1">req: BaseNextRequest | IncomingMessage,</span><span class="s3">\n    </span><span class="s1">parsedUrl: UrlWithParsedQuery</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const rewriteParams: Record&lt;string, string&gt; = {}</span><span class="s3">\n    </span><span class="s1">let fsPathname = parsedUrl.pathname</span><span class="s3">\n\n    </span><span class="s1">const matchesPage = () =&gt; {</span><span class="s3">\n      </span><span class="s1">const fsPathnameNoSlash = removeTrailingSlash(fsPathname || '')</span><span class="s3">\n      </span><span class="s1">return (</span><span class="s3">\n        </span><span class="s1">fsPathnameNoSlash === removeTrailingSlash(page) ||</span><span class="s3">\n        </span><span class="s1">dynamicRouteMatcher?.(fsPathnameNoSlash)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const checkRewrite = (rewrite: DeepReadonly&lt;Rewrite&gt;): boolean =&gt; {</span><span class="s3">\n      </span><span class="s1">const matcher = getPathMatch(</span><span class="s3">\n        </span><span class="s1">rewrite.source + (trailingSlash ? '(/)?' : ''),</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">removeUnnamedParams: true,</span><span class="s3">\n          </span><span class="s1">strict: true,</span><span class="s3">\n          </span><span class="s1">sensitive: !!caseSensitive,</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">if (!parsedUrl.pathname) return false</span><span class="s3">\n\n      </span><span class="s1">let params = matcher(parsedUrl.pathname)</span><span class="s3">\n\n      </span><span class="s1">if ((rewrite.has || rewrite.missing) &amp;&amp; params) {</span><span class="s3">\n        </span><span class="s1">const hasParams = matchHas(</span><span class="s3">\n          </span><span class="s1">req,</span><span class="s3">\n          </span><span class="s1">parsedUrl.query,</span><span class="s3">\n          </span><span class="s1">rewrite.has as Rewrite['has'],</span><span class="s3">\n          </span><span class="s1">rewrite.missing as Rewrite['missing']</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">if (hasParams) {</span><span class="s3">\n          </span><span class="s1">Object.assign(params, hasParams)</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">params = false</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (params) {</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n          </span><span class="s1">// An interception rewrite might reference a dynamic param for a route the user</span><span class="s3">\n          </span><span class="s1">// is currently on, which wouldn't be extractable from the matched route params.</span><span class="s3">\n          </span><span class="s1">// This attempts to extract the dynamic params from the provided router state.</span><span class="s3">\n          </span><span class="s1">if (isInterceptionRouteRewrite(rewrite as Rewrite)) {</span><span class="s3">\n            </span><span class="s1">const stateHeader = req.headers[NEXT_ROUTER_STATE_TREE_HEADER]</span><span class="s3">\n\n            </span><span class="s1">if (stateHeader) {</span><span class="s3">\n              </span><span class="s1">params = {</span><span class="s3">\n                </span><span class="s1">...getSelectedParams(</span><span class="s3">\n                  </span><span class="s1">parseAndValidateFlightRouterState(stateHeader)</span><span class="s3">\n                </span><span class="s1">),</span><span class="s3">\n                </span><span class="s1">...params,</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} catch (err) {</span><span class="s3">\n          </span><span class="s1">// this is a no-op -- we couldn't extract dynamic params from the provided router state,</span><span class="s3">\n          </span><span class="s1">// so we'll just use the params from the route matcher</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const { parsedDestination, destQuery } = prepareDestination({</span><span class="s3">\n          </span><span class="s1">appendParamsToQuery: true,</span><span class="s3">\n          </span><span class="s1">destination: rewrite.destination,</span><span class="s3">\n          </span><span class="s1">params: params,</span><span class="s3">\n          </span><span class="s1">query: parsedUrl.query,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n\n        </span><span class="s1">// if the rewrite destination is external break rewrite chain</span><span class="s3">\n        </span><span class="s1">if (parsedDestination.protocol) {</span><span class="s3">\n          </span><span class="s1">return true</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">Object.assign(rewriteParams, destQuery, params)</span><span class="s3">\n        </span><span class="s1">Object.assign(parsedUrl.query, parsedDestination.query)</span><span class="s3">\n        </span><span class="s1">delete (parsedDestination as any).query</span><span class="s3">\n\n        </span><span class="s1">// for each property in parsedUrl.query, if the value is parametrized (eg :foo), look up the value</span><span class="s3">\n        </span><span class="s1">// in rewriteParams and replace the parametrized value with the actual value</span><span class="s3">\n        </span><span class="s1">// this is used when the rewrite destination does not contain the original source param</span><span class="s3">\n        </span><span class="s1">// and so the value is still parametrized and needs to be replaced with the actual rewrite param</span><span class="s3">\n        </span><span class="s1">Object.entries(parsedUrl.query).forEach(([key, value]) =&gt; {</span><span class="s3">\n          </span><span class="s1">if (value &amp;&amp; typeof value === 'string' &amp;&amp; value.startsWith(':')) {</span><span class="s3">\n            </span><span class="s1">const paramName = value.slice(1)</span><span class="s3">\n            </span><span class="s1">const actualValue = rewriteParams[paramName]</span><span class="s3">\n            </span><span class="s1">if (actualValue) {</span><span class="s3">\n              </span><span class="s1">parsedUrl.query[key] = actualValue</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n\n        </span><span class="s1">Object.assign(parsedUrl, parsedDestination)</span><span class="s3">\n\n        </span><span class="s1">fsPathname = parsedUrl.pathname</span><span class="s3">\n        </span><span class="s1">if (!fsPathname) return false</span><span class="s3">\n\n        </span><span class="s1">if (basePath) {</span><span class="s3">\n          </span><span class="s1">fsPathname = fsPathname.replace(new RegExp(`^${basePath}`), '') || '/'</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (i18n) {</span><span class="s3">\n          </span><span class="s1">const result = normalizeLocalePath(fsPathname, i18n.locales)</span><span class="s3">\n          </span><span class="s1">fsPathname = result.pathname</span><span class="s3">\n          </span><span class="s1">parsedUrl.query.nextInternalLocale =</span><span class="s3">\n            </span><span class="s1">result.detectedLocale || params.nextInternalLocale</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (fsPathname === page) {</span><span class="s3">\n          </span><span class="s1">return true</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (pageIsDynamic &amp;&amp; dynamicRouteMatcher) {</span><span class="s3">\n          </span><span class="s1">const dynamicParams = dynamicRouteMatcher(fsPathname)</span><span class="s3">\n          </span><span class="s1">if (dynamicParams) {</span><span class="s3">\n            </span><span class="s1">parsedUrl.query = {</span><span class="s3">\n              </span><span class="s1">...parsedUrl.query,</span><span class="s3">\n              </span><span class="s1">...dynamicParams,</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return true</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const rewrite of rewrites.beforeFiles || []) {</span><span class="s3">\n      </span><span class="s1">checkRewrite(rewrite)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (fsPathname !== page) {</span><span class="s3">\n      </span><span class="s1">let finished = false</span><span class="s3">\n\n      </span><span class="s1">for (const rewrite of rewrites.afterFiles || []) {</span><span class="s3">\n        </span><span class="s1">finished = checkRewrite(rewrite)</span><span class="s3">\n        </span><span class="s1">if (finished) break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (!finished &amp;&amp; !matchesPage()) {</span><span class="s3">\n        </span><span class="s1">for (const rewrite of rewrites.fallback || []) {</span><span class="s3">\n          </span><span class="s1">finished = checkRewrite(rewrite)</span><span class="s3">\n          </span><span class="s1">if (finished) break</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return rewriteParams</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function getParamsFromRouteMatches(routeMatchesHeader: string) {</span><span class="s3">\n    </span><span class="s1">// If we don't have a default route regex, we can't get params from route</span><span class="s3">\n    </span><span class="s1">// matches</span><span class="s3">\n    </span><span class="s1">if (!defaultRouteRegex) return null</span><span class="s3">\n\n    </span><span class="s1">const { groups, routeKeys } = defaultRouteRegex</span><span class="s3">\n\n    </span><span class="s1">const matcher = getRouteMatcher({</span><span class="s3">\n      </span><span class="s1">re: {</span><span class="s3">\n        </span><span class="s1">// Simulate a RegExp match from the </span><span class="s3">\\</span><span class="s1">`req.url</span><span class="s3">\\</span><span class="s1">` input</span><span class="s3">\n        </span><span class="s1">exec: (str: string) =&gt; {</span><span class="s3">\n          </span><span class="s1">// Normalize all the prefixed query params.</span><span class="s3">\n          </span><span class="s1">const obj: Record&lt;string, string&gt; = Object.fromEntries(</span><span class="s3">\n            </span><span class="s1">new URLSearchParams(str)</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">for (const [key, value] of Object.entries(obj)) {</span><span class="s3">\n            </span><span class="s1">const normalizedKey = normalizeNextQueryParam(key)</span><span class="s3">\n            </span><span class="s1">if (!normalizedKey) continue</span><span class="s3">\n\n            </span><span class="s1">obj[normalizedKey] = value</span><span class="s3">\n            </span><span class="s1">delete obj[key]</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">// Use all the named route keys.</span><span class="s3">\n          </span><span class="s1">const result = {} as RegExpExecArray</span><span class="s3">\n          </span><span class="s1">for (const keyName of Object.keys(routeKeys)) {</span><span class="s3">\n            </span><span class="s1">const paramName = routeKeys[keyName]</span><span class="s3">\n\n            </span><span class="s1">// If this param name is not a valid parameter name, then skip it.</span><span class="s3">\n            </span><span class="s1">if (!paramName) continue</span><span class="s3">\n\n            </span><span class="s1">const group = groups[paramName]</span><span class="s3">\n            </span><span class="s1">const value = obj[keyName]</span><span class="s3">\n\n            </span><span class="s1">// When we're missing a required param, we can't match the route.</span><span class="s3">\n            </span><span class="s1">if (!group.optional &amp;&amp; !value) return null</span><span class="s3">\n\n            </span><span class="s1">result[group.pos] = value</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">return result</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">groups,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">const routeMatches = matcher(routeMatchesHeader)</span><span class="s3">\n    </span><span class="s1">if (!routeMatches) return null</span><span class="s3">\n\n    </span><span class="s1">return routeMatches</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function normalizeQueryParams(</span><span class="s3">\n    </span><span class="s1">query: Record&lt;string, string | string[] | undefined&gt;,</span><span class="s3">\n    </span><span class="s1">routeParamKeys: Set&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">// this is used to pass query information in rewrites</span><span class="s3">\n    </span><span class="s1">// but should not be exposed in final query</span><span class="s3">\n    </span><span class="s1">delete query['nextInternalLocale']</span><span class="s3">\n\n    </span><span class="s1">for (const [key, value] of Object.entries(query)) {</span><span class="s3">\n      </span><span class="s1">const normalizedKey = normalizeNextQueryParam(key)</span><span class="s3">\n      </span><span class="s1">if (!normalizedKey) continue</span><span class="s3">\n\n      </span><span class="s1">// Remove the prefixed key from the query params because we want</span><span class="s3">\n      </span><span class="s1">// to consume it for the dynamic route matcher.</span><span class="s3">\n      </span><span class="s1">delete query[key]</span><span class="s3">\n      </span><span class="s1">routeParamKeys.add(normalizedKey)</span><span class="s3">\n\n      </span><span class="s1">if (typeof value === 'undefined') continue</span><span class="s3">\n\n      </span><span class="s1">query[normalizedKey] = Array.isArray(value)</span><span class="s3">\n        </span><span class="s1">? value.map((v) =&gt; decodeQueryPathParameter(v))</span><span class="s3">\n        </span><span class="s1">: decodeQueryPathParameter(value)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">handleRewrites,</span><span class="s3">\n    </span><span class="s1">defaultRouteRegex,</span><span class="s3">\n    </span><span class="s1">dynamicRouteMatcher,</span><span class="s3">\n    </span><span class="s1">defaultRouteMatches,</span><span class="s3">\n    </span><span class="s1">normalizeQueryParams,</span><span class="s3">\n    </span><span class="s1">getParamsFromRouteMatches,</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Normalize dynamic route params.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param query - The query params to normalize.</span><span class="s3">\n     </span><span class="s1">* @param ignoreMissingOptional - Whether to ignore missing optional params.</span><span class="s3">\n     </span><span class="s1">* @returns The normalized params and whether they are valid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">normalizeDynamicRouteParams: (</span><span class="s3">\n      </span><span class="s1">query: ParsedUrlQuery,</span><span class="s3">\n      </span><span class="s1">ignoreMissingOptional: boolean</span><span class="s3">\n    </span><span class="s1">) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (!defaultRouteRegex || !defaultRouteMatches) {</span><span class="s3">\n        </span><span class="s1">return { params: {}, hasValidParams: false }</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return normalizeDynamicRouteParams(</span><span class="s3">\n        </span><span class="s1">query,</span><span class="s3">\n        </span><span class="s1">defaultRouteRegex,</span><span class="s3">\n        </span><span class="s1">defaultRouteMatches,</span><span class="s3">\n        </span><span class="s1">ignoreMissingOptional</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">normalizeCdnUrl: (</span><span class="s3">\n      </span><span class="s1">req: BaseNextRequest | IncomingMessage,</span><span class="s3">\n      </span><span class="s1">paramKeys: string[]</span><span class="s3">\n    </span><span class="s1">) =&gt; normalizeCdnUrl(req, paramKeys),</span><span class="s3">\n\n    </span><span class="s1">interpolateDynamicPath: (</span><span class="s3">\n      </span><span class="s1">pathname: string,</span><span class="s3">\n      </span><span class="s1">params: Record&lt;string, undefined | string | string[]&gt;</span><span class="s3">\n    </span><span class="s1">) =&gt; interpolateDynamicPath(pathname, params, defaultRouteRegex),</span><span class="s3">\n\n    </span><span class="s1">filterInternalQuery: (query: ParsedUrlQuery, paramKeys: string[]) =&gt;</span><span class="s3">\n      </span><span class="s1">filterInternalQuery(query, paramKeys),</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getPreviouslyRevalidatedTags(</span><span class="s3">\n  </span><span class="s1">headers: IncomingHttpHeaders,</span><span class="s3">\n  </span><span class="s1">previewModeId: string | undefined</span><span class="s3">\n</span><span class="s1">): string[] {</span><span class="s3">\n  </span><span class="s1">return typeof headers[NEXT_CACHE_REVALIDATED_TAGS_HEADER] === 'string' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">headers[NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER] === previewModeId</span><span class="s3">\n    </span><span class="s1">? headers[NEXT_CACHE_REVALIDATED_TAGS_HEADER].split(',')</span><span class="s3">\n    </span><span class="s1">: []</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { DomainLocale } from '../../../server/config-shared'</span><span class="s3">\n\n</span><span class="s1">export function detectDomainLocale(</span><span class="s3">\n  </span><span class="s1">domainItems?: readonly DomainLocale[],</span><span class="s3">\n  </span><span class="s1">hostname?: string,</span><span class="s3">\n  </span><span class="s1">detectedLocale?: string</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">if (!domainItems) return</span><span class="s3">\n\n  </span><span class="s1">if (detectedLocale) {</span><span class="s3">\n    </span><span class="s1">detectedLocale = detectedLocale.toLowerCase()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const item of domainItems) {</span><span class="s3">\n    </span><span class="s1">// remove port if present</span><span class="s3">\n    </span><span class="s1">const domainHostname = item.domain?.split(':', 1)[0].toLowerCase()</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">hostname === domainHostname ||</span><span class="s3">\n      </span><span class="s1">detectedLocale === item.defaultLocale.toLowerCase() ||</span><span class="s3">\n      </span><span class="s1">item.locales?.some((locale) =&gt; locale.toLowerCase() === detectedLocale)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return item</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { OutgoingHttpHeaders } from 'http'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Takes an object with a hostname property (like a parsed URL) and some</span><span class="s3">\n </span><span class="s1">* headers that may contain Host and returns the preferred hostname.</span><span class="s3">\n </span><span class="s1">* @param parsed An object containing a hostname property.</span><span class="s3">\n </span><span class="s1">* @param headers A dictionary with headers containing a `host`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getHostname(</span><span class="s3">\n  </span><span class="s1">parsed: { hostname?: string | null },</span><span class="s3">\n  </span><span class="s1">headers?: OutgoingHttpHeaders</span><span class="s3">\n</span><span class="s1">): string | undefined {</span><span class="s3">\n  </span><span class="s1">// Get the hostname from the headers if it exists, otherwise use the parsed</span><span class="s3">\n  </span><span class="s1">// hostname.</span><span class="s3">\n  </span><span class="s1">let hostname: string</span><span class="s3">\n  </span><span class="s1">if (headers?.host &amp;&amp; !Array.isArray(headers.host)) {</span><span class="s3">\n    </span><span class="s1">hostname = headers.host.toString().split(':', 1)[0]</span><span class="s3">\n  </span><span class="s1">} else if (parsed.hostname) {</span><span class="s3">\n    </span><span class="s1">hostname = parsed.hostname</span><span class="s3">\n  </span><span class="s1">} else return</span><span class="s3">\n\n  </span><span class="s1">return hostname.toLowerCase()</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { pathHasPrefix } from '../router/utils/path-has-prefix'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* strip _next/data/&lt;build-id&gt;/ prefix and .json suffix</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function normalizeDataPath(pathname: string) {</span><span class="s3">\n  </span><span class="s1">if (!pathHasPrefix(pathname || '/', '/_next/data')) {</span><span class="s3">\n    </span><span class="s1">return pathname</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">pathname = pathname</span><span class="s3">\n    </span><span class="s1">.replace(/</span><span class="s3">\\</span><span class="s1">/_next</span><span class="s3">\\</span><span class="s1">/data</span><span class="s3">\\</span><span class="s1">/[^/]{1,}/, '')</span><span class="s3">\n    </span><span class="s1">.replace(/</span><span class="s3">\\</span><span class="s1">.json$/, '')</span><span class="s3">\n\n  </span><span class="s1">if (pathname === '/index') {</span><span class="s3">\n    </span><span class="s1">return '/'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return pathname</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/* eslint-disable no-redeclare */</span><span class="s3">\n</span><span class="s1">import type { IncomingMessage } from 'http'</span><span class="s3">\n</span><span class="s1">import type { ParsedUrlQuery } from 'querystring'</span><span class="s3">\n</span><span class="s1">import type { UrlWithParsedQuery } from 'url'</span><span class="s3">\n</span><span class="s1">import type { BaseNextRequest } from './base-http'</span><span class="s3">\n</span><span class="s1">import type { CloneableBody } from './body-streams'</span><span class="s3">\n</span><span class="s1">import type { RouteMatch } from './route-matches/route-match'</span><span class="s3">\n</span><span class="s1">import type { NEXT_RSC_UNION_QUERY } from '../client/components/app-router-headers'</span><span class="s3">\n</span><span class="s1">import type { ServerComponentsHmrCache } from './response-cache'</span><span class="s3">\n</span><span class="s1">import type { PagesDevOverlayBridgeType } from '../next-devtools/userspace/pages/pages-dev-overlay-setup'</span><span class="s3">\n\n</span><span class="s1">// FIXME: (wyattjoh) this is a temporary solution to allow us to pass data between bundled modules</span><span class="s3">\n</span><span class="s1">export const NEXT_REQUEST_META = Symbol.for('NextInternalRequestMeta')</span><span class="s3">\n\n</span><span class="s1">export type NextIncomingMessage = (BaseNextRequest | IncomingMessage) &amp; {</span><span class="s3">\n  </span><span class="s1">[NEXT_REQUEST_META]?: RequestMeta</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface RequestMeta {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The query that was used to make the request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">initQuery?: ParsedUrlQuery</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The URL that was used to make the request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">initURL?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The protocol that was used to make the request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">initProtocol?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The body that was read from the request. This is used to allow the body to</span><span class="s3">\n   </span><span class="s1">* be read multiple times.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">clonableBody?: CloneableBody</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True when the request matched a locale domain that was configured in the</span><span class="s3">\n   </span><span class="s1">* next.config.js file.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isLocaleDomain?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True when the request had locale information stripped from the pathname</span><span class="s3">\n   </span><span class="s1">* part of the URL.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">didStripLocale?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* If the request had it's URL rewritten, this is the URL it was rewritten to.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">rewroteURL?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The cookies that were added by middleware and were added to the response.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">middlewareCookie?: string[]</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The match on the request for a given route.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">match?: RouteMatch</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The incremental cache to use for the request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">incrementalCache?: any</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The server components HMR cache, only for dev.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">serverComponentsHmrCache?: ServerComponentsHmrCache</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Equals the segment path that was used for the prefetch RSC request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">segmentPrefetchRSCRequest?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True when the request is for the prefetch flight data.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isPrefetchRSCRequest?: true</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True when the request is for the flight data.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isRSCRequest?: true</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A search param set by the Next.js client when performing RSC requests.</span><span class="s3">\n   </span><span class="s1">* Because some CDNs do not vary their cache entries on our custom headers,</span><span class="s3">\n   </span><span class="s1">* this search param represents a hash of the header values. For any cached</span><span class="s3">\n   </span><span class="s1">* RSC request, we should verify that the hash matches before responding.</span><span class="s3">\n   </span><span class="s1">* Otherwise this can lead to cache poisoning.</span><span class="s3">\n   </span><span class="s1">* TODO: Consider not using custom request headers at all, and instead encode</span><span class="s3">\n   </span><span class="s1">* everything into the search param.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">cacheBustingSearchParam?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True when the request is for the `/_next/data` route using the pages</span><span class="s3">\n   </span><span class="s1">* router.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isNextDataReq?: true</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Postponed state to use for resumption. If present it's assumed that the</span><span class="s3">\n   </span><span class="s1">* request is for a page that has postponed (there are no guarantees that the</span><span class="s3">\n   </span><span class="s1">* page actually has postponed though as it would incur an additional cache</span><span class="s3">\n   </span><span class="s1">* lookup).</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">postponed?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* If provided, this will be called when a response cache entry was generated</span><span class="s3">\n   </span><span class="s1">* or looked up in the cache.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">onCacheEntry?: (</span><span class="s3">\n    </span><span class="s1">cacheEntry: any,</span><span class="s3">\n    </span><span class="s1">requestMeta: any</span><span class="s3">\n  </span><span class="s1">) =&gt; Promise&lt;boolean | void&gt; | boolean | void</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The previous revalidate before rendering 404 page for notFound: true</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">notFoundRevalidate?: number | false</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* In development, the original source page that returned a 404.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">developmentNotFoundSourcePage?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The path we routed to and should be invoked</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">invokePath?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The specific page output we should be matching</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">invokeOutput?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The status we are invoking the request with from routing</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">invokeStatus?: number</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The routing error we are invoking with</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">invokeError?: Error</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The query parsed for the invocation</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">invokeQuery?: Record&lt;string, undefined | string | string[]&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether the request is a middleware invocation</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">middlewareInvoke?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether the request should render the fallback shell or not.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">renderFallbackShell?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether the request is for the custom error page.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">customErrorRender?: true</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether to bubble up the NoFallbackError to the caller when a 404 is</span><span class="s3">\n   </span><span class="s1">* returned.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">bubbleNoFallback?: true</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True when the request had locale information inferred from the default</span><span class="s3">\n   </span><span class="s1">* locale.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">localeInferredFromDefault?: true</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The locale that was inferred or explicitly set for the request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">locale?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The default locale that was inferred or explicitly set for the request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">defaultLocale?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The relative project dir the server is running in from project root</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">relativeProjectDir?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The dist directory the server is currently using</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">distDir?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The query after resolving routes</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">query?: ParsedUrlQuery</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The params after resolving routes</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">params?: ParsedUrlQuery</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The AMP validator to use in development</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">ampValidator?: (html: string, pathname: string) =&gt; Promise&lt;void&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* ErrorOverlay component to use in development for pages router</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">PagesErrorDebug?: PagesDevOverlayBridgeType</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether server is in minimal mode (this will be replaced with more</span><span class="s3">\n   </span><span class="s1">* specific flags in future)</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">minimalMode?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* DEV only: The fallback params that should be used when validating prerenders during dev</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">devValidatingFallbackParams?: Map&lt;string, string&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Gets the request metadata. If no key is provided, the entire metadata object</span><span class="s3">\n </span><span class="s1">* is returned.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param req the request to get the metadata from</span><span class="s3">\n </span><span class="s1">* @param key the key to get from the metadata (optional)</span><span class="s3">\n </span><span class="s1">* @returns the value for the key or the entire metadata object</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getRequestMeta(</span><span class="s3">\n  </span><span class="s1">req: NextIncomingMessage,</span><span class="s3">\n  </span><span class="s1">key?: undefined</span><span class="s3">\n</span><span class="s1">): RequestMeta</span><span class="s3">\n</span><span class="s1">export function getRequestMeta&lt;K extends keyof RequestMeta&gt;(</span><span class="s3">\n  </span><span class="s1">req: NextIncomingMessage,</span><span class="s3">\n  </span><span class="s1">key: K</span><span class="s3">\n</span><span class="s1">): RequestMeta[K]</span><span class="s3">\n</span><span class="s1">export function getRequestMeta&lt;K extends keyof RequestMeta&gt;(</span><span class="s3">\n  </span><span class="s1">req: NextIncomingMessage,</span><span class="s3">\n  </span><span class="s1">key?: K</span><span class="s3">\n</span><span class="s1">): RequestMeta | RequestMeta[K] {</span><span class="s3">\n  </span><span class="s1">const meta = req[NEXT_REQUEST_META] || {}</span><span class="s3">\n  </span><span class="s1">return typeof key === 'string' ? meta[key] : meta</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Sets the request metadata.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param req the request to set the metadata on</span><span class="s3">\n </span><span class="s1">* @param meta the metadata to set</span><span class="s3">\n </span><span class="s1">* @returns the mutated request metadata</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function setRequestMeta(req: NextIncomingMessage, meta: RequestMeta) {</span><span class="s3">\n  </span><span class="s1">req[NEXT_REQUEST_META] = meta</span><span class="s3">\n  </span><span class="s1">return meta</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Adds a value to the request metadata.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param request the request to mutate</span><span class="s3">\n </span><span class="s1">* @param key the key to set</span><span class="s3">\n </span><span class="s1">* @param value the value to set</span><span class="s3">\n </span><span class="s1">* @returns the mutated request metadata</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function addRequestMeta&lt;K extends keyof RequestMeta&gt;(</span><span class="s3">\n  </span><span class="s1">request: NextIncomingMessage,</span><span class="s3">\n  </span><span class="s1">key: K,</span><span class="s3">\n  </span><span class="s1">value: RequestMeta[K]</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const meta = getRequestMeta(request)</span><span class="s3">\n  </span><span class="s1">meta[key] = value</span><span class="s3">\n  </span><span class="s1">return setRequestMeta(request, meta)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Removes a key from the request metadata.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param request the request to mutate</span><span class="s3">\n </span><span class="s1">* @param key the key to remove</span><span class="s3">\n </span><span class="s1">* @returns the mutated request metadata</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function removeRequestMeta&lt;K extends keyof RequestMeta&gt;(</span><span class="s3">\n  </span><span class="s1">request: NextIncomingMessage,</span><span class="s3">\n  </span><span class="s1">key: K</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const meta = getRequestMeta(request)</span><span class="s3">\n  </span><span class="s1">delete meta[key]</span><span class="s3">\n  </span><span class="s1">return setRequestMeta(request, meta)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type NextQueryMetadata = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The `_rsc` query parameter used for cache busting to ensure that the RSC</span><span class="s3">\n   </span><span class="s1">* requests do not get cached by the browser explicitly.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">[NEXT_RSC_UNION_QUERY]?: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type NextParsedUrlQuery = ParsedUrlQuery &amp;</span><span class="s3">\n  </span><span class="s1">NextQueryMetadata &amp; {</span><span class="s3">\n    </span><span class="s1">amp?: '1'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface NextUrlWithParsedQuery extends UrlWithParsedQuery {</span><span class="s3">\n  </span><span class="s1">query: NextParsedUrlQuery</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { ensureLeadingSlash } from './ensure-leading-slash'</span><span class="s3">\n</span><span class="s1">import { isDynamicRoute } from '../router/utils'</span><span class="s3">\n</span><span class="s1">import { NormalizeError } from '../utils'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Takes a page and transforms it into its file counterpart ensuring that the</span><span class="s3">\n </span><span class="s1">* output is normalized. Note this function is not idempotent because a page</span><span class="s3">\n </span><span class="s1">* `/index` can be referencing `/index/index.js` and `/index/index` could be</span><span class="s3">\n </span><span class="s1">* referencing `/index/index/index.js`. Examples:</span><span class="s3">\n </span><span class="s1">*  - `/` -&gt; `/index`</span><span class="s3">\n </span><span class="s1">*  - `/index/foo` -&gt; `/index/index/foo`</span><span class="s3">\n </span><span class="s1">*  - `/index` -&gt; `/index/index`</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function normalizePagePath(page: string): string {</span><span class="s3">\n  </span><span class="s1">const normalized =</span><span class="s3">\n    </span><span class="s1">/^</span><span class="s3">\\</span><span class="s1">/index(</span><span class="s3">\\</span><span class="s1">/|$)/.test(page) &amp;&amp; !isDynamicRoute(page)</span><span class="s3">\n      </span><span class="s1">? `/index${page}`</span><span class="s3">\n      </span><span class="s1">: page === '/'</span><span class="s3">\n        </span><span class="s1">? '/index'</span><span class="s3">\n        </span><span class="s1">: ensureLeadingSlash(page)</span><span class="s3">\n\n  </span><span class="s1">if (process.env.NEXT_RUNTIME !== 'edge') {</span><span class="s3">\n    </span><span class="s1">const { posix } = require('path') as typeof import('path')</span><span class="s3">\n    </span><span class="s1">const resolvedPage = posix.normalize(normalized)</span><span class="s3">\n    </span><span class="s1">if (resolvedPage !== normalized) {</span><span class="s3">\n      </span><span class="s1">throw new NormalizeError(</span><span class="s3">\n        </span><span class="s1">`Requested and resolved page mismatch: ${normalized} ${resolvedPage}`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return normalized</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* For a given page path, this function ensures that there is no backslash</span><span class="s3">\n </span><span class="s1">* escaping slashes in the path. Example:</span><span class="s3">\n </span><span class="s1">*  - `foo</span><span class="s3">\\</span><span class="s1">/bar</span><span class="s3">\\</span><span class="s1">/baz` -&gt; `foo/bar/baz`</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function normalizePathSep(path: string): string {</span><span class="s3">\n  </span><span class="s1">return path.replace(/</span><span class="s3">\\\\</span><span class="s1">/g, '/')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { PageExtensions } from '../../build/page-extensions-type'</span><span class="s3">\n</span><span class="s1">import { normalizePathSep } from '../../shared/lib/page-path/normalize-path-sep'</span><span class="s3">\n</span><span class="s1">import { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'</span><span class="s3">\n</span><span class="s1">import { isAppRouteRoute } from '../is-app-route-route'</span><span class="s3">\n\n</span><span class="s1">export const STATIC_METADATA_IMAGES = {</span><span class="s3">\n  </span><span class="s1">icon: {</span><span class="s3">\n    </span><span class="s1">filename: 'icon',</span><span class="s3">\n    </span><span class="s1">extensions: ['ico', 'jpg', 'jpeg', 'png', 'svg'],</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">apple: {</span><span class="s3">\n    </span><span class="s1">filename: 'apple-icon',</span><span class="s3">\n    </span><span class="s1">extensions: ['jpg', 'jpeg', 'png'],</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">favicon: {</span><span class="s3">\n    </span><span class="s1">filename: 'favicon',</span><span class="s3">\n    </span><span class="s1">extensions: ['ico'],</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">openGraph: {</span><span class="s3">\n    </span><span class="s1">filename: 'opengraph-image',</span><span class="s3">\n    </span><span class="s1">extensions: ['jpg', 'jpeg', 'png', 'gif'],</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">twitter: {</span><span class="s3">\n    </span><span class="s1">filename: 'twitter-image',</span><span class="s3">\n    </span><span class="s1">extensions: ['jpg', 'jpeg', 'png', 'gif'],</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">} as const</span><span class="s3">\n\n</span><span class="s1">// Match routes that are metadata routes, e.g. /sitemap.xml, /favicon.&lt;ext&gt;, /&lt;icon&gt;.&lt;ext&gt;, etc.</span><span class="s3">\n</span><span class="s1">// TODO-METADATA: support more metadata routes with more extensions</span><span class="s3">\n</span><span class="s1">export const DEFAULT_METADATA_ROUTE_EXTENSIONS = ['js', 'jsx', 'ts', 'tsx']</span><span class="s3">\n\n</span><span class="s1">// Match the file extension with the dynamic multi-routes extensions</span><span class="s3">\n</span><span class="s1">// e.g. ([xml, js], null) -&gt; can match `/sitemap.xml/route`, `sitemap.js/route`</span><span class="s3">\n</span><span class="s1">// e.g. ([png], [ts]) -&gt; can match `/opengrapg-image.png`, `/opengraph-image.ts`</span><span class="s3">\n</span><span class="s1">export const getExtensionRegexString = (</span><span class="s3">\n  </span><span class="s1">staticExtensions: readonly string[],</span><span class="s3">\n  </span><span class="s1">dynamicExtensions: readonly string[] | null</span><span class="s3">\n</span><span class="s1">) =&gt; {</span><span class="s3">\n  </span><span class="s1">// If there's no possible multi dynamic routes, will not match any &lt;name&gt;[].&lt;ext&gt; files</span><span class="s3">\n  </span><span class="s1">if (!dynamicExtensions || dynamicExtensions.length === 0) {</span><span class="s3">\n    </span><span class="s1">return `(</span><span class="s3">\\\\</span><span class="s1">.(?:${staticExtensions.join('|')}))`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return `(?:</span><span class="s3">\\\\</span><span class="s1">.(${staticExtensions.join('|')})|(</span><span class="s3">\\\\</span><span class="s1">.(${dynamicExtensions.join('|')})))`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Determine if the file is a metadata route file entry</span><span class="s3">\n </span><span class="s1">* @param appDirRelativePath the relative file path to app/</span><span class="s3">\n </span><span class="s1">* @param pageExtensions the js extensions, such as ['js', 'jsx', 'ts', 'tsx']</span><span class="s3">\n </span><span class="s1">* @param strictlyMatchExtensions if it's true, match the file with page extension, otherwise match the file with default corresponding extension</span><span class="s3">\n </span><span class="s1">* @returns if the file is a metadata route file</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isMetadataRouteFile(</span><span class="s3">\n  </span><span class="s1">appDirRelativePath: string,</span><span class="s3">\n  </span><span class="s1">pageExtensions: PageExtensions,</span><span class="s3">\n  </span><span class="s1">strictlyMatchExtensions: boolean</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// End with the extension or optional to have the extension</span><span class="s3">\n  </span><span class="s1">// When strictlyMatchExtensions is true, it's used for match file path;</span><span class="s3">\n  </span><span class="s1">// When strictlyMatchExtensions, the dynamic extension is skipped but</span><span class="s3">\n  </span><span class="s1">// static extension is kept, which is usually used for matching route path.</span><span class="s3">\n  </span><span class="s1">const trailingMatcher = (strictlyMatchExtensions ? '' : '?') + '$'</span><span class="s3">\n  </span><span class="s1">// Match the optional variants like /opengraph-image2, /icon-a102f4.png, etc.</span><span class="s3">\n  </span><span class="s1">const variantsMatcher = '</span><span class="s3">\\\\</span><span class="s1">d?'</span><span class="s3">\n  </span><span class="s1">// The -</span><span class="s3">\\</span><span class="s1">w{6} is the suffix that normalized from group routes;</span><span class="s3">\n  </span><span class="s1">const groupSuffix = strictlyMatchExtensions ? '' : '(-</span><span class="s3">\\\\</span><span class="s1">w{6})?'</span><span class="s3">\n\n  </span><span class="s1">const suffixMatcher = `${variantsMatcher}${groupSuffix}`</span><span class="s3">\n\n  </span><span class="s1">const metadataRouteFilesRegex = [</span><span class="s3">\n    </span><span class="s1">new RegExp(</span><span class="s3">\n      </span><span class="s1">`^[</span><span class="s3">\\\\\\\\</span><span class="s1">/]robots${getExtensionRegexString(</span><span class="s3">\n        </span><span class="s1">pageExtensions.concat('txt'),</span><span class="s3">\n        </span><span class="s1">null</span><span class="s3">\n      </span><span class="s1">)}${trailingMatcher}`</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">new RegExp(</span><span class="s3">\n      </span><span class="s1">`^[</span><span class="s3">\\\\\\\\</span><span class="s1">/]manifest${getExtensionRegexString(</span><span class="s3">\n        </span><span class="s1">pageExtensions.concat('webmanifest', 'json'),</span><span class="s3">\n        </span><span class="s1">null</span><span class="s3">\n      </span><span class="s1">)}${trailingMatcher}`</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">new RegExp(`^[</span><span class="s3">\\\\\\\\</span><span class="s1">/]favicon</span><span class="s3">\\\\</span><span class="s1">.ico$`),</span><span class="s3">\n    </span><span class="s1">new RegExp(</span><span class="s3">\n      </span><span class="s1">`[</span><span class="s3">\\\\\\\\</span><span class="s1">/]sitemap${getExtensionRegexString(['xml'], pageExtensions)}${trailingMatcher}`</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">new RegExp(</span><span class="s3">\n      </span><span class="s1">`[</span><span class="s3">\\\\\\\\</span><span class="s1">/]${STATIC_METADATA_IMAGES.icon.filename}${suffixMatcher}${getExtensionRegexString(</span><span class="s3">\n        </span><span class="s1">STATIC_METADATA_IMAGES.icon.extensions,</span><span class="s3">\n        </span><span class="s1">pageExtensions</span><span class="s3">\n      </span><span class="s1">)}${trailingMatcher}`</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">new RegExp(</span><span class="s3">\n      </span><span class="s1">`[</span><span class="s3">\\\\\\\\</span><span class="s1">/]${STATIC_METADATA_IMAGES.apple.filename}${suffixMatcher}${getExtensionRegexString(</span><span class="s3">\n        </span><span class="s1">STATIC_METADATA_IMAGES.apple.extensions,</span><span class="s3">\n        </span><span class="s1">pageExtensions</span><span class="s3">\n      </span><span class="s1">)}${trailingMatcher}`</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">new RegExp(</span><span class="s3">\n      </span><span class="s1">`[</span><span class="s3">\\\\\\\\</span><span class="s1">/]${STATIC_METADATA_IMAGES.openGraph.filename}${suffixMatcher}${getExtensionRegexString(</span><span class="s3">\n        </span><span class="s1">STATIC_METADATA_IMAGES.openGraph.extensions,</span><span class="s3">\n        </span><span class="s1">pageExtensions</span><span class="s3">\n      </span><span class="s1">)}${trailingMatcher}`</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">new RegExp(</span><span class="s3">\n      </span><span class="s1">`[</span><span class="s3">\\\\\\\\</span><span class="s1">/]${STATIC_METADATA_IMAGES.twitter.filename}${suffixMatcher}${getExtensionRegexString(</span><span class="s3">\n        </span><span class="s1">STATIC_METADATA_IMAGES.twitter.extensions,</span><span class="s3">\n        </span><span class="s1">pageExtensions</span><span class="s3">\n      </span><span class="s1">)}${trailingMatcher}`</span><span class="s3">\n    </span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">]</span><span class="s3">\n\n  </span><span class="s1">const normalizedAppDirRelativePath = normalizePathSep(appDirRelativePath)</span><span class="s3">\n  </span><span class="s1">const matched = metadataRouteFilesRegex.some((r) =&gt;</span><span class="s3">\n    </span><span class="s1">r.test(normalizedAppDirRelativePath)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">return matched</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Check if the route is a static metadata route, with /route suffix</span><span class="s3">\n</span><span class="s1">// e.g. /favicon.ico/route, /icon.png/route, etc.</span><span class="s3">\n</span><span class="s1">// But skip the text routes like robots.txt since they might also be dynamic.</span><span class="s3">\n</span><span class="s1">// Checking route path is not enough to determine if text routes is dynamic.</span><span class="s3">\n</span><span class="s1">export function isStaticMetadataRoute(route: string) {</span><span class="s3">\n  </span><span class="s1">// extract ext with regex</span><span class="s3">\n  </span><span class="s1">const pathname = route.replace(/</span><span class="s3">\\</span><span class="s1">/route$/, '')</span><span class="s3">\n\n  </span><span class="s1">const matched =</span><span class="s3">\n    </span><span class="s1">isAppRouteRoute(route) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">isMetadataRouteFile(pathname, [], true) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">// These routes can either be built by static or dynamic entrypoints,</span><span class="s3">\n    </span><span class="s1">// so we assume they're dynamic</span><span class="s3">\n    </span><span class="s1">pathname !== '/robots.txt' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">pathname !== '/manifest.webmanifest' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">!pathname.endsWith('/sitemap.xml')</span><span class="s3">\n\n  </span><span class="s1">return matched</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Determine if a page or pathname is a metadata page.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The input is a page or pathname, which can be with or without page suffix /foo/page or /foo.</span><span class="s3">\n </span><span class="s1">* But it will not contain the /route suffix.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* .e.g</span><span class="s3">\n </span><span class="s1">* /robots -&gt; true</span><span class="s3">\n </span><span class="s1">* /sitemap -&gt; true</span><span class="s3">\n </span><span class="s1">* /foo -&gt; false</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isMetadataPage(page: string) {</span><span class="s3">\n  </span><span class="s1">const matched = !isAppRouteRoute(page) &amp;&amp; isMetadataRouteFile(page, [], false)</span><span class="s3">\n\n  </span><span class="s1">return matched</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Determine if a Next.js route is a metadata route.</span><span class="s3">\n </span><span class="s1">* `route` will has a route suffix.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* e.g.</span><span class="s3">\n </span><span class="s1">* /app/robots/route -&gt; true</span><span class="s3">\n </span><span class="s1">* /robots/route -&gt; true</span><span class="s3">\n </span><span class="s1">* /sitemap/[__metadata_id__]/route -&gt; true</span><span class="s3">\n </span><span class="s1">* /app/sitemap/page -&gt; false</span><span class="s3">\n </span><span class="s1">* /icon-a102f4/route -&gt; true</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isMetadataRoute(route: string): boolean {</span><span class="s3">\n  </span><span class="s1">let page = normalizeAppPath(route)</span><span class="s3">\n    </span><span class="s1">.replace(/^</span><span class="s3">\\</span><span class="s1">/?app</span><span class="s3">\\</span><span class="s1">//, '')</span><span class="s3">\n    </span><span class="s1">// Remove the dynamic route id</span><span class="s3">\n    </span><span class="s1">.replace('/[__metadata_id__]', '')</span><span class="s3">\n    </span><span class="s1">// Remove the /route suffix</span><span class="s3">\n    </span><span class="s1">.replace(/</span><span class="s3">\\</span><span class="s1">/route$/, '')</span><span class="s3">\n\n  </span><span class="s1">if (page[0] !== '/') page = '/' + page</span><span class="s3">\n\n  </span><span class="s1">const matched = isAppRouteRoute(route) &amp;&amp; isMetadataRouteFile(page, [], false)</span><span class="s3">\n\n  </span><span class="s1">return matched</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* A `Promise.withResolvers` implementation that exposes the `resolve` and</span><span class="s3">\n </span><span class="s1">* `reject` functions on a `Promise`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @see https://tc39.es/proposal-promise-with-resolvers/</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class DetachedPromise&lt;T = any&gt; {</span><span class="s3">\n  </span><span class="s1">public readonly resolve: (value: T | PromiseLike&lt;T&gt;) =&gt; void</span><span class="s3">\n  </span><span class="s1">public readonly reject: (reason: any) =&gt; void</span><span class="s3">\n  </span><span class="s1">public readonly promise: Promise&lt;T&gt;</span><span class="s3">\n\n  </span><span class="s1">constructor() {</span><span class="s3">\n    </span><span class="s1">let resolve: (value: T | PromiseLike&lt;T&gt;) =&gt; void</span><span class="s3">\n    </span><span class="s1">let reject: (reason: any) =&gt; void</span><span class="s3">\n\n    </span><span class="s1">// Create the promise and assign the resolvers to the object.</span><span class="s3">\n    </span><span class="s1">this.promise = new Promise&lt;T&gt;((res, rej) =&gt; {</span><span class="s3">\n      </span><span class="s1">resolve = res</span><span class="s3">\n      </span><span class="s1">reject = rej</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">// We know that resolvers is defined because the Promise constructor runs</span><span class="s3">\n    </span><span class="s1">// synchronously.</span><span class="s3">\n    </span><span class="s1">this.resolve = resolve!</span><span class="s3">\n    </span><span class="s1">this.reject = reject!</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { SchedulerFn } from './scheduler'</span><span class="s3">\n\n</span><span class="s1">import { DetachedPromise } from './detached-promise'</span><span class="s3">\n\n</span><span class="s1">type CacheKeyFn&lt;K, C extends string | number | null&gt; = (</span><span class="s3">\n  </span><span class="s1">key: K</span><span class="s3">\n</span><span class="s1">) =&gt; PromiseLike&lt;C&gt; | C</span><span class="s3">\n\n</span><span class="s1">type BatcherOptions&lt;K, C extends string | number | null&gt; = {</span><span class="s3">\n  </span><span class="s1">cacheKeyFn?: CacheKeyFn&lt;K, C&gt;</span><span class="s3">\n  </span><span class="s1">schedulerFn?: SchedulerFn&lt;void&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type WorkFn&lt;V, C&gt; = (</span><span class="s3">\n  </span><span class="s1">key: C,</span><span class="s3">\n  </span><span class="s1">resolve: (value: V | PromiseLike&lt;V&gt;) =&gt; void</span><span class="s3">\n</span><span class="s1">) =&gt; Promise&lt;V&gt;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A wrapper for a function that will only allow one call to the function to</span><span class="s3">\n </span><span class="s1">* execute at a time.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class Batcher&lt;K, V, C extends string | number | null&gt; {</span><span class="s3">\n  </span><span class="s1">private readonly pending = new Map&lt;C, Promise&lt;V&gt;&gt;()</span><span class="s3">\n\n  </span><span class="s1">protected constructor(</span><span class="s3">\n    </span><span class="s1">private readonly cacheKeyFn?: CacheKeyFn&lt;K, C&gt;,</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* A function that will be called to schedule the wrapped function to be</span><span class="s3">\n     </span><span class="s1">* executed. This defaults to a function that will execute the function</span><span class="s3">\n     </span><span class="s1">* immediately.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">private readonly schedulerFn: SchedulerFn&lt;void&gt; = (fn) =&gt; fn()</span><span class="s3">\n  </span><span class="s1">) {}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Creates a new instance of PendingWrapper. If the key extends a string or</span><span class="s3">\n   </span><span class="s1">* number, the key will be used as the cache key. If the key is an object, a</span><span class="s3">\n   </span><span class="s1">* cache key function must be provided.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public static create&lt;K extends string | number | null, V&gt;(</span><span class="s3">\n    </span><span class="s1">options?: BatcherOptions&lt;K, K&gt;</span><span class="s3">\n  </span><span class="s1">): Batcher&lt;K, V, K&gt;</span><span class="s3">\n  </span><span class="s1">public static create&lt;K, V, C extends string | number | null&gt;(</span><span class="s3">\n    </span><span class="s1">options: BatcherOptions&lt;K, C&gt; &amp;</span><span class="s3">\n      </span><span class="s1">Required&lt;Pick&lt;BatcherOptions&lt;K, C&gt;, 'cacheKeyFn'&gt;&gt;</span><span class="s3">\n  </span><span class="s1">): Batcher&lt;K, V, C&gt;</span><span class="s3">\n  </span><span class="s1">public static create&lt;K, V, C extends string | number | null&gt;(</span><span class="s3">\n    </span><span class="s1">options?: BatcherOptions&lt;K, C&gt;</span><span class="s3">\n  </span><span class="s1">): Batcher&lt;K, V, C&gt; {</span><span class="s3">\n    </span><span class="s1">return new Batcher&lt;K, V, C&gt;(options?.cacheKeyFn, options?.schedulerFn)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Wraps a function in a promise that will be resolved or rejected only once</span><span class="s3">\n   </span><span class="s1">* for a given key. This will allow multiple calls to the function to be</span><span class="s3">\n   </span><span class="s1">* made, but only one will be executed at a time. The result of the first</span><span class="s3">\n   </span><span class="s1">* call will be returned to all callers.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param key the key to use for the cache</span><span class="s3">\n   </span><span class="s1">* @param fn the function to wrap</span><span class="s3">\n   </span><span class="s1">* @returns a promise that resolves to the result of the function</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public async batch(key: K, fn: WorkFn&lt;V, C&gt;): Promise&lt;V&gt; {</span><span class="s3">\n    </span><span class="s1">const cacheKey = (this.cacheKeyFn ? await this.cacheKeyFn(key) : key) as C</span><span class="s3">\n    </span><span class="s1">if (cacheKey === null) {</span><span class="s3">\n      </span><span class="s1">return fn(cacheKey, Promise.resolve)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const pending = this.pending.get(cacheKey)</span><span class="s3">\n    </span><span class="s1">if (pending) return pending</span><span class="s3">\n\n    </span><span class="s1">const { promise, resolve, reject } = new DetachedPromise&lt;V&gt;()</span><span class="s3">\n    </span><span class="s1">this.pending.set(cacheKey, promise)</span><span class="s3">\n\n    </span><span class="s1">this.schedulerFn(async () =&gt; {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">const result = await fn(cacheKey, resolve)</span><span class="s3">\n\n        </span><span class="s1">// Resolving a promise multiple times is a no-op, so we can safely</span><span class="s3">\n        </span><span class="s1">// resolve all pending promises with the same result.</span><span class="s3">\n        </span><span class="s1">resolve(result)</span><span class="s3">\n      </span><span class="s1">} catch (err) {</span><span class="s3">\n        </span><span class="s1">reject(err)</span><span class="s3">\n      </span><span class="s1">} finally {</span><span class="s3">\n        </span><span class="s1">this.pending.delete(cacheKey)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">return promise</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export type ScheduledFn&lt;T = void&gt; = () =&gt; T | PromiseLike&lt;T&gt;</span><span class="s3">\n</span><span class="s1">export type SchedulerFn&lt;T = void&gt; = (cb: ScheduledFn&lt;T&gt;) =&gt; void</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Schedules a function to be called on the next tick after the other promises</span><span class="s3">\n </span><span class="s1">* have been resolved.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param cb the function to schedule</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const scheduleOnNextTick = (cb: ScheduledFn&lt;void&gt;) =&gt; {</span><span class="s3">\n  </span><span class="s1">// We use Promise.resolve().then() here so that the operation is scheduled at</span><span class="s3">\n  </span><span class="s1">// the end of the promise job queue, we then add it to the next process tick</span><span class="s3">\n  </span><span class="s1">// to ensure it's evaluated afterwards.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// This was inspired by the implementation of the DataLoader interface: https://github.com/graphql/dataloader/blob/d336bd15282664e0be4b4a657cb796f09bafbc6b/src/index.js#L213-L255</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">Promise.resolve().then(() =&gt; {</span><span class="s3">\n    </span><span class="s1">if (process.env.NEXT_RUNTIME === 'edge') {</span><span class="s3">\n      </span><span class="s1">setTimeout(cb, 0)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">process.nextTick(cb)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Schedules a function to be called using `setImmediate` or `setTimeout` if</span><span class="s3">\n </span><span class="s1">* `setImmediate` is not available (like in the Edge runtime).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param cb the function to schedule</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const scheduleImmediate = (cb: ScheduledFn&lt;void&gt;): void =&gt; {</span><span class="s3">\n  </span><span class="s1">if (process.env.NEXT_RUNTIME === 'edge') {</span><span class="s3">\n    </span><span class="s1">setTimeout(cb, 0)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">setImmediate(cb)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* returns a promise than resolves in a future task. There is no guarantee that the task it resolves in</span><span class="s3">\n </span><span class="s1">* will be the next task but if you await it you can at least be sure that the current task is over and</span><span class="s3">\n </span><span class="s1">* most usefully that the entire microtask queue of the current task has been emptied.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function atLeastOneTask() {</span><span class="s3">\n  </span><span class="s1">return new Promise&lt;void&gt;((resolve) =&gt; scheduleImmediate(resolve))</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This utility function is extracted to make it easier to find places where we are doing</span><span class="s3">\n </span><span class="s1">* specific timing tricks to try to schedule work after React has rendered. This is especially</span><span class="s3">\n </span><span class="s1">* important at the moment because Next.js uses the edge builds of React which use setTimeout to</span><span class="s3">\n </span><span class="s1">* schedule work when you might expect that something like setImmediate would do the trick.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Long term we should switch to the node versions of React rendering when possible and then</span><span class="s3">\n </span><span class="s1">* update this to use setImmediate rather than setTimeout</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function waitAtLeastOneReactRenderTask(): Promise&lt;void&gt; {</span><span class="s3">\n  </span><span class="s1">if (process.env.NEXT_RUNTIME === 'edge') {</span><span class="s3">\n    </span><span class="s1">return new Promise((r) =&gt; setTimeout(r, 0))</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return new Promise((r) =&gt; setImmediate(r))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { OutgoingHttpHeaders } from 'http'</span><span class="s3">\n</span><span class="s1">import type RenderResult from '../render-result'</span><span class="s3">\n</span><span class="s1">import type { CacheControl, Revalidate } from '../lib/cache-control'</span><span class="s3">\n</span><span class="s1">import type { RouteKind } from '../route-kind'</span><span class="s3">\n\n</span><span class="s1">export interface ResponseCacheBase {</span><span class="s3">\n  </span><span class="s1">get(</span><span class="s3">\n    </span><span class="s1">key: string | null,</span><span class="s3">\n    </span><span class="s1">responseGenerator: ResponseGenerator,</span><span class="s3">\n    </span><span class="s1">context: {</span><span class="s3">\n      </span><span class="s1">isOnDemandRevalidate?: boolean</span><span class="s3">\n      </span><span class="s1">isPrefetch?: boolean</span><span class="s3">\n      </span><span class="s1">incrementalCache: IncrementalCache</span><span class="s3">\n      </span><span class="s1">/**</span><span class="s3">\n       </span><span class="s1">* This is a hint to the cache to help it determine what kind of route</span><span class="s3">\n       </span><span class="s1">* this is so it knows where to look up the cache entry from. If not</span><span class="s3">\n       </span><span class="s1">* provided it will test the filesystem to check.</span><span class="s3">\n       </span><span class="s1">*/</span><span class="s3">\n      </span><span class="s1">routeKind: RouteKind</span><span class="s3">\n\n      </span><span class="s1">/**</span><span class="s3">\n       </span><span class="s1">* True if this is a fallback request.</span><span class="s3">\n       </span><span class="s1">*/</span><span class="s3">\n      </span><span class="s1">isFallback?: boolean</span><span class="s3">\n\n      </span><span class="s1">/**</span><span class="s3">\n       </span><span class="s1">* True if the route is enabled for PPR.</span><span class="s3">\n       </span><span class="s1">*/</span><span class="s3">\n      </span><span class="s1">isRoutePPREnabled?: boolean</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">): Promise&lt;ResponseCacheEntry | null&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// The server components HMR cache might store other data as well in the future,</span><span class="s3">\n</span><span class="s1">// at which point this should be refactored to a discriminated union type.</span><span class="s3">\n</span><span class="s1">export interface ServerComponentsHmrCache {</span><span class="s3">\n  </span><span class="s1">get(key: string): CachedFetchData | undefined</span><span class="s3">\n  </span><span class="s1">set(key: string, data: CachedFetchData): void</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type CachedFetchData = {</span><span class="s3">\n  </span><span class="s1">headers: Record&lt;string, string&gt;</span><span class="s3">\n  </span><span class="s1">body: string</span><span class="s3">\n  </span><span class="s1">url: string</span><span class="s3">\n  </span><span class="s1">status?: number</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const enum CachedRouteKind {</span><span class="s3">\n  </span><span class="s1">APP_PAGE = 'APP_PAGE',</span><span class="s3">\n  </span><span class="s1">APP_ROUTE = 'APP_ROUTE',</span><span class="s3">\n  </span><span class="s1">PAGES = 'PAGES',</span><span class="s3">\n  </span><span class="s1">FETCH = 'FETCH',</span><span class="s3">\n  </span><span class="s1">REDIRECT = 'REDIRECT',</span><span class="s3">\n  </span><span class="s1">IMAGE = 'IMAGE',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface CachedFetchValue {</span><span class="s3">\n  </span><span class="s1">kind: CachedRouteKind.FETCH</span><span class="s3">\n  </span><span class="s1">data: CachedFetchData</span><span class="s3">\n  </span><span class="s1">// tags are only present with file-system-cache</span><span class="s3">\n  </span><span class="s1">// fetch cache stores tags outside of cache entry</span><span class="s3">\n  </span><span class="s1">tags?: string[]</span><span class="s3">\n  </span><span class="s1">revalidate: number</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface CachedRedirectValue {</span><span class="s3">\n  </span><span class="s1">kind: CachedRouteKind.REDIRECT</span><span class="s3">\n  </span><span class="s1">props: Object</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface CachedAppPageValue {</span><span class="s3">\n  </span><span class="s1">kind: CachedRouteKind.APP_PAGE</span><span class="s3">\n  </span><span class="s1">// this needs to be a RenderResult so since renderResponse</span><span class="s3">\n  </span><span class="s1">// expects that type instead of a string</span><span class="s3">\n  </span><span class="s1">html: RenderResult</span><span class="s3">\n  </span><span class="s1">rscData: Buffer | undefined</span><span class="s3">\n  </span><span class="s1">status: number | undefined</span><span class="s3">\n  </span><span class="s1">postponed: string | undefined</span><span class="s3">\n  </span><span class="s1">headers: OutgoingHttpHeaders | undefined</span><span class="s3">\n  </span><span class="s1">segmentData: Map&lt;string, Buffer&gt; | undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface CachedPageValue {</span><span class="s3">\n  </span><span class="s1">kind: CachedRouteKind.PAGES</span><span class="s3">\n  </span><span class="s1">// this needs to be a RenderResult so since renderResponse</span><span class="s3">\n  </span><span class="s1">// expects that type instead of a string</span><span class="s3">\n  </span><span class="s1">html: RenderResult</span><span class="s3">\n  </span><span class="s1">pageData: Object</span><span class="s3">\n  </span><span class="s1">status: number | undefined</span><span class="s3">\n  </span><span class="s1">headers: OutgoingHttpHeaders | undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface CachedRouteValue {</span><span class="s3">\n  </span><span class="s1">kind: CachedRouteKind.APP_ROUTE</span><span class="s3">\n  </span><span class="s1">// this needs to be a RenderResult so since renderResponse</span><span class="s3">\n  </span><span class="s1">// expects that type instead of a string</span><span class="s3">\n  </span><span class="s1">body: Buffer</span><span class="s3">\n  </span><span class="s1">status: number</span><span class="s3">\n  </span><span class="s1">headers: OutgoingHttpHeaders</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface CachedImageValue {</span><span class="s3">\n  </span><span class="s1">kind: CachedRouteKind.IMAGE</span><span class="s3">\n  </span><span class="s1">etag: string</span><span class="s3">\n  </span><span class="s1">upstreamEtag: string</span><span class="s3">\n  </span><span class="s1">buffer: Buffer</span><span class="s3">\n  </span><span class="s1">extension: string</span><span class="s3">\n  </span><span class="s1">isMiss?: boolean</span><span class="s3">\n  </span><span class="s1">isStale?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface IncrementalCachedAppPageValue {</span><span class="s3">\n  </span><span class="s1">kind: CachedRouteKind.APP_PAGE</span><span class="s3">\n  </span><span class="s1">// this needs to be a string since the cache expects to store</span><span class="s3">\n  </span><span class="s1">// the string value</span><span class="s3">\n  </span><span class="s1">html: string</span><span class="s3">\n  </span><span class="s1">rscData: Buffer | undefined</span><span class="s3">\n  </span><span class="s1">headers: OutgoingHttpHeaders | undefined</span><span class="s3">\n  </span><span class="s1">postponed: string | undefined</span><span class="s3">\n  </span><span class="s1">status: number | undefined</span><span class="s3">\n  </span><span class="s1">segmentData: Map&lt;string, Buffer&gt; | undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface IncrementalCachedPageValue {</span><span class="s3">\n  </span><span class="s1">kind: CachedRouteKind.PAGES</span><span class="s3">\n  </span><span class="s1">// this needs to be a string since the cache expects to store</span><span class="s3">\n  </span><span class="s1">// the string value</span><span class="s3">\n  </span><span class="s1">html: string</span><span class="s3">\n  </span><span class="s1">pageData: Object</span><span class="s3">\n  </span><span class="s1">headers: OutgoingHttpHeaders | undefined</span><span class="s3">\n  </span><span class="s1">status: number | undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface IncrementalResponseCacheEntry {</span><span class="s3">\n  </span><span class="s1">cacheControl?: CacheControl</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* timestamp in milliseconds to revalidate after</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">revalidateAfter?: Revalidate</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `-1` here dictates a blocking revalidate should be used</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isStale?: boolean | -1</span><span class="s3">\n  </span><span class="s1">isMiss?: boolean</span><span class="s3">\n  </span><span class="s1">value: Exclude&lt;IncrementalCacheValue, CachedFetchValue&gt; | null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface IncrementalFetchCacheEntry {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `-1` here dictates a blocking revalidate should be used</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isStale?: boolean | -1</span><span class="s3">\n  </span><span class="s1">value: CachedFetchValue</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type IncrementalCacheEntry =</span><span class="s3">\n  </span><span class="s1">| IncrementalResponseCacheEntry</span><span class="s3">\n  </span><span class="s1">| IncrementalFetchCacheEntry</span><span class="s3">\n\n</span><span class="s1">export type IncrementalCacheValue =</span><span class="s3">\n  </span><span class="s1">| CachedRedirectValue</span><span class="s3">\n  </span><span class="s1">| IncrementalCachedPageValue</span><span class="s3">\n  </span><span class="s1">| IncrementalCachedAppPageValue</span><span class="s3">\n  </span><span class="s1">| CachedImageValue</span><span class="s3">\n  </span><span class="s1">| CachedFetchValue</span><span class="s3">\n  </span><span class="s1">| CachedRouteValue</span><span class="s3">\n\n</span><span class="s1">export type ResponseCacheValue =</span><span class="s3">\n  </span><span class="s1">| CachedRedirectValue</span><span class="s3">\n  </span><span class="s1">| CachedPageValue</span><span class="s3">\n  </span><span class="s1">| CachedAppPageValue</span><span class="s3">\n  </span><span class="s1">| CachedImageValue</span><span class="s3">\n  </span><span class="s1">| CachedRouteValue</span><span class="s3">\n\n</span><span class="s1">export type ResponseCacheEntry = {</span><span class="s3">\n  </span><span class="s1">cacheControl?: CacheControl</span><span class="s3">\n  </span><span class="s1">value: ResponseCacheValue | null</span><span class="s3">\n  </span><span class="s1">isStale?: boolean | -1</span><span class="s3">\n  </span><span class="s1">isMiss?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param hasResolved whether the responseGenerator has resolved it's promise</span><span class="s3">\n </span><span class="s1">* @param previousCacheEntry the previous cache entry if it exists or the current</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type ResponseGenerator = (state: {</span><span class="s3">\n  </span><span class="s1">hasResolved: boolean</span><span class="s3">\n  </span><span class="s1">previousCacheEntry?: IncrementalResponseCacheEntry | null</span><span class="s3">\n  </span><span class="s1">isRevalidating?: boolean</span><span class="s3">\n  </span><span class="s1">span?: any</span><span class="s3">\n</span><span class="s1">}) =&gt; Promise&lt;ResponseCacheEntry | null&gt;</span><span class="s3">\n\n</span><span class="s1">export const enum IncrementalCacheKind {</span><span class="s3">\n  </span><span class="s1">APP_PAGE = 'APP_PAGE',</span><span class="s3">\n  </span><span class="s1">APP_ROUTE = 'APP_ROUTE',</span><span class="s3">\n  </span><span class="s1">PAGES = 'PAGES',</span><span class="s3">\n  </span><span class="s1">FETCH = 'FETCH',</span><span class="s3">\n  </span><span class="s1">IMAGE = 'IMAGE',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface GetIncrementalFetchCacheContext {</span><span class="s3">\n  </span><span class="s1">kind: IncrementalCacheKind.FETCH</span><span class="s3">\n  </span><span class="s1">revalidate?: Revalidate</span><span class="s3">\n  </span><span class="s1">fetchUrl?: string</span><span class="s3">\n  </span><span class="s1">fetchIdx?: number</span><span class="s3">\n  </span><span class="s1">tags?: string[]</span><span class="s3">\n  </span><span class="s1">softTags?: string[]</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface GetIncrementalResponseCacheContext {</span><span class="s3">\n  </span><span class="s1">kind: Exclude&lt;IncrementalCacheKind, IncrementalCacheKind.FETCH&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True if the route is enabled for PPR.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isRoutePPREnabled?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True if this is a fallback request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isFallback: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface SetIncrementalFetchCacheContext {</span><span class="s3">\n  </span><span class="s1">fetchCache: true</span><span class="s3">\n  </span><span class="s1">fetchUrl?: string</span><span class="s3">\n  </span><span class="s1">fetchIdx?: number</span><span class="s3">\n  </span><span class="s1">tags?: string[]</span><span class="s3">\n  </span><span class="s1">isImplicitBuildTimeCache?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface SetIncrementalResponseCacheContext {</span><span class="s3">\n  </span><span class="s1">fetchCache?: false</span><span class="s3">\n  </span><span class="s1">cacheControl?: CacheControl</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True if the route is enabled for PPR.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isRoutePPREnabled?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True if this is a fallback request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isFallback?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface IncrementalResponseCache {</span><span class="s3">\n  </span><span class="s1">get(</span><span class="s3">\n    </span><span class="s1">cacheKey: string,</span><span class="s3">\n    </span><span class="s1">ctx: GetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;IncrementalResponseCacheEntry | null&gt;</span><span class="s3">\n  </span><span class="s1">set(</span><span class="s3">\n    </span><span class="s1">key: string,</span><span class="s3">\n    </span><span class="s1">data: Exclude&lt;IncrementalCacheValue, CachedFetchValue&gt; | null,</span><span class="s3">\n    </span><span class="s1">ctx: SetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface IncrementalCache extends IncrementalResponseCache {</span><span class="s3">\n  </span><span class="s1">get(</span><span class="s3">\n    </span><span class="s1">cacheKey: string,</span><span class="s3">\n    </span><span class="s1">ctx: GetIncrementalFetchCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;IncrementalFetchCacheEntry | null&gt;</span><span class="s3">\n  </span><span class="s1">get(</span><span class="s3">\n    </span><span class="s1">cacheKey: string,</span><span class="s3">\n    </span><span class="s1">ctx: GetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;IncrementalResponseCacheEntry | null&gt;</span><span class="s3">\n  </span><span class="s1">set(</span><span class="s3">\n    </span><span class="s1">key: string,</span><span class="s3">\n    </span><span class="s1">data: CachedFetchValue | null,</span><span class="s3">\n    </span><span class="s1">ctx: SetIncrementalFetchCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt;</span><span class="s3">\n  </span><span class="s1">set(</span><span class="s3">\n    </span><span class="s1">key: string,</span><span class="s3">\n    </span><span class="s1">data: Exclude&lt;IncrementalCacheValue, CachedFetchValue&gt; | null,</span><span class="s3">\n    </span><span class="s1">ctx: SetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Contains predefined constants for the trace span name in next/server.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Currently, next/server/tracer is internal implementation only for tracking</span><span class="s3">\n </span><span class="s1">* next.js's implementation only with known span names defined here.</span><span class="s3">\n </span><span class="s1">**/</span><span class="s3">\n\n</span><span class="s1">// eslint typescript has a bug with TS enums</span><span class="s3">\n</span><span class="s1">/* eslint-disable no-shadow */</span><span class="s3">\n\n</span><span class="s1">enum BaseServerSpan {</span><span class="s3">\n  </span><span class="s1">handleRequest = 'BaseServer.handleRequest',</span><span class="s3">\n  </span><span class="s1">run = 'BaseServer.run',</span><span class="s3">\n  </span><span class="s1">pipe = 'BaseServer.pipe',</span><span class="s3">\n  </span><span class="s1">getStaticHTML = 'BaseServer.getStaticHTML',</span><span class="s3">\n  </span><span class="s1">render = 'BaseServer.render',</span><span class="s3">\n  </span><span class="s1">renderToResponseWithComponents = 'BaseServer.renderToResponseWithComponents',</span><span class="s3">\n  </span><span class="s1">renderToResponse = 'BaseServer.renderToResponse',</span><span class="s3">\n  </span><span class="s1">renderToHTML = 'BaseServer.renderToHTML',</span><span class="s3">\n  </span><span class="s1">renderError = 'BaseServer.renderError',</span><span class="s3">\n  </span><span class="s1">renderErrorToResponse = 'BaseServer.renderErrorToResponse',</span><span class="s3">\n  </span><span class="s1">renderErrorToHTML = 'BaseServer.renderErrorToHTML',</span><span class="s3">\n  </span><span class="s1">render404 = 'BaseServer.render404',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum LoadComponentsSpan {</span><span class="s3">\n  </span><span class="s1">loadDefaultErrorComponents = 'LoadComponents.loadDefaultErrorComponents',</span><span class="s3">\n  </span><span class="s1">loadComponents = 'LoadComponents.loadComponents',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum NextServerSpan {</span><span class="s3">\n  </span><span class="s1">getRequestHandler = 'NextServer.getRequestHandler',</span><span class="s3">\n  </span><span class="s1">getServer = 'NextServer.getServer',</span><span class="s3">\n  </span><span class="s1">getServerRequestHandler = 'NextServer.getServerRequestHandler',</span><span class="s3">\n  </span><span class="s1">createServer = 'createServer.createServer',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum NextNodeServerSpan {</span><span class="s3">\n  </span><span class="s1">compression = 'NextNodeServer.compression',</span><span class="s3">\n  </span><span class="s1">getBuildId = 'NextNodeServer.getBuildId',</span><span class="s3">\n  </span><span class="s1">createComponentTree = 'NextNodeServer.createComponentTree',</span><span class="s3">\n  </span><span class="s1">clientComponentLoading = 'NextNodeServer.clientComponentLoading',</span><span class="s3">\n  </span><span class="s1">getLayoutOrPageModule = 'NextNodeServer.getLayoutOrPageModule',</span><span class="s3">\n  </span><span class="s1">generateStaticRoutes = 'NextNodeServer.generateStaticRoutes',</span><span class="s3">\n  </span><span class="s1">generateFsStaticRoutes = 'NextNodeServer.generateFsStaticRoutes',</span><span class="s3">\n  </span><span class="s1">generatePublicRoutes = 'NextNodeServer.generatePublicRoutes',</span><span class="s3">\n  </span><span class="s1">generateImageRoutes = 'NextNodeServer.generateImageRoutes.route',</span><span class="s3">\n  </span><span class="s1">sendRenderResult = 'NextNodeServer.sendRenderResult',</span><span class="s3">\n  </span><span class="s1">proxyRequest = 'NextNodeServer.proxyRequest',</span><span class="s3">\n  </span><span class="s1">runApi = 'NextNodeServer.runApi',</span><span class="s3">\n  </span><span class="s1">render = 'NextNodeServer.render',</span><span class="s3">\n  </span><span class="s1">renderHTML = 'NextNodeServer.renderHTML',</span><span class="s3">\n  </span><span class="s1">imageOptimizer = 'NextNodeServer.imageOptimizer',</span><span class="s3">\n  </span><span class="s1">getPagePath = 'NextNodeServer.getPagePath',</span><span class="s3">\n  </span><span class="s1">getRoutesManifest = 'NextNodeServer.getRoutesManifest',</span><span class="s3">\n  </span><span class="s1">findPageComponents = 'NextNodeServer.findPageComponents',</span><span class="s3">\n  </span><span class="s1">getFontManifest = 'NextNodeServer.getFontManifest',</span><span class="s3">\n  </span><span class="s1">getServerComponentManifest = 'NextNodeServer.getServerComponentManifest',</span><span class="s3">\n  </span><span class="s1">getRequestHandler = 'NextNodeServer.getRequestHandler',</span><span class="s3">\n  </span><span class="s1">renderToHTML = 'NextNodeServer.renderToHTML',</span><span class="s3">\n  </span><span class="s1">renderError = 'NextNodeServer.renderError',</span><span class="s3">\n  </span><span class="s1">renderErrorToHTML = 'NextNodeServer.renderErrorToHTML',</span><span class="s3">\n  </span><span class="s1">render404 = 'NextNodeServer.render404',</span><span class="s3">\n  </span><span class="s1">startResponse = 'NextNodeServer.startResponse',</span><span class="s3">\n\n  </span><span class="s1">// nested inner span, does not require parent scope name</span><span class="s3">\n  </span><span class="s1">route = 'route',</span><span class="s3">\n  </span><span class="s1">onProxyReq = 'onProxyReq',</span><span class="s3">\n  </span><span class="s1">apiResolver = 'apiResolver',</span><span class="s3">\n  </span><span class="s1">internalFetch = 'internalFetch',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum StartServerSpan {</span><span class="s3">\n  </span><span class="s1">startServer = 'startServer.startServer',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum RenderSpan {</span><span class="s3">\n  </span><span class="s1">getServerSideProps = 'Render.getServerSideProps',</span><span class="s3">\n  </span><span class="s1">getStaticProps = 'Render.getStaticProps',</span><span class="s3">\n  </span><span class="s1">renderToString = 'Render.renderToString',</span><span class="s3">\n  </span><span class="s1">renderDocument = 'Render.renderDocument',</span><span class="s3">\n  </span><span class="s1">createBodyResult = 'Render.createBodyResult',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum AppRenderSpan {</span><span class="s3">\n  </span><span class="s1">renderToString = 'AppRender.renderToString',</span><span class="s3">\n  </span><span class="s1">renderToReadableStream = 'AppRender.renderToReadableStream',</span><span class="s3">\n  </span><span class="s1">getBodyResult = 'AppRender.getBodyResult',</span><span class="s3">\n  </span><span class="s1">fetch = 'AppRender.fetch',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum RouterSpan {</span><span class="s3">\n  </span><span class="s1">executeRoute = 'Router.executeRoute',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum NodeSpan {</span><span class="s3">\n  </span><span class="s1">runHandler = 'Node.runHandler',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum AppRouteRouteHandlersSpan {</span><span class="s3">\n  </span><span class="s1">runHandler = 'AppRouteRouteHandlers.runHandler',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum ResolveMetadataSpan {</span><span class="s3">\n  </span><span class="s1">generateMetadata = 'ResolveMetadata.generateMetadata',</span><span class="s3">\n  </span><span class="s1">generateViewport = 'ResolveMetadata.generateViewport',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum MiddlewareSpan {</span><span class="s3">\n  </span><span class="s1">execute = 'Middleware.execute',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type SpanTypes =</span><span class="s3">\n  </span><span class="s1">| `${BaseServerSpan}`</span><span class="s3">\n  </span><span class="s1">| `${LoadComponentsSpan}`</span><span class="s3">\n  </span><span class="s1">| `${NextServerSpan}`</span><span class="s3">\n  </span><span class="s1">| `${StartServerSpan}`</span><span class="s3">\n  </span><span class="s1">| `${NextNodeServerSpan}`</span><span class="s3">\n  </span><span class="s1">| `${RenderSpan}`</span><span class="s3">\n  </span><span class="s1">| `${RouterSpan}`</span><span class="s3">\n  </span><span class="s1">| `${AppRenderSpan}`</span><span class="s3">\n  </span><span class="s1">| `${NodeSpan}`</span><span class="s3">\n  </span><span class="s1">| `${AppRouteRouteHandlersSpan}`</span><span class="s3">\n  </span><span class="s1">| `${ResolveMetadataSpan}`</span><span class="s3">\n  </span><span class="s1">| `${MiddlewareSpan}`</span><span class="s3">\n\n</span><span class="s1">// This list is used to filter out spans that are not relevant to the user</span><span class="s3">\n</span><span class="s1">export const NextVanillaSpanAllowlist = [</span><span class="s3">\n  </span><span class="s1">MiddlewareSpan.execute,</span><span class="s3">\n  </span><span class="s1">BaseServerSpan.handleRequest,</span><span class="s3">\n  </span><span class="s1">RenderSpan.getServerSideProps,</span><span class="s3">\n  </span><span class="s1">RenderSpan.getStaticProps,</span><span class="s3">\n  </span><span class="s1">AppRenderSpan.fetch,</span><span class="s3">\n  </span><span class="s1">AppRenderSpan.getBodyResult,</span><span class="s3">\n  </span><span class="s1">RenderSpan.renderDocument,</span><span class="s3">\n  </span><span class="s1">NodeSpan.runHandler,</span><span class="s3">\n  </span><span class="s1">AppRouteRouteHandlersSpan.runHandler,</span><span class="s3">\n  </span><span class="s1">ResolveMetadataSpan.generateMetadata,</span><span class="s3">\n  </span><span class="s1">ResolveMetadataSpan.generateViewport,</span><span class="s3">\n  </span><span class="s1">NextNodeServerSpan.createComponentTree,</span><span class="s3">\n  </span><span class="s1">NextNodeServerSpan.findPageComponents,</span><span class="s3">\n  </span><span class="s1">NextNodeServerSpan.getLayoutOrPageModule,</span><span class="s3">\n  </span><span class="s1">NextNodeServerSpan.startResponse,</span><span class="s3">\n  </span><span class="s1">NextNodeServerSpan.clientComponentLoading,</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">// These Spans are allowed to be always logged</span><span class="s3">\n</span><span class="s1">// when the otel log prefix env is set</span><span class="s3">\n</span><span class="s1">export const LogSpanAllowList = [</span><span class="s3">\n  </span><span class="s1">NextNodeServerSpan.findPageComponents,</span><span class="s3">\n  </span><span class="s1">NextNodeServerSpan.createComponentTree,</span><span class="s3">\n  </span><span class="s1">NextNodeServerSpan.clientComponentLoading,</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">export {</span><span class="s3">\n  </span><span class="s1">BaseServerSpan,</span><span class="s3">\n  </span><span class="s1">LoadComponentsSpan,</span><span class="s3">\n  </span><span class="s1">NextServerSpan,</span><span class="s3">\n  </span><span class="s1">NextNodeServerSpan,</span><span class="s3">\n  </span><span class="s1">StartServerSpan,</span><span class="s3">\n  </span><span class="s1">RenderSpan,</span><span class="s3">\n  </span><span class="s1">RouterSpan,</span><span class="s3">\n  </span><span class="s1">AppRenderSpan,</span><span class="s3">\n  </span><span class="s1">NodeSpan,</span><span class="s3">\n  </span><span class="s1">AppRouteRouteHandlersSpan,</span><span class="s3">\n  </span><span class="s1">ResolveMetadataSpan,</span><span class="s3">\n  </span><span class="s1">MiddlewareSpan,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type { SpanTypes }</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { ReactDOMServerReadableStream } from 'react-dom/server'</span><span class="s3">\n</span><span class="s1">import { getTracer } from '../lib/trace/tracer'</span><span class="s3">\n</span><span class="s1">import { AppRenderSpan } from '../lib/trace/constants'</span><span class="s3">\n</span><span class="s1">import { DetachedPromise } from '../../lib/detached-promise'</span><span class="s3">\n</span><span class="s1">import { scheduleImmediate, atLeastOneTask } from '../../lib/scheduler'</span><span class="s3">\n</span><span class="s1">import { ENCODED_TAGS } from './encoded-tags'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">indexOfUint8Array,</span><span class="s3">\n  </span><span class="s1">isEquivalentUint8Arrays,</span><span class="s3">\n  </span><span class="s1">removeFromUint8Array,</span><span class="s3">\n</span><span class="s1">} from './uint8array-helpers'</span><span class="s3">\n</span><span class="s1">import { MISSING_ROOT_TAGS_ERROR } from '../../shared/lib/errors/constants'</span><span class="s3">\n</span><span class="s1">import { insertBuildIdComment } from '../../shared/lib/segment-cache/output-export-prefetch-encoding'</span><span class="s3">\n\n</span><span class="s1">function voidCatch() {</span><span class="s3">\n  </span><span class="s1">// this catcher is designed to be used with pipeTo where we expect the underlying</span><span class="s3">\n  </span><span class="s1">// pipe implementation to forward errors but we don't want the pipeTo promise to reject</span><span class="s3">\n  </span><span class="s1">// and be unhandled</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// We can share the same encoder instance everywhere</span><span class="s3">\n</span><span class="s1">// Notably we cannot do the same for TextDecoder because it is stateful</span><span class="s3">\n</span><span class="s1">// when handling streaming data</span><span class="s3">\n</span><span class="s1">const encoder = new TextEncoder()</span><span class="s3">\n\n</span><span class="s1">export function chainStreams&lt;T&gt;(</span><span class="s3">\n  </span><span class="s1">...streams: ReadableStream&lt;T&gt;[]</span><span class="s3">\n</span><span class="s1">): ReadableStream&lt;T&gt; {</span><span class="s3">\n  </span><span class="s1">// If we have no streams, return an empty stream. This behavior is</span><span class="s3">\n  </span><span class="s1">// intentional as we're now providing the `RenderResult.EMPTY` value.</span><span class="s3">\n  </span><span class="s1">if (streams.length === 0) {</span><span class="s3">\n    </span><span class="s1">return new ReadableStream&lt;T&gt;({</span><span class="s3">\n      </span><span class="s1">start(controller) {</span><span class="s3">\n        </span><span class="s1">controller.close()</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// If we only have 1 stream we fast path it by returning just this stream</span><span class="s3">\n  </span><span class="s1">if (streams.length === 1) {</span><span class="s3">\n    </span><span class="s1">return streams[0]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { readable, writable } = new TransformStream()</span><span class="s3">\n\n  </span><span class="s1">// We always initiate pipeTo immediately. We know we have at least 2 streams</span><span class="s3">\n  </span><span class="s1">// so we need to avoid closing the writable when this one finishes.</span><span class="s3">\n  </span><span class="s1">let promise = streams[0].pipeTo(writable, { preventClose: true })</span><span class="s3">\n\n  </span><span class="s1">let i = 1</span><span class="s3">\n  </span><span class="s1">for (; i &lt; streams.length - 1; i++) {</span><span class="s3">\n    </span><span class="s1">const nextStream = streams[i]</span><span class="s3">\n    </span><span class="s1">promise = promise.then(() =&gt;</span><span class="s3">\n      </span><span class="s1">nextStream.pipeTo(writable, { preventClose: true })</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// We can omit the length check because we halted before the last stream and there</span><span class="s3">\n  </span><span class="s1">// is at least two streams so the lastStream here will always be defined</span><span class="s3">\n  </span><span class="s1">const lastStream = streams[i]</span><span class="s3">\n  </span><span class="s1">promise = promise.then(() =&gt; lastStream.pipeTo(writable))</span><span class="s3">\n\n  </span><span class="s1">// Catch any errors from the streams and ignore them, they will be handled</span><span class="s3">\n  </span><span class="s1">// by whatever is consuming the readable stream.</span><span class="s3">\n  </span><span class="s1">promise.catch(voidCatch)</span><span class="s3">\n\n  </span><span class="s1">return readable</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function streamFromString(str: string): ReadableStream&lt;Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">return new ReadableStream({</span><span class="s3">\n    </span><span class="s1">start(controller) {</span><span class="s3">\n      </span><span class="s1">controller.enqueue(encoder.encode(str))</span><span class="s3">\n      </span><span class="s1">controller.close()</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function streamFromBuffer(chunk: Buffer): ReadableStream&lt;Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">return new ReadableStream({</span><span class="s3">\n    </span><span class="s1">start(controller) {</span><span class="s3">\n      </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n      </span><span class="s1">controller.close()</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function streamToBuffer(</span><span class="s3">\n  </span><span class="s1">stream: ReadableStream&lt;Uint8Array&gt;</span><span class="s3">\n</span><span class="s1">): Promise&lt;Buffer&gt; {</span><span class="s3">\n  </span><span class="s1">const reader = stream.getReader()</span><span class="s3">\n  </span><span class="s1">const chunks: Uint8Array[] = []</span><span class="s3">\n\n  </span><span class="s1">while (true) {</span><span class="s3">\n    </span><span class="s1">const { done, value } = await reader.read()</span><span class="s3">\n    </span><span class="s1">if (done) {</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">chunks.push(value)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return Buffer.concat(chunks)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function streamToString(</span><span class="s3">\n  </span><span class="s1">stream: ReadableStream&lt;Uint8Array&gt;,</span><span class="s3">\n  </span><span class="s1">signal?: AbortSignal</span><span class="s3">\n</span><span class="s1">): Promise&lt;string&gt; {</span><span class="s3">\n  </span><span class="s1">const decoder = new TextDecoder('utf-8', { fatal: true })</span><span class="s3">\n  </span><span class="s1">let string = ''</span><span class="s3">\n\n  </span><span class="s1">for await (const chunk of stream) {</span><span class="s3">\n    </span><span class="s1">if (signal?.aborted) {</span><span class="s3">\n      </span><span class="s1">return string</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">string += decoder.decode(chunk, { stream: true })</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">string += decoder.decode()</span><span class="s3">\n\n  </span><span class="s1">return string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function createBufferedTransformStream(): TransformStream&lt;</span><span class="s3">\n  </span><span class="s1">Uint8Array,</span><span class="s3">\n  </span><span class="s1">Uint8Array</span><span class="s3">\n</span><span class="s1">&gt; {</span><span class="s3">\n  </span><span class="s1">let bufferedChunks: Array&lt;Uint8Array&gt; = []</span><span class="s3">\n  </span><span class="s1">let bufferByteLength: number = 0</span><span class="s3">\n  </span><span class="s1">let pending: DetachedPromise&lt;void&gt; | undefined</span><span class="s3">\n\n  </span><span class="s1">const flush = (controller: TransformStreamDefaultController) =&gt; {</span><span class="s3">\n    </span><span class="s1">// If we already have a pending flush, then return early.</span><span class="s3">\n    </span><span class="s1">if (pending) return</span><span class="s3">\n\n    </span><span class="s1">const detached = new DetachedPromise&lt;void&gt;()</span><span class="s3">\n    </span><span class="s1">pending = detached</span><span class="s3">\n\n    </span><span class="s1">scheduleImmediate(() =&gt; {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">const chunk = new Uint8Array(bufferByteLength)</span><span class="s3">\n        </span><span class="s1">let copiedBytes = 0</span><span class="s3">\n\n        </span><span class="s1">for (let i = 0; i &lt; bufferedChunks.length; i++) {</span><span class="s3">\n          </span><span class="s1">const bufferedChunk = bufferedChunks[i]</span><span class="s3">\n          </span><span class="s1">chunk.set(bufferedChunk, copiedBytes)</span><span class="s3">\n          </span><span class="s1">copiedBytes += bufferedChunk.byteLength</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// We just wrote all the buffered chunks so we need to reset the bufferedChunks array</span><span class="s3">\n        </span><span class="s1">// and our bufferByteLength to prepare for the next round of buffered chunks</span><span class="s3">\n        </span><span class="s1">bufferedChunks.length = 0</span><span class="s3">\n        </span><span class="s1">bufferByteLength = 0</span><span class="s3">\n        </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n      </span><span class="s1">} catch {</span><span class="s3">\n        </span><span class="s1">// If an error occurs while enqueuing it can't be due to this</span><span class="s3">\n        </span><span class="s1">// transformers fault. It's likely due to the controller being</span><span class="s3">\n        </span><span class="s1">// errored due to the stream being cancelled.</span><span class="s3">\n      </span><span class="s1">} finally {</span><span class="s3">\n        </span><span class="s1">pending = undefined</span><span class="s3">\n        </span><span class="s1">detached.resolve()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return new TransformStream({</span><span class="s3">\n    </span><span class="s1">transform(chunk, controller) {</span><span class="s3">\n      </span><span class="s1">// Combine the previous buffer with the new chunk.</span><span class="s3">\n      </span><span class="s1">bufferedChunks.push(chunk)</span><span class="s3">\n      </span><span class="s1">bufferByteLength += chunk.byteLength</span><span class="s3">\n\n      </span><span class="s1">// Flush the buffer to the controller.</span><span class="s3">\n      </span><span class="s1">flush(controller)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">flush() {</span><span class="s3">\n      </span><span class="s1">if (!pending) return</span><span class="s3">\n\n      </span><span class="s1">return pending.promise</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createPrefetchCommentStream(</span><span class="s3">\n  </span><span class="s1">isBuildTimePrerendering: boolean,</span><span class="s3">\n  </span><span class="s1">buildId: string</span><span class="s3">\n</span><span class="s1">): TransformStream&lt;Uint8Array, Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">// Insert an extra comment at the beginning of the HTML document. This must</span><span class="s3">\n  </span><span class="s1">// come after the DOCTYPE, which is inserted by React.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// The first chunk sent by React will contain the doctype. After that, we can</span><span class="s3">\n  </span><span class="s1">// pass through the rest of the chunks as-is.</span><span class="s3">\n  </span><span class="s1">let didTransformFirstChunk = false</span><span class="s3">\n  </span><span class="s1">return new TransformStream({</span><span class="s3">\n    </span><span class="s1">transform(chunk, controller) {</span><span class="s3">\n      </span><span class="s1">if (isBuildTimePrerendering &amp;&amp; !didTransformFirstChunk) {</span><span class="s3">\n        </span><span class="s1">didTransformFirstChunk = true</span><span class="s3">\n        </span><span class="s1">const decoder = new TextDecoder('utf-8', { fatal: true })</span><span class="s3">\n        </span><span class="s1">const chunkStr = decoder.decode(chunk, {</span><span class="s3">\n          </span><span class="s1">stream: true,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">const updatedChunkStr = insertBuildIdComment(chunkStr, buildId)</span><span class="s3">\n        </span><span class="s1">controller.enqueue(encoder.encode(updatedChunkStr))</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function renderToInitialFizzStream({</span><span class="s3">\n  </span><span class="s1">ReactDOMServer,</span><span class="s3">\n  </span><span class="s1">element,</span><span class="s3">\n  </span><span class="s1">streamOptions,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">ReactDOMServer: {</span><span class="s3">\n    </span><span class="s1">renderToReadableStream: typeof import('react-dom/server').renderToReadableStream</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">element: React.ReactElement</span><span class="s3">\n  </span><span class="s1">streamOptions?: Parameters&lt;typeof ReactDOMServer.renderToReadableStream&gt;[1]</span><span class="s3">\n</span><span class="s1">}): Promise&lt;ReactDOMServerReadableStream&gt; {</span><span class="s3">\n  </span><span class="s1">return getTracer().trace(AppRenderSpan.renderToReadableStream, async () =&gt;</span><span class="s3">\n    </span><span class="s1">ReactDOMServer.renderToReadableStream(element, streamOptions)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createMetadataTransformStream(</span><span class="s3">\n  </span><span class="s1">insert: () =&gt; Promise&lt;string&gt; | string</span><span class="s3">\n</span><span class="s1">): TransformStream&lt;Uint8Array, Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">let chunkIndex = -1</span><span class="s3">\n  </span><span class="s1">let isMarkRemoved = false</span><span class="s3">\n\n  </span><span class="s1">return new TransformStream({</span><span class="s3">\n    </span><span class="s1">async transform(chunk, controller) {</span><span class="s3">\n      </span><span class="s1">let iconMarkIndex = -1</span><span class="s3">\n      </span><span class="s1">let closedHeadIndex = -1</span><span class="s3">\n      </span><span class="s1">chunkIndex++</span><span class="s3">\n\n      </span><span class="s1">if (isMarkRemoved) {</span><span class="s3">\n        </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">let iconMarkLength = 0</span><span class="s3">\n      </span><span class="s1">// Only search for the closed head tag once</span><span class="s3">\n      </span><span class="s1">if (iconMarkIndex === -1) {</span><span class="s3">\n        </span><span class="s1">iconMarkIndex = indexOfUint8Array(chunk, ENCODED_TAGS.META.ICON_MARK)</span><span class="s3">\n        </span><span class="s1">if (iconMarkIndex === -1) {</span><span class="s3">\n          </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n          </span><span class="s1">return</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// When we found the `&lt;meta name=</span><span class="s3">\&quot;</span><span class="s1">nxt-icon</span><span class="s3">\&quot;</span><span class="s1">` tag prefix, we will remove it from the chunk.</span><span class="s3">\n          </span><span class="s1">// Its close tag could either be `/&gt;` or `&gt;`, checking the next char to ensure we cover both cases.</span><span class="s3">\n          </span><span class="s1">iconMarkLength = ENCODED_TAGS.META.ICON_MARK.length</span><span class="s3">\n          </span><span class="s1">// Check if next char is /, this is for xml mode.</span><span class="s3">\n          </span><span class="s1">if (chunk[iconMarkIndex + iconMarkLength] === 47) {</span><span class="s3">\n            </span><span class="s1">iconMarkLength += 2</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">// The last char is `&gt;`</span><span class="s3">\n            </span><span class="s1">iconMarkLength++</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Check if icon mark is inside &lt;head&gt; tag in the first chunk.</span><span class="s3">\n      </span><span class="s1">if (chunkIndex === 0) {</span><span class="s3">\n        </span><span class="s1">closedHeadIndex = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.HEAD)</span><span class="s3">\n        </span><span class="s1">if (iconMarkIndex !== -1) {</span><span class="s3">\n          </span><span class="s1">// The mark icon is located in the 1st chunk before the head tag.</span><span class="s3">\n          </span><span class="s1">// We do not need to insert the script tag in this case because it's in the head.</span><span class="s3">\n          </span><span class="s1">// Just remove the icon mark from the chunk.</span><span class="s3">\n          </span><span class="s1">if (iconMarkIndex &lt; closedHeadIndex) {</span><span class="s3">\n            </span><span class="s1">const replaced = new Uint8Array(chunk.length - iconMarkLength)</span><span class="s3">\n\n            </span><span class="s1">// Remove the icon mark from the chunk.</span><span class="s3">\n            </span><span class="s1">replaced.set(chunk.subarray(0, iconMarkIndex))</span><span class="s3">\n            </span><span class="s1">replaced.set(</span><span class="s3">\n              </span><span class="s1">chunk.subarray(iconMarkIndex + iconMarkLength),</span><span class="s3">\n              </span><span class="s1">iconMarkIndex</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">chunk = replaced</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">// The icon mark is after the head tag, replace and insert the script tag at that position.</span><span class="s3">\n            </span><span class="s1">const insertion = await insert()</span><span class="s3">\n            </span><span class="s1">const encodedInsertion = encoder.encode(insertion)</span><span class="s3">\n            </span><span class="s1">const insertionLength = encodedInsertion.length</span><span class="s3">\n            </span><span class="s1">const replaced = new Uint8Array(</span><span class="s3">\n              </span><span class="s1">chunk.length - iconMarkLength + insertionLength</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">replaced.set(chunk.subarray(0, iconMarkIndex))</span><span class="s3">\n            </span><span class="s1">replaced.set(encodedInsertion, iconMarkIndex)</span><span class="s3">\n            </span><span class="s1">replaced.set(</span><span class="s3">\n              </span><span class="s1">chunk.subarray(iconMarkIndex + iconMarkLength),</span><span class="s3">\n              </span><span class="s1">iconMarkIndex + insertionLength</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">chunk = replaced</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">isMarkRemoved = true</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// If there's no icon mark located, it will be handled later when if present in the following chunks.</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// When it's appeared in the following chunks, we'll need to</span><span class="s3">\n        </span><span class="s1">// remove the mark and then insert the script tag at that position.</span><span class="s3">\n        </span><span class="s1">const insertion = await insert()</span><span class="s3">\n        </span><span class="s1">const encodedInsertion = encoder.encode(insertion)</span><span class="s3">\n        </span><span class="s1">const insertionLength = encodedInsertion.length</span><span class="s3">\n        </span><span class="s1">// Replace the icon mark with the hoist script or empty string.</span><span class="s3">\n        </span><span class="s1">const replaced = new Uint8Array(</span><span class="s3">\n          </span><span class="s1">chunk.length - iconMarkLength + insertionLength</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">// Set the first part of the chunk, before the icon mark.</span><span class="s3">\n        </span><span class="s1">replaced.set(chunk.subarray(0, iconMarkIndex))</span><span class="s3">\n        </span><span class="s1">// Set the insertion after the icon mark.</span><span class="s3">\n        </span><span class="s1">replaced.set(encodedInsertion, iconMarkIndex)</span><span class="s3">\n\n        </span><span class="s1">// Set the rest of the chunk after the icon mark.</span><span class="s3">\n        </span><span class="s1">replaced.set(</span><span class="s3">\n          </span><span class="s1">chunk.subarray(iconMarkIndex + iconMarkLength),</span><span class="s3">\n          </span><span class="s1">iconMarkIndex + insertionLength</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">chunk = replaced</span><span class="s3">\n        </span><span class="s1">isMarkRemoved = true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createHeadInsertionTransformStream(</span><span class="s3">\n  </span><span class="s1">insert: () =&gt; Promise&lt;string&gt;</span><span class="s3">\n</span><span class="s1">): TransformStream&lt;Uint8Array, Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">let inserted = false</span><span class="s3">\n\n  </span><span class="s1">// We need to track if this transform saw any bytes because if it didn't</span><span class="s3">\n  </span><span class="s1">// we won't want to insert any server HTML at all</span><span class="s3">\n  </span><span class="s1">let hasBytes = false</span><span class="s3">\n\n  </span><span class="s1">return new TransformStream({</span><span class="s3">\n    </span><span class="s1">async transform(chunk, controller) {</span><span class="s3">\n      </span><span class="s1">hasBytes = true</span><span class="s3">\n\n      </span><span class="s1">const insertion = await insert()</span><span class="s3">\n      </span><span class="s1">if (inserted) {</span><span class="s3">\n        </span><span class="s1">if (insertion) {</span><span class="s3">\n          </span><span class="s1">const encodedInsertion = encoder.encode(insertion)</span><span class="s3">\n          </span><span class="s1">controller.enqueue(encodedInsertion)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// TODO (@Ethan-Arrowood): Replace the generic `indexOfUint8Array` method with something finely tuned for the subset of things actually being checked for.</span><span class="s3">\n        </span><span class="s1">const index = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.HEAD)</span><span class="s3">\n        </span><span class="s1">// In fully static rendering or non PPR rendering cases:</span><span class="s3">\n        </span><span class="s1">// `/head&gt;` will always be found in the chunk in first chunk rendering.</span><span class="s3">\n        </span><span class="s1">if (index !== -1) {</span><span class="s3">\n          </span><span class="s1">if (insertion) {</span><span class="s3">\n            </span><span class="s1">const encodedInsertion = encoder.encode(insertion)</span><span class="s3">\n            </span><span class="s1">// Get the total count of the bytes in the chunk and the insertion</span><span class="s3">\n            </span><span class="s1">// e.g.</span><span class="s3">\n            </span><span class="s1">// chunk = &lt;head&gt;&lt;meta charset=</span><span class="s3">\&quot;</span><span class="s1">utf-8</span><span class="s3">\&quot;</span><span class="s1">&gt;&lt;/head&gt;</span><span class="s3">\n            </span><span class="s1">// insertion = &lt;script&gt;...&lt;/script&gt;</span><span class="s3">\n            </span><span class="s1">// output = &lt;head&gt;&lt;meta charset=</span><span class="s3">\&quot;</span><span class="s1">utf-8</span><span class="s3">\&quot;</span><span class="s1">&gt; [ &lt;script&gt;...&lt;/script&gt; ] &lt;/head&gt;</span><span class="s3">\n            </span><span class="s1">const insertedHeadContent = new Uint8Array(</span><span class="s3">\n              </span><span class="s1">chunk.length + encodedInsertion.length</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">// Append the first part of the chunk, before the head tag</span><span class="s3">\n            </span><span class="s1">insertedHeadContent.set(chunk.slice(0, index))</span><span class="s3">\n            </span><span class="s1">// Append the server inserted content</span><span class="s3">\n            </span><span class="s1">insertedHeadContent.set(encodedInsertion, index)</span><span class="s3">\n            </span><span class="s1">// Append the rest of the chunk</span><span class="s3">\n            </span><span class="s1">insertedHeadContent.set(</span><span class="s3">\n              </span><span class="s1">chunk.slice(index),</span><span class="s3">\n              </span><span class="s1">index + encodedInsertion.length</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">controller.enqueue(insertedHeadContent)</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">inserted = true</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// This will happens in PPR rendering during next start, when the page is partially rendered.</span><span class="s3">\n          </span><span class="s1">// When the page resumes, the head tag will be found in the middle of the chunk.</span><span class="s3">\n          </span><span class="s1">// Where we just need to append the insertion and chunk to the current stream.</span><span class="s3">\n          </span><span class="s1">// e.g.</span><span class="s3">\n          </span><span class="s1">// PPR-static: &lt;head&gt;...&lt;/head&gt;&lt;body&gt; [ resume content ] &lt;/body&gt;</span><span class="s3">\n          </span><span class="s1">// PPR-resume: [ insertion ] [ rest content ]</span><span class="s3">\n          </span><span class="s1">if (insertion) {</span><span class="s3">\n            </span><span class="s1">controller.enqueue(encoder.encode(insertion))</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n          </span><span class="s1">inserted = true</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">async flush(controller) {</span><span class="s3">\n      </span><span class="s1">// Check before closing if there's anything remaining to insert.</span><span class="s3">\n      </span><span class="s1">if (hasBytes) {</span><span class="s3">\n        </span><span class="s1">const insertion = await insert()</span><span class="s3">\n        </span><span class="s1">if (insertion) {</span><span class="s3">\n          </span><span class="s1">controller.enqueue(encoder.encode(insertion))</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Suffix after main body content - scripts before &lt;/body&gt;,</span><span class="s3">\n</span><span class="s1">// but wait for the major chunks to be enqueued.</span><span class="s3">\n</span><span class="s1">function createDeferredSuffixStream(</span><span class="s3">\n  </span><span class="s1">suffix: string</span><span class="s3">\n</span><span class="s1">): TransformStream&lt;Uint8Array, Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">let flushed = false</span><span class="s3">\n  </span><span class="s1">let pending: DetachedPromise&lt;void&gt; | undefined</span><span class="s3">\n\n  </span><span class="s1">const flush = (controller: TransformStreamDefaultController) =&gt; {</span><span class="s3">\n    </span><span class="s1">const detached = new DetachedPromise&lt;void&gt;()</span><span class="s3">\n    </span><span class="s1">pending = detached</span><span class="s3">\n\n    </span><span class="s1">scheduleImmediate(() =&gt; {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">controller.enqueue(encoder.encode(suffix))</span><span class="s3">\n      </span><span class="s1">} catch {</span><span class="s3">\n        </span><span class="s1">// If an error occurs while enqueuing it can't be due to this</span><span class="s3">\n        </span><span class="s1">// transformers fault. It's likely due to the controller being</span><span class="s3">\n        </span><span class="s1">// errored due to the stream being cancelled.</span><span class="s3">\n      </span><span class="s1">} finally {</span><span class="s3">\n        </span><span class="s1">pending = undefined</span><span class="s3">\n        </span><span class="s1">detached.resolve()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return new TransformStream({</span><span class="s3">\n    </span><span class="s1">transform(chunk, controller) {</span><span class="s3">\n      </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n\n      </span><span class="s1">// If we've already flushed, we're done.</span><span class="s3">\n      </span><span class="s1">if (flushed) return</span><span class="s3">\n\n      </span><span class="s1">// Schedule the flush to happen.</span><span class="s3">\n      </span><span class="s1">flushed = true</span><span class="s3">\n      </span><span class="s1">flush(controller)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">flush(controller) {</span><span class="s3">\n      </span><span class="s1">if (pending) return pending.promise</span><span class="s3">\n      </span><span class="s1">if (flushed) return</span><span class="s3">\n\n      </span><span class="s1">// Flush now.</span><span class="s3">\n      </span><span class="s1">controller.enqueue(encoder.encode(suffix))</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createFlightDataInjectionTransformStream(</span><span class="s3">\n  </span><span class="s1">stream: ReadableStream&lt;Uint8Array&gt;,</span><span class="s3">\n  </span><span class="s1">delayDataUntilFirstHtmlChunk: boolean</span><span class="s3">\n</span><span class="s1">): TransformStream&lt;Uint8Array, Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">let htmlStreamFinished = false</span><span class="s3">\n\n  </span><span class="s1">let pull: Promise&lt;void&gt; | null = null</span><span class="s3">\n  </span><span class="s1">let donePulling = false</span><span class="s3">\n\n  </span><span class="s1">function startOrContinuePulling(</span><span class="s3">\n    </span><span class="s1">controller: TransformStreamDefaultController</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (!pull) {</span><span class="s3">\n      </span><span class="s1">pull = startPulling(controller)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return pull</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">async function startPulling(controller: TransformStreamDefaultController) {</span><span class="s3">\n    </span><span class="s1">const reader = stream.getReader()</span><span class="s3">\n\n    </span><span class="s1">if (delayDataUntilFirstHtmlChunk) {</span><span class="s3">\n      </span><span class="s1">// NOTE: streaming flush</span><span class="s3">\n      </span><span class="s1">// We are buffering here for the inlined data stream because the</span><span class="s3">\n      </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">shell</span><span class="s3">\&quot; </span><span class="s1">stream might be chunkenized again by the underlying stream</span><span class="s3">\n      </span><span class="s1">// implementation, e.g. with a specific high-water mark. To ensure it's</span><span class="s3">\n      </span><span class="s1">// the safe timing to pipe the data stream, this extra tick is</span><span class="s3">\n      </span><span class="s1">// necessary.</span><span class="s3">\n\n      </span><span class="s1">// We don't start reading until we've left the current Task to ensure</span><span class="s3">\n      </span><span class="s1">// that it's inserted after flushing the shell. Note that this implementation</span><span class="s3">\n      </span><span class="s1">// might get stale if impl details of Fizz change in the future.</span><span class="s3">\n      </span><span class="s1">await atLeastOneTask()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">while (true) {</span><span class="s3">\n        </span><span class="s1">const { done, value } = await reader.read()</span><span class="s3">\n        </span><span class="s1">if (done) {</span><span class="s3">\n          </span><span class="s1">donePulling = true</span><span class="s3">\n          </span><span class="s1">return</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// We want to prioritize HTML over RSC data.</span><span class="s3">\n        </span><span class="s1">// The SSR render is based on the same RSC stream, so when we get a new RSC chunk,</span><span class="s3">\n        </span><span class="s1">// we're likely to produce an HTML chunk as well, so give it a chance to flush first.</span><span class="s3">\n        </span><span class="s1">if (!delayDataUntilFirstHtmlChunk &amp;&amp; !htmlStreamFinished) {</span><span class="s3">\n          </span><span class="s1">await atLeastOneTask()</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">controller.enqueue(value)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} catch (err) {</span><span class="s3">\n      </span><span class="s1">controller.error(err)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return new TransformStream({</span><span class="s3">\n    </span><span class="s1">start(controller) {</span><span class="s3">\n      </span><span class="s1">if (!delayDataUntilFirstHtmlChunk) {</span><span class="s3">\n        </span><span class="s1">startOrContinuePulling(controller)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">transform(chunk, controller) {</span><span class="s3">\n      </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n\n      </span><span class="s1">// Start the streaming if it hasn't already been started yet.</span><span class="s3">\n      </span><span class="s1">if (delayDataUntilFirstHtmlChunk) {</span><span class="s3">\n        </span><span class="s1">startOrContinuePulling(controller)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">flush(controller) {</span><span class="s3">\n      </span><span class="s1">htmlStreamFinished = true</span><span class="s3">\n      </span><span class="s1">if (donePulling) {</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return startOrContinuePulling(controller)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const CLOSE_TAG = '&lt;/body&gt;&lt;/html&gt;'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This transform stream moves the suffix to the end of the stream, so results</span><span class="s3">\n </span><span class="s1">* like `&lt;/body&gt;&lt;/html&gt;&lt;script&gt;...&lt;/script&gt;` will be transformed to</span><span class="s3">\n </span><span class="s1">* `&lt;script&gt;...&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function createMoveSuffixStream(): TransformStream&lt;Uint8Array, Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">let foundSuffix = false</span><span class="s3">\n\n  </span><span class="s1">return new TransformStream({</span><span class="s3">\n    </span><span class="s1">transform(chunk, controller) {</span><span class="s3">\n      </span><span class="s1">if (foundSuffix) {</span><span class="s3">\n        </span><span class="s1">return controller.enqueue(chunk)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const index = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.BODY_AND_HTML)</span><span class="s3">\n      </span><span class="s1">if (index &gt; -1) {</span><span class="s3">\n        </span><span class="s1">foundSuffix = true</span><span class="s3">\n\n        </span><span class="s1">// If the whole chunk is the suffix, then don't write anything, it will</span><span class="s3">\n        </span><span class="s1">// be written in the flush.</span><span class="s3">\n        </span><span class="s1">if (chunk.length === ENCODED_TAGS.CLOSED.BODY_AND_HTML.length) {</span><span class="s3">\n          </span><span class="s1">return</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// Write out the part before the suffix.</span><span class="s3">\n        </span><span class="s1">const before = chunk.slice(0, index)</span><span class="s3">\n        </span><span class="s1">controller.enqueue(before)</span><span class="s3">\n\n        </span><span class="s1">// In the case where the suffix is in the middle of the chunk, we need</span><span class="s3">\n        </span><span class="s1">// to split the chunk into two parts.</span><span class="s3">\n        </span><span class="s1">if (chunk.length &gt; ENCODED_TAGS.CLOSED.BODY_AND_HTML.length + index) {</span><span class="s3">\n          </span><span class="s1">// Write out the part after the suffix.</span><span class="s3">\n          </span><span class="s1">const after = chunk.slice(</span><span class="s3">\n            </span><span class="s1">index + ENCODED_TAGS.CLOSED.BODY_AND_HTML.length</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">controller.enqueue(after)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">flush(controller) {</span><span class="s3">\n      </span><span class="s1">// Even if we didn't find the suffix, the HTML is not valid if we don't</span><span class="s3">\n      </span><span class="s1">// add it, so insert it at the end.</span><span class="s3">\n      </span><span class="s1">controller.enqueue(ENCODED_TAGS.CLOSED.BODY_AND_HTML)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createStripDocumentClosingTagsTransform(): TransformStream&lt;</span><span class="s3">\n  </span><span class="s1">Uint8Array,</span><span class="s3">\n  </span><span class="s1">Uint8Array</span><span class="s3">\n</span><span class="s1">&gt; {</span><span class="s3">\n  </span><span class="s1">return new TransformStream({</span><span class="s3">\n    </span><span class="s1">transform(chunk, controller) {</span><span class="s3">\n      </span><span class="s1">// We rely on the assumption that chunks will never break across a code unit.</span><span class="s3">\n      </span><span class="s1">// This is reasonable because we currently concat all of React's output from a single</span><span class="s3">\n      </span><span class="s1">// flush into one chunk before streaming it forward which means the chunk will represent</span><span class="s3">\n      </span><span class="s1">// a single coherent utf-8 string. This is not safe to use if we change our streaming to no</span><span class="s3">\n      </span><span class="s1">// longer do this large buffered chunk</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.BODY_AND_HTML) ||</span><span class="s3">\n        </span><span class="s1">isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.BODY) ||</span><span class="s3">\n        </span><span class="s1">isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.HTML)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">// the entire chunk is the closing tags; return without enqueueing anything.</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// We assume these tags will go at together at the end of the document and that</span><span class="s3">\n      </span><span class="s1">// they won't appear anywhere else in the document. This is not really a safe assumption</span><span class="s3">\n      </span><span class="s1">// but until we revamp our streaming infra this is a performant way to string the tags</span><span class="s3">\n      </span><span class="s1">chunk = removeFromUint8Array(chunk, ENCODED_TAGS.CLOSED.BODY)</span><span class="s3">\n      </span><span class="s1">chunk = removeFromUint8Array(chunk, ENCODED_TAGS.CLOSED.HTML)</span><span class="s3">\n\n      </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Checks if the root layout is missing the html or body tags</span><span class="s3">\n </span><span class="s1">* and if so, it will inject a script tag to throw an error in the browser, showing the user</span><span class="s3">\n </span><span class="s1">* the error message in the error overlay.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function createRootLayoutValidatorStream(): TransformStream&lt;</span><span class="s3">\n  </span><span class="s1">Uint8Array,</span><span class="s3">\n  </span><span class="s1">Uint8Array</span><span class="s3">\n</span><span class="s1">&gt; {</span><span class="s3">\n  </span><span class="s1">let foundHtml = false</span><span class="s3">\n  </span><span class="s1">let foundBody = false</span><span class="s3">\n  </span><span class="s1">return new TransformStream({</span><span class="s3">\n    </span><span class="s1">async transform(chunk, controller) {</span><span class="s3">\n      </span><span class="s1">// Peek into the streamed chunk to see if the tags are present.</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">!foundHtml &amp;&amp;</span><span class="s3">\n        </span><span class="s1">indexOfUint8Array(chunk, ENCODED_TAGS.OPENING.HTML) &gt; -1</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">foundHtml = true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">!foundBody &amp;&amp;</span><span class="s3">\n        </span><span class="s1">indexOfUint8Array(chunk, ENCODED_TAGS.OPENING.BODY) &gt; -1</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">foundBody = true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">controller.enqueue(chunk)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">flush(controller) {</span><span class="s3">\n      </span><span class="s1">const missingTags: ('html' | 'body')[] = []</span><span class="s3">\n      </span><span class="s1">if (!foundHtml) missingTags.push('html')</span><span class="s3">\n      </span><span class="s1">if (!foundBody) missingTags.push('body')</span><span class="s3">\n\n      </span><span class="s1">if (!missingTags.length) return</span><span class="s3">\n\n      </span><span class="s1">controller.enqueue(</span><span class="s3">\n        </span><span class="s1">encoder.encode(</span><span class="s3">\n          </span><span class="s1">`&lt;html id=</span><span class="s3">\&quot;</span><span class="s1">__next_error__</span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\n            </span><span class="s1">&lt;template</span><span class="s3">\n              </span><span class="s1">data-next-error-message=</span><span class="s3">\&quot;</span><span class="s1">Missing ${missingTags</span><span class="s3">\n                </span><span class="s1">.map((c) =&gt; `&lt;${c}&gt;`)</span><span class="s3">\n                </span><span class="s1">.join(</span><span class="s3">\n                  </span><span class="s1">missingTags.length &gt; 1 ? ' and ' : ''</span><span class="s3">\n                </span><span class="s1">)} tags in the root layout.</span><span class="s3">\\</span><span class="s1">nRead more at https://nextjs.org/docs/messages/missing-root-layout-tags</span><span class="s3">\&quot;\n              </span><span class="s1">data-next-error-digest=</span><span class="s3">\&quot;</span><span class="s1">${MISSING_ROOT_TAGS_ERROR}</span><span class="s3">\&quot;\n              </span><span class="s1">data-next-error-stack=</span><span class="s3">\&quot;\&quot;\n            </span><span class="s1">&gt;&lt;/template&gt;</span><span class="s3">\n          </span><span class="s1">`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function chainTransformers&lt;T&gt;(</span><span class="s3">\n  </span><span class="s1">readable: ReadableStream&lt;T&gt;,</span><span class="s3">\n  </span><span class="s1">transformers: ReadonlyArray&lt;TransformStream&lt;T, T&gt; | null&gt;</span><span class="s3">\n</span><span class="s1">): ReadableStream&lt;T&gt; {</span><span class="s3">\n  </span><span class="s1">let stream = readable</span><span class="s3">\n  </span><span class="s1">for (const transformer of transformers) {</span><span class="s3">\n    </span><span class="s1">if (!transformer) continue</span><span class="s3">\n\n    </span><span class="s1">stream = stream.pipeThrough(transformer)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return stream</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type ContinueStreamOptions = {</span><span class="s3">\n  </span><span class="s1">inlinedDataStream: ReadableStream&lt;Uint8Array&gt; | undefined</span><span class="s3">\n  </span><span class="s1">isStaticGeneration: boolean</span><span class="s3">\n  </span><span class="s1">isBuildTimePrerendering: boolean</span><span class="s3">\n  </span><span class="s1">buildId: string</span><span class="s3">\n  </span><span class="s1">getServerInsertedHTML: () =&gt; Promise&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">getServerInsertedMetadata: () =&gt; Promise&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">validateRootLayout?: boolean</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Suffix to inject after the buffered data, but before the close tags.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">suffix?: string | undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function continueFizzStream(</span><span class="s3">\n  </span><span class="s1">renderStream: ReactDOMServerReadableStream,</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">suffix,</span><span class="s3">\n    </span><span class="s1">inlinedDataStream,</span><span class="s3">\n    </span><span class="s1">isStaticGeneration,</span><span class="s3">\n    </span><span class="s1">isBuildTimePrerendering,</span><span class="s3">\n    </span><span class="s1">buildId,</span><span class="s3">\n    </span><span class="s1">getServerInsertedHTML,</span><span class="s3">\n    </span><span class="s1">getServerInsertedMetadata,</span><span class="s3">\n    </span><span class="s1">validateRootLayout,</span><span class="s3">\n  </span><span class="s1">}: ContinueStreamOptions</span><span class="s3">\n</span><span class="s1">): Promise&lt;ReadableStream&lt;Uint8Array&gt;&gt; {</span><span class="s3">\n  </span><span class="s1">// Suffix itself might contain close tags at the end, so we need to split it.</span><span class="s3">\n  </span><span class="s1">const suffixUnclosed = suffix ? suffix.split(CLOSE_TAG, 1)[0] : null</span><span class="s3">\n\n  </span><span class="s1">// If we're generating static HTML we need to wait for it to resolve before continuing.</span><span class="s3">\n  </span><span class="s1">if (isStaticGeneration) {</span><span class="s3">\n    </span><span class="s1">await renderStream.allReady</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return chainTransformers(renderStream, [</span><span class="s3">\n    </span><span class="s1">// Buffer everything to avoid flushing too frequently</span><span class="s3">\n    </span><span class="s1">createBufferedTransformStream(),</span><span class="s3">\n\n    </span><span class="s1">// Add build id comment to start of the HTML document (in export mode)</span><span class="s3">\n    </span><span class="s1">createPrefetchCommentStream(isBuildTimePrerendering, buildId),</span><span class="s3">\n\n    </span><span class="s1">// Transform metadata</span><span class="s3">\n    </span><span class="s1">createMetadataTransformStream(getServerInsertedMetadata),</span><span class="s3">\n\n    </span><span class="s1">// Insert suffix content</span><span class="s3">\n    </span><span class="s1">suffixUnclosed != null &amp;&amp; suffixUnclosed.length &gt; 0</span><span class="s3">\n      </span><span class="s1">? createDeferredSuffixStream(suffixUnclosed)</span><span class="s3">\n      </span><span class="s1">: null,</span><span class="s3">\n\n    </span><span class="s1">// Insert the inlined data (Flight data, form state, etc.) stream into the HTML</span><span class="s3">\n    </span><span class="s1">inlinedDataStream</span><span class="s3">\n      </span><span class="s1">? createFlightDataInjectionTransformStream(inlinedDataStream, true)</span><span class="s3">\n      </span><span class="s1">: null,</span><span class="s3">\n\n    </span><span class="s1">// Validate the root layout for missing html or body tags</span><span class="s3">\n    </span><span class="s1">validateRootLayout ? createRootLayoutValidatorStream() : null,</span><span class="s3">\n\n    </span><span class="s1">// Close tags should always be deferred to the end</span><span class="s3">\n    </span><span class="s1">createMoveSuffixStream(),</span><span class="s3">\n\n    </span><span class="s1">// Special head insertions</span><span class="s3">\n    </span><span class="s1">// TODO-APP: Insert server side html to end of head in app layout rendering, to avoid</span><span class="s3">\n    </span><span class="s1">// hydration errors. Remove this once it's ready to be handled by react itself.</span><span class="s3">\n    </span><span class="s1">createHeadInsertionTransformStream(getServerInsertedHTML),</span><span class="s3">\n  </span><span class="s1">])</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type ContinueDynamicPrerenderOptions = {</span><span class="s3">\n  </span><span class="s1">getServerInsertedHTML: () =&gt; Promise&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">getServerInsertedMetadata: () =&gt; Promise&lt;string&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function continueDynamicPrerender(</span><span class="s3">\n  </span><span class="s1">prerenderStream: ReadableStream&lt;Uint8Array&gt;,</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">getServerInsertedHTML,</span><span class="s3">\n    </span><span class="s1">getServerInsertedMetadata,</span><span class="s3">\n  </span><span class="s1">}: ContinueDynamicPrerenderOptions</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">prerenderStream</span><span class="s3">\n      </span><span class="s1">// Buffer everything to avoid flushing too frequently</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createBufferedTransformStream())</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createStripDocumentClosingTagsTransform())</span><span class="s3">\n      </span><span class="s1">// Insert generated tags to head</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))</span><span class="s3">\n      </span><span class="s1">// Transform metadata</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type ContinueStaticPrerenderOptions = {</span><span class="s3">\n  </span><span class="s1">inlinedDataStream: ReadableStream&lt;Uint8Array&gt;</span><span class="s3">\n  </span><span class="s1">getServerInsertedHTML: () =&gt; Promise&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">getServerInsertedMetadata: () =&gt; Promise&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">isBuildTimePrerendering: boolean</span><span class="s3">\n  </span><span class="s1">buildId: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function continueStaticPrerender(</span><span class="s3">\n  </span><span class="s1">prerenderStream: ReadableStream&lt;Uint8Array&gt;,</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">inlinedDataStream,</span><span class="s3">\n    </span><span class="s1">getServerInsertedHTML,</span><span class="s3">\n    </span><span class="s1">getServerInsertedMetadata,</span><span class="s3">\n    </span><span class="s1">isBuildTimePrerendering,</span><span class="s3">\n    </span><span class="s1">buildId,</span><span class="s3">\n  </span><span class="s1">}: ContinueStaticPrerenderOptions</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">prerenderStream</span><span class="s3">\n      </span><span class="s1">// Buffer everything to avoid flushing too frequently</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createBufferedTransformStream())</span><span class="s3">\n      </span><span class="s1">// Add build id comment to start of the HTML document (in export mode)</span><span class="s3">\n      </span><span class="s1">.pipeThrough(</span><span class="s3">\n        </span><span class="s1">createPrefetchCommentStream(isBuildTimePrerendering, buildId)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">// Insert generated tags to head</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))</span><span class="s3">\n      </span><span class="s1">// Transform metadata</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))</span><span class="s3">\n      </span><span class="s1">// Insert the inlined data (Flight data, form state, etc.) stream into the HTML</span><span class="s3">\n      </span><span class="s1">.pipeThrough(</span><span class="s3">\n        </span><span class="s1">createFlightDataInjectionTransformStream(inlinedDataStream, true)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">// Close tags should always be deferred to the end</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createMoveSuffixStream())</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type ContinueResumeOptions = {</span><span class="s3">\n  </span><span class="s1">inlinedDataStream: ReadableStream&lt;Uint8Array&gt;</span><span class="s3">\n  </span><span class="s1">getServerInsertedHTML: () =&gt; Promise&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">getServerInsertedMetadata: () =&gt; Promise&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">delayDataUntilFirstHtmlChunk: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function continueDynamicHTMLResume(</span><span class="s3">\n  </span><span class="s1">renderStream: ReadableStream&lt;Uint8Array&gt;,</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">delayDataUntilFirstHtmlChunk,</span><span class="s3">\n    </span><span class="s1">inlinedDataStream,</span><span class="s3">\n    </span><span class="s1">getServerInsertedHTML,</span><span class="s3">\n    </span><span class="s1">getServerInsertedMetadata,</span><span class="s3">\n  </span><span class="s1">}: ContinueResumeOptions</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">renderStream</span><span class="s3">\n      </span><span class="s1">// Buffer everything to avoid flushing too frequently</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createBufferedTransformStream())</span><span class="s3">\n      </span><span class="s1">// Insert generated tags to head</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))</span><span class="s3">\n      </span><span class="s1">// Transform metadata</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))</span><span class="s3">\n      </span><span class="s1">// Insert the inlined data (Flight data, form state, etc.) stream into the HTML</span><span class="s3">\n      </span><span class="s1">.pipeThrough(</span><span class="s3">\n        </span><span class="s1">createFlightDataInjectionTransformStream(</span><span class="s3">\n          </span><span class="s1">inlinedDataStream,</span><span class="s3">\n          </span><span class="s1">delayDataUntilFirstHtmlChunk</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">// Close tags should always be deferred to the end</span><span class="s3">\n      </span><span class="s1">.pipeThrough(createMoveSuffixStream())</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function createDocumentClosingStream(): ReadableStream&lt;Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">return streamFromString(CLOSE_TAG)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export const ENCODED_TAGS = {</span><span class="s3">\n  </span><span class="s1">// opening tags do not have the closing `&gt;` since they can contain other attributes such as `&lt;body className=''&gt;`</span><span class="s3">\n  </span><span class="s1">OPENING: {</span><span class="s3">\n    </span><span class="s1">// &lt;html</span><span class="s3">\n    </span><span class="s1">HTML: new Uint8Array([60, 104, 116, 109, 108]),</span><span class="s3">\n    </span><span class="s1">// &lt;body</span><span class="s3">\n    </span><span class="s1">BODY: new Uint8Array([60, 98, 111, 100, 121]),</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">CLOSED: {</span><span class="s3">\n    </span><span class="s1">// &lt;/head&gt;</span><span class="s3">\n    </span><span class="s1">HEAD: new Uint8Array([60, 47, 104, 101, 97, 100, 62]),</span><span class="s3">\n    </span><span class="s1">// &lt;/body&gt;</span><span class="s3">\n    </span><span class="s1">BODY: new Uint8Array([60, 47, 98, 111, 100, 121, 62]),</span><span class="s3">\n    </span><span class="s1">// &lt;/html&gt;</span><span class="s3">\n    </span><span class="s1">HTML: new Uint8Array([60, 47, 104, 116, 109, 108, 62]),</span><span class="s3">\n    </span><span class="s1">// &lt;/body&gt;&lt;/html&gt;</span><span class="s3">\n    </span><span class="s1">BODY_AND_HTML: new Uint8Array([</span><span class="s3">\n      </span><span class="s1">60, 47, 98, 111, 100, 121, 62, 60, 47, 104, 116, 109, 108, 62,</span><span class="s3">\n    </span><span class="s1">]),</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">META: {</span><span class="s3">\n    </span><span class="s1">// Only the match the prefix cause the suffix can be different wether it's xml compatible or not </span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot; </span><span class="s1">or </span><span class="s3">\&quot;</span><span class="s1">/&gt;</span><span class="s3">\&quot;\n    </span><span class="s1">// &lt;meta name=</span><span class="s3">\&quot;</span><span class="s1">nxt-icon</span><span class="s3">\&quot;\n    </span><span class="s1">// This is a special mark that will be replaced by the icon insertion script tag.</span><span class="s3">\n    </span><span class="s1">ICON_MARK: new Uint8Array([</span><span class="s3">\n      </span><span class="s1">60, 109, 101, 116, 97, 32, 110, 97, 109, 101, 61, 34, 194, 171, 110, 120,</span><span class="s3">\n      </span><span class="s1">116, 45, 105, 99, 111, 110, 194, 187, 34,</span><span class="s3">\n    </span><span class="s1">]),</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">} as const</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { parsePath } from './parse-path'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Adds the provided prefix to the given path. It first ensures that the path</span><span class="s3">\n </span><span class="s1">* is indeed starting with a slash.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function addPathPrefix(path: string, prefix?: string) {</span><span class="s3">\n  </span><span class="s1">if (!path.startsWith('/') || !prefix) {</span><span class="s3">\n    </span><span class="s1">return path</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { pathname, query, hash } = parsePath(path)</span><span class="s3">\n  </span><span class="s1">return `${prefix}${pathname}${query}${hash}`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { parsePath } from './parse-path'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Similarly to `addPathPrefix`, this function adds a suffix at the end on the</span><span class="s3">\n </span><span class="s1">* provided path. It also works only for paths ensuring the argument starts</span><span class="s3">\n </span><span class="s1">* with a slash.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function addPathSuffix(path: string, suffix?: string) {</span><span class="s3">\n  </span><span class="s1">if (!path.startsWith('/') || !suffix) {</span><span class="s3">\n    </span><span class="s1">return path</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { pathname, query, hash } = parsePath(path)</span><span class="s3">\n  </span><span class="s1">return `${pathname}${suffix}${query}${hash}`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { OutgoingHttpHeaders } from 'http'</span><span class="s3">\n</span><span class="s1">import type { DomainLocale, I18NConfig } from '../config-shared'</span><span class="s3">\n</span><span class="s1">import type { I18NProvider } from '../lib/i18n-provider'</span><span class="s3">\n\n</span><span class="s1">import { detectDomainLocale } from '../../shared/lib/i18n/detect-domain-locale'</span><span class="s3">\n</span><span class="s1">import { formatNextPathnameInfo } from '../../shared/lib/router/utils/format-next-pathname-info'</span><span class="s3">\n</span><span class="s1">import { getHostname } from '../../shared/lib/get-hostname'</span><span class="s3">\n</span><span class="s1">import { getNextPathnameInfo } from '../../shared/lib/router/utils/get-next-pathname-info'</span><span class="s3">\n\n</span><span class="s1">interface Options {</span><span class="s3">\n  </span><span class="s1">base?: string | URL</span><span class="s3">\n  </span><span class="s1">headers?: OutgoingHttpHeaders</span><span class="s3">\n  </span><span class="s1">forceLocale?: boolean</span><span class="s3">\n  </span><span class="s1">nextConfig?: {</span><span class="s3">\n    </span><span class="s1">basePath?: string</span><span class="s3">\n    </span><span class="s1">i18n?: I18NConfig | null</span><span class="s3">\n    </span><span class="s1">trailingSlash?: boolean</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">i18nProvider?: I18NProvider</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const REGEX_LOCALHOST_HOSTNAME =</span><span class="s3">\n  </span><span class="s1">/(?!^https?:</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">/)(127(?:</span><span class="s3">\\</span><span class="s1">.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}|</span><span class="s3">\\</span><span class="s1">[::1</span><span class="s3">\\</span><span class="s1">]|localhost)/</span><span class="s3">\n\n</span><span class="s1">function parseURL(url: string | URL, base?: string | URL) {</span><span class="s3">\n  </span><span class="s1">return new URL(</span><span class="s3">\n    </span><span class="s1">String(url).replace(REGEX_LOCALHOST_HOSTNAME, 'localhost'),</span><span class="s3">\n    </span><span class="s1">base &amp;&amp; String(base).replace(REGEX_LOCALHOST_HOSTNAME, 'localhost')</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const Internal = Symbol('NextURLInternal')</span><span class="s3">\n\n</span><span class="s1">export class NextURL {</span><span class="s3">\n  </span><span class="s1">private [Internal]: {</span><span class="s3">\n    </span><span class="s1">basePath: string</span><span class="s3">\n    </span><span class="s1">buildId?: string</span><span class="s3">\n    </span><span class="s1">flightSearchParameters?: Record&lt;string, string&gt;</span><span class="s3">\n    </span><span class="s1">defaultLocale?: string</span><span class="s3">\n    </span><span class="s1">domainLocale?: DomainLocale</span><span class="s3">\n    </span><span class="s1">locale?: string</span><span class="s3">\n    </span><span class="s1">options: Options</span><span class="s3">\n    </span><span class="s1">trailingSlash?: boolean</span><span class="s3">\n    </span><span class="s1">url: URL</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">constructor(input: string | URL, base?: string | URL, opts?: Options)</span><span class="s3">\n  </span><span class="s1">constructor(input: string | URL, opts?: Options)</span><span class="s3">\n  </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">input: string | URL,</span><span class="s3">\n    </span><span class="s1">baseOrOpts?: string | URL | Options,</span><span class="s3">\n    </span><span class="s1">opts?: Options</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">let base: undefined | string | URL</span><span class="s3">\n    </span><span class="s1">let options: Options</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">(typeof baseOrOpts === 'object' &amp;&amp; 'pathname' in baseOrOpts) ||</span><span class="s3">\n      </span><span class="s1">typeof baseOrOpts === 'string'</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">base = baseOrOpts</span><span class="s3">\n      </span><span class="s1">options = opts || {}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">options = opts || baseOrOpts || {}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this[Internal] = {</span><span class="s3">\n      </span><span class="s1">url: parseURL(input, base ?? options.base),</span><span class="s3">\n      </span><span class="s1">options: options,</span><span class="s3">\n      </span><span class="s1">basePath: '',</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.analyze()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private analyze() {</span><span class="s3">\n    </span><span class="s1">const info = getNextPathnameInfo(this[Internal].url.pathname, {</span><span class="s3">\n      </span><span class="s1">nextConfig: this[Internal].options.nextConfig,</span><span class="s3">\n      </span><span class="s1">parseData: !process.env.__NEXT_NO_MIDDLEWARE_URL_NORMALIZE,</span><span class="s3">\n      </span><span class="s1">i18nProvider: this[Internal].options.i18nProvider,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">const hostname = getHostname(</span><span class="s3">\n      </span><span class="s1">this[Internal].url,</span><span class="s3">\n      </span><span class="s1">this[Internal].options.headers</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">this[Internal].domainLocale = this[Internal].options.i18nProvider</span><span class="s3">\n      </span><span class="s1">? this[Internal].options.i18nProvider.detectDomainLocale(hostname)</span><span class="s3">\n      </span><span class="s1">: detectDomainLocale(</span><span class="s3">\n          </span><span class="s1">this[Internal].options.nextConfig?.i18n?.domains,</span><span class="s3">\n          </span><span class="s1">hostname</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">const defaultLocale =</span><span class="s3">\n      </span><span class="s1">this[Internal].domainLocale?.defaultLocale ||</span><span class="s3">\n      </span><span class="s1">this[Internal].options.nextConfig?.i18n?.defaultLocale</span><span class="s3">\n\n    </span><span class="s1">this[Internal].url.pathname = info.pathname</span><span class="s3">\n    </span><span class="s1">this[Internal].defaultLocale = defaultLocale</span><span class="s3">\n    </span><span class="s1">this[Internal].basePath = info.basePath ?? ''</span><span class="s3">\n    </span><span class="s1">this[Internal].buildId = info.buildId</span><span class="s3">\n    </span><span class="s1">this[Internal].locale = info.locale ?? defaultLocale</span><span class="s3">\n    </span><span class="s1">this[Internal].trailingSlash = info.trailingSlash</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private formatPathname() {</span><span class="s3">\n    </span><span class="s1">return formatNextPathnameInfo({</span><span class="s3">\n      </span><span class="s1">basePath: this[Internal].basePath,</span><span class="s3">\n      </span><span class="s1">buildId: this[Internal].buildId,</span><span class="s3">\n      </span><span class="s1">defaultLocale: !this[Internal].options.forceLocale</span><span class="s3">\n        </span><span class="s1">? this[Internal].defaultLocale</span><span class="s3">\n        </span><span class="s1">: undefined,</span><span class="s3">\n      </span><span class="s1">locale: this[Internal].locale,</span><span class="s3">\n      </span><span class="s1">pathname: this[Internal].url.pathname,</span><span class="s3">\n      </span><span class="s1">trailingSlash: this[Internal].trailingSlash,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private formatSearch() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.search</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get buildId() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].buildId</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public set buildId(buildId: string | undefined) {</span><span class="s3">\n    </span><span class="s1">this[Internal].buildId = buildId</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get locale() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].locale ?? ''</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public set locale(locale: string) {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!this[Internal].locale ||</span><span class="s3">\n      </span><span class="s1">!this[Internal].options.nextConfig?.i18n?.locales.includes(locale)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">throw new TypeError(</span><span class="s3">\n        </span><span class="s1">`The NextURL configuration includes no locale </span><span class="s3">\&quot;</span><span class="s1">${locale}</span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this[Internal].locale = locale</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get defaultLocale() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].defaultLocale</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get domainLocale() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].domainLocale</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get searchParams() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.searchParams</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get host() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.host</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set host(value: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].url.host = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get hostname() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.hostname</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set hostname(value: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].url.hostname = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get port() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.port</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set port(value: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].url.port = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get protocol() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.protocol</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set protocol(value: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].url.protocol = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get href() {</span><span class="s3">\n    </span><span class="s1">const pathname = this.formatPathname()</span><span class="s3">\n    </span><span class="s1">const search = this.formatSearch()</span><span class="s3">\n    </span><span class="s1">return `${this.protocol}//${this.host}${pathname}${search}${this.hash}`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set href(url: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].url = parseURL(url)</span><span class="s3">\n    </span><span class="s1">this.analyze()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get origin() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.origin</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get pathname() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.pathname</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set pathname(value: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].url.pathname = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get hash() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.hash</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set hash(value: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].url.hash = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get search() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.search</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set search(value: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].url.search = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get password() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.password</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set password(value: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].url.password = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get username() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].url.username</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set username(value: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].url.username = value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get basePath() {</span><span class="s3">\n    </span><span class="s1">return this[Internal].basePath</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set basePath(value: string) {</span><span class="s3">\n    </span><span class="s1">this[Internal].basePath = value.startsWith('/') ? value : `/${value}`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">toString() {</span><span class="s3">\n    </span><span class="s1">return this.href</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">toJSON() {</span><span class="s3">\n    </span><span class="s1">return this.href</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[Symbol.for('edge-runtime.inspect.custom')]() {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">href: this.href,</span><span class="s3">\n      </span><span class="s1">origin: this.origin,</span><span class="s3">\n      </span><span class="s1">protocol: this.protocol,</span><span class="s3">\n      </span><span class="s1">username: this.username,</span><span class="s3">\n      </span><span class="s1">password: this.password,</span><span class="s3">\n      </span><span class="s1">host: this.host,</span><span class="s3">\n      </span><span class="s1">hostname: this.hostname,</span><span class="s3">\n      </span><span class="s1">port: this.port,</span><span class="s3">\n      </span><span class="s1">pathname: this.pathname,</span><span class="s3">\n      </span><span class="s1">search: this.search,</span><span class="s3">\n      </span><span class="s1">searchParams: this.searchParams,</span><span class="s3">\n      </span><span class="s1">hash: this.hash,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">clone() {</span><span class="s3">\n    </span><span class="s1">return new NextURL(String(this), this[Internal].options)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { normalizeLocalePath } from '../../i18n/normalize-locale-path'</span><span class="s3">\n</span><span class="s1">import { removePathPrefix } from './remove-path-prefix'</span><span class="s3">\n</span><span class="s1">import { pathHasPrefix } from './path-has-prefix'</span><span class="s3">\n</span><span class="s1">import type { I18NProvider } from '../../../../server/lib/i18n-provider'</span><span class="s3">\n\n</span><span class="s1">export interface NextPathnameInfo {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The base path in case the pathname included it.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">basePath?: string</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The buildId for when the parsed URL is a data URL. Parsing it can be</span><span class="s3">\n   </span><span class="s1">* disabled with the `parseData` option.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">buildId?: string</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* If there was a locale in the pathname, this will hold its value.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">locale?: string</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The processed pathname without a base path, locale, or data URL elements</span><span class="s3">\n   </span><span class="s1">* when parsing it is enabled.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">pathname: string</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A boolean telling if the pathname had a trailingSlash. This can be only</span><span class="s3">\n   </span><span class="s1">* true if trailingSlash is enabled.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">trailingSlash?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">interface Options {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When passed to true, this function will also parse Nextjs data URLs.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">parseData?: boolean</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A partial of the Next.js configuration to parse the URL.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">nextConfig?: {</span><span class="s3">\n    </span><span class="s1">basePath?: string</span><span class="s3">\n    </span><span class="s1">i18n?: { locales?: readonly string[] } | null</span><span class="s3">\n    </span><span class="s1">trailingSlash?: boolean</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* If provided, this normalizer will be used to detect the locale instead of</span><span class="s3">\n   </span><span class="s1">* the default locale detection.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">i18nProvider?: I18NProvider</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getNextPathnameInfo(</span><span class="s3">\n  </span><span class="s1">pathname: string,</span><span class="s3">\n  </span><span class="s1">options: Options</span><span class="s3">\n</span><span class="s1">): NextPathnameInfo {</span><span class="s3">\n  </span><span class="s1">const { basePath, i18n, trailingSlash } = options.nextConfig ?? {}</span><span class="s3">\n  </span><span class="s1">const info: NextPathnameInfo = {</span><span class="s3">\n    </span><span class="s1">pathname,</span><span class="s3">\n    </span><span class="s1">trailingSlash: pathname !== '/' ? pathname.endsWith('/') : trailingSlash,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (basePath &amp;&amp; pathHasPrefix(info.pathname, basePath)) {</span><span class="s3">\n    </span><span class="s1">info.pathname = removePathPrefix(info.pathname, basePath)</span><span class="s3">\n    </span><span class="s1">info.basePath = basePath</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">let pathnameNoDataPrefix = info.pathname</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">info.pathname.startsWith('/_next/data/') &amp;&amp;</span><span class="s3">\n    </span><span class="s1">info.pathname.endsWith('.json')</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">const paths = info.pathname</span><span class="s3">\n      </span><span class="s1">.replace(/^</span><span class="s3">\\</span><span class="s1">/_next</span><span class="s3">\\</span><span class="s1">/data</span><span class="s3">\\</span><span class="s1">//, '')</span><span class="s3">\n      </span><span class="s1">.replace(/</span><span class="s3">\\</span><span class="s1">.json$/, '')</span><span class="s3">\n      </span><span class="s1">.split('/')</span><span class="s3">\n\n    </span><span class="s1">const buildId = paths[0]</span><span class="s3">\n    </span><span class="s1">info.buildId = buildId</span><span class="s3">\n    </span><span class="s1">pathnameNoDataPrefix =</span><span class="s3">\n      </span><span class="s1">paths[1] !== 'index' ? `/${paths.slice(1).join('/')}` : '/'</span><span class="s3">\n\n    </span><span class="s1">// update pathname with normalized if enabled although</span><span class="s3">\n    </span><span class="s1">// we use normalized to populate locale info still</span><span class="s3">\n    </span><span class="s1">if (options.parseData === true) {</span><span class="s3">\n      </span><span class="s1">info.pathname = pathnameNoDataPrefix</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// If provided, use the locale route normalizer to detect the locale instead</span><span class="s3">\n  </span><span class="s1">// of the function below.</span><span class="s3">\n  </span><span class="s1">if (i18n) {</span><span class="s3">\n    </span><span class="s1">let result = options.i18nProvider</span><span class="s3">\n      </span><span class="s1">? options.i18nProvider.analyze(info.pathname)</span><span class="s3">\n      </span><span class="s1">: normalizeLocalePath(info.pathname, i18n.locales)</span><span class="s3">\n\n    </span><span class="s1">info.locale = result.detectedLocale</span><span class="s3">\n    </span><span class="s1">info.pathname = result.pathname ?? info.pathname</span><span class="s3">\n\n    </span><span class="s1">if (!result.detectedLocale &amp;&amp; info.buildId) {</span><span class="s3">\n      </span><span class="s1">result = options.i18nProvider</span><span class="s3">\n        </span><span class="s1">? options.i18nProvider.analyze(pathnameNoDataPrefix)</span><span class="s3">\n        </span><span class="s1">: normalizeLocalePath(pathnameNoDataPrefix, i18n.locales)</span><span class="s3">\n\n      </span><span class="s1">if (result.detectedLocale) {</span><span class="s3">\n        </span><span class="s1">info.locale = result.detectedLocale</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return info</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { NextPathnameInfo } from './get-next-pathname-info'</span><span class="s3">\n</span><span class="s1">import { removeTrailingSlash } from './remove-trailing-slash'</span><span class="s3">\n</span><span class="s1">import { addPathPrefix } from './add-path-prefix'</span><span class="s3">\n</span><span class="s1">import { addPathSuffix } from './add-path-suffix'</span><span class="s3">\n</span><span class="s1">import { addLocale } from './add-locale'</span><span class="s3">\n\n</span><span class="s1">interface ExtendedInfo extends NextPathnameInfo {</span><span class="s3">\n  </span><span class="s1">defaultLocale?: string</span><span class="s3">\n  </span><span class="s1">ignorePrefix?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function formatNextPathnameInfo(info: ExtendedInfo) {</span><span class="s3">\n  </span><span class="s1">let pathname = addLocale(</span><span class="s3">\n    </span><span class="s1">info.pathname,</span><span class="s3">\n    </span><span class="s1">info.locale,</span><span class="s3">\n    </span><span class="s1">info.buildId ? undefined : info.defaultLocale,</span><span class="s3">\n    </span><span class="s1">info.ignorePrefix</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">if (info.buildId || !info.trailingSlash) {</span><span class="s3">\n    </span><span class="s1">pathname = removeTrailingSlash(pathname)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (info.buildId) {</span><span class="s3">\n    </span><span class="s1">pathname = addPathSuffix(</span><span class="s3">\n      </span><span class="s1">addPathPrefix(pathname, `/_next/data/${info.buildId}`),</span><span class="s3">\n      </span><span class="s1">info.pathname === '/' ? 'index.json' : '.json'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">pathname = addPathPrefix(pathname, info.basePath)</span><span class="s3">\n  </span><span class="s1">return !info.buildId &amp;&amp; info.trailingSlash</span><span class="s3">\n    </span><span class="s1">? !pathname.endsWith('/')</span><span class="s3">\n      </span><span class="s1">? addPathSuffix(pathname, '/')</span><span class="s3">\n      </span><span class="s1">: pathname</span><span class="s3">\n    </span><span class="s1">: removeTrailingSlash(pathname)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { addPathPrefix } from './add-path-prefix'</span><span class="s3">\n</span><span class="s1">import { pathHasPrefix } from './path-has-prefix'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* For a given path and a locale, if the locale is given, it will prefix the</span><span class="s3">\n </span><span class="s1">* locale. The path shouldn't be an API path. If a default locale is given the</span><span class="s3">\n </span><span class="s1">* prefix will be omitted if the locale is already the default locale.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function addLocale(</span><span class="s3">\n  </span><span class="s1">path: string,</span><span class="s3">\n  </span><span class="s1">locale?: string | false,</span><span class="s3">\n  </span><span class="s1">defaultLocale?: string,</span><span class="s3">\n  </span><span class="s1">ignorePrefix?: boolean</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// If no locale was given or the locale is the default locale, we don't need</span><span class="s3">\n  </span><span class="s1">// to prefix the path.</span><span class="s3">\n  </span><span class="s1">if (!locale || locale === defaultLocale) return path</span><span class="s3">\n\n  </span><span class="s1">const lower = path.toLowerCase()</span><span class="s3">\n\n  </span><span class="s1">// If the path is an API path or the path already has the locale prefix, we</span><span class="s3">\n  </span><span class="s1">// don't need to prefix the path.</span><span class="s3">\n  </span><span class="s1">if (!ignorePrefix) {</span><span class="s3">\n    </span><span class="s1">if (pathHasPrefix(lower, '/api')) return path</span><span class="s3">\n    </span><span class="s1">if (pathHasPrefix(lower, `/${locale.toLowerCase()}`)) return path</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Add the locale prefix to the path.</span><span class="s3">\n  </span><span class="s1">return addPathPrefix(path, `/${locale}`)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { I18NConfig } from '../../config-shared'</span><span class="s3">\n</span><span class="s1">import { NextURL } from '../next-url'</span><span class="s3">\n</span><span class="s1">import { toNodeOutgoingHttpHeaders, validateURL } from '../utils'</span><span class="s3">\n</span><span class="s1">import { RemovedUAError, RemovedPageError } from '../error'</span><span class="s3">\n</span><span class="s1">import { RequestCookies } from './cookies'</span><span class="s3">\n\n</span><span class="s1">export const INTERNALS = Symbol('internal request')</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This class extends the [Web `Request` API](https://developer.mozilla.org/docs/Web/API/Request) with additional convenience methods.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Read more: [Next.js Docs: `NextRequest`](https://nextjs.org/docs/app/api-reference/functions/next-request)</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class NextRequest extends Request {</span><span class="s3">\n  </span><span class="s1">/** @internal */</span><span class="s3">\n  </span><span class="s1">[INTERNALS]: {</span><span class="s3">\n    </span><span class="s1">cookies: RequestCookies</span><span class="s3">\n    </span><span class="s1">url: string</span><span class="s3">\n    </span><span class="s1">nextUrl: NextURL</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">constructor(input: URL | RequestInfo, init: RequestInit = {}) {</span><span class="s3">\n    </span><span class="s1">const url =</span><span class="s3">\n      </span><span class="s1">typeof input !== 'string' &amp;&amp; 'url' in input ? input.url : String(input)</span><span class="s3">\n\n    </span><span class="s1">validateURL(url)</span><span class="s3">\n\n    </span><span class="s1">// node Request instance requires duplex option when a body</span><span class="s3">\n    </span><span class="s1">// is present or it errors, we don't handle this for</span><span class="s3">\n    </span><span class="s1">// Request being passed in since it would have already</span><span class="s3">\n    </span><span class="s1">// errored if this wasn't configured</span><span class="s3">\n    </span><span class="s1">if (process.env.NEXT_RUNTIME !== 'edge') {</span><span class="s3">\n      </span><span class="s1">if (init.body &amp;&amp; init.duplex !== 'half') {</span><span class="s3">\n        </span><span class="s1">init.duplex = 'half'</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (input instanceof Request) super(input, init)</span><span class="s3">\n    </span><span class="s1">else super(url, init)</span><span class="s3">\n\n    </span><span class="s1">const nextUrl = new NextURL(url, {</span><span class="s3">\n      </span><span class="s1">headers: toNodeOutgoingHttpHeaders(this.headers),</span><span class="s3">\n      </span><span class="s1">nextConfig: init.nextConfig,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">this[INTERNALS] = {</span><span class="s3">\n      </span><span class="s1">cookies: new RequestCookies(this.headers),</span><span class="s3">\n      </span><span class="s1">nextUrl,</span><span class="s3">\n      </span><span class="s1">url: process.env.__NEXT_NO_MIDDLEWARE_URL_NORMALIZE</span><span class="s3">\n        </span><span class="s1">? url</span><span class="s3">\n        </span><span class="s1">: nextUrl.toString(),</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[Symbol.for('edge-runtime.inspect.custom')]() {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">cookies: this.cookies,</span><span class="s3">\n      </span><span class="s1">nextUrl: this.nextUrl,</span><span class="s3">\n      </span><span class="s1">url: this.url,</span><span class="s3">\n      </span><span class="s1">// rest of props come from Request</span><span class="s3">\n      </span><span class="s1">bodyUsed: this.bodyUsed,</span><span class="s3">\n      </span><span class="s1">cache: this.cache,</span><span class="s3">\n      </span><span class="s1">credentials: this.credentials,</span><span class="s3">\n      </span><span class="s1">destination: this.destination,</span><span class="s3">\n      </span><span class="s1">headers: Object.fromEntries(this.headers),</span><span class="s3">\n      </span><span class="s1">integrity: this.integrity,</span><span class="s3">\n      </span><span class="s1">keepalive: this.keepalive,</span><span class="s3">\n      </span><span class="s1">method: this.method,</span><span class="s3">\n      </span><span class="s1">mode: this.mode,</span><span class="s3">\n      </span><span class="s1">redirect: this.redirect,</span><span class="s3">\n      </span><span class="s1">referrer: this.referrer,</span><span class="s3">\n      </span><span class="s1">referrerPolicy: this.referrerPolicy,</span><span class="s3">\n      </span><span class="s1">signal: this.signal,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get cookies() {</span><span class="s3">\n    </span><span class="s1">return this[INTERNALS].cookies</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get nextUrl() {</span><span class="s3">\n    </span><span class="s1">return this[INTERNALS].nextUrl</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @deprecated</span><span class="s3">\n   </span><span class="s1">* `page` has been deprecated in favour of `URLPattern`.</span><span class="s3">\n   </span><span class="s1">* Read more: https://nextjs.org/docs/messages/middleware-request-page</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public get page() {</span><span class="s3">\n    </span><span class="s1">throw new RemovedPageError()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @deprecated</span><span class="s3">\n   </span><span class="s1">* `ua` has been removed in favour of </span><span class="s3">\\</span><span class="s1">`userAgent</span><span class="s3">\\</span><span class="s1">` function.</span><span class="s3">\n   </span><span class="s1">* Read more: https://nextjs.org/docs/messages/middleware-parse-user-agent</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public get ua() {</span><span class="s3">\n    </span><span class="s1">throw new RemovedUAError()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public get url() {</span><span class="s3">\n    </span><span class="s1">return this[INTERNALS].url</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface RequestInit extends globalThis.RequestInit {</span><span class="s3">\n  </span><span class="s1">nextConfig?: {</span><span class="s3">\n    </span><span class="s1">basePath?: string</span><span class="s3">\n    </span><span class="s1">i18n?: I18NConfig | null</span><span class="s3">\n    </span><span class="s1">trailingSlash?: boolean</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">signal?: AbortSignal</span><span class="s3">\n  </span><span class="s1">// see https://github.com/whatwg/fetch/pull/1457</span><span class="s3">\n  </span><span class="s1">duplex?: 'half'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { BaseNextRequest } from '../../../base-http'</span><span class="s3">\n</span><span class="s1">import type { NodeNextRequest } from '../../../base-http/node'</span><span class="s3">\n</span><span class="s1">import type { WebNextRequest } from '../../../base-http/web'</span><span class="s3">\n</span><span class="s1">import type { Writable } from 'node:stream'</span><span class="s3">\n\n</span><span class="s1">import { getRequestMeta } from '../../../request-meta'</span><span class="s3">\n</span><span class="s1">import { fromNodeOutgoingHttpHeaders } from '../../utils'</span><span class="s3">\n</span><span class="s1">import { NextRequest } from '../request'</span><span class="s3">\n</span><span class="s1">import { isNodeNextRequest, isWebNextRequest } from '../../../base-http/helpers'</span><span class="s3">\n\n</span><span class="s1">export const ResponseAbortedName = 'ResponseAborted'</span><span class="s3">\n</span><span class="s1">export class ResponseAborted extends Error {</span><span class="s3">\n  </span><span class="s1">public readonly name = ResponseAbortedName</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates an AbortController tied to the closing of a ServerResponse (or other</span><span class="s3">\n </span><span class="s1">* appropriate Writable).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* If the `close` event is fired before the `finish` event, then we'll send the</span><span class="s3">\n </span><span class="s1">* `abort` signal.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function createAbortController(response: Writable): AbortController {</span><span class="s3">\n  </span><span class="s1">const controller = new AbortController()</span><span class="s3">\n\n  </span><span class="s1">// If `finish` fires first, then `res.end()` has been called and the close is</span><span class="s3">\n  </span><span class="s1">// just us finishing the stream on our side. If `close` fires first, then we</span><span class="s3">\n  </span><span class="s1">// know the client disconnected before we finished.</span><span class="s3">\n  </span><span class="s1">response.once('close', () =&gt; {</span><span class="s3">\n    </span><span class="s1">if (response.writableFinished) return</span><span class="s3">\n\n    </span><span class="s1">controller.abort(new ResponseAborted())</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">return controller</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates an AbortSignal tied to the closing of a ServerResponse (or other</span><span class="s3">\n </span><span class="s1">* appropriate Writable).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This cannot be done with the request (IncomingMessage or Readable) because</span><span class="s3">\n </span><span class="s1">* the `abort` event will not fire if to data has been fully read (because that</span><span class="s3">\n </span><span class="s1">* will </span><span class="s3">\&quot;</span><span class="s1">close</span><span class="s3">\&quot; </span><span class="s1">the readable stream and nothing fires after that).</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function signalFromNodeResponse(response: Writable): AbortSignal {</span><span class="s3">\n  </span><span class="s1">const { errored, destroyed } = response</span><span class="s3">\n  </span><span class="s1">if (errored || destroyed) {</span><span class="s3">\n    </span><span class="s1">return AbortSignal.abort(errored ?? new ResponseAborted())</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { signal } = createAbortController(response)</span><span class="s3">\n  </span><span class="s1">return signal</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class NextRequestAdapter {</span><span class="s3">\n  </span><span class="s1">public static fromBaseNextRequest(</span><span class="s3">\n    </span><span class="s1">request: BaseNextRequest,</span><span class="s3">\n    </span><span class="s1">signal: AbortSignal</span><span class="s3">\n  </span><span class="s1">): NextRequest {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">// The type check here ensures that `req` is correctly typed, and the</span><span class="s3">\n      </span><span class="s1">// environment variable check provides dead code elimination.</span><span class="s3">\n      </span><span class="s1">process.env.NEXT_RUNTIME === 'edge' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">isWebNextRequest(request)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return NextRequestAdapter.fromWebNextRequest(request)</span><span class="s3">\n    </span><span class="s1">} else if (</span><span class="s3">\n      </span><span class="s1">// The type check here ensures that `req` is correctly typed, and the</span><span class="s3">\n      </span><span class="s1">// environment variable check provides dead code elimination.</span><span class="s3">\n      </span><span class="s1">process.env.NEXT_RUNTIME !== 'edge' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">isNodeNextRequest(request)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return NextRequestAdapter.fromNodeNextRequest(request, signal)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">throw new Error('Invariant: Unsupported NextRequest type')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public static fromNodeNextRequest(</span><span class="s3">\n    </span><span class="s1">request: NodeNextRequest,</span><span class="s3">\n    </span><span class="s1">signal: AbortSignal</span><span class="s3">\n  </span><span class="s1">): NextRequest {</span><span class="s3">\n    </span><span class="s1">// HEAD and GET requests can not have a body.</span><span class="s3">\n    </span><span class="s1">let body: BodyInit | null = null</span><span class="s3">\n    </span><span class="s1">if (request.method !== 'GET' &amp;&amp; request.method !== 'HEAD' &amp;&amp; request.body) {</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error - this is handled by undici, when streams/web land use it instead</span><span class="s3">\n      </span><span class="s1">body = request.body</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let url: URL</span><span class="s3">\n    </span><span class="s1">if (request.url.startsWith('http')) {</span><span class="s3">\n      </span><span class="s1">url = new URL(request.url)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// Grab the full URL from the request metadata.</span><span class="s3">\n      </span><span class="s1">const base = getRequestMeta(request, 'initURL')</span><span class="s3">\n      </span><span class="s1">if (!base || !base.startsWith('http')) {</span><span class="s3">\n        </span><span class="s1">// Because the URL construction relies on the fact that the URL provided</span><span class="s3">\n        </span><span class="s1">// is absolute, we need to provide a base URL. We can't use the request</span><span class="s3">\n        </span><span class="s1">// URL because it's relative, so we use a dummy URL instead.</span><span class="s3">\n        </span><span class="s1">url = new URL(request.url, 'http://n')</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">url = new URL(request.url, base)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return new NextRequest(url, {</span><span class="s3">\n      </span><span class="s1">method: request.method,</span><span class="s3">\n      </span><span class="s1">headers: fromNodeOutgoingHttpHeaders(request.headers),</span><span class="s3">\n      </span><span class="s1">duplex: 'half',</span><span class="s3">\n      </span><span class="s1">signal,</span><span class="s3">\n      </span><span class="s1">// geo</span><span class="s3">\n      </span><span class="s1">// ip</span><span class="s3">\n      </span><span class="s1">// nextConfig</span><span class="s3">\n\n      </span><span class="s1">// body can not be passed if request was aborted</span><span class="s3">\n      </span><span class="s1">// or we get a Request body was disturbed error</span><span class="s3">\n      </span><span class="s1">...(signal.aborted</span><span class="s3">\n        </span><span class="s1">? {}</span><span class="s3">\n        </span><span class="s1">: {</span><span class="s3">\n            </span><span class="s1">body,</span><span class="s3">\n          </span><span class="s1">}),</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public static fromWebNextRequest(request: WebNextRequest): NextRequest {</span><span class="s3">\n    </span><span class="s1">// HEAD and GET requests can not have a body.</span><span class="s3">\n    </span><span class="s1">let body: ReadableStream | null = null</span><span class="s3">\n    </span><span class="s1">if (request.method !== 'GET' &amp;&amp; request.method !== 'HEAD') {</span><span class="s3">\n      </span><span class="s1">body = request.body</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return new NextRequest(request.url, {</span><span class="s3">\n      </span><span class="s1">method: request.method,</span><span class="s3">\n      </span><span class="s1">headers: fromNodeOutgoingHttpHeaders(request.headers),</span><span class="s3">\n      </span><span class="s1">duplex: 'half',</span><span class="s3">\n      </span><span class="s1">signal: request.request.signal,</span><span class="s3">\n      </span><span class="s1">// geo</span><span class="s3">\n      </span><span class="s1">// ip</span><span class="s3">\n      </span><span class="s1">// nextConfig</span><span class="s3">\n\n      </span><span class="s1">// body can not be passed if request was aborted</span><span class="s3">\n      </span><span class="s1">// or we get a Request body was disturbed error</span><span class="s3">\n      </span><span class="s1">...(request.request.signal.aborted</span><span class="s3">\n        </span><span class="s1">? {}</span><span class="s3">\n        </span><span class="s1">: {</span><span class="s3">\n            </span><span class="s1">body,</span><span class="s3">\n          </span><span class="s1">}),</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { AppPageModule } from './route-modules/app-page/module'</span><span class="s3">\n\n</span><span class="s1">// Combined load times for loading client components</span><span class="s3">\n</span><span class="s1">let clientComponentLoadStart = 0</span><span class="s3">\n</span><span class="s1">let clientComponentLoadTimes = 0</span><span class="s3">\n</span><span class="s1">let clientComponentLoadCount = 0</span><span class="s3">\n\n</span><span class="s1">export function wrapClientComponentLoader(</span><span class="s3">\n  </span><span class="s1">ComponentMod: AppPageModule</span><span class="s3">\n</span><span class="s1">): AppPageModule['__next_app__'] {</span><span class="s3">\n  </span><span class="s1">if (!('performance' in globalThis)) {</span><span class="s3">\n    </span><span class="s1">return ComponentMod.__next_app__</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">require: (...args) =&gt; {</span><span class="s3">\n      </span><span class="s1">const startTime = performance.now()</span><span class="s3">\n\n      </span><span class="s1">if (clientComponentLoadStart === 0) {</span><span class="s3">\n        </span><span class="s1">clientComponentLoadStart = startTime</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">clientComponentLoadCount += 1</span><span class="s3">\n        </span><span class="s1">return ComponentMod.__next_app__.require(...args)</span><span class="s3">\n      </span><span class="s1">} finally {</span><span class="s3">\n        </span><span class="s1">clientComponentLoadTimes += performance.now() - startTime</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">loadChunk: (...args) =&gt; {</span><span class="s3">\n      </span><span class="s1">const startTime = performance.now()</span><span class="s3">\n      </span><span class="s1">const result = ComponentMod.__next_app__.loadChunk(...args)</span><span class="s3">\n      </span><span class="s1">// Avoid wrapping `loadChunk`'s result in an extra promise in case something like React depends on its identity.</span><span class="s3">\n      </span><span class="s1">// We only need to know when it's settled.</span><span class="s3">\n      </span><span class="s1">result.finally(() =&gt; {</span><span class="s3">\n        </span><span class="s1">clientComponentLoadTimes += performance.now() - startTime</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">return result</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getClientComponentLoaderMetrics(</span><span class="s3">\n  </span><span class="s1">options: { reset?: boolean } = {}</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const metrics =</span><span class="s3">\n    </span><span class="s1">clientComponentLoadStart === 0</span><span class="s3">\n      </span><span class="s1">? undefined</span><span class="s3">\n      </span><span class="s1">: {</span><span class="s3">\n          </span><span class="s1">clientComponentLoadStart,</span><span class="s3">\n          </span><span class="s1">clientComponentLoadTimes,</span><span class="s3">\n          </span><span class="s1">clientComponentLoadCount,</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (options.reset) {</span><span class="s3">\n    </span><span class="s1">clientComponentLoadStart = 0</span><span class="s3">\n    </span><span class="s1">clientComponentLoadTimes = 0</span><span class="s3">\n    </span><span class="s1">clientComponentLoadCount = 0</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return metrics</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { ServerResponse } from 'node:http'</span><span class="s3">\n\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">ResponseAbortedName,</span><span class="s3">\n  </span><span class="s1">createAbortController,</span><span class="s3">\n</span><span class="s1">} from './web/spec-extension/adapters/next-request'</span><span class="s3">\n</span><span class="s1">import { DetachedPromise } from '../lib/detached-promise'</span><span class="s3">\n</span><span class="s1">import { getTracer } from './lib/trace/tracer'</span><span class="s3">\n</span><span class="s1">import { NextNodeServerSpan } from './lib/trace/constants'</span><span class="s3">\n</span><span class="s1">import { getClientComponentLoaderMetrics } from './client-component-renderer-logger'</span><span class="s3">\n\n</span><span class="s1">export function isAbortError(e: any): e is Error &amp; { name: 'AbortError' } {</span><span class="s3">\n  </span><span class="s1">return e?.name === 'AbortError' || e?.name === ResponseAbortedName</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createWriterFromResponse(</span><span class="s3">\n  </span><span class="s1">res: ServerResponse,</span><span class="s3">\n  </span><span class="s1">waitUntilForEnd?: Promise&lt;unknown&gt;</span><span class="s3">\n</span><span class="s1">): WritableStream&lt;Uint8Array&gt; {</span><span class="s3">\n  </span><span class="s1">let started = false</span><span class="s3">\n\n  </span><span class="s1">// Create a promise that will resolve once the response has drained. See</span><span class="s3">\n  </span><span class="s1">// https://nodejs.org/api/stream.html#stream_event_drain</span><span class="s3">\n  </span><span class="s1">let drained = new DetachedPromise&lt;void&gt;()</span><span class="s3">\n  </span><span class="s1">function onDrain() {</span><span class="s3">\n    </span><span class="s1">drained.resolve()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">res.on('drain', onDrain)</span><span class="s3">\n\n  </span><span class="s1">// If the finish event fires, it means we shouldn't block and wait for the</span><span class="s3">\n  </span><span class="s1">// drain event.</span><span class="s3">\n  </span><span class="s1">res.once('close', () =&gt; {</span><span class="s3">\n    </span><span class="s1">res.off('drain', onDrain)</span><span class="s3">\n    </span><span class="s1">drained.resolve()</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">// Create a promise that will resolve once the response has finished. See</span><span class="s3">\n  </span><span class="s1">// https://nodejs.org/api/http.html#event-finish_1</span><span class="s3">\n  </span><span class="s1">const finished = new DetachedPromise&lt;void&gt;()</span><span class="s3">\n  </span><span class="s1">res.once('finish', () =&gt; {</span><span class="s3">\n    </span><span class="s1">finished.resolve()</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">// Create a writable stream that will write to the response.</span><span class="s3">\n  </span><span class="s1">return new WritableStream&lt;Uint8Array&gt;({</span><span class="s3">\n    </span><span class="s1">write: async (chunk) =&gt; {</span><span class="s3">\n      </span><span class="s1">// You'd think we'd want to use `start` instead of placing this in `write`</span><span class="s3">\n      </span><span class="s1">// but this ensures that we don't actually flush the headers until we've</span><span class="s3">\n      </span><span class="s1">// started writing chunks.</span><span class="s3">\n      </span><span class="s1">if (!started) {</span><span class="s3">\n        </span><span class="s1">started = true</span><span class="s3">\n\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">'performance' in globalThis &amp;&amp;</span><span class="s3">\n          </span><span class="s1">process.env.NEXT_OTEL_PERFORMANCE_PREFIX</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">const metrics = getClientComponentLoaderMetrics()</span><span class="s3">\n          </span><span class="s1">if (metrics) {</span><span class="s3">\n            </span><span class="s1">performance.measure(</span><span class="s3">\n              </span><span class="s1">`${process.env.NEXT_OTEL_PERFORMANCE_PREFIX}:next-client-component-loading`,</span><span class="s3">\n              </span><span class="s1">{</span><span class="s3">\n                </span><span class="s1">start: metrics.clientComponentLoadStart,</span><span class="s3">\n                </span><span class="s1">end:</span><span class="s3">\n                  </span><span class="s1">metrics.clientComponentLoadStart +</span><span class="s3">\n                  </span><span class="s1">metrics.clientComponentLoadTimes,</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">res.flushHeaders()</span><span class="s3">\n        </span><span class="s1">getTracer().trace(</span><span class="s3">\n          </span><span class="s1">NextNodeServerSpan.startResponse,</span><span class="s3">\n          </span><span class="s1">{</span><span class="s3">\n            </span><span class="s1">spanName: 'start response',</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">() =&gt; undefined</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">const ok = res.write(chunk)</span><span class="s3">\n\n        </span><span class="s1">// Added by the `compression` middleware, this is a function that will</span><span class="s3">\n        </span><span class="s1">// flush the partially-compressed response to the client.</span><span class="s3">\n        </span><span class="s1">if ('flush' in res &amp;&amp; typeof res.flush === 'function') {</span><span class="s3">\n          </span><span class="s1">res.flush()</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// If the write returns false, it means there's some backpressure, so</span><span class="s3">\n        </span><span class="s1">// wait until it's streamed before continuing.</span><span class="s3">\n        </span><span class="s1">if (!ok) {</span><span class="s3">\n          </span><span class="s1">await drained.promise</span><span class="s3">\n\n          </span><span class="s1">// Reset the drained promise so that we can wait for the next drain event.</span><span class="s3">\n          </span><span class="s1">drained = new DetachedPromise&lt;void&gt;()</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} catch (err) {</span><span class="s3">\n        </span><span class="s1">res.end()</span><span class="s3">\n        </span><span class="s1">throw new Error('failed to write chunk to response', { cause: err })</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">abort: (err) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (res.writableFinished) return</span><span class="s3">\n\n      </span><span class="s1">res.destroy(err)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">close: async () =&gt; {</span><span class="s3">\n      </span><span class="s1">// if a waitUntil promise was passed, wait for it to resolve before</span><span class="s3">\n      </span><span class="s1">// ending the response.</span><span class="s3">\n      </span><span class="s1">if (waitUntilForEnd) {</span><span class="s3">\n        </span><span class="s1">await waitUntilForEnd</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (res.writableFinished) return</span><span class="s3">\n\n      </span><span class="s1">res.end()</span><span class="s3">\n      </span><span class="s1">return finished.promise</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function pipeToNodeResponse(</span><span class="s3">\n  </span><span class="s1">readable: ReadableStream&lt;Uint8Array&gt;,</span><span class="s3">\n  </span><span class="s1">res: ServerResponse,</span><span class="s3">\n  </span><span class="s1">waitUntilForEnd?: Promise&lt;unknown&gt;</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">// If the response has already errored, then just return now.</span><span class="s3">\n    </span><span class="s1">const { errored, destroyed } = res</span><span class="s3">\n    </span><span class="s1">if (errored || destroyed) return</span><span class="s3">\n\n    </span><span class="s1">// Create a new AbortController so that we can abort the readable if the</span><span class="s3">\n    </span><span class="s1">// client disconnects.</span><span class="s3">\n    </span><span class="s1">const controller = createAbortController(res)</span><span class="s3">\n\n    </span><span class="s1">const writer = createWriterFromResponse(res, waitUntilForEnd)</span><span class="s3">\n\n    </span><span class="s1">await readable.pipeTo(writer, { signal: controller.signal })</span><span class="s3">\n  </span><span class="s1">} catch (err: any) {</span><span class="s3">\n    </span><span class="s1">// If this isn't related to an abort error, re-throw it.</span><span class="s3">\n    </span><span class="s1">if (isAbortError(err)) return</span><span class="s3">\n\n    </span><span class="s1">throw new Error('failed to pipe response', { cause: err })</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export class InvariantError extends Error {</span><span class="s3">\n  </span><span class="s1">constructor(message: string, options?: ErrorOptions) {</span><span class="s3">\n    </span><span class="s1">super(</span><span class="s3">\n      </span><span class="s1">`Invariant: ${message.endsWith('.') ? message : message + '.'} This is a bug in Next.js.`,</span><span class="s3">\n      </span><span class="s1">options</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">this.name = 'InvariantError'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { OutgoingHttpHeaders, ServerResponse } from 'http'</span><span class="s3">\n</span><span class="s1">import type { CacheControl } from './lib/cache-control'</span><span class="s3">\n</span><span class="s1">import type { FetchMetrics } from './base-http'</span><span class="s3">\n\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">chainStreams,</span><span class="s3">\n  </span><span class="s1">streamFromBuffer,</span><span class="s3">\n  </span><span class="s1">streamFromString,</span><span class="s3">\n  </span><span class="s1">streamToString,</span><span class="s3">\n</span><span class="s1">} from './stream-utils/node-web-streams-helper'</span><span class="s3">\n</span><span class="s1">import { isAbortError, pipeToNodeResponse } from './pipe-readable'</span><span class="s3">\n</span><span class="s1">import type { RenderResumeDataCache } from './resume-data-cache/resume-data-cache'</span><span class="s3">\n</span><span class="s1">import { InvariantError } from '../shared/lib/invariant-error'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">HTML_CONTENT_TYPE_HEADER,</span><span class="s3">\n  </span><span class="s1">JSON_CONTENT_TYPE_HEADER,</span><span class="s3">\n  </span><span class="s1">TEXT_PLAIN_CONTENT_TYPE_HEADER,</span><span class="s3">\n</span><span class="s1">} from '../lib/constants'</span><span class="s3">\n</span><span class="s1">import type { RSC_CONTENT_TYPE_HEADER } from '../client/components/app-router-headers'</span><span class="s3">\n\n</span><span class="s1">type ContentTypeOption =</span><span class="s3">\n  </span><span class="s1">| typeof RSC_CONTENT_TYPE_HEADER // For App Page RSC responses</span><span class="s3">\n  </span><span class="s1">| typeof HTML_CONTENT_TYPE_HEADER // For App Page, Pages HTML responses</span><span class="s3">\n  </span><span class="s1">| typeof JSON_CONTENT_TYPE_HEADER // For API routes, Next.js data requests</span><span class="s3">\n  </span><span class="s1">| typeof TEXT_PLAIN_CONTENT_TYPE_HEADER // For simplified errors</span><span class="s3">\n\n</span><span class="s1">export type AppPageRenderResultMetadata = {</span><span class="s3">\n  </span><span class="s1">flightData?: Buffer</span><span class="s3">\n  </span><span class="s1">cacheControl?: CacheControl</span><span class="s3">\n  </span><span class="s1">staticBailoutInfo?: {</span><span class="s3">\n    </span><span class="s1">stack?: string</span><span class="s3">\n    </span><span class="s1">description?: string</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The postponed state if the render had postponed and needs to be resumed.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">postponed?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The headers to set on the response that were added by the render.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">headers?: OutgoingHttpHeaders</span><span class="s3">\n  </span><span class="s1">statusCode?: number</span><span class="s3">\n  </span><span class="s1">fetchTags?: string</span><span class="s3">\n  </span><span class="s1">fetchMetrics?: FetchMetrics</span><span class="s3">\n\n  </span><span class="s1">segmentData?: Map&lt;string, Buffer&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* In development, the resume data cache is warmed up before the render. This</span><span class="s3">\n   </span><span class="s1">* is attached to the metadata so that it can be used during the render. When</span><span class="s3">\n   </span><span class="s1">* prerendering, the filled resume data cache is also attached to the metadata</span><span class="s3">\n   </span><span class="s1">* so that it can be used when prerendering matching fallback shells.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">renderResumeDataCache?: RenderResumeDataCache</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type PagesRenderResultMetadata = {</span><span class="s3">\n  </span><span class="s1">pageData?: any</span><span class="s3">\n  </span><span class="s1">cacheControl?: CacheControl</span><span class="s3">\n  </span><span class="s1">assetQueryString?: string</span><span class="s3">\n  </span><span class="s1">isNotFound?: boolean</span><span class="s3">\n  </span><span class="s1">isRedirect?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type StaticRenderResultMetadata = {}</span><span class="s3">\n\n</span><span class="s1">export type RenderResultMetadata = AppPageRenderResultMetadata &amp;</span><span class="s3">\n  </span><span class="s1">PagesRenderResultMetadata &amp;</span><span class="s3">\n  </span><span class="s1">StaticRenderResultMetadata</span><span class="s3">\n\n</span><span class="s1">export type RenderResultResponse =</span><span class="s3">\n  </span><span class="s1">| ReadableStream&lt;Uint8Array&gt;[]</span><span class="s3">\n  </span><span class="s1">| ReadableStream&lt;Uint8Array&gt;</span><span class="s3">\n  </span><span class="s1">| string</span><span class="s3">\n  </span><span class="s1">| Buffer</span><span class="s3">\n  </span><span class="s1">| null</span><span class="s3">\n\n</span><span class="s1">export type RenderResultOptions&lt;</span><span class="s3">\n  </span><span class="s1">Metadata extends RenderResultMetadata = RenderResultMetadata,</span><span class="s3">\n</span><span class="s1">&gt; = {</span><span class="s3">\n  </span><span class="s1">contentType: ContentTypeOption | null</span><span class="s3">\n  </span><span class="s1">waitUntil?: Promise&lt;unknown&gt;</span><span class="s3">\n  </span><span class="s1">metadata: Metadata</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default class RenderResult&lt;</span><span class="s3">\n  </span><span class="s1">Metadata extends RenderResultMetadata = RenderResultMetadata,</span><span class="s3">\n</span><span class="s1">&gt; {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The detected content type for the response. This is used to set the</span><span class="s3">\n   </span><span class="s1">* `Content-Type` header.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public readonly contentType: ContentTypeOption | null</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The metadata for the response. This is used to set the revalidation times</span><span class="s3">\n   </span><span class="s1">* and other metadata.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public readonly metadata: Readonly&lt;Metadata&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The response itself. This can be a string, a stream, or null. If it's a</span><span class="s3">\n   </span><span class="s1">* string, then it's a static response. If it's a stream, then it's a</span><span class="s3">\n   </span><span class="s1">* dynamic response. If it's null, then the response was not found or was</span><span class="s3">\n   </span><span class="s1">* already sent.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private response: RenderResultResponse</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A render result that represents an empty response. This is used to</span><span class="s3">\n   </span><span class="s1">* represent a response that was not found or was already sent.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public static readonly EMPTY = new RenderResult&lt;StaticRenderResultMetadata&gt;(</span><span class="s3">\n    </span><span class="s1">null,</span><span class="s3">\n    </span><span class="s1">{ metadata: {}, contentType: null }</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Creates a new RenderResult instance from a static response.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param value the static response value</span><span class="s3">\n   </span><span class="s1">* @param contentType the content type of the response</span><span class="s3">\n   </span><span class="s1">* @returns a new RenderResult instance</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public static fromStatic(</span><span class="s3">\n    </span><span class="s1">value: string | Buffer,</span><span class="s3">\n    </span><span class="s1">contentType: ContentTypeOption</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return new RenderResult&lt;StaticRenderResultMetadata&gt;(value, {</span><span class="s3">\n      </span><span class="s1">metadata: {},</span><span class="s3">\n      </span><span class="s1">contentType,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private readonly waitUntil?: Promise&lt;unknown&gt;</span><span class="s3">\n\n  </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">response: RenderResultResponse,</span><span class="s3">\n    </span><span class="s1">{ contentType, waitUntil, metadata }: RenderResultOptions&lt;Metadata&gt;</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">this.response = response</span><span class="s3">\n    </span><span class="s1">this.contentType = contentType</span><span class="s3">\n    </span><span class="s1">this.metadata = metadata</span><span class="s3">\n    </span><span class="s1">this.waitUntil = waitUntil</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public assignMetadata(metadata: Metadata) {</span><span class="s3">\n    </span><span class="s1">Object.assign(this.metadata, metadata)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns true if the response is null. It can be null if the response was</span><span class="s3">\n   </span><span class="s1">* not found or was already sent.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public get isNull(): boolean {</span><span class="s3">\n    </span><span class="s1">return this.response === null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns false if the response is a string. It can be a string if the page</span><span class="s3">\n   </span><span class="s1">* was prerendered. If it's not, then it was generated dynamically.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public get isDynamic(): boolean {</span><span class="s3">\n    </span><span class="s1">return typeof this.response !== 'string'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns the response if it is a string. If the page was dynamic, this will</span><span class="s3">\n   </span><span class="s1">* return a promise if the `stream` option is true, or it will throw an error.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param stream Whether or not to return a promise if the response is dynamic</span><span class="s3">\n   </span><span class="s1">* @returns The response as a string</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public toUnchunkedString(stream?: false): string</span><span class="s3">\n  </span><span class="s1">public toUnchunkedString(stream: true): Promise&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">public toUnchunkedString(stream = false): Promise&lt;string&gt; | string {</span><span class="s3">\n    </span><span class="s1">if (this.response === null) {</span><span class="s3">\n      </span><span class="s1">// If the response is null, return an empty string. This behavior is</span><span class="s3">\n      </span><span class="s1">// intentional as we're now providing the `RenderResult.EMPTY` value.</span><span class="s3">\n      </span><span class="s1">return ''</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (typeof this.response !== 'string') {</span><span class="s3">\n      </span><span class="s1">if (!stream) {</span><span class="s3">\n        </span><span class="s1">throw new InvariantError(</span><span class="s3">\n          </span><span class="s1">'dynamic responses cannot be unchunked. This is a bug in Next.js'</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return streamToString(this.readable)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return this.response</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns a readable stream of the response.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private get readable(): ReadableStream&lt;Uint8Array&gt; {</span><span class="s3">\n    </span><span class="s1">if (this.response === null) {</span><span class="s3">\n      </span><span class="s1">// If the response is null, return an empty stream. This behavior is</span><span class="s3">\n      </span><span class="s1">// intentional as we're now providing the `RenderResult.EMPTY` value.</span><span class="s3">\n      </span><span class="s1">return new ReadableStream&lt;Uint8Array&gt;({</span><span class="s3">\n        </span><span class="s1">start(controller) {</span><span class="s3">\n          </span><span class="s1">controller.close()</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (typeof this.response === 'string') {</span><span class="s3">\n      </span><span class="s1">return streamFromString(this.response)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (Buffer.isBuffer(this.response)) {</span><span class="s3">\n      </span><span class="s1">return streamFromBuffer(this.response)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If the response is an array of streams, then chain them together.</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(this.response)) {</span><span class="s3">\n      </span><span class="s1">return chainStreams(...this.response)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return this.response</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Coerces the response to an array of streams. This will convert the response</span><span class="s3">\n   </span><span class="s1">* to an array of streams if it is not already one.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @returns An array of streams</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private coerce(): ReadableStream&lt;Uint8Array&gt;[] {</span><span class="s3">\n    </span><span class="s1">if (this.response === null) {</span><span class="s3">\n      </span><span class="s1">// If the response is null, return an empty stream. This behavior is</span><span class="s3">\n      </span><span class="s1">// intentional as we're now providing the `RenderResult.EMPTY` value.</span><span class="s3">\n      </span><span class="s1">return []</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (typeof this.response === 'string') {</span><span class="s3">\n      </span><span class="s1">return [streamFromString(this.response)]</span><span class="s3">\n    </span><span class="s1">} else if (Array.isArray(this.response)) {</span><span class="s3">\n      </span><span class="s1">return this.response</span><span class="s3">\n    </span><span class="s1">} else if (Buffer.isBuffer(this.response)) {</span><span class="s3">\n      </span><span class="s1">return [streamFromBuffer(this.response)]</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return [this.response]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Unshifts a new stream to the response. This will convert the response to an</span><span class="s3">\n   </span><span class="s1">* array of streams if it is not already one and will add the new stream to</span><span class="s3">\n   </span><span class="s1">* the start of the array. When this response is piped, all of the streams</span><span class="s3">\n   </span><span class="s1">* will be piped one after the other.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param readable The new stream to unshift</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public unshift(readable: ReadableStream&lt;Uint8Array&gt;): void {</span><span class="s3">\n    </span><span class="s1">// Coerce the response to an array of streams.</span><span class="s3">\n    </span><span class="s1">this.response = this.coerce()</span><span class="s3">\n\n    </span><span class="s1">// Add the new stream to the start of the array.</span><span class="s3">\n    </span><span class="s1">this.response.unshift(readable)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Chains a new stream to the response. This will convert the response to an</span><span class="s3">\n   </span><span class="s1">* array of streams if it is not already one and will add the new stream to</span><span class="s3">\n   </span><span class="s1">* the end. When this response is piped, all of the streams will be piped</span><span class="s3">\n   </span><span class="s1">* one after the other.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param readable The new stream to chain</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public push(readable: ReadableStream&lt;Uint8Array&gt;): void {</span><span class="s3">\n    </span><span class="s1">// Coerce the response to an array of streams.</span><span class="s3">\n    </span><span class="s1">this.response = this.coerce()</span><span class="s3">\n\n    </span><span class="s1">// Add the new stream to the end of the array.</span><span class="s3">\n    </span><span class="s1">this.response.push(readable)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Pipes the response to a writable stream. This will close/cancel the</span><span class="s3">\n   </span><span class="s1">* writable stream if an error is encountered. If this doesn't throw, then</span><span class="s3">\n   </span><span class="s1">* the writable stream will be closed or aborted.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param writable Writable stream to pipe the response to</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public async pipeTo(writable: WritableStream&lt;Uint8Array&gt;): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">await this.readable.pipeTo(writable, {</span><span class="s3">\n        </span><span class="s1">// We want to close the writable stream ourselves so that we can wait</span><span class="s3">\n        </span><span class="s1">// for the waitUntil promise to resolve before closing it. If an error</span><span class="s3">\n        </span><span class="s1">// is encountered, we'll abort the writable stream if we swallowed the</span><span class="s3">\n        </span><span class="s1">// error.</span><span class="s3">\n        </span><span class="s1">preventClose: true,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n\n      </span><span class="s1">// If there is a waitUntil promise, wait for it to resolve before</span><span class="s3">\n      </span><span class="s1">// closing the writable stream.</span><span class="s3">\n      </span><span class="s1">if (this.waitUntil) await this.waitUntil</span><span class="s3">\n\n      </span><span class="s1">// Close the writable stream.</span><span class="s3">\n      </span><span class="s1">await writable.close()</span><span class="s3">\n    </span><span class="s1">} catch (err) {</span><span class="s3">\n      </span><span class="s1">// If this is an abort error, we should abort the writable stream (as we</span><span class="s3">\n      </span><span class="s1">// took ownership of it when we started piping). We don't need to re-throw</span><span class="s3">\n      </span><span class="s1">// because we handled the error.</span><span class="s3">\n      </span><span class="s1">if (isAbortError(err)) {</span><span class="s3">\n        </span><span class="s1">// Abort the writable stream if an error is encountered.</span><span class="s3">\n        </span><span class="s1">await writable.abort(err)</span><span class="s3">\n\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// We're not aborting the writer here as when this method throws it's not</span><span class="s3">\n      </span><span class="s1">// clear as to how so the caller should assume it's their responsibility</span><span class="s3">\n      </span><span class="s1">// to clean up the writer.</span><span class="s3">\n      </span><span class="s1">throw err</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Pipes the response to a node response. This will close/cancel the node</span><span class="s3">\n   </span><span class="s1">* response if an error is encountered.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param res</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public async pipeToNodeResponse(res: ServerResponse) {</span><span class="s3">\n    </span><span class="s1">await pipeToNodeResponse(this.readable, res, this.waitUntil)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export const enum RouteKind {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `PAGES` represents all the React pages that are under `pages/`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">PAGES = 'PAGES',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `PAGES_API` represents all the API routes under `pages/api/`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">PAGES_API = 'PAGES_API',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `APP_PAGE` represents all the React pages that are under `app/` with the</span><span class="s3">\n   </span><span class="s1">* filename of `page.{j,t}s{,x}`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">APP_PAGE = 'APP_PAGE',</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `APP_ROUTE` represents all the API routes and metadata routes that are under `app/` with the</span><span class="s3">\n   </span><span class="s1">* filename of `route.{j,t}s{,x}`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">APP_ROUTE = 'APP_ROUTE',</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* `IMAGE` represents all the images that are generated by `next/image`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">IMAGE = 'IMAGE',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">CachedRouteKind,</span><span class="s3">\n  </span><span class="s1">IncrementalCacheKind,</span><span class="s3">\n  </span><span class="s1">type CachedAppPageValue,</span><span class="s3">\n  </span><span class="s1">type CachedPageValue,</span><span class="s3">\n  </span><span class="s1">type IncrementalResponseCacheEntry,</span><span class="s3">\n  </span><span class="s1">type ResponseCacheEntry,</span><span class="s3">\n</span><span class="s1">} from './types'</span><span class="s3">\n\n</span><span class="s1">import RenderResult from '../render-result'</span><span class="s3">\n</span><span class="s1">import { RouteKind } from '../route-kind'</span><span class="s3">\n</span><span class="s1">import { HTML_CONTENT_TYPE_HEADER } from '../../lib/constants'</span><span class="s3">\n\n</span><span class="s1">export async function fromResponseCacheEntry(</span><span class="s3">\n  </span><span class="s1">cacheEntry: ResponseCacheEntry</span><span class="s3">\n</span><span class="s1">): Promise&lt;IncrementalResponseCacheEntry&gt; {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">...cacheEntry,</span><span class="s3">\n    </span><span class="s1">value:</span><span class="s3">\n      </span><span class="s1">cacheEntry.value?.kind === CachedRouteKind.PAGES</span><span class="s3">\n        </span><span class="s1">? {</span><span class="s3">\n            </span><span class="s1">kind: CachedRouteKind.PAGES,</span><span class="s3">\n            </span><span class="s1">html: await cacheEntry.value.html.toUnchunkedString(true),</span><span class="s3">\n            </span><span class="s1">pageData: cacheEntry.value.pageData,</span><span class="s3">\n            </span><span class="s1">headers: cacheEntry.value.headers,</span><span class="s3">\n            </span><span class="s1">status: cacheEntry.value.status,</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">: cacheEntry.value?.kind === CachedRouteKind.APP_PAGE</span><span class="s3">\n          </span><span class="s1">? {</span><span class="s3">\n              </span><span class="s1">kind: CachedRouteKind.APP_PAGE,</span><span class="s3">\n              </span><span class="s1">html: await cacheEntry.value.html.toUnchunkedString(true),</span><span class="s3">\n              </span><span class="s1">postponed: cacheEntry.value.postponed,</span><span class="s3">\n              </span><span class="s1">rscData: cacheEntry.value.rscData,</span><span class="s3">\n              </span><span class="s1">headers: cacheEntry.value.headers,</span><span class="s3">\n              </span><span class="s1">status: cacheEntry.value.status,</span><span class="s3">\n              </span><span class="s1">segmentData: cacheEntry.value.segmentData,</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">: cacheEntry.value,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function toResponseCacheEntry(</span><span class="s3">\n  </span><span class="s1">response: IncrementalResponseCacheEntry | null</span><span class="s3">\n</span><span class="s1">): Promise&lt;ResponseCacheEntry | null&gt; {</span><span class="s3">\n  </span><span class="s1">if (!response) return null</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">isMiss: response.isMiss,</span><span class="s3">\n    </span><span class="s1">isStale: response.isStale,</span><span class="s3">\n    </span><span class="s1">cacheControl: response.cacheControl,</span><span class="s3">\n    </span><span class="s1">value:</span><span class="s3">\n      </span><span class="s1">response.value?.kind === CachedRouteKind.PAGES</span><span class="s3">\n        </span><span class="s1">? ({</span><span class="s3">\n            </span><span class="s1">kind: CachedRouteKind.PAGES,</span><span class="s3">\n            </span><span class="s1">html: RenderResult.fromStatic(</span><span class="s3">\n              </span><span class="s1">response.value.html,</span><span class="s3">\n              </span><span class="s1">HTML_CONTENT_TYPE_HEADER</span><span class="s3">\n            </span><span class="s1">),</span><span class="s3">\n            </span><span class="s1">pageData: response.value.pageData,</span><span class="s3">\n            </span><span class="s1">headers: response.value.headers,</span><span class="s3">\n            </span><span class="s1">status: response.value.status,</span><span class="s3">\n          </span><span class="s1">} satisfies CachedPageValue)</span><span class="s3">\n        </span><span class="s1">: response.value?.kind === CachedRouteKind.APP_PAGE</span><span class="s3">\n          </span><span class="s1">? ({</span><span class="s3">\n              </span><span class="s1">kind: CachedRouteKind.APP_PAGE,</span><span class="s3">\n              </span><span class="s1">html: RenderResult.fromStatic(</span><span class="s3">\n                </span><span class="s1">response.value.html,</span><span class="s3">\n                </span><span class="s1">HTML_CONTENT_TYPE_HEADER</span><span class="s3">\n              </span><span class="s1">),</span><span class="s3">\n              </span><span class="s1">rscData: response.value.rscData,</span><span class="s3">\n              </span><span class="s1">headers: response.value.headers,</span><span class="s3">\n              </span><span class="s1">status: response.value.status,</span><span class="s3">\n              </span><span class="s1">postponed: response.value.postponed,</span><span class="s3">\n              </span><span class="s1">segmentData: response.value.segmentData,</span><span class="s3">\n            </span><span class="s1">} satisfies CachedAppPageValue)</span><span class="s3">\n          </span><span class="s1">: response.value,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function routeKindToIncrementalCacheKind(</span><span class="s3">\n  </span><span class="s1">routeKind: RouteKind</span><span class="s3">\n</span><span class="s1">): Exclude&lt;IncrementalCacheKind, IncrementalCacheKind.FETCH&gt; {</span><span class="s3">\n  </span><span class="s1">switch (routeKind) {</span><span class="s3">\n    </span><span class="s1">case RouteKind.PAGES:</span><span class="s3">\n      </span><span class="s1">return IncrementalCacheKind.PAGES</span><span class="s3">\n    </span><span class="s1">case RouteKind.APP_PAGE:</span><span class="s3">\n      </span><span class="s1">return IncrementalCacheKind.APP_PAGE</span><span class="s3">\n    </span><span class="s1">case RouteKind.IMAGE:</span><span class="s3">\n      </span><span class="s1">return IncrementalCacheKind.IMAGE</span><span class="s3">\n    </span><span class="s1">case RouteKind.APP_ROUTE:</span><span class="s3">\n      </span><span class="s1">return IncrementalCacheKind.APP_ROUTE</span><span class="s3">\n    </span><span class="s1">case RouteKind.PAGES_API:</span><span class="s3">\n      </span><span class="s1">// Pages Router API routes are not cached in the incremental cache.</span><span class="s3">\n      </span><span class="s1">throw new Error(`Unexpected route kind ${routeKind}`)</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">return routeKind satisfies never</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type {</span><span class="s3">\n  </span><span class="s1">ResponseCacheEntry,</span><span class="s3">\n  </span><span class="s1">ResponseGenerator,</span><span class="s3">\n  </span><span class="s1">ResponseCacheBase,</span><span class="s3">\n  </span><span class="s1">IncrementalResponseCacheEntry,</span><span class="s3">\n  </span><span class="s1">IncrementalResponseCache,</span><span class="s3">\n</span><span class="s1">} from './types'</span><span class="s3">\n\n</span><span class="s1">import { Batcher } from '../../lib/batcher'</span><span class="s3">\n</span><span class="s1">import { scheduleOnNextTick } from '../../lib/scheduler'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">fromResponseCacheEntry,</span><span class="s3">\n  </span><span class="s1">routeKindToIncrementalCacheKind,</span><span class="s3">\n  </span><span class="s1">toResponseCacheEntry,</span><span class="s3">\n</span><span class="s1">} from './utils'</span><span class="s3">\n</span><span class="s1">import type { RouteKind } from '../route-kind'</span><span class="s3">\n\n</span><span class="s1">export * from './types'</span><span class="s3">\n\n</span><span class="s1">export default class ResponseCache implements ResponseCacheBase {</span><span class="s3">\n  </span><span class="s1">private readonly batcher = Batcher.create&lt;</span><span class="s3">\n    </span><span class="s1">{ key: string; isOnDemandRevalidate: boolean },</span><span class="s3">\n    </span><span class="s1">IncrementalResponseCacheEntry | null,</span><span class="s3">\n    </span><span class="s1">string</span><span class="s3">\n  </span><span class="s1">&gt;({</span><span class="s3">\n    </span><span class="s1">// Ensure on-demand revalidate doesn't block normal requests, it should be</span><span class="s3">\n    </span><span class="s1">// safe to run an on-demand revalidate for the same key as a normal request.</span><span class="s3">\n    </span><span class="s1">cacheKeyFn: ({ key, isOnDemandRevalidate }) =&gt;</span><span class="s3">\n      </span><span class="s1">`${key}-${isOnDemandRevalidate ? '1' : '0'}`,</span><span class="s3">\n    </span><span class="s1">// We wait to do any async work until after we've added our promise to</span><span class="s3">\n    </span><span class="s1">// `pendingResponses` to ensure that any any other calls will reuse the</span><span class="s3">\n    </span><span class="s1">// same promise until we've fully finished our work.</span><span class="s3">\n    </span><span class="s1">schedulerFn: scheduleOnNextTick,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">private previousCacheItem?: {</span><span class="s3">\n    </span><span class="s1">key: string</span><span class="s3">\n    </span><span class="s1">entry: IncrementalResponseCacheEntry | null</span><span class="s3">\n    </span><span class="s1">expiresAt: number</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// we don't use minimal_mode name here as this.minimal_mode is</span><span class="s3">\n  </span><span class="s1">// statically replace for server runtimes but we need it to</span><span class="s3">\n  </span><span class="s1">// be dynamic here</span><span class="s3">\n  </span><span class="s1">private minimal_mode?: boolean</span><span class="s3">\n\n  </span><span class="s1">constructor(minimal_mode: boolean) {</span><span class="s3">\n    </span><span class="s1">this.minimal_mode = minimal_mode</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async get(</span><span class="s3">\n    </span><span class="s1">key: string | null,</span><span class="s3">\n    </span><span class="s1">responseGenerator: ResponseGenerator,</span><span class="s3">\n    </span><span class="s1">context: {</span><span class="s3">\n      </span><span class="s1">routeKind: RouteKind</span><span class="s3">\n      </span><span class="s1">isOnDemandRevalidate?: boolean</span><span class="s3">\n      </span><span class="s1">isPrefetch?: boolean</span><span class="s3">\n      </span><span class="s1">incrementalCache: IncrementalResponseCache</span><span class="s3">\n      </span><span class="s1">isRoutePPREnabled?: boolean</span><span class="s3">\n      </span><span class="s1">isFallback?: boolean</span><span class="s3">\n      </span><span class="s1">waitUntil?: (prom: Promise&lt;any&gt;) =&gt; void</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">): Promise&lt;ResponseCacheEntry | null&gt; {</span><span class="s3">\n    </span><span class="s1">// If there is no key for the cache, we can't possibly look this up in the</span><span class="s3">\n    </span><span class="s1">// cache so just return the result of the response generator.</span><span class="s3">\n    </span><span class="s1">if (!key) {</span><span class="s3">\n      </span><span class="s1">return responseGenerator({ hasResolved: false, previousCacheEntry: null })</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const {</span><span class="s3">\n      </span><span class="s1">incrementalCache,</span><span class="s3">\n      </span><span class="s1">isOnDemandRevalidate = false,</span><span class="s3">\n      </span><span class="s1">isFallback = false,</span><span class="s3">\n      </span><span class="s1">isRoutePPREnabled = false,</span><span class="s3">\n      </span><span class="s1">waitUntil,</span><span class="s3">\n    </span><span class="s1">} = context</span><span class="s3">\n\n    </span><span class="s1">const response = await this.batcher.batch(</span><span class="s3">\n      </span><span class="s1">{ key, isOnDemandRevalidate },</span><span class="s3">\n      </span><span class="s1">(cacheKey, resolve) =&gt; {</span><span class="s3">\n        </span><span class="s1">const prom = (async () =&gt; {</span><span class="s3">\n          </span><span class="s1">// We keep the previous cache entry around to leverage when the</span><span class="s3">\n          </span><span class="s1">// incremental cache is disabled in minimal mode.</span><span class="s3">\n          </span><span class="s1">if (</span><span class="s3">\n            </span><span class="s1">this.minimal_mode &amp;&amp;</span><span class="s3">\n            </span><span class="s1">this.previousCacheItem?.key === cacheKey &amp;&amp;</span><span class="s3">\n            </span><span class="s1">this.previousCacheItem.expiresAt &gt; Date.now()</span><span class="s3">\n          </span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">return this.previousCacheItem.entry</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">// Coerce the kindHint into a given kind for the incremental cache.</span><span class="s3">\n          </span><span class="s1">const kind = routeKindToIncrementalCacheKind(context.routeKind)</span><span class="s3">\n\n          </span><span class="s1">let resolved = false</span><span class="s3">\n          </span><span class="s1">let cachedResponse: IncrementalResponseCacheEntry | null = null</span><span class="s3">\n          </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">cachedResponse = !this.minimal_mode</span><span class="s3">\n              </span><span class="s1">? await incrementalCache.get(key, {</span><span class="s3">\n                  </span><span class="s1">kind,</span><span class="s3">\n                  </span><span class="s1">isRoutePPREnabled: context.isRoutePPREnabled,</span><span class="s3">\n                  </span><span class="s1">isFallback,</span><span class="s3">\n                </span><span class="s1">})</span><span class="s3">\n              </span><span class="s1">: null</span><span class="s3">\n\n            </span><span class="s1">if (cachedResponse &amp;&amp; !isOnDemandRevalidate) {</span><span class="s3">\n              </span><span class="s1">resolve(cachedResponse)</span><span class="s3">\n              </span><span class="s1">resolved = true</span><span class="s3">\n\n              </span><span class="s1">if (!cachedResponse.isStale || context.isPrefetch) {</span><span class="s3">\n                </span><span class="s1">// The cached value is still valid, so we don't need</span><span class="s3">\n                </span><span class="s1">// to update it yet.</span><span class="s3">\n                </span><span class="s1">return null</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">const cacheEntry = await responseGenerator({</span><span class="s3">\n              </span><span class="s1">hasResolved: resolved,</span><span class="s3">\n              </span><span class="s1">previousCacheEntry: cachedResponse,</span><span class="s3">\n              </span><span class="s1">isRevalidating: true,</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n\n            </span><span class="s1">// If the cache entry couldn't be generated, we don't want to cache</span><span class="s3">\n            </span><span class="s1">// the result.</span><span class="s3">\n            </span><span class="s1">if (!cacheEntry) {</span><span class="s3">\n              </span><span class="s1">// Unset the previous cache item if it was set.</span><span class="s3">\n              </span><span class="s1">if (this.minimal_mode) this.previousCacheItem = undefined</span><span class="s3">\n              </span><span class="s1">return null</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">const resolveValue = await fromResponseCacheEntry({</span><span class="s3">\n              </span><span class="s1">...cacheEntry,</span><span class="s3">\n              </span><span class="s1">isMiss: !cachedResponse,</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n            </span><span class="s1">if (!resolveValue) {</span><span class="s3">\n              </span><span class="s1">// Unset the previous cache item if it was set.</span><span class="s3">\n              </span><span class="s1">if (this.minimal_mode) this.previousCacheItem = undefined</span><span class="s3">\n              </span><span class="s1">return null</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// For on-demand revalidate wait to resolve until cache is set.</span><span class="s3">\n            </span><span class="s1">// Otherwise resolve now.</span><span class="s3">\n            </span><span class="s1">if (!isOnDemandRevalidate &amp;&amp; !resolved) {</span><span class="s3">\n              </span><span class="s1">resolve(resolveValue)</span><span class="s3">\n              </span><span class="s1">resolved = true</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// We want to persist the result only if it has a cache control value</span><span class="s3">\n            </span><span class="s1">// defined.</span><span class="s3">\n            </span><span class="s1">if (resolveValue.cacheControl) {</span><span class="s3">\n              </span><span class="s1">if (this.minimal_mode) {</span><span class="s3">\n                </span><span class="s1">this.previousCacheItem = {</span><span class="s3">\n                  </span><span class="s1">key: cacheKey,</span><span class="s3">\n                  </span><span class="s1">entry: resolveValue,</span><span class="s3">\n                  </span><span class="s1">expiresAt: Date.now() + 1000,</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">} else {</span><span class="s3">\n                </span><span class="s1">await incrementalCache.set(key, resolveValue.value, {</span><span class="s3">\n                  </span><span class="s1">cacheControl: resolveValue.cacheControl,</span><span class="s3">\n                  </span><span class="s1">isRoutePPREnabled,</span><span class="s3">\n                  </span><span class="s1">isFallback,</span><span class="s3">\n                </span><span class="s1">})</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">return resolveValue</span><span class="s3">\n          </span><span class="s1">} catch (err) {</span><span class="s3">\n            </span><span class="s1">// When a path is erroring we automatically re-set the existing cache</span><span class="s3">\n            </span><span class="s1">// with new revalidate and expire times to prevent non-stop retrying.</span><span class="s3">\n            </span><span class="s1">if (cachedResponse?.cacheControl) {</span><span class="s3">\n              </span><span class="s1">const newRevalidate = Math.min(</span><span class="s3">\n                </span><span class="s1">Math.max(cachedResponse.cacheControl.revalidate || 3, 3),</span><span class="s3">\n                </span><span class="s1">30</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n\n              </span><span class="s1">const newExpire =</span><span class="s3">\n                </span><span class="s1">cachedResponse.cacheControl.expire === undefined</span><span class="s3">\n                  </span><span class="s1">? undefined</span><span class="s3">\n                  </span><span class="s1">: Math.max(</span><span class="s3">\n                      </span><span class="s1">newRevalidate + 3,</span><span class="s3">\n                      </span><span class="s1">cachedResponse.cacheControl.expire</span><span class="s3">\n                    </span><span class="s1">)</span><span class="s3">\n\n              </span><span class="s1">await incrementalCache.set(key, cachedResponse.value, {</span><span class="s3">\n                </span><span class="s1">cacheControl: { revalidate: newRevalidate, expire: newExpire },</span><span class="s3">\n                </span><span class="s1">isRoutePPREnabled,</span><span class="s3">\n                </span><span class="s1">isFallback,</span><span class="s3">\n              </span><span class="s1">})</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// While revalidating in the background we can't reject as we already</span><span class="s3">\n            </span><span class="s1">// resolved the cache entry so log the error here.</span><span class="s3">\n            </span><span class="s1">if (resolved) {</span><span class="s3">\n              </span><span class="s1">console.error(err)</span><span class="s3">\n              </span><span class="s1">return null</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// We haven't resolved yet, so let's throw to indicate an error.</span><span class="s3">\n            </span><span class="s1">throw err</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">})()</span><span class="s3">\n\n        </span><span class="s1">// we need to ensure background revalidates are</span><span class="s3">\n        </span><span class="s1">// passed to waitUntil</span><span class="s3">\n        </span><span class="s1">if (waitUntil) {</span><span class="s3">\n          </span><span class="s1">waitUntil(prom)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return prom</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">return toResponseCacheEntry(response)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import path from '../shared/lib/isomorphic/path'</span><span class="s3">\n</span><span class="s1">import type { CacheFs } from '../shared/lib/utils'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A task to be written.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">type Task = [</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The directory to create.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">directory: string,</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The promise to create the directory.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">mkdir: Promise&lt;unknown&gt;,</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The promises to write the files that are dependent on the directory being</span><span class="s3">\n   </span><span class="s1">* created.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">writeFile: Promise&lt;unknown&gt;[],</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* MultiFileWriter is a utility for writing multiple files in parallel that</span><span class="s3">\n </span><span class="s1">* guarantees that all files will be written after their containing directory</span><span class="s3">\n </span><span class="s1">* is created, and that the directory will only be created once.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class MultiFileWriter {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The tasks to be written.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private readonly tasks: Task[] = []</span><span class="s3">\n\n  </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The file system methods to use.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">private readonly fs: Pick&lt;CacheFs, 'mkdir' | 'writeFile'&gt;</span><span class="s3">\n  </span><span class="s1">) {}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Finds or creates a task for a directory.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param directory - The directory to find or create a task for.</span><span class="s3">\n   </span><span class="s1">* @returns The task for the directory.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private findOrCreateTask(directory: string): Task {</span><span class="s3">\n    </span><span class="s1">// See if this directory already has a task to create it.</span><span class="s3">\n    </span><span class="s1">for (const task of this.tasks) {</span><span class="s3">\n      </span><span class="s1">if (task[0] === directory) {</span><span class="s3">\n        </span><span class="s1">return task</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const promise = this.fs.mkdir(directory)</span><span class="s3">\n\n    </span><span class="s1">// Attach a catch handler so that it doesn't throw an unhandled promise</span><span class="s3">\n    </span><span class="s1">// rejection warning.</span><span class="s3">\n    </span><span class="s1">promise.catch(() =&gt; {})</span><span class="s3">\n\n    </span><span class="s1">// Otherwise, create a new task for this directory.</span><span class="s3">\n    </span><span class="s1">const task: Task = [directory, promise, []]</span><span class="s3">\n    </span><span class="s1">this.tasks.push(task)</span><span class="s3">\n\n    </span><span class="s1">return task</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Appends a file to the writer to be written after its containing directory</span><span class="s3">\n   </span><span class="s1">* is created. The file writer should be awaited after all the files have been</span><span class="s3">\n   </span><span class="s1">* appended. Any async operation that occurs between appending and awaiting</span><span class="s3">\n   </span><span class="s1">* may cause an unhandled promise rejection warning and potentially crash the</span><span class="s3">\n   </span><span class="s1">* process.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param filePath - The path to the file to write.</span><span class="s3">\n   </span><span class="s1">* @param data - The data to write to the file.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public append(filePath: string, data: Buffer | string): void {</span><span class="s3">\n    </span><span class="s1">// Find or create a task for the directory that contains the file.</span><span class="s3">\n    </span><span class="s1">const task = this.findOrCreateTask(path.dirname(filePath))</span><span class="s3">\n\n    </span><span class="s1">const promise = task[1].then(() =&gt; this.fs.writeFile(filePath, data))</span><span class="s3">\n\n    </span><span class="s1">// Attach a catch handler so that it doesn't throw an unhandled promise</span><span class="s3">\n    </span><span class="s1">// rejection warning.</span><span class="s3">\n    </span><span class="s1">promise.catch(() =&gt; {})</span><span class="s3">\n\n    </span><span class="s1">// Add the file write to the task AFTER the directory promise has resolved.</span><span class="s3">\n    </span><span class="s1">task[2].push(promise)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns a promise that resolves when all the files have been written.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public wait(): Promise&lt;unknown&gt; {</span><span class="s3">\n    </span><span class="s1">return Promise.all(this.tasks.flatMap((task) =&gt; task[2]))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { RouteMetadata } from '../../../export/routes/types'</span><span class="s3">\n</span><span class="s1">import type { CacheHandler, CacheHandlerContext, CacheHandlerValue } from '.'</span><span class="s3">\n</span><span class="s1">import type { CacheFs } from '../../../shared/lib/utils'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">CachedRouteKind,</span><span class="s3">\n  </span><span class="s1">IncrementalCacheKind,</span><span class="s3">\n  </span><span class="s1">type CachedFetchValue,</span><span class="s3">\n  </span><span class="s1">type IncrementalCacheValue,</span><span class="s3">\n  </span><span class="s1">type SetIncrementalFetchCacheContext,</span><span class="s3">\n  </span><span class="s1">type SetIncrementalResponseCacheContext,</span><span class="s3">\n</span><span class="s1">} from '../../response-cache'</span><span class="s3">\n\n</span><span class="s1">import type { LRUCache } from '../lru-cache'</span><span class="s3">\n</span><span class="s1">import path from '../../../shared/lib/isomorphic/path'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">NEXT_CACHE_TAGS_HEADER,</span><span class="s3">\n  </span><span class="s1">NEXT_DATA_SUFFIX,</span><span class="s3">\n  </span><span class="s1">NEXT_META_SUFFIX,</span><span class="s3">\n  </span><span class="s1">RSC_PREFETCH_SUFFIX,</span><span class="s3">\n  </span><span class="s1">RSC_SEGMENT_SUFFIX,</span><span class="s3">\n  </span><span class="s1">RSC_SEGMENTS_DIR_SUFFIX,</span><span class="s3">\n  </span><span class="s1">RSC_SUFFIX,</span><span class="s3">\n</span><span class="s1">} from '../../../lib/constants'</span><span class="s3">\n</span><span class="s1">import { isStale, tagsManifest } from './tags-manifest.external'</span><span class="s3">\n</span><span class="s1">import { MultiFileWriter } from '../../../lib/multi-file-writer'</span><span class="s3">\n</span><span class="s1">import { getMemoryCache } from './memory-cache.external'</span><span class="s3">\n\n</span><span class="s1">type FileSystemCacheContext = Omit&lt;</span><span class="s3">\n  </span><span class="s1">CacheHandlerContext,</span><span class="s3">\n  </span><span class="s1">'fs' | 'serverDistDir'</span><span class="s3">\n</span><span class="s1">&gt; &amp; {</span><span class="s3">\n  </span><span class="s1">fs: CacheFs</span><span class="s3">\n  </span><span class="s1">serverDistDir: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default class FileSystemCache implements CacheHandler {</span><span class="s3">\n  </span><span class="s1">private fs: FileSystemCacheContext['fs']</span><span class="s3">\n  </span><span class="s1">private flushToDisk?: FileSystemCacheContext['flushToDisk']</span><span class="s3">\n  </span><span class="s1">private serverDistDir: FileSystemCacheContext['serverDistDir']</span><span class="s3">\n  </span><span class="s1">private revalidatedTags: string[]</span><span class="s3">\n  </span><span class="s1">private static debug: boolean = !!process.env.NEXT_PRIVATE_DEBUG_CACHE</span><span class="s3">\n  </span><span class="s1">private static memoryCache: LRUCache&lt;CacheHandlerValue&gt; | undefined</span><span class="s3">\n\n  </span><span class="s1">constructor(ctx: FileSystemCacheContext) {</span><span class="s3">\n    </span><span class="s1">this.fs = ctx.fs</span><span class="s3">\n    </span><span class="s1">this.flushToDisk = ctx.flushToDisk</span><span class="s3">\n    </span><span class="s1">this.serverDistDir = ctx.serverDistDir</span><span class="s3">\n    </span><span class="s1">this.revalidatedTags = ctx.revalidatedTags</span><span class="s3">\n\n    </span><span class="s1">if (ctx.maxMemoryCacheSize) {</span><span class="s3">\n      </span><span class="s1">if (!FileSystemCache.memoryCache) {</span><span class="s3">\n        </span><span class="s1">if (FileSystemCache.debug) {</span><span class="s3">\n          </span><span class="s1">console.log('using memory store for fetch cache')</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">FileSystemCache.memoryCache = getMemoryCache(ctx.maxMemoryCacheSize)</span><span class="s3">\n      </span><span class="s1">} else if (FileSystemCache.debug) {</span><span class="s3">\n        </span><span class="s1">console.log('memory store already initialized')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (FileSystemCache.debug) {</span><span class="s3">\n      </span><span class="s1">console.log('not using memory store for fetch cache')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public resetRequestCache(): void {}</span><span class="s3">\n\n  </span><span class="s1">public async revalidateTag(</span><span class="s3">\n    </span><span class="s1">...args: Parameters&lt;CacheHandler['revalidateTag']&gt;</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">let [tags] = args</span><span class="s3">\n    </span><span class="s1">tags = typeof tags === 'string' ? [tags] : tags</span><span class="s3">\n\n    </span><span class="s1">if (FileSystemCache.debug) {</span><span class="s3">\n      </span><span class="s1">console.log('revalidateTag', tags)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (tags.length === 0) {</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const tag of tags) {</span><span class="s3">\n      </span><span class="s1">if (!tagsManifest.has(tag)) {</span><span class="s3">\n        </span><span class="s1">tagsManifest.set(tag, Date.now())</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async get(...args: Parameters&lt;CacheHandler['get']&gt;) {</span><span class="s3">\n    </span><span class="s1">const [key, ctx] = args</span><span class="s3">\n    </span><span class="s1">const { kind } = ctx</span><span class="s3">\n\n    </span><span class="s1">let data = FileSystemCache.memoryCache?.get(key)</span><span class="s3">\n\n    </span><span class="s1">if (FileSystemCache.debug) {</span><span class="s3">\n      </span><span class="s1">if (kind === IncrementalCacheKind.FETCH) {</span><span class="s3">\n        </span><span class="s1">console.log('get', key, ctx.tags, kind, !!data)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">console.log('get', key, kind, !!data)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// let's check the disk for seed data</span><span class="s3">\n    </span><span class="s1">if (!data &amp;&amp; process.env.NEXT_RUNTIME !== 'edge') {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">if (kind === IncrementalCacheKind.APP_ROUTE) {</span><span class="s3">\n          </span><span class="s1">const filePath = this.getFilePath(</span><span class="s3">\n            </span><span class="s1">`${key}.body`,</span><span class="s3">\n            </span><span class="s1">IncrementalCacheKind.APP_ROUTE</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">const fileData = await this.fs.readFile(filePath)</span><span class="s3">\n          </span><span class="s1">const { mtime } = await this.fs.stat(filePath)</span><span class="s3">\n\n          </span><span class="s1">const meta = JSON.parse(</span><span class="s3">\n            </span><span class="s1">await this.fs.readFile(</span><span class="s3">\n              </span><span class="s1">filePath.replace(/</span><span class="s3">\\</span><span class="s1">.body$/, NEXT_META_SUFFIX),</span><span class="s3">\n              </span><span class="s1">'utf8'</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n\n          </span><span class="s1">data = {</span><span class="s3">\n            </span><span class="s1">lastModified: mtime.getTime(),</span><span class="s3">\n            </span><span class="s1">value: {</span><span class="s3">\n              </span><span class="s1">kind: CachedRouteKind.APP_ROUTE,</span><span class="s3">\n              </span><span class="s1">body: fileData,</span><span class="s3">\n              </span><span class="s1">headers: meta.headers,</span><span class="s3">\n              </span><span class="s1">status: meta.status,</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">const filePath = this.getFilePath(</span><span class="s3">\n            </span><span class="s1">kind === IncrementalCacheKind.FETCH ? key : `${key}.html`,</span><span class="s3">\n            </span><span class="s1">kind</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n\n          </span><span class="s1">const fileData = await this.fs.readFile(filePath, 'utf8')</span><span class="s3">\n          </span><span class="s1">const { mtime } = await this.fs.stat(filePath)</span><span class="s3">\n\n          </span><span class="s1">if (kind === IncrementalCacheKind.FETCH) {</span><span class="s3">\n            </span><span class="s1">const { tags, fetchIdx, fetchUrl } = ctx</span><span class="s3">\n\n            </span><span class="s1">if (!this.flushToDisk) return null</span><span class="s3">\n\n            </span><span class="s1">const lastModified = mtime.getTime()</span><span class="s3">\n            </span><span class="s1">const parsedData: CachedFetchValue = JSON.parse(fileData)</span><span class="s3">\n            </span><span class="s1">data = {</span><span class="s3">\n              </span><span class="s1">lastModified,</span><span class="s3">\n              </span><span class="s1">value: parsedData,</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">if (data.value?.kind === CachedRouteKind.FETCH) {</span><span class="s3">\n              </span><span class="s1">const storedTags = data.value?.tags</span><span class="s3">\n\n              </span><span class="s1">// update stored tags if a new one is being added</span><span class="s3">\n              </span><span class="s1">// TODO: remove this when we can send the tags</span><span class="s3">\n              </span><span class="s1">// via header on GET same as SET</span><span class="s3">\n              </span><span class="s1">if (!tags?.every((tag) =&gt; storedTags?.includes(tag))) {</span><span class="s3">\n                </span><span class="s1">if (FileSystemCache.debug) {</span><span class="s3">\n                  </span><span class="s1">console.log('tags vs storedTags mismatch', tags, storedTags)</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">await this.set(key, data.value, {</span><span class="s3">\n                  </span><span class="s1">fetchCache: true,</span><span class="s3">\n                  </span><span class="s1">tags,</span><span class="s3">\n                  </span><span class="s1">fetchIdx,</span><span class="s3">\n                  </span><span class="s1">fetchUrl,</span><span class="s3">\n                </span><span class="s1">})</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else if (kind === IncrementalCacheKind.APP_PAGE) {</span><span class="s3">\n            </span><span class="s1">// We try to load the metadata file, but if it fails, we don't</span><span class="s3">\n            </span><span class="s1">// error. We also don't load it if this is a fallback.</span><span class="s3">\n            </span><span class="s1">let meta: RouteMetadata | undefined</span><span class="s3">\n            </span><span class="s1">try {</span><span class="s3">\n              </span><span class="s1">meta = JSON.parse(</span><span class="s3">\n                </span><span class="s1">await this.fs.readFile(</span><span class="s3">\n                  </span><span class="s1">filePath.replace(/</span><span class="s3">\\</span><span class="s1">.html$/, NEXT_META_SUFFIX),</span><span class="s3">\n                  </span><span class="s1">'utf8'</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">} catch {}</span><span class="s3">\n\n            </span><span class="s1">let maybeSegmentData: Map&lt;string, Buffer&gt; | undefined</span><span class="s3">\n            </span><span class="s1">if (meta?.segmentPaths) {</span><span class="s3">\n              </span><span class="s1">// Collect all the segment data for this page.</span><span class="s3">\n              </span><span class="s1">// TODO: To optimize file system reads, we should consider creating</span><span class="s3">\n              </span><span class="s1">// separate cache entries for each segment, rather than storing them</span><span class="s3">\n              </span><span class="s1">// all on the page's entry. Though the behavior is</span><span class="s3">\n              </span><span class="s1">// identical regardless.</span><span class="s3">\n              </span><span class="s1">const segmentData: Map&lt;string, Buffer&gt; = new Map()</span><span class="s3">\n              </span><span class="s1">maybeSegmentData = segmentData</span><span class="s3">\n              </span><span class="s1">const segmentsDir = key + RSC_SEGMENTS_DIR_SUFFIX</span><span class="s3">\n              </span><span class="s1">await Promise.all(</span><span class="s3">\n                </span><span class="s1">meta.segmentPaths.map(async (segmentPath: string) =&gt; {</span><span class="s3">\n                  </span><span class="s1">const segmentDataFilePath = this.getFilePath(</span><span class="s3">\n                    </span><span class="s1">segmentsDir + segmentPath + RSC_SEGMENT_SUFFIX,</span><span class="s3">\n                    </span><span class="s1">IncrementalCacheKind.APP_PAGE</span><span class="s3">\n                  </span><span class="s1">)</span><span class="s3">\n                  </span><span class="s1">try {</span><span class="s3">\n                    </span><span class="s1">segmentData.set(</span><span class="s3">\n                      </span><span class="s1">segmentPath,</span><span class="s3">\n                      </span><span class="s1">await this.fs.readFile(segmentDataFilePath)</span><span class="s3">\n                    </span><span class="s1">)</span><span class="s3">\n                  </span><span class="s1">} catch {</span><span class="s3">\n                    </span><span class="s1">// This shouldn't happen, but if for some reason we fail to</span><span class="s3">\n                    </span><span class="s1">// load a segment from the filesystem, treat it the same as if</span><span class="s3">\n                    </span><span class="s1">// the segment is dynamic and does not have a prefetch.</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">})</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">let rscData: Buffer | undefined</span><span class="s3">\n            </span><span class="s1">if (!ctx.isFallback) {</span><span class="s3">\n              </span><span class="s1">rscData = await this.fs.readFile(</span><span class="s3">\n                </span><span class="s1">this.getFilePath(</span><span class="s3">\n                  </span><span class="s1">`${key}${ctx.isRoutePPREnabled ? RSC_PREFETCH_SUFFIX : RSC_SUFFIX}`,</span><span class="s3">\n                  </span><span class="s1">IncrementalCacheKind.APP_PAGE</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">data = {</span><span class="s3">\n              </span><span class="s1">lastModified: mtime.getTime(),</span><span class="s3">\n              </span><span class="s1">value: {</span><span class="s3">\n                </span><span class="s1">kind: CachedRouteKind.APP_PAGE,</span><span class="s3">\n                </span><span class="s1">html: fileData,</span><span class="s3">\n                </span><span class="s1">rscData,</span><span class="s3">\n                </span><span class="s1">postponed: meta?.postponed,</span><span class="s3">\n                </span><span class="s1">headers: meta?.headers,</span><span class="s3">\n                </span><span class="s1">status: meta?.status,</span><span class="s3">\n                </span><span class="s1">segmentData: maybeSegmentData,</span><span class="s3">\n              </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else if (kind === IncrementalCacheKind.PAGES) {</span><span class="s3">\n            </span><span class="s1">let meta: RouteMetadata | undefined</span><span class="s3">\n            </span><span class="s1">let pageData: string | object = {}</span><span class="s3">\n\n            </span><span class="s1">if (!ctx.isFallback) {</span><span class="s3">\n              </span><span class="s1">pageData = JSON.parse(</span><span class="s3">\n                </span><span class="s1">await this.fs.readFile(</span><span class="s3">\n                  </span><span class="s1">this.getFilePath(</span><span class="s3">\n                    </span><span class="s1">`${key}${NEXT_DATA_SUFFIX}`,</span><span class="s3">\n                    </span><span class="s1">IncrementalCacheKind.PAGES</span><span class="s3">\n                  </span><span class="s1">),</span><span class="s3">\n                  </span><span class="s1">'utf8'</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">data = {</span><span class="s3">\n              </span><span class="s1">lastModified: mtime.getTime(),</span><span class="s3">\n              </span><span class="s1">value: {</span><span class="s3">\n                </span><span class="s1">kind: CachedRouteKind.PAGES,</span><span class="s3">\n                </span><span class="s1">html: fileData,</span><span class="s3">\n                </span><span class="s1">pageData,</span><span class="s3">\n                </span><span class="s1">headers: meta?.headers,</span><span class="s3">\n                </span><span class="s1">status: meta?.status,</span><span class="s3">\n              </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\n              </span><span class="s1">`Invariant: Unexpected route kind ${kind} in file system cache.`</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (data) {</span><span class="s3">\n          </span><span class="s1">FileSystemCache.memoryCache?.set(key, data)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} catch {</span><span class="s3">\n        </span><span class="s1">return null</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">data?.value?.kind === CachedRouteKind.APP_PAGE ||</span><span class="s3">\n      </span><span class="s1">data?.value?.kind === CachedRouteKind.APP_ROUTE ||</span><span class="s3">\n      </span><span class="s1">data?.value?.kind === CachedRouteKind.PAGES</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">let cacheTags: undefined | string[]</span><span class="s3">\n      </span><span class="s1">const tagsHeader = data.value.headers?.[NEXT_CACHE_TAGS_HEADER]</span><span class="s3">\n\n      </span><span class="s1">if (typeof tagsHeader === 'string') {</span><span class="s3">\n        </span><span class="s1">cacheTags = tagsHeader.split(',')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (cacheTags?.length) {</span><span class="s3">\n        </span><span class="s1">// we trigger a blocking validation if an ISR page</span><span class="s3">\n        </span><span class="s1">// had a tag revalidated, if we want to be a background</span><span class="s3">\n        </span><span class="s1">// revalidation instead we return data.lastModified = -1</span><span class="s3">\n        </span><span class="s1">if (isStale(cacheTags, data?.lastModified || Date.now())) {</span><span class="s3">\n          </span><span class="s1">return null</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (data?.value?.kind === CachedRouteKind.FETCH) {</span><span class="s3">\n      </span><span class="s1">const combinedTags =</span><span class="s3">\n        </span><span class="s1">ctx.kind === IncrementalCacheKind.FETCH</span><span class="s3">\n          </span><span class="s1">? [...(ctx.tags || []), ...(ctx.softTags || [])]</span><span class="s3">\n          </span><span class="s1">: []</span><span class="s3">\n\n      </span><span class="s1">const wasRevalidated = combinedTags.some((tag) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (this.revalidatedTags.includes(tag)) {</span><span class="s3">\n          </span><span class="s1">return true</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">return isStale([tag], data?.lastModified || Date.now())</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">// When revalidate tag is called we don't return</span><span class="s3">\n      </span><span class="s1">// stale data so it's updated right away</span><span class="s3">\n      </span><span class="s1">if (wasRevalidated) {</span><span class="s3">\n        </span><span class="s1">data = undefined</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return data ?? null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async set(</span><span class="s3">\n    </span><span class="s1">key: string,</span><span class="s3">\n    </span><span class="s1">data: IncrementalCacheValue | null,</span><span class="s3">\n    </span><span class="s1">ctx: SetIncrementalFetchCacheContext | SetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">FileSystemCache.memoryCache?.set(key, {</span><span class="s3">\n      </span><span class="s1">value: data,</span><span class="s3">\n      </span><span class="s1">lastModified: Date.now(),</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">if (FileSystemCache.debug) {</span><span class="s3">\n      </span><span class="s1">console.log('set', key)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!this.flushToDisk || !data) return</span><span class="s3">\n\n    </span><span class="s1">// Create a new writer that will prepare to write all the files to disk</span><span class="s3">\n    </span><span class="s1">// after their containing directory is created.</span><span class="s3">\n    </span><span class="s1">const writer = new MultiFileWriter(this.fs)</span><span class="s3">\n\n    </span><span class="s1">if (data.kind === CachedRouteKind.APP_ROUTE) {</span><span class="s3">\n      </span><span class="s1">const filePath = this.getFilePath(</span><span class="s3">\n        </span><span class="s1">`${key}.body`,</span><span class="s3">\n        </span><span class="s1">IncrementalCacheKind.APP_ROUTE</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">writer.append(filePath, data.body)</span><span class="s3">\n\n      </span><span class="s1">const meta: RouteMetadata = {</span><span class="s3">\n        </span><span class="s1">headers: data.headers,</span><span class="s3">\n        </span><span class="s1">status: data.status,</span><span class="s3">\n        </span><span class="s1">postponed: undefined,</span><span class="s3">\n        </span><span class="s1">segmentPaths: undefined,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">writer.append(</span><span class="s3">\n        </span><span class="s1">filePath.replace(/</span><span class="s3">\\</span><span class="s1">.body$/, NEXT_META_SUFFIX),</span><span class="s3">\n        </span><span class="s1">JSON.stringify(meta, null, 2)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else if (</span><span class="s3">\n      </span><span class="s1">data.kind === CachedRouteKind.PAGES ||</span><span class="s3">\n      </span><span class="s1">data.kind === CachedRouteKind.APP_PAGE</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">const isAppPath = data.kind === CachedRouteKind.APP_PAGE</span><span class="s3">\n      </span><span class="s1">const htmlPath = this.getFilePath(</span><span class="s3">\n        </span><span class="s1">`${key}.html`,</span><span class="s3">\n        </span><span class="s1">isAppPath ? IncrementalCacheKind.APP_PAGE : IncrementalCacheKind.PAGES</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">writer.append(htmlPath, data.html)</span><span class="s3">\n\n      </span><span class="s1">// Fallbacks don't generate a data file.</span><span class="s3">\n      </span><span class="s1">if (!ctx.fetchCache &amp;&amp; !ctx.isFallback) {</span><span class="s3">\n        </span><span class="s1">writer.append(</span><span class="s3">\n          </span><span class="s1">this.getFilePath(</span><span class="s3">\n            </span><span class="s1">`${key}${</span><span class="s3">\n              </span><span class="s1">isAppPath</span><span class="s3">\n                </span><span class="s1">? ctx.isRoutePPREnabled</span><span class="s3">\n                  </span><span class="s1">? RSC_PREFETCH_SUFFIX</span><span class="s3">\n                  </span><span class="s1">: RSC_SUFFIX</span><span class="s3">\n                </span><span class="s1">: NEXT_DATA_SUFFIX</span><span class="s3">\n            </span><span class="s1">}`,</span><span class="s3">\n            </span><span class="s1">isAppPath</span><span class="s3">\n              </span><span class="s1">? IncrementalCacheKind.APP_PAGE</span><span class="s3">\n              </span><span class="s1">: IncrementalCacheKind.PAGES</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">isAppPath ? data.rscData! : JSON.stringify(data.pageData)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (data?.kind === CachedRouteKind.APP_PAGE) {</span><span class="s3">\n        </span><span class="s1">let segmentPaths: string[] | undefined</span><span class="s3">\n        </span><span class="s1">if (data.segmentData) {</span><span class="s3">\n          </span><span class="s1">segmentPaths = []</span><span class="s3">\n          </span><span class="s1">const segmentsDir = htmlPath.replace(</span><span class="s3">\n            </span><span class="s1">/</span><span class="s3">\\</span><span class="s1">.html$/,</span><span class="s3">\n            </span><span class="s1">RSC_SEGMENTS_DIR_SUFFIX</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n\n          </span><span class="s1">for (const [segmentPath, buffer] of data.segmentData) {</span><span class="s3">\n            </span><span class="s1">segmentPaths.push(segmentPath)</span><span class="s3">\n            </span><span class="s1">const segmentDataFilePath =</span><span class="s3">\n              </span><span class="s1">segmentsDir + segmentPath + RSC_SEGMENT_SUFFIX</span><span class="s3">\n            </span><span class="s1">writer.append(segmentDataFilePath, buffer)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const meta: RouteMetadata = {</span><span class="s3">\n          </span><span class="s1">headers: data.headers,</span><span class="s3">\n          </span><span class="s1">status: data.status,</span><span class="s3">\n          </span><span class="s1">postponed: data.postponed,</span><span class="s3">\n          </span><span class="s1">segmentPaths,</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">writer.append(</span><span class="s3">\n          </span><span class="s1">htmlPath.replace(/</span><span class="s3">\\</span><span class="s1">.html$/, NEXT_META_SUFFIX),</span><span class="s3">\n          </span><span class="s1">JSON.stringify(meta)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (data.kind === CachedRouteKind.FETCH) {</span><span class="s3">\n      </span><span class="s1">const filePath = this.getFilePath(key, IncrementalCacheKind.FETCH)</span><span class="s3">\n      </span><span class="s1">writer.append(</span><span class="s3">\n        </span><span class="s1">filePath,</span><span class="s3">\n        </span><span class="s1">JSON.stringify({</span><span class="s3">\n          </span><span class="s1">...data,</span><span class="s3">\n          </span><span class="s1">tags: ctx.fetchCache ? ctx.tags : [],</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Wait for all FS operations to complete.</span><span class="s3">\n    </span><span class="s1">await writer.wait()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private getFilePath(pathname: string, kind: IncrementalCacheKind): string {</span><span class="s3">\n    </span><span class="s1">switch (kind) {</span><span class="s3">\n      </span><span class="s1">case IncrementalCacheKind.FETCH:</span><span class="s3">\n        </span><span class="s1">// we store in .next/cache/fetch-cache so it can be persisted</span><span class="s3">\n        </span><span class="s1">// across deploys</span><span class="s3">\n        </span><span class="s1">return path.join(</span><span class="s3">\n          </span><span class="s1">this.serverDistDir,</span><span class="s3">\n          </span><span class="s1">'..',</span><span class="s3">\n          </span><span class="s1">'cache',</span><span class="s3">\n          </span><span class="s1">'fetch-cache',</span><span class="s3">\n          </span><span class="s1">pathname</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">case IncrementalCacheKind.PAGES:</span><span class="s3">\n        </span><span class="s1">return path.join(this.serverDistDir, 'pages', pathname)</span><span class="s3">\n      </span><span class="s1">case IncrementalCacheKind.IMAGE:</span><span class="s3">\n      </span><span class="s1">case IncrementalCacheKind.APP_PAGE:</span><span class="s3">\n      </span><span class="s1">case IncrementalCacheKind.APP_ROUTE:</span><span class="s3">\n        </span><span class="s1">return path.join(this.serverDistDir, 'app', pathname)</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">throw new Error(`Unexpected file path kind: ${kind}`)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* This transforms a URL pathname into a route. It removes any trailing slashes</span><span class="s3">\n </span><span class="s1">* and the `/index` suffix.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param pathname - The URL path that needs to be optimized.</span><span class="s3">\n </span><span class="s1">* @returns - The route</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">* // returns '/example'</span><span class="s3">\n </span><span class="s1">* toRoute('/example/index/');</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">* // returns '/example'</span><span class="s3">\n </span><span class="s1">* toRoute('/example/');</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">* // returns '/'</span><span class="s3">\n </span><span class="s1">* toRoute('/index/');</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">* // returns '/'</span><span class="s3">\n </span><span class="s1">* toRoute('/');</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function toRoute(pathname: string): string {</span><span class="s3">\n  </span><span class="s1">return pathname.replace(/(?:</span><span class="s3">\\</span><span class="s1">/index)?</span><span class="s3">\\</span><span class="s1">/?$/, '') || '/'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { CacheFs } from '../../../shared/lib/utils'</span><span class="s3">\n</span><span class="s1">import type { PrerenderManifest } from '../../../build'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">type IncrementalCacheValue,</span><span class="s3">\n  </span><span class="s1">type IncrementalCacheEntry,</span><span class="s3">\n  </span><span class="s1">type IncrementalCache as IncrementalCacheType,</span><span class="s3">\n  </span><span class="s1">IncrementalCacheKind,</span><span class="s3">\n  </span><span class="s1">CachedRouteKind,</span><span class="s3">\n  </span><span class="s1">type IncrementalResponseCacheEntry,</span><span class="s3">\n  </span><span class="s1">type IncrementalFetchCacheEntry,</span><span class="s3">\n  </span><span class="s1">type GetIncrementalFetchCacheContext,</span><span class="s3">\n  </span><span class="s1">type GetIncrementalResponseCacheContext,</span><span class="s3">\n  </span><span class="s1">type CachedFetchValue,</span><span class="s3">\n  </span><span class="s1">type SetIncrementalFetchCacheContext,</span><span class="s3">\n  </span><span class="s1">type SetIncrementalResponseCacheContext,</span><span class="s3">\n</span><span class="s1">} from '../../response-cache'</span><span class="s3">\n</span><span class="s1">import type { DeepReadonly } from '../../../shared/lib/deep-readonly'</span><span class="s3">\n\n</span><span class="s1">import FileSystemCache from './file-system-cache'</span><span class="s3">\n</span><span class="s1">import { normalizePagePath } from '../../../shared/lib/page-path/normalize-page-path'</span><span class="s3">\n\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">CACHE_ONE_YEAR,</span><span class="s3">\n  </span><span class="s1">PRERENDER_REVALIDATE_HEADER,</span><span class="s3">\n</span><span class="s1">} from '../../../lib/constants'</span><span class="s3">\n</span><span class="s1">import { toRoute } from '../to-route'</span><span class="s3">\n</span><span class="s1">import { SharedCacheControls } from './shared-cache-controls.external'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">getPrerenderResumeDataCache,</span><span class="s3">\n  </span><span class="s1">getRenderResumeDataCache,</span><span class="s3">\n  </span><span class="s1">workUnitAsyncStorage,</span><span class="s3">\n</span><span class="s1">} from '../../app-render/work-unit-async-storage.external'</span><span class="s3">\n</span><span class="s1">import { InvariantError } from '../../../shared/lib/invariant-error'</span><span class="s3">\n</span><span class="s1">import type { Revalidate } from '../cache-control'</span><span class="s3">\n</span><span class="s1">import { getPreviouslyRevalidatedTags } from '../../server-utils'</span><span class="s3">\n</span><span class="s1">import { workAsyncStorage } from '../../app-render/work-async-storage.external'</span><span class="s3">\n</span><span class="s1">import { DetachedPromise } from '../../../lib/detached-promise'</span><span class="s3">\n\n</span><span class="s1">export interface CacheHandlerContext {</span><span class="s3">\n  </span><span class="s1">fs?: CacheFs</span><span class="s3">\n  </span><span class="s1">dev?: boolean</span><span class="s3">\n  </span><span class="s1">flushToDisk?: boolean</span><span class="s3">\n  </span><span class="s1">serverDistDir?: string</span><span class="s3">\n  </span><span class="s1">maxMemoryCacheSize?: number</span><span class="s3">\n  </span><span class="s1">fetchCacheKeyPrefix?: string</span><span class="s3">\n  </span><span class="s1">prerenderManifest?: PrerenderManifest</span><span class="s3">\n  </span><span class="s1">revalidatedTags: string[]</span><span class="s3">\n  </span><span class="s1">_requestHeaders: IncrementalCache['requestHeaders']</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface CacheHandlerValue {</span><span class="s3">\n  </span><span class="s1">lastModified?: number</span><span class="s3">\n  </span><span class="s1">age?: number</span><span class="s3">\n  </span><span class="s1">cacheState?: string</span><span class="s3">\n  </span><span class="s1">value: IncrementalCacheValue | null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class CacheHandler {</span><span class="s3">\n  </span><span class="s1">// eslint-disable-next-line</span><span class="s3">\n  </span><span class="s1">constructor(_ctx: CacheHandlerContext) {}</span><span class="s3">\n\n  </span><span class="s1">public async get(</span><span class="s3">\n    </span><span class="s1">_cacheKey: string,</span><span class="s3">\n    </span><span class="s1">_ctx: GetIncrementalFetchCacheContext | GetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;CacheHandlerValue | null&gt; {</span><span class="s3">\n    </span><span class="s1">return {} as any</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async set(</span><span class="s3">\n    </span><span class="s1">_cacheKey: string,</span><span class="s3">\n    </span><span class="s1">_data: IncrementalCacheValue | null,</span><span class="s3">\n    </span><span class="s1">_ctx: SetIncrementalFetchCacheContext | SetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; {}</span><span class="s3">\n\n  </span><span class="s1">public async revalidateTag(</span><span class="s3">\n    </span><span class="s1">..._args: Parameters&lt;IncrementalCache['revalidateTag']&gt;</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; {}</span><span class="s3">\n\n  </span><span class="s1">public resetRequestCache(): void {}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class IncrementalCache implements IncrementalCacheType {</span><span class="s3">\n  </span><span class="s1">readonly dev?: boolean</span><span class="s3">\n  </span><span class="s1">readonly disableForTestmode?: boolean</span><span class="s3">\n  </span><span class="s1">readonly cacheHandler?: CacheHandler</span><span class="s3">\n  </span><span class="s1">readonly hasCustomCacheHandler: boolean</span><span class="s3">\n  </span><span class="s1">readonly prerenderManifest: DeepReadonly&lt;PrerenderManifest&gt;</span><span class="s3">\n  </span><span class="s1">readonly requestHeaders: Record&lt;string, undefined | string | string[]&gt;</span><span class="s3">\n  </span><span class="s1">readonly allowedRevalidateHeaderKeys?: string[]</span><span class="s3">\n  </span><span class="s1">readonly minimalMode?: boolean</span><span class="s3">\n  </span><span class="s1">readonly fetchCacheKeyPrefix?: string</span><span class="s3">\n  </span><span class="s1">readonly revalidatedTags?: string[]</span><span class="s3">\n  </span><span class="s1">readonly isOnDemandRevalidate?: boolean</span><span class="s3">\n\n  </span><span class="s1">private static readonly debug: boolean =</span><span class="s3">\n    </span><span class="s1">!!process.env.NEXT_PRIVATE_DEBUG_CACHE</span><span class="s3">\n  </span><span class="s1">private readonly locks = new Map&lt;string, Promise&lt;void&gt;&gt;()</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The cache controls for routes. This will source the values from the</span><span class="s3">\n   </span><span class="s1">* prerender manifest until the in-memory cache is updated with new values.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">private readonly cacheControls: SharedCacheControls</span><span class="s3">\n\n  </span><span class="s1">constructor({</span><span class="s3">\n    </span><span class="s1">fs,</span><span class="s3">\n    </span><span class="s1">dev,</span><span class="s3">\n    </span><span class="s1">flushToDisk,</span><span class="s3">\n    </span><span class="s1">minimalMode,</span><span class="s3">\n    </span><span class="s1">serverDistDir,</span><span class="s3">\n    </span><span class="s1">requestHeaders,</span><span class="s3">\n    </span><span class="s1">maxMemoryCacheSize,</span><span class="s3">\n    </span><span class="s1">getPrerenderManifest,</span><span class="s3">\n    </span><span class="s1">fetchCacheKeyPrefix,</span><span class="s3">\n    </span><span class="s1">CurCacheHandler,</span><span class="s3">\n    </span><span class="s1">allowedRevalidateHeaderKeys,</span><span class="s3">\n  </span><span class="s1">}: {</span><span class="s3">\n    </span><span class="s1">fs?: CacheFs</span><span class="s3">\n    </span><span class="s1">dev: boolean</span><span class="s3">\n    </span><span class="s1">minimalMode?: boolean</span><span class="s3">\n    </span><span class="s1">serverDistDir?: string</span><span class="s3">\n    </span><span class="s1">flushToDisk?: boolean</span><span class="s3">\n    </span><span class="s1">allowedRevalidateHeaderKeys?: string[]</span><span class="s3">\n    </span><span class="s1">requestHeaders: IncrementalCache['requestHeaders']</span><span class="s3">\n    </span><span class="s1">maxMemoryCacheSize?: number</span><span class="s3">\n    </span><span class="s1">getPrerenderManifest: () =&gt; DeepReadonly&lt;PrerenderManifest&gt;</span><span class="s3">\n    </span><span class="s1">fetchCacheKeyPrefix?: string</span><span class="s3">\n    </span><span class="s1">CurCacheHandler?: typeof CacheHandler</span><span class="s3">\n  </span><span class="s1">}) {</span><span class="s3">\n    </span><span class="s1">this.hasCustomCacheHandler = Boolean(CurCacheHandler)</span><span class="s3">\n\n    </span><span class="s1">const cacheHandlersSymbol = Symbol.for('@next/cache-handlers')</span><span class="s3">\n    </span><span class="s1">const _globalThis: typeof globalThis &amp; {</span><span class="s3">\n      </span><span class="s1">[cacheHandlersSymbol]?: {</span><span class="s3">\n        </span><span class="s1">FetchCache?: typeof CacheHandler</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} = globalThis</span><span class="s3">\n\n    </span><span class="s1">if (!CurCacheHandler) {</span><span class="s3">\n      </span><span class="s1">// if we have a global cache handler available leverage it</span><span class="s3">\n      </span><span class="s1">const globalCacheHandler = _globalThis[cacheHandlersSymbol]</span><span class="s3">\n\n      </span><span class="s1">if (globalCacheHandler?.FetchCache) {</span><span class="s3">\n        </span><span class="s1">CurCacheHandler = globalCacheHandler.FetchCache</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">if (fs &amp;&amp; serverDistDir) {</span><span class="s3">\n          </span><span class="s1">if (IncrementalCache.debug) {</span><span class="s3">\n            </span><span class="s1">console.log('using filesystem cache handler')</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">CurCacheHandler = FileSystemCache</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (IncrementalCache.debug) {</span><span class="s3">\n      </span><span class="s1">console.log('using custom cache handler', CurCacheHandler.name)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (process.env.__NEXT_TEST_MAX_ISR_CACHE) {</span><span class="s3">\n      </span><span class="s1">// Allow cache size to be overridden for testing purposes</span><span class="s3">\n      </span><span class="s1">maxMemoryCacheSize = parseInt(process.env.__NEXT_TEST_MAX_ISR_CACHE, 10)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.dev = dev</span><span class="s3">\n    </span><span class="s1">this.disableForTestmode = process.env.NEXT_PRIVATE_TEST_PROXY === 'true'</span><span class="s3">\n    </span><span class="s1">// this is a hack to avoid Webpack knowing this is equal to this.minimalMode</span><span class="s3">\n    </span><span class="s1">// because we replace this.minimalMode to true in production bundles.</span><span class="s3">\n    </span><span class="s1">const minimalModeKey = 'minimalMode'</span><span class="s3">\n    </span><span class="s1">this[minimalModeKey] = minimalMode</span><span class="s3">\n    </span><span class="s1">this.requestHeaders = requestHeaders</span><span class="s3">\n    </span><span class="s1">this.allowedRevalidateHeaderKeys = allowedRevalidateHeaderKeys</span><span class="s3">\n    </span><span class="s1">this.prerenderManifest = getPrerenderManifest()</span><span class="s3">\n    </span><span class="s1">this.cacheControls = new SharedCacheControls(this.prerenderManifest)</span><span class="s3">\n    </span><span class="s1">this.fetchCacheKeyPrefix = fetchCacheKeyPrefix</span><span class="s3">\n    </span><span class="s1">let revalidatedTags: string[] = []</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">requestHeaders[PRERENDER_REVALIDATE_HEADER] ===</span><span class="s3">\n      </span><span class="s1">this.prerenderManifest?.preview?.previewModeId</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">this.isOnDemandRevalidate = true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (minimalMode) {</span><span class="s3">\n      </span><span class="s1">revalidatedTags = getPreviouslyRevalidatedTags(</span><span class="s3">\n        </span><span class="s1">requestHeaders,</span><span class="s3">\n        </span><span class="s1">this.prerenderManifest?.preview?.previewModeId</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (CurCacheHandler) {</span><span class="s3">\n      </span><span class="s1">this.cacheHandler = new CurCacheHandler({</span><span class="s3">\n        </span><span class="s1">dev,</span><span class="s3">\n        </span><span class="s1">fs,</span><span class="s3">\n        </span><span class="s1">flushToDisk,</span><span class="s3">\n        </span><span class="s1">serverDistDir,</span><span class="s3">\n        </span><span class="s1">revalidatedTags,</span><span class="s3">\n        </span><span class="s1">maxMemoryCacheSize,</span><span class="s3">\n        </span><span class="s1">_requestHeaders: requestHeaders,</span><span class="s3">\n        </span><span class="s1">fetchCacheKeyPrefix,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private calculateRevalidate(</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">fromTime: number,</span><span class="s3">\n    </span><span class="s1">dev: boolean,</span><span class="s3">\n    </span><span class="s1">isFallback: boolean | undefined</span><span class="s3">\n  </span><span class="s1">): Revalidate {</span><span class="s3">\n    </span><span class="s1">// in development we don't have a prerender-manifest</span><span class="s3">\n    </span><span class="s1">// and default to always revalidating to allow easier debugging</span><span class="s3">\n    </span><span class="s1">if (dev)</span><span class="s3">\n      </span><span class="s1">return Math.floor(performance.timeOrigin + performance.now() - 1000)</span><span class="s3">\n\n    </span><span class="s1">const cacheControl = this.cacheControls.get(toRoute(pathname))</span><span class="s3">\n\n    </span><span class="s1">// if an entry isn't present in routes we fallback to a default</span><span class="s3">\n    </span><span class="s1">// of revalidating after 1 second unless it's a fallback request.</span><span class="s3">\n    </span><span class="s1">const initialRevalidateSeconds = cacheControl</span><span class="s3">\n      </span><span class="s1">? cacheControl.revalidate</span><span class="s3">\n      </span><span class="s1">: isFallback</span><span class="s3">\n        </span><span class="s1">? false</span><span class="s3">\n        </span><span class="s1">: 1</span><span class="s3">\n\n    </span><span class="s1">const revalidateAfter =</span><span class="s3">\n      </span><span class="s1">typeof initialRevalidateSeconds === 'number'</span><span class="s3">\n        </span><span class="s1">? initialRevalidateSeconds * 1000 + fromTime</span><span class="s3">\n        </span><span class="s1">: initialRevalidateSeconds</span><span class="s3">\n\n    </span><span class="s1">return revalidateAfter</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_getPathname(pathname: string, fetchCache?: boolean) {</span><span class="s3">\n    </span><span class="s1">return fetchCache ? pathname : normalizePagePath(pathname)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">resetRequestCache() {</span><span class="s3">\n    </span><span class="s1">this.cacheHandler?.resetRequestCache?.()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">async lock(cacheKey: string): Promise&lt;() =&gt; Promise&lt;void&gt; | void&gt; {</span><span class="s3">\n    </span><span class="s1">// Wait for any existing lock on this cache key to be released</span><span class="s3">\n    </span><span class="s1">// This implements a simple queue-based locking mechanism</span><span class="s3">\n    </span><span class="s1">while (true) {</span><span class="s3">\n      </span><span class="s1">const lock = this.locks.get(cacheKey)</span><span class="s3">\n\n      </span><span class="s1">if (IncrementalCache.debug) {</span><span class="s3">\n        </span><span class="s1">console.log('lock get', cacheKey, !!lock)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// If no lock exists, we can proceed to acquire it</span><span class="s3">\n      </span><span class="s1">if (!lock) break</span><span class="s3">\n\n      </span><span class="s1">// Wait for the existing lock to be released before trying again</span><span class="s3">\n      </span><span class="s1">await lock</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Create a new detached promise that will represent this lock</span><span class="s3">\n    </span><span class="s1">// The resolve function (unlock) will be returned to the caller</span><span class="s3">\n    </span><span class="s1">const { resolve, promise } = new DetachedPromise&lt;void&gt;()</span><span class="s3">\n\n    </span><span class="s1">if (IncrementalCache.debug) {</span><span class="s3">\n      </span><span class="s1">console.log('successfully locked', cacheKey)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Store the lock promise in the locks map</span><span class="s3">\n    </span><span class="s1">this.locks.set(cacheKey, promise)</span><span class="s3">\n\n    </span><span class="s1">return () =&gt; {</span><span class="s3">\n      </span><span class="s1">// Resolve the promise to release the lock.</span><span class="s3">\n      </span><span class="s1">resolve()</span><span class="s3">\n\n      </span><span class="s1">// Remove the lock from the map once it's released so that future gets</span><span class="s3">\n      </span><span class="s1">// can acquire the lock.</span><span class="s3">\n      </span><span class="s1">this.locks.delete(cacheKey)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">async revalidateTag(tags: string | string[]): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">return this.cacheHandler?.revalidateTag(tags)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// x-ref: https://github.com/facebook/react/blob/2655c9354d8e1c54ba888444220f63e836925caa/packages/react/src/ReactFetch.js#L23</span><span class="s3">\n  </span><span class="s1">async generateCacheKey(</span><span class="s3">\n    </span><span class="s1">url: string,</span><span class="s3">\n    </span><span class="s1">init: RequestInit | Request = {}</span><span class="s3">\n  </span><span class="s1">): Promise&lt;string&gt; {</span><span class="s3">\n    </span><span class="s1">// this should be bumped anytime a fix is made to cache entries</span><span class="s3">\n    </span><span class="s1">// that should bust the cache</span><span class="s3">\n    </span><span class="s1">const MAIN_KEY_PREFIX = 'v3'</span><span class="s3">\n\n    </span><span class="s1">const bodyChunks: string[] = []</span><span class="s3">\n\n    </span><span class="s1">const encoder = new TextEncoder()</span><span class="s3">\n    </span><span class="s1">const decoder = new TextDecoder()</span><span class="s3">\n\n    </span><span class="s1">if (init.body) {</span><span class="s3">\n      </span><span class="s1">// handle Uint8Array body</span><span class="s3">\n      </span><span class="s1">if (init.body instanceof Uint8Array) {</span><span class="s3">\n        </span><span class="s1">bodyChunks.push(decoder.decode(init.body))</span><span class="s3">\n        </span><span class="s1">;(init as any)._ogBody = init.body</span><span class="s3">\n      </span><span class="s1">} // handle ReadableStream body</span><span class="s3">\n      </span><span class="s1">else if (typeof (init.body as any).getReader === 'function') {</span><span class="s3">\n        </span><span class="s1">const readableBody = init.body as ReadableStream&lt;Uint8Array | string&gt;</span><span class="s3">\n\n        </span><span class="s1">const chunks: Uint8Array[] = []</span><span class="s3">\n\n        </span><span class="s1">try {</span><span class="s3">\n          </span><span class="s1">await readableBody.pipeTo(</span><span class="s3">\n            </span><span class="s1">new WritableStream({</span><span class="s3">\n              </span><span class="s1">write(chunk) {</span><span class="s3">\n                </span><span class="s1">if (typeof chunk === 'string') {</span><span class="s3">\n                  </span><span class="s1">chunks.push(encoder.encode(chunk))</span><span class="s3">\n                  </span><span class="s1">bodyChunks.push(chunk)</span><span class="s3">\n                </span><span class="s1">} else {</span><span class="s3">\n                  </span><span class="s1">chunks.push(chunk)</span><span class="s3">\n                  </span><span class="s1">bodyChunks.push(decoder.decode(chunk, { stream: true }))</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n\n          </span><span class="s1">// Flush the decoder.</span><span class="s3">\n          </span><span class="s1">bodyChunks.push(decoder.decode())</span><span class="s3">\n\n          </span><span class="s1">// Create a new buffer with all the chunks.</span><span class="s3">\n          </span><span class="s1">const length = chunks.reduce((total, arr) =&gt; total + arr.length, 0)</span><span class="s3">\n          </span><span class="s1">const arrayBuffer = new Uint8Array(length)</span><span class="s3">\n\n          </span><span class="s1">// Push each of the chunks into the new array buffer.</span><span class="s3">\n          </span><span class="s1">let offset = 0</span><span class="s3">\n          </span><span class="s1">for (const chunk of chunks) {</span><span class="s3">\n            </span><span class="s1">arrayBuffer.set(chunk, offset)</span><span class="s3">\n            </span><span class="s1">offset += chunk.length</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">;(init as any)._ogBody = arrayBuffer</span><span class="s3">\n        </span><span class="s1">} catch (err) {</span><span class="s3">\n          </span><span class="s1">console.error('Problem reading body', err)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} // handle FormData or URLSearchParams bodies</span><span class="s3">\n      </span><span class="s1">else if (typeof (init.body as any).keys === 'function') {</span><span class="s3">\n        </span><span class="s1">const formData = init.body as FormData</span><span class="s3">\n        </span><span class="s1">;(init as any)._ogBody = init.body</span><span class="s3">\n        </span><span class="s1">for (const key of new Set([...formData.keys()])) {</span><span class="s3">\n          </span><span class="s1">const values = formData.getAll(key)</span><span class="s3">\n          </span><span class="s1">bodyChunks.push(</span><span class="s3">\n            </span><span class="s1">`${key}=${(</span><span class="s3">\n              </span><span class="s1">await Promise.all(</span><span class="s3">\n                </span><span class="s1">values.map(async (val) =&gt; {</span><span class="s3">\n                  </span><span class="s1">if (typeof val === 'string') {</span><span class="s3">\n                    </span><span class="s1">return val</span><span class="s3">\n                  </span><span class="s1">} else {</span><span class="s3">\n                    </span><span class="s1">return await val.text()</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">})</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">).join(',')}`</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// handle blob body</span><span class="s3">\n      </span><span class="s1">} else if (typeof (init.body as any).arrayBuffer === 'function') {</span><span class="s3">\n        </span><span class="s1">const blob = init.body as Blob</span><span class="s3">\n        </span><span class="s1">const arrayBuffer = await blob.arrayBuffer()</span><span class="s3">\n        </span><span class="s1">bodyChunks.push(await blob.text())</span><span class="s3">\n        </span><span class="s1">;(init as any)._ogBody = new Blob([arrayBuffer], { type: blob.type })</span><span class="s3">\n      </span><span class="s1">} else if (typeof init.body === 'string') {</span><span class="s3">\n        </span><span class="s1">bodyChunks.push(init.body)</span><span class="s3">\n        </span><span class="s1">;(init as any)._ogBody = init.body</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const headers =</span><span class="s3">\n      </span><span class="s1">typeof (init.headers || {}).keys === 'function'</span><span class="s3">\n        </span><span class="s1">? Object.fromEntries(init.headers as Headers)</span><span class="s3">\n        </span><span class="s1">: Object.assign({}, init.headers)</span><span class="s3">\n\n    </span><span class="s1">// w3c trace context headers can break request caching and deduplication</span><span class="s3">\n    </span><span class="s1">// so we remove them from the cache key</span><span class="s3">\n    </span><span class="s1">if ('traceparent' in headers) delete headers['traceparent']</span><span class="s3">\n    </span><span class="s1">if ('tracestate' in headers) delete headers['tracestate']</span><span class="s3">\n\n    </span><span class="s1">const cacheString = JSON.stringify([</span><span class="s3">\n      </span><span class="s1">MAIN_KEY_PREFIX,</span><span class="s3">\n      </span><span class="s1">this.fetchCacheKeyPrefix || '',</span><span class="s3">\n      </span><span class="s1">url,</span><span class="s3">\n      </span><span class="s1">init.method,</span><span class="s3">\n      </span><span class="s1">headers,</span><span class="s3">\n      </span><span class="s1">init.mode,</span><span class="s3">\n      </span><span class="s1">init.redirect,</span><span class="s3">\n      </span><span class="s1">init.credentials,</span><span class="s3">\n      </span><span class="s1">init.referrer,</span><span class="s3">\n      </span><span class="s1">init.referrerPolicy,</span><span class="s3">\n      </span><span class="s1">init.integrity,</span><span class="s3">\n      </span><span class="s1">init.cache,</span><span class="s3">\n      </span><span class="s1">bodyChunks,</span><span class="s3">\n    </span><span class="s1">])</span><span class="s3">\n\n    </span><span class="s1">if (process.env.NEXT_RUNTIME === 'edge') {</span><span class="s3">\n      </span><span class="s1">function bufferToHex(buffer: ArrayBuffer): string {</span><span class="s3">\n        </span><span class="s1">return Array.prototype.map</span><span class="s3">\n          </span><span class="s1">.call(new Uint8Array(buffer), (b) =&gt; b.toString(16).padStart(2, '0'))</span><span class="s3">\n          </span><span class="s1">.join('')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const buffer = encoder.encode(cacheString)</span><span class="s3">\n      </span><span class="s1">return bufferToHex(await crypto.subtle.digest('SHA-256', buffer))</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">const crypto = require('crypto') as typeof import('crypto')</span><span class="s3">\n      </span><span class="s1">return crypto.createHash('sha256').update(cacheString).digest('hex')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">async get(</span><span class="s3">\n    </span><span class="s1">cacheKey: string,</span><span class="s3">\n    </span><span class="s1">ctx: GetIncrementalFetchCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;IncrementalFetchCacheEntry | null&gt;</span><span class="s3">\n  </span><span class="s1">async get(</span><span class="s3">\n    </span><span class="s1">cacheKey: string,</span><span class="s3">\n    </span><span class="s1">ctx: GetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;IncrementalResponseCacheEntry | null&gt;</span><span class="s3">\n  </span><span class="s1">async get(</span><span class="s3">\n    </span><span class="s1">cacheKey: string,</span><span class="s3">\n    </span><span class="s1">ctx: GetIncrementalFetchCacheContext | GetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;IncrementalCacheEntry | null&gt; {</span><span class="s3">\n    </span><span class="s1">// Unlike other caches if we have a resume data cache, we use it even if</span><span class="s3">\n    </span><span class="s1">// testmode would normally disable it or if requestHeaders say 'no-cache'.</span><span class="s3">\n    </span><span class="s1">if (ctx.kind === IncrementalCacheKind.FETCH) {</span><span class="s3">\n      </span><span class="s1">const workUnitStore = workUnitAsyncStorage.getStore()</span><span class="s3">\n      </span><span class="s1">const resumeDataCache = workUnitStore</span><span class="s3">\n        </span><span class="s1">? getRenderResumeDataCache(workUnitStore)</span><span class="s3">\n        </span><span class="s1">: null</span><span class="s3">\n      </span><span class="s1">if (resumeDataCache) {</span><span class="s3">\n        </span><span class="s1">const memoryCacheData = resumeDataCache.fetch.get(cacheKey)</span><span class="s3">\n        </span><span class="s1">if (memoryCacheData?.kind === CachedRouteKind.FETCH) {</span><span class="s3">\n          </span><span class="s1">return { isStale: false, value: memoryCacheData }</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// we don't leverage the prerender cache in dev mode</span><span class="s3">\n    </span><span class="s1">// so that getStaticProps is always called for easier debugging</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">this.disableForTestmode ||</span><span class="s3">\n      </span><span class="s1">(this.dev &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(ctx.kind !== IncrementalCacheKind.FETCH ||</span><span class="s3">\n          </span><span class="s1">this.requestHeaders['cache-control'] === 'no-cache'))</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">cacheKey = this._getPathname(</span><span class="s3">\n      </span><span class="s1">cacheKey,</span><span class="s3">\n      </span><span class="s1">ctx.kind === IncrementalCacheKind.FETCH</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">const cacheData = await this.cacheHandler?.get(cacheKey, ctx)</span><span class="s3">\n\n    </span><span class="s1">if (ctx.kind === IncrementalCacheKind.FETCH) {</span><span class="s3">\n      </span><span class="s1">if (!cacheData) {</span><span class="s3">\n        </span><span class="s1">return null</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (cacheData.value?.kind !== CachedRouteKind.FETCH) {</span><span class="s3">\n        </span><span class="s1">throw new InvariantError(</span><span class="s3">\n          </span><span class="s1">`Expected cached value for cache key ${JSON.stringify(cacheKey)} to be a </span><span class="s3">\&quot;</span><span class="s1">FETCH</span><span class="s3">\&quot; </span><span class="s1">kind, got ${JSON.stringify(cacheData.value?.kind)} instead.`</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const workStore = workAsyncStorage.getStore()</span><span class="s3">\n      </span><span class="s1">const combinedTags = [...(ctx.tags || []), ...(ctx.softTags || [])]</span><span class="s3">\n      </span><span class="s1">// if a tag was revalidated we don't return stale data</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">combinedTags.some(</span><span class="s3">\n          </span><span class="s1">(tag) =&gt;</span><span class="s3">\n            </span><span class="s1">this.revalidatedTags?.includes(tag) ||</span><span class="s3">\n            </span><span class="s1">workStore?.pendingRevalidatedTags?.includes(tag)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return null</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const revalidate = ctx.revalidate || cacheData.value.revalidate</span><span class="s3">\n      </span><span class="s1">const age =</span><span class="s3">\n        </span><span class="s1">(performance.timeOrigin +</span><span class="s3">\n          </span><span class="s1">performance.now() -</span><span class="s3">\n          </span><span class="s1">(cacheData.lastModified || 0)) /</span><span class="s3">\n        </span><span class="s1">1000</span><span class="s3">\n\n      </span><span class="s1">const isStale = age &gt; revalidate</span><span class="s3">\n      </span><span class="s1">const data = cacheData.value.data</span><span class="s3">\n\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">isStale,</span><span class="s3">\n        </span><span class="s1">value: { kind: CachedRouteKind.FETCH, data, revalidate },</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (cacheData?.value?.kind === CachedRouteKind.FETCH) {</span><span class="s3">\n      </span><span class="s1">throw new InvariantError(</span><span class="s3">\n        </span><span class="s1">`Expected cached value for cache key ${JSON.stringify(cacheKey)} not to be a ${JSON.stringify(ctx.kind)} kind, got </span><span class="s3">\&quot;</span><span class="s1">FETCH</span><span class="s3">\&quot; </span><span class="s1">instead.`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let entry: IncrementalResponseCacheEntry | null = null</span><span class="s3">\n    </span><span class="s1">const cacheControl = this.cacheControls.get(toRoute(cacheKey))</span><span class="s3">\n\n    </span><span class="s1">let isStale: boolean | -1 | undefined</span><span class="s3">\n    </span><span class="s1">let revalidateAfter: Revalidate</span><span class="s3">\n\n    </span><span class="s1">if (cacheData?.lastModified === -1) {</span><span class="s3">\n      </span><span class="s1">isStale = -1</span><span class="s3">\n      </span><span class="s1">revalidateAfter = -1 * CACHE_ONE_YEAR</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">revalidateAfter = this.calculateRevalidate(</span><span class="s3">\n        </span><span class="s1">cacheKey,</span><span class="s3">\n        </span><span class="s1">cacheData?.lastModified || performance.timeOrigin + performance.now(),</span><span class="s3">\n        </span><span class="s1">this.dev ?? false,</span><span class="s3">\n        </span><span class="s1">ctx.isFallback</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">isStale =</span><span class="s3">\n        </span><span class="s1">revalidateAfter !== false &amp;&amp;</span><span class="s3">\n        </span><span class="s1">revalidateAfter &lt; performance.timeOrigin + performance.now()</span><span class="s3">\n          </span><span class="s1">? true</span><span class="s3">\n          </span><span class="s1">: undefined</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (cacheData) {</span><span class="s3">\n      </span><span class="s1">entry = {</span><span class="s3">\n        </span><span class="s1">isStale,</span><span class="s3">\n        </span><span class="s1">cacheControl,</span><span class="s3">\n        </span><span class="s1">revalidateAfter,</span><span class="s3">\n        </span><span class="s1">value: cacheData.value,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">!cacheData &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this.prerenderManifest.notFoundRoutes.includes(cacheKey)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// for the first hit after starting the server the cache</span><span class="s3">\n      </span><span class="s1">// may not have a way to save notFound: true so if</span><span class="s3">\n      </span><span class="s1">// the prerender-manifest marks this as notFound then we</span><span class="s3">\n      </span><span class="s1">// return that entry and trigger a cache set to give it a</span><span class="s3">\n      </span><span class="s1">// chance to update in-memory entries</span><span class="s3">\n      </span><span class="s1">entry = {</span><span class="s3">\n        </span><span class="s1">isStale,</span><span class="s3">\n        </span><span class="s1">value: null,</span><span class="s3">\n        </span><span class="s1">cacheControl,</span><span class="s3">\n        </span><span class="s1">revalidateAfter,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">this.set(cacheKey, entry.value, { ...ctx, cacheControl })</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return entry</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">async set(</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">data: CachedFetchValue | null,</span><span class="s3">\n    </span><span class="s1">ctx: SetIncrementalFetchCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt;</span><span class="s3">\n  </span><span class="s1">async set(</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">data: Exclude&lt;IncrementalCacheValue, CachedFetchValue&gt; | null,</span><span class="s3">\n    </span><span class="s1">ctx: SetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt;</span><span class="s3">\n  </span><span class="s1">async set(</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">data: IncrementalCacheValue | null,</span><span class="s3">\n    </span><span class="s1">ctx: SetIncrementalFetchCacheContext | SetIncrementalResponseCacheContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">// Even if we otherwise disable caching for testMode or if no fetchCache is</span><span class="s3">\n    </span><span class="s1">// configured we still always stash results in the resume data cache if one</span><span class="s3">\n    </span><span class="s1">// exists. This is because this is a transient in memory cache that</span><span class="s3">\n    </span><span class="s1">// populates caches ahead of a dynamic render in dev mode to allow the RSC</span><span class="s3">\n    </span><span class="s1">// debug info to have the right environment associated to it.</span><span class="s3">\n    </span><span class="s1">if (data?.kind === CachedRouteKind.FETCH) {</span><span class="s3">\n      </span><span class="s1">const workUnitStore = workUnitAsyncStorage.getStore()</span><span class="s3">\n      </span><span class="s1">const prerenderResumeDataCache = workUnitStore</span><span class="s3">\n        </span><span class="s1">? getPrerenderResumeDataCache(workUnitStore)</span><span class="s3">\n        </span><span class="s1">: null</span><span class="s3">\n      </span><span class="s1">if (prerenderResumeDataCache) {</span><span class="s3">\n        </span><span class="s1">prerenderResumeDataCache.fetch.set(pathname, data)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (this.disableForTestmode || (this.dev &amp;&amp; !ctx.fetchCache)) return</span><span class="s3">\n\n    </span><span class="s1">pathname = this._getPathname(pathname, ctx.fetchCache)</span><span class="s3">\n\n    </span><span class="s1">// FetchCache has upper limit of 2MB per-entry currently</span><span class="s3">\n    </span><span class="s1">const itemSize = JSON.stringify(data).length</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">ctx.fetchCache &amp;&amp;</span><span class="s3">\n      </span><span class="s1">itemSize &gt; 2 * 1024 * 1024 &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// We ignore the size limit when custom cache handler is being used, as it</span><span class="s3">\n      </span><span class="s1">// might not have this limit</span><span class="s3">\n      </span><span class="s1">!this.hasCustomCacheHandler &amp;&amp;</span><span class="s3">\n      </span><span class="s1">// We also ignore the size limit when it's an implicit build-time-only</span><span class="s3">\n      </span><span class="s1">// caching that the user isn't even aware of.</span><span class="s3">\n      </span><span class="s1">!ctx.isImplicitBuildTimeCache</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">const warningText = `Failed to set Next.js data cache for ${ctx.fetchUrl || pathname}, items over 2MB can not be cached (${itemSize} bytes)`</span><span class="s3">\n\n      </span><span class="s1">if (this.dev) {</span><span class="s3">\n        </span><span class="s1">throw new Error(warningText)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">console.warn(warningText)</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">if (!ctx.fetchCache &amp;&amp; ctx.cacheControl) {</span><span class="s3">\n        </span><span class="s1">this.cacheControls.set(toRoute(pathname), ctx.cacheControl)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">await this.cacheHandler?.set(pathname, data, ctx)</span><span class="s3">\n    </span><span class="s1">} catch (error) {</span><span class="s3">\n      </span><span class="s1">console.warn('Failed to update prerender cache for', pathname, error)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import DefaultCacheHandler from '../lib/cache-handlers/default.external'</span><span class="s3">\n</span><span class="s1">import type { CacheHandlerCompat } from '../lib/cache-handlers/types'</span><span class="s3">\n\n</span><span class="s1">const debug = process.env.NEXT_PRIVATE_DEBUG_CACHE</span><span class="s3">\n  </span><span class="s1">? (message: string, ...args: any[]) =&gt; {</span><span class="s3">\n      </span><span class="s1">console.log(`use-cache: ${message}`, ...args)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">: undefined</span><span class="s3">\n\n</span><span class="s1">const handlersSymbol = Symbol.for('@next/cache-handlers')</span><span class="s3">\n</span><span class="s1">const handlersMapSymbol = Symbol.for('@next/cache-handlers-map')</span><span class="s3">\n</span><span class="s1">const handlersSetSymbol = Symbol.for('@next/cache-handlers-set')</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The reference to the cache handlers. We store the cache handlers on the</span><span class="s3">\n </span><span class="s1">* global object so that we can access the same instance across different</span><span class="s3">\n </span><span class="s1">* boundaries (such as different copies of the same module).</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const reference: typeof globalThis &amp; {</span><span class="s3">\n  </span><span class="s1">[handlersSymbol]?: {</span><span class="s3">\n    </span><span class="s1">RemoteCache?: CacheHandlerCompat</span><span class="s3">\n    </span><span class="s1">DefaultCache?: CacheHandlerCompat</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">[handlersMapSymbol]?: Map&lt;string, CacheHandlerCompat&gt;</span><span class="s3">\n  </span><span class="s1">[handlersSetSymbol]?: Set&lt;CacheHandlerCompat&gt;</span><span class="s3">\n</span><span class="s1">} = globalThis</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Initialize the cache handlers.</span><span class="s3">\n </span><span class="s1">* @returns `true` if the cache handlers were initialized, `false` if they were already initialized.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function initializeCacheHandlers(): boolean {</span><span class="s3">\n  </span><span class="s1">// If the cache handlers have already been initialized, don't do it again.</span><span class="s3">\n  </span><span class="s1">if (reference[handlersMapSymbol]) {</span><span class="s3">\n    </span><span class="s1">debug?.('cache handlers already initialized')</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">debug?.('initializing cache handlers')</span><span class="s3">\n  </span><span class="s1">reference[handlersMapSymbol] = new Map&lt;string, CacheHandlerCompat&gt;()</span><span class="s3">\n\n  </span><span class="s1">// Initialize the cache from the symbol contents first.</span><span class="s3">\n  </span><span class="s1">if (reference[handlersSymbol]) {</span><span class="s3">\n    </span><span class="s1">let fallback: CacheHandlerCompat</span><span class="s3">\n    </span><span class="s1">if (reference[handlersSymbol].DefaultCache) {</span><span class="s3">\n      </span><span class="s1">debug?.('setting </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot; </span><span class="s1">cache handler from symbol')</span><span class="s3">\n      </span><span class="s1">fallback = reference[handlersSymbol].DefaultCache</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">debug?.('setting </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot; </span><span class="s1">cache handler from default')</span><span class="s3">\n      </span><span class="s1">fallback = DefaultCacheHandler</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">reference[handlersMapSymbol].set('default', fallback)</span><span class="s3">\n\n    </span><span class="s1">if (reference[handlersSymbol].RemoteCache) {</span><span class="s3">\n      </span><span class="s1">debug?.('setting </span><span class="s3">\&quot;</span><span class="s1">remote</span><span class="s3">\&quot; </span><span class="s1">cache handler from symbol')</span><span class="s3">\n      </span><span class="s1">reference[handlersMapSymbol].set(</span><span class="s3">\n        </span><span class="s1">'remote',</span><span class="s3">\n        </span><span class="s1">reference[handlersSymbol].RemoteCache</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">debug?.('setting </span><span class="s3">\&quot;</span><span class="s1">remote</span><span class="s3">\&quot; </span><span class="s1">cache handler from default')</span><span class="s3">\n      </span><span class="s1">reference[handlersMapSymbol].set('remote', fallback)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">debug?.('setting </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot; </span><span class="s1">cache handler from default')</span><span class="s3">\n    </span><span class="s1">reference[handlersMapSymbol].set('default', DefaultCacheHandler)</span><span class="s3">\n    </span><span class="s1">debug?.('setting </span><span class="s3">\&quot;</span><span class="s1">remote</span><span class="s3">\&quot; </span><span class="s1">cache handler from default')</span><span class="s3">\n    </span><span class="s1">reference[handlersMapSymbol].set('remote', DefaultCacheHandler)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Create a set of the cache handlers.</span><span class="s3">\n  </span><span class="s1">reference[handlersSetSymbol] = new Set(reference[handlersMapSymbol].values())</span><span class="s3">\n\n  </span><span class="s1">return true</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Get a cache handler by kind.</span><span class="s3">\n </span><span class="s1">* @param kind - The kind of cache handler to get.</span><span class="s3">\n </span><span class="s1">* @returns The cache handler, or `undefined` if it does not exist.</span><span class="s3">\n </span><span class="s1">* @throws If the cache handlers are not initialized.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getCacheHandler(kind: string): CacheHandlerCompat | undefined {</span><span class="s3">\n  </span><span class="s1">// This should never be called before initializeCacheHandlers.</span><span class="s3">\n  </span><span class="s1">if (!reference[handlersMapSymbol]) {</span><span class="s3">\n    </span><span class="s1">throw new Error('Cache handlers not initialized')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return reference[handlersMapSymbol].get(kind)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Get a set iterator over the cache handlers.</span><span class="s3">\n </span><span class="s1">* @returns An iterator over the cache handlers, or `undefined` if they are not</span><span class="s3">\n </span><span class="s1">* initialized.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getCacheHandlers():</span><span class="s3">\n  </span><span class="s1">| SetIterator&lt;CacheHandlerCompat&gt;</span><span class="s3">\n  </span><span class="s1">| undefined {</span><span class="s3">\n  </span><span class="s1">if (!reference[handlersSetSymbol]) {</span><span class="s3">\n    </span><span class="s1">return undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return reference[handlersSetSymbol].values()</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Get a map iterator over the cache handlers (keyed by kind).</span><span class="s3">\n </span><span class="s1">* @returns An iterator over the cache handler entries, or `undefined` if they</span><span class="s3">\n </span><span class="s1">* are not initialized.</span><span class="s3">\n </span><span class="s1">* @throws If the cache handlers are not initialized.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getCacheHandlerEntries():</span><span class="s3">\n  </span><span class="s1">| MapIterator&lt;[string, CacheHandlerCompat]&gt;</span><span class="s3">\n  </span><span class="s1">| undefined {</span><span class="s3">\n  </span><span class="s1">if (!reference[handlersMapSymbol]) {</span><span class="s3">\n    </span><span class="s1">return undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return reference[handlersMapSymbol].entries()</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Set a cache handler by kind.</span><span class="s3">\n </span><span class="s1">* @param kind - The kind of cache handler to set.</span><span class="s3">\n </span><span class="s1">* @param cacheHandler - The cache handler to set.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function setCacheHandler(</span><span class="s3">\n  </span><span class="s1">kind: string,</span><span class="s3">\n  </span><span class="s1">cacheHandler: CacheHandlerCompat</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">// This should never be called before initializeCacheHandlers.</span><span class="s3">\n  </span><span class="s1">if (!reference[handlersMapSymbol] || !reference[handlersSetSymbol]) {</span><span class="s3">\n    </span><span class="s1">throw new Error('Cache handlers not initialized')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">debug?.('setting cache handler for </span><span class="s3">\&quot;</span><span class="s1">%s</span><span class="s3">\&quot;</span><span class="s1">', kind)</span><span class="s3">\n  </span><span class="s1">reference[handlersMapSymbol].set(kind, cacheHandler)</span><span class="s3">\n  </span><span class="s1">reference[handlersSetSymbol].add(cacheHandler)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Interop between </span><span class="s3">\&quot;</span><span class="s1">export default</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">module.exports</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function interopDefault(mod: any) {</span><span class="s3">\n  </span><span class="s1">return mod.default || mod</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { IncomingMessage, ServerResponse } from 'node:http'</span><span class="s3">\n</span><span class="s1">import type { NextConfigComplete } from '../../config-shared'</span><span class="s3">\n</span><span class="s1">import type { UrlWithParsedQuery } from 'node:url'</span><span class="s3">\n\n</span><span class="s1">export type RevalidateFn = (config: {</span><span class="s3">\n  </span><span class="s1">urlPath: string</span><span class="s3">\n  </span><span class="s1">revalidateHeaders: { [key: string]: string | string[] }</span><span class="s3">\n  </span><span class="s1">opts: { unstable_onlyGenerated?: boolean }</span><span class="s3">\n</span><span class="s1">}) =&gt; Promise&lt;void&gt;</span><span class="s3">\n\n</span><span class="s1">// The RouterServerContext contains instance specific</span><span class="s3">\n</span><span class="s1">// information that isn't available/relevant when</span><span class="s3">\n</span><span class="s1">// deployed in serverless environments, the key is</span><span class="s3">\n</span><span class="s1">// the relative project dir this allows separate contexts</span><span class="s3">\n</span><span class="s1">// when running multiple next instances in same process</span><span class="s3">\n</span><span class="s1">export type RouterServerContext = Record&lt;</span><span class="s3">\n  </span><span class="s1">string,</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">// hostname the server is started with</span><span class="s3">\n    </span><span class="s1">hostname?: string</span><span class="s3">\n    </span><span class="s1">// revalidate function to bypass going through network</span><span class="s3">\n    </span><span class="s1">// to invoke revalidate request (uses mocked req/res)</span><span class="s3">\n    </span><span class="s1">revalidate?: RevalidateFn</span><span class="s3">\n    </span><span class="s1">// function to render the 404 page</span><span class="s3">\n    </span><span class="s1">render404?: (</span><span class="s3">\n      </span><span class="s1">req: IncomingMessage,</span><span class="s3">\n      </span><span class="s1">res: ServerResponse,</span><span class="s3">\n      </span><span class="s1">parsedUrl?: UrlWithParsedQuery,</span><span class="s3">\n      </span><span class="s1">setHeaders?: boolean</span><span class="s3">\n    </span><span class="s1">) =&gt; Promise&lt;void&gt;</span><span class="s3">\n    </span><span class="s1">// current loaded public runtime config</span><span class="s3">\n    </span><span class="s1">publicRuntimeConfig?: NextConfigComplete['publicRuntimeConfig']</span><span class="s3">\n    </span><span class="s1">// exposing nextConfig for dev mode specifically</span><span class="s3">\n    </span><span class="s1">nextConfig?: NextConfigComplete</span><span class="s3">\n    </span><span class="s1">// whether running in custom server mode</span><span class="s3">\n    </span><span class="s1">isCustomServer?: boolean</span><span class="s3">\n    </span><span class="s1">// whether test proxy is enabled</span><span class="s3">\n    </span><span class="s1">experimentalTestProxy?: boolean</span><span class="s3">\n    </span><span class="s1">// allow dev server to log with original stack</span><span class="s3">\n    </span><span class="s1">logErrorWithOriginalStack?: (err: unknown, type: string) =&gt; void</span><span class="s3">\n    </span><span class="s1">// allow setting ISR status in dev</span><span class="s3">\n    </span><span class="s1">setIsrStatus?: (key: string, value: boolean | null) =&gt; void</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&gt;</span><span class="s3">\n\n</span><span class="s1">export const RouterServerContextSymbol = Symbol.for(</span><span class="s3">\n  </span><span class="s1">'@next/router-server-methods'</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n\n</span><span class="s1">export const routerServerGlobal = globalThis as typeof globalThis &amp; {</span><span class="s3">\n  </span><span class="s1">[RouterServerContextSymbol]?: RouterServerContext</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { IncomingMessage, ServerResponse } from 'node:http'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">InstrumentationOnRequestError,</span><span class="s3">\n  </span><span class="s1">RequestErrorContext,</span><span class="s3">\n</span><span class="s1">} from '../instrumentation/types'</span><span class="s3">\n</span><span class="s1">import type { ParsedUrlQuery } from 'node:querystring'</span><span class="s3">\n</span><span class="s1">import type { UrlWithParsedQuery } from 'node:url'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">PrerenderManifest,</span><span class="s3">\n  </span><span class="s1">RequiredServerFilesManifest,</span><span class="s3">\n</span><span class="s1">} from '../../build'</span><span class="s3">\n</span><span class="s1">import type { DevRoutesManifest } from '../lib/router-utils/setup-dev-bundler'</span><span class="s3">\n</span><span class="s1">import type { RouteDefinition } from '../route-definitions/route-definition'</span><span class="s3">\n</span><span class="s1">import type { DeepReadonly } from '../../shared/lib/deep-readonly'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">BUILD_ID_FILE,</span><span class="s3">\n  </span><span class="s1">BUILD_MANIFEST,</span><span class="s3">\n  </span><span class="s1">CLIENT_REFERENCE_MANIFEST,</span><span class="s3">\n  </span><span class="s1">DYNAMIC_CSS_MANIFEST,</span><span class="s3">\n  </span><span class="s1">NEXT_FONT_MANIFEST,</span><span class="s3">\n  </span><span class="s1">PRERENDER_MANIFEST,</span><span class="s3">\n  </span><span class="s1">REACT_LOADABLE_MANIFEST,</span><span class="s3">\n  </span><span class="s1">ROUTES_MANIFEST,</span><span class="s3">\n  </span><span class="s1">SERVER_FILES_MANIFEST,</span><span class="s3">\n  </span><span class="s1">SERVER_REFERENCE_MANIFEST,</span><span class="s3">\n  </span><span class="s1">SUBRESOURCE_INTEGRITY_MANIFEST,</span><span class="s3">\n</span><span class="s1">} from '../../shared/lib/constants'</span><span class="s3">\n</span><span class="s1">import { parseReqUrl } from '../../lib/url'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">normalizeLocalePath,</span><span class="s3">\n  </span><span class="s1">type PathLocale,</span><span class="s3">\n</span><span class="s1">} from '../../shared/lib/i18n/normalize-locale-path'</span><span class="s3">\n</span><span class="s1">import { isDynamicRoute } from '../../shared/lib/router/utils'</span><span class="s3">\n</span><span class="s1">import { removePathPrefix } from '../../shared/lib/router/utils/remove-path-prefix'</span><span class="s3">\n</span><span class="s1">import { getServerUtils } from '../server-utils'</span><span class="s3">\n</span><span class="s1">import { detectDomainLocale } from '../../shared/lib/i18n/detect-domain-locale'</span><span class="s3">\n</span><span class="s1">import { getHostname } from '../../shared/lib/get-hostname'</span><span class="s3">\n</span><span class="s1">import { checkIsOnDemandRevalidate } from '../api-utils'</span><span class="s3">\n</span><span class="s1">import type { PreviewData } from '../../types'</span><span class="s3">\n</span><span class="s1">import type { BuildManifest } from '../get-page-files'</span><span class="s3">\n</span><span class="s1">import type { ReactLoadableManifest } from '../load-components'</span><span class="s3">\n</span><span class="s1">import type { NextFontManifest } from '../../build/webpack/plugins/next-font-manifest-plugin'</span><span class="s3">\n</span><span class="s1">import { normalizeDataPath } from '../../shared/lib/page-path/normalize-data-path'</span><span class="s3">\n</span><span class="s1">import { pathHasPrefix } from '../../shared/lib/router/utils/path-has-prefix'</span><span class="s3">\n</span><span class="s1">import { addRequestMeta, getRequestMeta } from '../request-meta'</span><span class="s3">\n</span><span class="s1">import { normalizePagePath } from '../../shared/lib/page-path/normalize-page-path'</span><span class="s3">\n</span><span class="s1">import { isStaticMetadataRoute } from '../../lib/metadata/is-metadata-route'</span><span class="s3">\n</span><span class="s1">import { IncrementalCache } from '../lib/incremental-cache'</span><span class="s3">\n</span><span class="s1">import { initializeCacheHandlers, setCacheHandler } from '../use-cache/handlers'</span><span class="s3">\n</span><span class="s1">import { interopDefault } from '../app-render/interop-default'</span><span class="s3">\n</span><span class="s1">import type { RouteKind } from '../route-kind'</span><span class="s3">\n</span><span class="s1">import type { BaseNextRequest } from '../base-http'</span><span class="s3">\n</span><span class="s1">import type { I18NConfig, NextConfigComplete } from '../config-shared'</span><span class="s3">\n</span><span class="s1">import ResponseCache, { type ResponseGenerator } from '../response-cache'</span><span class="s3">\n</span><span class="s1">import { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">RouterServerContextSymbol,</span><span class="s3">\n  </span><span class="s1">routerServerGlobal,</span><span class="s3">\n  </span><span class="s1">type RouterServerContext,</span><span class="s3">\n</span><span class="s1">} from '../lib/router-utils/router-server-context'</span><span class="s3">\n</span><span class="s1">import { decodePathParams } from '../lib/router-utils/decode-path-params'</span><span class="s3">\n</span><span class="s1">import { removeTrailingSlash } from '../../shared/lib/router/utils/remove-trailing-slash'</span><span class="s3">\n</span><span class="s1">import { isInterceptionRouteRewrite } from '../../lib/generate-interception-routes-rewrites'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* RouteModuleOptions is the options that are passed to the route module, other</span><span class="s3">\n </span><span class="s1">* route modules should extend this class to add specific options for their</span><span class="s3">\n </span><span class="s1">* route.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export interface RouteModuleOptions&lt;</span><span class="s3">\n  </span><span class="s1">D extends RouteDefinition = RouteDefinition,</span><span class="s3">\n  </span><span class="s1">U = unknown,</span><span class="s3">\n</span><span class="s1">&gt; {</span><span class="s3">\n  </span><span class="s1">readonly definition: Readonly&lt;D&gt;</span><span class="s3">\n  </span><span class="s1">readonly userland: Readonly&lt;U&gt;</span><span class="s3">\n  </span><span class="s1">readonly distDir: string</span><span class="s3">\n  </span><span class="s1">readonly relativeProjectDir: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* RouteHandlerContext is the base context for a route handler.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export interface RouteModuleHandleContext {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Any matched parameters for the request. This is only defined for dynamic</span><span class="s3">\n   </span><span class="s1">* routes.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">params: Record&lt;string, string | string[] | undefined&gt; | undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const dynamicImportEsmDefault = (id: string) =&gt;</span><span class="s3">\n  </span><span class="s1">import(/* webpackIgnore: true */ /* turbopackIgnore: true */ id).then(</span><span class="s3">\n    </span><span class="s1">(mod) =&gt; mod.default || mod</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* RouteModule is the base class for all route modules. This class should be</span><span class="s3">\n </span><span class="s1">* extended by all route modules.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export abstract class RouteModule&lt;</span><span class="s3">\n  </span><span class="s1">D extends RouteDefinition = RouteDefinition,</span><span class="s3">\n  </span><span class="s1">U = unknown,</span><span class="s3">\n</span><span class="s1">&gt; {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The userland module. This is the module that is exported from the user's</span><span class="s3">\n   </span><span class="s1">* code. This is marked as readonly to ensure that the module is not mutated</span><span class="s3">\n   </span><span class="s1">* because the module (when compiled) only provides getters.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public readonly userland: Readonly&lt;U&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The definition of the route.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public readonly definition: Readonly&lt;D&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The shared modules that are exposed and required for the route module.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public static readonly sharedModules: any</span><span class="s3">\n\n  </span><span class="s1">public isDev: boolean</span><span class="s3">\n  </span><span class="s1">public distDir: string</span><span class="s3">\n  </span><span class="s1">public isAppRouter?: boolean</span><span class="s3">\n  </span><span class="s1">public relativeProjectDir: string</span><span class="s3">\n  </span><span class="s1">public incrementCache?: IncrementalCache</span><span class="s3">\n  </span><span class="s1">public responseCache?: ResponseCache</span><span class="s3">\n\n  </span><span class="s1">constructor({</span><span class="s3">\n    </span><span class="s1">userland,</span><span class="s3">\n    </span><span class="s1">definition,</span><span class="s3">\n    </span><span class="s1">distDir,</span><span class="s3">\n    </span><span class="s1">relativeProjectDir,</span><span class="s3">\n  </span><span class="s1">}: RouteModuleOptions&lt;D, U&gt;) {</span><span class="s3">\n    </span><span class="s1">this.userland = userland</span><span class="s3">\n    </span><span class="s1">this.definition = definition</span><span class="s3">\n    </span><span class="s1">this.isDev = process.env.NODE_ENV === 'development'</span><span class="s3">\n    </span><span class="s1">this.distDir = distDir</span><span class="s3">\n    </span><span class="s1">this.relativeProjectDir = relativeProjectDir</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async instrumentationOnRequestError(</span><span class="s3">\n    </span><span class="s1">req: IncomingMessage | BaseNextRequest,</span><span class="s3">\n    </span><span class="s1">...args: Parameters&lt;InstrumentationOnRequestError&gt;</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (process.env.NEXT_RUNTIME === 'edge') {</span><span class="s3">\n      </span><span class="s1">const { getEdgeInstrumentationModule } = await import('../web/globals')</span><span class="s3">\n      </span><span class="s1">const instrumentation = await getEdgeInstrumentationModule()</span><span class="s3">\n\n      </span><span class="s1">if (instrumentation) {</span><span class="s3">\n        </span><span class="s1">await instrumentation.onRequestError?.(...args)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">const { join } = require('node:path') as typeof import('node:path')</span><span class="s3">\n      </span><span class="s1">const absoluteProjectDir = join(</span><span class="s3">\n        </span><span class="s1">process.cwd(),</span><span class="s3">\n        </span><span class="s1">getRequestMeta(req, 'relativeProjectDir') || this.relativeProjectDir</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">const { instrumentationOnRequestError } = await import(</span><span class="s3">\n        </span><span class="s1">'../lib/router-utils/instrumentation-globals.external.js'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">return instrumentationOnRequestError(</span><span class="s3">\n        </span><span class="s1">absoluteProjectDir,</span><span class="s3">\n        </span><span class="s1">this.distDir,</span><span class="s3">\n        </span><span class="s1">...args</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">private loadManifests(</span><span class="s3">\n    </span><span class="s1">srcPage: string,</span><span class="s3">\n    </span><span class="s1">projectDir?: string</span><span class="s3">\n  </span><span class="s1">): {</span><span class="s3">\n    </span><span class="s1">buildId: string</span><span class="s3">\n    </span><span class="s1">buildManifest: BuildManifest</span><span class="s3">\n    </span><span class="s1">fallbackBuildManifest: BuildManifest</span><span class="s3">\n    </span><span class="s1">routesManifest: DeepReadonly&lt;DevRoutesManifest&gt;</span><span class="s3">\n    </span><span class="s1">nextFontManifest: DeepReadonly&lt;NextFontManifest&gt;</span><span class="s3">\n    </span><span class="s1">prerenderManifest: DeepReadonly&lt;PrerenderManifest&gt;</span><span class="s3">\n    </span><span class="s1">serverFilesManifest: RequiredServerFilesManifest</span><span class="s3">\n    </span><span class="s1">reactLoadableManifest: DeepReadonly&lt;ReactLoadableManifest&gt;</span><span class="s3">\n    </span><span class="s1">subresourceIntegrityManifest: any</span><span class="s3">\n    </span><span class="s1">clientReferenceManifest: any</span><span class="s3">\n    </span><span class="s1">serverActionsManifest: any</span><span class="s3">\n    </span><span class="s1">dynamicCssManifest: any</span><span class="s3">\n    </span><span class="s1">interceptionRoutePatterns: RegExp[]</span><span class="s3">\n  </span><span class="s1">} {</span><span class="s3">\n    </span><span class="s1">if (process.env.NEXT_RUNTIME === 'edge') {</span><span class="s3">\n      </span><span class="s1">const { getEdgePreviewProps } =</span><span class="s3">\n        </span><span class="s1">require('../web/get-edge-preview-props') as typeof import('../web/get-edge-preview-props')</span><span class="s3">\n\n      </span><span class="s1">const maybeJSONParse = (str?: string) =&gt;</span><span class="s3">\n        </span><span class="s1">str ? JSON.parse(str) : undefined</span><span class="s3">\n\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">buildId: process.env.__NEXT_BUILD_ID || '',</span><span class="s3">\n        </span><span class="s1">buildManifest: self.__BUILD_MANIFEST as any,</span><span class="s3">\n        </span><span class="s1">fallbackBuildManifest: {} as any,</span><span class="s3">\n        </span><span class="s1">reactLoadableManifest: maybeJSONParse(self.__REACT_LOADABLE_MANIFEST),</span><span class="s3">\n        </span><span class="s1">nextFontManifest: maybeJSONParse(self.__NEXT_FONT_MANIFEST),</span><span class="s3">\n        </span><span class="s1">prerenderManifest: {</span><span class="s3">\n          </span><span class="s1">routes: {},</span><span class="s3">\n          </span><span class="s1">dynamicRoutes: {},</span><span class="s3">\n          </span><span class="s1">notFoundRoutes: [],</span><span class="s3">\n          </span><span class="s1">version: 4,</span><span class="s3">\n          </span><span class="s1">preview: getEdgePreviewProps(),</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">routesManifest: {</span><span class="s3">\n          </span><span class="s1">version: 4,</span><span class="s3">\n          </span><span class="s1">caseSensitive: Boolean(process.env.__NEXT_CASE_SENSITIVE_ROUTES),</span><span class="s3">\n          </span><span class="s1">basePath: process.env.__NEXT_BASE_PATH || '',</span><span class="s3">\n          </span><span class="s1">rewrites: (process.env.__NEXT_REWRITES as any) || {</span><span class="s3">\n            </span><span class="s1">beforeFiles: [],</span><span class="s3">\n            </span><span class="s1">afterFiles: [],</span><span class="s3">\n            </span><span class="s1">fallback: [],</span><span class="s3">\n          </span><span class="s1">},</span><span class="s3">\n          </span><span class="s1">redirects: [],</span><span class="s3">\n          </span><span class="s1">headers: [],</span><span class="s3">\n          </span><span class="s1">i18n:</span><span class="s3">\n            </span><span class="s1">(process.env.__NEXT_I18N_CONFIG as any as I18NConfig) || undefined,</span><span class="s3">\n          </span><span class="s1">skipMiddlewareUrlNormalize: Boolean(</span><span class="s3">\n            </span><span class="s1">process.env.__NEXT_NO_MIDDLEWARE_URL_NORMALIZE</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">serverFilesManifest: {</span><span class="s3">\n          </span><span class="s1">config: (globalThis as any).nextConfig || {},</span><span class="s3">\n        </span><span class="s1">} as any,</span><span class="s3">\n        </span><span class="s1">clientReferenceManifest: self.__RSC_MANIFEST?.[srcPage],</span><span class="s3">\n        </span><span class="s1">serverActionsManifest: maybeJSONParse(self.__RSC_SERVER_MANIFEST),</span><span class="s3">\n        </span><span class="s1">subresourceIntegrityManifest: maybeJSONParse(</span><span class="s3">\n          </span><span class="s1">self.__SUBRESOURCE_INTEGRITY_MANIFEST</span><span class="s3">\n        </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">dynamicCssManifest: maybeJSONParse(self.__DYNAMIC_CSS_MANIFEST),</span><span class="s3">\n        </span><span class="s1">interceptionRoutePatterns: (</span><span class="s3">\n          </span><span class="s1">maybeJSONParse(self.__INTERCEPTION_ROUTE_REWRITE_MANIFEST) ?? []</span><span class="s3">\n        </span><span class="s1">).map((rewrite: any) =&gt; new RegExp(rewrite.regex)),</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">if (!projectDir) {</span><span class="s3">\n        </span><span class="s1">throw new Error('Invariant: projectDir is required for node runtime')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const { loadManifestFromRelativePath } =</span><span class="s3">\n        </span><span class="s1">require('../load-manifest.external') as typeof import('../load-manifest.external')</span><span class="s3">\n      </span><span class="s1">const normalizedPagePath = normalizePagePath(srcPage)</span><span class="s3">\n\n      </span><span class="s1">const [</span><span class="s3">\n        </span><span class="s1">routesManifest,</span><span class="s3">\n        </span><span class="s1">prerenderManifest,</span><span class="s3">\n        </span><span class="s1">buildManifest,</span><span class="s3">\n        </span><span class="s1">fallbackBuildManifest,</span><span class="s3">\n        </span><span class="s1">reactLoadableManifest,</span><span class="s3">\n        </span><span class="s1">nextFontManifest,</span><span class="s3">\n        </span><span class="s1">clientReferenceManifest,</span><span class="s3">\n        </span><span class="s1">serverActionsManifest,</span><span class="s3">\n        </span><span class="s1">subresourceIntegrityManifest,</span><span class="s3">\n        </span><span class="s1">serverFilesManifest,</span><span class="s3">\n        </span><span class="s1">buildId,</span><span class="s3">\n        </span><span class="s1">dynamicCssManifest,</span><span class="s3">\n      </span><span class="s1">] = [</span><span class="s3">\n        </span><span class="s1">loadManifestFromRelativePath&lt;DevRoutesManifest&gt;({</span><span class="s3">\n          </span><span class="s1">projectDir,</span><span class="s3">\n          </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n          </span><span class="s1">manifest: ROUTES_MANIFEST,</span><span class="s3">\n          </span><span class="s1">shouldCache: !this.isDev,</span><span class="s3">\n        </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">loadManifestFromRelativePath&lt;PrerenderManifest&gt;({</span><span class="s3">\n          </span><span class="s1">projectDir,</span><span class="s3">\n          </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n          </span><span class="s1">manifest: PRERENDER_MANIFEST,</span><span class="s3">\n          </span><span class="s1">shouldCache: !this.isDev,</span><span class="s3">\n        </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">loadManifestFromRelativePath&lt;BuildManifest&gt;({</span><span class="s3">\n          </span><span class="s1">projectDir,</span><span class="s3">\n          </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n          </span><span class="s1">manifest: BUILD_MANIFEST,</span><span class="s3">\n          </span><span class="s1">shouldCache: !this.isDev,</span><span class="s3">\n        </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">srcPage === '/_error'</span><span class="s3">\n          </span><span class="s1">? loadManifestFromRelativePath&lt;BuildManifest&gt;({</span><span class="s3">\n              </span><span class="s1">projectDir,</span><span class="s3">\n              </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n              </span><span class="s1">manifest: `fallback-${BUILD_MANIFEST}`,</span><span class="s3">\n              </span><span class="s1">shouldCache: !this.isDev,</span><span class="s3">\n              </span><span class="s1">handleMissing: true,</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n          </span><span class="s1">: ({} as BuildManifest),</span><span class="s3">\n        </span><span class="s1">loadManifestFromRelativePath&lt;ReactLoadableManifest&gt;({</span><span class="s3">\n          </span><span class="s1">projectDir,</span><span class="s3">\n          </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n          </span><span class="s1">manifest: process.env.TURBOPACK</span><span class="s3">\n            </span><span class="s1">? `server/${this.isAppRouter ? 'app' : 'pages'}${normalizedPagePath}/${REACT_LOADABLE_MANIFEST}`</span><span class="s3">\n            </span><span class="s1">: REACT_LOADABLE_MANIFEST,</span><span class="s3">\n          </span><span class="s1">handleMissing: true,</span><span class="s3">\n          </span><span class="s1">shouldCache: !this.isDev,</span><span class="s3">\n        </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">loadManifestFromRelativePath&lt;NextFontManifest&gt;({</span><span class="s3">\n          </span><span class="s1">projectDir,</span><span class="s3">\n          </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n          </span><span class="s1">manifest: `server/${NEXT_FONT_MANIFEST}.json`,</span><span class="s3">\n          </span><span class="s1">shouldCache: !this.isDev,</span><span class="s3">\n        </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">this.isAppRouter &amp;&amp; !isStaticMetadataRoute(srcPage)</span><span class="s3">\n          </span><span class="s1">? loadManifestFromRelativePath({</span><span class="s3">\n              </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n              </span><span class="s1">projectDir,</span><span class="s3">\n              </span><span class="s1">useEval: true,</span><span class="s3">\n              </span><span class="s1">handleMissing: true,</span><span class="s3">\n              </span><span class="s1">manifest: `server/app${srcPage.replace(/%5F/g, '_') + '_' + CLIENT_REFERENCE_MANIFEST}.js`,</span><span class="s3">\n              </span><span class="s1">shouldCache: !this.isDev,</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n          </span><span class="s1">: undefined,</span><span class="s3">\n        </span><span class="s1">this.isAppRouter</span><span class="s3">\n          </span><span class="s1">? loadManifestFromRelativePath&lt;any&gt;({</span><span class="s3">\n              </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n              </span><span class="s1">projectDir,</span><span class="s3">\n              </span><span class="s1">manifest: `server/${SERVER_REFERENCE_MANIFEST}.json`,</span><span class="s3">\n              </span><span class="s1">handleMissing: true,</span><span class="s3">\n              </span><span class="s1">shouldCache: !this.isDev,</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n          </span><span class="s1">: {},</span><span class="s3">\n        </span><span class="s1">loadManifestFromRelativePath&lt;Record&lt;string, string&gt;&gt;({</span><span class="s3">\n          </span><span class="s1">projectDir,</span><span class="s3">\n          </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n          </span><span class="s1">manifest: `server/${SUBRESOURCE_INTEGRITY_MANIFEST}.json`,</span><span class="s3">\n          </span><span class="s1">handleMissing: true,</span><span class="s3">\n          </span><span class="s1">shouldCache: !this.isDev,</span><span class="s3">\n        </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">this.isDev</span><span class="s3">\n          </span><span class="s1">? ({} as any)</span><span class="s3">\n          </span><span class="s1">: loadManifestFromRelativePath&lt;RequiredServerFilesManifest&gt;({</span><span class="s3">\n              </span><span class="s1">projectDir,</span><span class="s3">\n              </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n              </span><span class="s1">manifest: SERVER_FILES_MANIFEST,</span><span class="s3">\n            </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">this.isDev</span><span class="s3">\n          </span><span class="s1">? 'development'</span><span class="s3">\n          </span><span class="s1">: loadManifestFromRelativePath&lt;any&gt;({</span><span class="s3">\n              </span><span class="s1">projectDir,</span><span class="s3">\n              </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n              </span><span class="s1">manifest: BUILD_ID_FILE,</span><span class="s3">\n              </span><span class="s1">skipParse: true,</span><span class="s3">\n            </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">loadManifestFromRelativePath&lt;any&gt;({</span><span class="s3">\n          </span><span class="s1">projectDir,</span><span class="s3">\n          </span><span class="s1">distDir: this.distDir,</span><span class="s3">\n          </span><span class="s1">manifest: DYNAMIC_CSS_MANIFEST,</span><span class="s3">\n          </span><span class="s1">handleMissing: true,</span><span class="s3">\n        </span><span class="s1">}),</span><span class="s3">\n      </span><span class="s1">]</span><span class="s3">\n\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">buildId,</span><span class="s3">\n        </span><span class="s1">buildManifest,</span><span class="s3">\n        </span><span class="s1">fallbackBuildManifest,</span><span class="s3">\n        </span><span class="s1">routesManifest,</span><span class="s3">\n        </span><span class="s1">nextFontManifest,</span><span class="s3">\n        </span><span class="s1">prerenderManifest,</span><span class="s3">\n        </span><span class="s1">serverFilesManifest,</span><span class="s3">\n        </span><span class="s1">reactLoadableManifest,</span><span class="s3">\n        </span><span class="s1">clientReferenceManifest: (clientReferenceManifest as any)</span><span class="s3">\n          </span><span class="s1">?.__RSC_MANIFEST?.[srcPage.replace(/%5F/g, '_')],</span><span class="s3">\n        </span><span class="s1">serverActionsManifest,</span><span class="s3">\n        </span><span class="s1">subresourceIntegrityManifest,</span><span class="s3">\n        </span><span class="s1">dynamicCssManifest,</span><span class="s3">\n        </span><span class="s1">interceptionRoutePatterns: routesManifest.rewrites.beforeFiles</span><span class="s3">\n          </span><span class="s1">.filter(isInterceptionRouteRewrite)</span><span class="s3">\n          </span><span class="s1">.map((rewrite) =&gt; new RegExp(rewrite.regex)),</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async loadCustomCacheHandlers(</span><span class="s3">\n    </span><span class="s1">req: IncomingMessage | BaseNextRequest,</span><span class="s3">\n    </span><span class="s1">nextConfig: NextConfigComplete</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (process.env.NEXT_RUNTIME !== 'edge') {</span><span class="s3">\n      </span><span class="s1">const { cacheHandlers } = nextConfig.experimental</span><span class="s3">\n      </span><span class="s1">if (!cacheHandlers) return</span><span class="s3">\n\n      </span><span class="s1">// If we've already initialized the cache handlers interface, don't do it</span><span class="s3">\n      </span><span class="s1">// again.</span><span class="s3">\n      </span><span class="s1">if (!initializeCacheHandlers()) return</span><span class="s3">\n\n      </span><span class="s1">for (const [kind, handler] of Object.entries(cacheHandlers)) {</span><span class="s3">\n        </span><span class="s1">if (!handler) continue</span><span class="s3">\n\n        </span><span class="s1">const { formatDynamicImportPath } =</span><span class="s3">\n          </span><span class="s1">require('../../lib/format-dynamic-import-path') as typeof import('../../lib/format-dynamic-import-path')</span><span class="s3">\n\n        </span><span class="s1">const { join } = require('node:path') as typeof import('node:path')</span><span class="s3">\n        </span><span class="s1">const absoluteProjectDir = join(</span><span class="s3">\n          </span><span class="s1">process.cwd(),</span><span class="s3">\n          </span><span class="s1">getRequestMeta(req, 'relativeProjectDir') || this.relativeProjectDir</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">setCacheHandler(</span><span class="s3">\n          </span><span class="s1">kind,</span><span class="s3">\n          </span><span class="s1">interopDefault(</span><span class="s3">\n            </span><span class="s1">await dynamicImportEsmDefault(</span><span class="s3">\n              </span><span class="s1">formatDynamicImportPath(</span><span class="s3">\n                </span><span class="s1">`${absoluteProjectDir}/${this.distDir}`,</span><span class="s3">\n                </span><span class="s1">handler</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async getIncrementalCache(</span><span class="s3">\n    </span><span class="s1">req: IncomingMessage | BaseNextRequest,</span><span class="s3">\n    </span><span class="s1">nextConfig: NextConfigComplete,</span><span class="s3">\n    </span><span class="s1">prerenderManifest: DeepReadonly&lt;PrerenderManifest&gt;</span><span class="s3">\n  </span><span class="s1">): Promise&lt;IncrementalCache&gt; {</span><span class="s3">\n    </span><span class="s1">if (process.env.NEXT_RUNTIME === 'edge') {</span><span class="s3">\n      </span><span class="s1">return (globalThis as any).__incrementalCache</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">let CacheHandler: any</span><span class="s3">\n      </span><span class="s1">const { cacheHandler } = nextConfig</span><span class="s3">\n\n      </span><span class="s1">if (cacheHandler) {</span><span class="s3">\n        </span><span class="s1">const { formatDynamicImportPath } =</span><span class="s3">\n          </span><span class="s1">require('../../lib/format-dynamic-import-path') as typeof import('../../lib/format-dynamic-import-path')</span><span class="s3">\n\n        </span><span class="s1">CacheHandler = interopDefault(</span><span class="s3">\n          </span><span class="s1">await dynamicImportEsmDefault(</span><span class="s3">\n            </span><span class="s1">formatDynamicImportPath(this.distDir, cacheHandler)</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const { join } = require('node:path') as typeof import('node:path')</span><span class="s3">\n      </span><span class="s1">const projectDir = join(</span><span class="s3">\n        </span><span class="s1">process.cwd(),</span><span class="s3">\n        </span><span class="s1">getRequestMeta(req, 'relativeProjectDir') || this.relativeProjectDir</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">await this.loadCustomCacheHandlers(req, nextConfig)</span><span class="s3">\n\n      </span><span class="s1">// incremental-cache is request specific</span><span class="s3">\n      </span><span class="s1">// although can have shared caches in module scope</span><span class="s3">\n      </span><span class="s1">// per-cache handler</span><span class="s3">\n      </span><span class="s1">return new IncrementalCache({</span><span class="s3">\n        </span><span class="s1">fs: (</span><span class="s3">\n          </span><span class="s1">require('../lib/node-fs-methods') as typeof import('../lib/node-fs-methods')</span><span class="s3">\n        </span><span class="s1">).nodeFs,</span><span class="s3">\n        </span><span class="s1">dev: this.isDev,</span><span class="s3">\n        </span><span class="s1">requestHeaders: req.headers,</span><span class="s3">\n        </span><span class="s1">allowedRevalidateHeaderKeys:</span><span class="s3">\n          </span><span class="s1">nextConfig.experimental.allowedRevalidateHeaderKeys,</span><span class="s3">\n        </span><span class="s1">minimalMode: getRequestMeta(req, 'minimalMode'),</span><span class="s3">\n        </span><span class="s1">serverDistDir: `${projectDir}/${this.distDir}/server`,</span><span class="s3">\n        </span><span class="s1">fetchCacheKeyPrefix: nextConfig.experimental.fetchCacheKeyPrefix,</span><span class="s3">\n        </span><span class="s1">maxMemoryCacheSize: nextConfig.cacheMaxMemorySize,</span><span class="s3">\n        </span><span class="s1">flushToDisk: nextConfig.experimental.isrFlushToDisk,</span><span class="s3">\n        </span><span class="s1">getPrerenderManifest: () =&gt; prerenderManifest,</span><span class="s3">\n        </span><span class="s1">CurCacheHandler: CacheHandler,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async onRequestError(</span><span class="s3">\n    </span><span class="s1">req: IncomingMessage | BaseNextRequest,</span><span class="s3">\n    </span><span class="s1">err: unknown,</span><span class="s3">\n    </span><span class="s1">errorContext: RequestErrorContext,</span><span class="s3">\n    </span><span class="s1">routerServerContext?: RouterServerContext[string]</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (routerServerContext?.logErrorWithOriginalStack) {</span><span class="s3">\n      </span><span class="s1">routerServerContext.logErrorWithOriginalStack(err, 'app-dir')</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">console.error(err)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">await this.instrumentationOnRequestError(</span><span class="s3">\n      </span><span class="s1">req,</span><span class="s3">\n      </span><span class="s1">err,</span><span class="s3">\n      </span><span class="s1">{</span><span class="s3">\n        </span><span class="s1">path: req.url || '/',</span><span class="s3">\n        </span><span class="s1">headers: req.headers,</span><span class="s3">\n        </span><span class="s1">method: req.method || 'GET',</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">errorContext</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async prepare(</span><span class="s3">\n    </span><span class="s1">req: IncomingMessage | BaseNextRequest,</span><span class="s3">\n    </span><span class="s1">res: ServerResponse | null,</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">srcPage,</span><span class="s3">\n      </span><span class="s1">multiZoneDraftMode,</span><span class="s3">\n    </span><span class="s1">}: {</span><span class="s3">\n      </span><span class="s1">srcPage: string</span><span class="s3">\n      </span><span class="s1">multiZoneDraftMode?: boolean</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">): Promise&lt;</span><span class="s3">\n    </span><span class="s1">| {</span><span class="s3">\n        </span><span class="s1">buildId: string</span><span class="s3">\n        </span><span class="s1">locale?: string</span><span class="s3">\n        </span><span class="s1">locales?: readonly string[]</span><span class="s3">\n        </span><span class="s1">defaultLocale?: string</span><span class="s3">\n        </span><span class="s1">query: ParsedUrlQuery</span><span class="s3">\n        </span><span class="s1">originalQuery: ParsedUrlQuery</span><span class="s3">\n        </span><span class="s1">originalPathname: string</span><span class="s3">\n        </span><span class="s1">params?: ParsedUrlQuery</span><span class="s3">\n        </span><span class="s1">parsedUrl: UrlWithParsedQuery</span><span class="s3">\n        </span><span class="s1">previewData: PreviewData</span><span class="s3">\n        </span><span class="s1">pageIsDynamic: boolean</span><span class="s3">\n        </span><span class="s1">isDraftMode: boolean</span><span class="s3">\n        </span><span class="s1">resolvedPathname: string</span><span class="s3">\n        </span><span class="s1">isNextDataRequest: boolean</span><span class="s3">\n        </span><span class="s1">buildManifest: DeepReadonly&lt;BuildManifest&gt;</span><span class="s3">\n        </span><span class="s1">fallbackBuildManifest: DeepReadonly&lt;BuildManifest&gt;</span><span class="s3">\n        </span><span class="s1">nextFontManifest: DeepReadonly&lt;NextFontManifest&gt;</span><span class="s3">\n        </span><span class="s1">serverFilesManifest: DeepReadonly&lt;RequiredServerFilesManifest&gt;</span><span class="s3">\n        </span><span class="s1">reactLoadableManifest: DeepReadonly&lt;ReactLoadableManifest&gt;</span><span class="s3">\n        </span><span class="s1">routesManifest: DeepReadonly&lt;DevRoutesManifest&gt;</span><span class="s3">\n        </span><span class="s1">prerenderManifest: DeepReadonly&lt;PrerenderManifest&gt;</span><span class="s3">\n        </span><span class="s1">// we can't pull in the client reference type or it causes issues with</span><span class="s3">\n        </span><span class="s1">// our pre-compiled types</span><span class="s3">\n        </span><span class="s1">clientReferenceManifest?: any</span><span class="s3">\n        </span><span class="s1">serverActionsManifest?: any</span><span class="s3">\n        </span><span class="s1">dynamicCssManifest?: any</span><span class="s3">\n        </span><span class="s1">subresourceIntegrityManifest?: DeepReadonly&lt;Record&lt;string, string&gt;&gt;</span><span class="s3">\n        </span><span class="s1">isOnDemandRevalidate: boolean</span><span class="s3">\n        </span><span class="s1">revalidateOnlyGenerated: boolean</span><span class="s3">\n        </span><span class="s1">nextConfig: NextConfigComplete</span><span class="s3">\n        </span><span class="s1">routerServerContext?: RouterServerContext[string]</span><span class="s3">\n        </span><span class="s1">interceptionRoutePatterns?: any</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">| undefined</span><span class="s3">\n  </span><span class="s1">&gt; {</span><span class="s3">\n    </span><span class="s1">let absoluteProjectDir: string | undefined</span><span class="s3">\n\n    </span><span class="s1">// edge runtime handles loading instrumentation at the edge adapter level</span><span class="s3">\n    </span><span class="s1">if (process.env.NEXT_RUNTIME !== 'edge') {</span><span class="s3">\n      </span><span class="s1">const { join, relative } =</span><span class="s3">\n        </span><span class="s1">require('node:path') as typeof import('node:path')</span><span class="s3">\n\n      </span><span class="s1">absoluteProjectDir = join(</span><span class="s3">\n        </span><span class="s1">process.cwd(),</span><span class="s3">\n        </span><span class="s1">getRequestMeta(req, 'relativeProjectDir') || this.relativeProjectDir</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">const absoluteDistDir = getRequestMeta(req, 'distDir')</span><span class="s3">\n\n      </span><span class="s1">if (absoluteDistDir) {</span><span class="s3">\n        </span><span class="s1">this.distDir = relative(absoluteProjectDir, absoluteDistDir)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const { ensureInstrumentationRegistered } = await import(</span><span class="s3">\n        </span><span class="s1">'../lib/router-utils/instrumentation-globals.external.js'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">// ensure instrumentation is registered and pass</span><span class="s3">\n      </span><span class="s1">// onRequestError below</span><span class="s3">\n      </span><span class="s1">ensureInstrumentationRegistered(absoluteProjectDir, this.distDir)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const manifests = await this.loadManifests(srcPage, absoluteProjectDir)</span><span class="s3">\n    </span><span class="s1">const { routesManifest, prerenderManifest, serverFilesManifest } = manifests</span><span class="s3">\n\n    </span><span class="s1">const { basePath, i18n, rewrites } = routesManifest</span><span class="s3">\n\n    </span><span class="s1">if (basePath) {</span><span class="s3">\n      </span><span class="s1">req.url = removePathPrefix(req.url || '/', basePath)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const parsedUrl = parseReqUrl(req.url || '/')</span><span class="s3">\n    </span><span class="s1">// if we couldn't parse the URL we can't continue</span><span class="s3">\n    </span><span class="s1">if (!parsedUrl) {</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let isNextDataRequest = false</span><span class="s3">\n\n    </span><span class="s1">if (pathHasPrefix(parsedUrl.pathname || '/', '/_next/data')) {</span><span class="s3">\n      </span><span class="s1">isNextDataRequest = true</span><span class="s3">\n      </span><span class="s1">parsedUrl.pathname = normalizeDataPath(parsedUrl.pathname || '/')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let originalPathname = parsedUrl.pathname || '/'</span><span class="s3">\n    </span><span class="s1">const originalQuery = { ...parsedUrl.query }</span><span class="s3">\n    </span><span class="s1">const pageIsDynamic = isDynamicRoute(srcPage)</span><span class="s3">\n\n    </span><span class="s1">let localeResult: PathLocale | undefined</span><span class="s3">\n    </span><span class="s1">let detectedLocale: string | undefined</span><span class="s3">\n\n    </span><span class="s1">if (i18n) {</span><span class="s3">\n      </span><span class="s1">localeResult = normalizeLocalePath(</span><span class="s3">\n        </span><span class="s1">parsedUrl.pathname || '/',</span><span class="s3">\n        </span><span class="s1">i18n.locales</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">if (localeResult.detectedLocale) {</span><span class="s3">\n        </span><span class="s1">req.url = `${localeResult.pathname}${parsedUrl.search}`</span><span class="s3">\n        </span><span class="s1">originalPathname = localeResult.pathname</span><span class="s3">\n\n        </span><span class="s1">if (!detectedLocale) {</span><span class="s3">\n          </span><span class="s1">detectedLocale = localeResult.detectedLocale</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const serverUtils = getServerUtils({</span><span class="s3">\n      </span><span class="s1">page: srcPage,</span><span class="s3">\n      </span><span class="s1">i18n,</span><span class="s3">\n      </span><span class="s1">basePath,</span><span class="s3">\n      </span><span class="s1">rewrites,</span><span class="s3">\n      </span><span class="s1">pageIsDynamic,</span><span class="s3">\n      </span><span class="s1">trailingSlash: process.env.__NEXT_TRAILING_SLASH as any as boolean,</span><span class="s3">\n      </span><span class="s1">caseSensitive: Boolean(routesManifest.caseSensitive),</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">const domainLocale = detectDomainLocale(</span><span class="s3">\n      </span><span class="s1">i18n?.domains,</span><span class="s3">\n      </span><span class="s1">getHostname(parsedUrl, req.headers),</span><span class="s3">\n      </span><span class="s1">detectedLocale</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">addRequestMeta(req, 'isLocaleDomain', Boolean(domainLocale))</span><span class="s3">\n\n    </span><span class="s1">const defaultLocale = domainLocale?.defaultLocale || i18n?.defaultLocale</span><span class="s3">\n\n    </span><span class="s1">// Ensure parsedUrl.pathname includes locale before processing</span><span class="s3">\n    </span><span class="s1">// rewrites or they won't match correctly.</span><span class="s3">\n    </span><span class="s1">if (defaultLocale &amp;&amp; !detectedLocale) {</span><span class="s3">\n      </span><span class="s1">parsedUrl.pathname = `/${defaultLocale}${parsedUrl.pathname === '/' ? '' : parsedUrl.pathname}`</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const locale =</span><span class="s3">\n      </span><span class="s1">getRequestMeta(req, 'locale') || detectedLocale || defaultLocale</span><span class="s3">\n\n    </span><span class="s1">const rewriteParamKeys = Object.keys(</span><span class="s3">\n      </span><span class="s1">serverUtils.handleRewrites(req, parsedUrl)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">// after processing rewrites we want to remove locale</span><span class="s3">\n    </span><span class="s1">// from parsedUrl pathname</span><span class="s3">\n    </span><span class="s1">if (i18n) {</span><span class="s3">\n      </span><span class="s1">parsedUrl.pathname = normalizeLocalePath(</span><span class="s3">\n        </span><span class="s1">parsedUrl.pathname || '/',</span><span class="s3">\n        </span><span class="s1">i18n.locales</span><span class="s3">\n      </span><span class="s1">).pathname</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let params: Record&lt;string, undefined | string | string[]&gt; | undefined =</span><span class="s3">\n      </span><span class="s1">getRequestMeta(req, 'params')</span><span class="s3">\n\n    </span><span class="s1">// attempt parsing from pathname</span><span class="s3">\n    </span><span class="s1">if (!params &amp;&amp; serverUtils.dynamicRouteMatcher) {</span><span class="s3">\n      </span><span class="s1">const paramsMatch = serverUtils.dynamicRouteMatcher(</span><span class="s3">\n        </span><span class="s1">normalizeDataPath(localeResult?.pathname || parsedUrl.pathname || '/')</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">const paramsResult = serverUtils.normalizeDynamicRouteParams(</span><span class="s3">\n        </span><span class="s1">paramsMatch || {},</span><span class="s3">\n        </span><span class="s1">true</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">if (paramsResult.hasValidParams) {</span><span class="s3">\n        </span><span class="s1">params = paramsResult.params</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Local </span><span class="s3">\&quot;</span><span class="s1">next start</span><span class="s3">\&quot; </span><span class="s1">expects the routing parsed query values</span><span class="s3">\n    </span><span class="s1">// to not be present in the URL although when deployed proxies</span><span class="s3">\n    </span><span class="s1">// will add query values from resolving the routes to pass to function.</span><span class="s3">\n\n    </span><span class="s1">// TODO: do we want to change expectations for </span><span class="s3">\&quot;</span><span class="s1">next start</span><span class="s3">\&quot;\n    </span><span class="s1">// to include these query values in the URL which affects asPath</span><span class="s3">\n    </span><span class="s1">// but would match deployed behavior, e.g. a rewrite from middleware</span><span class="s3">\n    </span><span class="s1">// that adds a query param would be in asPath as query but locally</span><span class="s3">\n    </span><span class="s1">// it won't be in the asPath but still available in the query object</span><span class="s3">\n    </span><span class="s1">const query = getRequestMeta(req, 'query') || {</span><span class="s3">\n      </span><span class="s1">...parsedUrl.query,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const routeParamKeys = new Set&lt;string&gt;()</span><span class="s3">\n    </span><span class="s1">const combinedParamKeys = []</span><span class="s3">\n\n    </span><span class="s1">// we don't include rewriteParamKeys in the combinedParamKeys</span><span class="s3">\n    </span><span class="s1">// for app router since the searchParams is populated from the</span><span class="s3">\n    </span><span class="s1">// URL so we don't want to strip the rewrite params from the URL</span><span class="s3">\n    </span><span class="s1">// so that searchParams can include them</span><span class="s3">\n    </span><span class="s1">if (!this.isAppRouter) {</span><span class="s3">\n      </span><span class="s1">for (const key of [</span><span class="s3">\n        </span><span class="s1">...rewriteParamKeys,</span><span class="s3">\n        </span><span class="s1">...Object.keys(serverUtils.defaultRouteMatches || {}),</span><span class="s3">\n      </span><span class="s1">]) {</span><span class="s3">\n        </span><span class="s1">// We only want to filter rewrite param keys from the URL</span><span class="s3">\n        </span><span class="s1">// if they are matches from the URL e.g. the key/value matches</span><span class="s3">\n        </span><span class="s1">// before and after applying the rewrites /:path for /hello and</span><span class="s3">\n        </span><span class="s1">// { path: 'hello' } but not for { path: 'another' } and /hello</span><span class="s3">\n        </span><span class="s1">// TODO: we should prefix rewrite param keys the same as we do</span><span class="s3">\n        </span><span class="s1">// for dynamic routes so we can identify them properly</span><span class="s3">\n        </span><span class="s1">const originalValue = Array.isArray(originalQuery[key])</span><span class="s3">\n          </span><span class="s1">? originalQuery[key].join('')</span><span class="s3">\n          </span><span class="s1">: originalQuery[key]</span><span class="s3">\n\n        </span><span class="s1">const queryValue = Array.isArray(query[key])</span><span class="s3">\n          </span><span class="s1">? query[key].join('')</span><span class="s3">\n          </span><span class="s1">: query[key]</span><span class="s3">\n\n        </span><span class="s1">if (!(key in originalQuery) || originalValue === queryValue) {</span><span class="s3">\n          </span><span class="s1">combinedParamKeys.push(key)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">serverUtils.normalizeCdnUrl(req, combinedParamKeys)</span><span class="s3">\n    </span><span class="s1">serverUtils.normalizeQueryParams(query, routeParamKeys)</span><span class="s3">\n    </span><span class="s1">serverUtils.filterInternalQuery(originalQuery, combinedParamKeys)</span><span class="s3">\n\n    </span><span class="s1">if (pageIsDynamic) {</span><span class="s3">\n      </span><span class="s1">const queryResult = serverUtils.normalizeDynamicRouteParams(query, true)</span><span class="s3">\n\n      </span><span class="s1">const paramsResult = serverUtils.normalizeDynamicRouteParams(</span><span class="s3">\n        </span><span class="s1">params || {},</span><span class="s3">\n        </span><span class="s1">true</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">const paramsToInterpolate: ParsedUrlQuery =</span><span class="s3">\n        </span><span class="s1">paramsResult.hasValidParams &amp;&amp; params</span><span class="s3">\n          </span><span class="s1">? params</span><span class="s3">\n          </span><span class="s1">: queryResult.hasValidParams</span><span class="s3">\n            </span><span class="s1">? query</span><span class="s3">\n            </span><span class="s1">: {}</span><span class="s3">\n\n      </span><span class="s1">req.url = serverUtils.interpolateDynamicPath(</span><span class="s3">\n        </span><span class="s1">req.url || '/',</span><span class="s3">\n        </span><span class="s1">paramsToInterpolate</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">parsedUrl.pathname = serverUtils.interpolateDynamicPath(</span><span class="s3">\n        </span><span class="s1">parsedUrl.pathname || '/',</span><span class="s3">\n        </span><span class="s1">paramsToInterpolate</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">originalPathname = serverUtils.interpolateDynamicPath(</span><span class="s3">\n        </span><span class="s1">originalPathname,</span><span class="s3">\n        </span><span class="s1">paramsToInterpolate</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">// try pulling from query if valid</span><span class="s3">\n      </span><span class="s1">if (!params) {</span><span class="s3">\n        </span><span class="s1">if (queryResult.hasValidParams) {</span><span class="s3">\n          </span><span class="s1">params = Object.assign({}, queryResult.params)</span><span class="s3">\n\n          </span><span class="s1">// If we pulled from query remove it so it's</span><span class="s3">\n          </span><span class="s1">// only in params</span><span class="s3">\n          </span><span class="s1">for (const key in serverUtils.defaultRouteMatches) {</span><span class="s3">\n            </span><span class="s1">delete query[key]</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// use final params from URL matching</span><span class="s3">\n          </span><span class="s1">const paramsMatch = serverUtils.dynamicRouteMatcher?.(</span><span class="s3">\n            </span><span class="s1">normalizeDataPath(</span><span class="s3">\n              </span><span class="s1">localeResult?.pathname || parsedUrl.pathname || '/'</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">// we don't normalize these as they are allowed to be</span><span class="s3">\n          </span><span class="s1">// the literal slug matches here e.g. /blog/[slug]</span><span class="s3">\n          </span><span class="s1">// actually being requested</span><span class="s3">\n          </span><span class="s1">if (paramsMatch) {</span><span class="s3">\n            </span><span class="s1">params = Object.assign({}, paramsMatch)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Remove any normalized params from the query if they</span><span class="s3">\n    </span><span class="s1">// weren't present as non-prefixed query key e.g.</span><span class="s3">\n    </span><span class="s1">// ?search=1&amp;nxtPsearch=hello we don't delete search</span><span class="s3">\n    </span><span class="s1">for (const key of routeParamKeys) {</span><span class="s3">\n      </span><span class="s1">if (!(key in originalQuery)) {</span><span class="s3">\n        </span><span class="s1">delete query[key]</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const { isOnDemandRevalidate, revalidateOnlyGenerated } =</span><span class="s3">\n      </span><span class="s1">checkIsOnDemandRevalidate(req, prerenderManifest.preview)</span><span class="s3">\n\n    </span><span class="s1">let isDraftMode = false</span><span class="s3">\n    </span><span class="s1">let previewData: PreviewData</span><span class="s3">\n\n    </span><span class="s1">// preview data relies on non-edge utils</span><span class="s3">\n    </span><span class="s1">if (process.env.NEXT_RUNTIME !== 'edge' &amp;&amp; res) {</span><span class="s3">\n      </span><span class="s1">const { tryGetPreviewData } =</span><span class="s3">\n        </span><span class="s1">require('../api-utils/node/try-get-preview-data') as typeof import('../api-utils/node/try-get-preview-data')</span><span class="s3">\n\n      </span><span class="s1">previewData = tryGetPreviewData(</span><span class="s3">\n        </span><span class="s1">req,</span><span class="s3">\n        </span><span class="s1">res,</span><span class="s3">\n        </span><span class="s1">prerenderManifest.preview,</span><span class="s3">\n        </span><span class="s1">Boolean(multiZoneDraftMode)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">isDraftMode = previewData !== false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const relativeProjectDir =</span><span class="s3">\n      </span><span class="s1">getRequestMeta(req, 'relativeProjectDir') || this.relativeProjectDir</span><span class="s3">\n\n    </span><span class="s1">const routerServerContext =</span><span class="s3">\n      </span><span class="s1">routerServerGlobal[RouterServerContextSymbol]?.[relativeProjectDir]</span><span class="s3">\n    </span><span class="s1">const nextConfig =</span><span class="s3">\n      </span><span class="s1">routerServerContext?.nextConfig || serverFilesManifest.config</span><span class="s3">\n\n    </span><span class="s1">const normalizedSrcPage = normalizeAppPath(srcPage)</span><span class="s3">\n    </span><span class="s1">let resolvedPathname =</span><span class="s3">\n      </span><span class="s1">getRequestMeta(req, 'rewroteURL') || normalizedSrcPage</span><span class="s3">\n\n    </span><span class="s1">if (isDynamicRoute(resolvedPathname) &amp;&amp; params) {</span><span class="s3">\n      </span><span class="s1">resolvedPathname = serverUtils.interpolateDynamicPath(</span><span class="s3">\n        </span><span class="s1">resolvedPathname,</span><span class="s3">\n        </span><span class="s1">params</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (resolvedPathname === '/index') {</span><span class="s3">\n      </span><span class="s1">resolvedPathname = '/'</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">resolvedPathname = decodePathParams(resolvedPathname)</span><span class="s3">\n    </span><span class="s1">} catch (_) {}</span><span class="s3">\n\n    </span><span class="s1">resolvedPathname = removeTrailingSlash(resolvedPathname)</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">query,</span><span class="s3">\n      </span><span class="s1">originalQuery,</span><span class="s3">\n      </span><span class="s1">originalPathname,</span><span class="s3">\n      </span><span class="s1">params,</span><span class="s3">\n      </span><span class="s1">parsedUrl,</span><span class="s3">\n      </span><span class="s1">locale,</span><span class="s3">\n      </span><span class="s1">isNextDataRequest,</span><span class="s3">\n      </span><span class="s1">locales: i18n?.locales,</span><span class="s3">\n      </span><span class="s1">defaultLocale,</span><span class="s3">\n      </span><span class="s1">isDraftMode,</span><span class="s3">\n      </span><span class="s1">previewData,</span><span class="s3">\n      </span><span class="s1">pageIsDynamic,</span><span class="s3">\n      </span><span class="s1">resolvedPathname,</span><span class="s3">\n      </span><span class="s1">isOnDemandRevalidate,</span><span class="s3">\n      </span><span class="s1">revalidateOnlyGenerated,</span><span class="s3">\n      </span><span class="s1">...manifests,</span><span class="s3">\n      </span><span class="s1">serverActionsManifest: manifests.serverActionsManifest,</span><span class="s3">\n      </span><span class="s1">clientReferenceManifest: manifests.clientReferenceManifest,</span><span class="s3">\n      </span><span class="s1">nextConfig,</span><span class="s3">\n      </span><span class="s1">routerServerContext,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public getResponseCache(req: IncomingMessage | BaseNextRequest) {</span><span class="s3">\n    </span><span class="s1">if (!this.responseCache) {</span><span class="s3">\n      </span><span class="s1">const minimalMode = getRequestMeta(req, 'minimalMode') ?? false</span><span class="s3">\n      </span><span class="s1">this.responseCache = new ResponseCache(minimalMode)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this.responseCache</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public async handleResponse({</span><span class="s3">\n    </span><span class="s1">req,</span><span class="s3">\n    </span><span class="s1">nextConfig,</span><span class="s3">\n    </span><span class="s1">cacheKey,</span><span class="s3">\n    </span><span class="s1">routeKind,</span><span class="s3">\n    </span><span class="s1">isFallback,</span><span class="s3">\n    </span><span class="s1">prerenderManifest,</span><span class="s3">\n    </span><span class="s1">isRoutePPREnabled,</span><span class="s3">\n    </span><span class="s1">isOnDemandRevalidate,</span><span class="s3">\n    </span><span class="s1">revalidateOnlyGenerated,</span><span class="s3">\n    </span><span class="s1">responseGenerator,</span><span class="s3">\n    </span><span class="s1">waitUntil,</span><span class="s3">\n  </span><span class="s1">}: {</span><span class="s3">\n    </span><span class="s1">req: IncomingMessage | BaseNextRequest</span><span class="s3">\n    </span><span class="s1">nextConfig: NextConfigComplete</span><span class="s3">\n    </span><span class="s1">cacheKey: string | null</span><span class="s3">\n    </span><span class="s1">routeKind: RouteKind</span><span class="s3">\n    </span><span class="s1">isFallback?: boolean</span><span class="s3">\n    </span><span class="s1">prerenderManifest: DeepReadonly&lt;PrerenderManifest&gt;</span><span class="s3">\n    </span><span class="s1">isRoutePPREnabled?: boolean</span><span class="s3">\n    </span><span class="s1">isOnDemandRevalidate?: boolean</span><span class="s3">\n    </span><span class="s1">revalidateOnlyGenerated?: boolean</span><span class="s3">\n    </span><span class="s1">responseGenerator: ResponseGenerator</span><span class="s3">\n    </span><span class="s1">waitUntil?: (prom: Promise&lt;any&gt;) =&gt; void</span><span class="s3">\n  </span><span class="s1">}) {</span><span class="s3">\n    </span><span class="s1">const responseCache = this.getResponseCache(req)</span><span class="s3">\n    </span><span class="s1">const cacheEntry = await responseCache.get(cacheKey, responseGenerator, {</span><span class="s3">\n      </span><span class="s1">routeKind,</span><span class="s3">\n      </span><span class="s1">isFallback,</span><span class="s3">\n      </span><span class="s1">isRoutePPREnabled,</span><span class="s3">\n      </span><span class="s1">isOnDemandRevalidate,</span><span class="s3">\n      </span><span class="s1">isPrefetch: req.headers.purpose === 'prefetch',</span><span class="s3">\n      </span><span class="s1">incrementalCache: await this.getIncrementalCache(</span><span class="s3">\n        </span><span class="s1">req,</span><span class="s3">\n        </span><span class="s1">nextConfig,</span><span class="s3">\n        </span><span class="s1">prerenderManifest</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">waitUntil,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">if (!cacheEntry) {</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">cacheKey &amp;&amp;</span><span class="s3">\n        </span><span class="s1">// revalidate only generated can bail even if cacheKey is provided</span><span class="s3">\n        </span><span class="s1">!(isOnDemandRevalidate &amp;&amp; revalidateOnlyGenerated)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">// A cache entry might not be generated if a response is written</span><span class="s3">\n        </span><span class="s1">// in `getInitialProps` or `getServerSideProps`, but those shouldn't</span><span class="s3">\n        </span><span class="s1">// have a cache key. If we do have a cache key but we don't end up</span><span class="s3">\n        </span><span class="s1">// with a cache entry, then either Next.js or the application has a</span><span class="s3">\n        </span><span class="s1">// bug that needs fixing.</span><span class="s3">\n        </span><span class="s1">throw new Error('invariant: cache entry required but not generated')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return cacheEntry</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export function isAppRouteRoute(route: string): boolean {</span><span class="s3">\n  </span><span class="s1">return route.endsWith('/route')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { Key } from 'next/dist/compiled/path-to-regexp'</span><span class="s3">\n</span><span class="s1">import { regexpToFunction } from 'next/dist/compiled/path-to-regexp'</span><span class="s3">\n</span><span class="s1">import { pathToRegexp } from 'next/dist/compiled/path-to-regexp'</span><span class="s3">\n\n</span><span class="s1">interface Options {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A transformer function that will be applied to the regexp generated</span><span class="s3">\n   </span><span class="s1">* from the provided path and path-to-regexp.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">regexModifier?: (regex: string) =&gt; string</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When true the function will remove all unnamed parameters</span><span class="s3">\n   </span><span class="s1">* from the matched parameters.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">removeUnnamedParams?: boolean</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When true the regexp won't allow an optional trailing delimiter</span><span class="s3">\n   </span><span class="s1">* to match.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">strict?: boolean</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When true the matcher will be case-sensitive, defaults to false</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">sensitive?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type PatchMatcher = (</span><span class="s3">\n  </span><span class="s1">pathname: string,</span><span class="s3">\n  </span><span class="s1">params?: Record&lt;string, any&gt;</span><span class="s3">\n</span><span class="s1">) =&gt; Record&lt;string, any&gt; | false</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Generates a path matcher function for a given path and options based on</span><span class="s3">\n </span><span class="s1">* path-to-regexp. By default the match will be case insensitive, non strict</span><span class="s3">\n </span><span class="s1">* and delimited by `/`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getPathMatch(path: string, options?: Options): PatchMatcher {</span><span class="s3">\n  </span><span class="s1">const keys: Key[] = []</span><span class="s3">\n  </span><span class="s1">const regexp = pathToRegexp(path, keys, {</span><span class="s3">\n    </span><span class="s1">delimiter: '/',</span><span class="s3">\n    </span><span class="s1">sensitive:</span><span class="s3">\n      </span><span class="s1">typeof options?.sensitive === 'boolean' ? options.sensitive : false,</span><span class="s3">\n    </span><span class="s1">strict: options?.strict,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">const matcher = regexpToFunction&lt;Record&lt;string, any&gt;&gt;(</span><span class="s3">\n    </span><span class="s1">options?.regexModifier</span><span class="s3">\n      </span><span class="s1">? new RegExp(options.regexModifier(regexp.source), regexp.flags)</span><span class="s3">\n      </span><span class="s1">: regexp,</span><span class="s3">\n    </span><span class="s1">keys</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A matcher function that will check if a given pathname matches the path</span><span class="s3">\n   </span><span class="s1">* given in the builder function. When the path does not match it will return</span><span class="s3">\n   </span><span class="s1">* `false` but if it does it will return an object with the matched params</span><span class="s3">\n   </span><span class="s1">* merged with the params provided in the second argument.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">return (pathname, params) =&gt; {</span><span class="s3">\n    </span><span class="s1">// If no pathname is provided it's not a match.</span><span class="s3">\n    </span><span class="s1">if (typeof pathname !== 'string') return false</span><span class="s3">\n\n    </span><span class="s1">const match = matcher(pathname)</span><span class="s3">\n\n    </span><span class="s1">// If the path did not match `false` will be returned.</span><span class="s3">\n    </span><span class="s1">if (!match) return false</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* If unnamed params are not allowed they must be removed from</span><span class="s3">\n     </span><span class="s1">* the matched parameters. path-to-regexp uses </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">for named and</span><span class="s3">\n     </span><span class="s1">* </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">for unnamed parameters.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">if (options?.removeUnnamedParams) {</span><span class="s3">\n      </span><span class="s1">for (const key of keys) {</span><span class="s3">\n        </span><span class="s1">if (typeof key.name === 'number') {</span><span class="s3">\n          </span><span class="s1">delete match.params[key.name]</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return { ...params, ...match.params }</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type {</span><span class="s3">\n  </span><span class="s1">FlightRouterState,</span><span class="s3">\n  </span><span class="s1">Segment,</span><span class="s3">\n</span><span class="s1">} from '../../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import { INTERCEPTION_ROUTE_MARKERS } from '../../../shared/lib/router/utils/interception-routes'</span><span class="s3">\n</span><span class="s1">import type { Params } from '../../../server/request/params'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">isGroupSegment,</span><span class="s3">\n  </span><span class="s1">DEFAULT_SEGMENT_KEY,</span><span class="s3">\n  </span><span class="s1">PAGE_SEGMENT_KEY,</span><span class="s3">\n</span><span class="s1">} from '../../../shared/lib/segment'</span><span class="s3">\n</span><span class="s1">import { matchSegment } from '../match-segments'</span><span class="s3">\n\n</span><span class="s1">const removeLeadingSlash = (segment: string): string =&gt; {</span><span class="s3">\n  </span><span class="s1">return segment[0] === '/' ? segment.slice(1) : segment</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const segmentToPathname = (segment: Segment): string =&gt; {</span><span class="s3">\n  </span><span class="s1">if (typeof segment === 'string') {</span><span class="s3">\n    </span><span class="s1">// 'children' is not a valid path -- it's technically a parallel route that corresponds with the current segment's page</span><span class="s3">\n    </span><span class="s1">// if we don't skip it, then the computed pathname might be something like `/children` which doesn't make sense.</span><span class="s3">\n    </span><span class="s1">if (segment === 'children') return ''</span><span class="s3">\n\n    </span><span class="s1">return segment</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return segment[1]</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function normalizeSegments(segments: string[]): string {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">segments.reduce((acc, segment) =&gt; {</span><span class="s3">\n      </span><span class="s1">segment = removeLeadingSlash(segment)</span><span class="s3">\n      </span><span class="s1">if (segment === '' || isGroupSegment(segment)) {</span><span class="s3">\n        </span><span class="s1">return acc</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return `${acc}/${segment}`</span><span class="s3">\n    </span><span class="s1">}, '') || '/'</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function extractPathFromFlightRouterState(</span><span class="s3">\n  </span><span class="s1">flightRouterState: FlightRouterState</span><span class="s3">\n</span><span class="s1">): string | undefined {</span><span class="s3">\n  </span><span class="s1">const segment = Array.isArray(flightRouterState[0])</span><span class="s3">\n    </span><span class="s1">? flightRouterState[0][1]</span><span class="s3">\n    </span><span class="s1">: flightRouterState[0]</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">segment === DEFAULT_SEGMENT_KEY ||</span><span class="s3">\n    </span><span class="s1">INTERCEPTION_ROUTE_MARKERS.some((m) =&gt; segment.startsWith(m))</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">return undefined</span><span class="s3">\n\n  </span><span class="s1">if (segment.startsWith(PAGE_SEGMENT_KEY)) return ''</span><span class="s3">\n\n  </span><span class="s1">const segments = [segmentToPathname(segment)]</span><span class="s3">\n  </span><span class="s1">const parallelRoutes = flightRouterState[1] ?? {}</span><span class="s3">\n\n  </span><span class="s1">const childrenPath = parallelRoutes.children</span><span class="s3">\n    </span><span class="s1">? extractPathFromFlightRouterState(parallelRoutes.children)</span><span class="s3">\n    </span><span class="s1">: undefined</span><span class="s3">\n\n  </span><span class="s1">if (childrenPath !== undefined) {</span><span class="s3">\n    </span><span class="s1">segments.push(childrenPath)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">for (const [key, value] of Object.entries(parallelRoutes)) {</span><span class="s3">\n      </span><span class="s1">if (key === 'children') continue</span><span class="s3">\n\n      </span><span class="s1">const childPath = extractPathFromFlightRouterState(value)</span><span class="s3">\n\n      </span><span class="s1">if (childPath !== undefined) {</span><span class="s3">\n        </span><span class="s1">segments.push(childPath)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return normalizeSegments(segments)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function computeChangedPathImpl(</span><span class="s3">\n  </span><span class="s1">treeA: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">treeB: FlightRouterState</span><span class="s3">\n</span><span class="s1">): string | null {</span><span class="s3">\n  </span><span class="s1">const [segmentA, parallelRoutesA] = treeA</span><span class="s3">\n  </span><span class="s1">const [segmentB, parallelRoutesB] = treeB</span><span class="s3">\n\n  </span><span class="s1">const normalizedSegmentA = segmentToPathname(segmentA)</span><span class="s3">\n  </span><span class="s1">const normalizedSegmentB = segmentToPathname(segmentB)</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">INTERCEPTION_ROUTE_MARKERS.some(</span><span class="s3">\n      </span><span class="s1">(m) =&gt;</span><span class="s3">\n        </span><span class="s1">normalizedSegmentA.startsWith(m) || normalizedSegmentB.startsWith(m)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return ''</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!matchSegment(segmentA, segmentB)) {</span><span class="s3">\n    </span><span class="s1">// once we find where the tree changed, we compute the rest of the path by traversing the tree</span><span class="s3">\n    </span><span class="s1">return extractPathFromFlightRouterState(treeB) ?? ''</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const parallelRouterKey in parallelRoutesA) {</span><span class="s3">\n    </span><span class="s1">if (parallelRoutesB[parallelRouterKey]) {</span><span class="s3">\n      </span><span class="s1">const changedPath = computeChangedPathImpl(</span><span class="s3">\n        </span><span class="s1">parallelRoutesA[parallelRouterKey],</span><span class="s3">\n        </span><span class="s1">parallelRoutesB[parallelRouterKey]</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">if (changedPath !== null) {</span><span class="s3">\n        </span><span class="s1">return `${segmentToPathname(segmentB)}/${changedPath}`</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function computeChangedPath(</span><span class="s3">\n  </span><span class="s1">treeA: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">treeB: FlightRouterState</span><span class="s3">\n</span><span class="s1">): string | null {</span><span class="s3">\n  </span><span class="s1">const changedPath = computeChangedPathImpl(treeA, treeB)</span><span class="s3">\n\n  </span><span class="s1">if (changedPath == null || changedPath === '/') {</span><span class="s3">\n    </span><span class="s1">return changedPath</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// lightweight normalization to remove route groups</span><span class="s3">\n  </span><span class="s1">return normalizeSegments(changedPath.split('/'))</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Recursively extracts dynamic parameters from FlightRouterState.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getSelectedParams(</span><span class="s3">\n  </span><span class="s1">currentTree: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">params: Params = {}</span><span class="s3">\n</span><span class="s1">): Params {</span><span class="s3">\n  </span><span class="s1">const parallelRoutes = currentTree[1]</span><span class="s3">\n\n  </span><span class="s1">for (const parallelRoute of Object.values(parallelRoutes)) {</span><span class="s3">\n    </span><span class="s1">const segment = parallelRoute[0]</span><span class="s3">\n    </span><span class="s1">const isDynamicParameter = Array.isArray(segment)</span><span class="s3">\n    </span><span class="s1">const segmentValue = isDynamicParameter ? segment[1] : segment</span><span class="s3">\n    </span><span class="s1">if (!segmentValue || segmentValue.startsWith(PAGE_SEGMENT_KEY)) continue</span><span class="s3">\n\n    </span><span class="s1">// Ensure catchAll and optional catchall are turned into an array</span><span class="s3">\n    </span><span class="s1">const isCatchAll =</span><span class="s3">\n      </span><span class="s1">isDynamicParameter &amp;&amp; (segment[2] === 'c' || segment[2] === 'oc')</span><span class="s3">\n\n    </span><span class="s1">if (isCatchAll) {</span><span class="s3">\n      </span><span class="s1">params[segment[0]] = segment[1].split('/')</span><span class="s3">\n    </span><span class="s1">} else if (isDynamicParameter) {</span><span class="s3">\n      </span><span class="s1">params[segment[0]] = segment[1]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">params = getSelectedParams(parallelRoute, params)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return params</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { FlightRouterState } from './types'</span><span class="s3">\n</span><span class="s1">import { flightRouterStateSchema } from './types'</span><span class="s3">\n</span><span class="s1">import { assert } from 'next/dist/compiled/superstruct'</span><span class="s3">\n\n</span><span class="s1">export function parseAndValidateFlightRouterState(</span><span class="s3">\n  </span><span class="s1">stateHeader: string | string[]</span><span class="s3">\n</span><span class="s1">): FlightRouterState</span><span class="s3">\n</span><span class="s1">export function parseAndValidateFlightRouterState(</span><span class="s3">\n  </span><span class="s1">stateHeader: undefined</span><span class="s3">\n</span><span class="s1">): undefined</span><span class="s3">\n</span><span class="s1">export function parseAndValidateFlightRouterState(</span><span class="s3">\n  </span><span class="s1">stateHeader: string | string[] | undefined</span><span class="s3">\n</span><span class="s1">): FlightRouterState | undefined</span><span class="s3">\n</span><span class="s1">export function parseAndValidateFlightRouterState(</span><span class="s3">\n  </span><span class="s1">stateHeader: string | string[] | undefined</span><span class="s3">\n</span><span class="s1">): FlightRouterState | undefined {</span><span class="s3">\n  </span><span class="s1">if (typeof stateHeader === 'undefined') {</span><span class="s3">\n    </span><span class="s1">return undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (Array.isArray(stateHeader)) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">'Multiple router state headers were sent. This is not allowed.'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// We limit the size of the router state header to ~40kb. This is to prevent</span><span class="s3">\n  </span><span class="s1">// a malicious user from sending a very large header and slowing down the</span><span class="s3">\n  </span><span class="s1">// resolving of the router state.</span><span class="s3">\n  </span><span class="s1">// This is around 2,000 nested or parallel route segment states:</span><span class="s3">\n  </span><span class="s1">// '{</span><span class="s3">\&quot;</span><span class="s1">children</span><span class="s3">\&quot;</span><span class="s1">:[</span><span class="s3">\&quot;\&quot;</span><span class="s1">,{}]}'.length === 20.</span><span class="s3">\n  </span><span class="s1">if (stateHeader.length &gt; 20 * 2000) {</span><span class="s3">\n    </span><span class="s1">throw new Error('The router state header was too large.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">const state = JSON.parse(decodeURIComponent(stateHeader))</span><span class="s3">\n    </span><span class="s1">assert(state, flightRouterStateSchema)</span><span class="s3">\n    </span><span class="s1">return state</span><span class="s3">\n  </span><span class="s1">} catch {</span><span class="s3">\n    </span><span class="s1">throw new Error('The router state header was sent but could not be parsed.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { ParsedUrlQuery } from 'querystring'</span><span class="s3">\n\n</span><span class="s1">import { searchParamsToUrlQuery } from './querystring'</span><span class="s3">\n</span><span class="s1">import { parseRelativeUrl } from './parse-relative-url'</span><span class="s3">\n\n</span><span class="s1">export interface ParsedUrl {</span><span class="s3">\n  </span><span class="s1">hash: string</span><span class="s3">\n  </span><span class="s1">hostname?: string | null</span><span class="s3">\n  </span><span class="s1">href: string</span><span class="s3">\n  </span><span class="s1">pathname: string</span><span class="s3">\n  </span><span class="s1">port?: string | null</span><span class="s3">\n  </span><span class="s1">protocol?: string | null</span><span class="s3">\n  </span><span class="s1">query: ParsedUrlQuery</span><span class="s3">\n  </span><span class="s1">search: string</span><span class="s3">\n  </span><span class="s1">slashes: boolean | undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function parseUrl(url: string): ParsedUrl {</span><span class="s3">\n  </span><span class="s1">if (url.startsWith('/')) {</span><span class="s3">\n    </span><span class="s1">return parseRelativeUrl(url)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const parsedURL = new URL(url)</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">hash: parsedURL.hash,</span><span class="s3">\n    </span><span class="s1">hostname: parsedURL.hostname,</span><span class="s3">\n    </span><span class="s1">href: parsedURL.href,</span><span class="s3">\n    </span><span class="s1">pathname: parsedURL.pathname,</span><span class="s3">\n    </span><span class="s1">port: parsedURL.port,</span><span class="s3">\n    </span><span class="s1">protocol: parsedURL.protocol,</span><span class="s3">\n    </span><span class="s1">query: searchParamsToUrlQuery(parsedURL.searchParams),</span><span class="s3">\n    </span><span class="s1">search: parsedURL.search,</span><span class="s3">\n    </span><span class="s1">slashes:</span><span class="s3">\n      </span><span class="s1">parsedURL.href.slice(</span><span class="s3">\n        </span><span class="s1">parsedURL.protocol.length,</span><span class="s3">\n        </span><span class="s1">parsedURL.protocol.length + 2</span><span class="s3">\n      </span><span class="s1">) === '//',</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { ParsedUrlQuery } from 'querystring'</span><span class="s3">\n</span><span class="s1">import { getLocationOrigin } from '../../utils'</span><span class="s3">\n</span><span class="s1">import { searchParamsToUrlQuery } from './querystring'</span><span class="s3">\n\n</span><span class="s1">export interface ParsedRelativeUrl {</span><span class="s3">\n  </span><span class="s1">hash: string</span><span class="s3">\n  </span><span class="s1">href: string</span><span class="s3">\n  </span><span class="s1">pathname: string</span><span class="s3">\n  </span><span class="s1">query: ParsedUrlQuery</span><span class="s3">\n  </span><span class="s1">search: string</span><span class="s3">\n  </span><span class="s1">slashes: undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Parses path-relative urls (e.g. `/hello/world?foo=bar`). If url isn't path-relative</span><span class="s3">\n </span><span class="s1">* (e.g. `./hello`) then at least base must be.</span><span class="s3">\n </span><span class="s1">* Absolute urls are rejected with one exception, in the browser, absolute urls that are on</span><span class="s3">\n </span><span class="s1">* the current origin will be parsed as relative</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function parseRelativeUrl(</span><span class="s3">\n  </span><span class="s1">url: string,</span><span class="s3">\n  </span><span class="s1">base?: string,</span><span class="s3">\n  </span><span class="s1">parseQuery?: true</span><span class="s3">\n</span><span class="s1">): ParsedRelativeUrl</span><span class="s3">\n</span><span class="s1">export function parseRelativeUrl(</span><span class="s3">\n  </span><span class="s1">url: string,</span><span class="s3">\n  </span><span class="s1">base: string | undefined,</span><span class="s3">\n  </span><span class="s1">parseQuery: false</span><span class="s3">\n</span><span class="s1">): Omit&lt;ParsedRelativeUrl, 'query'&gt;</span><span class="s3">\n</span><span class="s1">export function parseRelativeUrl(</span><span class="s3">\n  </span><span class="s1">url: string,</span><span class="s3">\n  </span><span class="s1">base?: string,</span><span class="s3">\n  </span><span class="s1">parseQuery = true</span><span class="s3">\n</span><span class="s1">): ParsedRelativeUrl | Omit&lt;ParsedRelativeUrl, 'query'&gt; {</span><span class="s3">\n  </span><span class="s1">const globalBase = new URL(</span><span class="s3">\n    </span><span class="s1">typeof window === 'undefined' ? 'http://n' : getLocationOrigin()</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">const resolvedBase = base</span><span class="s3">\n    </span><span class="s1">? new URL(base, globalBase)</span><span class="s3">\n    </span><span class="s1">: url.startsWith('.')</span><span class="s3">\n      </span><span class="s1">? new URL(</span><span class="s3">\n          </span><span class="s1">typeof window === 'undefined' ? 'http://n' : window.location.href</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">: globalBase</span><span class="s3">\n\n  </span><span class="s1">const { pathname, searchParams, search, hash, href, origin } = new URL(</span><span class="s3">\n    </span><span class="s1">url,</span><span class="s3">\n    </span><span class="s1">resolvedBase</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">if (origin !== globalBase.origin) {</span><span class="s3">\n    </span><span class="s1">throw new Error(`invariant: invalid relative URL, router received ${url}`)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">pathname,</span><span class="s3">\n    </span><span class="s1">query: parseQuery ? searchParamsToUrlQuery(searchParams) : undefined,</span><span class="s3">\n    </span><span class="s1">search,</span><span class="s3">\n    </span><span class="s1">hash,</span><span class="s3">\n    </span><span class="s1">href: href.slice(origin.length),</span><span class="s3">\n    </span><span class="s1">// We don't know for relative URLs at this point since we set a custom, internal</span><span class="s3">\n    </span><span class="s1">// base that isn't surfaced to users.</span><span class="s3">\n    </span><span class="s1">slashes: undefined,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import escapePathDelimiters from '../../../shared/lib/router/utils/escape-path-delimiters'</span><span class="s3">\n</span><span class="s1">import { DecodeError } from '../../../shared/lib/utils'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* We only encode path delimiters for path segments from</span><span class="s3">\n </span><span class="s1">* getStaticPaths so we need to attempt decoding the URL</span><span class="s3">\n </span><span class="s1">* to match against and only escape the path delimiters</span><span class="s3">\n </span><span class="s1">* this allows non-ascii values to be handled e.g.</span><span class="s3">\n </span><span class="s1">* Japanese characters.</span><span class="s3">\n </span><span class="s1">* */</span><span class="s3">\n</span><span class="s1">function decodePathParams(pathname: string): string {</span><span class="s3">\n  </span><span class="s1">// TODO: investigate adding this handling for non-SSG</span><span class="s3">\n  </span><span class="s1">// pages so non-ascii names also work there.</span><span class="s3">\n  </span><span class="s1">return pathname</span><span class="s3">\n    </span><span class="s1">.split('/')</span><span class="s3">\n    </span><span class="s1">.map((seg) =&gt; {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">seg = escapePathDelimiters(decodeURIComponent(seg), true)</span><span class="s3">\n      </span><span class="s1">} catch (_) {</span><span class="s3">\n        </span><span class="s1">// An improperly encoded URL was provided</span><span class="s3">\n        </span><span class="s1">throw new DecodeError('Failed to decode path param(s).')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return seg</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">.join('/')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { decodePathParams }</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// escape delimiters used by path-to-regexp</span><span class="s3">\n</span><span class="s1">export default function escapePathDelimiters(</span><span class="s3">\n  </span><span class="s1">segment: string,</span><span class="s3">\n  </span><span class="s1">escapeEncoded?: boolean</span><span class="s3">\n</span><span class="s1">): string {</span><span class="s3">\n  </span><span class="s1">return segment.replace(</span><span class="s3">\n    </span><span class="s1">new RegExp(`([/#?]${escapeEncoded ? '|%(2f|23|3f|5c)' : ''})`, 'gi'),</span><span class="s3">\n    </span><span class="s1">(char: string) =&gt; encodeURIComponent(char)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export function getObjectClassLabel(value: any): string {</span><span class="s3">\n  </span><span class="s1">return Object.prototype.toString.call(value)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isPlainObject(value: any): boolean {</span><span class="s3">\n  </span><span class="s1">if (getObjectClassLabel(value) !== '[object Object]') {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const prototype = Object.getPrototypeOf(value)</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* this used to be previously:</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* `return prototype === null || prototype === Object.prototype`</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* but Edge Runtime expose Object from vm, being that kind of type-checking wrongly fail.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* It was changed to the current implementation since it's resilient to serialization.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">return prototype === null || prototype.hasOwnProperty('isPrototypeOf')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">isPlainObject,</span><span class="s3">\n  </span><span class="s1">getObjectClassLabel,</span><span class="s3">\n</span><span class="s1">} from '../shared/lib/is-plain-object'</span><span class="s3">\n\n</span><span class="s1">const regexpPlainIdentifier = /^[A-Za-z_$][A-Za-z0-9_$]*$/</span><span class="s3">\n\n</span><span class="s1">export class SerializableError extends Error {</span><span class="s3">\n  </span><span class="s1">constructor(page: string, method: string, path: string, message: string) {</span><span class="s3">\n    </span><span class="s1">super(</span><span class="s3">\n      </span><span class="s1">path</span><span class="s3">\n        </span><span class="s1">? `Error serializing </span><span class="s3">\\</span><span class="s1">`${path}</span><span class="s3">\\</span><span class="s1">` returned from </span><span class="s3">\\</span><span class="s1">`${method}</span><span class="s3">\\</span><span class="s1">` in </span><span class="s3">\&quot;</span><span class="s1">${page}</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">nReason: ${message}`</span><span class="s3">\n        </span><span class="s1">: `Error serializing props returned from </span><span class="s3">\\</span><span class="s1">`${method}</span><span class="s3">\\</span><span class="s1">` in </span><span class="s3">\&quot;</span><span class="s1">${page}</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">nReason: ${message}`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function isSerializableProps(</span><span class="s3">\n  </span><span class="s1">page: string,</span><span class="s3">\n  </span><span class="s1">method: string,</span><span class="s3">\n  </span><span class="s1">input: any</span><span class="s3">\n</span><span class="s1">): true {</span><span class="s3">\n  </span><span class="s1">if (!isPlainObject(input)) {</span><span class="s3">\n    </span><span class="s1">throw new SerializableError(</span><span class="s3">\n      </span><span class="s1">page,</span><span class="s3">\n      </span><span class="s1">method,</span><span class="s3">\n      </span><span class="s1">'',</span><span class="s3">\n      </span><span class="s1">`Props must be returned as a plain object from ${method}: </span><span class="s3">\\</span><span class="s1">`{ props: { ... } }</span><span class="s3">\\</span><span class="s1">` (received: </span><span class="s3">\\</span><span class="s1">`${getObjectClassLabel(</span><span class="s3">\n        </span><span class="s1">input</span><span class="s3">\n      </span><span class="s1">)}</span><span class="s3">\\</span><span class="s1">`).`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function visit(visited: Map&lt;any, string&gt;, value: any, path: string) {</span><span class="s3">\n    </span><span class="s1">if (visited.has(value)) {</span><span class="s3">\n      </span><span class="s1">throw new SerializableError(</span><span class="s3">\n        </span><span class="s1">page,</span><span class="s3">\n        </span><span class="s1">method,</span><span class="s3">\n        </span><span class="s1">path,</span><span class="s3">\n        </span><span class="s1">`Circular references cannot be expressed in JSON (references: </span><span class="s3">\\</span><span class="s1">`${</span><span class="s3">\n          </span><span class="s1">visited.get(value) || '(self)'</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\\</span><span class="s1">`).`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">visited.set(value, path)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function isSerializable(</span><span class="s3">\n    </span><span class="s1">refs: Map&lt;any, string&gt;,</span><span class="s3">\n    </span><span class="s1">value: any,</span><span class="s3">\n    </span><span class="s1">path: string</span><span class="s3">\n  </span><span class="s1">): true {</span><span class="s3">\n    </span><span class="s1">const type = typeof value</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">// `null` can be serialized, but not `undefined`.</span><span class="s3">\n      </span><span class="s1">value === null ||</span><span class="s3">\n      </span><span class="s1">// n.b. `bigint`, `function`, `symbol`, and `undefined` cannot be</span><span class="s3">\n      </span><span class="s1">// serialized.</span><span class="s3">\n      </span><span class="s1">//</span><span class="s3">\n      </span><span class="s1">// `object` is special-cased below, as it may represent `null`, an Array,</span><span class="s3">\n      </span><span class="s1">// a plain object, a class, et al.</span><span class="s3">\n      </span><span class="s1">type === 'boolean' ||</span><span class="s3">\n      </span><span class="s1">type === 'number' ||</span><span class="s3">\n      </span><span class="s1">type === 'string'</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (type === 'undefined') {</span><span class="s3">\n      </span><span class="s1">throw new SerializableError(</span><span class="s3">\n        </span><span class="s1">page,</span><span class="s3">\n        </span><span class="s1">method,</span><span class="s3">\n        </span><span class="s1">path,</span><span class="s3">\n        </span><span class="s1">'`undefined` cannot be serialized as JSON. Please use `null` or omit this value.'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (isPlainObject(value)) {</span><span class="s3">\n      </span><span class="s1">visit(refs, value, path)</span><span class="s3">\n\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">Object.entries(value).every(([key, nestedValue]) =&gt; {</span><span class="s3">\n          </span><span class="s1">const nextPath = regexpPlainIdentifier.test(key)</span><span class="s3">\n            </span><span class="s1">? `${path}.${key}`</span><span class="s3">\n            </span><span class="s1">: `${path}[${JSON.stringify(key)}]`</span><span class="s3">\n\n          </span><span class="s1">const newRefs = new Map(refs)</span><span class="s3">\n          </span><span class="s1">return (</span><span class="s3">\n            </span><span class="s1">isSerializable(newRefs, key, nextPath) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">isSerializable(newRefs, nestedValue, nextPath)</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">throw new SerializableError(</span><span class="s3">\n        </span><span class="s1">page,</span><span class="s3">\n        </span><span class="s1">method,</span><span class="s3">\n        </span><span class="s1">path,</span><span class="s3">\n        </span><span class="s1">`invariant: Unknown error encountered in Object.`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (Array.isArray(value)) {</span><span class="s3">\n      </span><span class="s1">visit(refs, value, path)</span><span class="s3">\n\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">value.every((nestedValue, index) =&gt; {</span><span class="s3">\n          </span><span class="s1">const newRefs = new Map(refs)</span><span class="s3">\n          </span><span class="s1">return isSerializable(newRefs, nestedValue, `${path}[${index}]`)</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">throw new SerializableError(</span><span class="s3">\n        </span><span class="s1">page,</span><span class="s3">\n        </span><span class="s1">method,</span><span class="s3">\n        </span><span class="s1">path,</span><span class="s3">\n        </span><span class="s1">`invariant: Unknown error encountered in Array.`</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// None of these can be expressed as JSON:</span><span class="s3">\n    </span><span class="s1">// const type: </span><span class="s3">\&quot;</span><span class="s1">bigint</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">symbol</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">| </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;\n    </span><span class="s1">throw new SerializableError(</span><span class="s3">\n      </span><span class="s1">page,</span><span class="s3">\n      </span><span class="s1">method,</span><span class="s3">\n      </span><span class="s1">path,</span><span class="s3">\n      </span><span class="s1">'`' +</span><span class="s3">\n        </span><span class="s1">type +</span><span class="s3">\n        </span><span class="s1">'`' +</span><span class="s3">\n        </span><span class="s1">(type === 'object'</span><span class="s3">\n          </span><span class="s1">? ` (</span><span class="s3">\&quot;</span><span class="s1">${Object.prototype.toString.call(value)}</span><span class="s3">\&quot;</span><span class="s1">)`</span><span class="s3">\n          </span><span class="s1">: '') +</span><span class="s3">\n        </span><span class="s1">' cannot be serialized as JSON. Please only return JSON serializable data types.'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return isSerializable(new Map(), input, '')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import React from 'react'</span><span class="s3">\n\n</span><span class="s1">export const AmpStateContext: React.Context&lt;any&gt; = React.createContext({})</span><span class="s3">\n\n</span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n  </span><span class="s1">AmpStateContext.displayName = 'AmpStateContext'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import React from 'react'</span><span class="s3">\n\n</span><span class="s1">export const HeadManagerContext: React.Context&lt;{</span><span class="s3">\n  </span><span class="s1">updateHead?: (state: any) =&gt; void</span><span class="s3">\n  </span><span class="s1">mountedInstances?: any</span><span class="s3">\n  </span><span class="s1">updateScripts?: (state: any) =&gt; void</span><span class="s3">\n  </span><span class="s1">scripts?: any</span><span class="s3">\n  </span><span class="s1">getIsSsr?: () =&gt; boolean</span><span class="s3">\n\n  </span><span class="s1">// Used in app directory, to render script tags as server components.</span><span class="s3">\n  </span><span class="s1">appDir?: boolean</span><span class="s3">\n  </span><span class="s1">nonce?: string</span><span class="s3">\n</span><span class="s1">}&gt; = React.createContext({})</span><span class="s3">\n\n</span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n  </span><span class="s1">HeadManagerContext.displayName = 'HeadManagerContext'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;'use client'</span><span class="s3">\n\n</span><span class="s1">import React from 'react'</span><span class="s3">\n\n</span><span class="s1">type CaptureFn = (moduleName: string) =&gt; void</span><span class="s3">\n\n</span><span class="s1">export const LoadableContext = React.createContext&lt;CaptureFn | null&gt;(null)</span><span class="s3">\n\n</span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n  </span><span class="s1">LoadableContext.displayName = 'LoadableContext'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// TODO: Remove use of `any` type.</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">@copyright (c) 2017-present James Kyle &lt;me@thejameskyle.com&gt;</span><span class="s3">\n </span><span class="s1">MIT License</span><span class="s3">\n </span><span class="s1">Permission is hereby granted, free of charge, to any person obtaining</span><span class="s3">\n</span><span class="s1">a copy of this software and associated documentation files (the</span><span class="s3">\n\&quot;</span><span class="s1">Software</span><span class="s3">\&quot;</span><span class="s1">), to deal in the Software without restriction, including</span><span class="s3">\n</span><span class="s1">without limitation the rights to use, copy, modify, merge, publish,</span><span class="s3">\n</span><span class="s1">distribute, sublicense, and/or sell copies of the Software, and to</span><span class="s3">\n</span><span class="s1">permit persons to whom the Software is furnished to do so, subject to</span><span class="s3">\n</span><span class="s1">the following conditions:</span><span class="s3">\n </span><span class="s1">The above copyright notice and this permission notice shall be</span><span class="s3">\n</span><span class="s1">included in all copies or substantial portions of the Software.</span><span class="s3">\n </span><span class="s1">THE SOFTWARE IS PROVIDED </span><span class="s3">\&quot;</span><span class="s1">AS IS</span><span class="s3">\&quot;</span><span class="s1">, WITHOUT WARRANTY OF ANY KIND,</span><span class="s3">\n</span><span class="s1">EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span><span class="s3">\n</span><span class="s1">MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</span><span class="s3">\n</span><span class="s1">NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE</span><span class="s3">\n</span><span class="s1">LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION</span><span class="s3">\n</span><span class="s1">OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION</span><span class="s3">\n</span><span class="s1">WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">// https://github.com/jamiebuilds/react-loadable/blob/v5.5.0/src/index.js</span><span class="s3">\n</span><span class="s1">// Modified to be compatible with webpack 4 / Next.js</span><span class="s3">\n\n</span><span class="s1">import React from 'react'</span><span class="s3">\n</span><span class="s1">import { LoadableContext } from './loadable-context.shared-runtime'</span><span class="s3">\n\n</span><span class="s1">function resolve(obj: any) {</span><span class="s3">\n  </span><span class="s1">return obj &amp;&amp; obj.default ? obj.default : obj</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const ALL_INITIALIZERS: any[] = []</span><span class="s3">\n</span><span class="s1">const READY_INITIALIZERS: any[] = []</span><span class="s3">\n</span><span class="s1">let initialized = false</span><span class="s3">\n\n</span><span class="s1">function load(loader: any) {</span><span class="s3">\n  </span><span class="s1">let promise = loader()</span><span class="s3">\n\n  </span><span class="s1">let state: any = {</span><span class="s3">\n    </span><span class="s1">loading: true,</span><span class="s3">\n    </span><span class="s1">loaded: null,</span><span class="s3">\n    </span><span class="s1">error: null,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">state.promise = promise</span><span class="s3">\n    </span><span class="s1">.then((loaded: any) =&gt; {</span><span class="s3">\n      </span><span class="s1">state.loading = false</span><span class="s3">\n      </span><span class="s1">state.loaded = loaded</span><span class="s3">\n      </span><span class="s1">return loaded</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">.catch((err: any) =&gt; {</span><span class="s3">\n      </span><span class="s1">state.loading = false</span><span class="s3">\n      </span><span class="s1">state.error = err</span><span class="s3">\n      </span><span class="s1">throw err</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">return state</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createLoadableComponent(loadFn: any, options: any) {</span><span class="s3">\n  </span><span class="s1">let opts = Object.assign(</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">loader: null,</span><span class="s3">\n      </span><span class="s1">loading: null,</span><span class="s3">\n      </span><span class="s1">delay: 200,</span><span class="s3">\n      </span><span class="s1">timeout: null,</span><span class="s3">\n      </span><span class="s1">webpack: null,</span><span class="s3">\n      </span><span class="s1">modules: null,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">options</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">/** @type LoadableSubscription */</span><span class="s3">\n  </span><span class="s1">let subscription: any = null</span><span class="s3">\n  </span><span class="s1">function init() {</span><span class="s3">\n    </span><span class="s1">if (!subscription) {</span><span class="s3">\n      </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-use-before-define</span><span class="s3">\n      </span><span class="s1">const sub = new LoadableSubscription(loadFn, opts)</span><span class="s3">\n      </span><span class="s1">subscription = {</span><span class="s3">\n        </span><span class="s1">getCurrentValue: sub.getCurrentValue.bind(sub),</span><span class="s3">\n        </span><span class="s1">subscribe: sub.subscribe.bind(sub),</span><span class="s3">\n        </span><span class="s1">retry: sub.retry.bind(sub),</span><span class="s3">\n        </span><span class="s1">promise: sub.promise.bind(sub),</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return subscription.promise()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Server only</span><span class="s3">\n  </span><span class="s1">if (typeof window === 'undefined') {</span><span class="s3">\n    </span><span class="s1">ALL_INITIALIZERS.push(init)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Client only</span><span class="s3">\n  </span><span class="s1">if (!initialized &amp;&amp; typeof window !== 'undefined') {</span><span class="s3">\n    </span><span class="s1">// require.resolveWeak check is needed for environments that don't have it available like Jest</span><span class="s3">\n    </span><span class="s1">const moduleIds =</span><span class="s3">\n      </span><span class="s1">opts.webpack &amp;&amp; typeof (require as any).resolveWeak === 'function'</span><span class="s3">\n        </span><span class="s1">? opts.webpack()</span><span class="s3">\n        </span><span class="s1">: opts.modules</span><span class="s3">\n    </span><span class="s1">if (moduleIds) {</span><span class="s3">\n      </span><span class="s1">READY_INITIALIZERS.push((ids: any) =&gt; {</span><span class="s3">\n        </span><span class="s1">for (const moduleId of moduleIds) {</span><span class="s3">\n          </span><span class="s1">if (ids.includes(moduleId)) {</span><span class="s3">\n            </span><span class="s1">return init()</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function useLoadableModule() {</span><span class="s3">\n    </span><span class="s1">init()</span><span class="s3">\n\n    </span><span class="s1">const context = React.useContext(LoadableContext)</span><span class="s3">\n    </span><span class="s1">if (context &amp;&amp; Array.isArray(opts.modules)) {</span><span class="s3">\n      </span><span class="s1">opts.modules.forEach((moduleName: any) =&gt; {</span><span class="s3">\n        </span><span class="s1">context(moduleName)</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function LoadableComponent(props: any, ref: any) {</span><span class="s3">\n    </span><span class="s1">useLoadableModule()</span><span class="s3">\n\n    </span><span class="s1">const state = (React as any).useSyncExternalStore(</span><span class="s3">\n      </span><span class="s1">subscription.subscribe,</span><span class="s3">\n      </span><span class="s1">subscription.getCurrentValue,</span><span class="s3">\n      </span><span class="s1">subscription.getCurrentValue</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">React.useImperativeHandle(</span><span class="s3">\n      </span><span class="s1">ref,</span><span class="s3">\n      </span><span class="s1">() =&gt; ({</span><span class="s3">\n        </span><span class="s1">retry: subscription.retry,</span><span class="s3">\n      </span><span class="s1">}),</span><span class="s3">\n      </span><span class="s1">[]</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">return React.useMemo(() =&gt; {</span><span class="s3">\n      </span><span class="s1">if (state.loading || state.error) {</span><span class="s3">\n        </span><span class="s1">return React.createElement(opts.loading, {</span><span class="s3">\n          </span><span class="s1">isLoading: state.loading,</span><span class="s3">\n          </span><span class="s1">pastDelay: state.pastDelay,</span><span class="s3">\n          </span><span class="s1">timedOut: state.timedOut,</span><span class="s3">\n          </span><span class="s1">error: state.error,</span><span class="s3">\n          </span><span class="s1">retry: subscription.retry,</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">} else if (state.loaded) {</span><span class="s3">\n        </span><span class="s1">return React.createElement(resolve(state.loaded), props)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return null</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}, [props, state])</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">LoadableComponent.preload = () =&gt; init()</span><span class="s3">\n  </span><span class="s1">LoadableComponent.displayName = 'LoadableComponent'</span><span class="s3">\n\n  </span><span class="s1">return React.forwardRef(LoadableComponent)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">class LoadableSubscription {</span><span class="s3">\n  </span><span class="s1">_loadFn: any</span><span class="s3">\n  </span><span class="s1">_opts: any</span><span class="s3">\n  </span><span class="s1">_callbacks: any</span><span class="s3">\n  </span><span class="s1">_delay: any</span><span class="s3">\n  </span><span class="s1">_timeout: any</span><span class="s3">\n  </span><span class="s1">_res: any</span><span class="s3">\n  </span><span class="s1">_state: any</span><span class="s3">\n  </span><span class="s1">constructor(loadFn: any, opts: any) {</span><span class="s3">\n    </span><span class="s1">this._loadFn = loadFn</span><span class="s3">\n    </span><span class="s1">this._opts = opts</span><span class="s3">\n    </span><span class="s1">this._callbacks = new Set()</span><span class="s3">\n    </span><span class="s1">this._delay = null</span><span class="s3">\n    </span><span class="s1">this._timeout = null</span><span class="s3">\n\n    </span><span class="s1">this.retry()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">promise() {</span><span class="s3">\n    </span><span class="s1">return this._res.promise</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">retry() {</span><span class="s3">\n    </span><span class="s1">this._clearTimeouts()</span><span class="s3">\n    </span><span class="s1">this._res = this._loadFn(this._opts.loader)</span><span class="s3">\n\n    </span><span class="s1">this._state = {</span><span class="s3">\n      </span><span class="s1">pastDelay: false,</span><span class="s3">\n      </span><span class="s1">timedOut: false,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const { _res: res, _opts: opts } = this</span><span class="s3">\n\n    </span><span class="s1">if (res.loading) {</span><span class="s3">\n      </span><span class="s1">if (typeof opts.delay === 'number') {</span><span class="s3">\n        </span><span class="s1">if (opts.delay === 0) {</span><span class="s3">\n          </span><span class="s1">this._state.pastDelay = true</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">this._delay = setTimeout(() =&gt; {</span><span class="s3">\n            </span><span class="s1">this._update({</span><span class="s3">\n              </span><span class="s1">pastDelay: true,</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n          </span><span class="s1">}, opts.delay)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (typeof opts.timeout === 'number') {</span><span class="s3">\n        </span><span class="s1">this._timeout = setTimeout(() =&gt; {</span><span class="s3">\n          </span><span class="s1">this._update({ timedOut: true })</span><span class="s3">\n        </span><span class="s1">}, opts.timeout)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this._res.promise</span><span class="s3">\n      </span><span class="s1">.then(() =&gt; {</span><span class="s3">\n        </span><span class="s1">this._update({})</span><span class="s3">\n        </span><span class="s1">this._clearTimeouts()</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">.catch((_err: any) =&gt; {</span><span class="s3">\n        </span><span class="s1">this._update({})</span><span class="s3">\n        </span><span class="s1">this._clearTimeouts()</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">this._update({})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_update(partial: any) {</span><span class="s3">\n    </span><span class="s1">this._state = {</span><span class="s3">\n      </span><span class="s1">...this._state,</span><span class="s3">\n      </span><span class="s1">error: this._res.error,</span><span class="s3">\n      </span><span class="s1">loaded: this._res.loaded,</span><span class="s3">\n      </span><span class="s1">loading: this._res.loading,</span><span class="s3">\n      </span><span class="s1">...partial,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this._callbacks.forEach((callback: any) =&gt; callback())</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_clearTimeouts() {</span><span class="s3">\n    </span><span class="s1">clearTimeout(this._delay)</span><span class="s3">\n    </span><span class="s1">clearTimeout(this._timeout)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">getCurrentValue() {</span><span class="s3">\n    </span><span class="s1">return this._state</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">subscribe(callback: any) {</span><span class="s3">\n    </span><span class="s1">this._callbacks.add(callback)</span><span class="s3">\n    </span><span class="s1">return () =&gt; {</span><span class="s3">\n      </span><span class="s1">this._callbacks.delete(callback)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function Loadable(opts: any) {</span><span class="s3">\n  </span><span class="s1">return createLoadableComponent(load, opts)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function flushInitializers(initializers: any, ids?: any): any {</span><span class="s3">\n  </span><span class="s1">let promises = []</span><span class="s3">\n\n  </span><span class="s1">while (initializers.length) {</span><span class="s3">\n    </span><span class="s1">let init = initializers.pop()</span><span class="s3">\n    </span><span class="s1">promises.push(init(ids))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return Promise.all(promises).then(() =&gt; {</span><span class="s3">\n    </span><span class="s1">if (initializers.length) {</span><span class="s3">\n      </span><span class="s1">return flushInitializers(initializers, ids)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">Loadable.preloadAll = () =&gt; {</span><span class="s3">\n  </span><span class="s1">return new Promise((resolveInitializers, reject) =&gt; {</span><span class="s3">\n    </span><span class="s1">flushInitializers(ALL_INITIALIZERS).then(resolveInitializers, reject)</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">Loadable.preloadReady = (ids: (string | number)[] = []): Promise&lt;void&gt; =&gt; {</span><span class="s3">\n  </span><span class="s1">return new Promise&lt;void&gt;((resolvePreload) =&gt; {</span><span class="s3">\n    </span><span class="s1">const res = () =&gt; {</span><span class="s3">\n      </span><span class="s1">initialized = true</span><span class="s3">\n      </span><span class="s1">return resolvePreload()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// We always will resolve, errors should be handled within loading UIs.</span><span class="s3">\n    </span><span class="s1">flushInitializers(READY_INITIALIZERS, ids).then(res, res)</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">declare global {</span><span class="s3">\n  </span><span class="s1">interface Window {</span><span class="s3">\n    </span><span class="s1">__NEXT_PRELOADREADY?: (ids?: (string | number)[]) =&gt; Promise&lt;void&gt;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">if (typeof window !== 'undefined') {</span><span class="s3">\n  </span><span class="s1">window.__NEXT_PRELOADREADY = Loadable.preloadReady</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default Loadable</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import React from 'react'</span><span class="s3">\n</span><span class="s1">import type { NextRouter } from './router/router'</span><span class="s3">\n\n</span><span class="s1">export const RouterContext = React.createContext&lt;NextRouter | null&gt;(null)</span><span class="s3">\n\n</span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n  </span><span class="s1">RouterContext.displayName = 'RouterContext'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { BuildManifest } from '../../server/get-page-files'</span><span class="s3">\n</span><span class="s1">import type { ServerRuntime } from '../../types'</span><span class="s3">\n</span><span class="s1">import type { NEXT_DATA } from './utils'</span><span class="s3">\n</span><span class="s1">import type { NextFontManifest } from '../../build/webpack/plugins/next-font-manifest-plugin'</span><span class="s3">\n</span><span class="s1">import type { DeepReadonly } from './deep-readonly'</span><span class="s3">\n\n</span><span class="s1">import { createContext, useContext, type JSX } from 'react'</span><span class="s3">\n\n</span><span class="s1">export type HtmlProps = {</span><span class="s3">\n  </span><span class="s1">__NEXT_DATA__: NEXT_DATA</span><span class="s3">\n  </span><span class="s1">nonce?: string</span><span class="s3">\n  </span><span class="s1">dangerousAsPath: string</span><span class="s3">\n  </span><span class="s1">docComponentsRendered: {</span><span class="s3">\n    </span><span class="s1">Html?: boolean</span><span class="s3">\n    </span><span class="s1">Main?: boolean</span><span class="s3">\n    </span><span class="s1">Head?: boolean</span><span class="s3">\n    </span><span class="s1">NextScript?: boolean</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">buildManifest: BuildManifest</span><span class="s3">\n  </span><span class="s1">ampPath: string</span><span class="s3">\n  </span><span class="s1">inAmpMode: boolean</span><span class="s3">\n  </span><span class="s1">hybridAmp: boolean</span><span class="s3">\n  </span><span class="s1">isDevelopment: boolean</span><span class="s3">\n  </span><span class="s1">dynamicImports: string[]</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* This manifest is only needed for Pages dir, Production, Webpack</span><span class="s3">\n   </span><span class="s1">* @see https://github.com/vercel/next.js/pull/72959</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">dynamicCssManifest: Set&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">assetPrefix?: string</span><span class="s3">\n  </span><span class="s1">canonicalBase: string</span><span class="s3">\n  </span><span class="s1">headTags: any[]</span><span class="s3">\n  </span><span class="s1">unstable_runtimeJS?: false</span><span class="s3">\n  </span><span class="s1">unstable_JsPreload?: false</span><span class="s3">\n  </span><span class="s1">assetQueryString: string</span><span class="s3">\n  </span><span class="s1">scriptLoader: {</span><span class="s3">\n    </span><span class="s1">afterInteractive?: string[]</span><span class="s3">\n    </span><span class="s1">beforeInteractive?: any[]</span><span class="s3">\n    </span><span class="s1">worker?: any[]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">locale?: string</span><span class="s3">\n  </span><span class="s1">disableOptimizedLoading?: boolean</span><span class="s3">\n  </span><span class="s1">styles?: React.ReactElement[] | Iterable&lt;React.ReactNode&gt;</span><span class="s3">\n  </span><span class="s1">head?: Array&lt;JSX.Element | null&gt;</span><span class="s3">\n  </span><span class="s1">crossOrigin?: 'anonymous' | 'use-credentials' | '' | undefined</span><span class="s3">\n  </span><span class="s1">optimizeCss?: any</span><span class="s3">\n  </span><span class="s1">nextConfigOutput?: 'standalone' | 'export'</span><span class="s3">\n  </span><span class="s1">nextScriptWorkers?: boolean</span><span class="s3">\n  </span><span class="s1">runtime?: ServerRuntime</span><span class="s3">\n  </span><span class="s1">hasConcurrentFeatures?: boolean</span><span class="s3">\n  </span><span class="s1">largePageDataBytes?: number</span><span class="s3">\n  </span><span class="s1">nextFontManifest?: DeepReadonly&lt;NextFontManifest&gt;</span><span class="s3">\n  </span><span class="s1">experimentalClientTraceMetadata?: string[]</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const HtmlContext = createContext&lt;HtmlProps | undefined&gt;(undefined)</span><span class="s3">\n</span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n  </span><span class="s1">HtmlContext.displayName = 'HtmlContext'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function useHtmlContext() {</span><span class="s3">\n  </span><span class="s1">const context = useContext(HtmlContext)</span><span class="s3">\n\n  </span><span class="s1">if (!context) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`&lt;Html&gt; should not be imported outside of pages/_document.</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n        </span><span class="s1">'Read more: https://nextjs.org/docs/messages/no-document-import-in-page'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return context</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export enum RedirectStatusCode {</span><span class="s3">\n  </span><span class="s1">SeeOther = 303,</span><span class="s3">\n  </span><span class="s1">TemporaryRedirect = 307,</span><span class="s3">\n  </span><span class="s1">PermanentRedirect = 308,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { RedirectStatusCode } from '../client/components/redirect-status-code'</span><span class="s3">\n\n</span><span class="s1">export const allowedStatusCodes = new Set([301, 302, 303, 307, 308])</span><span class="s3">\n\n</span><span class="s1">export function getRedirectStatus(route: {</span><span class="s3">\n  </span><span class="s1">statusCode?: number</span><span class="s3">\n  </span><span class="s1">permanent?: boolean</span><span class="s3">\n</span><span class="s1">}): number {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">route.statusCode ||</span><span class="s3">\n    </span><span class="s1">(route.permanent</span><span class="s3">\n      </span><span class="s1">? RedirectStatusCode.PermanentRedirect</span><span class="s3">\n      </span><span class="s1">: RedirectStatusCode.TemporaryRedirect)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// for redirects we restrict matching /_next and for all routes</span><span class="s3">\n</span><span class="s1">// we add an optional trailing slash at the end for easier</span><span class="s3">\n</span><span class="s1">// configuring between trailingSlash: true/false</span><span class="s3">\n</span><span class="s1">export function modifyRouteRegex(regex: string, restrictedPaths?: string[]) {</span><span class="s3">\n  </span><span class="s1">if (restrictedPaths) {</span><span class="s3">\n    </span><span class="s1">regex = regex.replace(</span><span class="s3">\n      </span><span class="s1">/</span><span class="s3">\\</span><span class="s1">^/,</span><span class="s3">\n      </span><span class="s1">`^(?!${restrictedPaths</span><span class="s3">\n        </span><span class="s1">.map((path) =&gt; path.replace(/</span><span class="s3">\\</span><span class="s1">//g, '</span><span class="s3">\\\\</span><span class="s1">/'))</span><span class="s3">\n        </span><span class="s1">.join('|')})`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">regex = regex.replace(/</span><span class="s3">\\</span><span class="s1">$$/, '(?:</span><span class="s3">\\\\</span><span class="s1">/)?$')</span><span class="s3">\n  </span><span class="s1">return regex</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import React from 'react'</span><span class="s3">\n</span><span class="s1">import type { ImageConfigComplete } from './image-config'</span><span class="s3">\n</span><span class="s1">import { imageConfigDefault } from './image-config'</span><span class="s3">\n\n</span><span class="s1">export const ImageConfigContext =</span><span class="s3">\n  </span><span class="s1">React.createContext&lt;ImageConfigComplete&gt;(imageConfigDefault)</span><span class="s3">\n\n</span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n  </span><span class="s1">ImageConfigContext.displayName = 'ImageConfigContext'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export const VALID_LOADERS = [</span><span class="s3">\n  </span><span class="s1">'default',</span><span class="s3">\n  </span><span class="s1">'imgix',</span><span class="s3">\n  </span><span class="s1">'cloudinary',</span><span class="s3">\n  </span><span class="s1">'akamai',</span><span class="s3">\n  </span><span class="s1">'custom',</span><span class="s3">\n</span><span class="s1">] as const</span><span class="s3">\n\n</span><span class="s1">export type LoaderValue = (typeof VALID_LOADERS)[number]</span><span class="s3">\n\n</span><span class="s1">export type ImageLoaderProps = {</span><span class="s3">\n  </span><span class="s1">src: string</span><span class="s3">\n  </span><span class="s1">width: number</span><span class="s3">\n  </span><span class="s1">quality?: number</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type ImageLoaderPropsWithConfig = ImageLoaderProps &amp; {</span><span class="s3">\n  </span><span class="s1">config: Readonly&lt;ImageConfig&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type LocalPattern = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Can be literal or wildcard.</span><span class="s3">\n   </span><span class="s1">* Single `*` matches a single path segment.</span><span class="s3">\n   </span><span class="s1">* Double `**` matches any number of path segments.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">pathname?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Can be literal query string such as `?v=1` or</span><span class="s3">\n   </span><span class="s1">* empty string meaning no query string.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">search?: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type RemotePattern = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Must be `http` or `https`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">protocol?: 'http' | 'https'</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Can be literal or wildcard.</span><span class="s3">\n   </span><span class="s1">* Single `*` matches a single subdomain.</span><span class="s3">\n   </span><span class="s1">* Double `**` matches any number of subdomains.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">hostname: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Can be literal port such as `8080` or empty string</span><span class="s3">\n   </span><span class="s1">* meaning no port.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">port?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Can be literal or wildcard.</span><span class="s3">\n   </span><span class="s1">* Single `*` matches a single path segment.</span><span class="s3">\n   </span><span class="s1">* Double `**` matches any number of path segments.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">pathname?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Can be literal query string such as `?v=1` or</span><span class="s3">\n   </span><span class="s1">* empty string meaning no query string.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">search?: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type ImageFormat = 'image/avif' | 'image/webp'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Image configurations</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @see [Image configuration options](https://nextjs.org/docs/api-reference/next/image#configuration-options)</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type ImageConfigComplete = {</span><span class="s3">\n  </span><span class="s1">/** @see [Device sizes documentation](https://nextjs.org/docs/api-reference/next/image#device-sizes) */</span><span class="s3">\n  </span><span class="s1">deviceSizes: number[]</span><span class="s3">\n\n  </span><span class="s1">/** @see [Image sizing documentation](https://nextjs.org/docs/app/building-your-application/optimizing/images#image-sizing) */</span><span class="s3">\n  </span><span class="s1">imageSizes: number[]</span><span class="s3">\n\n  </span><span class="s1">/** @see [Image loaders configuration](https://nextjs.org/docs/api-reference/next/legacy/image#loader) */</span><span class="s3">\n  </span><span class="s1">loader: LoaderValue</span><span class="s3">\n\n  </span><span class="s1">/** @see [Image loader configuration](https://nextjs.org/docs/app/api-reference/components/image#path) */</span><span class="s3">\n  </span><span class="s1">path: string</span><span class="s3">\n\n  </span><span class="s1">/** @see [Image loader configuration](https://nextjs.org/docs/api-reference/next/image#loader-configuration) */</span><span class="s3">\n  </span><span class="s1">loaderFile: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @deprecated Use `remotePatterns` instead.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">domains: string[]</span><span class="s3">\n\n  </span><span class="s1">/** @see [Disable static image import configuration](https://nextjs.org/docs/api-reference/next/image#disable-static-imports) */</span><span class="s3">\n  </span><span class="s1">disableStaticImages: boolean</span><span class="s3">\n\n  </span><span class="s1">/** @see [Cache behavior](https://nextjs.org/docs/api-reference/next/image#caching-behavior) */</span><span class="s3">\n  </span><span class="s1">minimumCacheTTL: number</span><span class="s3">\n\n  </span><span class="s1">/** @see [Acceptable formats](https://nextjs.org/docs/api-reference/next/image#acceptable-formats) */</span><span class="s3">\n  </span><span class="s1">formats: ImageFormat[]</span><span class="s3">\n\n  </span><span class="s1">/** @see [Dangerously Allow SVG](https://nextjs.org/docs/api-reference/next/image#dangerously-allow-svg) */</span><span class="s3">\n  </span><span class="s1">dangerouslyAllowSVG: boolean</span><span class="s3">\n\n  </span><span class="s1">/** @see [Content Security Policy](https://nextjs.org/docs/api-reference/next/image#contentsecuritypolicy) */</span><span class="s3">\n  </span><span class="s1">contentSecurityPolicy: string</span><span class="s3">\n\n  </span><span class="s1">/** @see [Content Disposition Type](https://nextjs.org/docs/api-reference/next/image#contentdispositiontype) */</span><span class="s3">\n  </span><span class="s1">contentDispositionType: 'inline' | 'attachment'</span><span class="s3">\n\n  </span><span class="s1">/** @see [Remote Patterns](https://nextjs.org/docs/api-reference/next/image#remotepatterns) */</span><span class="s3">\n  </span><span class="s1">remotePatterns: Array&lt;URL | RemotePattern&gt;</span><span class="s3">\n\n  </span><span class="s1">/** @see [Local Patterns](https://nextjs.org/docs/api-reference/next/image#localPatterns) */</span><span class="s3">\n  </span><span class="s1">localPatterns: LocalPattern[] | undefined</span><span class="s3">\n\n  </span><span class="s1">/** @see [Qualities](https://nextjs.org/docs/api-reference/next/image#qualities) */</span><span class="s3">\n  </span><span class="s1">qualities: number[] | undefined</span><span class="s3">\n\n  </span><span class="s1">/** @see [Unoptimized](https://nextjs.org/docs/api-reference/next/image#unoptimized) */</span><span class="s3">\n  </span><span class="s1">unoptimized: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type ImageConfig = Partial&lt;ImageConfigComplete&gt;</span><span class="s3">\n\n</span><span class="s1">export const imageConfigDefault: ImageConfigComplete = {</span><span class="s3">\n  </span><span class="s1">deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],</span><span class="s3">\n  </span><span class="s1">imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],</span><span class="s3">\n  </span><span class="s1">path: '/_next/image',</span><span class="s3">\n  </span><span class="s1">loader: 'default',</span><span class="s3">\n  </span><span class="s1">loaderFile: '',</span><span class="s3">\n  </span><span class="s1">domains: [],</span><span class="s3">\n  </span><span class="s1">disableStaticImages: false,</span><span class="s3">\n  </span><span class="s1">minimumCacheTTL: 60,</span><span class="s3">\n  </span><span class="s1">formats: ['image/webp'],</span><span class="s3">\n  </span><span class="s1">dangerouslyAllowSVG: false,</span><span class="s3">\n  </span><span class="s1">contentSecurityPolicy: `script-src 'none'; frame-src 'none'; sandbox;`,</span><span class="s3">\n  </span><span class="s1">contentDispositionType: 'attachment',</span><span class="s3">\n  </span><span class="s1">localPatterns: undefined, // default: allow all local images</span><span class="s3">\n  </span><span class="s1">remotePatterns: [], // default: allow no remote images</span><span class="s3">\n  </span><span class="s1">qualities: undefined, // default: allow all qualities</span><span class="s3">\n  </span><span class="s1">unoptimized: false,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { NextParsedUrlQuery } from './request-meta'</span><span class="s3">\n\n</span><span class="s1">import { NEXT_RSC_UNION_QUERY } from '../client/components/app-router-headers'</span><span class="s3">\n\n</span><span class="s1">const INTERNAL_QUERY_NAMES = [NEXT_RSC_UNION_QUERY] as const</span><span class="s3">\n\n</span><span class="s1">export function stripInternalQueries(query: NextParsedUrlQuery) {</span><span class="s3">\n  </span><span class="s1">for (const name of INTERNAL_QUERY_NAMES) {</span><span class="s3">\n    </span><span class="s1">delete query[name]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function stripInternalSearchParams&lt;T extends string | URL&gt;(url: T): T {</span><span class="s3">\n  </span><span class="s1">const isStringUrl = typeof url === 'string'</span><span class="s3">\n  </span><span class="s1">const instance = isStringUrl ? new URL(url) : (url as URL)</span><span class="s3">\n\n  </span><span class="s1">instance.searchParams.delete(NEXT_RSC_UNION_QUERY)</span><span class="s3">\n\n  </span><span class="s1">return (isStringUrl ? instance.toString() : instance) as T</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;'use client'</span><span class="s3">\n\n</span><span class="s1">import { createContext } from 'react'</span><span class="s3">\n</span><span class="s1">import type { Params } from '../../server/request/params'</span><span class="s3">\n\n</span><span class="s1">export const SearchParamsContext = createContext&lt;URLSearchParams | null&gt;(null)</span><span class="s3">\n</span><span class="s1">export const PathnameContext = createContext&lt;string | null&gt;(null)</span><span class="s3">\n</span><span class="s1">export const PathParamsContext = createContext&lt;Params | null&gt;(null)</span><span class="s3">\n\n</span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n  </span><span class="s1">SearchParamsContext.displayName = 'SearchParamsContext'</span><span class="s3">\n  </span><span class="s1">PathnameContext.displayName = 'PathnameContext'</span><span class="s3">\n  </span><span class="s1">PathParamsContext.displayName = 'PathParamsContext'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { AppRouterInstance } from '../app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import type { Params } from '../../../server/request/params'</span><span class="s3">\n</span><span class="s1">import type { NextRouter } from './router'</span><span class="s3">\n\n</span><span class="s1">import React, { useMemo, useRef } from 'react'</span><span class="s3">\n</span><span class="s1">import { PathnameContext } from '../hooks-client-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import { isDynamicRoute } from './utils'</span><span class="s3">\n</span><span class="s1">import { asPathToSearchParams } from './utils/as-path-to-search-params'</span><span class="s3">\n</span><span class="s1">import { getRouteRegex } from './utils/route-regex'</span><span class="s3">\n\n</span><span class="s1">/** It adapts a Pages Router (`NextRouter`) to the App Router Instance. */</span><span class="s3">\n</span><span class="s1">export function adaptForAppRouterInstance(</span><span class="s3">\n  </span><span class="s1">pagesRouter: NextRouter</span><span class="s3">\n</span><span class="s1">): AppRouterInstance {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">back() {</span><span class="s3">\n      </span><span class="s1">pagesRouter.back()</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">forward() {</span><span class="s3">\n      </span><span class="s1">pagesRouter.forward()</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">refresh() {</span><span class="s3">\n      </span><span class="s1">pagesRouter.reload()</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">hmrRefresh() {},</span><span class="s3">\n    </span><span class="s1">push(href, { scroll } = {}) {</span><span class="s3">\n      </span><span class="s1">void pagesRouter.push(href, undefined, { scroll })</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">replace(href, { scroll } = {}) {</span><span class="s3">\n      </span><span class="s1">void pagesRouter.replace(href, undefined, { scroll })</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">prefetch(href) {</span><span class="s3">\n      </span><span class="s1">void pagesRouter.prefetch(href)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* adaptForSearchParams transforms the ParsedURLQuery into URLSearchParams.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param router the router that contains the query.</span><span class="s3">\n </span><span class="s1">* @returns the search params in the URLSearchParams format</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function adaptForSearchParams(</span><span class="s3">\n  </span><span class="s1">router: Pick&lt;NextRouter, 'isReady' | 'query' | 'asPath'&gt;</span><span class="s3">\n</span><span class="s1">): URLSearchParams {</span><span class="s3">\n  </span><span class="s1">if (!router.isReady || !router.query) {</span><span class="s3">\n    </span><span class="s1">return new URLSearchParams()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return asPathToSearchParams(router.asPath)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function adaptForPathParams(</span><span class="s3">\n  </span><span class="s1">router: Pick&lt;NextRouter, 'isReady' | 'pathname' | 'query' | 'asPath'&gt;</span><span class="s3">\n</span><span class="s1">): Params | null {</span><span class="s3">\n  </span><span class="s1">if (!router.isReady || !router.query) {</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const pathParams: Params = {}</span><span class="s3">\n  </span><span class="s1">const routeRegex = getRouteRegex(router.pathname)</span><span class="s3">\n  </span><span class="s1">const keys = Object.keys(routeRegex.groups)</span><span class="s3">\n  </span><span class="s1">for (const key of keys) {</span><span class="s3">\n    </span><span class="s1">pathParams[key] = router.query[key]!</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return pathParams</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function PathnameContextProviderAdapter({</span><span class="s3">\n  </span><span class="s1">children,</span><span class="s3">\n  </span><span class="s1">router,</span><span class="s3">\n  </span><span class="s1">...props</span><span class="s3">\n</span><span class="s1">}: React.PropsWithChildren&lt;{</span><span class="s3">\n  </span><span class="s1">router: Pick&lt;NextRouter, 'pathname' | 'asPath' | 'isReady' | 'isFallback'&gt;</span><span class="s3">\n  </span><span class="s1">isAutoExport: boolean</span><span class="s3">\n</span><span class="s1">}&gt;) {</span><span class="s3">\n  </span><span class="s1">const ref = useRef(props.isAutoExport)</span><span class="s3">\n  </span><span class="s1">const value = useMemo(() =&gt; {</span><span class="s3">\n    </span><span class="s1">// isAutoExport is only ever `true` on the first render from the server,</span><span class="s3">\n    </span><span class="s1">// so reset it to `false` after we read it for the first time as `true`. If</span><span class="s3">\n    </span><span class="s1">// we don't use the value, then we don't need it.</span><span class="s3">\n    </span><span class="s1">const isAutoExport = ref.current</span><span class="s3">\n    </span><span class="s1">if (isAutoExport) {</span><span class="s3">\n      </span><span class="s1">ref.current = false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// When the route is a dynamic route, we need to do more processing to</span><span class="s3">\n    </span><span class="s1">// determine if we need to stop showing the pathname.</span><span class="s3">\n    </span><span class="s1">if (isDynamicRoute(router.pathname)) {</span><span class="s3">\n      </span><span class="s1">// When the router is rendering the fallback page, it can't possibly know</span><span class="s3">\n      </span><span class="s1">// the path, so return `null` here. Read more about fallback pages over</span><span class="s3">\n      </span><span class="s1">// at:</span><span class="s3">\n      </span><span class="s1">// https://nextjs.org/docs/api-reference/data-fetching/get-static-paths#fallback-pages</span><span class="s3">\n      </span><span class="s1">if (router.isFallback) {</span><span class="s3">\n        </span><span class="s1">return null</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// When `isAutoExport` is true, meaning this is a page page has been</span><span class="s3">\n      </span><span class="s1">// automatically statically optimized, and the router is not ready, then</span><span class="s3">\n      </span><span class="s1">// we can't know the pathname yet. Read more about automatic static</span><span class="s3">\n      </span><span class="s1">// optimization at:</span><span class="s3">\n      </span><span class="s1">// https://nextjs.org/docs/advanced-features/automatic-static-optimization</span><span class="s3">\n      </span><span class="s1">if (isAutoExport &amp;&amp; !router.isReady) {</span><span class="s3">\n        </span><span class="s1">return null</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// The `router.asPath` contains the pathname seen by the browser (including</span><span class="s3">\n    </span><span class="s1">// any query strings), so it should have that stripped. Read more about the</span><span class="s3">\n    </span><span class="s1">// `asPath` option over at:</span><span class="s3">\n    </span><span class="s1">// https://nextjs.org/docs/api-reference/next/router#router-object</span><span class="s3">\n    </span><span class="s1">let url: URL</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">url = new URL(router.asPath, 'http://f')</span><span class="s3">\n    </span><span class="s1">} catch (_) {</span><span class="s3">\n      </span><span class="s1">// fallback to / for invalid asPath values e.g. //</span><span class="s3">\n      </span><span class="s1">return '/'</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return url.pathname</span><span class="s3">\n  </span><span class="s1">}, [router.asPath, router.isFallback, router.isReady, router.pathname])</span><span class="s3">\n\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">&lt;PathnameContext.Provider value={value}&gt;</span><span class="s3">\n      </span><span class="s1">{children}</span><span class="s3">\n    </span><span class="s1">&lt;/PathnameContext.Provider&gt;</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;'use client'</span><span class="s3">\n\n</span><span class="s1">import type { FetchServerResponseResult } from '../../client/components/router-reducer/fetch-server-response'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">FocusAndScrollRef,</span><span class="s3">\n  </span><span class="s1">PrefetchKind,</span><span class="s3">\n</span><span class="s1">} from '../../client/components/router-reducer/router-reducer-types'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">FlightRouterState,</span><span class="s3">\n  </span><span class="s1">FlightSegmentPath,</span><span class="s3">\n</span><span class="s1">} from '../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import React from 'react'</span><span class="s3">\n\n</span><span class="s1">export type ChildSegmentMap = Map&lt;string, CacheNode&gt;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Cache node used in app-router / layout-router.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type CacheNode = ReadyCacheNode | LazyCacheNode</span><span class="s3">\n\n</span><span class="s1">export type LoadingModuleData =</span><span class="s3">\n  </span><span class="s1">| [React.JSX.Element, React.ReactNode, React.ReactNode]</span><span class="s3">\n  </span><span class="s1">| null</span><span class="s3">\n\n</span><span class="s1">/** viewport metadata node */</span><span class="s3">\n</span><span class="s1">export type HeadData = React.ReactNode</span><span class="s3">\n\n</span><span class="s1">export type LazyCacheNode = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When rsc is null, this is a lazily-initialized cache node.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* If the app attempts to render it, it triggers a lazy data fetch,</span><span class="s3">\n   </span><span class="s1">* postpones the render, and schedules an update to a new tree.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* TODO: This mechanism should not be used when PPR is enabled, though it</span><span class="s3">\n   </span><span class="s1">* currently is in some cases until we've implemented partial</span><span class="s3">\n   </span><span class="s1">* segment fetching.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">rsc: null</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A prefetched version of the segment data. See explanation in corresponding</span><span class="s3">\n   </span><span class="s1">* field of ReadyCacheNode (below).</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* Since LazyCacheNode mostly only exists in the non-PPR implementation, this</span><span class="s3">\n   </span><span class="s1">* will usually be null, but it could have been cloned from a previous</span><span class="s3">\n   </span><span class="s1">* CacheNode that was created by the PPR implementation. Eventually we want</span><span class="s3">\n   </span><span class="s1">* to migrate everything away from LazyCacheNode entirely.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">prefetchRsc: React.ReactNode</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* A pending response for the lazy data fetch. If this is not present</span><span class="s3">\n   </span><span class="s1">* during render, it is lazily created.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">lazyData: Promise&lt;FetchServerResponseResult&gt; | null</span><span class="s3">\n\n  </span><span class="s1">prefetchHead: HeadData | null</span><span class="s3">\n\n  </span><span class="s1">head: HeadData</span><span class="s3">\n\n  </span><span class="s1">loading: LoadingModuleData | Promise&lt;LoadingModuleData&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Child parallel routes.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">parallelRoutes: Map&lt;string, ChildSegmentMap&gt;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The timestamp of the navigation that last updated the CacheNode's data. If</span><span class="s3">\n   </span><span class="s1">* a CacheNode is reused from a previous navigation, this value is not</span><span class="s3">\n   </span><span class="s1">* updated. Used to track the staleness of the data.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">navigatedAt: number</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type ReadyCacheNode = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When rsc is not null, it represents the RSC data for the</span><span class="s3">\n   </span><span class="s1">* corresponding segment.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* `null` is a valid React Node but because segment data is always a</span><span class="s3">\n   </span><span class="s1">* &lt;LayoutRouter&gt; component, we can use `null` to represent empty.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* TODO: For additional type safety, update this type to</span><span class="s3">\n   </span><span class="s1">* Exclude&lt;React.ReactNode, null&gt;. Need to update createEmptyCacheNode to</span><span class="s3">\n   </span><span class="s1">* accept rsc as an argument, or just inline the callers.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">rsc: React.ReactNode</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Represents a static version of the segment that can be shown immediately,</span><span class="s3">\n   </span><span class="s1">* and may or may not contain dynamic holes. It's prefetched before a</span><span class="s3">\n   </span><span class="s1">* navigation occurs.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* During rendering, we will choose whether to render `rsc` or `prefetchRsc`</span><span class="s3">\n   </span><span class="s1">* with `useDeferredValue`. As with the `rsc` field, a value of `null` means</span><span class="s3">\n   </span><span class="s1">* no value was provided. In this case, the LayoutRouter will go straight to</span><span class="s3">\n   </span><span class="s1">* rendering the `rsc` value; if that one is also missing, it will suspend and</span><span class="s3">\n   </span><span class="s1">* trigger a lazy fetch.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">prefetchRsc: React.ReactNode</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* There should never be a lazy data request in this case.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">lazyData: null</span><span class="s3">\n  </span><span class="s1">prefetchHead: HeadData | null</span><span class="s3">\n\n  </span><span class="s1">head: HeadData</span><span class="s3">\n\n  </span><span class="s1">loading: LoadingModuleData | Promise&lt;LoadingModuleData&gt;</span><span class="s3">\n\n  </span><span class="s1">parallelRoutes: Map&lt;string, ChildSegmentMap&gt;</span><span class="s3">\n\n  </span><span class="s1">navigatedAt: number</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface NavigateOptions {</span><span class="s3">\n  </span><span class="s1">scroll?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface PrefetchOptions {</span><span class="s3">\n  </span><span class="s1">kind: PrefetchKind</span><span class="s3">\n  </span><span class="s1">onInvalidate?: () =&gt; void</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface AppRouterInstance {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Navigate to the previous history entry.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">back(): void</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Navigate to the next history entry.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">forward(): void</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Refresh the current page.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">refresh(): void</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Refresh the current page. Use in development only.</span><span class="s3">\n   </span><span class="s1">* @internal</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">hmrRefresh(): void</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Navigate to the provided href.</span><span class="s3">\n   </span><span class="s1">* Pushes a new history entry.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">push(href: string, options?: NavigateOptions): void</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Navigate to the provided href.</span><span class="s3">\n   </span><span class="s1">* Replaces the current history entry.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">replace(href: string, options?: NavigateOptions): void</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Prefetch the provided href.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">prefetch(href: string, options?: PrefetchOptions): void</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const AppRouterContext = React.createContext&lt;AppRouterInstance | null&gt;(</span><span class="s3">\n  </span><span class="s1">null</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">export const LayoutRouterContext = React.createContext&lt;{</span><span class="s3">\n  </span><span class="s1">parentTree: FlightRouterState</span><span class="s3">\n  </span><span class="s1">parentCacheNode: CacheNode</span><span class="s3">\n  </span><span class="s1">parentSegmentPath: FlightSegmentPath | null</span><span class="s3">\n  </span><span class="s1">url: string</span><span class="s3">\n</span><span class="s1">} | null&gt;(null)</span><span class="s3">\n\n</span><span class="s1">export const GlobalLayoutRouterContext = React.createContext&lt;{</span><span class="s3">\n  </span><span class="s1">tree: FlightRouterState</span><span class="s3">\n  </span><span class="s1">focusAndScrollRef: FocusAndScrollRef</span><span class="s3">\n  </span><span class="s1">nextUrl: string | null</span><span class="s3">\n</span><span class="s1">}&gt;(null as any)</span><span class="s3">\n\n</span><span class="s1">export const TemplateContext = React.createContext&lt;React.ReactNode&gt;(null as any)</span><span class="s3">\n\n</span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n  </span><span class="s1">AppRouterContext.displayName = 'AppRouterContext'</span><span class="s3">\n  </span><span class="s1">LayoutRouterContext.displayName = 'LayoutRouterContext'</span><span class="s3">\n  </span><span class="s1">GlobalLayoutRouterContext.displayName = 'GlobalLayoutRouterContext'</span><span class="s3">\n  </span><span class="s1">TemplateContext.displayName = 'TemplateContext'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const MissingSlotContext = React.createContext&lt;Set&lt;string&gt;&gt;(new Set())</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const symbolError = Symbol.for('NextjsError')</span><span class="s3">\n\n</span><span class="s1">export function getErrorSource(error: Error): 'server' | 'edge-server' | null {</span><span class="s3">\n  </span><span class="s1">return (error as any)[symbolError] || null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type ErrorSourceType = 'edge-server' | 'server'</span><span class="s3">\n\n</span><span class="s1">export function decorateServerError(error: Error, type: ErrorSourceType) {</span><span class="s3">\n  </span><span class="s1">Object.defineProperty(error, symbolError, {</span><span class="s3">\n    </span><span class="s1">writable: false,</span><span class="s3">\n    </span><span class="s1">enumerable: false,</span><span class="s3">\n    </span><span class="s1">configurable: false,</span><span class="s3">\n    </span><span class="s1">value: type,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// This utility is based on https://github.com/zertosh/htmlescape</span><span class="s3">\n</span><span class="s1">// License: https://github.com/zertosh/htmlescape/blob/0527ca7156a524d256101bb310a9f970f63078ad/LICENSE</span><span class="s3">\n\n</span><span class="s1">const ESCAPE_LOOKUP: { [match: string]: string } = {</span><span class="s3">\n  </span><span class="s1">'&amp;': '</span><span class="s3">\\\\</span><span class="s1">u0026',</span><span class="s3">\n  </span><span class="s1">'&gt;': '</span><span class="s3">\\\\</span><span class="s1">u003e',</span><span class="s3">\n  </span><span class="s1">'&lt;': '</span><span class="s3">\\\\</span><span class="s1">u003c',</span><span class="s3">\n  </span><span class="s1">'</span><span class="s3">\\</span><span class="s1">u2028': '</span><span class="s3">\\\\</span><span class="s1">u2028',</span><span class="s3">\n  </span><span class="s1">'</span><span class="s3">\\</span><span class="s1">u2029': '</span><span class="s3">\\\\</span><span class="s1">u2029',</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const ESCAPE_REGEX = /[&amp;&gt;&lt;</span><span class="s3">\\</span><span class="s1">u2028</span><span class="s3">\\</span><span class="s1">u2029]/g</span><span class="s3">\n\n</span><span class="s1">export function htmlEscapeJsonString(str: string): string {</span><span class="s3">\n  </span><span class="s1">return str.replace(ESCAPE_REGEX, (match) =&gt; ESCAPE_LOOKUP[match])</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { CACHE_ONE_YEAR } from '../../lib/constants'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The revalidate option used internally for pages. A value of `false` means</span><span class="s3">\n </span><span class="s1">* that the page should not be revalidated. A number means that the page</span><span class="s3">\n </span><span class="s1">* should be revalidated after the given number of seconds (this also includes</span><span class="s3">\n </span><span class="s1">* `1` which means to revalidate after 1 second). A value of `0` is not a valid</span><span class="s3">\n </span><span class="s1">* value for this option.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type Revalidate = number | false</span><span class="s3">\n\n</span><span class="s1">export interface CacheControl {</span><span class="s3">\n  </span><span class="s1">revalidate: Revalidate</span><span class="s3">\n  </span><span class="s1">expire: number | undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getCacheControlHeader({</span><span class="s3">\n  </span><span class="s1">revalidate,</span><span class="s3">\n  </span><span class="s1">expire,</span><span class="s3">\n</span><span class="s1">}: CacheControl): string {</span><span class="s3">\n  </span><span class="s1">const swrHeader =</span><span class="s3">\n    </span><span class="s1">typeof revalidate === 'number' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">expire !== undefined &amp;&amp;</span><span class="s3">\n    </span><span class="s1">revalidate &lt; expire</span><span class="s3">\n      </span><span class="s1">? `, stale-while-revalidate=${expire - revalidate}`</span><span class="s3">\n      </span><span class="s1">: ''</span><span class="s3">\n\n  </span><span class="s1">if (revalidate === 0) {</span><span class="s3">\n    </span><span class="s1">return 'private, no-cache, no-store, max-age=0, must-revalidate'</span><span class="s3">\n  </span><span class="s1">} else if (typeof revalidate === 'number') {</span><span class="s3">\n    </span><span class="s1">return `s-maxage=${revalidate}${swrHeader}`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return `s-maxage=${CACHE_ONE_YEAR}${swrHeader}`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export function isInAmpMode({</span><span class="s3">\n  </span><span class="s1">ampFirst = false,</span><span class="s3">\n  </span><span class="s1">hybrid = false,</span><span class="s3">\n  </span><span class="s1">hasQuery = false,</span><span class="s3">\n</span><span class="s1">} = {}): boolean {</span><span class="s3">\n  </span><span class="s1">return ampFirst || (hybrid &amp;&amp; hasQuery)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;'use client'</span><span class="s3">\n\n</span><span class="s1">import React, { useContext, type JSX } from 'react'</span><span class="s3">\n</span><span class="s1">import Effect from './side-effect'</span><span class="s3">\n</span><span class="s1">import { AmpStateContext } from './amp-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import { HeadManagerContext } from './head-manager-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import { isInAmpMode } from './amp-mode'</span><span class="s3">\n</span><span class="s1">import { warnOnce } from './utils/warn-once'</span><span class="s3">\n\n</span><span class="s1">type WithInAmpMode = {</span><span class="s3">\n  </span><span class="s1">inAmpMode?: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function defaultHead(inAmpMode = false): JSX.Element[] {</span><span class="s3">\n  </span><span class="s1">const head = [&lt;meta charSet=</span><span class="s3">\&quot;</span><span class="s1">utf-8</span><span class="s3">\&quot; </span><span class="s1">key=</span><span class="s3">\&quot;</span><span class="s1">charset</span><span class="s3">\&quot; </span><span class="s1">/&gt;]</span><span class="s3">\n  </span><span class="s1">if (!inAmpMode) {</span><span class="s3">\n    </span><span class="s1">head.push(</span><span class="s3">\n      </span><span class="s1">&lt;meta name=</span><span class="s3">\&quot;</span><span class="s1">viewport</span><span class="s3">\&quot; </span><span class="s1">content=</span><span class="s3">\&quot;</span><span class="s1">width=device-width</span><span class="s3">\&quot; </span><span class="s1">key=</span><span class="s3">\&quot;</span><span class="s1">viewport</span><span class="s3">\&quot; </span><span class="s1">/&gt;</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return head</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function onlyReactElement(</span><span class="s3">\n  </span><span class="s1">list: Array&lt;React.ReactElement&lt;any&gt;&gt;,</span><span class="s3">\n  </span><span class="s1">child: React.ReactElement | number | string</span><span class="s3">\n</span><span class="s1">): Array&lt;React.ReactElement&lt;any&gt;&gt; {</span><span class="s3">\n  </span><span class="s1">// React children can be </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">or </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">in this case we ignore them for backwards compat</span><span class="s3">\n  </span><span class="s1">if (typeof child === 'string' || typeof child === 'number') {</span><span class="s3">\n    </span><span class="s1">return list</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Adds support for React.Fragment</span><span class="s3">\n  </span><span class="s1">if (child.type === React.Fragment) {</span><span class="s3">\n    </span><span class="s1">return list.concat(</span><span class="s3">\n      </span><span class="s1">// @ts-expect-error @types/react does not remove fragments but this could also return ReactPortal[]</span><span class="s3">\n      </span><span class="s1">React.Children.toArray(child.props.children).reduce(</span><span class="s3">\n        </span><span class="s1">// @ts-expect-error @types/react does not remove fragments but this could also return ReactPortal[]</span><span class="s3">\n        </span><span class="s1">(</span><span class="s3">\n          </span><span class="s1">fragmentList: Array&lt;React.ReactElement&lt;any&gt;&gt;,</span><span class="s3">\n          </span><span class="s1">fragmentChild: React.ReactElement | number | string</span><span class="s3">\n        </span><span class="s1">): Array&lt;React.ReactElement&lt;any&gt;&gt; =&gt; {</span><span class="s3">\n          </span><span class="s1">if (</span><span class="s3">\n            </span><span class="s1">typeof fragmentChild === 'string' ||</span><span class="s3">\n            </span><span class="s1">typeof fragmentChild === 'number'</span><span class="s3">\n          </span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">return fragmentList</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">return fragmentList.concat(fragmentChild)</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">[]</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return list.concat(child)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const METATYPES = ['name', 'httpEquiv', 'charSet', 'itemProp']</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">returns a function for filtering head child elements</span><span class="s3">\n </span><span class="s1">which shouldn't be duplicated, like &lt;title/&gt;</span><span class="s3">\n </span><span class="s1">Also adds support for deduplicated `key` properties</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function unique() {</span><span class="s3">\n  </span><span class="s1">const keys = new Set()</span><span class="s3">\n  </span><span class="s1">const tags = new Set()</span><span class="s3">\n  </span><span class="s1">const metaTypes = new Set()</span><span class="s3">\n  </span><span class="s1">const metaCategories: { [metatype: string]: Set&lt;string&gt; } = {}</span><span class="s3">\n\n  </span><span class="s1">return (h: React.ReactElement&lt;any&gt;) =&gt; {</span><span class="s3">\n    </span><span class="s1">let isUnique = true</span><span class="s3">\n    </span><span class="s1">let hasKey = false</span><span class="s3">\n\n    </span><span class="s1">if (h.key &amp;&amp; typeof h.key !== 'number' &amp;&amp; h.key.indexOf('$') &gt; 0) {</span><span class="s3">\n      </span><span class="s1">hasKey = true</span><span class="s3">\n      </span><span class="s1">const key = h.key.slice(h.key.indexOf('$') + 1)</span><span class="s3">\n      </span><span class="s1">if (keys.has(key)) {</span><span class="s3">\n        </span><span class="s1">isUnique = false</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">keys.add(key)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// eslint-disable-next-line default-case</span><span class="s3">\n    </span><span class="s1">switch (h.type) {</span><span class="s3">\n      </span><span class="s1">case 'title':</span><span class="s3">\n      </span><span class="s1">case 'base':</span><span class="s3">\n        </span><span class="s1">if (tags.has(h.type)) {</span><span class="s3">\n          </span><span class="s1">isUnique = false</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">tags.add(h.type)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">case 'meta':</span><span class="s3">\n        </span><span class="s1">for (let i = 0, len = METATYPES.length; i &lt; len; i++) {</span><span class="s3">\n          </span><span class="s1">const metatype = METATYPES[i]</span><span class="s3">\n          </span><span class="s1">if (!h.props.hasOwnProperty(metatype)) continue</span><span class="s3">\n\n          </span><span class="s1">if (metatype === 'charSet') {</span><span class="s3">\n            </span><span class="s1">if (metaTypes.has(metatype)) {</span><span class="s3">\n              </span><span class="s1">isUnique = false</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">metaTypes.add(metatype)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">const category = h.props[metatype]</span><span class="s3">\n            </span><span class="s1">const categories = metaCategories[metatype] || new Set()</span><span class="s3">\n            </span><span class="s1">if ((metatype !== 'name' || !hasKey) &amp;&amp; categories.has(category)) {</span><span class="s3">\n              </span><span class="s1">isUnique = false</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">categories.add(category)</span><span class="s3">\n              </span><span class="s1">metaCategories[metatype] = categories</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return isUnique</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param headChildrenElements List of children of &lt;Head&gt;</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function reduceComponents&lt;T extends {} &amp; WithInAmpMode&gt;(</span><span class="s3">\n  </span><span class="s1">headChildrenElements: Array&lt;React.ReactElement&lt;any&gt;&gt;,</span><span class="s3">\n  </span><span class="s1">props: T</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const { inAmpMode } = props</span><span class="s3">\n  </span><span class="s1">return headChildrenElements</span><span class="s3">\n    </span><span class="s1">.reduce(onlyReactElement, [])</span><span class="s3">\n    </span><span class="s1">.reverse()</span><span class="s3">\n    </span><span class="s1">.concat(defaultHead(inAmpMode).reverse())</span><span class="s3">\n    </span><span class="s1">.filter(unique())</span><span class="s3">\n    </span><span class="s1">.reverse()</span><span class="s3">\n    </span><span class="s1">.map((c: React.ReactElement&lt;any&gt;, i: number) =&gt; {</span><span class="s3">\n      </span><span class="s1">const key = c.key || i</span><span class="s3">\n      </span><span class="s1">if (process.env.NODE_ENV === 'development') {</span><span class="s3">\n        </span><span class="s1">// omit JSON-LD structured data snippets from the warning</span><span class="s3">\n        </span><span class="s1">if (c.type === 'script' &amp;&amp; c.props['type'] !== 'application/ld+json') {</span><span class="s3">\n          </span><span class="s1">const srcMessage = c.props['src']</span><span class="s3">\n            </span><span class="s1">? `&lt;script&gt; tag with src=</span><span class="s3">\&quot;</span><span class="s1">${c.props['src']}</span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\n            </span><span class="s1">: `inline &lt;script&gt;`</span><span class="s3">\n          </span><span class="s1">warnOnce(</span><span class="s3">\n            </span><span class="s1">`Do not add &lt;script&gt; tags using next/head (see ${srcMessage}). Use next/script instead. </span><span class="s3">\\</span><span class="s1">nSee more info here: https://nextjs.org/docs/messages/no-script-tags-in-head-component`</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">} else if (c.type === 'link' &amp;&amp; c.props['rel'] === 'stylesheet') {</span><span class="s3">\n          </span><span class="s1">warnOnce(</span><span class="s3">\n            </span><span class="s1">`Do not add stylesheets using next/head (see &lt;link rel=</span><span class="s3">\&quot;</span><span class="s1">stylesheet</span><span class="s3">\&quot;</span><span class="s1">&gt; tag with href=</span><span class="s3">\&quot;</span><span class="s1">${c.props['href']}</span><span class="s3">\&quot;</span><span class="s1">). Use Document instead. </span><span class="s3">\\</span><span class="s1">nSee more info here: https://nextjs.org/docs/messages/no-stylesheets-in-head-component`</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return React.cloneElement(c, { key })</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This component injects elements to `&lt;head&gt;` of your page.</span><span class="s3">\n </span><span class="s1">* To avoid duplicated `tags` in `&lt;head&gt;` you can use the `key` property, which will make sure every tag is only rendered once.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function Head({ children }: { children: React.ReactNode }) {</span><span class="s3">\n  </span><span class="s1">const ampState = useContext(AmpStateContext)</span><span class="s3">\n  </span><span class="s1">const headManager = useContext(HeadManagerContext)</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">&lt;Effect</span><span class="s3">\n      </span><span class="s1">reduceComponentsToState={reduceComponents}</span><span class="s3">\n      </span><span class="s1">headManager={headManager}</span><span class="s3">\n      </span><span class="s1">inAmpMode={isInAmpMode(ampState)}</span><span class="s3">\n    </span><span class="s1">&gt;</span><span class="s3">\n      </span><span class="s1">{children}</span><span class="s3">\n    </span><span class="s1">&lt;/Effect&gt;</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default Head</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { ESCAPE_REGEX } from '../htmlescape'</span><span class="s3">\n\n</span><span class="s1">export function getScriptNonceFromHeader(</span><span class="s3">\n  </span><span class="s1">cspHeaderValue: string</span><span class="s3">\n</span><span class="s1">): string | undefined {</span><span class="s3">\n  </span><span class="s1">const directives = cspHeaderValue</span><span class="s3">\n    </span><span class="s1">// Directives are split by ';'.</span><span class="s3">\n    </span><span class="s1">.split(';')</span><span class="s3">\n    </span><span class="s1">.map((directive) =&gt; directive.trim())</span><span class="s3">\n\n  </span><span class="s1">// First try to find the directive for the 'script-src', otherwise try to</span><span class="s3">\n  </span><span class="s1">// fallback to the 'default-src'.</span><span class="s3">\n  </span><span class="s1">const directive =</span><span class="s3">\n    </span><span class="s1">directives.find((dir) =&gt; dir.startsWith('script-src')) ||</span><span class="s3">\n    </span><span class="s1">directives.find((dir) =&gt; dir.startsWith('default-src'))</span><span class="s3">\n\n  </span><span class="s1">// If no directive could be found, then we're done.</span><span class="s3">\n  </span><span class="s1">if (!directive) {</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Extract the nonce from the directive</span><span class="s3">\n  </span><span class="s1">const nonce = directive</span><span class="s3">\n    </span><span class="s1">.split(' ')</span><span class="s3">\n    </span><span class="s1">// Remove the 'strict-src'/'default-src' string, this can't be the nonce.</span><span class="s3">\n    </span><span class="s1">.slice(1)</span><span class="s3">\n    </span><span class="s1">.map((source) =&gt; source.trim())</span><span class="s3">\n    </span><span class="s1">// Find the first source with the 'nonce-' prefix.</span><span class="s3">\n    </span><span class="s1">.find(</span><span class="s3">\n      </span><span class="s1">(source) =&gt;</span><span class="s3">\n        </span><span class="s1">source.startsWith(</span><span class="s3">\&quot;</span><span class="s1">'nonce-</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">source.length &gt; 8 &amp;&amp;</span><span class="s3">\n        </span><span class="s1">source.endsWith(</span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">// Grab the nonce by trimming the 'nonce-' prefix.</span><span class="s3">\n    </span><span class="s1">?.slice(7, -1)</span><span class="s3">\n\n  </span><span class="s1">// If we could't find the nonce, then we're done.</span><span class="s3">\n  </span><span class="s1">if (!nonce) {</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Don't accept the nonce value if it contains HTML escape characters.</span><span class="s3">\n  </span><span class="s1">// Technically, the spec requires a base64'd value, but this is just an</span><span class="s3">\n  </span><span class="s1">// extra layer.</span><span class="s3">\n  </span><span class="s1">if (ESCAPE_REGEX.test(nonce)) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">'Nonce value from Content-Security-Policy contained HTML escape characters.</span><span class="s3">\\</span><span class="s1">nLearn more: https://nextjs.org/docs/messages/nonce-contained-invalid-characters'</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return nonce</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// Convert router.asPath to a URLSearchParams object</span><span class="s3">\n</span><span class="s1">// example: /dynamic/[slug]?foo=bar -&gt; { foo: 'bar' }</span><span class="s3">\n</span><span class="s1">export function asPathToSearchParams(asPath: string): URLSearchParams {</span><span class="s3">\n  </span><span class="s1">return new URL(asPath, 'http://n').searchParams</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { isPlainObject } from '../shared/lib/is-plain-object'</span><span class="s3">\n\n</span><span class="s1">// We allow some additional attached properties for Next.js errors</span><span class="s3">\n</span><span class="s1">export interface NextError extends Error {</span><span class="s3">\n  </span><span class="s1">type?: string</span><span class="s3">\n  </span><span class="s1">page?: string</span><span class="s3">\n  </span><span class="s1">code?: string | number</span><span class="s3">\n  </span><span class="s1">cancelled?: boolean</span><span class="s3">\n  </span><span class="s1">digest?: number</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks whether the given value is a NextError.</span><span class="s3">\n </span><span class="s1">* This can be used to print a more detailed error message with properties like `code` &amp; `digest`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function isError(err: unknown): err is NextError {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">typeof err === 'object' &amp;&amp; err !== null &amp;&amp; 'name' in err &amp;&amp; 'message' in err</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function safeStringify(obj: any) {</span><span class="s3">\n  </span><span class="s1">const seen = new WeakSet()</span><span class="s3">\n\n  </span><span class="s1">return JSON.stringify(obj, (_key, value) =&gt; {</span><span class="s3">\n    </span><span class="s1">// If value is an object and already seen, replace with </span><span class="s3">\&quot;</span><span class="s1">[Circular]</span><span class="s3">\&quot;\n    </span><span class="s1">if (typeof value === 'object' &amp;&amp; value !== null) {</span><span class="s3">\n      </span><span class="s1">if (seen.has(value)) {</span><span class="s3">\n        </span><span class="s1">return '[Circular]'</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">seen.add(value)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return value</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getProperError(err: unknown): Error {</span><span class="s3">\n  </span><span class="s1">if (isError(err)) {</span><span class="s3">\n    </span><span class="s1">return err</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (process.env.NODE_ENV === 'development') {</span><span class="s3">\n    </span><span class="s1">// provide better error for case where `throw undefined`</span><span class="s3">\n    </span><span class="s1">// is called in development</span><span class="s3">\n    </span><span class="s1">if (typeof err === 'undefined') {</span><span class="s3">\n      </span><span class="s1">return new Error(</span><span class="s3">\n        </span><span class="s1">'An undefined error was thrown, ' +</span><span class="s3">\n          </span><span class="s1">'see here for more info: https://nextjs.org/docs/messages/threw-undefined'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (err === null) {</span><span class="s3">\n      </span><span class="s1">return new Error(</span><span class="s3">\n        </span><span class="s1">'A null error was thrown, ' +</span><span class="s3">\n          </span><span class="s1">'see here for more info: https://nextjs.org/docs/messages/threw-undefined'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return new Error(isPlainObject(err) ? safeStringify(err) : err + '')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { isDynamicRoute } from '../router/utils'</span><span class="s3">\n</span><span class="s1">import { normalizePathSep } from './normalize-path-sep'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Performs the opposite transformation of `normalizePagePath`. Note that</span><span class="s3">\n </span><span class="s1">* this function is not idempotent either in cases where there are multiple</span><span class="s3">\n </span><span class="s1">* leading `/index` for the page. Examples:</span><span class="s3">\n </span><span class="s1">*  - `/index` -&gt; `/`</span><span class="s3">\n </span><span class="s1">*  - `/index/foo` -&gt; `/foo`</span><span class="s3">\n </span><span class="s1">*  - `/index/index` -&gt; `/index`</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function denormalizePagePath(page: string) {</span><span class="s3">\n  </span><span class="s1">let _page = normalizePathSep(page)</span><span class="s3">\n  </span><span class="s1">return _page.startsWith('/index/') &amp;&amp; !isDynamicRoute(_page)</span><span class="s3">\n    </span><span class="s1">? _page.slice(6)</span><span class="s3">\n    </span><span class="s1">: _page !== '/index'</span><span class="s3">\n      </span><span class="s1">? _page</span><span class="s3">\n      </span><span class="s1">: '/'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;'use client'</span><span class="s3">\n\n</span><span class="s1">import React, { useContext } from 'react'</span><span class="s3">\n\n</span><span class="s1">export type ServerInsertedHTMLHook = (callbacks: () =&gt; React.ReactNode) =&gt; void</span><span class="s3">\n\n</span><span class="s1">// Use `React.createContext` to avoid errors from the RSC checks because</span><span class="s3">\n</span><span class="s1">// it can't be imported directly in Server Components:</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">//   import { createContext } from 'react'</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// More info: https://github.com/vercel/next.js/pull/40686</span><span class="s3">\n</span><span class="s1">export const ServerInsertedHTMLContext =</span><span class="s3">\n  </span><span class="s1">React.createContext&lt;ServerInsertedHTMLHook | null&gt;(null as any)</span><span class="s3">\n\n</span><span class="s1">export function useServerInsertedHTML(callback: () =&gt; React.ReactNode): void {</span><span class="s3">\n  </span><span class="s1">const addInsertedServerHTMLCallback = useContext(ServerInsertedHTMLContext)</span><span class="s3">\n  </span><span class="s1">// Should have no effects on client where there's no flush effects provider</span><span class="s3">\n  </span><span class="s1">if (addInsertedServerHTMLCallback) {</span><span class="s3">\n    </span><span class="s1">addInsertedServerHTMLCallback(callback)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import type { IncomingMessage, ServerResponse } from 'http'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">GetServerSideProps,</span><span class="s3">\n  </span><span class="s1">GetStaticPaths,</span><span class="s3">\n  </span><span class="s1">GetStaticProps,</span><span class="s3">\n  </span><span class="s1">NextComponentType,</span><span class="s3">\n  </span><span class="s1">PageConfig,</span><span class="s3">\n</span><span class="s1">} from '../../../types'</span><span class="s3">\n</span><span class="s1">import type { PagesRouteDefinition } from '../../route-definitions/pages-route-definition'</span><span class="s3">\n</span><span class="s1">import type { NextParsedUrlQuery } from '../../request-meta'</span><span class="s3">\n</span><span class="s1">import type {</span><span class="s3">\n  </span><span class="s1">PagesRenderContext,</span><span class="s3">\n  </span><span class="s1">PagesSharedContext,</span><span class="s3">\n  </span><span class="s1">RenderOpts,</span><span class="s3">\n</span><span class="s1">} from '../../render'</span><span class="s3">\n</span><span class="s1">import type RenderResult from '../../render-result'</span><span class="s3">\n</span><span class="s1">import type { AppType, DocumentType } from '../../../shared/lib/utils'</span><span class="s3">\n\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">RouteModule,</span><span class="s3">\n  </span><span class="s1">type RouteModuleHandleContext,</span><span class="s3">\n  </span><span class="s1">type RouteModuleOptions,</span><span class="s3">\n</span><span class="s1">} from '../route-module'</span><span class="s3">\n</span><span class="s1">import { renderToHTMLImpl, renderToHTML } from '../../render'</span><span class="s3">\n</span><span class="s1">import * as vendoredContexts from './vendored/contexts/entrypoints'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The PagesModule is the type of the module exported by the bundled pages</span><span class="s3">\n </span><span class="s1">* module.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type PagesModule = typeof import('../../../build/templates/pages')</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The userland module for a page. This is the module that is exported from the</span><span class="s3">\n </span><span class="s1">* page file that contains the page component, page config, and any page data</span><span class="s3">\n </span><span class="s1">* fetching functions.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export type PagesUserlandModule = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The exported page component.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readonly default: NextComponentType</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The exported page config.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readonly config?: PageConfig</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The exported `getStaticProps` function.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readonly getStaticProps?: GetStaticProps</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The exported `getStaticPaths` function.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readonly getStaticPaths?: GetStaticPaths</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The exported `getServerSideProps` function.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readonly getServerSideProps?: GetServerSideProps</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The components that are used to render a page. These aren't tied to the</span><span class="s3">\n </span><span class="s1">* specific page being rendered, but rather are the components that are used to</span><span class="s3">\n </span><span class="s1">* render all pages.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">type PagesComponents = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The `App` component. This could be exported by a user's custom `_app` page</span><span class="s3">\n   </span><span class="s1">* file, or it could be the default `App` component.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readonly App: AppType</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The `Document` component. This could be exported by a user's custom</span><span class="s3">\n   </span><span class="s1">* `_document` page file, or it could be the default `Document` component.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readonly Document: DocumentType</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export interface PagesRouteModuleOptions</span><span class="s3">\n  </span><span class="s1">extends RouteModuleOptions&lt;PagesRouteDefinition, PagesUserlandModule&gt; {</span><span class="s3">\n  </span><span class="s1">readonly components: PagesComponents</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* AppRouteRouteHandlerContext is the context that is passed to the route</span><span class="s3">\n </span><span class="s1">* handler for app routes.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export interface PagesRouteHandlerContext extends RouteModuleHandleContext {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The page for the given route.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">page: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The parsed URL query for the given request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">query: NextParsedUrlQuery</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The shared context used for all page renders.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">sharedContext: PagesSharedContext</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The context for the given request.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">renderContext: PagesRenderContext</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The arguments for the given request.</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The RenderOpts for the given request which include the specific modules to</span><span class="s3">\n   </span><span class="s1">* use for rendering.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">// TODO: (wyattjoh) break this out into smaller parts, it currently includes the userland components</span><span class="s3">\n  </span><span class="s1">renderOpts: Omit&lt;RenderOpts, 'Document' | 'App'&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class PagesRouteModule extends RouteModule&lt;</span><span class="s3">\n  </span><span class="s1">PagesRouteDefinition,</span><span class="s3">\n  </span><span class="s1">PagesUserlandModule</span><span class="s3">\n</span><span class="s1">&gt; {</span><span class="s3">\n  </span><span class="s1">private readonly components: PagesComponents</span><span class="s3">\n\n  </span><span class="s1">constructor(options: PagesRouteModuleOptions) {</span><span class="s3">\n    </span><span class="s1">super(options)</span><span class="s3">\n\n    </span><span class="s1">this.components = options.components</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">public render(</span><span class="s3">\n    </span><span class="s1">req: IncomingMessage,</span><span class="s3">\n    </span><span class="s1">res: ServerResponse,</span><span class="s3">\n    </span><span class="s1">context: PagesRouteHandlerContext</span><span class="s3">\n  </span><span class="s1">): Promise&lt;RenderResult&gt; {</span><span class="s3">\n    </span><span class="s1">return renderToHTMLImpl(</span><span class="s3">\n      </span><span class="s1">req,</span><span class="s3">\n      </span><span class="s1">res,</span><span class="s3">\n      </span><span class="s1">context.page,</span><span class="s3">\n      </span><span class="s1">context.query,</span><span class="s3">\n      </span><span class="s1">context.renderOpts,</span><span class="s3">\n      </span><span class="s1">{</span><span class="s3">\n        </span><span class="s1">App: this.components.App,</span><span class="s3">\n        </span><span class="s1">Document: this.components.Document,</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">context.sharedContext,</span><span class="s3">\n      </span><span class="s1">context.renderContext</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const vendored = {</span><span class="s3">\n  </span><span class="s1">contexts: vendoredContexts,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// needed for the static build</span><span class="s3">\n</span><span class="s1">export { renderToHTML, vendored }</span><span class="s3">\n\n</span><span class="s1">export default PagesRouteModule</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;Date&quot;</span><span class="s0">,</span><span class="s1">&quot;Boolean&quot;</span><span class="s0">,</span><span class="s1">&quot;encodeURIComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;decodeURIComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;Number&quot;</span><span class="s0">,</span><span class="s1">&quot;Symbol&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;n&quot;</span><span class="s0">,</span><span class="s1">&quot;r&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON&quot;</span><span class="s0">,</span><span class="s1">&quot;__nccwpck_require__&quot;</span><span class="s0">,</span><span class="s1">&quot;__dirname&quot;</span><span class="s0">,</span><span class="s1">&quot;e&quot;</span><span class="s0">,</span><span class="s1">&quot;TypeError&quot;</span><span class="s0">,</span><span class="s1">&quot;a&quot;</span><span class="s0">,</span><span class="s1">&quot;o&quot;</span><span class="s0">,</span><span class="s1">&quot;s&quot;</span><span class="s0">,</span><span class="s1">&quot;isNaN&quot;</span><span class="s0">,</span><span class="s1">&quot;isFinite&quot;</span><span class="s0">,</span><span class="s1">&quot;Math&quot;</span><span class="s0">,</span><span class="s1">&quot;u&quot;</span><span class="s0">,</span><span class="s1">&quot;v&quot;</span><span class="s0">,</span><span class="s1">&quot;x&quot;</span><span class="s0">,</span><span class="s1">&quot;RegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;String&quot;</span><span class="s0">,</span><span class="s1">&quot;_&quot;</span><span class="s0">,</span><span class="s1">&quot;globalThis&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;stdout&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;enabled&quot;</span><span class="s0">,</span><span class="s1">&quot;NO_COLOR&quot;</span><span class="s0">,</span><span class="s1">&quot;FORCE_COLOR&quot;</span><span class="s0">,</span><span class="s1">&quot;isTTY&quot;</span><span class="s0">,</span><span class="s1">&quot;CI&quot;</span><span class="s0">,</span><span class="s1">&quot;TERM&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceClose&quot;</span><span class="s0">,</span><span class="s1">&quot;str&quot;</span><span class="s0">,</span><span class="s1">&quot;close&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;index&quot;</span><span class="s0">,</span><span class="s1">&quot;start&quot;</span><span class="s0">,</span><span class="s1">&quot;substring&quot;</span><span class="s0">,</span><span class="s1">&quot;end&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;nextIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;indexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;formatter&quot;</span><span class="s0">,</span><span class="s1">&quot;open&quot;</span><span class="s0">,</span><span class="s1">&quot;input&quot;</span><span class="s0">,</span><span class="s1">&quot;string&quot;</span><span class="s0">,</span><span class="s1">&quot;bold&quot;</span><span class="s0">,</span><span class="s1">&quot;red&quot;</span><span class="s0">,</span><span class="s1">&quot;green&quot;</span><span class="s0">,</span><span class="s1">&quot;yellow&quot;</span><span class="s0">,</span><span class="s1">&quot;magenta&quot;</span><span class="s0">,</span><span class="s1">&quot;white&quot;</span><span class="s0">,</span><span class="s1">&quot;LRUNode&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;data&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">,</span><span class="s1">&quot;prev&quot;</span><span class="s0">,</span><span class="s1">&quot;next&quot;</span><span class="s0">,</span><span class="s1">&quot;SentinelNode&quot;</span><span class="s0">,</span><span class="s1">&quot;LRUCache&quot;</span><span class="s0">,</span><span class="s1">&quot;maxSize&quot;</span><span class="s0">,</span><span class="s1">&quot;calculateSize&quot;</span><span class="s0">,</span><span class="s1">&quot;cache&quot;</span><span class="s0">,</span><span class="s1">&quot;totalSize&quot;</span><span class="s0">,</span><span class="s1">&quot;head&quot;</span><span class="s0">,</span><span class="s1">&quot;tail&quot;</span><span class="s0">,</span><span class="s1">&quot;addToHead&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;removeNode&quot;</span><span class="s0">,</span><span class="s1">&quot;moveToHead&quot;</span><span class="s0">,</span><span class="s1">&quot;removeTail&quot;</span><span class="s0">,</span><span class="s1">&quot;lastNode&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;warn&quot;</span><span class="s0">,</span><span class="s1">&quot;existing&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;newNode&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;iterator&quot;</span><span class="s0">,</span><span class="s1">&quot;current&quot;</span><span class="s0">,</span><span class="s1">&quot;remove&quot;</span><span class="s0">,</span><span class="s1">&quot;currentSize&quot;</span><span class="s0">,</span><span class="s1">&quot;prefixes&quot;</span><span class="s0">,</span><span class="s1">&quot;wait&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;ready&quot;</span><span class="s0">,</span><span class="s1">&quot;info&quot;</span><span class="s0">,</span><span class="s1">&quot;event&quot;</span><span class="s0">,</span><span class="s1">&quot;trace&quot;</span><span class="s0">,</span><span class="s1">&quot;LOGGING_METHOD&quot;</span><span class="s0">,</span><span class="s1">&quot;log&quot;</span><span class="s0">,</span><span class="s1">&quot;message&quot;</span><span class="s0">,</span><span class="s1">&quot;prefixedLog&quot;</span><span class="s0">,</span><span class="s1">&quot;prefixType&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;shift&quot;</span><span class="s0">,</span><span class="s1">&quot;consoleMethod&quot;</span><span class="s0">,</span><span class="s1">&quot;prefix&quot;</span><span class="s0">,</span><span class="s1">&quot;HTML_CONTENT_TYPE_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON_CONTENT_TYPE_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_QUERY_PARAM_PREFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_INTERCEPTION_MARKER_PREFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;PRERENDER_REVALIDATE_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;RSC_PREFETCH_SUFFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;RSC_SEGMENTS_DIR_SUFFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;RSC_SEGMENT_SUFFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;RSC_SUFFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_DATA_SUFFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_META_SUFFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_CACHE_TAGS_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_CACHE_REVALIDATED_TAGS_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER&quot;</span><span class="s0">,</span><span class="s1">&quot;CACHE_ONE_YEAR&quot;</span><span class="s0">,</span><span class="s1">&quot;SSG_GET_INITIAL_PROPS_CONFLICT&quot;</span><span class="s0">,</span><span class="s1">&quot;SERVER_PROPS_GET_INIT_PROPS_CONFLICT&quot;</span><span class="s0">,</span><span class="s1">&quot;SERVER_PROPS_SSG_CONFLICT&quot;</span><span class="s0">,</span><span class="s1">&quot;STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR&quot;</span><span class="s0">,</span><span class="s1">&quot;GSP_NO_RETURNED_VALUE&quot;</span><span class="s0">,</span><span class="s1">&quot;GSSP_NO_RETURNED_VALUE&quot;</span><span class="s0">,</span><span class="s1">&quot;UNSTABLE_REVALIDATE_RENAME_ERROR&quot;</span><span class="s0">,</span><span class="s1">&quot;GSSP_COMPONENT_MEMBER_ERROR&quot;</span><span class="s0">,</span><span class="s1">&quot;WEBPACK_LAYERS_NAMES&quot;</span><span class="s0">,</span><span class="s1">&quot;shared&quot;</span><span class="s0">,</span><span class="s1">&quot;reactServerComponents&quot;</span><span class="s0">,</span><span class="s1">&quot;serverSideRendering&quot;</span><span class="s0">,</span><span class="s1">&quot;actionBrowser&quot;</span><span class="s0">,</span><span class="s1">&quot;apiNode&quot;</span><span class="s0">,</span><span class="s1">&quot;apiEdge&quot;</span><span class="s0">,</span><span class="s1">&quot;middleware&quot;</span><span class="s0">,</span><span class="s1">&quot;instrument&quot;</span><span class="s0">,</span><span class="s1">&quot;edgeAsset&quot;</span><span class="s0">,</span><span class="s1">&quot;appPagesBrowser&quot;</span><span class="s0">,</span><span class="s1">&quot;pagesDirBrowser&quot;</span><span class="s0">,</span><span class="s1">&quot;pagesDirEdge&quot;</span><span class="s0">,</span><span class="s1">&quot;pagesDirNode&quot;</span><span class="s0">,</span><span class="s1">&quot;GROUP&quot;</span><span class="s0">,</span><span class="s1">&quot;builtinReact&quot;</span><span class="s0">,</span><span class="s1">&quot;serverOnly&quot;</span><span class="s0">,</span><span class="s1">&quot;neutralTarget&quot;</span><span class="s0">,</span><span class="s1">&quot;clientOnly&quot;</span><span class="s0">,</span><span class="s1">&quot;bundled&quot;</span><span class="s0">,</span><span class="s1">&quot;appPages&quot;</span><span class="s0">,</span><span class="s1">&quot;formatDynamicImportPath&quot;</span><span class="s0">,</span><span class="s1">&quot;dir&quot;</span><span class="s0">,</span><span class="s1">&quot;filePath&quot;</span><span class="s0">,</span><span class="s1">&quot;absoluteFilePath&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;pathToFileURL&quot;</span><span class="s0">,</span><span class="s1">&quot;toString&quot;</span><span class="s0">,</span><span class="s1">&quot;checkIsOnDemandRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;req&quot;</span><span class="s0">,</span><span class="s1">&quot;previewProps&quot;</span><span class="s0">,</span><span class="s1">&quot;headers&quot;</span><span class="s0">,</span><span class="s1">&quot;HeadersAdapter&quot;</span><span class="s0">,</span><span class="s1">&quot;isOnDemandRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;previewModeId&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidateOnlyGenerated&quot;</span><span class="s0">,</span><span class="s1">&quot;COOKIE_NAME_PRERENDER_BYPASS&quot;</span><span class="s0">,</span><span class="s1">&quot;COOKIE_NAME_PRERENDER_DATA&quot;</span><span class="s0">,</span><span class="s1">&quot;SYMBOL_PREVIEW_DATA&quot;</span><span class="s0">,</span><span class="s1">&quot;SYMBOL_CLEARED_COOKIES&quot;</span><span class="s0">,</span><span class="s1">&quot;clearPreviewData&quot;</span><span class="s0">,</span><span class="s1">&quot;res&quot;</span><span class="s0">,</span><span class="s1">&quot;options&quot;</span><span class="s0">,</span><span class="s1">&quot;serialize&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;previous&quot;</span><span class="s0">,</span><span class="s1">&quot;getHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;setHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;expires&quot;</span><span class="s0">,</span><span class="s1">&quot;httpOnly&quot;</span><span class="s0">,</span><span class="s1">&quot;sameSite&quot;</span><span class="s0">,</span><span class="s1">&quot;secure&quot;</span><span class="s0">,</span><span class="s1">&quot;defineProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;enumerable&quot;</span><span class="s0">,</span><span class="s1">&quot;setLazyProp&quot;</span><span class="s0">,</span><span class="s1">&quot;prop&quot;</span><span class="s0">,</span><span class="s1">&quot;getter&quot;</span><span class="s0">,</span><span class="s1">&quot;opts&quot;</span><span class="s0">,</span><span class="s1">&quot;configurable&quot;</span><span class="s0">,</span><span class="s1">&quot;optsReset&quot;</span><span class="s0">,</span><span class="s1">&quot;writable&quot;</span><span class="s0">,</span><span class="s1">&quot;tryGetPreviewData&quot;</span><span class="s0">,</span><span class="s1">&quot;multiZoneDraftMode&quot;</span><span class="s0">,</span><span class="s1">&quot;cookies&quot;</span><span class="s0">,</span><span class="s1">&quot;encryptedPreviewData&quot;</span><span class="s0">,</span><span class="s1">&quot;RequestCookies&quot;</span><span class="s0">,</span><span class="s1">&quot;tokenPreviewData&quot;</span><span class="s0">,</span><span class="s1">&quot;jsonwebtoken&quot;</span><span class="s0">,</span><span class="s1">&quot;verify&quot;</span><span class="s0">,</span><span class="s1">&quot;previewModeSigningKey&quot;</span><span class="s0">,</span><span class="s1">&quot;decryptWithSecret&quot;</span><span class="s0">,</span><span class="s1">&quot;decryptedPreviewData&quot;</span><span class="s0">,</span><span class="s1">&quot;Buffer&quot;</span><span class="s0">,</span><span class="s1">&quot;from&quot;</span><span class="s0">,</span><span class="s1">&quot;previewModeEncryptionKey&quot;</span><span class="s0">,</span><span class="s1">&quot;parse&quot;</span><span class="s0">,</span><span class="s1">&quot;CIPHER_ALGORITHM&quot;</span><span class="s0">,</span><span class="s1">&quot;encryptWithSecret&quot;</span><span class="s0">,</span><span class="s1">&quot;secret&quot;</span><span class="s0">,</span><span class="s1">&quot;iv&quot;</span><span class="s0">,</span><span class="s1">&quot;crypto&quot;</span><span class="s0">,</span><span class="s1">&quot;salt&quot;</span><span class="s0">,</span><span class="s1">&quot;cipher&quot;</span><span class="s0">,</span><span class="s1">&quot;encrypted&quot;</span><span class="s0">,</span><span class="s1">&quot;concat&quot;</span><span class="s0">,</span><span class="s1">&quot;update&quot;</span><span class="s0">,</span><span class="s1">&quot;final&quot;</span><span class="s0">,</span><span class="s1">&quot;tag&quot;</span><span class="s0">,</span><span class="s1">&quot;getAuthTag&quot;</span><span class="s0">,</span><span class="s1">&quot;encryptedData&quot;</span><span class="s0">,</span><span class="s1">&quot;buffer&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;CIPHER_SALT_LENGTH&quot;</span><span class="s0">,</span><span class="s1">&quot;decipher&quot;</span><span class="s0">,</span><span class="s1">&quot;setAuthTag&quot;</span><span class="s0">,</span><span class="s1">&quot;nodeFs&quot;</span><span class="s0">,</span><span class="s1">&quot;existsSync&quot;</span><span class="s0">,</span><span class="s1">&quot;fs&quot;</span><span class="s0">,</span><span class="s1">&quot;readFile&quot;</span><span class="s0">,</span><span class="s1">&quot;readFileSync&quot;</span><span class="s0">,</span><span class="s1">&quot;writeFile&quot;</span><span class="s0">,</span><span class="s1">&quot;f&quot;</span><span class="s0">,</span><span class="s1">&quot;d&quot;</span><span class="s0">,</span><span class="s1">&quot;mkdir&quot;</span><span class="s0">,</span><span class="s1">&quot;recursive&quot;</span><span class="s0">,</span><span class="s1">&quot;stat&quot;</span><span class="s0">,</span><span class="s1">&quot;optimize&quot;</span><span class="s0">,</span><span class="s1">&quot;html&quot;</span><span class="s0">,</span><span class="s1">&quot;config&quot;</span><span class="s0">,</span><span class="s1">&quot;AmpOptimizer&quot;</span><span class="s0">,</span><span class="s1">&quot;optimizer&quot;</span><span class="s0">,</span><span class="s1">&quot;create&quot;</span><span class="s0">,</span><span class="s1">&quot;transformHtml&quot;</span><span class="s0">,</span><span class="s1">&quot;nonNullable&quot;</span><span class="s0">,</span><span class="s1">&quot;postProcessHTML&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;content&quot;</span><span class="s0">,</span><span class="s1">&quot;renderOpts&quot;</span><span class="s0">,</span><span class="s1">&quot;inAmpMode&quot;</span><span class="s0">,</span><span class="s1">&quot;hybridAmp&quot;</span><span class="s0">,</span><span class="s1">&quot;postProcessor&quot;</span><span class="s0">,</span><span class="s1">&quot;optimizeAmp&quot;</span><span class="s0">,</span><span class="s1">&quot;ampOptimizerConfig&quot;</span><span class="s0">,</span><span class="s1">&quot;ampSkipValidation&quot;</span><span class="s0">,</span><span class="s1">&quot;ampValidator&quot;</span><span class="s0">,</span><span class="s1">&quot;optimizeCss&quot;</span><span class="s0">,</span><span class="s1">&quot;cssOptimizer&quot;</span><span class="s0">,</span><span class="s1">&quot;ssrMode&quot;</span><span class="s0">,</span><span class="s1">&quot;reduceInlineStyles&quot;</span><span class="s0">,</span><span class="s1">&quot;distDir&quot;</span><span class="s0">,</span><span class="s1">&quot;publicPath&quot;</span><span class="s0">,</span><span class="s1">&quot;assetPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;preload&quot;</span><span class="s0">,</span><span class="s1">&quot;fonts&quot;</span><span class="s0">,</span><span class="s1">&quot;logLevel&quot;</span><span class="s0">,</span><span class="s1">&quot;CRITTERS_LOG_LEVEL&quot;</span><span class="s0">,</span><span class="s1">&quot;filter&quot;</span><span class="s0">,</span><span class="s1">&quot;ReflectAdapter&quot;</span><span class="s0">,</span><span class="s1">&quot;target&quot;</span><span class="s0">,</span><span class="s1">&quot;receiver&quot;</span><span class="s0">,</span><span class="s1">&quot;Reflect&quot;</span><span class="s0">,</span><span class="s1">&quot;bind&quot;</span><span class="s0">,</span><span class="s1">&quot;deleteProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;ReadonlyHeadersError&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;callable&quot;</span><span class="s0">,</span><span class="s1">&quot;Headers&quot;</span><span class="s0">,</span><span class="s1">&quot;Proxy&quot;</span><span class="s0">,</span><span class="s1">&quot;lowercased&quot;</span><span class="s0">,</span><span class="s1">&quot;toLowerCase&quot;</span><span class="s0">,</span><span class="s1">&quot;original&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;find&quot;</span><span class="s0">,</span><span class="s1">&quot;seal&quot;</span><span class="s0">,</span><span class="s1">&quot;merge&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;append&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;forEach&quot;</span><span class="s0">,</span><span class="s1">&quot;callbackfn&quot;</span><span class="s0">,</span><span class="s1">&quot;thisArg&quot;</span><span class="s0">,</span><span class="s1">&quot;entries&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">,</span><span class="s1">&quot;values&quot;</span><span class="s0">,</span><span class="s1">&quot;module&quot;</span><span class="s0">,</span><span class="s1">&quot;ReactDOMServer&quot;</span><span class="s0">,</span><span class="s1">&quot;code&quot;</span><span class="s0">,</span><span class="s1">&quot;t&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;c&quot;</span><span class="s0">,</span><span class="s1">&quot;COMPILER_NAMES&quot;</span><span class="s0">,</span><span class="s1">&quot;client&quot;</span><span class="s0">,</span><span class="s1">&quot;server&quot;</span><span class="s0">,</span><span class="s1">&quot;edgeServer&quot;</span><span class="s0">,</span><span class="s1">&quot;BUILD_MANIFEST&quot;</span><span class="s0">,</span><span class="s1">&quot;STATIC_STATUS_PAGES&quot;</span><span class="s0">,</span><span class="s1">&quot;parseReqUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;parsedUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;parseUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;parsed&quot;</span><span class="s0">,</span><span class="s1">&quot;URL&quot;</span><span class="s0">,</span><span class="s1">&quot;query&quot;</span><span class="s0">,</span><span class="s1">&quot;searchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;getAll&quot;</span><span class="s0">,</span><span class="s1">&quot;hash&quot;</span><span class="s0">,</span><span class="s1">&quot;search&quot;</span><span class="s0">,</span><span class="s1">&quot;href&quot;</span><span class="s0">,</span><span class="s1">&quot;host&quot;</span><span class="s0">,</span><span class="s1">&quot;hostname&quot;</span><span class="s0">,</span><span class="s1">&quot;auth&quot;</span><span class="s0">,</span><span class="s1">&quot;protocol&quot;</span><span class="s0">,</span><span class="s1">&quot;slashes&quot;</span><span class="s0">,</span><span class="s1">&quot;port&quot;</span><span class="s0">,</span><span class="s1">&quot;WeakMap&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeLocalePath&quot;</span><span class="s0">,</span><span class="s1">&quot;locales&quot;</span><span class="s0">,</span><span class="s1">&quot;detectedLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;lowercasedLocales&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;locale&quot;</span><span class="s0">,</span><span class="s1">&quot;segments&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;ensureLeadingSlash&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeAppPath&quot;</span><span class="s0">,</span><span class="s1">&quot;route&quot;</span><span class="s0">,</span><span class="s1">&quot;reduce&quot;</span><span class="s0">,</span><span class="s1">&quot;endsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeRscURL&quot;</span><span class="s0">,</span><span class="s1">&quot;INTERCEPTION_ROUTE_MARKERS&quot;</span><span class="s0">,</span><span class="s1">&quot;isInterceptionRouteAppPath&quot;</span><span class="s0">,</span><span class="s1">&quot;m&quot;</span><span class="s0">,</span><span class="s1">&quot;TEST_ROUTE&quot;</span><span class="s0">,</span><span class="s1">&quot;TEST_STRICT_ROUTE&quot;</span><span class="s0">,</span><span class="s1">&quot;isDynamicRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;strict&quot;</span><span class="s0">,</span><span class="s1">&quot;extractInterceptionRouteInformation&quot;</span><span class="s0">,</span><span class="s1">&quot;interceptingRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;marker&quot;</span><span class="s0">,</span><span class="s1">&quot;interceptedRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;splitInterceptingRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;parsePath&quot;</span><span class="s0">,</span><span class="s1">&quot;hashIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;queryIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;hasQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;pathHasPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;removePathPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;withoutPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;reHasRegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;reReplaceRegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;escapeStringRegexp&quot;</span><span class="s0">,</span><span class="s1">&quot;removeTrailingSlash&quot;</span><span class="s0">,</span><span class="s1">&quot;PARAMETER_PATTERN&quot;</span><span class="s0">,</span><span class="s1">&quot;parseMatchedParameter&quot;</span><span class="s0">,</span><span class="s1">&quot;param&quot;</span><span class="s0">,</span><span class="s1">&quot;optional&quot;</span><span class="s0">,</span><span class="s1">&quot;repeat&quot;</span><span class="s0">,</span><span class="s1">&quot;getRouteRegex&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;includeSuffix&quot;</span><span class="s0">,</span><span class="s1">&quot;includePrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;excludeOptionalTrailingSlash&quot;</span><span class="s0">,</span><span class="s1">&quot;parameterizedRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;groups&quot;</span><span class="s0">,</span><span class="s1">&quot;getParametrizedRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;groupIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;markerMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;paramMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;match&quot;</span><span class="s0">,</span><span class="s1">&quot;pos&quot;</span><span class="s0">,</span><span class="s1">&quot;re&quot;</span><span class="s0">,</span><span class="s1">&quot;getSafeKeyFromSegment&quot;</span><span class="s0">,</span><span class="s1">&quot;pattern&quot;</span><span class="s0">,</span><span class="s1">&quot;interceptionMarker&quot;</span><span class="s0">,</span><span class="s1">&quot;getSafeRouteKey&quot;</span><span class="s0">,</span><span class="s1">&quot;routeKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;keyPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;backreferenceDuplicateKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;cleanedKey&quot;</span><span class="s0">,</span><span class="s1">&quot;invalidKey&quot;</span><span class="s0">,</span><span class="s1">&quot;parseInt&quot;</span><span class="s0">,</span><span class="s1">&quot;duplicateKey&quot;</span><span class="s0">,</span><span class="s1">&quot;interceptionPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;getDisplayName&quot;</span><span class="s0">,</span><span class="s1">&quot;Component&quot;</span><span class="s0">,</span><span class="s1">&quot;displayName&quot;</span><span class="s0">,</span><span class="s1">&quot;isResSent&quot;</span><span class="s0">,</span><span class="s1">&quot;finished&quot;</span><span class="s0">,</span><span class="s1">&quot;headersSent&quot;</span><span class="s0">,</span><span class="s1">&quot;loadGetInitialProps&quot;</span><span class="s0">,</span><span class="s1">&quot;App&quot;</span><span class="s0">,</span><span class="s1">&quot;ctx&quot;</span><span class="s0">,</span><span class="s1">&quot;getInitialProps&quot;</span><span class="s0">,</span><span class="s1">&quot;pageProps&quot;</span><span class="s0">,</span><span class="s1">&quot;props&quot;</span><span class="s0">,</span><span class="s1">&quot;SP&quot;</span><span class="s0">,</span><span class="s1">&quot;performance&quot;</span><span class="s0">,</span><span class="s1">&quot;every&quot;</span><span class="s0">,</span><span class="s1">&quot;method&quot;</span><span class="s0">,</span><span class="s1">&quot;DecodeError&quot;</span><span class="s0">,</span><span class="s1">&quot;NormalizeError&quot;</span><span class="s0">,</span><span class="s1">&quot;PARAM_SEPARATOR&quot;</span><span class="s0">,</span><span class="s1">&quot;hasAdjacentParameterIssues&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeAdjacentParameters&quot;</span><span class="s0">,</span><span class="s1">&quot;normalized&quot;</span><span class="s0">,</span><span class="s1">&quot;safePathToRegexp&quot;</span><span class="s0">,</span><span class="s1">&quot;pathToRegexp&quot;</span><span class="s0">,</span><span class="s1">&quot;needsNormalization&quot;</span><span class="s0">,</span><span class="s1">&quot;routeToUse&quot;</span><span class="s0">,</span><span class="s1">&quot;retryError&quot;</span><span class="s0">,</span><span class="s1">&quot;safeCompile&quot;</span><span class="s0">,</span><span class="s1">&quot;compile&quot;</span><span class="s0">,</span><span class="s1">&quot;getRouteMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;matcherFn&quot;</span><span class="s0">,</span><span class="s1">&quot;routeMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;exec&quot;</span><span class="s0">,</span><span class="s1">&quot;decode&quot;</span><span class="s0">,</span><span class="s1">&quot;params&quot;</span><span class="s0">,</span><span class="s1">&quot;group&quot;</span><span class="s0">,</span><span class="s1">&quot;entry&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;cleaned&quot;</span><span class="s0">,</span><span class="s1">&quot;item&quot;</span><span class="s0">,</span><span class="s1">&quot;searchParamsToUrlQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;stringifyUrlQueryParam&quot;</span><span class="s0">,</span><span class="s1">&quot;getCookieParser&quot;</span><span class="s0">,</span><span class="s1">&quot;cookie&quot;</span><span class="s0">,</span><span class="s1">&quot;parseCookieFn&quot;</span><span class="s0">,</span><span class="s1">&quot;unescapeSegments&quot;</span><span class="s0">,</span><span class="s1">&quot;compileNonPath&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;validate&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeNextQueryParam&quot;</span><span class="s0">,</span><span class="s1">&quot;decodeQueryPathParameter&quot;</span><span class="s0">,</span><span class="s1">&quot;slashedProtocols&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicParamTypesSchema&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentSchema&quot;</span><span class="s0">,</span><span class="s1">&quot;flightRouterStateSchema&quot;</span><span class="s0">,</span><span class="s1">&quot;isInterceptionRouteRewrite&quot;</span><span class="s0">,</span><span class="s1">&quot;filterInternalQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;paramKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;isNextQueryPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;isNextInterceptionMarkerPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;detectDomainLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;domainItems&quot;</span><span class="s0">,</span><span class="s1">&quot;domain&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;some&quot;</span><span class="s0">,</span><span class="s1">&quot;getHostname&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeDataPath&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_REQUEST_META&quot;</span><span class="s0">,</span><span class="s1">&quot;for&quot;</span><span class="s0">,</span><span class="s1">&quot;getRequestMeta&quot;</span><span class="s0">,</span><span class="s1">&quot;meta&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizePagePath&quot;</span><span class="s0">,</span><span class="s1">&quot;page&quot;</span><span class="s0">,</span><span class="s1">&quot;posix&quot;</span><span class="s0">,</span><span class="s1">&quot;resolvedPage&quot;</span><span class="s0">,</span><span class="s1">&quot;normalize&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizePathSep&quot;</span><span class="s0">,</span><span class="s1">&quot;STATIC_METADATA_IMAGES&quot;</span><span class="s0">,</span><span class="s1">&quot;icon&quot;</span><span class="s0">,</span><span class="s1">&quot;filename&quot;</span><span class="s0">,</span><span class="s1">&quot;extensions&quot;</span><span class="s0">,</span><span class="s1">&quot;apple&quot;</span><span class="s0">,</span><span class="s1">&quot;openGraph&quot;</span><span class="s0">,</span><span class="s1">&quot;twitter&quot;</span><span class="s0">,</span><span class="s1">&quot;getExtensionRegexString&quot;</span><span class="s0">,</span><span class="s1">&quot;staticExtensions&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicExtensions&quot;</span><span class="s0">,</span><span class="s1">&quot;DetachedPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;reject&quot;</span><span class="s0">,</span><span class="s1">&quot;promise&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;rej&quot;</span><span class="s0">,</span><span class="s1">&quot;Batcher&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheKeyFn&quot;</span><span class="s0">,</span><span class="s1">&quot;schedulerFn&quot;</span><span class="s0">,</span><span class="s1">&quot;fn&quot;</span><span class="s0">,</span><span class="s1">&quot;pending&quot;</span><span class="s0">,</span><span class="s1">&quot;batch&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;scheduleOnNextTick&quot;</span><span class="s0">,</span><span class="s1">&quot;cb&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;nextTick&quot;</span><span class="s0">,</span><span class="s1">&quot;CachedRouteKind&quot;</span><span class="s0">,</span><span class="s1">&quot;IncrementalCacheKind&quot;</span><span class="s0">,</span><span class="s1">&quot;NextNodeServerSpan&quot;</span><span class="s0">,</span><span class="s1">&quot;RenderSpan&quot;</span><span class="s0">,</span><span class="s1">&quot;AppRenderSpan&quot;</span><span class="s0">,</span><span class="s1">&quot;voidCatch&quot;</span><span class="s0">,</span><span class="s1">&quot;Uint8Array&quot;</span><span class="s0">,</span><span class="s1">&quot;encoder&quot;</span><span class="s0">,</span><span class="s1">&quot;TextEncoder&quot;</span><span class="s0">,</span><span class="s1">&quot;streamFromString&quot;</span><span class="s0">,</span><span class="s1">&quot;ReadableStream&quot;</span><span class="s0">,</span><span class="s1">&quot;controller&quot;</span><span class="s0">,</span><span class="s1">&quot;enqueue&quot;</span><span class="s0">,</span><span class="s1">&quot;encode&quot;</span><span class="s0">,</span><span class="s1">&quot;streamFromBuffer&quot;</span><span class="s0">,</span><span class="s1">&quot;chunk&quot;</span><span class="s0">,</span><span class="s1">&quot;streamToString&quot;</span><span class="s0">,</span><span class="s1">&quot;stream&quot;</span><span class="s0">,</span><span class="s1">&quot;signal&quot;</span><span class="s0">,</span><span class="s1">&quot;decoder&quot;</span><span class="s0">,</span><span class="s1">&quot;TextDecoder&quot;</span><span class="s0">,</span><span class="s1">&quot;fatal&quot;</span><span class="s0">,</span><span class="s1">&quot;aborted&quot;</span><span class="s0">,</span><span class="s1">&quot;addPathPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;addPathSuffix&quot;</span><span class="s0">,</span><span class="s1">&quot;suffix&quot;</span><span class="s0">,</span><span class="s1">&quot;REGEX_LOCALHOST_HOSTNAME&quot;</span><span class="s0">,</span><span class="s1">&quot;parseURL&quot;</span><span class="s0">,</span><span class="s1">&quot;base&quot;</span><span class="s0">,</span><span class="s1">&quot;Internal&quot;</span><span class="s0">,</span><span class="s1">&quot;NextURL&quot;</span><span class="s0">,</span><span class="s1">&quot;baseOrOpts&quot;</span><span class="s0">,</span><span class="s1">&quot;basePath&quot;</span><span class="s0">,</span><span class="s1">&quot;analyze&quot;</span><span class="s0">,</span><span class="s1">&quot;getNextPathnameInfo&quot;</span><span class="s0">,</span><span class="s1">&quot;i18n&quot;</span><span class="s0">,</span><span class="s1">&quot;trailingSlash&quot;</span><span class="s0">,</span><span class="s1">&quot;nextConfig&quot;</span><span class="s0">,</span><span class="s1">&quot;pathnameNoDataPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;paths&quot;</span><span class="s0">,</span><span class="s1">&quot;buildId&quot;</span><span class="s0">,</span><span class="s1">&quot;parseData&quot;</span><span class="s0">,</span><span class="s1">&quot;i18nProvider&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_NO_MIDDLEWARE_URL_NORMALIZE&quot;</span><span class="s0">,</span><span class="s1">&quot;domainLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;domains&quot;</span><span class="s0">,</span><span class="s1">&quot;formatPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;addLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;ignorePrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;lower&quot;</span><span class="s0">,</span><span class="s1">&quot;forceLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;formatSearch&quot;</span><span class="s0">,</span><span class="s1">&quot;origin&quot;</span><span class="s0">,</span><span class="s1">&quot;password&quot;</span><span class="s0">,</span><span class="s1">&quot;username&quot;</span><span class="s0">,</span><span class="s1">&quot;toJSON&quot;</span><span class="s0">,</span><span class="s1">&quot;clone&quot;</span><span class="s0">,</span><span class="s1">&quot;Request&quot;</span><span class="s0">,</span><span class="s1">&quot;ResponseAbortedName&quot;</span><span class="s0">,</span><span class="s1">&quot;ResponseAborted&quot;</span><span class="s0">,</span><span class="s1">&quot;clientComponentLoadStart&quot;</span><span class="s0">,</span><span class="s1">&quot;clientComponentLoadTimes&quot;</span><span class="s0">,</span><span class="s1">&quot;clientComponentLoadCount&quot;</span><span class="s0">,</span><span class="s1">&quot;isAbortError&quot;</span><span class="s0">,</span><span class="s1">&quot;pipeToNodeResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;readable&quot;</span><span class="s0">,</span><span class="s1">&quot;waitUntilForEnd&quot;</span><span class="s0">,</span><span class="s1">&quot;errored&quot;</span><span class="s0">,</span><span class="s1">&quot;destroyed&quot;</span><span class="s0">,</span><span class="s1">&quot;createAbortController&quot;</span><span class="s0">,</span><span class="s1">&quot;response&quot;</span><span class="s0">,</span><span class="s1">&quot;AbortController&quot;</span><span class="s0">,</span><span class="s1">&quot;once&quot;</span><span class="s0">,</span><span class="s1">&quot;writableFinished&quot;</span><span class="s0">,</span><span class="s1">&quot;abort&quot;</span><span class="s0">,</span><span class="s1">&quot;writer&quot;</span><span class="s0">,</span><span class="s1">&quot;createWriterFromResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;started&quot;</span><span class="s0">,</span><span class="s1">&quot;drained&quot;</span><span class="s0">,</span><span class="s1">&quot;onDrain&quot;</span><span class="s0">,</span><span class="s1">&quot;on&quot;</span><span class="s0">,</span><span class="s1">&quot;off&quot;</span><span class="s0">,</span><span class="s1">&quot;WritableStream&quot;</span><span class="s0">,</span><span class="s1">&quot;write&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_OTEL_PERFORMANCE_PREFIX&quot;</span><span class="s0">,</span><span class="s1">&quot;metrics&quot;</span><span class="s0">,</span><span class="s1">&quot;getClientComponentLoaderMetrics&quot;</span><span class="s0">,</span><span class="s1">&quot;reset&quot;</span><span class="s0">,</span><span class="s1">&quot;measure&quot;</span><span class="s0">,</span><span class="s1">&quot;flushHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;getTracer&quot;</span><span class="s0">,</span><span class="s1">&quot;spanName&quot;</span><span class="s0">,</span><span class="s1">&quot;ok&quot;</span><span class="s0">,</span><span class="s1">&quot;flush&quot;</span><span class="s0">,</span><span class="s1">&quot;cause&quot;</span><span class="s0">,</span><span class="s1">&quot;destroy&quot;</span><span class="s0">,</span><span class="s1">&quot;pipeTo&quot;</span><span class="s0">,</span><span class="s1">&quot;InvariantError&quot;</span><span class="s0">,</span><span class="s1">&quot;RenderResult&quot;</span><span class="s0">,</span><span class="s1">&quot;EMPTY&quot;</span><span class="s0">,</span><span class="s1">&quot;metadata&quot;</span><span class="s0">,</span><span class="s1">&quot;contentType&quot;</span><span class="s0">,</span><span class="s1">&quot;fromStatic&quot;</span><span class="s0">,</span><span class="s1">&quot;waitUntil&quot;</span><span class="s0">,</span><span class="s1">&quot;assignMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;assign&quot;</span><span class="s0">,</span><span class="s1">&quot;isNull&quot;</span><span class="s0">,</span><span class="s1">&quot;isDynamic&quot;</span><span class="s0">,</span><span class="s1">&quot;toUnchunkedString&quot;</span><span class="s0">,</span><span class="s1">&quot;isBuffer&quot;</span><span class="s0">,</span><span class="s1">&quot;chainStreams&quot;</span><span class="s0">,</span><span class="s1">&quot;streams&quot;</span><span class="s0">,</span><span class="s1">&quot;TransformStream&quot;</span><span class="s0">,</span><span class="s1">&quot;preventClose&quot;</span><span class="s0">,</span><span class="s1">&quot;nextStream&quot;</span><span class="s0">,</span><span class="s1">&quot;lastStream&quot;</span><span class="s0">,</span><span class="s1">&quot;catch&quot;</span><span class="s0">,</span><span class="s1">&quot;coerce&quot;</span><span class="s0">,</span><span class="s1">&quot;unshift&quot;</span><span class="s0">,</span><span class="s1">&quot;RouteKind&quot;</span><span class="s0">,</span><span class="s1">&quot;fromResponseCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;pageData&quot;</span><span class="s0">,</span><span class="s1">&quot;status&quot;</span><span class="s0">,</span><span class="s1">&quot;postponed&quot;</span><span class="s0">,</span><span class="s1">&quot;rscData&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentData&quot;</span><span class="s0">,</span><span class="s1">&quot;toResponseCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;isMiss&quot;</span><span class="s0">,</span><span class="s1">&quot;isStale&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheControl&quot;</span><span class="s0">,</span><span class="s1">&quot;ResponseCache&quot;</span><span class="s0">,</span><span class="s1">&quot;minimal_mode&quot;</span><span class="s0">,</span><span class="s1">&quot;batcher&quot;</span><span class="s0">,</span><span class="s1">&quot;responseGenerator&quot;</span><span class="s0">,</span><span class="s1">&quot;context&quot;</span><span class="s0">,</span><span class="s1">&quot;hasResolved&quot;</span><span class="s0">,</span><span class="s1">&quot;previousCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;incrementalCache&quot;</span><span class="s0">,</span><span class="s1">&quot;isFallback&quot;</span><span class="s0">,</span><span class="s1">&quot;isRoutePPREnabled&quot;</span><span class="s0">,</span><span class="s1">&quot;prom&quot;</span><span class="s0">,</span><span class="s1">&quot;previousCacheItem&quot;</span><span class="s0">,</span><span class="s1">&quot;expiresAt&quot;</span><span class="s0">,</span><span class="s1">&quot;now&quot;</span><span class="s0">,</span><span class="s1">&quot;routeKindToIncrementalCacheKind&quot;</span><span class="s0">,</span><span class="s1">&quot;routeKind&quot;</span><span class="s0">,</span><span class="s1">&quot;resolved&quot;</span><span class="s0">,</span><span class="s1">&quot;cachedResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;isPrefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;isRevalidating&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveValue&quot;</span><span class="s0">,</span><span class="s1">&quot;newRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;min&quot;</span><span class="s0">,</span><span class="s1">&quot;max&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;newExpire&quot;</span><span class="s0">,</span><span class="s1">&quot;expire&quot;</span><span class="s0">,</span><span class="s1">&quot;MultiFileWriter&quot;</span><span class="s0">,</span><span class="s1">&quot;tasks&quot;</span><span class="s0">,</span><span class="s1">&quot;findOrCreateTask&quot;</span><span class="s0">,</span><span class="s1">&quot;directory&quot;</span><span class="s0">,</span><span class="s1">&quot;task&quot;</span><span class="s0">,</span><span class="s1">&quot;all&quot;</span><span class="s0">,</span><span class="s1">&quot;flatMap&quot;</span><span class="s0">,</span><span class="s1">&quot;FileSystemCache&quot;</span><span class="s0">,</span><span class="s1">&quot;debug&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_PRIVATE_DEBUG_CACHE&quot;</span><span class="s0">,</span><span class="s1">&quot;flushToDisk&quot;</span><span class="s0">,</span><span class="s1">&quot;serverDistDir&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidatedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;maxMemoryCacheSize&quot;</span><span class="s0">,</span><span class="s1">&quot;memoryCache&quot;</span><span class="s0">,</span><span class="s1">&quot;getMemoryCache&quot;</span><span class="s0">,</span><span class="s1">&quot;resetRequestCache&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidateTag&quot;</span><span class="s0">,</span><span class="s1">&quot;args&quot;</span><span class="s0">,</span><span class="s1">&quot;tags&quot;</span><span class="s0">,</span><span class="s1">&quot;tagsManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;getFilePath&quot;</span><span class="s0">,</span><span class="s1">&quot;fileData&quot;</span><span class="s0">,</span><span class="s1">&quot;mtime&quot;</span><span class="s0">,</span><span class="s1">&quot;lastModified&quot;</span><span class="s0">,</span><span class="s1">&quot;getTime&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchIdx&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;parsedData&quot;</span><span class="s0">,</span><span class="s1">&quot;storedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchCache&quot;</span><span class="s0">,</span><span class="s1">&quot;maybeSegmentData&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentsDir&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentDataFilePath&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheTags&quot;</span><span class="s0">,</span><span class="s1">&quot;tagsHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;combinedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;softTags&quot;</span><span class="s0">,</span><span class="s1">&quot;stringify&quot;</span><span class="s0">,</span><span class="s1">&quot;isAppPath&quot;</span><span class="s0">,</span><span class="s1">&quot;htmlPath&quot;</span><span class="s0">,</span><span class="s1">&quot;toRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;IncrementalCache&quot;</span><span class="s0">,</span><span class="s1">&quot;dev&quot;</span><span class="s0">,</span><span class="s1">&quot;minimalMode&quot;</span><span class="s0">,</span><span class="s1">&quot;requestHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;getPrerenderManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchCacheKeyPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;CurCacheHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;allowedRevalidateHeaderKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;locks&quot;</span><span class="s0">,</span><span class="s1">&quot;hasCustomCacheHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheHandlersSymbol&quot;</span><span class="s0">,</span><span class="s1">&quot;_globalThis&quot;</span><span class="s0">,</span><span class="s1">&quot;globalCacheHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;FetchCache&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_TEST_MAX_ISR_CACHE&quot;</span><span class="s0">,</span><span class="s1">&quot;disableForTestmode&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_PRIVATE_TEST_PROXY&quot;</span><span class="s0">,</span><span class="s1">&quot;prerenderManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheControls&quot;</span><span class="s0">,</span><span class="s1">&quot;SharedCacheControls&quot;</span><span class="s0">,</span><span class="s1">&quot;preview&quot;</span><span class="s0">,</span><span class="s1">&quot;getPreviouslyRevalidatedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;_requestHeaders&quot;</span><span class="s0">,</span><span class="s1">&quot;calculateRevalidate&quot;</span><span class="s0">,</span><span class="s1">&quot;fromTime&quot;</span><span class="s0">,</span><span class="s1">&quot;floor&quot;</span><span class="s0">,</span><span class="s1">&quot;timeOrigin&quot;</span><span class="s0">,</span><span class="s1">&quot;initialRevalidateSeconds&quot;</span><span class="s0">,</span><span class="s1">&quot;_getPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;lock&quot;</span><span class="s0">,</span><span class="s1">&quot;generateCacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;init&quot;</span><span class="s0">,</span><span class="s1">&quot;bodyChunks&quot;</span><span class="s0">,</span><span class="s1">&quot;_ogBody&quot;</span><span class="s0">,</span><span class="s1">&quot;getReader&quot;</span><span class="s0">,</span><span class="s1">&quot;readableBody&quot;</span><span class="s0">,</span><span class="s1">&quot;chunks&quot;</span><span class="s0">,</span><span class="s1">&quot;total&quot;</span><span class="s0">,</span><span class="s1">&quot;arr&quot;</span><span class="s0">,</span><span class="s1">&quot;arrayBuffer&quot;</span><span class="s0">,</span><span class="s1">&quot;offset&quot;</span><span class="s0">,</span><span class="s1">&quot;formData&quot;</span><span class="s0">,</span><span class="s1">&quot;val&quot;</span><span class="s0">,</span><span class="s1">&quot;text&quot;</span><span class="s0">,</span><span class="s1">&quot;blob&quot;</span><span class="s0">,</span><span class="s1">&quot;Blob&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;fromEntries&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheString&quot;</span><span class="s0">,</span><span class="s1">&quot;mode&quot;</span><span class="s0">,</span><span class="s1">&quot;redirect&quot;</span><span class="s0">,</span><span class="s1">&quot;credentials&quot;</span><span class="s0">,</span><span class="s1">&quot;referrer&quot;</span><span class="s0">,</span><span class="s1">&quot;referrerPolicy&quot;</span><span class="s0">,</span><span class="s1">&quot;integrity&quot;</span><span class="s0">,</span><span class="s1">&quot;createHash&quot;</span><span class="s0">,</span><span class="s1">&quot;digest&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheData&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidateAfter&quot;</span><span class="s0">,</span><span class="s1">&quot;workUnitStore&quot;</span><span class="s0">,</span><span class="s1">&quot;workUnitAsyncStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;resumeDataCache&quot;</span><span class="s0">,</span><span class="s1">&quot;getRenderResumeDataCache&quot;</span><span class="s0">,</span><span class="s1">&quot;memoryCacheData&quot;</span><span class="s0">,</span><span class="s1">&quot;fetch&quot;</span><span class="s0">,</span><span class="s1">&quot;workStore&quot;</span><span class="s0">,</span><span class="s1">&quot;workAsyncStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingRevalidatedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;age&quot;</span><span class="s0">,</span><span class="s1">&quot;notFoundRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;prerenderResumeDataCache&quot;</span><span class="s0">,</span><span class="s1">&quot;getPrerenderResumeDataCache&quot;</span><span class="s0">,</span><span class="s1">&quot;itemSize&quot;</span><span class="s0">,</span><span class="s1">&quot;isImplicitBuildTimeCache&quot;</span><span class="s0">,</span><span class="s1">&quot;warningText&quot;</span><span class="s0">,</span><span class="s1">&quot;handlersSymbol&quot;</span><span class="s0">,</span><span class="s1">&quot;handlersMapSymbol&quot;</span><span class="s0">,</span><span class="s1">&quot;handlersSetSymbol&quot;</span><span class="s0">,</span><span class="s1">&quot;reference&quot;</span><span class="s0">,</span><span class="s1">&quot;interopDefault&quot;</span><span class="s0">,</span><span class="s1">&quot;mod&quot;</span><span class="s0">,</span><span class="s1">&quot;default&quot;</span><span class="s0">,</span><span class="s1">&quot;RouterServerContextSymbol&quot;</span><span class="s0">,</span><span class="s1">&quot;routerServerGlobal&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicImportEsmDefault&quot;</span><span class="s0">,</span><span class="s1">&quot;id&quot;</span><span class="s0">,</span><span class="s1">&quot;RouteModule&quot;</span><span class="s0">,</span><span class="s1">&quot;userland&quot;</span><span class="s0">,</span><span class="s1">&quot;definition&quot;</span><span class="s0">,</span><span class="s1">&quot;relativeProjectDir&quot;</span><span class="s0">,</span><span class="s1">&quot;isDev&quot;</span><span class="s0">,</span><span class="s1">&quot;instrumentationOnRequestError&quot;</span><span class="s0">,</span><span class="s1">&quot;absoluteProjectDir&quot;</span><span class="s0">,</span><span class="s1">&quot;cwd&quot;</span><span class="s0">,</span><span class="s1">&quot;loadManifests&quot;</span><span class="s0">,</span><span class="s1">&quot;srcPage&quot;</span><span class="s0">,</span><span class="s1">&quot;projectDir&quot;</span><span class="s0">,</span><span class="s1">&quot;loadManifestFromRelativePath&quot;</span><span class="s0">,</span><span class="s1">&quot;routesManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;buildManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;fallbackBuildManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;reactLoadableManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;nextFontManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;clientReferenceManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;serverActionsManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;subresourceIntegrityManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;serverFilesManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicCssManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;manifest&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldCache&quot;</span><span class="s0">,</span><span class="s1">&quot;handleMissing&quot;</span><span class="s0">,</span><span class="s1">&quot;isAppRouter&quot;</span><span class="s0">,</span><span class="s1">&quot;isStaticMetadataRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;isAppRouteRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;isMetadataRouteFile&quot;</span><span class="s0">,</span><span class="s1">&quot;appDirRelativePath&quot;</span><span class="s0">,</span><span class="s1">&quot;pageExtensions&quot;</span><span class="s0">,</span><span class="s1">&quot;strictlyMatchExtensions&quot;</span><span class="s0">,</span><span class="s1">&quot;trailingMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;suffixMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;metadataRouteFilesRegex&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedAppDirRelativePath&quot;</span><span class="s0">,</span><span class="s1">&quot;useEval&quot;</span><span class="s0">,</span><span class="s1">&quot;skipParse&quot;</span><span class="s0">,</span><span class="s1">&quot;__RSC_MANIFEST&quot;</span><span class="s0">,</span><span class="s1">&quot;interceptionRoutePatterns&quot;</span><span class="s0">,</span><span class="s1">&quot;rewrites&quot;</span><span class="s0">,</span><span class="s1">&quot;beforeFiles&quot;</span><span class="s0">,</span><span class="s1">&quot;rewrite&quot;</span><span class="s0">,</span><span class="s1">&quot;regex&quot;</span><span class="s0">,</span><span class="s1">&quot;loadCustomCacheHandlers&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheHandlers&quot;</span><span class="s0">,</span><span class="s1">&quot;experimental&quot;</span><span class="s0">,</span><span class="s1">&quot;initializeCacheHandlers&quot;</span><span class="s0">,</span><span class="s1">&quot;fallback&quot;</span><span class="s0">,</span><span class="s1">&quot;DefaultCache&quot;</span><span class="s0">,</span><span class="s1">&quot;DefaultCacheHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;RemoteCache&quot;</span><span class="s0">,</span><span class="s1">&quot;handler&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;getIncrementalCache&quot;</span><span class="s0">,</span><span class="s1">&quot;CacheHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheMaxMemorySize&quot;</span><span class="s0">,</span><span class="s1">&quot;isrFlushToDisk&quot;</span><span class="s0">,</span><span class="s1">&quot;onRequestError&quot;</span><span class="s0">,</span><span class="s1">&quot;errorContext&quot;</span><span class="s0">,</span><span class="s1">&quot;routerServerContext&quot;</span><span class="s0">,</span><span class="s1">&quot;logErrorWithOriginalStack&quot;</span><span class="s0">,</span><span class="s1">&quot;prepare&quot;</span><span class="s0">,</span><span class="s1">&quot;localeResult&quot;</span><span class="s0">,</span><span class="s1">&quot;previewData&quot;</span><span class="s0">,</span><span class="s1">&quot;relative&quot;</span><span class="s0">,</span><span class="s1">&quot;absoluteDistDir&quot;</span><span class="s0">,</span><span class="s1">&quot;ensureInstrumentationRegistered&quot;</span><span class="s0">,</span><span class="s1">&quot;manifests&quot;</span><span class="s0">,</span><span class="s1">&quot;isNextDataRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;originalPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;originalQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;pageIsDynamic&quot;</span><span class="s0">,</span><span class="s1">&quot;serverUtils&quot;</span><span class="s0">,</span><span class="s1">&quot;getServerUtils&quot;</span><span class="s0">,</span><span class="s1">&quot;caseSensitive&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultRouteRegex&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicRouteMatcher&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultRouteMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;getNamedRouteRegex&quot;</span><span class="s0">,</span><span class="s1">&quot;getNamedParametrizedRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;prefixRouteKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;routeKey&quot;</span><span class="s0">,</span><span class="s1">&quot;j&quot;</span><span class="s0">,</span><span class="s1">&quot;fromCharCode&quot;</span><span class="s0">,</span><span class="s1">&quot;hasInterceptionMarker&quot;</span><span class="s0">,</span><span class="s1">&quot;namedParameterizedRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;namedRegex&quot;</span><span class="s0">,</span><span class="s1">&quot;handleRewrites&quot;</span><span class="s0">,</span><span class="s1">&quot;rewriteParams&quot;</span><span class="s0">,</span><span class="s1">&quot;fsPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;checkRewrite&quot;</span><span class="s0">,</span><span class="s1">&quot;matcher&quot;</span><span class="s0">,</span><span class="s1">&quot;getPathMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;regexp&quot;</span><span class="s0">,</span><span class="s1">&quot;delimiter&quot;</span><span class="s0">,</span><span class="s1">&quot;sensitive&quot;</span><span class="s0">,</span><span class="s1">&quot;regexpToFunction&quot;</span><span class="s0">,</span><span class="s1">&quot;regexModifier&quot;</span><span class="s0">,</span><span class="s1">&quot;source&quot;</span><span class="s0">,</span><span class="s1">&quot;flags&quot;</span><span class="s0">,</span><span class="s1">&quot;removeUnnamedParams&quot;</span><span class="s0">,</span><span class="s1">&quot;missing&quot;</span><span class="s0">,</span><span class="s1">&quot;hasParams&quot;</span><span class="s0">,</span><span class="s1">&quot;matchHas&quot;</span><span class="s0">,</span><span class="s1">&quot;hasMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;hasItem&quot;</span><span class="s0">,</span><span class="s1">&quot;getSafeParamName&quot;</span><span class="s0">,</span><span class="s1">&quot;paramName&quot;</span><span class="s0">,</span><span class="s1">&quot;newParamName&quot;</span><span class="s0">,</span><span class="s1">&quot;charCode&quot;</span><span class="s0">,</span><span class="s1">&quot;charCodeAt&quot;</span><span class="s0">,</span><span class="s1">&quot;matches&quot;</span><span class="s0">,</span><span class="s1">&quot;groupKey&quot;</span><span class="s0">,</span><span class="s1">&quot;stateHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;getSelectedParams&quot;</span><span class="s0">,</span><span class="s1">&quot;currentTree&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoute&quot;</span><span class="s0">,</span><span class="s1">&quot;isDynamicParameter&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentValue&quot;</span><span class="s0">,</span><span class="s1">&quot;parseAndValidateFlightRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;assert&quot;</span><span class="s0">,</span><span class="s1">&quot;parsedDestination&quot;</span><span class="s0">,</span><span class="s1">&quot;destQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;prepareDestination&quot;</span><span class="s0">,</span><span class="s1">&quot;destHostnameCompiler&quot;</span><span class="s0">,</span><span class="s1">&quot;newUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;parseDestination&quot;</span><span class="s0">,</span><span class="s1">&quot;escaped&quot;</span><span class="s0">,</span><span class="s1">&quot;destination&quot;</span><span class="s0">,</span><span class="s1">&quot;parseRelativeUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;parseQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;globalBase&quot;</span><span class="s0">,</span><span class="s1">&quot;resolvedBase&quot;</span><span class="s0">,</span><span class="s1">&quot;parsedURL&quot;</span><span class="s0">,</span><span class="s1">&quot;destHostname&quot;</span><span class="s0">,</span><span class="s1">&quot;destSearch&quot;</span><span class="s0">,</span><span class="s1">&quot;destPath&quot;</span><span class="s0">,</span><span class="s1">&quot;destParams&quot;</span><span class="s0">,</span><span class="s1">&quot;destPathParamKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;destHostnameParamKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;destPathCompiler&quot;</span><span class="s0">,</span><span class="s1">&quot;strOrArray&quot;</span><span class="s0">,</span><span class="s1">&quot;appendParamsToQuery&quot;</span><span class="s0">,</span><span class="s1">&quot;actualValue&quot;</span><span class="s0">,</span><span class="s1">&quot;nextInternalLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicParams&quot;</span><span class="s0">,</span><span class="s1">&quot;afterFiles&quot;</span><span class="s0">,</span><span class="s1">&quot;matchesPage&quot;</span><span class="s0">,</span><span class="s1">&quot;fsPathnameNoSlash&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeQueryParams&quot;</span><span class="s0">,</span><span class="s1">&quot;routeParamKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedKey&quot;</span><span class="s0">,</span><span class="s1">&quot;getParamsFromRouteMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;routeMatchesHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;routeMatches&quot;</span><span class="s0">,</span><span class="s1">&quot;obj&quot;</span><span class="s0">,</span><span class="s1">&quot;URLSearchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;keyName&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeDynamicRouteParams&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreMissingOptional&quot;</span><span class="s0">,</span><span class="s1">&quot;hasValidParams&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultValue&quot;</span><span class="s0">,</span><span class="s1">&quot;isOptional&quot;</span><span class="s0">,</span><span class="s1">&quot;isDefaultValue&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultVal&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeCdnUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;_parsedUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;formatUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;urlObj&quot;</span><span class="s0">,</span><span class="s1">&quot;querystring&quot;</span><span class="s0">,</span><span class="s1">&quot;interpolateDynamicPath&quot;</span><span class="s0">,</span><span class="s1">&quot;paramValue&quot;</span><span class="s0">,</span><span class="s1">&quot;builtParam&quot;</span><span class="s0">,</span><span class="s1">&quot;replaceAll&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_TRAILING_SLASH&quot;</span><span class="s0">,</span><span class="s1">&quot;addRequestMeta&quot;</span><span class="s0">,</span><span class="s1">&quot;request&quot;</span><span class="s0">,</span><span class="s1">&quot;rewriteParamKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;paramsMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;paramsResult&quot;</span><span class="s0">,</span><span class="s1">&quot;combinedParamKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;originalValue&quot;</span><span class="s0">,</span><span class="s1">&quot;queryValue&quot;</span><span class="s0">,</span><span class="s1">&quot;queryResult&quot;</span><span class="s0">,</span><span class="s1">&quot;paramsToInterpolate&quot;</span><span class="s0">,</span><span class="s1">&quot;isDraftMode&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedSrcPage&quot;</span><span class="s0">,</span><span class="s1">&quot;resolvedPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;seg&quot;</span><span class="s0">,</span><span class="s1">&quot;char&quot;</span><span class="s0">,</span><span class="s1">&quot;getResponseCache&quot;</span><span class="s0">,</span><span class="s1">&quot;responseCache&quot;</span><span class="s0">,</span><span class="s1">&quot;handleResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;purpose&quot;</span><span class="s0">,</span><span class="s1">&quot;getObjectClassLabel&quot;</span><span class="s0">,</span><span class="s1">&quot;prototype&quot;</span><span class="s0">,</span><span class="s1">&quot;isPlainObject&quot;</span><span class="s0">,</span><span class="s1">&quot;getPrototypeOf&quot;</span><span class="s0">,</span><span class="s1">&quot;hasOwnProperty&quot;</span><span class="s0">,</span><span class="s1">&quot;regexpPlainIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;SerializableError&quot;</span><span class="s0">,</span><span class="s1">&quot;isSerializableProps&quot;</span><span class="s0">,</span><span class="s1">&quot;visit&quot;</span><span class="s0">,</span><span class="s1">&quot;visited&quot;</span><span class="s0">,</span><span class="s1">&quot;isSerializable&quot;</span><span class="s0">,</span><span class="s1">&quot;refs&quot;</span><span class="s0">,</span><span class="s1">&quot;nestedValue&quot;</span><span class="s0">,</span><span class="s1">&quot;nextPath&quot;</span><span class="s0">,</span><span class="s1">&quot;newRefs&quot;</span><span class="s0">,</span><span class="s1">&quot;AmpStateContext&quot;</span><span class="s0">,</span><span class="s1">&quot;React&quot;</span><span class="s0">,</span><span class="s1">&quot;HeadManagerContext&quot;</span><span class="s0">,</span><span class="s1">&quot;LoadableContext&quot;</span><span class="s0">,</span><span class="s1">&quot;ALL_INITIALIZERS&quot;</span><span class="s0">,</span><span class="s1">&quot;READY_INITIALIZERS&quot;</span><span class="s0">,</span><span class="s1">&quot;load&quot;</span><span class="s0">,</span><span class="s1">&quot;loader&quot;</span><span class="s0">,</span><span class="s1">&quot;loading&quot;</span><span class="s0">,</span><span class="s1">&quot;loaded&quot;</span><span class="s0">,</span><span class="s1">&quot;LoadableSubscription&quot;</span><span class="s0">,</span><span class="s1">&quot;_res&quot;</span><span class="s0">,</span><span class="s1">&quot;retry&quot;</span><span class="s0">,</span><span class="s1">&quot;_clearTimeouts&quot;</span><span class="s0">,</span><span class="s1">&quot;_loadFn&quot;</span><span class="s0">,</span><span class="s1">&quot;_opts&quot;</span><span class="s0">,</span><span class="s1">&quot;_state&quot;</span><span class="s0">,</span><span class="s1">&quot;pastDelay&quot;</span><span class="s0">,</span><span class="s1">&quot;timedOut&quot;</span><span class="s0">,</span><span class="s1">&quot;delay&quot;</span><span class="s0">,</span><span class="s1">&quot;_delay&quot;</span><span class="s0">,</span><span class="s1">&quot;setTimeout&quot;</span><span class="s0">,</span><span class="s1">&quot;_update&quot;</span><span class="s0">,</span><span class="s1">&quot;timeout&quot;</span><span class="s0">,</span><span class="s1">&quot;_timeout&quot;</span><span class="s0">,</span><span class="s1">&quot;_err&quot;</span><span class="s0">,</span><span class="s1">&quot;partial&quot;</span><span class="s0">,</span><span class="s1">&quot;_callbacks&quot;</span><span class="s0">,</span><span class="s1">&quot;callback&quot;</span><span class="s0">,</span><span class="s1">&quot;clearTimeout&quot;</span><span class="s0">,</span><span class="s1">&quot;getCurrentValue&quot;</span><span class="s0">,</span><span class="s1">&quot;subscribe&quot;</span><span class="s0">,</span><span class="s1">&quot;loadFn&quot;</span><span class="s0">,</span><span class="s1">&quot;Loadable&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack&quot;</span><span class="s0">,</span><span class="s1">&quot;modules&quot;</span><span class="s0">,</span><span class="s1">&quot;subscription&quot;</span><span class="s0">,</span><span class="s1">&quot;sub&quot;</span><span class="s0">,</span><span class="s1">&quot;LoadableComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;ref&quot;</span><span class="s0">,</span><span class="s1">&quot;moduleName&quot;</span><span class="s0">,</span><span class="s1">&quot;isLoading&quot;</span><span class="s0">,</span><span class="s1">&quot;flushInitializers&quot;</span><span class="s0">,</span><span class="s1">&quot;initializers&quot;</span><span class="s0">,</span><span class="s1">&quot;ids&quot;</span><span class="s0">,</span><span class="s1">&quot;promises&quot;</span><span class="s0">,</span><span class="s1">&quot;pop&quot;</span><span class="s0">,</span><span class="s1">&quot;preloadAll&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveInitializers&quot;</span><span class="s0">,</span><span class="s1">&quot;preloadReady&quot;</span><span class="s0">,</span><span class="s1">&quot;resolvePreload&quot;</span><span class="s0">,</span><span class="s1">&quot;RouterContext&quot;</span><span class="s0">,</span><span class="s1">&quot;HtmlContext&quot;</span><span class="s0">,</span><span class="s1">&quot;createContext&quot;</span><span class="s0">,</span><span class="s1">&quot;useHtmlContext&quot;</span><span class="s0">,</span><span class="s1">&quot;useContext&quot;</span><span class="s0">,</span><span class="s1">&quot;RedirectStatusCode&quot;</span><span class="s0">,</span><span class="s1">&quot;allowedStatusCodes&quot;</span><span class="s0">,</span><span class="s1">&quot;getRedirectStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;statusCode&quot;</span><span class="s0">,</span><span class="s1">&quot;permanent&quot;</span><span class="s0">,</span><span class="s1">&quot;ImageConfigContext&quot;</span><span class="s0">,</span><span class="s1">&quot;deviceSizes&quot;</span><span class="s0">,</span><span class="s1">&quot;imageSizes&quot;</span><span class="s0">,</span><span class="s1">&quot;loaderFile&quot;</span><span class="s0">,</span><span class="s1">&quot;disableStaticImages&quot;</span><span class="s0">,</span><span class="s1">&quot;minimumCacheTTL&quot;</span><span class="s0">,</span><span class="s1">&quot;formats&quot;</span><span class="s0">,</span><span class="s1">&quot;dangerouslyAllowSVG&quot;</span><span class="s0">,</span><span class="s1">&quot;contentSecurityPolicy&quot;</span><span class="s0">,</span><span class="s1">&quot;contentDispositionType&quot;</span><span class="s0">,</span><span class="s1">&quot;localPatterns&quot;</span><span class="s0">,</span><span class="s1">&quot;remotePatterns&quot;</span><span class="s0">,</span><span class="s1">&quot;qualities&quot;</span><span class="s0">,</span><span class="s1">&quot;unoptimized&quot;</span><span class="s0">,</span><span class="s1">&quot;INTERNAL_QUERY_NAMES&quot;</span><span class="s0">,</span><span class="s1">&quot;SearchParamsContext&quot;</span><span class="s0">,</span><span class="s1">&quot;PathnameContext&quot;</span><span class="s0">,</span><span class="s1">&quot;PathParamsContext&quot;</span><span class="s0">,</span><span class="s1">&quot;PathnameContextProviderAdapter&quot;</span><span class="s0">,</span><span class="s1">&quot;children&quot;</span><span class="s0">,</span><span class="s1">&quot;router&quot;</span><span class="s0">,</span><span class="s1">&quot;useRef&quot;</span><span class="s0">,</span><span class="s1">&quot;isAutoExport&quot;</span><span class="s0">,</span><span class="s1">&quot;useMemo&quot;</span><span class="s0">,</span><span class="s1">&quot;isReady&quot;</span><span class="s0">,</span><span class="s1">&quot;asPath&quot;</span><span class="s0">,</span><span class="s1">&quot;AppRouterContext&quot;</span><span class="s0">,</span><span class="s1">&quot;LayoutRouterContext&quot;</span><span class="s0">,</span><span class="s1">&quot;GlobalLayoutRouterContext&quot;</span><span class="s0">,</span><span class="s1">&quot;TemplateContext&quot;</span><span class="s0">,</span><span class="s1">&quot;MissingSlotContext&quot;</span><span class="s0">,</span><span class="s1">&quot;symbolError&quot;</span><span class="s0">,</span><span class="s1">&quot;ESCAPE_REGEX&quot;</span><span class="s0">,</span><span class="s1">&quot;DOCTYPE&quot;</span><span class="s0">,</span><span class="s1">&quot;noRouter&quot;</span><span class="s0">,</span><span class="s1">&quot;renderToString&quot;</span><span class="s0">,</span><span class="s1">&quot;element&quot;</span><span class="s0">,</span><span class="s1">&quot;renderStream&quot;</span><span class="s0">,</span><span class="s1">&quot;ReactDOMServerPages&quot;</span><span class="s0">,</span><span class="s1">&quot;allReady&quot;</span><span class="s0">,</span><span class="s1">&quot;ServerRouter&quot;</span><span class="s0">,</span><span class="s1">&quot;as&quot;</span><span class="s0">,</span><span class="s1">&quot;domainLocales&quot;</span><span class="s0">,</span><span class="s1">&quot;isPreview&quot;</span><span class="s0">,</span><span class="s1">&quot;isLocaleDomain&quot;</span><span class="s0">,</span><span class="s1">&quot;reload&quot;</span><span class="s0">,</span><span class="s1">&quot;back&quot;</span><span class="s0">,</span><span class="s1">&quot;forward&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;beforePopState&quot;</span><span class="s0">,</span><span class="s1">&quot;renderPageTree&quot;</span><span class="s0">,</span><span class="s1">&quot;invalidKeysMsg&quot;</span><span class="s0">,</span><span class="s1">&quot;methodName&quot;</span><span class="s0">,</span><span class="s1">&quot;invalidKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;docsPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;toLocaleLowerCase&quot;</span><span class="s0">,</span><span class="s1">&quot;checkRedirectValues&quot;</span><span class="s0">,</span><span class="s1">&quot;errors&quot;</span><span class="s0">,</span><span class="s1">&quot;hasStatusCode&quot;</span><span class="s0">,</span><span class="s1">&quot;hasPermanent&quot;</span><span class="s0">,</span><span class="s1">&quot;destinationType&quot;</span><span class="s0">,</span><span class="s1">&quot;basePathType&quot;</span><span class="s0">,</span><span class="s1">&quot;renderToHTMLImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;extra&quot;</span><span class="s0">,</span><span class="s1">&quot;sharedContext&quot;</span><span class="s0">,</span><span class="s1">&quot;renderContext&quot;</span><span class="s0">,</span><span class="s1">&quot;assetQueryString&quot;</span><span class="s0">,</span><span class="s1">&quot;userAgent&quot;</span><span class="s0">,</span><span class="s1">&quot;deploymentId&quot;</span><span class="s0">,</span><span class="s1">&quot;ampPath&quot;</span><span class="s0">,</span><span class="s1">&quot;pageConfig&quot;</span><span class="s0">,</span><span class="s1">&quot;ErrorDebug&quot;</span><span class="s0">,</span><span class="s1">&quot;getStaticProps&quot;</span><span class="s0">,</span><span class="s1">&quot;getStaticPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;getServerSideProps&quot;</span><span class="s0">,</span><span class="s1">&quot;images&quot;</span><span class="s0">,</span><span class="s1">&quot;runtime&quot;</span><span class="s0">,</span><span class="s1">&quot;globalRuntime&quot;</span><span class="s0">,</span><span class="s1">&quot;isExperimentalCompile&quot;</span><span class="s0">,</span><span class="s1">&quot;expireTime&quot;</span><span class="s0">,</span><span class="s1">&quot;Document&quot;</span><span class="s0">,</span><span class="s1">&quot;notFoundSrcPage&quot;</span><span class="s0">,</span><span class="s1">&quot;developmentNotFoundSourcePage&quot;</span><span class="s0">,</span><span class="s1">&quot;isSSG&quot;</span><span class="s0">,</span><span class="s1">&quot;isBuildTimeSSG&quot;</span><span class="s0">,</span><span class="s1">&quot;nextExport&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultAppGetInitialProps&quot;</span><span class="s0">,</span><span class="s1">&quot;origGetInitialProps&quot;</span><span class="s0">,</span><span class="s1">&quot;hasPageGetInitialProps&quot;</span><span class="s0">,</span><span class="s1">&quot;hasPageScripts&quot;</span><span class="s0">,</span><span class="s1">&quot;unstable_scriptLoader&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultErrorGetInitialProps&quot;</span><span class="s0">,</span><span class="s1">&quot;getCacheControlHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;swrHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;nextConfigOutput&quot;</span><span class="s0">,</span><span class="s1">&quot;resolvedAsPath&quot;</span><span class="s0">,</span><span class="s1">&quot;isValidElementType&quot;</span><span class="s0">,</span><span class="s1">&quot;amp&quot;</span><span class="s0">,</span><span class="s1">&quot;setIsrStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;routerIsReady&quot;</span><span class="s0">,</span><span class="s1">&quot;appRouter&quot;</span><span class="s0">,</span><span class="s1">&quot;pagesRouter&quot;</span><span class="s0">,</span><span class="s1">&quot;refresh&quot;</span><span class="s0">,</span><span class="s1">&quot;hmrRefresh&quot;</span><span class="s0">,</span><span class="s1">&quot;scroll&quot;</span><span class="s0">,</span><span class="s1">&quot;scriptLoader&quot;</span><span class="s0">,</span><span class="s1">&quot;jsxStyleRegistry&quot;</span><span class="s0">,</span><span class="s1">&quot;createStyleRegistry&quot;</span><span class="s0">,</span><span class="s1">&quot;ampState&quot;</span><span class="s0">,</span><span class="s1">&quot;ampFirst&quot;</span><span class="s0">,</span><span class="s1">&quot;hybrid&quot;</span><span class="s0">,</span><span class="s1">&quot;isInAmpMode&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultHead&quot;</span><span class="s0">,</span><span class="s1">&quot;charSet&quot;</span><span class="s0">,</span><span class="s1">&quot;reactLoadableModules&quot;</span><span class="s0">,</span><span class="s1">&quot;initialScripts&quot;</span><span class="s0">,</span><span class="s1">&quot;beforeInteractive&quot;</span><span class="s0">,</span><span class="s1">&quot;script&quot;</span><span class="s0">,</span><span class="s1">&quot;strategy&quot;</span><span class="s0">,</span><span class="s1">&quot;csp&quot;</span><span class="s0">,</span><span class="s1">&quot;nonce&quot;</span><span class="s0">,</span><span class="s1">&quot;getScriptNonceFromHeader&quot;</span><span class="s0">,</span><span class="s1">&quot;cspHeaderValue&quot;</span><span class="s0">,</span><span class="s1">&quot;directive&quot;</span><span class="s0">,</span><span class="s1">&quot;directives&quot;</span><span class="s0">,</span><span class="s1">&quot;trim&quot;</span><span class="s0">,</span><span class="s1">&quot;AppContainer&quot;</span><span class="s0">,</span><span class="s1">&quot;adaptForPathParams&quot;</span><span class="s0">,</span><span class="s1">&quot;pathParams&quot;</span><span class="s0">,</span><span class="s1">&quot;routeRegex&quot;</span><span class="s0">,</span><span class="s1">&quot;updateHead&quot;</span><span class="s0">,</span><span class="s1">&quot;updateScripts&quot;</span><span class="s0">,</span><span class="s1">&quot;scripts&quot;</span><span class="s0">,</span><span class="s1">&quot;mountedInstances&quot;</span><span class="s0">,</span><span class="s1">&quot;StyleRegistry&quot;</span><span class="s0">,</span><span class="s1">&quot;registry&quot;</span><span class="s0">,</span><span class="s1">&quot;Noop&quot;</span><span class="s0">,</span><span class="s1">&quot;AppContainerWithIsomorphicFiberStructure&quot;</span><span class="s0">,</span><span class="s1">&quot;AppTree&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultGetInitialProps&quot;</span><span class="s0">,</span><span class="s1">&quot;docCtx&quot;</span><span class="s0">,</span><span class="s1">&quot;renderPageHead&quot;</span><span class="s0">,</span><span class="s1">&quot;renderPage&quot;</span><span class="s0">,</span><span class="s1">&quot;enhanceApp&quot;</span><span class="s0">,</span><span class="s1">&quot;AppComp&quot;</span><span class="s0">,</span><span class="s1">&quot;styles&quot;</span><span class="s0">,</span><span class="s1">&quot;__N_PREVIEW&quot;</span><span class="s0">,</span><span class="s1">&quot;attributes&quot;</span><span class="s0">,</span><span class="s1">&quot;draftMode&quot;</span><span class="s0">,</span><span class="s1">&quot;revalidateReason&quot;</span><span class="s0">,</span><span class="s1">&quot;staticPropsError&quot;</span><span class="s0">,</span><span class="s1">&quot;notFound&quot;</span><span class="s0">,</span><span class="s1">&quot;isNotFound&quot;</span><span class="s0">,</span><span class="s1">&quot;__N_REDIRECT&quot;</span><span class="s0">,</span><span class="s1">&quot;__N_REDIRECT_STATUS&quot;</span><span class="s0">,</span><span class="s1">&quot;__N_REDIRECT_BASE_PATH&quot;</span><span class="s0">,</span><span class="s1">&quot;isRedirect&quot;</span><span class="s0">,</span><span class="s1">&quot;isInteger&quot;</span><span class="s0">,</span><span class="s1">&quot;ceil&quot;</span><span class="s0">,</span><span class="s1">&quot;deferredContent&quot;</span><span class="s0">,</span><span class="s1">&quot;resolvedUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;serverSidePropsError&quot;</span><span class="s0">,</span><span class="s1">&quot;isError&quot;</span><span class="s0">,</span><span class="s1">&quot;unstable_notFound&quot;</span><span class="s0">,</span><span class="s1">&quot;unstable_redirect&quot;</span><span class="s0">,</span><span class="s1">&quot;filteredBuildManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;_page&quot;</span><span class="s0">,</span><span class="s1">&quot;pages&quot;</span><span class="s0">,</span><span class="s1">&quot;lowPriorityFiles&quot;</span><span class="s0">,</span><span class="s1">&quot;Body&quot;</span><span class="s0">,</span><span class="s1">&quot;div&quot;</span><span class="s0">,</span><span class="s1">&quot;renderDocument&quot;</span><span class="s0">,</span><span class="s1">&quot;documentInitialPropsRes&quot;</span><span class="s0">,</span><span class="s1">&quot;loadDocumentInitialProps&quot;</span><span class="s0">,</span><span class="s1">&quot;renderShell&quot;</span><span class="s0">,</span><span class="s1">&quot;EnhancedApp&quot;</span><span class="s0">,</span><span class="s1">&quot;EnhancedComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;enhanceComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;documentCtx&quot;</span><span class="s0">,</span><span class="s1">&quot;docProps&quot;</span><span class="s0">,</span><span class="s1">&quot;renderContent&quot;</span><span class="s0">,</span><span class="s1">&quot;_App&quot;</span><span class="s0">,</span><span class="s1">&quot;_Component&quot;</span><span class="s0">,</span><span class="s1">&quot;renderToInitialFizzStream&quot;</span><span class="s0">,</span><span class="s1">&quot;streamOptions&quot;</span><span class="s0">,</span><span class="s1">&quot;renderToReadableStream&quot;</span><span class="s0">,</span><span class="s1">&quot;hasDocumentGetInitialProps&quot;</span><span class="s0">,</span><span class="s1">&quot;rawStyledJsxInsertedHTML&quot;</span><span class="s0">,</span><span class="s1">&quot;styledJsxInsertedHTML&quot;</span><span class="s0">,</span><span class="s1">&quot;contentHTML&quot;</span><span class="s0">,</span><span class="s1">&quot;documentElement&quot;</span><span class="s0">,</span><span class="s1">&quot;htmlProps&quot;</span><span class="s0">,</span><span class="s1">&quot;headTags&quot;</span><span class="s0">,</span><span class="s1">&quot;setRootSpanAttribute&quot;</span><span class="s0">,</span><span class="s1">&quot;documentResult&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicImportsIds&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicImports&quot;</span><span class="s0">,</span><span class="s1">&quot;manifestItem&quot;</span><span class="s0">,</span><span class="s1">&quot;files&quot;</span><span class="s0">,</span><span class="s1">&quot;disableOptimizedLoading&quot;</span><span class="s0">,</span><span class="s1">&quot;runtimeConfig&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_DATA__&quot;</span><span class="s0">,</span><span class="s1">&quot;autoExport&quot;</span><span class="s0">,</span><span class="s1">&quot;dynamicIds&quot;</span><span class="s0">,</span><span class="s1">&quot;serializeError&quot;</span><span class="s0">,</span><span class="s1">&quot;errorToJSON&quot;</span><span class="s0">,</span><span class="s1">&quot;getErrorSource&quot;</span><span class="s0">,</span><span class="s1">&quot;stripAnsi&quot;</span><span class="s0">,</span><span class="s1">&quot;stack&quot;</span><span class="s0">,</span><span class="s1">&quot;gsp&quot;</span><span class="s0">,</span><span class="s1">&quot;gssp&quot;</span><span class="s0">,</span><span class="s1">&quot;customServer&quot;</span><span class="s0">,</span><span class="s1">&quot;gip&quot;</span><span class="s0">,</span><span class="s1">&quot;appGip&quot;</span><span class="s0">,</span><span class="s1">&quot;docComponentsRendered&quot;</span><span class="s0">,</span><span class="s1">&quot;dangerousAsPath&quot;</span><span class="s0">,</span><span class="s1">&quot;canonicalBase&quot;</span><span class="s0">,</span><span class="s1">&quot;isDevelopment&quot;</span><span class="s0">,</span><span class="s1">&quot;unstable_runtimeJS&quot;</span><span class="s0">,</span><span class="s1">&quot;unstable_JsPreload&quot;</span><span class="s0">,</span><span class="s1">&quot;crossOrigin&quot;</span><span class="s0">,</span><span class="s1">&quot;nextScriptWorkers&quot;</span><span class="s0">,</span><span class="s1">&quot;largePageDataBytes&quot;</span><span class="s0">,</span><span class="s1">&quot;experimentalClientTraceMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;clientTraceMetadata&quot;</span><span class="s0">,</span><span class="s1">&quot;document&quot;</span><span class="s0">,</span><span class="s1">&quot;documentHTML&quot;</span><span class="s0">,</span><span class="s1">&quot;renderTargetPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;renderTargetSuffix&quot;</span><span class="s0">,</span><span class="s1">&quot;renderToHTML&quot;</span><span class="s0">,</span><span class="s1">&quot;ServerInsertedHTMLContext&quot;</span><span class="s0">,</span><span class="s1">&quot;useServerInsertedHTML&quot;</span><span class="s0">,</span><span class="s1">&quot;addInsertedServerHTMLCallback&quot;</span><span class="s0">,</span><span class="s1">&quot;PagesRouteModule&quot;</span><span class="s0">,</span><span class="s1">&quot;components&quot;</span><span class="s0">,</span><span class="s1">&quot;render&quot;</span><span class="s0">,</span><span class="s1">&quot;vendored&quot;</span><span class="s0">,</span><span class="s1">&quot;contexts&quot;</span><span class="s0">,</span><span class="s1">&quot;vendoredContexts&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">,</span><span class="s2">1</span><span class="s0">,</span><span class="s2">2</span><span class="s0">,</span><span class="s2">3</span><span class="s0">,</span><span class="s2">4</span><span class="s0">,</span><span class="s2">5</span><span class="s0">,</span><span class="s2">6</span><span class="s0">,</span><span class="s2">7</span><span class="s0">,</span><span class="s2">8</span><span class="s0">,</span><span class="s2">9</span><span class="s0">,</span><span class="s2">10</span><span class="s0">,</span><span class="s2">11</span><span class="s0">,</span><span class="s2">12</span><span class="s0">,</span><span class="s2">13</span><span class="s0">,</span><span class="s2">14</span><span class="s0">,</span><span class="s2">15</span><span class="s0">,</span><span class="s2">16</span><span class="s0">,</span><span class="s2">17</span><span class="s0">,</span><span class="s2">18</span><span class="s0">,</span><span class="s2">19</span><span class="s0">,</span><span class="s2">20</span><span class="s0">,</span><span class="s2">21</span><span class="s0">,</span><span class="s2">22</span><span class="s0">,</span><span class="s2">23</span><span class="s0">,</span><span class="s2">24</span><span class="s0">,</span><span class="s2">25</span><span class="s0">,</span><span class="s2">26</span><span class="s0">,</span><span class="s2">27</span><span class="s0">,</span><span class="s2">28</span><span class="s0">,</span><span class="s2">29</span><span class="s0">,</span><span class="s2">30</span><span class="s0">,</span><span class="s2">31</span><span class="s0">,</span><span class="s2">32</span><span class="s0">,</span><span class="s2">33</span><span class="s0">,</span><span class="s2">34</span><span class="s0">,</span><span class="s2">35</span><span class="s0">,</span><span class="s2">36</span><span class="s0">,</span><span class="s2">37</span><span class="s0">,</span><span class="s2">38</span><span class="s0">,</span><span class="s2">39</span><span class="s0">,</span><span class="s2">40</span><span class="s0">,</span><span class="s2">41</span><span class="s0">,</span><span class="s2">42</span><span class="s0">,</span><span class="s2">43</span><span class="s0">,</span><span class="s2">44</span><span class="s0">,</span><span class="s2">45</span><span class="s0">,</span><span class="s2">46</span><span class="s0">,</span><span class="s2">47</span><span class="s0">,</span><span class="s2">48</span><span class="s0">,</span><span class="s2">49</span><span class="s0">,</span><span class="s2">50</span><span class="s0">,</span><span class="s2">51</span><span class="s0">,</span><span class="s2">52</span><span class="s0">,</span><span class="s2">53</span><span class="s0">,</span><span class="s2">54</span><span class="s0">,</span><span class="s2">55</span><span class="s0">,</span><span class="s2">56</span><span class="s0">,</span><span class="s2">57</span><span class="s0">,</span><span class="s2">58</span><span class="s0">,</span><span class="s2">59</span><span class="s0">,</span><span class="s2">60</span><span class="s0">,</span><span class="s2">61</span><span class="s0">,</span><span class="s2">62</span><span class="s0">,</span><span class="s2">63</span><span class="s0">,</span><span class="s2">64</span><span class="s0">,</span><span class="s2">65</span><span class="s0">,</span><span class="s2">66</span><span class="s0">,</span><span class="s2">67</span><span class="s0">,</span><span class="s2">68</span><span class="s0">,</span><span class="s2">69</span><span class="s0">,</span><span class="s2">70</span><span class="s0">,</span><span class="s2">71</span><span class="s0">,</span><span class="s2">72</span><span class="s0">,</span><span class="s2">73</span><span class="s0">,</span><span class="s2">74</span><span class="s0">,</span><span class="s2">75</span><span class="s0">,</span><span class="s2">76</span><span class="s0">,</span><span class="s2">77</span><span class="s0">,</span><span class="s2">78</span><span class="s0">,</span><span class="s2">79</span><span class="s0">,</span><span class="s2">80</span><span class="s0">,</span><span class="s2">81</span><span class="s0">,</span><span class="s2">82</span><span class="s0">,</span><span class="s2">83</span><span class="s0">,</span><span class="s2">84</span><span class="s0">,</span><span class="s2">85</span><span class="s0">,</span><span class="s2">86</span><span class="s0">,</span><span class="s2">87</span><span class="s0">,</span><span class="s2">88</span><span class="s0">,</span><span class="s2">89</span><span class="s0">,</span><span class="s2">90</span><span class="s0">,</span><span class="s2">91</span><span class="s0">,</span><span class="s2">92</span><span class="s0">,</span><span class="s2">93</span><span class="s0">,</span><span class="s2">94</span><span class="s0">,</span><span class="s2">95</span><span class="s0">,</span><span class="s2">96</span><span class="s0">,</span><span class="s2">97</span><span class="s0">,</span><span class="s2">98</span><span class="s0">,</span><span class="s2">99</span><span class="s0">,</span><span class="s2">100</span><span class="s0">,</span><span class="s2">101</span><span class="s0">,</span><span class="s2">102</span><span class="s0">,</span><span class="s2">103</span><span class="s0">,</span><span class="s2">104</span><span class="s0">,</span><span class="s2">105</span><span class="s0">,</span><span class="s2">106</span><span class="s0">,</span><span class="s2">107</span><span class="s0">,</span><span class="s2">108</span><span class="s0">,</span><span class="s2">109</span><span class="s0">,</span><span class="s2">110</span><span class="s0">,</span><span class="s2">111</span><span class="s0">,</span><span class="s2">112</span><span class="s0">,</span><span class="s2">113</span><span class="s0">,</span><span class="s2">114</span><span class="s0">,</span><span class="s2">115</span><span class="s0">,</span><span class="s2">116</span><span class="s0">,</span><span class="s2">117</span><span class="s0">,</span><span class="s2">118</span><span class="s0">,</span><span class="s2">119</span><span class="s0">,</span><span class="s2">120</span><span class="s0">,</span><span class="s2">121</span><span class="s0">,</span><span class="s2">122</span><span class="s0">,</span><span class="s2">123</span><span class="s0">,</span><span class="s2">124</span><span class="s0">,</span><span class="s2">125</span><span class="s0">,</span><span class="s2">126</span><span class="s0">,</span><span class="s2">127</span><span class="s0">,</span><span class="s2">128</span><span class="s0">,</span><span class="s2">129</span><span class="s0">,</span><span class="s2">130</span><span class="s0">]}</span></pre>
</body>
</html>