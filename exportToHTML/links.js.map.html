<html>
<head>
<title>links.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
links.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/client/components/links.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { FlightRouterState } from '../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import type { AppRouterInstance } from '../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import { getCurrentAppRouterState } from './app-router-instance'</span><span class="s3">\n</span><span class="s1">import { createPrefetchURL } from './app-router'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">FetchStrategy,</span><span class="s3">\n  </span><span class="s1">isPrefetchTaskDirty,</span><span class="s3">\n  </span><span class="s1">type PrefetchTaskFetchStrategy,</span><span class="s3">\n</span><span class="s1">} from './segment-cache'</span><span class="s3">\n</span><span class="s1">import { createCacheKey } from './segment-cache'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">type PrefetchTask,</span><span class="s3">\n  </span><span class="s1">PrefetchPriority,</span><span class="s3">\n  </span><span class="s1">schedulePrefetchTask as scheduleSegmentPrefetchTask,</span><span class="s3">\n  </span><span class="s1">cancelPrefetchTask,</span><span class="s3">\n  </span><span class="s1">reschedulePrefetchTask,</span><span class="s3">\n</span><span class="s1">} from './segment-cache'</span><span class="s3">\n</span><span class="s1">import { startTransition } from 'react'</span><span class="s3">\n</span><span class="s1">import { PrefetchKind } from './router-reducer/router-reducer-types'</span><span class="s3">\n</span><span class="s1">import { InvariantError } from '../../shared/lib/invariant-error'</span><span class="s3">\n\n</span><span class="s1">type LinkElement = HTMLAnchorElement | SVGAElement</span><span class="s3">\n\n</span><span class="s1">type Element = LinkElement | HTMLFormElement</span><span class="s3">\n\n</span><span class="s1">// Properties that are shared between Link and Form instances. We use the same</span><span class="s3">\n</span><span class="s1">// shape for both to prevent a polymorphic de-opt in the VM.</span><span class="s3">\n</span><span class="s1">type LinkOrFormInstanceShared = {</span><span class="s3">\n  </span><span class="s1">router: AppRouterInstance</span><span class="s3">\n  </span><span class="s1">fetchStrategy: PrefetchTaskFetchStrategy</span><span class="s3">\n\n  </span><span class="s1">isVisible: boolean</span><span class="s3">\n\n  </span><span class="s1">// The most recently initiated prefetch task. It may or may not have</span><span class="s3">\n  </span><span class="s1">// already completed. The same prefetch task object can be reused across</span><span class="s3">\n  </span><span class="s1">// multiple prefetches of the same link.</span><span class="s3">\n  </span><span class="s1">prefetchTask: PrefetchTask | null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export type FormInstance = LinkOrFormInstanceShared &amp; {</span><span class="s3">\n  </span><span class="s1">prefetchHref: string</span><span class="s3">\n  </span><span class="s1">setOptimisticLinkStatus: null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type PrefetchableLinkInstance = LinkOrFormInstanceShared &amp; {</span><span class="s3">\n  </span><span class="s1">prefetchHref: string</span><span class="s3">\n  </span><span class="s1">setOptimisticLinkStatus: (status: { pending: boolean }) =&gt; void</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type NonPrefetchableLinkInstance = LinkOrFormInstanceShared &amp; {</span><span class="s3">\n  </span><span class="s1">prefetchHref: null</span><span class="s3">\n  </span><span class="s1">setOptimisticLinkStatus: (status: { pending: boolean }) =&gt; void</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type PrefetchableInstance = PrefetchableLinkInstance | FormInstance</span><span class="s3">\n\n</span><span class="s1">export type LinkInstance =</span><span class="s3">\n  </span><span class="s1">| PrefetchableLinkInstance</span><span class="s3">\n  </span><span class="s1">| NonPrefetchableLinkInstance</span><span class="s3">\n\n</span><span class="s1">// Tracks the most recently navigated link instance. When null, indicates</span><span class="s3">\n</span><span class="s1">// the current navigation was not initiated by a link click.</span><span class="s3">\n</span><span class="s1">let linkForMostRecentNavigation: LinkInstance | null = null</span><span class="s3">\n\n</span><span class="s1">// Status object indicating link is pending</span><span class="s3">\n</span><span class="s1">export const PENDING_LINK_STATUS = { pending: true }</span><span class="s3">\n\n</span><span class="s1">// Status object indicating link is idle</span><span class="s3">\n</span><span class="s1">export const IDLE_LINK_STATUS = { pending: false }</span><span class="s3">\n\n</span><span class="s1">// Updates the loading state when navigating between links</span><span class="s3">\n</span><span class="s1">// - Resets the previous link's loading state</span><span class="s3">\n</span><span class="s1">// - Sets the new link's loading state</span><span class="s3">\n</span><span class="s1">// - Updates tracking of current navigation</span><span class="s3">\n</span><span class="s1">export function setLinkForCurrentNavigation(link: LinkInstance | null) {</span><span class="s3">\n  </span><span class="s1">startTransition(() =&gt; {</span><span class="s3">\n    </span><span class="s1">linkForMostRecentNavigation?.setOptimisticLinkStatus(IDLE_LINK_STATUS)</span><span class="s3">\n    </span><span class="s1">link?.setOptimisticLinkStatus(PENDING_LINK_STATUS)</span><span class="s3">\n    </span><span class="s1">linkForMostRecentNavigation = link</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Unmounts the current link instance from navigation tracking</span><span class="s3">\n</span><span class="s1">export function unmountLinkForCurrentNavigation(link: LinkInstance) {</span><span class="s3">\n  </span><span class="s1">if (linkForMostRecentNavigation === link) {</span><span class="s3">\n    </span><span class="s1">linkForMostRecentNavigation = null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Use a WeakMap to associate a Link instance with its DOM element. This is</span><span class="s3">\n</span><span class="s1">// used by the IntersectionObserver to track the link's visibility.</span><span class="s3">\n</span><span class="s1">const prefetchable:</span><span class="s3">\n  </span><span class="s1">| WeakMap&lt;Element, PrefetchableInstance&gt;</span><span class="s3">\n  </span><span class="s1">| Map&lt;Element, PrefetchableInstance&gt; =</span><span class="s3">\n  </span><span class="s1">typeof WeakMap === 'function' ? new WeakMap() : new Map()</span><span class="s3">\n\n</span><span class="s1">// A Set of the currently visible links. We re-prefetch visible links after a</span><span class="s3">\n</span><span class="s1">// cache invalidation, or when the current URL changes. It's a separate data</span><span class="s3">\n</span><span class="s1">// structure from the WeakMap above because only the visible links need to</span><span class="s3">\n</span><span class="s1">// be enumerated.</span><span class="s3">\n</span><span class="s1">const prefetchableAndVisible: Set&lt;PrefetchableInstance&gt; = new Set()</span><span class="s3">\n\n</span><span class="s1">// A single IntersectionObserver instance shared by all &lt;Link&gt; components.</span><span class="s3">\n</span><span class="s1">const observer: IntersectionObserver | null =</span><span class="s3">\n  </span><span class="s1">typeof IntersectionObserver === 'function'</span><span class="s3">\n    </span><span class="s1">? new IntersectionObserver(handleIntersect, {</span><span class="s3">\n        </span><span class="s1">rootMargin: '200px',</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">: null</span><span class="s3">\n\n</span><span class="s1">function observeVisibility(element: Element, instance: PrefetchableInstance) {</span><span class="s3">\n  </span><span class="s1">const existingInstance = prefetchable.get(element)</span><span class="s3">\n  </span><span class="s1">if (existingInstance !== undefined) {</span><span class="s3">\n    </span><span class="s1">// This shouldn't happen because each &lt;Link&gt; component should have its own</span><span class="s3">\n    </span><span class="s1">// anchor tag instance, but it's defensive coding to avoid a memory leak in</span><span class="s3">\n    </span><span class="s1">// case there's a logical error somewhere else.</span><span class="s3">\n    </span><span class="s1">unmountPrefetchableInstance(element)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Only track prefetchable links that have a valid prefetch URL</span><span class="s3">\n  </span><span class="s1">prefetchable.set(element, instance)</span><span class="s3">\n  </span><span class="s1">if (observer !== null) {</span><span class="s3">\n    </span><span class="s1">observer.observe(element)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function coercePrefetchableUrl(href: string): URL | null {</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">return createPrefetchURL(href)</span><span class="s3">\n  </span><span class="s1">} catch {</span><span class="s3">\n    </span><span class="s1">// createPrefetchURL sometimes throws an error if an invalid URL is</span><span class="s3">\n    </span><span class="s1">// provided, though I'm not sure if it's actually necessary.</span><span class="s3">\n    </span><span class="s1">// TODO: Consider removing the throw from the inner function, or change it</span><span class="s3">\n    </span><span class="s1">// to reportError. Or maybe the error isn't even necessary for automatic</span><span class="s3">\n    </span><span class="s1">// prefetches, just navigations.</span><span class="s3">\n    </span><span class="s1">const reportErrorFn =</span><span class="s3">\n      </span><span class="s1">typeof reportError === 'function' ? reportError : console.error</span><span class="s3">\n    </span><span class="s1">reportErrorFn(</span><span class="s3">\n      </span><span class="s1">`Cannot prefetch '${href}' because it cannot be converted to a URL.`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function mountLinkInstance(</span><span class="s3">\n  </span><span class="s1">element: LinkElement,</span><span class="s3">\n  </span><span class="s1">href: string,</span><span class="s3">\n  </span><span class="s1">router: AppRouterInstance,</span><span class="s3">\n  </span><span class="s1">fetchStrategy: PrefetchTaskFetchStrategy,</span><span class="s3">\n  </span><span class="s1">prefetchEnabled: boolean,</span><span class="s3">\n  </span><span class="s1">setOptimisticLinkStatus: (status: { pending: boolean }) =&gt; void</span><span class="s3">\n</span><span class="s1">): LinkInstance {</span><span class="s3">\n  </span><span class="s1">if (prefetchEnabled) {</span><span class="s3">\n    </span><span class="s1">const prefetchURL = coercePrefetchableUrl(href)</span><span class="s3">\n    </span><span class="s1">if (prefetchURL !== null) {</span><span class="s3">\n      </span><span class="s1">const instance: PrefetchableLinkInstance = {</span><span class="s3">\n        </span><span class="s1">router,</span><span class="s3">\n        </span><span class="s1">fetchStrategy,</span><span class="s3">\n        </span><span class="s1">isVisible: false,</span><span class="s3">\n        </span><span class="s1">prefetchTask: null,</span><span class="s3">\n        </span><span class="s1">prefetchHref: prefetchURL.href,</span><span class="s3">\n        </span><span class="s1">setOptimisticLinkStatus,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">// We only observe the link's visibility if it's prefetchable. For</span><span class="s3">\n      </span><span class="s1">// example, this excludes links to external URLs.</span><span class="s3">\n      </span><span class="s1">observeVisibility(element, instance)</span><span class="s3">\n      </span><span class="s1">return instance</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// If the link is not prefetchable, we still create an instance so we can</span><span class="s3">\n  </span><span class="s1">// track its optimistic state (i.e. useLinkStatus).</span><span class="s3">\n  </span><span class="s1">const instance: NonPrefetchableLinkInstance = {</span><span class="s3">\n    </span><span class="s1">router,</span><span class="s3">\n    </span><span class="s1">fetchStrategy,</span><span class="s3">\n    </span><span class="s1">isVisible: false,</span><span class="s3">\n    </span><span class="s1">prefetchTask: null,</span><span class="s3">\n    </span><span class="s1">prefetchHref: null,</span><span class="s3">\n    </span><span class="s1">setOptimisticLinkStatus,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return instance</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function mountFormInstance(</span><span class="s3">\n  </span><span class="s1">element: HTMLFormElement,</span><span class="s3">\n  </span><span class="s1">href: string,</span><span class="s3">\n  </span><span class="s1">router: AppRouterInstance,</span><span class="s3">\n  </span><span class="s1">fetchStrategy: PrefetchTaskFetchStrategy</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">const prefetchURL = coercePrefetchableUrl(href)</span><span class="s3">\n  </span><span class="s1">if (prefetchURL === null) {</span><span class="s3">\n    </span><span class="s1">// This href is not prefetchable, so we don't track it.</span><span class="s3">\n    </span><span class="s1">// TODO: We currently observe/unobserve a form every time its href changes.</span><span class="s3">\n    </span><span class="s1">// For Links, this isn't a big deal because the href doesn't usually change,</span><span class="s3">\n    </span><span class="s1">// but for forms it's extremely common. We should optimize this.</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const instance: FormInstance = {</span><span class="s3">\n    </span><span class="s1">router,</span><span class="s3">\n    </span><span class="s1">fetchStrategy,</span><span class="s3">\n    </span><span class="s1">isVisible: false,</span><span class="s3">\n    </span><span class="s1">prefetchTask: null,</span><span class="s3">\n    </span><span class="s1">prefetchHref: prefetchURL.href,</span><span class="s3">\n    </span><span class="s1">setOptimisticLinkStatus: null,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">observeVisibility(element, instance)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function unmountPrefetchableInstance(element: Element) {</span><span class="s3">\n  </span><span class="s1">const instance = prefetchable.get(element)</span><span class="s3">\n  </span><span class="s1">if (instance !== undefined) {</span><span class="s3">\n    </span><span class="s1">prefetchable.delete(element)</span><span class="s3">\n    </span><span class="s1">prefetchableAndVisible.delete(instance)</span><span class="s3">\n    </span><span class="s1">const prefetchTask = instance.prefetchTask</span><span class="s3">\n    </span><span class="s1">if (prefetchTask !== null) {</span><span class="s3">\n      </span><span class="s1">cancelPrefetchTask(prefetchTask)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (observer !== null) {</span><span class="s3">\n    </span><span class="s1">observer.unobserve(element)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function handleIntersect(entries: Array&lt;IntersectionObserverEntry&gt;) {</span><span class="s3">\n  </span><span class="s1">for (const entry of entries) {</span><span class="s3">\n    </span><span class="s1">// Some extremely old browsers or polyfills don't reliably support</span><span class="s3">\n    </span><span class="s1">// isIntersecting so we check intersectionRatio instead. (Do we care? Not</span><span class="s3">\n    </span><span class="s1">// really. But whatever this is fine.)</span><span class="s3">\n    </span><span class="s1">const isVisible = entry.intersectionRatio &gt; 0</span><span class="s3">\n    </span><span class="s1">onLinkVisibilityChanged(entry.target as HTMLAnchorElement, isVisible)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function onLinkVisibilityChanged(element: Element, isVisible: boolean) {</span><span class="s3">\n  </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n    </span><span class="s1">// Prefetching on viewport is disabled in development for performance</span><span class="s3">\n    </span><span class="s1">// reasons, because it requires compiling the target page.</span><span class="s3">\n    </span><span class="s1">// TODO: Investigate re-enabling this.</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const instance = prefetchable.get(element)</span><span class="s3">\n  </span><span class="s1">if (instance === undefined) {</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">instance.isVisible = isVisible</span><span class="s3">\n  </span><span class="s1">if (isVisible) {</span><span class="s3">\n    </span><span class="s1">prefetchableAndVisible.add(instance)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">prefetchableAndVisible.delete(instance)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">rescheduleLinkPrefetch(instance, PrefetchPriority.Default)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function onNavigationIntent(</span><span class="s3">\n  </span><span class="s1">element: HTMLAnchorElement | SVGAElement,</span><span class="s3">\n  </span><span class="s1">unstable_upgradeToDynamicPrefetch: boolean</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const instance = prefetchable.get(element)</span><span class="s3">\n  </span><span class="s1">if (instance === undefined) {</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Prefetch the link on hover/touchstart.</span><span class="s3">\n  </span><span class="s1">if (instance !== undefined) {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">process.env.__NEXT_DYNAMIC_ON_HOVER &amp;&amp;</span><span class="s3">\n      </span><span class="s1">unstable_upgradeToDynamicPrefetch</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// Switch to a full prefetch</span><span class="s3">\n      </span><span class="s1">instance.fetchStrategy = FetchStrategy.Full</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">rescheduleLinkPrefetch(instance, PrefetchPriority.Intent)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function rescheduleLinkPrefetch(</span><span class="s3">\n  </span><span class="s1">instance: PrefetchableInstance,</span><span class="s3">\n  </span><span class="s1">priority: PrefetchPriority.Default | PrefetchPriority.Intent</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const existingPrefetchTask = instance.prefetchTask</span><span class="s3">\n\n  </span><span class="s1">if (!instance.isVisible) {</span><span class="s3">\n    </span><span class="s1">// Cancel any in-progress prefetch task. (If it already finished then this</span><span class="s3">\n    </span><span class="s1">// is a no-op.)</span><span class="s3">\n    </span><span class="s1">if (existingPrefetchTask !== null) {</span><span class="s3">\n      </span><span class="s1">cancelPrefetchTask(existingPrefetchTask)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// We don't need to reset the prefetchTask to null upon cancellation; an</span><span class="s3">\n    </span><span class="s1">// old task object can be rescheduled with reschedulePrefetchTask. This is a</span><span class="s3">\n    </span><span class="s1">// micro-optimization but also makes the code simpler (don't need to</span><span class="s3">\n    </span><span class="s1">// worry about whether an old task object is stale).</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!process.env.__NEXT_CLIENT_SEGMENT_CACHE) {</span><span class="s3">\n    </span><span class="s1">// The old prefetch implementation does not have different priority levels.</span><span class="s3">\n    </span><span class="s1">// Just schedule a new prefetch task.</span><span class="s3">\n    </span><span class="s1">prefetchWithOldCacheImplementation(instance)</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const appRouterState = getCurrentAppRouterState()</span><span class="s3">\n  </span><span class="s1">if (appRouterState !== null) {</span><span class="s3">\n    </span><span class="s1">const treeAtTimeOfPrefetch = appRouterState.tree</span><span class="s3">\n    </span><span class="s1">if (existingPrefetchTask === null) {</span><span class="s3">\n      </span><span class="s1">// Initiate a prefetch task.</span><span class="s3">\n      </span><span class="s1">const nextUrl = appRouterState.nextUrl</span><span class="s3">\n      </span><span class="s1">const cacheKey = createCacheKey(instance.prefetchHref, nextUrl)</span><span class="s3">\n      </span><span class="s1">instance.prefetchTask = scheduleSegmentPrefetchTask(</span><span class="s3">\n        </span><span class="s1">cacheKey,</span><span class="s3">\n        </span><span class="s1">treeAtTimeOfPrefetch,</span><span class="s3">\n        </span><span class="s1">instance.fetchStrategy,</span><span class="s3">\n        </span><span class="s1">priority,</span><span class="s3">\n        </span><span class="s1">null</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// We already have an old task object that we can reschedule. This is</span><span class="s3">\n      </span><span class="s1">// effectively the same as canceling the old task and creating a new one.</span><span class="s3">\n      </span><span class="s1">reschedulePrefetchTask(</span><span class="s3">\n        </span><span class="s1">existingPrefetchTask,</span><span class="s3">\n        </span><span class="s1">treeAtTimeOfPrefetch,</span><span class="s3">\n        </span><span class="s1">instance.fetchStrategy,</span><span class="s3">\n        </span><span class="s1">priority</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function pingVisibleLinks(</span><span class="s3">\n  </span><span class="s1">nextUrl: string | null,</span><span class="s3">\n  </span><span class="s1">tree: FlightRouterState</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">// For each currently visible link, cancel the existing prefetch task (if it</span><span class="s3">\n  </span><span class="s1">// exists) and schedule a new one. This is effectively the same as if all the</span><span class="s3">\n  </span><span class="s1">// visible links left and then re-entered the viewport.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// This is called when the Next-Url or the base tree changes, since those</span><span class="s3">\n  </span><span class="s1">// may affect the result of a prefetch task. It's also called after a</span><span class="s3">\n  </span><span class="s1">// cache invalidation.</span><span class="s3">\n  </span><span class="s1">for (const instance of prefetchableAndVisible) {</span><span class="s3">\n    </span><span class="s1">const task = instance.prefetchTask</span><span class="s3">\n    </span><span class="s1">if (task !== null &amp;&amp; !isPrefetchTaskDirty(task, nextUrl, tree)) {</span><span class="s3">\n      </span><span class="s1">// The cache has not been invalidated, and none of the inputs have</span><span class="s3">\n      </span><span class="s1">// changed. Bail out.</span><span class="s3">\n      </span><span class="s1">continue</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Something changed. Cancel the existing prefetch task and schedule a</span><span class="s3">\n    </span><span class="s1">// new one.</span><span class="s3">\n    </span><span class="s1">if (task !== null) {</span><span class="s3">\n      </span><span class="s1">cancelPrefetchTask(task)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const cacheKey = createCacheKey(instance.prefetchHref, nextUrl)</span><span class="s3">\n    </span><span class="s1">instance.prefetchTask = scheduleSegmentPrefetchTask(</span><span class="s3">\n      </span><span class="s1">cacheKey,</span><span class="s3">\n      </span><span class="s1">tree,</span><span class="s3">\n      </span><span class="s1">instance.fetchStrategy,</span><span class="s3">\n      </span><span class="s1">PrefetchPriority.Default,</span><span class="s3">\n      </span><span class="s1">null</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function prefetchWithOldCacheImplementation(instance: PrefetchableInstance) {</span><span class="s3">\n  </span><span class="s1">// This is the path used when the Segment Cache is not enabled.</span><span class="s3">\n  </span><span class="s1">if (typeof window === 'undefined') {</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const doPrefetch = async () =&gt; {</span><span class="s3">\n    </span><span class="s1">// note that `appRouter.prefetch()` is currently sync,</span><span class="s3">\n    </span><span class="s1">// so we have to wrap this call in an async function to be able to catch() errors below.</span><span class="s3">\n\n    </span><span class="s1">let prefetchKind: PrefetchKind</span><span class="s3">\n    </span><span class="s1">switch (instance.fetchStrategy) {</span><span class="s3">\n      </span><span class="s1">case FetchStrategy.PPR: {</span><span class="s3">\n        </span><span class="s1">prefetchKind = PrefetchKind.AUTO</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case FetchStrategy.Full: {</span><span class="s3">\n        </span><span class="s1">prefetchKind = PrefetchKind.FULL</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case FetchStrategy.PPRRuntime: {</span><span class="s3">\n        </span><span class="s1">// We can only get here if Client Segment Cache is off, and in that case</span><span class="s3">\n        </span><span class="s1">// it shouldn't be possible for a link to request a runtime prefetch.</span><span class="s3">\n        </span><span class="s1">throw new InvariantError(</span><span class="s3">\n          </span><span class="s1">'FetchStrategy.PPRRuntime should never be used when `experimental.clientSegmentCache` is disabled'</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">default: {</span><span class="s3">\n        </span><span class="s1">instance.fetchStrategy satisfies never</span><span class="s3">\n        </span><span class="s1">// Unreachable, but otherwise typescript will consider the variable unassigned</span><span class="s3">\n        </span><span class="s1">prefetchKind = undefined!</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return instance.router.prefetch(instance.prefetchHref, {</span><span class="s3">\n      </span><span class="s1">kind: prefetchKind,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Prefetch the page if asked (only in the client)</span><span class="s3">\n  </span><span class="s1">// We need to handle a prefetch error here since we may be</span><span class="s3">\n  </span><span class="s1">// loading with priority which can reject but we don't</span><span class="s3">\n  </span><span class="s1">// want to force navigation since this is only a prefetch</span><span class="s3">\n  </span><span class="s1">doPrefetch().catch((err) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (process.env.NODE_ENV !== 'production') {</span><span class="s3">\n      </span><span class="s1">// rethrow to show invalid URL errors</span><span class="s3">\n      </span><span class="s1">throw err</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;IDLE_LINK_STATUS&quot;</span><span class="s0">,</span><span class="s1">&quot;PENDING_LINK_STATUS&quot;</span><span class="s0">,</span><span class="s1">&quot;mountFormInstance&quot;</span><span class="s0">,</span><span class="s1">&quot;mountLinkInstance&quot;</span><span class="s0">,</span><span class="s1">&quot;onLinkVisibilityChanged&quot;</span><span class="s0">,</span><span class="s1">&quot;onNavigationIntent&quot;</span><span class="s0">,</span><span class="s1">&quot;pingVisibleLinks&quot;</span><span class="s0">,</span><span class="s1">&quot;setLinkForCurrentNavigation&quot;</span><span class="s0">,</span><span class="s1">&quot;unmountLinkForCurrentNavigation&quot;</span><span class="s0">,</span><span class="s1">&quot;unmountPrefetchableInstance&quot;</span><span class="s0">,</span><span class="s1">&quot;linkForMostRecentNavigation&quot;</span><span class="s0">,</span><span class="s1">&quot;pending&quot;</span><span class="s0">,</span><span class="s1">&quot;link&quot;</span><span class="s0">,</span><span class="s1">&quot;startTransition&quot;</span><span class="s0">,</span><span class="s1">&quot;setOptimisticLinkStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchable&quot;</span><span class="s0">,</span><span class="s1">&quot;WeakMap&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchableAndVisible&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;observer&quot;</span><span class="s0">,</span><span class="s1">&quot;IntersectionObserver&quot;</span><span class="s0">,</span><span class="s1">&quot;handleIntersect&quot;</span><span class="s0">,</span><span class="s1">&quot;rootMargin&quot;</span><span class="s0">,</span><span class="s1">&quot;observeVisibility&quot;</span><span class="s0">,</span><span class="s1">&quot;element&quot;</span><span class="s0">,</span><span class="s1">&quot;instance&quot;</span><span class="s0">,</span><span class="s1">&quot;existingInstance&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;observe&quot;</span><span class="s0">,</span><span class="s1">&quot;coercePrefetchableUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;href&quot;</span><span class="s0">,</span><span class="s1">&quot;createPrefetchURL&quot;</span><span class="s0">,</span><span class="s1">&quot;reportErrorFn&quot;</span><span class="s0">,</span><span class="s1">&quot;reportError&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;router&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchStrategy&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchEnabled&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchURL&quot;</span><span class="s0">,</span><span class="s1">&quot;isVisible&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchTask&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchHref&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;cancelPrefetchTask&quot;</span><span class="s0">,</span><span class="s1">&quot;unobserve&quot;</span><span class="s0">,</span><span class="s1">&quot;entries&quot;</span><span class="s0">,</span><span class="s1">&quot;entry&quot;</span><span class="s0">,</span><span class="s1">&quot;intersectionRatio&quot;</span><span class="s0">,</span><span class="s1">&quot;target&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;rescheduleLinkPrefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;PrefetchPriority&quot;</span><span class="s0">,</span><span class="s1">&quot;Default&quot;</span><span class="s0">,</span><span class="s1">&quot;unstable_upgradeToDynamicPrefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_DYNAMIC_ON_HOVER&quot;</span><span class="s0">,</span><span class="s1">&quot;FetchStrategy&quot;</span><span class="s0">,</span><span class="s1">&quot;Full&quot;</span><span class="s0">,</span><span class="s1">&quot;Intent&quot;</span><span class="s0">,</span><span class="s1">&quot;priority&quot;</span><span class="s0">,</span><span class="s1">&quot;existingPrefetchTask&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_CLIENT_SEGMENT_CACHE&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchWithOldCacheImplementation&quot;</span><span class="s0">,</span><span class="s1">&quot;appRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;getCurrentAppRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;treeAtTimeOfPrefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;nextUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;createCacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;scheduleSegmentPrefetchTask&quot;</span><span class="s0">,</span><span class="s1">&quot;reschedulePrefetchTask&quot;</span><span class="s0">,</span><span class="s1">&quot;task&quot;</span><span class="s0">,</span><span class="s1">&quot;isPrefetchTaskDirty&quot;</span><span class="s0">,</span><span class="s1">&quot;window&quot;</span><span class="s0">,</span><span class="s1">&quot;doPrefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchKind&quot;</span><span class="s0">,</span><span class="s1">&quot;PPR&quot;</span><span class="s0">,</span><span class="s1">&quot;PrefetchKind&quot;</span><span class="s0">,</span><span class="s1">&quot;AUTO&quot;</span><span class="s0">,</span><span class="s1">&quot;FULL&quot;</span><span class="s0">,</span><span class="s1">&quot;PPRRuntime&quot;</span><span class="s0">,</span><span class="s1">&quot;InvariantError&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetch&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;catch&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>