<html>
<head>
<title>file-report.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #8c8c8c; font-style: italic;}
.s2 { color: #080808;}
.s3 { color: #067d17;}
.s4 { color: #0033b3;}
.s5 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
file-report.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@fileoverview </span><span class="s0">A class to track messages reported by the linter for a file.</span>
 <span class="s0">* </span><span class="s1">@author </span><span class="s0">Nicholas C. Zakas</span>
 <span class="s0">*/</span>

<span class="s3">&quot;use strict&quot;</span><span class="s2">;</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Requirements</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s4">const </span><span class="s2">assert = require(</span><span class="s3">&quot;../shared/assert&quot;</span><span class="s2">);</span>
<span class="s4">const </span><span class="s2">{ RuleFixer } = require(</span><span class="s3">&quot;./rule-fixer&quot;</span><span class="s2">);</span>
<span class="s4">const </span><span class="s2">{ interpolate } = require(</span><span class="s3">&quot;./interpolate&quot;</span><span class="s2">);</span>
<span class="s4">const </span><span class="s2">ruleReplacements = require(</span><span class="s3">&quot;../../conf/replacements.json&quot;</span><span class="s2">);</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Typedefs</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import(&quot;../types&quot;).Linter.LintMessage} LintMessage */</span>
<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import(&quot;../types&quot;).Linter.LintSuggestion} SuggestionResult */</span>
<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import(&quot;@eslint/core&quot;).Language} Language */</span>
<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import(&quot;@eslint/core&quot;).SourceLocation} SourceLocation */</span>

<span class="s0">/**</span>
 <span class="s0">* An error message description</span>
 <span class="s0">* </span><span class="s1">@typedef </span><span class="s0">{Object} MessageDescriptor</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{ASTNode} [node] The reported node</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{Location} loc The location of the problem.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{string} message The problem message.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{Object} [data] Optional data to use to fill in placeholders in the</span>
 <span class="s0">*      message.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{Function} [fix] The function to call that creates a fix command.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{Array&lt;{desc?: string, messageId?: string, fix: Function}&gt;} suggest Suggestion descriptions and functions to create a the associated fixes.</span>
 <span class="s0">*/</span>

<span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@typedef </span><span class="s0">{Object} LintProblem</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{string} ruleId The rule ID that reported the problem.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{string} message The problem message.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{SourceLocation} loc The location of the problem.</span>
 <span class="s0">*/</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Helpers</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s4">const </span><span class="s2">DEFAULT_ERROR_LOC = {</span>
	<span class="s2">start: { line: </span><span class="s5">1</span><span class="s2">, column: </span><span class="s5">0 </span><span class="s2">},</span>
	<span class="s2">end: { line: </span><span class="s5">1</span><span class="s2">, column: </span><span class="s5">1 </span><span class="s2">},</span>
<span class="s2">};</span>

<span class="s0">/**</span>
 <span class="s0">* Updates a given location based on the language offsets. This allows us to</span>
 <span class="s0">* change 0-based locations to 1-based locations. We always want ESLint</span>
 <span class="s0">* reporting lines and columns starting from 1.</span>
 <span class="s0">* </span><span class="s1">@todo </span><span class="s0">Potentially this should be moved into a shared utility file.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} location The location to update.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} location.line The starting line number.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} location.column The starting column number.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} [location.endLine] The ending line number.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} [location.endColumn] The ending column number.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Language} language The language to use to adjust the location information.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Object} The updated location.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">updateLocationInformation(</span>
	<span class="s2">{ line, column, endLine, endColumn },</span>
	<span class="s2">language,</span>
<span class="s2">) {</span>
	<span class="s4">const </span><span class="s2">columnOffset = language.columnStart === </span><span class="s5">1 </span><span class="s2">? </span><span class="s5">0 </span><span class="s2">: </span><span class="s5">1</span><span class="s2">;</span>
	<span class="s4">const </span><span class="s2">lineOffset = language.lineStart === </span><span class="s5">1 </span><span class="s2">? </span><span class="s5">0 </span><span class="s2">: </span><span class="s5">1</span><span class="s2">;</span>

	<span class="s0">// calculate separately to account for undefined</span>
	<span class="s4">const </span><span class="s2">finalEndLine = endLine === </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">? endLine : endLine + lineOffset;</span>
	<span class="s4">const </span><span class="s2">finalEndColumn =</span>
		<span class="s2">endColumn === </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">? endColumn : endColumn + columnOffset;</span>

	<span class="s4">return </span><span class="s2">{</span>
		<span class="s2">line: line + lineOffset,</span>
		<span class="s2">column: column + columnOffset,</span>
		<span class="s2">endLine: finalEndLine,</span>
		<span class="s2">endColumn: finalEndColumn,</span>
	<span class="s2">};</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* creates a missing-rule message.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} ruleId the ruleId to create</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{string} created error message</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">createMissingRuleMessage(ruleId) {</span>
	<span class="s4">return </span><span class="s2">Object.hasOwn(ruleReplacements.rules, ruleId)</span>
		<span class="s2">? </span><span class="s3">`Rule '</span><span class="s2">${ruleId}</span><span class="s3">' was removed and replaced by: </span><span class="s2">${ruleReplacements.rules[ruleId].join(</span><span class="s3">&quot;, &quot;</span><span class="s2">)}</span><span class="s3">`</span>
		<span class="s2">: </span><span class="s3">`Definition for rule '</span><span class="s2">${ruleId}</span><span class="s3">' was not found.`</span><span class="s2">;</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* creates a linting problem</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{LintProblem} options to create linting error</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{RuleSeverity} severity the error message to report</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Language} language the language to use to adjust the location information.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{LintMessage} created problem, returns a missing-rule problem if only provided ruleId.</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">createLintingProblem(options, severity, language) {</span>
	<span class="s4">const </span><span class="s2">{</span>
		<span class="s2">ruleId = </span><span class="s4">null</span><span class="s2">,</span>
		<span class="s2">loc = DEFAULT_ERROR_LOC,</span>
		<span class="s2">message = createMissingRuleMessage(options.ruleId),</span>
	<span class="s2">} = options;</span>

	<span class="s4">return </span><span class="s2">{</span>
		<span class="s2">ruleId,</span>
		<span class="s2">message,</span>
		<span class="s2">...updateLocationInformation(</span>
			<span class="s2">{</span>
				<span class="s2">line: loc.start.line,</span>
				<span class="s2">column: loc.start.column,</span>
				<span class="s2">endLine: loc.end.line,</span>
				<span class="s2">endColumn: loc.end.column,</span>
			<span class="s2">},</span>
			<span class="s2">language,</span>
		<span class="s2">),</span>
		<span class="s2">severity,</span>
		<span class="s2">nodeType: </span><span class="s4">null</span><span class="s2">,</span>
	<span class="s2">};</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Translates a multi-argument context.report() call into a single object argument call</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{...*} args A list of arguments passed to `context.report`</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{MessageDescriptor} A normalized object containing report information</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">normalizeMultiArgReportCall(...args) {</span>
	<span class="s0">// If there is one argument, it is considered to be a new-style call already.</span>
	<span class="s4">if </span><span class="s2">(args.length === </span><span class="s5">1</span><span class="s2">) {</span>
		<span class="s0">// Shallow clone the object to avoid surprises if reusing the descriptor</span>
		<span class="s4">return </span><span class="s2">Object.assign({}, args[</span><span class="s5">0</span><span class="s2">]);</span>
	<span class="s2">}</span>

	<span class="s0">// If the second argument is a string, the arguments are interpreted as [node, message, data, fix].</span>
	<span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">args[</span><span class="s5">1</span><span class="s2">] === </span><span class="s3">&quot;string&quot;</span><span class="s2">) {</span>
		<span class="s4">return </span><span class="s2">{</span>
			<span class="s2">node: args[</span><span class="s5">0</span><span class="s2">],</span>
			<span class="s2">message: args[</span><span class="s5">1</span><span class="s2">],</span>
			<span class="s2">data: args[</span><span class="s5">2</span><span class="s2">],</span>
			<span class="s2">fix: args[</span><span class="s5">3</span><span class="s2">],</span>
		<span class="s2">};</span>
	<span class="s2">}</span>

	<span class="s0">// Otherwise, the arguments are interpreted as [node, loc, message, data, fix].</span>
	<span class="s4">return </span><span class="s2">{</span>
		<span class="s2">node: args[</span><span class="s5">0</span><span class="s2">],</span>
		<span class="s2">loc: args[</span><span class="s5">1</span><span class="s2">],</span>
		<span class="s2">message: args[</span><span class="s5">2</span><span class="s2">],</span>
		<span class="s2">data: args[</span><span class="s5">3</span><span class="s2">],</span>
		<span class="s2">fix: args[</span><span class="s5">4</span><span class="s2">],</span>
	<span class="s2">};</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Asserts that either a loc or a node was provided, and the node is valid if it was provided.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{MessageDescriptor} descriptor A descriptor to validate</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">AssertionError if neither a node nor a loc was provided, or if the node is not an object</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">assertValidNodeInfo(descriptor) {</span>
	<span class="s4">if </span><span class="s2">(descriptor.node) {</span>
		<span class="s2">assert(</span><span class="s4">typeof </span><span class="s2">descriptor.node === </span><span class="s3">&quot;object&quot;</span><span class="s2">, </span><span class="s3">&quot;Node must be an object&quot;</span><span class="s2">);</span>
	<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
		<span class="s2">assert(</span>
			<span class="s2">descriptor.loc,</span>
			<span class="s3">&quot;Node must be provided when reporting error if location is not provided&quot;</span><span class="s2">,</span>
		<span class="s2">);</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Normalizes a MessageDescriptor to always have a `loc` with `start` and `end` properties</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{MessageDescriptor} descriptor A descriptor for the report from a rule.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{{start: Location, end: (Location|null)}} An updated location that infers the `start` and `end` properties</span>
 <span class="s0">* from the `node` of the original descriptor, or infers the `start` from the `loc` of the original descriptor.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">normalizeReportLoc(descriptor) {</span>
	<span class="s4">if </span><span class="s2">(descriptor.loc.start) {</span>
		<span class="s4">return </span><span class="s2">descriptor.loc;</span>
	<span class="s2">}</span>
	<span class="s4">return </span><span class="s2">{ start: descriptor.loc, end: </span><span class="s4">null </span><span class="s2">};</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Clones the given fix object.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Fix|null} fix The fix to clone.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Fix|null} Deep cloned fix object or `null` if `null` or `undefined` was passed in.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">cloneFix(fix) {</span>
	<span class="s4">if </span><span class="s2">(!fix) {</span>
		<span class="s4">return null</span><span class="s2">;</span>
	<span class="s2">}</span>

	<span class="s4">return </span><span class="s2">{</span>
		<span class="s2">range: [fix.range[</span><span class="s5">0</span><span class="s2">], fix.range[</span><span class="s5">1</span><span class="s2">]],</span>
		<span class="s2">text: fix.text,</span>
	<span class="s2">};</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Check that a fix has a valid range.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Fix|null} fix The fix to validate.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">assertValidFix(fix) {</span>
	<span class="s4">if </span><span class="s2">(fix) {</span>
		<span class="s2">assert(</span>
			<span class="s2">fix.range &amp;&amp;</span>
				<span class="s4">typeof </span><span class="s2">fix.range[</span><span class="s5">0</span><span class="s2">] === </span><span class="s3">&quot;number&quot; </span><span class="s2">&amp;&amp;</span>
				<span class="s4">typeof </span><span class="s2">fix.range[</span><span class="s5">1</span><span class="s2">] === </span><span class="s3">&quot;number&quot;</span><span class="s2">,</span>
			<span class="s3">`Fix has invalid range: </span><span class="s2">${JSON.stringify(fix, </span><span class="s4">null</span><span class="s2">, </span><span class="s5">2</span><span class="s2">)}</span><span class="s3">`</span><span class="s2">,</span>
		<span class="s2">);</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Compares items in a fixes array by range.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Fix} a The first message.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Fix} b The second message.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{number} -1 if a comes before b, 1 if a comes after b, 0 if equal.</span>
 <span class="s0">* </span><span class="s1">@private</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">compareFixesByRange(a, b) {</span>
	<span class="s4">return </span><span class="s2">a.range[</span><span class="s5">0</span><span class="s2">] - b.range[</span><span class="s5">0</span><span class="s2">] || a.range[</span><span class="s5">1</span><span class="s2">] - b.range[</span><span class="s5">1</span><span class="s2">];</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Merges the given fixes array into one.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Fix[]} fixes The fixes to merge.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{SourceCode} sourceCode The source code object to get the text between fixes.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{{text: string, range: number[]}} The merged fixes</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">mergeFixes(fixes, sourceCode) {</span>
	<span class="s4">for </span><span class="s2">(</span><span class="s4">const </span><span class="s2">fix of fixes) {</span>
		<span class="s2">assertValidFix(fix);</span>
	<span class="s2">}</span>

	<span class="s4">if </span><span class="s2">(fixes.length === </span><span class="s5">0</span><span class="s2">) {</span>
		<span class="s4">return null</span><span class="s2">;</span>
	<span class="s2">}</span>
	<span class="s4">if </span><span class="s2">(fixes.length === </span><span class="s5">1</span><span class="s2">) {</span>
		<span class="s4">return </span><span class="s2">cloneFix(fixes[</span><span class="s5">0</span><span class="s2">]);</span>
	<span class="s2">}</span>

	<span class="s2">fixes.sort(compareFixesByRange);</span>

	<span class="s4">const </span><span class="s2">originalText = sourceCode.text;</span>
	<span class="s4">const </span><span class="s2">start = fixes[</span><span class="s5">0</span><span class="s2">].range[</span><span class="s5">0</span><span class="s2">];</span>
	<span class="s4">const </span><span class="s2">end = fixes.at(-</span><span class="s5">1</span><span class="s2">).range[</span><span class="s5">1</span><span class="s2">];</span>
	<span class="s4">let </span><span class="s2">text = </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
	<span class="s4">let </span><span class="s2">lastPos = Number.MIN_SAFE_INTEGER;</span>

	<span class="s4">for </span><span class="s2">(</span><span class="s4">const </span><span class="s2">fix of fixes) {</span>
		<span class="s2">assert(</span>
			<span class="s2">fix.range[</span><span class="s5">0</span><span class="s2">] &gt;= lastPos,</span>
			<span class="s3">&quot;Fix objects must not be overlapped in a report.&quot;</span><span class="s2">,</span>
		<span class="s2">);</span>

		<span class="s4">if </span><span class="s2">(fix.range[</span><span class="s5">0</span><span class="s2">] &gt;= </span><span class="s5">0</span><span class="s2">) {</span>
			<span class="s2">text += originalText.slice(</span>
				<span class="s2">Math.max(</span><span class="s5">0</span><span class="s2">, start, lastPos),</span>
				<span class="s2">fix.range[</span><span class="s5">0</span><span class="s2">],</span>
			<span class="s2">);</span>
		<span class="s2">}</span>
		<span class="s2">text += fix.text;</span>
		<span class="s2">lastPos = fix.range[</span><span class="s5">1</span><span class="s2">];</span>
	<span class="s2">}</span>
	<span class="s2">text += originalText.slice(Math.max(</span><span class="s5">0</span><span class="s2">, start, lastPos), end);</span>

	<span class="s4">return </span><span class="s2">{ range: [start, end], text };</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Gets one fix object from the given descriptor.</span>
 <span class="s0">* If the descriptor retrieves multiple fixes, this merges those to one.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{MessageDescriptor} descriptor The report descriptor.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{SourceCode} sourceCode The source code object to get text between fixes.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{({text: string, range: number[]}|null)} The fix for the descriptor</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">normalizeFixes(descriptor, sourceCode) {</span>
	<span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">descriptor.fix !== </span><span class="s3">&quot;function&quot;</span><span class="s2">) {</span>
		<span class="s4">return null</span><span class="s2">;</span>
	<span class="s2">}</span>

	<span class="s4">const </span><span class="s2">ruleFixer = </span><span class="s4">new </span><span class="s2">RuleFixer({ sourceCode });</span>

	<span class="s0">// @type {null | Fix | Fix[] | IterableIterator&lt;Fix&gt;}</span>
	<span class="s4">const </span><span class="s2">fix = descriptor.fix(ruleFixer);</span>

	<span class="s0">// Merge to one.</span>
	<span class="s4">if </span><span class="s2">(fix &amp;&amp; Symbol.iterator </span><span class="s4">in </span><span class="s2">fix) {</span>
		<span class="s4">return </span><span class="s2">mergeFixes(Array.from(fix), sourceCode);</span>
	<span class="s2">}</span>

	<span class="s2">assertValidFix(fix);</span>
	<span class="s4">return </span><span class="s2">cloneFix(fix);</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Gets an array of suggestion objects from the given descriptor.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{MessageDescriptor} descriptor The report descriptor.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{SourceCode} sourceCode The source code object to get text between fixes.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} messages Object of meta messages for the rule.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Array&lt;SuggestionResult&gt;} The suggestions for the descriptor</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">mapSuggestions(descriptor, sourceCode, messages) {</span>
	<span class="s4">if </span><span class="s2">(!descriptor.suggest || !Array.isArray(descriptor.suggest)) {</span>
		<span class="s4">return </span><span class="s2">[];</span>
	<span class="s2">}</span>

	<span class="s4">return </span><span class="s2">(</span>
		<span class="s2">descriptor.suggest</span>
			<span class="s2">.map(suggestInfo =&gt; {</span>
				<span class="s4">const </span><span class="s2">computedDesc =</span>
					<span class="s2">suggestInfo.desc || messages[suggestInfo.messageId];</span>

				<span class="s4">return </span><span class="s2">{</span>
					<span class="s2">...suggestInfo,</span>
					<span class="s2">desc: interpolate(computedDesc, suggestInfo.data),</span>
					<span class="s2">fix: normalizeFixes(suggestInfo, sourceCode),</span>
				<span class="s2">};</span>
			<span class="s2">})</span>

			<span class="s0">// Remove suggestions that didn't provide a fix</span>
			<span class="s2">.filter(({ fix }) =&gt; fix)</span>
	<span class="s2">);</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Creates information about the report from a descriptor</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} options Information about the problem</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} options.ruleId Rule ID</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{(0|1|2)} options.severity Rule severity</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{(ASTNode|null)} options.node Node</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} options.message Error message</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} [options.messageId] The error message ID.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{{start: SourceLocation, end: (SourceLocation|null)}} options.loc Start and end location</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{{text: string, range: (number[]|null)}} options.fix The fix object</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array&lt;{text: string, range: (number[]|null)}&gt;} options.suggestions The array of suggestions objects</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Language} [options.language] The language to use to adjust line and column offsets.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{LintMessage} Information about the report</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">createProblem(options) {</span>
	<span class="s4">const </span><span class="s2">{ language } = options;</span>

	<span class="s0">// calculate offsets based on the language in use</span>
	<span class="s4">const </span><span class="s2">columnOffset = language.columnStart === </span><span class="s5">1 </span><span class="s2">? </span><span class="s5">0 </span><span class="s2">: </span><span class="s5">1</span><span class="s2">;</span>
	<span class="s4">const </span><span class="s2">lineOffset = language.lineStart === </span><span class="s5">1 </span><span class="s2">? </span><span class="s5">0 </span><span class="s2">: </span><span class="s5">1</span><span class="s2">;</span>

	<span class="s4">const </span><span class="s2">problem = {</span>
		<span class="s2">ruleId: options.ruleId,</span>
		<span class="s2">severity: options.severity,</span>
		<span class="s2">message: options.message,</span>
		<span class="s2">line: options.loc.start.line + lineOffset,</span>
		<span class="s2">column: options.loc.start.column + columnOffset,</span>
		<span class="s2">nodeType: (options.node &amp;&amp; options.node.type) || </span><span class="s4">null</span><span class="s2">,</span>
	<span class="s2">};</span>

	<span class="s0">/* 
     * If this isnâ€™t in the conditional, some of the tests fail 
     * because `messageId` is present in the problem object 
     */</span>
	<span class="s4">if </span><span class="s2">(options.messageId) {</span>
		<span class="s2">problem.messageId = options.messageId;</span>
	<span class="s2">}</span>

	<span class="s4">if </span><span class="s2">(options.loc.end) {</span>
		<span class="s2">problem.endLine = options.loc.end.line + lineOffset;</span>
		<span class="s2">problem.endColumn = options.loc.end.column + columnOffset;</span>
	<span class="s2">}</span>

	<span class="s4">if </span><span class="s2">(options.fix) {</span>
		<span class="s2">problem.fix = options.fix;</span>
	<span class="s2">}</span>

	<span class="s4">if </span><span class="s2">(options.suggestions &amp;&amp; options.suggestions.length &gt; </span><span class="s5">0</span><span class="s2">) {</span>
		<span class="s2">problem.suggestions = options.suggestions;</span>
	<span class="s2">}</span>

	<span class="s4">return </span><span class="s2">problem;</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Validates that suggestions are properly defined. Throws if an error is detected.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array&lt;{ desc?: string, messageId?: string }&gt;} suggest The incoming suggest data.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} messages Object of meta messages for the rule.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">validateSuggestions(suggest, messages) {</span>
	<span class="s4">if </span><span class="s2">(suggest &amp;&amp; Array.isArray(suggest)) {</span>
		<span class="s2">suggest.forEach(suggestion =&gt; {</span>
			<span class="s4">if </span><span class="s2">(suggestion.messageId) {</span>
				<span class="s4">const </span><span class="s2">{ messageId } = suggestion;</span>

				<span class="s4">if </span><span class="s2">(!messages) {</span>
					<span class="s4">throw new </span><span class="s2">TypeError(</span>
						<span class="s3">`context.report() called with a suggest option with a messageId '</span><span class="s2">${messageId}</span><span class="s3">', but no messages were present in the rule metadata.`</span><span class="s2">,</span>
					<span class="s2">);</span>
				<span class="s2">}</span>

				<span class="s4">if </span><span class="s2">(!messages[messageId]) {</span>
					<span class="s4">throw new </span><span class="s2">TypeError(</span>
						<span class="s3">`context.report() called with a suggest option with a messageId '</span><span class="s2">${messageId}</span><span class="s3">' which is not present in the 'messages' config: </span><span class="s2">${JSON.stringify(messages, </span><span class="s4">null</span><span class="s2">, </span><span class="s5">2</span><span class="s2">)}</span><span class="s3">`</span><span class="s2">,</span>
					<span class="s2">);</span>
				<span class="s2">}</span>

				<span class="s4">if </span><span class="s2">(suggestion.desc) {</span>
					<span class="s4">throw new </span><span class="s2">TypeError(</span>
						<span class="s3">&quot;context.report() called with a suggest option that defines both a 'messageId' and an 'desc'. Please only pass one.&quot;</span><span class="s2">,</span>
					<span class="s2">);</span>
				<span class="s2">}</span>
			<span class="s2">} </span><span class="s4">else if </span><span class="s2">(!suggestion.desc) {</span>
				<span class="s4">throw new </span><span class="s2">TypeError(</span>
					<span class="s3">&quot;context.report() called with a suggest option that doesn't have either a `desc` or `messageId`&quot;</span><span class="s2">,</span>
				<span class="s2">);</span>
			<span class="s2">}</span>

			<span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">suggestion.fix !== </span><span class="s3">&quot;function&quot;</span><span class="s2">) {</span>
				<span class="s4">throw new </span><span class="s2">TypeError(</span>
					<span class="s3">`context.report() called with a suggest option without a fix function. See: </span><span class="s2">${suggestion}</span><span class="s3">`</span><span class="s2">,</span>
				<span class="s2">);</span>
			<span class="s2">}</span>
		<span class="s2">});</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Computes the message from a report descriptor.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{MessageDescriptor} descriptor The report descriptor.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} messages Object of meta messages for the rule.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{string} The computed message.</span>
 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} If messageId is not found or both message and messageId are provided.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">computeMessageFromDescriptor(descriptor, messages) {</span>
	<span class="s4">if </span><span class="s2">(descriptor.messageId) {</span>
		<span class="s4">if </span><span class="s2">(!messages) {</span>
			<span class="s4">throw new </span><span class="s2">TypeError(</span>
				<span class="s3">&quot;context.report() called with a messageId, but no messages were present in the rule metadata.&quot;</span><span class="s2">,</span>
			<span class="s2">);</span>
		<span class="s2">}</span>
		<span class="s4">const </span><span class="s2">id = descriptor.messageId;</span>

		<span class="s4">if </span><span class="s2">(descriptor.message) {</span>
			<span class="s4">throw new </span><span class="s2">TypeError(</span>
				<span class="s3">&quot;context.report() called with a message and a messageId. Please only pass one.&quot;</span><span class="s2">,</span>
			<span class="s2">);</span>
		<span class="s2">}</span>
		<span class="s4">if </span><span class="s2">(!messages || !Object.hasOwn(messages, id)) {</span>
			<span class="s4">throw new </span><span class="s2">TypeError(</span>
				<span class="s3">`context.report() called with a messageId of '</span><span class="s2">${id}</span><span class="s3">' which is not present in the 'messages' config: </span><span class="s2">${JSON.stringify(messages, </span><span class="s4">null</span><span class="s2">, </span><span class="s5">2</span><span class="s2">)}</span><span class="s3">`</span><span class="s2">,</span>
			<span class="s2">);</span>
		<span class="s2">}</span>
		<span class="s4">return </span><span class="s2">messages[id];</span>
	<span class="s2">}</span>

	<span class="s4">if </span><span class="s2">(descriptor.message) {</span>
		<span class="s4">return </span><span class="s2">descriptor.message;</span>
	<span class="s2">}</span>

	<span class="s4">throw new </span><span class="s2">TypeError(</span>
		<span class="s3">&quot;Missing `message` property in report() call; add a message that describes the linting problem.&quot;</span><span class="s2">,</span>
	<span class="s2">);</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* A report object that contains the messages reported the linter</span>
 <span class="s0">* for a file.</span>
 <span class="s0">*/</span>
<span class="s4">class </span><span class="s2">FileReport {</span>
	<span class="s0">/**</span>
	 <span class="s0">* The messages reported by the linter for this file.</span>
	 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{LintMessage[]}</span>
	 <span class="s0">*/</span>
	<span class="s2">messages = [];</span>

	<span class="s0">/**</span>
	 <span class="s0">* A rule mapper that maps rule IDs to their metadata.</span>
	 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{(string) =&gt; RuleDefinition}</span>
	 <span class="s0">*/</span>
	<span class="s2">#ruleMapper;</span>

	<span class="s0">/**</span>
	 <span class="s0">* The source code object for the file.</span>
	 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{SourceCode}</span>
	 <span class="s0">*/</span>
	<span class="s2">#sourceCode;</span>

	<span class="s0">/**</span>
	 <span class="s0">* The language to use to adjust line and column offsets.</span>
	 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Language}</span>
	 <span class="s0">*/</span>
	<span class="s2">#language;</span>

	<span class="s0">/**</span>
	 <span class="s0">* Whether to disable fixes for this report.</span>
	 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{boolean}</span>
	 <span class="s0">*/</span>
	<span class="s2">#disableFixes;</span>

	<span class="s0">/**</span>
	 <span class="s0">* Creates a new FileReport instance.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} options The options for the file report</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{(string) =&gt; RuleDefinition} options.ruleMapper A rule mapper that maps rule IDs to their metadata.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{SourceCode} options.sourceCode The source code object for the file.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Language} options.language The language to use to adjust line and column offsets.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{boolean} [options.disableFixes=false] Whether to disable fixes for this report.</span>
	 <span class="s0">*/</span>
	<span class="s2">constructor({ ruleMapper, sourceCode, language, disableFixes = </span><span class="s4">false </span><span class="s2">}) {</span>
		<span class="s4">this</span><span class="s2">.#ruleMapper = ruleMapper;</span>
		<span class="s4">this</span><span class="s2">.#sourceCode = sourceCode;</span>
		<span class="s4">this</span><span class="s2">.#language = language;</span>
		<span class="s4">this</span><span class="s2">.#disableFixes = disableFixes;</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Adds a rule-generated message to the report.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} ruleId The rule ID that reported the problem.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{0|1|2} severity The severity of the problem (0 = off, 1 = warning, 2 = error).</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{...*} args The arguments passed to `context.report()`.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{LintMessage} The created message object.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} If the messageId is not found or both message and messageId are provided.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{AssertionError} If the node is not an object or neither a node nor a loc is provided.</span>
	 <span class="s0">*/</span>
	<span class="s2">addRuleMessage(ruleId, severity, ...args) {</span>
		<span class="s4">const </span><span class="s2">descriptor = normalizeMultiArgReportCall(...args);</span>
		<span class="s4">const </span><span class="s2">ruleDefinition = </span><span class="s4">this</span><span class="s2">.#ruleMapper(ruleId);</span>
		<span class="s4">const </span><span class="s2">messages = ruleDefinition?.meta?.messages;</span>

		<span class="s2">assertValidNodeInfo(descriptor);</span>

		<span class="s4">const </span><span class="s2">computedMessage = computeMessageFromDescriptor(</span>
			<span class="s2">descriptor,</span>
			<span class="s2">messages,</span>
		<span class="s2">);</span>

		<span class="s2">validateSuggestions(descriptor.suggest, messages);</span>

		<span class="s4">this</span><span class="s2">.messages.push(</span>
			<span class="s2">createProblem({</span>
				<span class="s2">ruleId,</span>
				<span class="s2">severity,</span>
				<span class="s2">node: descriptor.node,</span>
				<span class="s2">message: interpolate(computedMessage, descriptor.data),</span>
				<span class="s2">messageId: descriptor.messageId,</span>
				<span class="s2">loc: descriptor.loc</span>
					<span class="s2">? normalizeReportLoc(descriptor)</span>
					<span class="s2">: </span><span class="s4">this</span><span class="s2">.#sourceCode.getLoc(descriptor.node),</span>
				<span class="s2">fix: </span><span class="s4">this</span><span class="s2">.#disableFixes</span>
					<span class="s2">? </span><span class="s4">null</span>
					<span class="s2">: normalizeFixes(descriptor, </span><span class="s4">this</span><span class="s2">.#sourceCode),</span>
				<span class="s2">suggestions: </span><span class="s4">this</span><span class="s2">.#disableFixes</span>
					<span class="s2">? []</span>
					<span class="s2">: mapSuggestions(descriptor, </span><span class="s4">this</span><span class="s2">.#sourceCode, messages),</span>
				<span class="s2">language: </span><span class="s4">this</span><span class="s2">.#language,</span>
			<span class="s2">}),</span>
		<span class="s2">);</span>

		<span class="s4">return this</span><span class="s2">.messages.at(-</span><span class="s5">1</span><span class="s2">);</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Adds an error message to the report. Meant to be called outside of rules.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{LintProblem} descriptor The descriptor for the error message.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{LintMessage} The created message object.</span>
	 <span class="s0">*/</span>
	<span class="s2">addError(descriptor) {</span>
		<span class="s4">const </span><span class="s2">message = createLintingProblem(descriptor, </span><span class="s5">2</span><span class="s2">, </span><span class="s4">this</span><span class="s2">.#language);</span>
		<span class="s4">this</span><span class="s2">.messages.push(message);</span>
		<span class="s4">return </span><span class="s2">message;</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Adds a fatal error message to the report. Meant to be called outside of rules.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{LintProblem} descriptor The descriptor for the fatal error message.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{LintMessage} The created message object.</span>
	 <span class="s0">*/</span>
	<span class="s2">addFatal(descriptor) {</span>
		<span class="s4">const </span><span class="s2">message = createLintingProblem(descriptor, </span><span class="s5">2</span><span class="s2">, </span><span class="s4">this</span><span class="s2">.#language);</span>
		<span class="s2">message.fatal = </span><span class="s4">true</span><span class="s2">;</span>
		<span class="s4">this</span><span class="s2">.messages.push(message);</span>
		<span class="s4">return </span><span class="s2">message;</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Adds a warning message to the report. Meant to be called outside of rules.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{LintProblem} descriptor The descriptor for the warning message.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{LintMessage} The created message object.</span>
	 <span class="s0">*/</span>
	<span class="s2">addWarning(descriptor) {</span>
		<span class="s4">const </span><span class="s2">message = createLintingProblem(descriptor, </span><span class="s5">1</span><span class="s2">, </span><span class="s4">this</span><span class="s2">.#language);</span>
		<span class="s4">this</span><span class="s2">.messages.push(message);</span>
		<span class="s4">return </span><span class="s2">message;</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s2">module.exports = {</span>
	<span class="s2">FileReport,</span>
	<span class="s2">updateLocationInformation,</span>
<span class="s2">};</span>
</pre>
</body>
</html>