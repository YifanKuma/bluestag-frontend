<html>
<head>
<title>index.mjs.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
index.mjs.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;index.mjs&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;src/get-innermost-scope.mjs&quot;</span><span class="s0">,</span><span class="s1">&quot;src/find-variable.mjs&quot;</span><span class="s0">,</span><span class="s1">&quot;src/token-predicate.mjs&quot;</span><span class="s0">,</span><span class="s1">&quot;src/get-function-head-location.mjs&quot;</span><span class="s0">,</span><span class="s1">&quot;src/get-static-value.mjs&quot;</span><span class="s0">,</span><span class="s1">&quot;src/get-string-if-constant.mjs&quot;</span><span class="s0">,</span><span class="s1">&quot;src/get-property-name.mjs&quot;</span><span class="s0">,</span><span class="s1">&quot;src/get-function-name-with-kind.mjs&quot;</span><span class="s0">,</span><span class="s1">&quot;src/has-side-effect.mjs&quot;</span><span class="s0">,</span><span class="s1">&quot;src/is-parenthesized.mjs&quot;</span><span class="s0">,</span><span class="s1">&quot;src/pattern-matcher.mjs&quot;</span><span class="s0">,</span><span class="s1">&quot;src/reference-tracker.mjs&quot;</span><span class="s0">,</span><span class="s1">&quot;src/index.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">eslint</span><span class="s3">\&quot;</span><span class="s1">).Scope.Scope} Scope */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).Node} Node */</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Get the innermost scope which contains a given location.</span><span class="s3">\n </span><span class="s1">* @param {Scope} initialScope The initial scope to search.</span><span class="s3">\n </span><span class="s1">* @param {Node} node The location to search.</span><span class="s3">\n </span><span class="s1">* @returns {Scope} The innermost scope.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getInnermostScope(initialScope, node) {</span><span class="s3">\n    </span><span class="s1">const location = /** @type {[number, number]} */ (node.range)[0]</span><span class="s3">\n\n    </span><span class="s1">let scope = initialScope</span><span class="s3">\n    </span><span class="s1">let found = false</span><span class="s3">\n    </span><span class="s1">do {</span><span class="s3">\n        </span><span class="s1">found = false</span><span class="s3">\n        </span><span class="s1">for (const childScope of scope.childScopes) {</span><span class="s3">\n            </span><span class="s1">const range = /** @type {[number, number]} */ (</span><span class="s3">\n                </span><span class="s1">childScope.block.range</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n\n            </span><span class="s1">if (range[0] &lt;= location &amp;&amp; location &lt; range[1]) {</span><span class="s3">\n                </span><span class="s1">scope = childScope</span><span class="s3">\n                </span><span class="s1">found = true</span><span class="s3">\n                </span><span class="s1">break</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} while (found)</span><span class="s3">\n\n    </span><span class="s1">return scope</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { getInnermostScope } from </span><span class="s3">\&quot;</span><span class="s1">./get-innermost-scope.mjs</span><span class="s3">\&quot;\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">eslint</span><span class="s3">\&quot;</span><span class="s1">).Scope.Scope} Scope */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">eslint</span><span class="s3">\&quot;</span><span class="s1">).Scope.Variable} Variable */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).Identifier} Identifier */</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Find the variable of a given name.</span><span class="s3">\n </span><span class="s1">* @param {Scope} initialScope The scope to start finding.</span><span class="s3">\n </span><span class="s1">* @param {string|Identifier} nameOrNode The variable name to find. If this is a Node object then it should be an Identifier node.</span><span class="s3">\n </span><span class="s1">* @returns {Variable|null} The found variable or null.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function findVariable(initialScope, nameOrNode) {</span><span class="s3">\n    </span><span class="s1">let name = </span><span class="s3">\&quot;\&quot;\n    </span><span class="s1">/** @type {Scope|null} */</span><span class="s3">\n    </span><span class="s1">let scope = initialScope</span><span class="s3">\n\n    </span><span class="s1">if (typeof nameOrNode === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">name = nameOrNode</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">name = nameOrNode.name</span><span class="s3">\n        </span><span class="s1">scope = getInnermostScope(scope, nameOrNode)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">while (scope != null) {</span><span class="s3">\n        </span><span class="s1">const variable = scope.set.get(name)</span><span class="s3">\n        </span><span class="s1">if (variable != null) {</span><span class="s3">\n            </span><span class="s1">return variable</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">scope = scope.upper</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">eslint</span><span class="s3">\&quot;</span><span class="s1">).AST.Token} Token */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).Comment} Comment */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">./types.mjs</span><span class="s3">\&quot;</span><span class="s1">).ArrowToken} ArrowToken */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">./types.mjs</span><span class="s3">\&quot;</span><span class="s1">).CommaToken} CommaToken */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">./types.mjs</span><span class="s3">\&quot;</span><span class="s1">).SemicolonToken} SemicolonToken */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">./types.mjs</span><span class="s3">\&quot;</span><span class="s1">).ColonToken} ColonToken */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">./types.mjs</span><span class="s3">\&quot;</span><span class="s1">).OpeningParenToken} OpeningParenToken */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">./types.mjs</span><span class="s3">\&quot;</span><span class="s1">).ClosingParenToken} ClosingParenToken */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">./types.mjs</span><span class="s3">\&quot;</span><span class="s1">).OpeningBracketToken} OpeningBracketToken */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">./types.mjs</span><span class="s3">\&quot;</span><span class="s1">).ClosingBracketToken} ClosingBracketToken */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">./types.mjs</span><span class="s3">\&quot;</span><span class="s1">).OpeningBraceToken} OpeningBraceToken */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">./types.mjs</span><span class="s3">\&quot;</span><span class="s1">).ClosingBraceToken} ClosingBraceToken */</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template {string} Value</span><span class="s3">\n </span><span class="s1">* @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">./types.mjs</span><span class="s3">\&quot;</span><span class="s1">).PunctuatorToken&lt;Value&gt;} PunctuatorToken</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/** @typedef {Comment | Token} CommentOrToken */</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates the negate function of the given function.</span><span class="s3">\n </span><span class="s1">* @param {function(CommentOrToken):boolean} f - The function to negate.</span><span class="s3">\n </span><span class="s1">* @returns {function(CommentOrToken):boolean} Negated function.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function negate(f) {</span><span class="s3">\n    </span><span class="s1">return (token) =&gt; !f(token)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if the given token is a PunctuatorToken with the given value</span><span class="s3">\n </span><span class="s1">* @template {string} Value</span><span class="s3">\n </span><span class="s1">* @param {CommentOrToken} token - The token to check.</span><span class="s3">\n </span><span class="s1">* @param {Value} value - The value to check.</span><span class="s3">\n </span><span class="s1">* @returns {token is PunctuatorToken&lt;Value&gt;} `true` if the token is a PunctuatorToken with the given value.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isPunctuatorTokenWithValue(token, value) {</span><span class="s3">\n    </span><span class="s1">return token.type === </span><span class="s3">\&quot;</span><span class="s1">Punctuator</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; token.value === value</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if the given token is an arrow token or not.</span><span class="s3">\n </span><span class="s1">* @param {CommentOrToken} token - The token to check.</span><span class="s3">\n </span><span class="s1">* @returns {token is ArrowToken} `true` if the token is an arrow token.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isArrowToken(token) {</span><span class="s3">\n    </span><span class="s1">return isPunctuatorTokenWithValue(token, </span><span class="s3">\&quot;</span><span class="s1">=&gt;</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if the given token is a comma token or not.</span><span class="s3">\n </span><span class="s1">* @param {CommentOrToken} token - The token to check.</span><span class="s3">\n </span><span class="s1">* @returns {token is CommaToken} `true` if the token is a comma token.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isCommaToken(token) {</span><span class="s3">\n    </span><span class="s1">return isPunctuatorTokenWithValue(token, </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if the given token is a semicolon token or not.</span><span class="s3">\n </span><span class="s1">* @param {CommentOrToken} token - The token to check.</span><span class="s3">\n </span><span class="s1">* @returns {token is SemicolonToken} `true` if the token is a semicolon token.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isSemicolonToken(token) {</span><span class="s3">\n    </span><span class="s1">return isPunctuatorTokenWithValue(token, </span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if the given token is a colon token or not.</span><span class="s3">\n </span><span class="s1">* @param {CommentOrToken} token - The token to check.</span><span class="s3">\n </span><span class="s1">* @returns {token is ColonToken} `true` if the token is a colon token.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isColonToken(token) {</span><span class="s3">\n    </span><span class="s1">return isPunctuatorTokenWithValue(token, </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if the given token is an opening parenthesis token or not.</span><span class="s3">\n </span><span class="s1">* @param {CommentOrToken} token - The token to check.</span><span class="s3">\n </span><span class="s1">* @returns {token is OpeningParenToken} `true` if the token is an opening parenthesis token.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isOpeningParenToken(token) {</span><span class="s3">\n    </span><span class="s1">return isPunctuatorTokenWithValue(token, </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if the given token is a closing parenthesis token or not.</span><span class="s3">\n </span><span class="s1">* @param {CommentOrToken} token - The token to check.</span><span class="s3">\n </span><span class="s1">* @returns {token is ClosingParenToken} `true` if the token is a closing parenthesis token.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isClosingParenToken(token) {</span><span class="s3">\n    </span><span class="s1">return isPunctuatorTokenWithValue(token, </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if the given token is an opening square bracket token or not.</span><span class="s3">\n </span><span class="s1">* @param {CommentOrToken} token - The token to check.</span><span class="s3">\n </span><span class="s1">* @returns {token is OpeningBracketToken} `true` if the token is an opening square bracket token.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isOpeningBracketToken(token) {</span><span class="s3">\n    </span><span class="s1">return isPunctuatorTokenWithValue(token, </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if the given token is a closing square bracket token or not.</span><span class="s3">\n </span><span class="s1">* @param {CommentOrToken} token - The token to check.</span><span class="s3">\n </span><span class="s1">* @returns {token is ClosingBracketToken} `true` if the token is a closing square bracket token.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isClosingBracketToken(token) {</span><span class="s3">\n    </span><span class="s1">return isPunctuatorTokenWithValue(token, </span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if the given token is an opening brace token or not.</span><span class="s3">\n </span><span class="s1">* @param {CommentOrToken} token - The token to check.</span><span class="s3">\n </span><span class="s1">* @returns {token is OpeningBraceToken} `true` if the token is an opening brace token.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isOpeningBraceToken(token) {</span><span class="s3">\n    </span><span class="s1">return isPunctuatorTokenWithValue(token, </span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if the given token is a closing brace token or not.</span><span class="s3">\n </span><span class="s1">* @param {CommentOrToken} token - The token to check.</span><span class="s3">\n </span><span class="s1">* @returns {token is ClosingBraceToken} `true` if the token is a closing brace token.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isClosingBraceToken(token) {</span><span class="s3">\n    </span><span class="s1">return isPunctuatorTokenWithValue(token, </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if the given token is a comment token or not.</span><span class="s3">\n </span><span class="s1">* @param {CommentOrToken} token - The token to check.</span><span class="s3">\n </span><span class="s1">* @returns {token is Comment} `true` if the token is a comment token.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isCommentToken(token) {</span><span class="s3">\n    </span><span class="s1">return [</span><span class="s3">\&quot;</span><span class="s1">Block</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">Line</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">Shebang</span><span class="s3">\&quot;</span><span class="s1">].includes(token.type)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const isNotArrowToken = negate(isArrowToken)</span><span class="s3">\n</span><span class="s1">export const isNotCommaToken = negate(isCommaToken)</span><span class="s3">\n</span><span class="s1">export const isNotSemicolonToken = negate(isSemicolonToken)</span><span class="s3">\n</span><span class="s1">export const isNotColonToken = negate(isColonToken)</span><span class="s3">\n</span><span class="s1">export const isNotOpeningParenToken = negate(isOpeningParenToken)</span><span class="s3">\n</span><span class="s1">export const isNotClosingParenToken = negate(isClosingParenToken)</span><span class="s3">\n</span><span class="s1">export const isNotOpeningBracketToken = negate(isOpeningBracketToken)</span><span class="s3">\n</span><span class="s1">export const isNotClosingBracketToken = negate(isClosingBracketToken)</span><span class="s3">\n</span><span class="s1">export const isNotOpeningBraceToken = negate(isOpeningBraceToken)</span><span class="s3">\n</span><span class="s1">export const isNotClosingBraceToken = negate(isClosingBraceToken)</span><span class="s3">\n</span><span class="s1">export const isNotCommentToken = negate(isCommentToken)</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { isArrowToken, isOpeningParenToken } from </span><span class="s3">\&quot;</span><span class="s1">./token-predicate.mjs</span><span class="s3">\&quot;\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">eslint</span><span class="s3">\&quot;</span><span class="s1">).Rule.Node} RuleNode */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">eslint</span><span class="s3">\&quot;</span><span class="s1">).SourceCode} SourceCode */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">eslint</span><span class="s3">\&quot;</span><span class="s1">).AST.Token} Token */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).Function} FunctionNode */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).FunctionDeclaration} FunctionDeclaration */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).FunctionExpression} FunctionExpression */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).SourceLocation} SourceLocation */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).Position} Position */</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Get the `(` token of the given function node.</span><span class="s3">\n </span><span class="s1">* @param {FunctionExpression | FunctionDeclaration} node - The function node to get.</span><span class="s3">\n </span><span class="s1">* @param {SourceCode} sourceCode - The source code object to get tokens.</span><span class="s3">\n </span><span class="s1">* @returns {Token} `(` token.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getOpeningParenOfParams(node, sourceCode) {</span><span class="s3">\n    </span><span class="s1">return node.id</span><span class="s3">\n        </span><span class="s1">? /** @type {Token} */ (</span><span class="s3">\n              </span><span class="s1">sourceCode.getTokenAfter(node.id, isOpeningParenToken)</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">: /** @type {Token} */ (</span><span class="s3">\n              </span><span class="s1">sourceCode.getFirstToken(node, isOpeningParenToken)</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Get the location of the given function node for reporting.</span><span class="s3">\n </span><span class="s1">* @param {FunctionNode} node - The function node to get.</span><span class="s3">\n </span><span class="s1">* @param {SourceCode} sourceCode - The source code object to get tokens.</span><span class="s3">\n </span><span class="s1">* @returns {SourceLocation|null} The location of the function node for reporting.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getFunctionHeadLocation(node, sourceCode) {</span><span class="s3">\n    </span><span class="s1">const parent = /** @type {RuleNode} */ (node).parent</span><span class="s3">\n\n    </span><span class="s1">/** @type {Position|null} */</span><span class="s3">\n    </span><span class="s1">let start = null</span><span class="s3">\n    </span><span class="s1">/** @type {Position|null} */</span><span class="s3">\n    </span><span class="s1">let end = null</span><span class="s3">\n\n    </span><span class="s1">if (node.type === </span><span class="s3">\&quot;</span><span class="s1">ArrowFunctionExpression</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">const arrowToken = /** @type {Token} */ (</span><span class="s3">\n            </span><span class="s1">sourceCode.getTokenBefore(node.body, isArrowToken)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">start = arrowToken.loc.start</span><span class="s3">\n        </span><span class="s1">end = arrowToken.loc.end</span><span class="s3">\n    </span><span class="s1">} else if (</span><span class="s3">\n        </span><span class="s1">parent.type === </span><span class="s3">\&quot;</span><span class="s1">Property</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n        </span><span class="s1">parent.type === </span><span class="s3">\&quot;</span><span class="s1">MethodDefinition</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n        </span><span class="s1">parent.type === </span><span class="s3">\&quot;</span><span class="s1">PropertyDefinition</span><span class="s3">\&quot;\n    </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">start = /** @type {SourceLocation} */ (parent.loc).start</span><span class="s3">\n        </span><span class="s1">end = getOpeningParenOfParams(node, sourceCode).loc.start</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">start = /** @type {SourceLocation} */ (node.loc).start</span><span class="s3">\n        </span><span class="s1">end = getOpeningParenOfParams(node, sourceCode).loc.start</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">start: { ...start },</span><span class="s3">\n        </span><span class="s1">end: { ...end },</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/* globals globalThis, global, self, window */</span><span class="s3">\n\n</span><span class="s1">import { findVariable } from </span><span class="s3">\&quot;</span><span class="s1">./find-variable.mjs</span><span class="s3">\&quot;\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">./types.mjs</span><span class="s3">\&quot;</span><span class="s1">).StaticValue} StaticValue */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">eslint</span><span class="s3">\&quot;</span><span class="s1">).Scope.Scope} Scope */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">eslint</span><span class="s3">\&quot;</span><span class="s1">).Scope.Variable} Variable */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).Node} Node */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">@typescript-eslint/types</span><span class="s3">\&quot;</span><span class="s1">).TSESTree.Node} TSESTreeNode */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">@typescript-eslint/types</span><span class="s3">\&quot;</span><span class="s1">).TSESTree.AST_NODE_TYPES} TSESTreeNodeTypes */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">@typescript-eslint/types</span><span class="s3">\&quot;</span><span class="s1">).TSESTree.MemberExpression} MemberExpression */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">@typescript-eslint/types</span><span class="s3">\&quot;</span><span class="s1">).TSESTree.Property} Property */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">@typescript-eslint/types</span><span class="s3">\&quot;</span><span class="s1">).TSESTree.RegExpLiteral} RegExpLiteral */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">@typescript-eslint/types</span><span class="s3">\&quot;</span><span class="s1">).TSESTree.BigIntLiteral} BigIntLiteral */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">@typescript-eslint/types</span><span class="s3">\&quot;</span><span class="s1">).TSESTree.Literal} Literal */</span><span class="s3">\n\n</span><span class="s1">const globalObject =</span><span class="s3">\n    </span><span class="s1">typeof globalThis !== </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;\n        </span><span class="s1">? globalThis</span><span class="s3">\n        </span><span class="s1">: // @ts-ignore</span><span class="s3">\n        </span><span class="s1">typeof self !== </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;\n        </span><span class="s1">? // @ts-ignore</span><span class="s3">\n          </span><span class="s1">self</span><span class="s3">\n        </span><span class="s1">: // @ts-ignore</span><span class="s3">\n        </span><span class="s1">typeof window !== </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;\n        </span><span class="s1">? // @ts-ignore</span><span class="s3">\n          </span><span class="s1">window</span><span class="s3">\n        </span><span class="s1">: typeof global !== </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;\n        </span><span class="s1">? global</span><span class="s3">\n        </span><span class="s1">: {}</span><span class="s3">\n\n</span><span class="s1">const builtinNames = Object.freeze(</span><span class="s3">\n    </span><span class="s1">new Set([</span><span class="s3">\n        \&quot;</span><span class="s1">Array</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">ArrayBuffer</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">BigInt</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">BigInt64Array</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">BigUint64Array</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">Boolean</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">DataView</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">Date</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">decodeURI</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">decodeURIComponent</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">encodeURI</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">encodeURIComponent</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">escape</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">Float32Array</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">Float64Array</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">Function</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">Infinity</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">Int16Array</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">Int32Array</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">Int8Array</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">isFinite</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">isNaN</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">isPrototypeOf</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">JSON</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">Map</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">Math</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">NaN</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">Number</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">Object</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">parseFloat</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">parseInt</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">Promise</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">Proxy</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">Reflect</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">RegExp</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">Set</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">String</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">Symbol</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">Uint16Array</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">Uint32Array</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">Uint8Array</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">Uint8ClampedArray</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">unescape</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">WeakMap</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">WeakSet</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">]),</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">const callAllowed = new Set(</span><span class="s3">\n    </span><span class="s1">[</span><span class="s3">\n        </span><span class="s1">Array.isArray,</span><span class="s3">\n        </span><span class="s1">Array.of,</span><span class="s3">\n        </span><span class="s1">Array.prototype.at,</span><span class="s3">\n        </span><span class="s1">Array.prototype.concat,</span><span class="s3">\n        </span><span class="s1">Array.prototype.entries,</span><span class="s3">\n        </span><span class="s1">Array.prototype.every,</span><span class="s3">\n        </span><span class="s1">Array.prototype.filter,</span><span class="s3">\n        </span><span class="s1">Array.prototype.find,</span><span class="s3">\n        </span><span class="s1">Array.prototype.findIndex,</span><span class="s3">\n        </span><span class="s1">Array.prototype.flat,</span><span class="s3">\n        </span><span class="s1">Array.prototype.includes,</span><span class="s3">\n        </span><span class="s1">Array.prototype.indexOf,</span><span class="s3">\n        </span><span class="s1">Array.prototype.join,</span><span class="s3">\n        </span><span class="s1">Array.prototype.keys,</span><span class="s3">\n        </span><span class="s1">Array.prototype.lastIndexOf,</span><span class="s3">\n        </span><span class="s1">Array.prototype.slice,</span><span class="s3">\n        </span><span class="s1">Array.prototype.some,</span><span class="s3">\n        </span><span class="s1">Array.prototype.toString,</span><span class="s3">\n        </span><span class="s1">Array.prototype.values,</span><span class="s3">\n        </span><span class="s1">typeof BigInt === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">? BigInt : undefined,</span><span class="s3">\n        </span><span class="s1">Boolean,</span><span class="s3">\n        </span><span class="s1">Date,</span><span class="s3">\n        </span><span class="s1">Date.parse,</span><span class="s3">\n        </span><span class="s1">decodeURI,</span><span class="s3">\n        </span><span class="s1">decodeURIComponent,</span><span class="s3">\n        </span><span class="s1">encodeURI,</span><span class="s3">\n        </span><span class="s1">encodeURIComponent,</span><span class="s3">\n        </span><span class="s1">escape,</span><span class="s3">\n        </span><span class="s1">isFinite,</span><span class="s3">\n        </span><span class="s1">isNaN,</span><span class="s3">\n        </span><span class="s1">// @ts-ignore</span><span class="s3">\n        </span><span class="s1">isPrototypeOf,</span><span class="s3">\n        </span><span class="s1">Map,</span><span class="s3">\n        </span><span class="s1">Map.prototype.entries,</span><span class="s3">\n        </span><span class="s1">Map.prototype.get,</span><span class="s3">\n        </span><span class="s1">Map.prototype.has,</span><span class="s3">\n        </span><span class="s1">Map.prototype.keys,</span><span class="s3">\n        </span><span class="s1">Map.prototype.values,</span><span class="s3">\n        </span><span class="s1">.../** @type {(keyof typeof Math)[]} */ (</span><span class="s3">\n            </span><span class="s1">Object.getOwnPropertyNames(Math)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">.filter((k) =&gt; k !== </span><span class="s3">\&quot;</span><span class="s1">random</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">.map((k) =&gt; Math[k])</span><span class="s3">\n            </span><span class="s1">.filter((f) =&gt; typeof f === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">Number,</span><span class="s3">\n        </span><span class="s1">Number.isFinite,</span><span class="s3">\n        </span><span class="s1">Number.isNaN,</span><span class="s3">\n        </span><span class="s1">Number.parseFloat,</span><span class="s3">\n        </span><span class="s1">Number.parseInt,</span><span class="s3">\n        </span><span class="s1">Number.prototype.toExponential,</span><span class="s3">\n        </span><span class="s1">Number.prototype.toFixed,</span><span class="s3">\n        </span><span class="s1">Number.prototype.toPrecision,</span><span class="s3">\n        </span><span class="s1">Number.prototype.toString,</span><span class="s3">\n        </span><span class="s1">Object,</span><span class="s3">\n        </span><span class="s1">Object.entries,</span><span class="s3">\n        </span><span class="s1">Object.is,</span><span class="s3">\n        </span><span class="s1">Object.isExtensible,</span><span class="s3">\n        </span><span class="s1">Object.isFrozen,</span><span class="s3">\n        </span><span class="s1">Object.isSealed,</span><span class="s3">\n        </span><span class="s1">Object.keys,</span><span class="s3">\n        </span><span class="s1">Object.values,</span><span class="s3">\n        </span><span class="s1">parseFloat,</span><span class="s3">\n        </span><span class="s1">parseInt,</span><span class="s3">\n        </span><span class="s1">RegExp,</span><span class="s3">\n        </span><span class="s1">Set,</span><span class="s3">\n        </span><span class="s1">Set.prototype.entries,</span><span class="s3">\n        </span><span class="s1">Set.prototype.has,</span><span class="s3">\n        </span><span class="s1">Set.prototype.keys,</span><span class="s3">\n        </span><span class="s1">Set.prototype.values,</span><span class="s3">\n        </span><span class="s1">String,</span><span class="s3">\n        </span><span class="s1">String.fromCharCode,</span><span class="s3">\n        </span><span class="s1">String.fromCodePoint,</span><span class="s3">\n        </span><span class="s1">String.raw,</span><span class="s3">\n        </span><span class="s1">String.prototype.at,</span><span class="s3">\n        </span><span class="s1">String.prototype.charAt,</span><span class="s3">\n        </span><span class="s1">String.prototype.charCodeAt,</span><span class="s3">\n        </span><span class="s1">String.prototype.codePointAt,</span><span class="s3">\n        </span><span class="s1">String.prototype.concat,</span><span class="s3">\n        </span><span class="s1">String.prototype.endsWith,</span><span class="s3">\n        </span><span class="s1">String.prototype.includes,</span><span class="s3">\n        </span><span class="s1">String.prototype.indexOf,</span><span class="s3">\n        </span><span class="s1">String.prototype.lastIndexOf,</span><span class="s3">\n        </span><span class="s1">String.prototype.normalize,</span><span class="s3">\n        </span><span class="s1">String.prototype.padEnd,</span><span class="s3">\n        </span><span class="s1">String.prototype.padStart,</span><span class="s3">\n        </span><span class="s1">String.prototype.slice,</span><span class="s3">\n        </span><span class="s1">String.prototype.startsWith,</span><span class="s3">\n        </span><span class="s1">String.prototype.substr,</span><span class="s3">\n        </span><span class="s1">String.prototype.substring,</span><span class="s3">\n        </span><span class="s1">String.prototype.toLowerCase,</span><span class="s3">\n        </span><span class="s1">String.prototype.toString,</span><span class="s3">\n        </span><span class="s1">String.prototype.toUpperCase,</span><span class="s3">\n        </span><span class="s1">String.prototype.trim,</span><span class="s3">\n        </span><span class="s1">String.prototype.trimEnd,</span><span class="s3">\n        </span><span class="s1">String.prototype.trimLeft,</span><span class="s3">\n        </span><span class="s1">String.prototype.trimRight,</span><span class="s3">\n        </span><span class="s1">String.prototype.trimStart,</span><span class="s3">\n        </span><span class="s1">Symbol.for,</span><span class="s3">\n        </span><span class="s1">Symbol.keyFor,</span><span class="s3">\n        </span><span class="s1">unescape,</span><span class="s3">\n    </span><span class="s1">].filter((f) =&gt; typeof f === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">const callPassThrough = new Set([</span><span class="s3">\n    </span><span class="s1">Object.freeze,</span><span class="s3">\n    </span><span class="s1">Object.preventExtensions,</span><span class="s3">\n    </span><span class="s1">Object.seal,</span><span class="s3">\n</span><span class="s1">])</span><span class="s3">\n\n</span><span class="s1">/** @type {ReadonlyArray&lt;readonly [Function, ReadonlySet&lt;string&gt;]&gt;} */</span><span class="s3">\n</span><span class="s1">const getterAllowed = [</span><span class="s3">\n    </span><span class="s1">[Map, new Set([</span><span class="s3">\&quot;</span><span class="s1">size</span><span class="s3">\&quot;</span><span class="s1">])],</span><span class="s3">\n    </span><span class="s1">[</span><span class="s3">\n        </span><span class="s1">RegExp,</span><span class="s3">\n        </span><span class="s1">new Set([</span><span class="s3">\n            \&quot;</span><span class="s1">dotAll</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            \&quot;</span><span class="s1">flags</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            \&quot;</span><span class="s1">global</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            \&quot;</span><span class="s1">hasIndices</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            \&quot;</span><span class="s1">ignoreCase</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            \&quot;</span><span class="s1">multiline</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            \&quot;</span><span class="s1">source</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            \&quot;</span><span class="s1">sticky</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            \&quot;</span><span class="s1">unicode</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">]),</span><span class="s3">\n    </span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">[Set, new Set([</span><span class="s3">\&quot;</span><span class="s1">size</span><span class="s3">\&quot;</span><span class="s1">])],</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Get the property descriptor.</span><span class="s3">\n </span><span class="s1">* @param {object} object The object to get.</span><span class="s3">\n </span><span class="s1">* @param {string|number|symbol} name The property name to get.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getPropertyDescriptor(object, name) {</span><span class="s3">\n    </span><span class="s1">let x = object</span><span class="s3">\n    </span><span class="s1">while ((typeof x === </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">|| typeof x === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp; x !== null) {</span><span class="s3">\n        </span><span class="s1">const d = Object.getOwnPropertyDescriptor(x, name)</span><span class="s3">\n        </span><span class="s1">if (d) {</span><span class="s3">\n            </span><span class="s1">return d</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">x = Object.getPrototypeOf(x)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Check if a property is getter or not.</span><span class="s3">\n </span><span class="s1">* @param {object} object The object to check.</span><span class="s3">\n </span><span class="s1">* @param {string|number|symbol} name The property name to check.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isGetter(object, name) {</span><span class="s3">\n    </span><span class="s1">const d = getPropertyDescriptor(object, name)</span><span class="s3">\n    </span><span class="s1">return d != null &amp;&amp; d.get != null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Get the element values of a given node list.</span><span class="s3">\n </span><span class="s1">* @param {(Node|TSESTreeNode|null)[]} nodeList The node list to get values.</span><span class="s3">\n </span><span class="s1">* @param {Scope|undefined|null} initialScope The initial scope to find variables.</span><span class="s3">\n </span><span class="s1">* @returns {any[]|null} The value list if all nodes are constant. Otherwise, null.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getElementValues(nodeList, initialScope) {</span><span class="s3">\n    </span><span class="s1">const valueList = []</span><span class="s3">\n\n    </span><span class="s1">for (let i = 0; i &lt; nodeList.length; ++i) {</span><span class="s3">\n        </span><span class="s1">const elementNode = nodeList[i]</span><span class="s3">\n\n        </span><span class="s1">if (elementNode == null) {</span><span class="s3">\n            </span><span class="s1">valueList.length = i + 1</span><span class="s3">\n        </span><span class="s1">} else if (elementNode.type === </span><span class="s3">\&quot;</span><span class="s1">SpreadElement</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">const argument = getStaticValueR(elementNode.argument, initialScope)</span><span class="s3">\n            </span><span class="s1">if (argument == null) {</span><span class="s3">\n                </span><span class="s1">return null</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">valueList.push(.../** @type {Iterable&lt;any&gt;} */ (argument.value))</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">const element = getStaticValueR(elementNode, initialScope)</span><span class="s3">\n            </span><span class="s1">if (element == null) {</span><span class="s3">\n                </span><span class="s1">return null</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">valueList.push(element.value)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return valueList</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if a variable is a built-in global.</span><span class="s3">\n </span><span class="s1">* @param {Variable|null} variable The variable to check.</span><span class="s3">\n </span><span class="s1">* @returns {variable is Variable &amp; {defs:[]}}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isBuiltinGlobal(variable) {</span><span class="s3">\n    </span><span class="s1">return (</span><span class="s3">\n        </span><span class="s1">variable != null &amp;&amp;</span><span class="s3">\n        </span><span class="s1">variable.defs.length === 0 &amp;&amp;</span><span class="s3">\n        </span><span class="s1">builtinNames.has(variable.name) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">variable.name in globalObject</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if a variable can be considered as a constant.</span><span class="s3">\n </span><span class="s1">* @param {Variable} variable</span><span class="s3">\n </span><span class="s1">* @returns {variable is Variable &amp; {defs: [import(</span><span class="s3">\&quot;</span><span class="s1">eslint</span><span class="s3">\&quot;</span><span class="s1">).Scope.Definition &amp; { type: </span><span class="s3">\&quot;</span><span class="s1">Variable</span><span class="s3">\&quot; </span><span class="s1">}]}} True if the variable can be considered as a constant.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function canBeConsideredConst(variable) {</span><span class="s3">\n    </span><span class="s1">if (variable.defs.length !== 1) {</span><span class="s3">\n        </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const def = variable.defs[0]</span><span class="s3">\n    </span><span class="s1">return Boolean(</span><span class="s3">\n        </span><span class="s1">def.parent &amp;&amp;</span><span class="s3">\n            </span><span class="s1">def.type === </span><span class="s3">\&quot;</span><span class="s1">Variable</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n            </span><span class="s1">(def.parent.kind === </span><span class="s3">\&quot;</span><span class="s1">const</span><span class="s3">\&quot; </span><span class="s1">|| isEffectivelyConst(variable)),</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns whether the given variable is never written to after initialization.</span><span class="s3">\n </span><span class="s1">* @param {Variable} variable</span><span class="s3">\n </span><span class="s1">* @returns {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isEffectivelyConst(variable) {</span><span class="s3">\n    </span><span class="s1">const refs = variable.references</span><span class="s3">\n\n    </span><span class="s1">const inits = refs.filter((r) =&gt; r.init).length</span><span class="s3">\n    </span><span class="s1">const reads = refs.filter((r) =&gt; r.isReadOnly()).length</span><span class="s3">\n    </span><span class="s1">if (inits === 1 &amp;&amp; reads + inits === refs.length) {</span><span class="s3">\n        </span><span class="s1">// there is only one init and all other references only read</span><span class="s3">\n        </span><span class="s1">return true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if a variable has mutation in its property.</span><span class="s3">\n </span><span class="s1">* @param {Variable} variable The variable to check.</span><span class="s3">\n </span><span class="s1">* @param {Scope|null} initialScope The scope to start finding variable. Optional. If the node is a computed property node and this scope was given, this checks the computed property name by the `getStringIfConstant` function with the scope, and returns the value of it.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} True if the variable has mutation in its property.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function hasMutationInProperty(variable, initialScope) {</span><span class="s3">\n    </span><span class="s1">for (const ref of variable.references) {</span><span class="s3">\n        </span><span class="s1">let node = /** @type {TSESTreeNode} */ (ref.identifier)</span><span class="s3">\n        </span><span class="s1">while (node &amp;&amp; node.parent &amp;&amp; node.parent.type === </span><span class="s3">\&quot;</span><span class="s1">MemberExpression</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">node = node.parent</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!node || !node.parent) {</span><span class="s3">\n            </span><span class="s1">continue</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n            </span><span class="s1">(node.parent.type === </span><span class="s3">\&quot;</span><span class="s1">AssignmentExpression</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n                </span><span class="s1">node.parent.left === node) ||</span><span class="s3">\n            </span><span class="s1">(node.parent.type === </span><span class="s3">\&quot;</span><span class="s1">UpdateExpression</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n                </span><span class="s1">node.parent.argument === node)</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">// This is a mutation.</span><span class="s3">\n            </span><span class="s1">return true</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n            </span><span class="s1">node.parent.type === </span><span class="s3">\&quot;</span><span class="s1">CallExpression</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n            </span><span class="s1">node.parent.callee === node &amp;&amp;</span><span class="s3">\n            </span><span class="s1">node.type === </span><span class="s3">\&quot;</span><span class="s1">MemberExpression</span><span class="s3">\&quot;\n        </span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">const methodName = getStaticPropertyNameValue(node, initialScope)</span><span class="s3">\n            </span><span class="s1">if (isNameOfMutationArrayMethod(methodName)) {</span><span class="s3">\n                </span><span class="s1">// This is a mutation.</span><span class="s3">\n                </span><span class="s1">return true</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Checks if a method name is one of the mutation array methods.</span><span class="s3">\n     </span><span class="s1">* @param {StaticValue|null} methodName The method name to check.</span><span class="s3">\n     </span><span class="s1">* @returns {boolean} True if the method name is a mutation array method.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function isNameOfMutationArrayMethod(methodName) {</span><span class="s3">\n        </span><span class="s1">if (methodName == null || methodName.value == null) {</span><span class="s3">\n            </span><span class="s1">return false</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const name = methodName.value</span><span class="s3">\n        </span><span class="s1">return (</span><span class="s3">\n            </span><span class="s1">name === </span><span class="s3">\&quot;</span><span class="s1">copyWithin</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n            </span><span class="s1">name === </span><span class="s3">\&quot;</span><span class="s1">fill</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n            </span><span class="s1">name === </span><span class="s3">\&quot;</span><span class="s1">pop</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n            </span><span class="s1">name === </span><span class="s3">\&quot;</span><span class="s1">push</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n            </span><span class="s1">name === </span><span class="s3">\&quot;</span><span class="s1">reverse</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n            </span><span class="s1">name === </span><span class="s3">\&quot;</span><span class="s1">shift</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n            </span><span class="s1">name === </span><span class="s3">\&quot;</span><span class="s1">sort</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n            </span><span class="s1">name === </span><span class="s3">\&quot;</span><span class="s1">splice</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n            </span><span class="s1">name === </span><span class="s3">\&quot;</span><span class="s1">unshift</span><span class="s3">\&quot;\n        </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template {TSESTreeNodeTypes} T</span><span class="s3">\n </span><span class="s1">* @callback VisitorCallback</span><span class="s3">\n </span><span class="s1">* @param {TSESTreeNode &amp; { type: T }} node</span><span class="s3">\n </span><span class="s1">* @param {Scope|undefined|null} initialScope</span><span class="s3">\n </span><span class="s1">* @returns {StaticValue | null}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @typedef { { [K in TSESTreeNodeTypes]?: VisitorCallback&lt;K&gt; } } Operations</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @type {Operations}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const operations = Object.freeze({</span><span class="s3">\n    </span><span class="s1">ArrayExpression(node, initialScope) {</span><span class="s3">\n        </span><span class="s1">const elements = getElementValues(node.elements, initialScope)</span><span class="s3">\n        </span><span class="s1">return elements != null ? { value: elements } : null</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">AssignmentExpression(node, initialScope) {</span><span class="s3">\n        </span><span class="s1">if (node.operator === </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">return getStaticValueR(node.right, initialScope)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">//eslint-disable-next-line complexity</span><span class="s3">\n    </span><span class="s1">BinaryExpression(node, initialScope) {</span><span class="s3">\n        </span><span class="s1">if (node.operator === </span><span class="s3">\&quot;</span><span class="s1">in</span><span class="s3">\&quot; </span><span class="s1">|| node.operator === </span><span class="s3">\&quot;</span><span class="s1">instanceof</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">// Not supported.</span><span class="s3">\n            </span><span class="s1">return null</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const left = getStaticValueR(node.left, initialScope)</span><span class="s3">\n        </span><span class="s1">const right = getStaticValueR(node.right, initialScope)</span><span class="s3">\n        </span><span class="s1">if (left != null &amp;&amp; right != null) {</span><span class="s3">\n            </span><span class="s1">switch (node.operator) {</span><span class="s3">\n                </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">==</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                    </span><span class="s1">return { value: left.value == right.value } //eslint-disable-line eqeqeq</span><span class="s3">\n                </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">!=</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                    </span><span class="s1">return { value: left.value != right.value } //eslint-disable-line eqeqeq</span><span class="s3">\n                </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">===</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                    </span><span class="s1">return { value: left.value === right.value }</span><span class="s3">\n                </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">!==</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                    </span><span class="s1">return { value: left.value !== right.value }</span><span class="s3">\n                </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">&lt;</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                    </span><span class="s1">return {</span><span class="s3">\n                        </span><span class="s1">value:</span><span class="s3">\n                            </span><span class="s1">/** @type {any} */ (left.value) &lt;</span><span class="s3">\n                            </span><span class="s1">/** @type {any} */ (right.value),</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">&lt;=</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                    </span><span class="s1">return {</span><span class="s3">\n                        </span><span class="s1">value:</span><span class="s3">\n                            </span><span class="s1">/** @type {any} */ (left.value) &lt;=</span><span class="s3">\n                            </span><span class="s1">/** @type {any} */ (right.value),</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                    </span><span class="s1">return {</span><span class="s3">\n                        </span><span class="s1">value:</span><span class="s3">\n                            </span><span class="s1">/** @type {any} */ (left.value) &gt;</span><span class="s3">\n                            </span><span class="s1">/** @type {any} */ (right.value),</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">&gt;=</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                    </span><span class="s1">return {</span><span class="s3">\n                        </span><span class="s1">value:</span><span class="s3">\n                            </span><span class="s1">/** @type {any} */ (left.value) &gt;=</span><span class="s3">\n                            </span><span class="s1">/** @type {any} */ (right.value),</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">&lt;&lt;</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                    </span><span class="s1">return {</span><span class="s3">\n                        </span><span class="s1">value:</span><span class="s3">\n                            </span><span class="s1">/** @type {any} */ (left.value) &lt;&lt;</span><span class="s3">\n                            </span><span class="s1">/** @type {any} */ (right.value),</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">&gt;&gt;</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                    </span><span class="s1">return {</span><span class="s3">\n                        </span><span class="s1">value:</span><span class="s3">\n                            </span><span class="s1">/** @type {any} */ (left.value) &gt;&gt;</span><span class="s3">\n                            </span><span class="s1">/** @type {any} */ (right.value),</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">&gt;&gt;&gt;</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                    </span><span class="s1">return {</span><span class="s3">\n                        </span><span class="s1">value:</span><span class="s3">\n                            </span><span class="s1">/** @type {any} */ (left.value) &gt;&gt;&gt;</span><span class="s3">\n                            </span><span class="s1">/** @type {any} */ (right.value),</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                    </span><span class="s1">return {</span><span class="s3">\n                        </span><span class="s1">value:</span><span class="s3">\n                            </span><span class="s1">/** @type {any} */ (left.value) +</span><span class="s3">\n                            </span><span class="s1">/** @type {any} */ (right.value),</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                    </span><span class="s1">return {</span><span class="s3">\n                        </span><span class="s1">value:</span><span class="s3">\n                            </span><span class="s1">/** @type {any} */ (left.value) -</span><span class="s3">\n                            </span><span class="s1">/** @type {any} */ (right.value),</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                    </span><span class="s1">return {</span><span class="s3">\n                        </span><span class="s1">value:</span><span class="s3">\n                            </span><span class="s1">/** @type {any} */ (left.value) *</span><span class="s3">\n                            </span><span class="s1">/** @type {any} */ (right.value),</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                    </span><span class="s1">return {</span><span class="s3">\n                        </span><span class="s1">value:</span><span class="s3">\n                            </span><span class="s1">/** @type {any} */ (left.value) /</span><span class="s3">\n                            </span><span class="s1">/** @type {any} */ (right.value),</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">%</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                    </span><span class="s1">return {</span><span class="s3">\n                        </span><span class="s1">value:</span><span class="s3">\n                            </span><span class="s1">/** @type {any} */ (left.value) %</span><span class="s3">\n                            </span><span class="s1">/** @type {any} */ (right.value),</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">**</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                    </span><span class="s1">return {</span><span class="s3">\n                        </span><span class="s1">value:</span><span class="s3">\n                            </span><span class="s1">/** @type {any} */ (left.value) **</span><span class="s3">\n                            </span><span class="s1">/** @type {any} */ (right.value),</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                    </span><span class="s1">return {</span><span class="s3">\n                        </span><span class="s1">value:</span><span class="s3">\n                            </span><span class="s1">/** @type {any} */ (left.value) |</span><span class="s3">\n                            </span><span class="s1">/** @type {any} */ (right.value),</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">^</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                    </span><span class="s1">return {</span><span class="s3">\n                        </span><span class="s1">value:</span><span class="s3">\n                            </span><span class="s1">/** @type {any} */ (left.value) ^</span><span class="s3">\n                            </span><span class="s1">/** @type {any} */ (right.value),</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">&amp;</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                    </span><span class="s1">return {</span><span class="s3">\n                        </span><span class="s1">value:</span><span class="s3">\n                            </span><span class="s1">/** @type {any} */ (left.value) &amp;</span><span class="s3">\n                            </span><span class="s1">/** @type {any} */ (right.value),</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n\n                </span><span class="s1">// no default</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">CallExpression(node, initialScope) {</span><span class="s3">\n        </span><span class="s1">const calleeNode = node.callee</span><span class="s3">\n        </span><span class="s1">const args = getElementValues(node.arguments, initialScope)</span><span class="s3">\n\n        </span><span class="s1">if (args != null) {</span><span class="s3">\n            </span><span class="s1">if (calleeNode.type === </span><span class="s3">\&quot;</span><span class="s1">MemberExpression</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">if (calleeNode.property.type === </span><span class="s3">\&quot;</span><span class="s1">PrivateIdentifier</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                    </span><span class="s1">return null</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">const object = getStaticValueR(calleeNode.object, initialScope)</span><span class="s3">\n                </span><span class="s1">if (object != null) {</span><span class="s3">\n                    </span><span class="s1">if (</span><span class="s3">\n                        </span><span class="s1">object.value == null &amp;&amp;</span><span class="s3">\n                        </span><span class="s1">(object.optional || node.optional)</span><span class="s3">\n                    </span><span class="s1">) {</span><span class="s3">\n                        </span><span class="s1">return { value: undefined, optional: true }</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">const property = getStaticPropertyNameValue(</span><span class="s3">\n                        </span><span class="s1">calleeNode,</span><span class="s3">\n                        </span><span class="s1">initialScope,</span><span class="s3">\n                    </span><span class="s1">)</span><span class="s3">\n\n                    </span><span class="s1">if (property != null) {</span><span class="s3">\n                        </span><span class="s1">const receiver =</span><span class="s3">\n                            </span><span class="s1">/** @type {Record&lt;PropertyKey, (...args: any[]) =&gt; any&gt;} */ (</span><span class="s3">\n                                </span><span class="s1">object.value</span><span class="s3">\n                            </span><span class="s1">)</span><span class="s3">\n                        </span><span class="s1">const methodName = /** @type {PropertyKey} */ (</span><span class="s3">\n                            </span><span class="s1">property.value</span><span class="s3">\n                        </span><span class="s1">)</span><span class="s3">\n                        </span><span class="s1">if (callAllowed.has(receiver[methodName])) {</span><span class="s3">\n                            </span><span class="s1">return {</span><span class="s3">\n                                </span><span class="s1">value: receiver[methodName](...args),</span><span class="s3">\n                            </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">if (callPassThrough.has(receiver[methodName])) {</span><span class="s3">\n                            </span><span class="s1">return { value: args[0] }</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n                </span><span class="s1">const callee = getStaticValueR(calleeNode, initialScope)</span><span class="s3">\n                </span><span class="s1">if (callee != null) {</span><span class="s3">\n                    </span><span class="s1">if (callee.value == null &amp;&amp; node.optional) {</span><span class="s3">\n                        </span><span class="s1">return { value: undefined, optional: true }</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">const func = /** @type {(...args: any[]) =&gt; any} */ (</span><span class="s3">\n                        </span><span class="s1">callee.value</span><span class="s3">\n                    </span><span class="s1">)</span><span class="s3">\n                    </span><span class="s1">if (callAllowed.has(func)) {</span><span class="s3">\n                        </span><span class="s1">return { value: func(...args) }</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">if (callPassThrough.has(func)) {</span><span class="s3">\n                        </span><span class="s1">return { value: args[0] }</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">ConditionalExpression(node, initialScope) {</span><span class="s3">\n        </span><span class="s1">const test = getStaticValueR(node.test, initialScope)</span><span class="s3">\n        </span><span class="s1">if (test != null) {</span><span class="s3">\n            </span><span class="s1">return test.value</span><span class="s3">\n                </span><span class="s1">? getStaticValueR(node.consequent, initialScope)</span><span class="s3">\n                </span><span class="s1">: getStaticValueR(node.alternate, initialScope)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">ExpressionStatement(node, initialScope) {</span><span class="s3">\n        </span><span class="s1">return getStaticValueR(node.expression, initialScope)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">Identifier(node, initialScope) {</span><span class="s3">\n        </span><span class="s1">if (initialScope != null) {</span><span class="s3">\n            </span><span class="s1">const variable = findVariable(initialScope, node)</span><span class="s3">\n\n            </span><span class="s1">if (variable != null) {</span><span class="s3">\n                </span><span class="s1">// Built-in globals.</span><span class="s3">\n                </span><span class="s1">if (isBuiltinGlobal(variable)) {</span><span class="s3">\n                    </span><span class="s1">return { value: globalObject[variable.name] }</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n\n                </span><span class="s1">// Constants.</span><span class="s3">\n                </span><span class="s1">if (canBeConsideredConst(variable)) {</span><span class="s3">\n                    </span><span class="s1">const def = variable.defs[0]</span><span class="s3">\n                    </span><span class="s1">if (</span><span class="s3">\n                        </span><span class="s1">// TODO(mysticatea): don't support destructuring here.</span><span class="s3">\n                        </span><span class="s1">def.node.id.type === </span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot;\n                    </span><span class="s1">) {</span><span class="s3">\n                        </span><span class="s1">const init = getStaticValueR(</span><span class="s3">\n                            </span><span class="s1">def.node.init,</span><span class="s3">\n                            </span><span class="s1">initialScope,</span><span class="s3">\n                        </span><span class="s1">)</span><span class="s3">\n                        </span><span class="s1">if (</span><span class="s3">\n                            </span><span class="s1">init &amp;&amp;</span><span class="s3">\n                            </span><span class="s1">typeof init.value === </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n                            </span><span class="s1">init.value !== null</span><span class="s3">\n                        </span><span class="s1">) {</span><span class="s3">\n                            </span><span class="s1">if (hasMutationInProperty(variable, initialScope)) {</span><span class="s3">\n                                </span><span class="s1">// This variable has mutation in its property.</span><span class="s3">\n                                </span><span class="s1">return null</span><span class="s3">\n                            </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">return init</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">Literal(node) {</span><span class="s3">\n        </span><span class="s1">const literal =</span><span class="s3">\n            </span><span class="s1">/** @type {Partial&lt;Literal&gt; &amp; Partial&lt;RegExpLiteral&gt; &amp; Partial&lt;BigIntLiteral&gt;} */ (</span><span class="s3">\n                </span><span class="s1">node</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">//istanbul ignore if : this is implementation-specific behavior.</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n            </span><span class="s1">(literal.regex != null || literal.bigint != null) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">literal.value == null</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">// It was a RegExp/BigInt literal, but Node.js didn't support it.</span><span class="s3">\n            </span><span class="s1">return null</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return { value: literal.value }</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">LogicalExpression(node, initialScope) {</span><span class="s3">\n        </span><span class="s1">const left = getStaticValueR(node.left, initialScope)</span><span class="s3">\n        </span><span class="s1">if (left != null) {</span><span class="s3">\n            </span><span class="s1">if (</span><span class="s3">\n                </span><span class="s1">(node.operator === </span><span class="s3">\&quot;</span><span class="s1">||</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; Boolean(left.value) === true) ||</span><span class="s3">\n                </span><span class="s1">(node.operator === </span><span class="s3">\&quot;</span><span class="s1">&amp;&amp;</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; Boolean(left.value) === false) ||</span><span class="s3">\n                </span><span class="s1">(node.operator === </span><span class="s3">\&quot;</span><span class="s1">??</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; left.value != null)</span><span class="s3">\n            </span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">return left</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">const right = getStaticValueR(node.right, initialScope)</span><span class="s3">\n            </span><span class="s1">if (right != null) {</span><span class="s3">\n                </span><span class="s1">return right</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">MemberExpression(node, initialScope) {</span><span class="s3">\n        </span><span class="s1">if (node.property.type === </span><span class="s3">\&quot;</span><span class="s1">PrivateIdentifier</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">return null</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const object = getStaticValueR(node.object, initialScope)</span><span class="s3">\n        </span><span class="s1">if (object != null) {</span><span class="s3">\n            </span><span class="s1">if (object.value == null &amp;&amp; (object.optional || node.optional)) {</span><span class="s3">\n                </span><span class="s1">return { value: undefined, optional: true }</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const property = getStaticPropertyNameValue(node, initialScope)</span><span class="s3">\n\n            </span><span class="s1">if (property != null) {</span><span class="s3">\n                </span><span class="s1">if (</span><span class="s3">\n                    </span><span class="s1">!isGetter(</span><span class="s3">\n                        </span><span class="s1">/** @type {object} */ (object.value),</span><span class="s3">\n                        </span><span class="s1">/** @type {PropertyKey} */ (property.value),</span><span class="s3">\n                    </span><span class="s1">)</span><span class="s3">\n                </span><span class="s1">) {</span><span class="s3">\n                    </span><span class="s1">return {</span><span class="s3">\n                        </span><span class="s1">value: /** @type {Record&lt;PropertyKey, unknown&gt;} */ (</span><span class="s3">\n                            </span><span class="s1">object.value</span><span class="s3">\n                        </span><span class="s1">)[/** @type {PropertyKey} */ (property.value)],</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n\n                </span><span class="s1">for (const [classFn, allowed] of getterAllowed) {</span><span class="s3">\n                    </span><span class="s1">if (</span><span class="s3">\n                        </span><span class="s1">object.value instanceof classFn &amp;&amp;</span><span class="s3">\n                        </span><span class="s1">allowed.has(/** @type {string} */ (property.value))</span><span class="s3">\n                    </span><span class="s1">) {</span><span class="s3">\n                        </span><span class="s1">return {</span><span class="s3">\n                            </span><span class="s1">value: /** @type {Record&lt;PropertyKey, unknown&gt;} */ (</span><span class="s3">\n                                </span><span class="s1">object.value</span><span class="s3">\n                            </span><span class="s1">)[/** @type {PropertyKey} */ (property.value)],</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">ChainExpression(node, initialScope) {</span><span class="s3">\n        </span><span class="s1">const expression = getStaticValueR(node.expression, initialScope)</span><span class="s3">\n        </span><span class="s1">if (expression != null) {</span><span class="s3">\n            </span><span class="s1">return { value: expression.value }</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">NewExpression(node, initialScope) {</span><span class="s3">\n        </span><span class="s1">const callee = getStaticValueR(node.callee, initialScope)</span><span class="s3">\n        </span><span class="s1">const args = getElementValues(node.arguments, initialScope)</span><span class="s3">\n\n        </span><span class="s1">if (callee != null &amp;&amp; args != null) {</span><span class="s3">\n            </span><span class="s1">const Func = /** @type {new (...args: any[]) =&gt; any} */ (</span><span class="s3">\n                </span><span class="s1">callee.value</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">if (callAllowed.has(Func)) {</span><span class="s3">\n                </span><span class="s1">return { value: new Func(...args) }</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">ObjectExpression(node, initialScope) {</span><span class="s3">\n        </span><span class="s1">/** @type {Record&lt;PropertyKey, unknown&gt;} */</span><span class="s3">\n        </span><span class="s1">const object = {}</span><span class="s3">\n\n        </span><span class="s1">for (const propertyNode of node.properties) {</span><span class="s3">\n            </span><span class="s1">if (propertyNode.type === </span><span class="s3">\&quot;</span><span class="s1">Property</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">if (propertyNode.kind !== </span><span class="s3">\&quot;</span><span class="s1">init</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                    </span><span class="s1">return null</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">const key = getStaticPropertyNameValue(</span><span class="s3">\n                    </span><span class="s1">propertyNode,</span><span class="s3">\n                    </span><span class="s1">initialScope,</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n                </span><span class="s1">const value = getStaticValueR(propertyNode.value, initialScope)</span><span class="s3">\n                </span><span class="s1">if (key == null || value == null) {</span><span class="s3">\n                    </span><span class="s1">return null</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">object[/** @type {PropertyKey} */ (key.value)] = value.value</span><span class="s3">\n            </span><span class="s1">} else if (</span><span class="s3">\n                </span><span class="s1">propertyNode.type === </span><span class="s3">\&quot;</span><span class="s1">SpreadElement</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n                </span><span class="s1">// @ts-expect-error -- Backward compatibility</span><span class="s3">\n                </span><span class="s1">propertyNode.type === </span><span class="s3">\&quot;</span><span class="s1">ExperimentalSpreadProperty</span><span class="s3">\&quot;\n            </span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">const argument = getStaticValueR(</span><span class="s3">\n                    </span><span class="s1">propertyNode.argument,</span><span class="s3">\n                    </span><span class="s1">initialScope,</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n                </span><span class="s1">if (argument == null) {</span><span class="s3">\n                    </span><span class="s1">return null</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">Object.assign(object, argument.value)</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n                </span><span class="s1">return null</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">return { value: object }</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">SequenceExpression(node, initialScope) {</span><span class="s3">\n        </span><span class="s1">const last = node.expressions[node.expressions.length - 1]</span><span class="s3">\n        </span><span class="s1">return getStaticValueR(last, initialScope)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">TaggedTemplateExpression(node, initialScope) {</span><span class="s3">\n        </span><span class="s1">const tag = getStaticValueR(node.tag, initialScope)</span><span class="s3">\n        </span><span class="s1">const expressions = getElementValues(</span><span class="s3">\n            </span><span class="s1">node.quasi.expressions,</span><span class="s3">\n            </span><span class="s1">initialScope,</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n\n        </span><span class="s1">if (tag != null &amp;&amp; expressions != null) {</span><span class="s3">\n            </span><span class="s1">const func = /** @type {(...args: any[]) =&gt; any} */ (tag.value)</span><span class="s3">\n            </span><span class="s1">/** @type {any[] &amp; { raw?: string[] }} */</span><span class="s3">\n            </span><span class="s1">const strings = node.quasi.quasis.map((q) =&gt; q.value.cooked)</span><span class="s3">\n            </span><span class="s1">strings.raw = node.quasi.quasis.map((q) =&gt; q.value.raw)</span><span class="s3">\n\n            </span><span class="s1">if (func === String.raw) {</span><span class="s3">\n                </span><span class="s1">return { value: func(strings, ...expressions) }</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">TemplateLiteral(node, initialScope) {</span><span class="s3">\n        </span><span class="s1">const expressions = getElementValues(node.expressions, initialScope)</span><span class="s3">\n        </span><span class="s1">if (expressions != null) {</span><span class="s3">\n            </span><span class="s1">let value = node.quasis[0].value.cooked</span><span class="s3">\n            </span><span class="s1">for (let i = 0; i &lt; expressions.length; ++i) {</span><span class="s3">\n                </span><span class="s1">value += expressions[i]</span><span class="s3">\n                </span><span class="s1">value += /** @type {string} */ (node.quasis[i + 1].value.cooked)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return { value }</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">UnaryExpression(node, initialScope) {</span><span class="s3">\n        </span><span class="s1">if (node.operator === </span><span class="s3">\&quot;</span><span class="s1">delete</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">// Not supported.</span><span class="s3">\n            </span><span class="s1">return null</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (node.operator === </span><span class="s3">\&quot;</span><span class="s1">void</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">return { value: undefined }</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const arg = getStaticValueR(node.argument, initialScope)</span><span class="s3">\n        </span><span class="s1">if (arg != null) {</span><span class="s3">\n            </span><span class="s1">switch (node.operator) {</span><span class="s3">\n                </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                    </span><span class="s1">return { value: -(/** @type {any} */ (arg.value)) }</span><span class="s3">\n                </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                    </span><span class="s1">return { value: +(/** @type {any} */ (arg.value)) } //eslint-disable-line no-implicit-coercion</span><span class="s3">\n                </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">!</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                    </span><span class="s1">return { value: !arg.value }</span><span class="s3">\n                </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">~</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                    </span><span class="s1">return { value: ~(/** @type {any} */ (arg.value)) }</span><span class="s3">\n                </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">typeof</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                    </span><span class="s1">return { value: typeof arg.value }</span><span class="s3">\n\n                </span><span class="s1">// no default</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">TSAsExpression(node, initialScope) {</span><span class="s3">\n        </span><span class="s1">return getStaticValueR(node.expression, initialScope)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">TSSatisfiesExpression(node, initialScope) {</span><span class="s3">\n        </span><span class="s1">return getStaticValueR(node.expression, initialScope)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">TSTypeAssertion(node, initialScope) {</span><span class="s3">\n        </span><span class="s1">return getStaticValueR(node.expression, initialScope)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">TSNonNullExpression(node, initialScope) {</span><span class="s3">\n        </span><span class="s1">return getStaticValueR(node.expression, initialScope)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">TSInstantiationExpression(node, initialScope) {</span><span class="s3">\n        </span><span class="s1">return getStaticValueR(node.expression, initialScope)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">})</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Get the value of a given node if it's a static value.</span><span class="s3">\n </span><span class="s1">* @param {Node|TSESTreeNode|null|undefined} node The node to get.</span><span class="s3">\n </span><span class="s1">* @param {Scope|undefined|null} initialScope The scope to start finding variable.</span><span class="s3">\n </span><span class="s1">* @returns {StaticValue|null} The static value of the node, or `null`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getStaticValueR(node, initialScope) {</span><span class="s3">\n    </span><span class="s1">if (node != null &amp;&amp; Object.hasOwnProperty.call(operations, node.type)) {</span><span class="s3">\n        </span><span class="s1">return /** @type {VisitorCallback&lt;any&gt;} */ (operations[node.type])(</span><span class="s3">\n            </span><span class="s1">/** @type {TSESTreeNode} */ (node),</span><span class="s3">\n            </span><span class="s1">initialScope,</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Get the static value of property name from a MemberExpression node or a Property node.</span><span class="s3">\n </span><span class="s1">* @param {MemberExpression|Property} node The node to get.</span><span class="s3">\n </span><span class="s1">* @param {Scope|null} [initialScope] The scope to start finding variable. Optional. If the node is a computed property node and this scope was given, this checks the computed property name by the `getStringIfConstant` function with the scope, and returns the value of it.</span><span class="s3">\n </span><span class="s1">* @returns {StaticValue|null} The static value of the property name of the node, or `null`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getStaticPropertyNameValue(node, initialScope) {</span><span class="s3">\n    </span><span class="s1">const nameNode = node.type === </span><span class="s3">\&quot;</span><span class="s1">Property</span><span class="s3">\&quot; </span><span class="s1">? node.key : node.property</span><span class="s3">\n\n    </span><span class="s1">if (node.computed) {</span><span class="s3">\n        </span><span class="s1">return getStaticValueR(nameNode, initialScope)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (nameNode.type === </span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return { value: nameNode.name }</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (nameNode.type === </span><span class="s3">\&quot;</span><span class="s1">Literal</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">if (/** @type {Partial&lt;BigIntLiteral&gt;} */ (nameNode).bigint) {</span><span class="s3">\n            </span><span class="s1">return { value: /** @type {BigIntLiteral} */ (nameNode).bigint }</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return { value: String(nameNode.value) }</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Get the value of a given node if it's a static value.</span><span class="s3">\n </span><span class="s1">* @param {Node} node The node to get.</span><span class="s3">\n </span><span class="s1">* @param {Scope|null} [initialScope] The scope to start finding variable. Optional. If this scope was given, this tries to resolve identifier references which are in the given node as much as possible.</span><span class="s3">\n </span><span class="s1">* @returns {StaticValue | null} The static value of the node, or `null`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getStaticValue(node, initialScope = null) {</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">return getStaticValueR(node, initialScope)</span><span class="s3">\n    </span><span class="s1">} catch (_error) {</span><span class="s3">\n        </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { getStaticValue } from </span><span class="s3">\&quot;</span><span class="s1">./get-static-value.mjs</span><span class="s3">\&quot;\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">eslint</span><span class="s3">\&quot;</span><span class="s1">).Scope.Scope} Scope */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).Node} Node */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).RegExpLiteral} RegExpLiteral */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).BigIntLiteral} BigIntLiteral */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).SimpleLiteral} SimpleLiteral */</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Get the value of a given node if it's a literal or a template literal.</span><span class="s3">\n </span><span class="s1">* @param {Node} node The node to get.</span><span class="s3">\n </span><span class="s1">* @param {Scope|null} [initialScope] The scope to start finding variable. Optional. If the node is an Identifier node and this scope was given, this checks the variable of the identifier, and returns the value of it if the variable is a constant.</span><span class="s3">\n </span><span class="s1">* @returns {string|null} The value of the node, or `null`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getStringIfConstant(node, initialScope = null) {</span><span class="s3">\n    </span><span class="s1">// Handle the literals that the platform doesn't support natively.</span><span class="s3">\n    </span><span class="s1">if (node &amp;&amp; node.type === </span><span class="s3">\&quot;</span><span class="s1">Literal</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; node.value === null) {</span><span class="s3">\n        </span><span class="s1">const literal =</span><span class="s3">\n            </span><span class="s1">/** @type {Partial&lt;SimpleLiteral&gt; &amp; Partial&lt;RegExpLiteral&gt; &amp; Partial&lt;BigIntLiteral&gt;} */ (</span><span class="s3">\n                </span><span class="s1">node</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">if (literal.regex) {</span><span class="s3">\n            </span><span class="s1">return `/${literal.regex.pattern}/${literal.regex.flags}`</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (literal.bigint) {</span><span class="s3">\n            </span><span class="s1">return literal.bigint</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const evaluated = getStaticValue(node, initialScope)</span><span class="s3">\n\n    </span><span class="s1">if (evaluated) {</span><span class="s3">\n        </span><span class="s1">// `String(Symbol.prototype)` throws error</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">return String(evaluated.value)</span><span class="s3">\n        </span><span class="s1">} catch {</span><span class="s3">\n            </span><span class="s1">// No op</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { getStringIfConstant } from </span><span class="s3">\&quot;</span><span class="s1">./get-string-if-constant.mjs</span><span class="s3">\&quot;\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">eslint</span><span class="s3">\&quot;</span><span class="s1">).Scope.Scope} Scope */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).MemberExpression} MemberExpression */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).MethodDefinition} MethodDefinition */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).Property} Property */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).PropertyDefinition} PropertyDefinition */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).Identifier} Identifier */</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Get the property name from a MemberExpression node or a Property node.</span><span class="s3">\n </span><span class="s1">* @param {MemberExpression | MethodDefinition | Property | PropertyDefinition} node The node to get.</span><span class="s3">\n </span><span class="s1">* @param {Scope} [initialScope] The scope to start finding variable. Optional. If the node is a computed property node and this scope was given, this checks the computed property name by the `getStringIfConstant` function with the scope, and returns the value of it.</span><span class="s3">\n </span><span class="s1">* @returns {string|null|undefined} The property name of the node.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getPropertyName(node, initialScope) {</span><span class="s3">\n    </span><span class="s1">switch (node.type) {</span><span class="s3">\n        </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">MemberExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">if (node.computed) {</span><span class="s3">\n                </span><span class="s1">return getStringIfConstant(node.property, initialScope)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (node.property.type === </span><span class="s3">\&quot;</span><span class="s1">PrivateIdentifier</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">return null</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return /** @type {Partial&lt;Identifier&gt;} */ (node.property).name</span><span class="s3">\n\n        </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">Property</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">MethodDefinition</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">PropertyDefinition</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">if (node.computed) {</span><span class="s3">\n                </span><span class="s1">return getStringIfConstant(node.key, initialScope)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (node.key.type === </span><span class="s3">\&quot;</span><span class="s1">Literal</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">return String(node.key.value)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (node.key.type === </span><span class="s3">\&quot;</span><span class="s1">PrivateIdentifier</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">return null</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return /** @type {Partial&lt;Identifier&gt;} */ (node.key).name</span><span class="s3">\n\n        </span><span class="s1">default:</span><span class="s3">\n            </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { getPropertyName } from </span><span class="s3">\&quot;</span><span class="s1">./get-property-name.mjs</span><span class="s3">\&quot;\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">eslint</span><span class="s3">\&quot;</span><span class="s1">).Rule.Node} RuleNode */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">eslint</span><span class="s3">\&quot;</span><span class="s1">).SourceCode} SourceCode */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).Function} FunctionNode */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).FunctionDeclaration} FunctionDeclaration */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).FunctionExpression} FunctionExpression */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).Identifier} Identifier */</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Get the name and kind of the given function node.</span><span class="s3">\n </span><span class="s1">* @param {FunctionNode} node - The function node to get.</span><span class="s3">\n </span><span class="s1">* @param {SourceCode} [sourceCode] The source code object to get the code of computed property keys.</span><span class="s3">\n </span><span class="s1">* @returns {string} The name and kind of the function node.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">// eslint-disable-next-line complexity</span><span class="s3">\n</span><span class="s1">export function getFunctionNameWithKind(node, sourceCode) {</span><span class="s3">\n    </span><span class="s1">const parent = /** @type {RuleNode} */ (node).parent</span><span class="s3">\n    </span><span class="s1">const tokens = []</span><span class="s3">\n    </span><span class="s1">const isObjectMethod = parent.type === </span><span class="s3">\&quot;</span><span class="s1">Property</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; parent.value === node</span><span class="s3">\n    </span><span class="s1">const isClassMethod =</span><span class="s3">\n        </span><span class="s1">parent.type === </span><span class="s3">\&quot;</span><span class="s1">MethodDefinition</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; parent.value === node</span><span class="s3">\n    </span><span class="s1">const isClassFieldMethod =</span><span class="s3">\n        </span><span class="s1">parent.type === </span><span class="s3">\&quot;</span><span class="s1">PropertyDefinition</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; parent.value === node</span><span class="s3">\n\n    </span><span class="s1">// Modifiers.</span><span class="s3">\n    </span><span class="s1">if (isClassMethod || isClassFieldMethod) {</span><span class="s3">\n        </span><span class="s1">if (parent.static) {</span><span class="s3">\n            </span><span class="s1">tokens.push(</span><span class="s3">\&quot;</span><span class="s1">static</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (parent.key.type === </span><span class="s3">\&quot;</span><span class="s1">PrivateIdentifier</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">tokens.push(</span><span class="s3">\&quot;</span><span class="s1">private</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (node.async) {</span><span class="s3">\n        </span><span class="s1">tokens.push(</span><span class="s3">\&quot;</span><span class="s1">async</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (node.generator) {</span><span class="s3">\n        </span><span class="s1">tokens.push(</span><span class="s3">\&quot;</span><span class="s1">generator</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Kinds.</span><span class="s3">\n    </span><span class="s1">if (isObjectMethod || isClassMethod) {</span><span class="s3">\n        </span><span class="s1">if (parent.kind === </span><span class="s3">\&quot;</span><span class="s1">constructor</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">constructor</span><span class="s3">\&quot;\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (parent.kind === </span><span class="s3">\&quot;</span><span class="s1">get</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">tokens.push(</span><span class="s3">\&quot;</span><span class="s1">getter</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">} else if (parent.kind === </span><span class="s3">\&quot;</span><span class="s1">set</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">tokens.push(</span><span class="s3">\&quot;</span><span class="s1">setter</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">tokens.push(</span><span class="s3">\&quot;</span><span class="s1">method</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (isClassFieldMethod) {</span><span class="s3">\n        </span><span class="s1">tokens.push(</span><span class="s3">\&quot;</span><span class="s1">method</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">if (node.type === </span><span class="s3">\&quot;</span><span class="s1">ArrowFunctionExpression</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">tokens.push(</span><span class="s3">\&quot;</span><span class="s1">arrow</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">tokens.push(</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Names.</span><span class="s3">\n    </span><span class="s1">if (isObjectMethod || isClassMethod || isClassFieldMethod) {</span><span class="s3">\n        </span><span class="s1">if (parent.key.type === </span><span class="s3">\&quot;</span><span class="s1">PrivateIdentifier</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">tokens.push(`#${parent.key.name}`)</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">const name = getPropertyName(parent)</span><span class="s3">\n            </span><span class="s1">if (name) {</span><span class="s3">\n                </span><span class="s1">tokens.push(`'${name}'`)</span><span class="s3">\n            </span><span class="s1">} else if (sourceCode) {</span><span class="s3">\n                </span><span class="s1">const keyText = sourceCode.getText(parent.key)</span><span class="s3">\n                </span><span class="s1">if (!keyText.includes(</span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n                    </span><span class="s1">tokens.push(`[${keyText}]`)</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (hasId(node)) {</span><span class="s3">\n        </span><span class="s1">tokens.push(`'${node.id.name}'`)</span><span class="s3">\n    </span><span class="s1">} else if (</span><span class="s3">\n        </span><span class="s1">parent.type === </span><span class="s3">\&quot;</span><span class="s1">VariableDeclarator</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n        </span><span class="s1">parent.id &amp;&amp;</span><span class="s3">\n        </span><span class="s1">parent.id.type === </span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot;\n    </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">tokens.push(`'${parent.id.name}'`)</span><span class="s3">\n    </span><span class="s1">} else if (</span><span class="s3">\n        </span><span class="s1">(parent.type === </span><span class="s3">\&quot;</span><span class="s1">AssignmentExpression</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n            </span><span class="s1">parent.type === </span><span class="s3">\&quot;</span><span class="s1">AssignmentPattern</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">parent.left &amp;&amp;</span><span class="s3">\n        </span><span class="s1">parent.left.type === </span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot;\n    </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">tokens.push(`'${parent.left.name}'`)</span><span class="s3">\n    </span><span class="s1">} else if (</span><span class="s3">\n        </span><span class="s1">parent.type === </span><span class="s3">\&quot;</span><span class="s1">ExportDefaultDeclaration</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n        </span><span class="s1">parent.declaration === node</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">tokens.push(</span><span class="s3">\&quot;</span><span class="s1">'default'</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return tokens.join(</span><span class="s3">\&quot; \&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {FunctionNode} node</span><span class="s3">\n </span><span class="s1">* @returns {node is FunctionDeclaration | FunctionExpression &amp; { id: Identifier }}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function hasId(node) {</span><span class="s3">\n    </span><span class="s1">return Boolean(</span><span class="s3">\n        </span><span class="s1">/** @type {Partial&lt;FunctionDeclaration | FunctionExpression&gt;} */ (node)</span><span class="s3">\n            </span><span class="s1">.id,</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { getKeys, KEYS } from </span><span class="s3">\&quot;</span><span class="s1">eslint-visitor-keys</span><span class="s3">\&quot;\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).Node} Node */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">eslint</span><span class="s3">\&quot;</span><span class="s1">).SourceCode} SourceCode */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">./types.mjs</span><span class="s3">\&quot;</span><span class="s1">).HasSideEffectOptions} HasSideEffectOptions */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).BinaryExpression} BinaryExpression */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).MemberExpression} MemberExpression */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).MethodDefinition} MethodDefinition */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).Property} Property */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).PropertyDefinition} PropertyDefinition */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).UnaryExpression} UnaryExpression */</span><span class="s3">\n\n</span><span class="s1">const typeConversionBinaryOps = Object.freeze(</span><span class="s3">\n    </span><span class="s1">new Set([</span><span class="s3">\n        \&quot;</span><span class="s1">==</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">!=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">&lt;</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">&lt;=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">&gt;=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">&lt;&lt;</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">&gt;&gt;</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">&gt;&gt;&gt;</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">-</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">%</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">|</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">^</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">&amp;</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">in</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">]),</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">const typeConversionUnaryOps = Object.freeze(new Set([</span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">!</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">~</span><span class="s3">\&quot;</span><span class="s1">]))</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Check whether the given value is an ASTNode or not.</span><span class="s3">\n </span><span class="s1">* @param {any} x The value to check.</span><span class="s3">\n </span><span class="s1">* @returns {x is Node} `true` if the value is an ASTNode.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isNode(x) {</span><span class="s3">\n    </span><span class="s1">return x !== null &amp;&amp; typeof x === </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; typeof x.type === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const visitor = Object.freeze(</span><span class="s3">\n    </span><span class="s1">Object.assign(Object.create(null), {</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* @param {Node} node</span><span class="s3">\n         </span><span class="s1">* @param {HasSideEffectOptions} options</span><span class="s3">\n         </span><span class="s1">* @param {Record&lt;string, string[]&gt;} visitorKeys</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">$visit(node, options, visitorKeys) {</span><span class="s3">\n            </span><span class="s1">const { type } = node</span><span class="s3">\n\n            </span><span class="s1">if (typeof (/** @type {any} */ (this)[type]) === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">return /** @type {any} */ (this)[type](</span><span class="s3">\n                    </span><span class="s1">node,</span><span class="s3">\n                    </span><span class="s1">options,</span><span class="s3">\n                    </span><span class="s1">visitorKeys,</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">return this.$visitChildren(node, options, visitorKeys)</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* @param {Node} node</span><span class="s3">\n         </span><span class="s1">* @param {HasSideEffectOptions} options</span><span class="s3">\n         </span><span class="s1">* @param {Record&lt;string, string[]&gt;} visitorKeys</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">$visitChildren(node, options, visitorKeys) {</span><span class="s3">\n            </span><span class="s1">const { type } = node</span><span class="s3">\n\n            </span><span class="s1">for (const key of /** @type {(keyof Node)[]} */ (</span><span class="s3">\n                </span><span class="s1">visitorKeys[type] || getKeys(node)</span><span class="s3">\n            </span><span class="s1">)) {</span><span class="s3">\n                </span><span class="s1">const value = node[key]</span><span class="s3">\n\n                </span><span class="s1">if (Array.isArray(value)) {</span><span class="s3">\n                    </span><span class="s1">for (const element of value) {</span><span class="s3">\n                        </span><span class="s1">if (</span><span class="s3">\n                            </span><span class="s1">isNode(element) &amp;&amp;</span><span class="s3">\n                            </span><span class="s1">this.$visit(element, options, visitorKeys)</span><span class="s3">\n                        </span><span class="s1">) {</span><span class="s3">\n                            </span><span class="s1">return true</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">} else if (</span><span class="s3">\n                    </span><span class="s1">isNode(value) &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">this.$visit(value, options, visitorKeys)</span><span class="s3">\n                </span><span class="s1">) {</span><span class="s3">\n                    </span><span class="s1">return true</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">return false</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n\n        </span><span class="s1">ArrowFunctionExpression() {</span><span class="s3">\n            </span><span class="s1">return false</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">AssignmentExpression() {</span><span class="s3">\n            </span><span class="s1">return true</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">AwaitExpression() {</span><span class="s3">\n            </span><span class="s1">return true</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* @param {BinaryExpression} node</span><span class="s3">\n         </span><span class="s1">* @param {HasSideEffectOptions} options</span><span class="s3">\n         </span><span class="s1">* @param {Record&lt;string, string[]&gt;} visitorKeys</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">BinaryExpression(node, options, visitorKeys) {</span><span class="s3">\n            </span><span class="s1">if (</span><span class="s3">\n                </span><span class="s1">options.considerImplicitTypeConversion &amp;&amp;</span><span class="s3">\n                </span><span class="s1">typeConversionBinaryOps.has(node.operator) &amp;&amp;</span><span class="s3">\n                </span><span class="s1">(node.left.type !== </span><span class="s3">\&quot;</span><span class="s1">Literal</span><span class="s3">\&quot; </span><span class="s1">|| node.right.type !== </span><span class="s3">\&quot;</span><span class="s1">Literal</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">return true</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return this.$visitChildren(node, options, visitorKeys)</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">CallExpression() {</span><span class="s3">\n            </span><span class="s1">return true</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">FunctionExpression() {</span><span class="s3">\n            </span><span class="s1">return false</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">ImportExpression() {</span><span class="s3">\n            </span><span class="s1">return true</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* @param {MemberExpression} node</span><span class="s3">\n         </span><span class="s1">* @param {HasSideEffectOptions} options</span><span class="s3">\n         </span><span class="s1">* @param {Record&lt;string, string[]&gt;} visitorKeys</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">MemberExpression(node, options, visitorKeys) {</span><span class="s3">\n            </span><span class="s1">if (options.considerGetters) {</span><span class="s3">\n                </span><span class="s1">return true</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (</span><span class="s3">\n                </span><span class="s1">options.considerImplicitTypeConversion &amp;&amp;</span><span class="s3">\n                </span><span class="s1">node.computed &amp;&amp;</span><span class="s3">\n                </span><span class="s1">node.property.type !== </span><span class="s3">\&quot;</span><span class="s1">Literal</span><span class="s3">\&quot;\n            </span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">return true</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return this.$visitChildren(node, options, visitorKeys)</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* @param {MethodDefinition} node</span><span class="s3">\n         </span><span class="s1">* @param {HasSideEffectOptions} options</span><span class="s3">\n         </span><span class="s1">* @param {Record&lt;string, string[]&gt;} visitorKeys</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">MethodDefinition(node, options, visitorKeys) {</span><span class="s3">\n            </span><span class="s1">if (</span><span class="s3">\n                </span><span class="s1">options.considerImplicitTypeConversion &amp;&amp;</span><span class="s3">\n                </span><span class="s1">node.computed &amp;&amp;</span><span class="s3">\n                </span><span class="s1">node.key.type !== </span><span class="s3">\&quot;</span><span class="s1">Literal</span><span class="s3">\&quot;\n            </span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">return true</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return this.$visitChildren(node, options, visitorKeys)</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">NewExpression() {</span><span class="s3">\n            </span><span class="s1">return true</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* @param {Property} node</span><span class="s3">\n         </span><span class="s1">* @param {HasSideEffectOptions} options</span><span class="s3">\n         </span><span class="s1">* @param {Record&lt;string, string[]&gt;} visitorKeys</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">Property(node, options, visitorKeys) {</span><span class="s3">\n            </span><span class="s1">if (</span><span class="s3">\n                </span><span class="s1">options.considerImplicitTypeConversion &amp;&amp;</span><span class="s3">\n                </span><span class="s1">node.computed &amp;&amp;</span><span class="s3">\n                </span><span class="s1">node.key.type !== </span><span class="s3">\&quot;</span><span class="s1">Literal</span><span class="s3">\&quot;\n            </span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">return true</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return this.$visitChildren(node, options, visitorKeys)</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* @param {PropertyDefinition} node</span><span class="s3">\n         </span><span class="s1">* @param {HasSideEffectOptions} options</span><span class="s3">\n         </span><span class="s1">* @param {Record&lt;string, string[]&gt;} visitorKeys</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">PropertyDefinition(node, options, visitorKeys) {</span><span class="s3">\n            </span><span class="s1">if (</span><span class="s3">\n                </span><span class="s1">options.considerImplicitTypeConversion &amp;&amp;</span><span class="s3">\n                </span><span class="s1">node.computed &amp;&amp;</span><span class="s3">\n                </span><span class="s1">node.key.type !== </span><span class="s3">\&quot;</span><span class="s1">Literal</span><span class="s3">\&quot;\n            </span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">return true</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return this.$visitChildren(node, options, visitorKeys)</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* @param {UnaryExpression} node</span><span class="s3">\n         </span><span class="s1">* @param {HasSideEffectOptions} options</span><span class="s3">\n         </span><span class="s1">* @param {Record&lt;string, string[]&gt;} visitorKeys</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">UnaryExpression(node, options, visitorKeys) {</span><span class="s3">\n            </span><span class="s1">if (node.operator === </span><span class="s3">\&quot;</span><span class="s1">delete</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">return true</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (</span><span class="s3">\n                </span><span class="s1">options.considerImplicitTypeConversion &amp;&amp;</span><span class="s3">\n                </span><span class="s1">typeConversionUnaryOps.has(node.operator) &amp;&amp;</span><span class="s3">\n                </span><span class="s1">node.argument.type !== </span><span class="s3">\&quot;</span><span class="s1">Literal</span><span class="s3">\&quot;\n            </span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">return true</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return this.$visitChildren(node, options, visitorKeys)</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">UpdateExpression() {</span><span class="s3">\n            </span><span class="s1">return true</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">YieldExpression() {</span><span class="s3">\n            </span><span class="s1">return true</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">}),</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Check whether a given node has any side effect or not.</span><span class="s3">\n </span><span class="s1">* @param {Node} node The node to get.</span><span class="s3">\n </span><span class="s1">* @param {SourceCode} sourceCode The source code object.</span><span class="s3">\n </span><span class="s1">* @param {HasSideEffectOptions} [options] The option object.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} `true` if the node has a certain side effect.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function hasSideEffect(node, sourceCode, options = {}) {</span><span class="s3">\n    </span><span class="s1">const { considerGetters = false, considerImplicitTypeConversion = false } =</span><span class="s3">\n        </span><span class="s1">options</span><span class="s3">\n    </span><span class="s1">return visitor.$visit(</span><span class="s3">\n        </span><span class="s1">node,</span><span class="s3">\n        </span><span class="s1">{ considerGetters, considerImplicitTypeConversion },</span><span class="s3">\n        </span><span class="s1">sourceCode.visitorKeys || KEYS,</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { isClosingParenToken, isOpeningParenToken } from </span><span class="s3">\&quot;</span><span class="s1">./token-predicate.mjs</span><span class="s3">\&quot;\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).Node} Node */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">@typescript-eslint/types</span><span class="s3">\&quot;</span><span class="s1">).TSESTree.NewExpression} TSNewExpression */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">@typescript-eslint/types</span><span class="s3">\&quot;</span><span class="s1">).TSESTree.CallExpression} TSCallExpression */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">eslint</span><span class="s3">\&quot;</span><span class="s1">).SourceCode} SourceCode */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">eslint</span><span class="s3">\&quot;</span><span class="s1">).AST.Token} Token */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">eslint</span><span class="s3">\&quot;</span><span class="s1">).Rule.Node} RuleNode */</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Get the left parenthesis of the parent node syntax if it exists.</span><span class="s3">\n </span><span class="s1">* E.g., `if (a) {}` then the `(`.</span><span class="s3">\n </span><span class="s1">* @param {Node} node The AST node to check.</span><span class="s3">\n </span><span class="s1">* @param {SourceCode} sourceCode The source code object to get tokens.</span><span class="s3">\n </span><span class="s1">* @returns {Token|null} The left parenthesis of the parent node syntax</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">// eslint-disable-next-line complexity</span><span class="s3">\n</span><span class="s1">function getParentSyntaxParen(node, sourceCode) {</span><span class="s3">\n    </span><span class="s1">const parent = /** @type {RuleNode} */ (node).parent</span><span class="s3">\n\n    </span><span class="s1">switch (parent.type) {</span><span class="s3">\n        </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">CallExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">NewExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">if (parent.arguments.length === 1 &amp;&amp; parent.arguments[0] === node) {</span><span class="s3">\n                </span><span class="s1">return sourceCode.getTokenAfter(</span><span class="s3">\n                    </span><span class="s1">// @ts-expect-error https://github.com/typescript-eslint/typescript-eslint/pull/5384</span><span class="s3">\n                    </span><span class="s1">parent.typeArguments ||</span><span class="s3">\n                        </span><span class="s1">/** @type {RuleNode} */ (</span><span class="s3">\n                            </span><span class="s1">/** @type {unknown} */ (</span><span class="s3">\n                                </span><span class="s1">/** @type {TSNewExpression | TSCallExpression} */ (</span><span class="s3">\n                                    </span><span class="s1">parent</span><span class="s3">\n                                </span><span class="s1">).typeParameters</span><span class="s3">\n                            </span><span class="s1">)</span><span class="s3">\n                        </span><span class="s1">) ||</span><span class="s3">\n                        </span><span class="s1">parent.callee,</span><span class="s3">\n                    </span><span class="s1">isOpeningParenToken,</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return null</span><span class="s3">\n\n        </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">DoWhileStatement</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">if (parent.test === node) {</span><span class="s3">\n                </span><span class="s1">return sourceCode.getTokenAfter(</span><span class="s3">\n                    </span><span class="s1">parent.body,</span><span class="s3">\n                    </span><span class="s1">isOpeningParenToken,</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return null</span><span class="s3">\n\n        </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">IfStatement</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n        </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">WhileStatement</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">if (parent.test === node) {</span><span class="s3">\n                </span><span class="s1">return sourceCode.getFirstToken(parent, 1)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return null</span><span class="s3">\n\n        </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ImportExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">if (parent.source === node) {</span><span class="s3">\n                </span><span class="s1">return sourceCode.getFirstToken(parent, 1)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return null</span><span class="s3">\n\n        </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">SwitchStatement</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">if (parent.discriminant === node) {</span><span class="s3">\n                </span><span class="s1">return sourceCode.getFirstToken(parent, 1)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return null</span><span class="s3">\n\n        </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">WithStatement</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">if (parent.object === node) {</span><span class="s3">\n                </span><span class="s1">return sourceCode.getFirstToken(parent, 1)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return null</span><span class="s3">\n\n        </span><span class="s1">default:</span><span class="s3">\n            </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Check whether a given node is parenthesized or not.</span><span class="s3">\n </span><span class="s1">* @param {number} times The number of parantheses.</span><span class="s3">\n </span><span class="s1">* @param {Node} node The AST node to check.</span><span class="s3">\n </span><span class="s1">* @param {SourceCode} sourceCode The source code object to get tokens.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} `true` if the node is parenthesized the given times.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Check whether a given node is parenthesized or not.</span><span class="s3">\n </span><span class="s1">* @param {Node} node The AST node to check.</span><span class="s3">\n </span><span class="s1">* @param {SourceCode} sourceCode The source code object to get tokens.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} `true` if the node is parenthesized.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Check whether a given node is parenthesized or not.</span><span class="s3">\n </span><span class="s1">* @param {Node|number} timesOrNode The first parameter.</span><span class="s3">\n </span><span class="s1">* @param {Node|SourceCode} nodeOrSourceCode The second parameter.</span><span class="s3">\n </span><span class="s1">* @param {SourceCode} [optionalSourceCode] The third parameter.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} `true` if the node is parenthesized.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isParenthesized(</span><span class="s3">\n    </span><span class="s1">timesOrNode,</span><span class="s3">\n    </span><span class="s1">nodeOrSourceCode,</span><span class="s3">\n    </span><span class="s1">optionalSourceCode,</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">/** @type {number} */</span><span class="s3">\n    </span><span class="s1">let times,</span><span class="s3">\n        </span><span class="s1">/** @type {RuleNode} */</span><span class="s3">\n        </span><span class="s1">node,</span><span class="s3">\n        </span><span class="s1">/** @type {SourceCode} */</span><span class="s3">\n        </span><span class="s1">sourceCode,</span><span class="s3">\n        </span><span class="s1">maybeLeftParen,</span><span class="s3">\n        </span><span class="s1">maybeRightParen</span><span class="s3">\n    </span><span class="s1">if (typeof timesOrNode === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">times = timesOrNode | 0</span><span class="s3">\n        </span><span class="s1">node = /** @type {RuleNode} */ (nodeOrSourceCode)</span><span class="s3">\n        </span><span class="s1">sourceCode = /** @type {SourceCode} */ (optionalSourceCode)</span><span class="s3">\n        </span><span class="s1">if (!(times &gt;= 1)) {</span><span class="s3">\n            </span><span class="s1">throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">'times' should be a positive integer.</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">times = 1</span><span class="s3">\n        </span><span class="s1">node = /** @type {RuleNode} */ (timesOrNode)</span><span class="s3">\n        </span><span class="s1">sourceCode = /** @type {SourceCode} */ (nodeOrSourceCode)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">node == null ||</span><span class="s3">\n        </span><span class="s1">// `Program` can't be parenthesized</span><span class="s3">\n        </span><span class="s1">node.parent == null ||</span><span class="s3">\n        </span><span class="s1">// `CatchClause.param` can't be parenthesized, example `try {} catch (error) {}`</span><span class="s3">\n        </span><span class="s1">(node.parent.type === </span><span class="s3">\&quot;</span><span class="s1">CatchClause</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; node.parent.param === node)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">maybeLeftParen = maybeRightParen = node</span><span class="s3">\n    </span><span class="s1">do {</span><span class="s3">\n        </span><span class="s1">maybeLeftParen = sourceCode.getTokenBefore(maybeLeftParen)</span><span class="s3">\n        </span><span class="s1">maybeRightParen = sourceCode.getTokenAfter(maybeRightParen)</span><span class="s3">\n    </span><span class="s1">} while (</span><span class="s3">\n        </span><span class="s1">maybeLeftParen != null &amp;&amp;</span><span class="s3">\n        </span><span class="s1">maybeRightParen != null &amp;&amp;</span><span class="s3">\n        </span><span class="s1">isOpeningParenToken(maybeLeftParen) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">isClosingParenToken(maybeRightParen) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">// Avoid false positive such as `if (a) {}`</span><span class="s3">\n        </span><span class="s1">maybeLeftParen !== getParentSyntaxParen(node, sourceCode) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">--times &gt; 0</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">return times === 0</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* @author Toru Nagashima &lt;https://github.com/mysticatea&gt;</span><span class="s3">\n </span><span class="s1">* See LICENSE file in root directory for full license.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">const placeholder = /</span><span class="s3">\\</span><span class="s1">$(?:[$&amp;`']|[1-9][0-9]?)/gu</span><span class="s3">\n\n</span><span class="s1">/** @type {WeakMap&lt;PatternMatcher, {pattern:RegExp,escaped:boolean}&gt;} */</span><span class="s3">\n</span><span class="s1">const internal = new WeakMap()</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Check whether a given character is escaped or not.</span><span class="s3">\n </span><span class="s1">* @param {string} str The string to check.</span><span class="s3">\n </span><span class="s1">* @param {number} index The location of the character to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} `true` if the character is escaped.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isEscaped(str, index) {</span><span class="s3">\n    </span><span class="s1">let escaped = false</span><span class="s3">\n    </span><span class="s1">for (let i = index - 1; i &gt;= 0 &amp;&amp; str.charCodeAt(i) === 0x5c; --i) {</span><span class="s3">\n        </span><span class="s1">escaped = !escaped</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return escaped</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Replace a given string by a given matcher.</span><span class="s3">\n </span><span class="s1">* @param {PatternMatcher} matcher The pattern matcher.</span><span class="s3">\n </span><span class="s1">* @param {string} str The string to be replaced.</span><span class="s3">\n </span><span class="s1">* @param {string} replacement The new substring to replace each matched part.</span><span class="s3">\n </span><span class="s1">* @returns {string} The replaced string.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function replaceS(matcher, str, replacement) {</span><span class="s3">\n    </span><span class="s1">const chunks = []</span><span class="s3">\n    </span><span class="s1">let index = 0</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @param {string} key The placeholder.</span><span class="s3">\n     </span><span class="s1">* @param {RegExpExecArray} match The matched information.</span><span class="s3">\n     </span><span class="s1">* @returns {string} The replaced string.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function replacer(key, match) {</span><span class="s3">\n        </span><span class="s1">switch (key) {</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">$$</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">$</span><span class="s3">\&quot;\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">$&amp;</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">return match[0]</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">$`</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">return str.slice(0, match.index)</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">$'</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">return str.slice(match.index + match[0].length)</span><span class="s3">\n            </span><span class="s1">default: {</span><span class="s3">\n                </span><span class="s1">const i = key.slice(1)</span><span class="s3">\n                </span><span class="s1">if (i in match) {</span><span class="s3">\n                    </span><span class="s1">return match[/** @type {any} */ (i)]</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">return key</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (const match of matcher.execAll(str)) {</span><span class="s3">\n        </span><span class="s1">chunks.push(str.slice(index, match.index))</span><span class="s3">\n        </span><span class="s1">chunks.push(</span><span class="s3">\n            </span><span class="s1">replacement.replace(placeholder, (key) =&gt; replacer(key, match)),</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">index = match.index + match[0].length</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">chunks.push(str.slice(index))</span><span class="s3">\n\n    </span><span class="s1">return chunks.join(</span><span class="s3">\&quot;\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Replace a given string by a given matcher.</span><span class="s3">\n </span><span class="s1">* @param {PatternMatcher} matcher The pattern matcher.</span><span class="s3">\n </span><span class="s1">* @param {string} str The string to be replaced.</span><span class="s3">\n </span><span class="s1">* @param {(substring: string, ...args: any[]) =&gt; string} replace The function to replace each matched part.</span><span class="s3">\n </span><span class="s1">* @returns {string} The replaced string.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function replaceF(matcher, str, replace) {</span><span class="s3">\n    </span><span class="s1">const chunks = []</span><span class="s3">\n    </span><span class="s1">let index = 0</span><span class="s3">\n\n    </span><span class="s1">for (const match of matcher.execAll(str)) {</span><span class="s3">\n        </span><span class="s1">chunks.push(str.slice(index, match.index))</span><span class="s3">\n        </span><span class="s1">chunks.push(</span><span class="s3">\n            </span><span class="s1">String(</span><span class="s3">\n                </span><span class="s1">replace(</span><span class="s3">\n                    </span><span class="s1">.../** @type {[string, ...string[]]} */ (</span><span class="s3">\n                        </span><span class="s1">/** @type {string[]} */ (match)</span><span class="s3">\n                    </span><span class="s1">),</span><span class="s3">\n                    </span><span class="s1">match.index,</span><span class="s3">\n                    </span><span class="s1">match.input,</span><span class="s3">\n                </span><span class="s1">),</span><span class="s3">\n            </span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">index = match.index + match[0].length</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">chunks.push(str.slice(index))</span><span class="s3">\n\n    </span><span class="s1">return chunks.join(</span><span class="s3">\&quot;\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The class to find patterns as considering escape sequences.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class PatternMatcher {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Initialize this matcher.</span><span class="s3">\n     </span><span class="s1">* @param {RegExp} pattern The pattern to match.</span><span class="s3">\n     </span><span class="s1">* @param {{escaped?:boolean}} [options] The options.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(pattern, options = {}) {</span><span class="s3">\n        </span><span class="s1">const { escaped = false } = options</span><span class="s3">\n        </span><span class="s1">if (!(pattern instanceof RegExp)) {</span><span class="s3">\n            </span><span class="s1">throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">'pattern' should be a RegExp instance.</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!pattern.flags.includes(</span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">'pattern' should contains 'g' flag.</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">internal.set(this, {</span><span class="s3">\n            </span><span class="s1">pattern: new RegExp(pattern.source, pattern.flags),</span><span class="s3">\n            </span><span class="s1">escaped: Boolean(escaped),</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Find the pattern in a given string.</span><span class="s3">\n     </span><span class="s1">* @param {string} str The string to find.</span><span class="s3">\n     </span><span class="s1">* @returns {IterableIterator&lt;RegExpExecArray&gt;} The iterator which iterate the matched information.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">*execAll(str) {</span><span class="s3">\n        </span><span class="s1">const { pattern, escaped } =</span><span class="s3">\n            </span><span class="s1">/** @type {{pattern:RegExp,escaped:boolean}} */ (internal.get(this))</span><span class="s3">\n        </span><span class="s1">let match = null</span><span class="s3">\n        </span><span class="s1">let lastIndex = 0</span><span class="s3">\n\n        </span><span class="s1">pattern.lastIndex = 0</span><span class="s3">\n        </span><span class="s1">while ((match = pattern.exec(str)) != null) {</span><span class="s3">\n            </span><span class="s1">if (escaped || !isEscaped(str, match.index)) {</span><span class="s3">\n                </span><span class="s1">lastIndex = pattern.lastIndex</span><span class="s3">\n                </span><span class="s1">yield match</span><span class="s3">\n                </span><span class="s1">pattern.lastIndex = lastIndex</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Check whether the pattern is found in a given string.</span><span class="s3">\n     </span><span class="s1">* @param {string} str The string to check.</span><span class="s3">\n     </span><span class="s1">* @returns {boolean} `true` if the pattern was found in the string.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">test(str) {</span><span class="s3">\n        </span><span class="s1">const it = this.execAll(str)</span><span class="s3">\n        </span><span class="s1">const ret = it.next()</span><span class="s3">\n        </span><span class="s1">return !ret.done</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Replace a given string.</span><span class="s3">\n     </span><span class="s1">* @param {string} str The string to be replaced.</span><span class="s3">\n     </span><span class="s1">* @param {(string|((...strs:string[])=&gt;string))} replacer The string or function to replace. This is the same as the 2nd argument of `String.prototype.replace`.</span><span class="s3">\n     </span><span class="s1">* @returns {string} The replaced string.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">[Symbol.replace](str, replacer) {</span><span class="s3">\n        </span><span class="s1">return typeof replacer === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;\n            </span><span class="s1">? replaceF(this, String(str), replacer)</span><span class="s3">\n            </span><span class="s1">: replaceS(this, String(str), String(replacer))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { findVariable } from </span><span class="s3">\&quot;</span><span class="s1">./find-variable.mjs</span><span class="s3">\&quot;\n</span><span class="s1">import { getPropertyName } from </span><span class="s3">\&quot;</span><span class="s1">./get-property-name.mjs</span><span class="s3">\&quot;\n</span><span class="s1">import { getStringIfConstant } from </span><span class="s3">\&quot;</span><span class="s1">./get-string-if-constant.mjs</span><span class="s3">\&quot;\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">eslint</span><span class="s3">\&quot;</span><span class="s1">).Scope.Scope} Scope */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">eslint</span><span class="s3">\&quot;</span><span class="s1">).Scope.Variable} Variable */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">eslint</span><span class="s3">\&quot;</span><span class="s1">).Rule.Node} RuleNode */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).Node} Node */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).Expression} Expression */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).Pattern} Pattern */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).Identifier} Identifier */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).SimpleCallExpression} CallExpression */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).Program} Program */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).ImportDeclaration} ImportDeclaration */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).ExportAllDeclaration} ExportAllDeclaration */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).ExportDefaultDeclaration} ExportDefaultDeclaration */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).ExportNamedDeclaration} ExportNamedDeclaration */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).ImportSpecifier} ImportSpecifier */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).ImportDefaultSpecifier} ImportDefaultSpecifier */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).ImportNamespaceSpecifier} ImportNamespaceSpecifier */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).ExportSpecifier} ExportSpecifier */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).Property} Property */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).AssignmentProperty} AssignmentProperty */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">estree</span><span class="s3">\&quot;</span><span class="s1">).Literal} Literal */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">@typescript-eslint/types</span><span class="s3">\&quot;</span><span class="s1">).TSESTree.Node} TSESTreeNode */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">./types.mjs</span><span class="s3">\&quot;</span><span class="s1">).ReferenceTrackerOptions} ReferenceTrackerOptions */</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template T</span><span class="s3">\n </span><span class="s1">* @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">./types.mjs</span><span class="s3">\&quot;</span><span class="s1">).TraceMap&lt;T&gt;} TraceMap</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template T</span><span class="s3">\n </span><span class="s1">* @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">./types.mjs</span><span class="s3">\&quot;</span><span class="s1">).TraceMapObject&lt;T&gt;} TraceMapObject</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template T</span><span class="s3">\n </span><span class="s1">* @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">./types.mjs</span><span class="s3">\&quot;</span><span class="s1">).TrackedReferences&lt;T&gt;} TrackedReferences</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">const IMPORT_TYPE = /^(?:Import|Export(?:All|Default|Named))Declaration$/u</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Check whether a given node is an import node or not.</span><span class="s3">\n </span><span class="s1">* @param {Node} node</span><span class="s3">\n </span><span class="s1">* @returns {node is ImportDeclaration|ExportAllDeclaration|ExportNamedDeclaration&amp;{source: Literal}} `true` if the node is an import node.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isHasSource(node) {</span><span class="s3">\n    </span><span class="s1">return (</span><span class="s3">\n        </span><span class="s1">IMPORT_TYPE.test(node.type) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">/** @type {ImportDeclaration|ExportAllDeclaration|ExportNamedDeclaration} */ (</span><span class="s3">\n            </span><span class="s1">node</span><span class="s3">\n        </span><span class="s1">).source != null</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const has =</span><span class="s3">\n    </span><span class="s1">/** @type {&lt;T&gt;(traceMap: TraceMap&lt;unknown&gt;, v: T) =&gt; v is (string extends T ? string : T)} */ (</span><span class="s3">\n        </span><span class="s1">Function.call.bind(Object.hasOwnProperty)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n</span><span class="s1">export const READ = Symbol(</span><span class="s3">\&quot;</span><span class="s1">read</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">export const CALL = Symbol(</span><span class="s3">\&quot;</span><span class="s1">call</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">export const CONSTRUCT = Symbol(</span><span class="s3">\&quot;</span><span class="s1">construct</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">export const ESM = Symbol(</span><span class="s3">\&quot;</span><span class="s1">esm</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n\n</span><span class="s1">const requireCall = { require: { [CALL]: true } }</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Check whether a given variable is modified or not.</span><span class="s3">\n </span><span class="s1">* @param {Variable|undefined} variable The variable to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} `true` if the variable is modified.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isModifiedGlobal(variable) {</span><span class="s3">\n    </span><span class="s1">return (</span><span class="s3">\n        </span><span class="s1">variable == null ||</span><span class="s3">\n        </span><span class="s1">variable.defs.length !== 0 ||</span><span class="s3">\n        </span><span class="s1">variable.references.some((r) =&gt; r.isWrite())</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Check if the value of a given node is passed through to the parent syntax as-is.</span><span class="s3">\n </span><span class="s1">* For example, `a` and `b` in (`a || b` and `c ? a : b`) are passed through.</span><span class="s3">\n </span><span class="s1">* @param {Node} node A node to check.</span><span class="s3">\n </span><span class="s1">* @returns {node is RuleNode &amp; {parent: Expression}} `true` if the node is passed through.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isPassThrough(node) {</span><span class="s3">\n    </span><span class="s1">const parent = /** @type {TSESTreeNode} */ (node).parent</span><span class="s3">\n\n    </span><span class="s1">if (parent) {</span><span class="s3">\n        </span><span class="s1">switch (parent.type) {</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ConditionalExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">return parent.consequent === node || parent.alternate === node</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">LogicalExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">return true</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">SequenceExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">return (</span><span class="s3">\n                    </span><span class="s1">parent.expressions[parent.expressions.length - 1] === node</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">ChainExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">return true</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">TSAsExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">TSSatisfiesExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">TSTypeAssertion</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">TSNonNullExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">TSInstantiationExpression</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">return true</span><span class="s3">\n\n            </span><span class="s1">default:</span><span class="s3">\n                </span><span class="s1">return false</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The reference tracker.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class ReferenceTracker {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Initialize this tracker.</span><span class="s3">\n     </span><span class="s1">* @param {Scope} globalScope The global scope.</span><span class="s3">\n     </span><span class="s1">* @param {object} [options] The options.</span><span class="s3">\n     </span><span class="s1">* @param {</span><span class="s3">\&quot;</span><span class="s1">legacy</span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot;</span><span class="s1">strict</span><span class="s3">\&quot;</span><span class="s1">} [options.mode=</span><span class="s3">\&quot;</span><span class="s1">strict</span><span class="s3">\&quot;</span><span class="s1">] The mode to determine the ImportDeclaration's behavior for CJS modules.</span><span class="s3">\n     </span><span class="s1">* @param {string[]} [options.globalObjectNames=[</span><span class="s3">\&quot;</span><span class="s1">global</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">globalThis</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">self</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">window</span><span class="s3">\&quot;</span><span class="s1">]] The variable names for Global Object.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(globalScope, options = {}) {</span><span class="s3">\n        </span><span class="s1">const {</span><span class="s3">\n            </span><span class="s1">mode = </span><span class="s3">\&quot;</span><span class="s1">strict</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">globalObjectNames = [</span><span class="s3">\&quot;</span><span class="s1">global</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">globalThis</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">self</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">window</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n        </span><span class="s1">} = options</span><span class="s3">\n        </span><span class="s1">/** @private @type {Variable[]} */</span><span class="s3">\n        </span><span class="s1">this.variableStack = []</span><span class="s3">\n        </span><span class="s1">/** @private */</span><span class="s3">\n        </span><span class="s1">this.globalScope = globalScope</span><span class="s3">\n        </span><span class="s1">/** @private */</span><span class="s3">\n        </span><span class="s1">this.mode = mode</span><span class="s3">\n        </span><span class="s1">/** @private */</span><span class="s3">\n        </span><span class="s1">this.globalObjectNames = globalObjectNames.slice(0)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Iterate the references of global variables.</span><span class="s3">\n     </span><span class="s1">* @template T</span><span class="s3">\n     </span><span class="s1">* @param {TraceMap&lt;T&gt;} traceMap The trace map.</span><span class="s3">\n     </span><span class="s1">* @returns {IterableIterator&lt;TrackedReferences&lt;T&gt;&gt;} The iterator to iterate references.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">*iterateGlobalReferences(traceMap) {</span><span class="s3">\n        </span><span class="s1">for (const key of Object.keys(traceMap)) {</span><span class="s3">\n            </span><span class="s1">const nextTraceMap = traceMap[key]</span><span class="s3">\n            </span><span class="s1">const path = [key]</span><span class="s3">\n            </span><span class="s1">const variable = this.globalScope.set.get(key)</span><span class="s3">\n\n            </span><span class="s1">if (isModifiedGlobal(variable)) {</span><span class="s3">\n                </span><span class="s1">continue</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">yield* this._iterateVariableReferences(</span><span class="s3">\n                </span><span class="s1">/** @type {Variable} */ (variable),</span><span class="s3">\n                </span><span class="s1">path,</span><span class="s3">\n                </span><span class="s1">nextTraceMap,</span><span class="s3">\n                </span><span class="s1">true,</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">for (const key of this.globalObjectNames) {</span><span class="s3">\n            </span><span class="s1">/** @type {string[]} */</span><span class="s3">\n            </span><span class="s1">const path = []</span><span class="s3">\n            </span><span class="s1">const variable = this.globalScope.set.get(key)</span><span class="s3">\n\n            </span><span class="s1">if (isModifiedGlobal(variable)) {</span><span class="s3">\n                </span><span class="s1">continue</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">yield* this._iterateVariableReferences(</span><span class="s3">\n                </span><span class="s1">/** @type {Variable} */ (variable),</span><span class="s3">\n                </span><span class="s1">path,</span><span class="s3">\n                </span><span class="s1">traceMap,</span><span class="s3">\n                </span><span class="s1">false,</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Iterate the references of CommonJS modules.</span><span class="s3">\n     </span><span class="s1">* @template T</span><span class="s3">\n     </span><span class="s1">* @param {TraceMap&lt;T&gt;} traceMap The trace map.</span><span class="s3">\n     </span><span class="s1">* @returns {IterableIterator&lt;TrackedReferences&lt;T&gt;&gt;} The iterator to iterate references.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">*iterateCjsReferences(traceMap) {</span><span class="s3">\n        </span><span class="s1">for (const { node } of this.iterateGlobalReferences(requireCall)) {</span><span class="s3">\n            </span><span class="s1">const key = getStringIfConstant(</span><span class="s3">\n                </span><span class="s1">/** @type {CallExpression} */ (node).arguments[0],</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">if (key == null || !has(traceMap, key)) {</span><span class="s3">\n                </span><span class="s1">continue</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">const nextTraceMap = traceMap[key]</span><span class="s3">\n            </span><span class="s1">const path = [key]</span><span class="s3">\n\n            </span><span class="s1">if (nextTraceMap[READ]) {</span><span class="s3">\n                </span><span class="s1">yield {</span><span class="s3">\n                    </span><span class="s1">node,</span><span class="s3">\n                    </span><span class="s1">path,</span><span class="s3">\n                    </span><span class="s1">type: READ,</span><span class="s3">\n                    </span><span class="s1">info: nextTraceMap[READ],</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">yield* this._iteratePropertyReferences(</span><span class="s3">\n                </span><span class="s1">/** @type {CallExpression} */ (node),</span><span class="s3">\n                </span><span class="s1">path,</span><span class="s3">\n                </span><span class="s1">nextTraceMap,</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Iterate the references of ES modules.</span><span class="s3">\n     </span><span class="s1">* @template T</span><span class="s3">\n     </span><span class="s1">* @param {TraceMap&lt;T&gt;} traceMap The trace map.</span><span class="s3">\n     </span><span class="s1">* @returns {IterableIterator&lt;TrackedReferences&lt;T&gt;&gt;} The iterator to iterate references.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">*iterateEsmReferences(traceMap) {</span><span class="s3">\n        </span><span class="s1">const programNode = /** @type {Program} */ (this.globalScope.block)</span><span class="s3">\n\n        </span><span class="s1">for (const node of programNode.body) {</span><span class="s3">\n            </span><span class="s1">if (!isHasSource(node)) {</span><span class="s3">\n                </span><span class="s1">continue</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const moduleId = /** @type {string} */ (node.source.value)</span><span class="s3">\n\n            </span><span class="s1">if (!has(traceMap, moduleId)) {</span><span class="s3">\n                </span><span class="s1">continue</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const nextTraceMap = traceMap[moduleId]</span><span class="s3">\n            </span><span class="s1">const path = [moduleId]</span><span class="s3">\n\n            </span><span class="s1">if (nextTraceMap[READ]) {</span><span class="s3">\n                </span><span class="s1">yield {</span><span class="s3">\n                    </span><span class="s1">// eslint-disable-next-line object-shorthand -- apply type</span><span class="s3">\n                    </span><span class="s1">node: /** @type {RuleNode} */ (node),</span><span class="s3">\n                    </span><span class="s1">path,</span><span class="s3">\n                    </span><span class="s1">type: READ,</span><span class="s3">\n                    </span><span class="s1">info: nextTraceMap[READ],</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">if (node.type === </span><span class="s3">\&quot;</span><span class="s1">ExportAllDeclaration</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">for (const key of Object.keys(nextTraceMap)) {</span><span class="s3">\n                    </span><span class="s1">const exportTraceMap = nextTraceMap[key]</span><span class="s3">\n                    </span><span class="s1">if (exportTraceMap[READ]) {</span><span class="s3">\n                        </span><span class="s1">yield {</span><span class="s3">\n                            </span><span class="s1">// eslint-disable-next-line object-shorthand -- apply type</span><span class="s3">\n                            </span><span class="s1">node: /** @type {RuleNode} */ (node),</span><span class="s3">\n                            </span><span class="s1">path: path.concat(key),</span><span class="s3">\n                            </span><span class="s1">type: READ,</span><span class="s3">\n                            </span><span class="s1">info: exportTraceMap[READ],</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n                </span><span class="s1">for (const specifier of node.specifiers) {</span><span class="s3">\n                    </span><span class="s1">const esm = has(nextTraceMap, ESM)</span><span class="s3">\n                    </span><span class="s1">const it = this._iterateImportReferences(</span><span class="s3">\n                        </span><span class="s1">specifier,</span><span class="s3">\n                        </span><span class="s1">path,</span><span class="s3">\n                        </span><span class="s1">esm</span><span class="s3">\n                            </span><span class="s1">? nextTraceMap</span><span class="s3">\n                            </span><span class="s1">: this.mode === </span><span class="s3">\&quot;</span><span class="s1">legacy</span><span class="s3">\&quot;\n                            </span><span class="s1">? { default: nextTraceMap, ...nextTraceMap }</span><span class="s3">\n                            </span><span class="s1">: { default: nextTraceMap },</span><span class="s3">\n                    </span><span class="s1">)</span><span class="s3">\n\n                    </span><span class="s1">if (esm) {</span><span class="s3">\n                        </span><span class="s1">yield* it</span><span class="s3">\n                    </span><span class="s1">} else {</span><span class="s3">\n                        </span><span class="s1">for (const report of it) {</span><span class="s3">\n                            </span><span class="s1">report.path = report.path.filter(exceptDefault)</span><span class="s3">\n                            </span><span class="s1">if (</span><span class="s3">\n                                </span><span class="s1">report.path.length &gt;= 2 ||</span><span class="s3">\n                                </span><span class="s1">report.type !== READ</span><span class="s3">\n                            </span><span class="s1">) {</span><span class="s3">\n                                </span><span class="s1">yield report</span><span class="s3">\n                            </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Iterate the property references for a given expression AST node.</span><span class="s3">\n     </span><span class="s1">* @template T</span><span class="s3">\n     </span><span class="s1">* @param {Expression} node The expression AST node to iterate property references.</span><span class="s3">\n     </span><span class="s1">* @param {TraceMap&lt;T&gt;} traceMap The trace map.</span><span class="s3">\n     </span><span class="s1">* @returns {IterableIterator&lt;TrackedReferences&lt;T&gt;&gt;} The iterator to iterate property references.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">*iteratePropertyReferences(node, traceMap) {</span><span class="s3">\n        </span><span class="s1">yield* this._iteratePropertyReferences(node, [], traceMap)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Iterate the references for a given variable.</span><span class="s3">\n     </span><span class="s1">* @private</span><span class="s3">\n     </span><span class="s1">* @template T</span><span class="s3">\n     </span><span class="s1">* @param {Variable} variable The variable to iterate that references.</span><span class="s3">\n     </span><span class="s1">* @param {string[]} path The current path.</span><span class="s3">\n     </span><span class="s1">* @param {TraceMapObject&lt;T&gt;} traceMap The trace map.</span><span class="s3">\n     </span><span class="s1">* @param {boolean} shouldReport = The flag to report those references.</span><span class="s3">\n     </span><span class="s1">* @returns {IterableIterator&lt;TrackedReferences&lt;T&gt;&gt;} The iterator to iterate references.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">*_iterateVariableReferences(variable, path, traceMap, shouldReport) {</span><span class="s3">\n        </span><span class="s1">if (this.variableStack.includes(variable)) {</span><span class="s3">\n            </span><span class="s1">return</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.variableStack.push(variable)</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">for (const reference of variable.references) {</span><span class="s3">\n                </span><span class="s1">if (!reference.isRead()) {</span><span class="s3">\n                    </span><span class="s1">continue</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">const node = /** @type {RuleNode &amp; Identifier} */ (</span><span class="s3">\n                    </span><span class="s1">reference.identifier</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n\n                </span><span class="s1">if (shouldReport &amp;&amp; traceMap[READ]) {</span><span class="s3">\n                    </span><span class="s1">yield { node, path, type: READ, info: traceMap[READ] }</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">yield* this._iteratePropertyReferences(node, path, traceMap)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} finally {</span><span class="s3">\n            </span><span class="s1">this.variableStack.pop()</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Iterate the references for a given AST node.</span><span class="s3">\n     </span><span class="s1">* @private</span><span class="s3">\n     </span><span class="s1">* @template T</span><span class="s3">\n     </span><span class="s1">* @param {Expression} rootNode The AST node to iterate references.</span><span class="s3">\n     </span><span class="s1">* @param {string[]} path The current path.</span><span class="s3">\n     </span><span class="s1">* @param {TraceMapObject&lt;T&gt;} traceMap The trace map.</span><span class="s3">\n     </span><span class="s1">* @returns {IterableIterator&lt;TrackedReferences&lt;T&gt;&gt;} The iterator to iterate references.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">//eslint-disable-next-line complexity</span><span class="s3">\n    </span><span class="s1">*_iteratePropertyReferences(rootNode, path, traceMap) {</span><span class="s3">\n        </span><span class="s1">let node = rootNode</span><span class="s3">\n        </span><span class="s1">while (isPassThrough(node)) {</span><span class="s3">\n            </span><span class="s1">node = node.parent</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">const parent = /** @type {RuleNode} */ (node).parent</span><span class="s3">\n        </span><span class="s1">if (parent.type === </span><span class="s3">\&quot;</span><span class="s1">MemberExpression</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">if (parent.object === node) {</span><span class="s3">\n                </span><span class="s1">const key = getPropertyName(parent)</span><span class="s3">\n                </span><span class="s1">if (key == null || !has(traceMap, key)) {</span><span class="s3">\n                    </span><span class="s1">return</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n\n                </span><span class="s1">path = path.concat(key) //eslint-disable-line no-param-reassign</span><span class="s3">\n                </span><span class="s1">const nextTraceMap = traceMap[key]</span><span class="s3">\n                </span><span class="s1">if (nextTraceMap[READ]) {</span><span class="s3">\n                    </span><span class="s1">yield {</span><span class="s3">\n                        </span><span class="s1">node: parent,</span><span class="s3">\n                        </span><span class="s1">path,</span><span class="s3">\n                        </span><span class="s1">type: READ,</span><span class="s3">\n                        </span><span class="s1">info: nextTraceMap[READ],</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">yield* this._iteratePropertyReferences(</span><span class="s3">\n                    </span><span class="s1">parent,</span><span class="s3">\n                    </span><span class="s1">path,</span><span class="s3">\n                    </span><span class="s1">nextTraceMap,</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (parent.type === </span><span class="s3">\&quot;</span><span class="s1">CallExpression</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">if (parent.callee === node &amp;&amp; traceMap[CALL]) {</span><span class="s3">\n                </span><span class="s1">yield { node: parent, path, type: CALL, info: traceMap[CALL] }</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (parent.type === </span><span class="s3">\&quot;</span><span class="s1">NewExpression</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">if (parent.callee === node &amp;&amp; traceMap[CONSTRUCT]) {</span><span class="s3">\n                </span><span class="s1">yield {</span><span class="s3">\n                    </span><span class="s1">node: parent,</span><span class="s3">\n                    </span><span class="s1">path,</span><span class="s3">\n                    </span><span class="s1">type: CONSTRUCT,</span><span class="s3">\n                    </span><span class="s1">info: traceMap[CONSTRUCT],</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (parent.type === </span><span class="s3">\&quot;</span><span class="s1">AssignmentExpression</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">if (parent.right === node) {</span><span class="s3">\n                </span><span class="s1">yield* this._iterateLhsReferences(parent.left, path, traceMap)</span><span class="s3">\n                </span><span class="s1">yield* this._iteratePropertyReferences(parent, path, traceMap)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (parent.type === </span><span class="s3">\&quot;</span><span class="s1">AssignmentPattern</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">if (parent.right === node) {</span><span class="s3">\n                </span><span class="s1">yield* this._iterateLhsReferences(parent.left, path, traceMap)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (parent.type === </span><span class="s3">\&quot;</span><span class="s1">VariableDeclarator</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">if (parent.init === node) {</span><span class="s3">\n                </span><span class="s1">yield* this._iterateLhsReferences(parent.id, path, traceMap)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Iterate the references for a given Pattern node.</span><span class="s3">\n     </span><span class="s1">* @private</span><span class="s3">\n     </span><span class="s1">* @template T</span><span class="s3">\n     </span><span class="s1">* @param {Pattern} patternNode The Pattern node to iterate references.</span><span class="s3">\n     </span><span class="s1">* @param {string[]} path The current path.</span><span class="s3">\n     </span><span class="s1">* @param {TraceMapObject&lt;T&gt;} traceMap The trace map.</span><span class="s3">\n     </span><span class="s1">* @returns {IterableIterator&lt;TrackedReferences&lt;T&gt;&gt;} The iterator to iterate references.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">*_iterateLhsReferences(patternNode, path, traceMap) {</span><span class="s3">\n        </span><span class="s1">if (patternNode.type === </span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">const variable = findVariable(this.globalScope, patternNode)</span><span class="s3">\n            </span><span class="s1">if (variable != null) {</span><span class="s3">\n                </span><span class="s1">yield* this._iterateVariableReferences(</span><span class="s3">\n                    </span><span class="s1">variable,</span><span class="s3">\n                    </span><span class="s1">path,</span><span class="s3">\n                    </span><span class="s1">traceMap,</span><span class="s3">\n                    </span><span class="s1">false,</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (patternNode.type === </span><span class="s3">\&quot;</span><span class="s1">ObjectPattern</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">for (const property of patternNode.properties) {</span><span class="s3">\n                </span><span class="s1">const key = getPropertyName(</span><span class="s3">\n                    </span><span class="s1">/** @type {AssignmentProperty} */ (property),</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n\n                </span><span class="s1">if (key == null || !has(traceMap, key)) {</span><span class="s3">\n                    </span><span class="s1">continue</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n\n                </span><span class="s1">const nextPath = path.concat(key)</span><span class="s3">\n                </span><span class="s1">const nextTraceMap = traceMap[key]</span><span class="s3">\n                </span><span class="s1">if (nextTraceMap[READ]) {</span><span class="s3">\n                    </span><span class="s1">yield {</span><span class="s3">\n                        </span><span class="s1">node: /** @type {RuleNode} */ (property),</span><span class="s3">\n                        </span><span class="s1">path: nextPath,</span><span class="s3">\n                        </span><span class="s1">type: READ,</span><span class="s3">\n                        </span><span class="s1">info: nextTraceMap[READ],</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">yield* this._iterateLhsReferences(</span><span class="s3">\n                    </span><span class="s1">/** @type {AssignmentProperty} */ (property).value,</span><span class="s3">\n                    </span><span class="s1">nextPath,</span><span class="s3">\n                    </span><span class="s1">nextTraceMap,</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (patternNode.type === </span><span class="s3">\&quot;</span><span class="s1">AssignmentPattern</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">yield* this._iterateLhsReferences(patternNode.left, path, traceMap)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Iterate the references for a given ModuleSpecifier node.</span><span class="s3">\n     </span><span class="s1">* @private</span><span class="s3">\n     </span><span class="s1">* @template T</span><span class="s3">\n     </span><span class="s1">* @param {ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier | ExportSpecifier} specifierNode The ModuleSpecifier node to iterate references.</span><span class="s3">\n     </span><span class="s1">* @param {string[]} path The current path.</span><span class="s3">\n     </span><span class="s1">* @param {TraceMapObject&lt;T&gt;} traceMap The trace map.</span><span class="s3">\n     </span><span class="s1">* @returns {IterableIterator&lt;TrackedReferences&lt;T&gt;&gt;} The iterator to iterate references.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">*_iterateImportReferences(specifierNode, path, traceMap) {</span><span class="s3">\n        </span><span class="s1">const type = specifierNode.type</span><span class="s3">\n\n        </span><span class="s1">if (type === </span><span class="s3">\&quot;</span><span class="s1">ImportSpecifier</span><span class="s3">\&quot; </span><span class="s1">|| type === </span><span class="s3">\&quot;</span><span class="s1">ImportDefaultSpecifier</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">const key =</span><span class="s3">\n                </span><span class="s1">type === </span><span class="s3">\&quot;</span><span class="s1">ImportDefaultSpecifier</span><span class="s3">\&quot;\n                    </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;\n                    </span><span class="s1">: specifierNode.imported.type === </span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot;\n                    </span><span class="s1">? specifierNode.imported.name</span><span class="s3">\n                    </span><span class="s1">: specifierNode.imported.value</span><span class="s3">\n            </span><span class="s1">if (!has(traceMap, key)) {</span><span class="s3">\n                </span><span class="s1">return</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">path = path.concat(key) //eslint-disable-line no-param-reassign</span><span class="s3">\n            </span><span class="s1">const nextTraceMap = traceMap[key]</span><span class="s3">\n            </span><span class="s1">if (nextTraceMap[READ]) {</span><span class="s3">\n                </span><span class="s1">yield {</span><span class="s3">\n                    </span><span class="s1">node: /** @type {RuleNode} */ (specifierNode),</span><span class="s3">\n                    </span><span class="s1">path,</span><span class="s3">\n                    </span><span class="s1">type: READ,</span><span class="s3">\n                    </span><span class="s1">info: nextTraceMap[READ],</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">yield* this._iterateVariableReferences(</span><span class="s3">\n                </span><span class="s1">/** @type {Variable} */ (</span><span class="s3">\n                    </span><span class="s1">findVariable(this.globalScope, specifierNode.local)</span><span class="s3">\n                </span><span class="s1">),</span><span class="s3">\n                </span><span class="s1">path,</span><span class="s3">\n                </span><span class="s1">nextTraceMap,</span><span class="s3">\n                </span><span class="s1">false,</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n\n            </span><span class="s1">return</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (type === </span><span class="s3">\&quot;</span><span class="s1">ImportNamespaceSpecifier</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">yield* this._iterateVariableReferences(</span><span class="s3">\n                </span><span class="s1">/** @type {Variable} */ (</span><span class="s3">\n                    </span><span class="s1">findVariable(this.globalScope, specifierNode.local)</span><span class="s3">\n                </span><span class="s1">),</span><span class="s3">\n                </span><span class="s1">path,</span><span class="s3">\n                </span><span class="s1">traceMap,</span><span class="s3">\n                </span><span class="s1">false,</span><span class="s3">\n            </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">return</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (type === </span><span class="s3">\&quot;</span><span class="s1">ExportSpecifier</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">const key =</span><span class="s3">\n                </span><span class="s1">specifierNode.local.type === </span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot;\n                    </span><span class="s1">? specifierNode.local.name</span><span class="s3">\n                    </span><span class="s1">: specifierNode.local.value</span><span class="s3">\n            </span><span class="s1">if (!has(traceMap, key)) {</span><span class="s3">\n                </span><span class="s1">return</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">path = path.concat(key) //eslint-disable-line no-param-reassign</span><span class="s3">\n            </span><span class="s1">const nextTraceMap = traceMap[key]</span><span class="s3">\n            </span><span class="s1">if (nextTraceMap[READ]) {</span><span class="s3">\n                </span><span class="s1">yield {</span><span class="s3">\n                    </span><span class="s1">node: /** @type {RuleNode} */ (specifierNode),</span><span class="s3">\n                    </span><span class="s1">path,</span><span class="s3">\n                    </span><span class="s1">type: READ,</span><span class="s3">\n                    </span><span class="s1">info: nextTraceMap[READ],</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">ReferenceTracker.READ = READ</span><span class="s3">\n</span><span class="s1">ReferenceTracker.CALL = CALL</span><span class="s3">\n</span><span class="s1">ReferenceTracker.CONSTRUCT = CONSTRUCT</span><span class="s3">\n</span><span class="s1">ReferenceTracker.ESM = ESM</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This is a predicate function for Array#filter.</span><span class="s3">\n </span><span class="s1">* @param {string} name A name part.</span><span class="s3">\n </span><span class="s1">* @param {number} index The index of the name.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} `false` if it's default.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function exceptDefault(name, index) {</span><span class="s3">\n    </span><span class="s1">return !(index === 1 &amp;&amp; name === </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">./types.mjs</span><span class="s3">\&quot;</span><span class="s1">).StaticValue} StaticValue */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">./types.mjs</span><span class="s3">\&quot;</span><span class="s1">).StaticValueOptional} StaticValueOptional */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">./types.mjs</span><span class="s3">\&quot;</span><span class="s1">).StaticValueProvided} StaticValueProvided */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">./types.mjs</span><span class="s3">\&quot;</span><span class="s1">).ReferenceTrackerOptions} ReferenceTrackerOptions */</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template T</span><span class="s3">\n </span><span class="s1">* @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">./types.mjs</span><span class="s3">\&quot;</span><span class="s1">).TraceMap&lt;T&gt;} TraceMap</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template T</span><span class="s3">\n </span><span class="s1">* @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">./types.mjs</span><span class="s3">\&quot;</span><span class="s1">).TrackedReferences&lt;T&gt;} TrackedReferences</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">./types.mjs</span><span class="s3">\&quot;</span><span class="s1">).HasSideEffectOptions} HasSideEffectOptions */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">./types.mjs</span><span class="s3">\&quot;</span><span class="s1">).ArrowToken} ArrowToken */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">./types.mjs</span><span class="s3">\&quot;</span><span class="s1">).CommaToken} CommaToken */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">./types.mjs</span><span class="s3">\&quot;</span><span class="s1">).SemicolonToken} SemicolonToken */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">./types.mjs</span><span class="s3">\&quot;</span><span class="s1">).ColonToken} ColonToken */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">./types.mjs</span><span class="s3">\&quot;</span><span class="s1">).OpeningParenToken} OpeningParenToken */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">./types.mjs</span><span class="s3">\&quot;</span><span class="s1">).ClosingParenToken} ClosingParenToken */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">./types.mjs</span><span class="s3">\&quot;</span><span class="s1">).OpeningBracketToken} OpeningBracketToken */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">./types.mjs</span><span class="s3">\&quot;</span><span class="s1">).ClosingBracketToken} ClosingBracketToken */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">./types.mjs</span><span class="s3">\&quot;</span><span class="s1">).OpeningBraceToken} OpeningBraceToken */</span><span class="s3">\n</span><span class="s1">/** @typedef {import(</span><span class="s3">\&quot;</span><span class="s1">./types.mjs</span><span class="s3">\&quot;</span><span class="s1">).ClosingBraceToken} ClosingBraceToken */</span><span class="s3">\n\n</span><span class="s1">import { findVariable } from </span><span class="s3">\&quot;</span><span class="s1">./find-variable.mjs</span><span class="s3">\&quot;\n</span><span class="s1">import { getFunctionHeadLocation } from </span><span class="s3">\&quot;</span><span class="s1">./get-function-head-location.mjs</span><span class="s3">\&quot;\n</span><span class="s1">import { getFunctionNameWithKind } from </span><span class="s3">\&quot;</span><span class="s1">./get-function-name-with-kind.mjs</span><span class="s3">\&quot;\n</span><span class="s1">import { getInnermostScope } from </span><span class="s3">\&quot;</span><span class="s1">./get-innermost-scope.mjs</span><span class="s3">\&quot;\n</span><span class="s1">import { getPropertyName } from </span><span class="s3">\&quot;</span><span class="s1">./get-property-name.mjs</span><span class="s3">\&quot;\n</span><span class="s1">import { getStaticValue } from </span><span class="s3">\&quot;</span><span class="s1">./get-static-value.mjs</span><span class="s3">\&quot;\n</span><span class="s1">import { getStringIfConstant } from </span><span class="s3">\&quot;</span><span class="s1">./get-string-if-constant.mjs</span><span class="s3">\&quot;\n</span><span class="s1">import { hasSideEffect } from </span><span class="s3">\&quot;</span><span class="s1">./has-side-effect.mjs</span><span class="s3">\&quot;\n</span><span class="s1">import { isParenthesized } from </span><span class="s3">\&quot;</span><span class="s1">./is-parenthesized.mjs</span><span class="s3">\&quot;\n</span><span class="s1">import { PatternMatcher } from </span><span class="s3">\&quot;</span><span class="s1">./pattern-matcher.mjs</span><span class="s3">\&quot;\n</span><span class="s1">import {</span><span class="s3">\n    </span><span class="s1">CALL,</span><span class="s3">\n    </span><span class="s1">CONSTRUCT,</span><span class="s3">\n    </span><span class="s1">ESM,</span><span class="s3">\n    </span><span class="s1">READ,</span><span class="s3">\n    </span><span class="s1">ReferenceTracker,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">./reference-tracker.mjs</span><span class="s3">\&quot;\n</span><span class="s1">import {</span><span class="s3">\n    </span><span class="s1">isArrowToken,</span><span class="s3">\n    </span><span class="s1">isClosingBraceToken,</span><span class="s3">\n    </span><span class="s1">isClosingBracketToken,</span><span class="s3">\n    </span><span class="s1">isClosingParenToken,</span><span class="s3">\n    </span><span class="s1">isColonToken,</span><span class="s3">\n    </span><span class="s1">isCommaToken,</span><span class="s3">\n    </span><span class="s1">isCommentToken,</span><span class="s3">\n    </span><span class="s1">isNotArrowToken,</span><span class="s3">\n    </span><span class="s1">isNotClosingBraceToken,</span><span class="s3">\n    </span><span class="s1">isNotClosingBracketToken,</span><span class="s3">\n    </span><span class="s1">isNotClosingParenToken,</span><span class="s3">\n    </span><span class="s1">isNotColonToken,</span><span class="s3">\n    </span><span class="s1">isNotCommaToken,</span><span class="s3">\n    </span><span class="s1">isNotCommentToken,</span><span class="s3">\n    </span><span class="s1">isNotOpeningBraceToken,</span><span class="s3">\n    </span><span class="s1">isNotOpeningBracketToken,</span><span class="s3">\n    </span><span class="s1">isNotOpeningParenToken,</span><span class="s3">\n    </span><span class="s1">isNotSemicolonToken,</span><span class="s3">\n    </span><span class="s1">isOpeningBraceToken,</span><span class="s3">\n    </span><span class="s1">isOpeningBracketToken,</span><span class="s3">\n    </span><span class="s1">isOpeningParenToken,</span><span class="s3">\n    </span><span class="s1">isSemicolonToken,</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">./token-predicate.mjs</span><span class="s3">\&quot;\n\n</span><span class="s1">export default {</span><span class="s3">\n    </span><span class="s1">CALL,</span><span class="s3">\n    </span><span class="s1">CONSTRUCT,</span><span class="s3">\n    </span><span class="s1">ESM,</span><span class="s3">\n    </span><span class="s1">findVariable,</span><span class="s3">\n    </span><span class="s1">getFunctionHeadLocation,</span><span class="s3">\n    </span><span class="s1">getFunctionNameWithKind,</span><span class="s3">\n    </span><span class="s1">getInnermostScope,</span><span class="s3">\n    </span><span class="s1">getPropertyName,</span><span class="s3">\n    </span><span class="s1">getStaticValue,</span><span class="s3">\n    </span><span class="s1">getStringIfConstant,</span><span class="s3">\n    </span><span class="s1">hasSideEffect,</span><span class="s3">\n    </span><span class="s1">isArrowToken,</span><span class="s3">\n    </span><span class="s1">isClosingBraceToken,</span><span class="s3">\n    </span><span class="s1">isClosingBracketToken,</span><span class="s3">\n    </span><span class="s1">isClosingParenToken,</span><span class="s3">\n    </span><span class="s1">isColonToken,</span><span class="s3">\n    </span><span class="s1">isCommaToken,</span><span class="s3">\n    </span><span class="s1">isCommentToken,</span><span class="s3">\n    </span><span class="s1">isNotArrowToken,</span><span class="s3">\n    </span><span class="s1">isNotClosingBraceToken,</span><span class="s3">\n    </span><span class="s1">isNotClosingBracketToken,</span><span class="s3">\n    </span><span class="s1">isNotClosingParenToken,</span><span class="s3">\n    </span><span class="s1">isNotColonToken,</span><span class="s3">\n    </span><span class="s1">isNotCommaToken,</span><span class="s3">\n    </span><span class="s1">isNotCommentToken,</span><span class="s3">\n    </span><span class="s1">isNotOpeningBraceToken,</span><span class="s3">\n    </span><span class="s1">isNotOpeningBracketToken,</span><span class="s3">\n    </span><span class="s1">isNotOpeningParenToken,</span><span class="s3">\n    </span><span class="s1">isNotSemicolonToken,</span><span class="s3">\n    </span><span class="s1">isOpeningBraceToken,</span><span class="s3">\n    </span><span class="s1">isOpeningBracketToken,</span><span class="s3">\n    </span><span class="s1">isOpeningParenToken,</span><span class="s3">\n    </span><span class="s1">isParenthesized,</span><span class="s3">\n    </span><span class="s1">isSemicolonToken,</span><span class="s3">\n    </span><span class="s1">PatternMatcher,</span><span class="s3">\n    </span><span class="s1">READ,</span><span class="s3">\n    </span><span class="s1">ReferenceTracker,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export {</span><span class="s3">\n    </span><span class="s1">CALL,</span><span class="s3">\n    </span><span class="s1">CONSTRUCT,</span><span class="s3">\n    </span><span class="s1">ESM,</span><span class="s3">\n    </span><span class="s1">findVariable,</span><span class="s3">\n    </span><span class="s1">getFunctionHeadLocation,</span><span class="s3">\n    </span><span class="s1">getFunctionNameWithKind,</span><span class="s3">\n    </span><span class="s1">getInnermostScope,</span><span class="s3">\n    </span><span class="s1">getPropertyName,</span><span class="s3">\n    </span><span class="s1">getStaticValue,</span><span class="s3">\n    </span><span class="s1">getStringIfConstant,</span><span class="s3">\n    </span><span class="s1">hasSideEffect,</span><span class="s3">\n    </span><span class="s1">isArrowToken,</span><span class="s3">\n    </span><span class="s1">isClosingBraceToken,</span><span class="s3">\n    </span><span class="s1">isClosingBracketToken,</span><span class="s3">\n    </span><span class="s1">isClosingParenToken,</span><span class="s3">\n    </span><span class="s1">isColonToken,</span><span class="s3">\n    </span><span class="s1">isCommaToken,</span><span class="s3">\n    </span><span class="s1">isCommentToken,</span><span class="s3">\n    </span><span class="s1">isNotArrowToken,</span><span class="s3">\n    </span><span class="s1">isNotClosingBraceToken,</span><span class="s3">\n    </span><span class="s1">isNotClosingBracketToken,</span><span class="s3">\n    </span><span class="s1">isNotClosingParenToken,</span><span class="s3">\n    </span><span class="s1">isNotColonToken,</span><span class="s3">\n    </span><span class="s1">isNotCommaToken,</span><span class="s3">\n    </span><span class="s1">isNotCommentToken,</span><span class="s3">\n    </span><span class="s1">isNotOpeningBraceToken,</span><span class="s3">\n    </span><span class="s1">isNotOpeningBracketToken,</span><span class="s3">\n    </span><span class="s1">isNotOpeningParenToken,</span><span class="s3">\n    </span><span class="s1">isNotSemicolonToken,</span><span class="s3">\n    </span><span class="s1">isOpeningBraceToken,</span><span class="s3">\n    </span><span class="s1">isOpeningBracketToken,</span><span class="s3">\n    </span><span class="s1">isOpeningParenToken,</span><span class="s3">\n    </span><span class="s1">isParenthesized,</span><span class="s3">\n    </span><span class="s1">isSemicolonToken,</span><span class="s3">\n    </span><span class="s1">PatternMatcher,</span><span class="s3">\n    </span><span class="s1">READ,</span><span class="s3">\n    </span><span class="s1">ReferenceTracker,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">}</span></pre>
</body>
</html>