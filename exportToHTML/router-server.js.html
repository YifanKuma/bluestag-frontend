<html>
<head>
<title>router-server.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #0033b3;}
.s4 { color: #1750eb;}
.s5 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
router-server.js</font>
</center></td></tr></table>
<pre><span class="s0">// this must come first as it includes require hooks</span>
<span class="s2">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s3">true</span>
<span class="s1">});</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s2">&quot;initialize&quot;</span><span class="s1">, {</span>
    <span class="s1">enumerable: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s1">get: </span><span class="s3">function</span><span class="s1">() {</span>
        <span class="s3">return </span><span class="s1">initialize;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s1">require(</span><span class="s2">&quot;../node-environment&quot;</span><span class="s1">);</span>
<span class="s1">require(</span><span class="s2">&quot;../require-hook&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_url = </span><span class="s0">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s2">&quot;url&quot;</span><span class="s1">));</span>
<span class="s3">const </span><span class="s1">_path = </span><span class="s0">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s2">&quot;path&quot;</span><span class="s1">));</span>
<span class="s3">const </span><span class="s1">_config = </span><span class="s0">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s2">&quot;../config&quot;</span><span class="s1">));</span>
<span class="s3">const </span><span class="s1">_servestatic = require(</span><span class="s2">&quot;../serve-static&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_debug = </span><span class="s0">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s2">&quot;next/dist/compiled/debug&quot;</span><span class="s1">));</span>
<span class="s3">const </span><span class="s1">_log = </span><span class="s0">/*#__PURE__*/ </span><span class="s1">_interop_require_wildcard(require(</span><span class="s2">&quot;../../build/output/log&quot;</span><span class="s1">));</span>
<span class="s3">const </span><span class="s1">_utils = require(</span><span class="s2">&quot;../../shared/lib/utils&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_findpagesdir = require(</span><span class="s2">&quot;../../lib/find-pages-dir&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_filesystem = require(</span><span class="s2">&quot;./router-utils/filesystem&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_proxyrequest = require(</span><span class="s2">&quot;./router-utils/proxy-request&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_pipereadable = require(</span><span class="s2">&quot;../pipe-readable&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_resolveroutes = require(</span><span class="s2">&quot;./router-utils/resolve-routes&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_requestmeta = require(</span><span class="s2">&quot;../request-meta&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_pathhasprefix = require(</span><span class="s2">&quot;../../shared/lib/router/utils/path-has-prefix&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_removepathprefix = require(</span><span class="s2">&quot;../../shared/lib/router/utils/remove-path-prefix&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_compression = </span><span class="s0">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s2">&quot;next/dist/compiled/compression&quot;</span><span class="s1">));</span>
<span class="s3">const </span><span class="s1">_nextrequest = require(</span><span class="s2">&quot;../web/spec-extension/adapters/next-request&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_ispostpone = require(</span><span class="s2">&quot;./router-utils/is-postpone&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_parseurl = require(</span><span class="s2">&quot;../../shared/lib/router/utils/parse-url&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_constants = require(</span><span class="s2">&quot;../../shared/lib/constants&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_redirectstatuscode = require(</span><span class="s2">&quot;../../client/components/redirect-status-code&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_devbundlerservice = require(</span><span class="s2">&quot;./dev-bundler-service&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_trace = require(</span><span class="s2">&quot;../../trace&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_ensureleadingslash = require(</span><span class="s2">&quot;../../shared/lib/page-path/ensure-leading-slash&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_getnextpathnameinfo = require(</span><span class="s2">&quot;../../shared/lib/router/utils/get-next-pathname-info&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_gethostname = require(</span><span class="s2">&quot;../../shared/lib/get-hostname&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_detectdomainlocale = require(</span><span class="s2">&quot;../../shared/lib/i18n/detect-domain-locale&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_mockrequest = require(</span><span class="s2">&quot;./mock-request&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_hotreloadertypes = require(</span><span class="s2">&quot;../dev/hot-reloader-types&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_normalizedassetprefix = require(</span><span class="s2">&quot;../../shared/lib/normalized-asset-prefix&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_patchfetch = require(</span><span class="s2">&quot;./patch-fetch&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_utils1 = require(</span><span class="s2">&quot;./server-ipc/utils&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_blockcrosssite = require(</span><span class="s2">&quot;./router-utils/block-cross-site&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_shared = require(</span><span class="s2">&quot;../../trace/shared&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_nofallbackerrorexternal = require(</span><span class="s2">&quot;../../shared/lib/no-fallback-error.external&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_routerservercontext = require(</span><span class="s2">&quot;./router-utils/router-server-context&quot;</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">_chromedevtoolsworkspace = require(</span><span class="s2">&quot;./chrome-devtools-workspace&quot;</span><span class="s1">);</span>
<span class="s3">function </span><span class="s1">_interop_require_default(obj) {</span>
    <span class="s3">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : {</span>
        <span class="s3">default</span><span class="s1">: obj</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">_getRequireWildcardCache(nodeInterop) {</span>
    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">WeakMap !== </span><span class="s2">&quot;function&quot;</span><span class="s1">) </span><span class="s3">return null</span><span class="s1">;</span>
    <span class="s3">var </span><span class="s1">cacheBabelInterop = </span><span class="s3">new </span><span class="s1">WeakMap();</span>
    <span class="s3">var </span><span class="s1">cacheNodeInterop = </span><span class="s3">new </span><span class="s1">WeakMap();</span>
    <span class="s3">return </span><span class="s1">(_getRequireWildcardCache = </span><span class="s3">function</span><span class="s1">(nodeInterop) {</span>
        <span class="s3">return </span><span class="s1">nodeInterop ? cacheNodeInterop : cacheBabelInterop;</span>
    <span class="s1">})(nodeInterop);</span>
<span class="s1">}</span>
<span class="s3">function </span><span class="s1">_interop_require_wildcard(obj, nodeInterop) {</span>
    <span class="s3">if </span><span class="s1">(!nodeInterop &amp;&amp; obj &amp;&amp; obj.__esModule) {</span>
        <span class="s3">return </span><span class="s1">obj;</span>
    <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">(obj === </span><span class="s3">null </span><span class="s1">|| </span><span class="s3">typeof </span><span class="s1">obj !== </span><span class="s2">&quot;object&quot; </span><span class="s1">&amp;&amp; </span><span class="s3">typeof </span><span class="s1">obj !== </span><span class="s2">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s3">return </span><span class="s1">{</span>
            <span class="s3">default</span><span class="s1">: obj</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s3">var </span><span class="s1">cache = _getRequireWildcardCache(nodeInterop);</span>
    <span class="s3">if </span><span class="s1">(cache &amp;&amp; cache.has(obj)) {</span>
        <span class="s3">return </span><span class="s1">cache.get(obj);</span>
    <span class="s1">}</span>
    <span class="s3">var </span><span class="s1">newObj = {</span>
        <span class="s1">__proto__: </span><span class="s3">null</span>
    <span class="s1">};</span>
    <span class="s3">var </span><span class="s1">hasPropertyDescriptor = Object.defineProperty &amp;&amp; Object.getOwnPropertyDescriptor;</span>
    <span class="s3">for</span><span class="s1">(</span><span class="s3">var </span><span class="s1">key </span><span class="s3">in </span><span class="s1">obj){</span>
        <span class="s3">if </span><span class="s1">(key !== </span><span class="s2">&quot;default&quot; </span><span class="s1">&amp;&amp; Object.prototype.hasOwnProperty.call(obj, key)) {</span>
            <span class="s3">var </span><span class="s1">desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : </span><span class="s3">null</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(desc &amp;&amp; (desc.get || desc.set)) {</span>
                <span class="s1">Object.defineProperty(newObj, key, desc);</span>
            <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                <span class="s1">newObj[key] = obj[key];</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">newObj.default = obj;</span>
    <span class="s3">if </span><span class="s1">(cache) {</span>
        <span class="s1">cache.set(obj, newObj);</span>
    <span class="s1">}</span>
    <span class="s3">return </span><span class="s1">newObj;</span>
<span class="s1">}</span>
<span class="s3">const </span><span class="s1">debug = (</span><span class="s4">0</span><span class="s1">, _debug.default)(</span><span class="s2">'next:router-server:main'</span><span class="s1">);</span>
<span class="s3">const </span><span class="s1">isNextFont = (pathname)=&gt;pathname &amp;&amp; </span><span class="s5">/\/media\/[^/]+\.(woff|woff2|eot|ttf|otf)$/</span><span class="s1">.test(pathname);</span>
<span class="s3">const </span><span class="s1">requestHandlers = {};</span>
<span class="s1">async </span><span class="s3">function </span><span class="s1">initialize(opts) {</span>
    <span class="s3">if </span><span class="s1">(!process.env.NODE_ENV) {</span>
        <span class="s0">// @ts-ignore not readonly</span>
        <span class="s1">process.env.NODE_ENV = opts.dev ? </span><span class="s2">'development' </span><span class="s1">: </span><span class="s2">'production'</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">const </span><span class="s1">config = </span><span class="s3">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _config.default)(opts.dev ? _constants.PHASE_DEVELOPMENT_SERVER : _constants.PHASE_PRODUCTION_SERVER, opts.dir, {</span>
        <span class="s1">silent: </span><span class="s3">false</span>
    <span class="s1">});</span>
    <span class="s3">let </span><span class="s1">compress;</span>
    <span class="s3">if </span><span class="s1">((config == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: config.compress) !== </span><span class="s3">false</span><span class="s1">) {</span>
        <span class="s1">compress = (</span><span class="s4">0</span><span class="s1">, _compression.default)();</span>
    <span class="s1">}</span>
    <span class="s3">const </span><span class="s1">fsChecker = </span><span class="s3">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _filesystem.setupFsCheck)({</span>
        <span class="s1">dev: opts.dev,</span>
        <span class="s1">dir: opts.dir,</span>
        <span class="s1">config,</span>
        <span class="s1">minimalMode: opts.minimalMode</span>
    <span class="s1">});</span>
    <span class="s3">const </span><span class="s1">renderServer = {};</span>
    <span class="s3">let </span><span class="s1">developmentBundler;</span>
    <span class="s3">let </span><span class="s1">devBundlerService;</span>
    <span class="s3">let </span><span class="s1">originalFetch = globalThis.fetch;</span>
    <span class="s3">if </span><span class="s1">(opts.dev) {</span>
        <span class="s3">const </span><span class="s1">{ Telemetry } = require(</span><span class="s2">'../../telemetry/storage'</span><span class="s1">);</span>
        <span class="s3">const </span><span class="s1">telemetry = </span><span class="s3">new </span><span class="s1">Telemetry({</span>
            <span class="s1">distDir: _path.default.join(opts.dir, config.distDir)</span>
        <span class="s1">});</span>
        <span class="s1">_shared.traceGlobals.set(</span><span class="s2">'telemetry'</span><span class="s1">, telemetry);</span>
        <span class="s3">const </span><span class="s1">{ pagesDir, appDir } = (</span><span class="s4">0</span><span class="s1">, _findpagesdir.findPagesDir)(opts.dir);</span>
        <span class="s3">const </span><span class="s1">{ setupDevBundler } = require(</span><span class="s2">'./router-utils/setup-dev-bundler'</span><span class="s1">);</span>
        <span class="s3">const </span><span class="s1">resetFetch = ()=&gt;{</span>
            <span class="s1">globalThis.fetch = originalFetch;</span>
            <span class="s1">globalThis[_patchfetch.NEXT_PATCH_SYMBOL] = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s1">};</span>
        <span class="s3">const </span><span class="s1">setupDevBundlerSpan = opts.startServerSpan ? opts.startServerSpan.traceChild(</span><span class="s2">'setup-dev-bundler'</span><span class="s1">) : (</span><span class="s4">0</span><span class="s1">, _trace.trace)(</span><span class="s2">'setup-dev-bundler'</span><span class="s1">);</span>
        <span class="s1">developmentBundler = </span><span class="s3">await </span><span class="s1">setupDevBundlerSpan.traceAsyncFn(()=&gt;setupDevBundler({</span>
                <span class="s0">// Passed here but the initialization of this object happens below, doing the initialization before the setupDev call breaks.</span>
                <span class="s1">renderServer,</span>
                <span class="s1">appDir,</span>
                <span class="s1">pagesDir,</span>
                <span class="s1">telemetry,</span>
                <span class="s1">fsChecker,</span>
                <span class="s1">dir: opts.dir,</span>
                <span class="s1">nextConfig: config,</span>
                <span class="s1">isCustomServer: opts.customServer,</span>
                <span class="s1">turbo: !!process.env.TURBOPACK,</span>
                <span class="s1">port: opts.port,</span>
                <span class="s1">onDevServerCleanup: opts.onDevServerCleanup,</span>
                <span class="s1">resetFetch</span>
            <span class="s1">}));</span>
        <span class="s1">devBundlerService = </span><span class="s3">new </span><span class="s1">_devbundlerservice.DevBundlerService(developmentBundler, </span><span class="s0">// The request handler is assigned below, this allows us to create a lazy</span>
        <span class="s0">// reference to it.</span>
        <span class="s1">(req, res)=&gt;{</span>
            <span class="s3">return </span><span class="s1">requestHandlers[opts.dir](req, res);</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">renderServer.instance = require(</span><span class="s2">'./render-server'</span><span class="s1">);</span>
    <span class="s3">const </span><span class="s1">requestHandlerImpl = async (req, res)=&gt;{</span>
        <span class="s1">(</span><span class="s4">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s2">'relativeProjectDir'</span><span class="s1">, relativeProjectDir);</span>
        <span class="s0">// internal headers should not be honored by the request handler</span>
        <span class="s3">if </span><span class="s1">(!process.env.NEXT_PRIVATE_TEST_HEADERS) {</span>
            <span class="s1">(</span><span class="s4">0</span><span class="s1">, _utils1.filterInternalHeaders)(req.headers);</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(!opts.minimalMode &amp;&amp; config.i18n &amp;&amp; config.i18n.localeDetection !== </span><span class="s3">false</span><span class="s1">) {</span>
            <span class="s3">var </span><span class="s1">_this;</span>
            <span class="s3">const </span><span class="s1">urlParts = (req.url || </span><span class="s2">''</span><span class="s1">).split(</span><span class="s2">'?'</span><span class="s1">, </span><span class="s4">1</span><span class="s1">);</span>
            <span class="s3">let </span><span class="s1">urlNoQuery = urlParts[</span><span class="s4">0</span><span class="s1">] || </span><span class="s2">''</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(config.basePath) {</span>
                <span class="s1">urlNoQuery = (</span><span class="s4">0</span><span class="s1">, _removepathprefix.removePathPrefix)(urlNoQuery, config.basePath);</span>
            <span class="s1">}</span>
            <span class="s3">const </span><span class="s1">pathnameInfo = (</span><span class="s4">0</span><span class="s1">, _getnextpathnameinfo.getNextPathnameInfo)(urlNoQuery, {</span>
                <span class="s1">nextConfig: config</span>
            <span class="s1">});</span>
            <span class="s3">const </span><span class="s1">domainLocale = (</span><span class="s4">0</span><span class="s1">, _detectdomainlocale.detectDomainLocale)(config.i18n.domains, (</span><span class="s4">0</span><span class="s1">, _gethostname.getHostname)({</span>
                <span class="s1">hostname: urlNoQuery</span>
            <span class="s1">}, req.headers));</span>
            <span class="s3">const </span><span class="s1">defaultLocale = (domainLocale == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: domainLocale.defaultLocale) || config.i18n.defaultLocale;</span>
            <span class="s3">const </span><span class="s1">{ getLocaleRedirect } = require(</span><span class="s2">'../../shared/lib/i18n/get-locale-redirect'</span><span class="s1">);</span>
            <span class="s3">const </span><span class="s1">parsedUrl = (</span><span class="s4">0</span><span class="s1">, _parseurl.parseUrl)((_this = req.url || </span><span class="s2">''</span><span class="s1">) == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: _this.replace(</span><span class="s5">/^\/+/</span><span class="s1">, </span><span class="s2">'/'</span><span class="s1">));</span>
            <span class="s3">const </span><span class="s1">redirect = getLocaleRedirect({</span>
                <span class="s1">defaultLocale,</span>
                <span class="s1">domainLocale,</span>
                <span class="s1">headers: req.headers,</span>
                <span class="s1">nextConfig: config,</span>
                <span class="s1">pathLocale: pathnameInfo.locale,</span>
                <span class="s1">urlParsed: {</span>
                    <span class="s1">...parsedUrl,</span>
                    <span class="s1">pathname: pathnameInfo.locale ? </span><span class="s2">`/</span><span class="s1">${pathnameInfo.locale}${urlNoQuery}</span><span class="s2">` </span><span class="s1">: urlNoQuery</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
            <span class="s3">if </span><span class="s1">(redirect) {</span>
                <span class="s1">res.setHeader(</span><span class="s2">'Location'</span><span class="s1">, redirect);</span>
                <span class="s1">res.statusCode = _redirectstatuscode.RedirectStatusCode.TemporaryRedirect;</span>
                <span class="s1">res.end(redirect);</span>
                <span class="s3">return</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(compress) {</span>
            <span class="s0">// @ts-expect-error not express req/res</span>
            <span class="s1">compress(req, res, ()=&gt;{});</span>
        <span class="s1">}</span>
        <span class="s1">req.on(</span><span class="s2">'error'</span><span class="s1">, (_err)=&gt;{</span>
        <span class="s0">// TODO: log socket errors?</span>
        <span class="s1">});</span>
        <span class="s1">res.on(</span><span class="s2">'error'</span><span class="s1">, (_err)=&gt;{</span>
        <span class="s0">// TODO: log socket errors?</span>
        <span class="s1">});</span>
        <span class="s3">const </span><span class="s1">invokedOutputs = </span><span class="s3">new </span><span class="s1">Set();</span>
        <span class="s1">async </span><span class="s3">function </span><span class="s1">invokeRender(parsedUrl, invokePath, handleIndex, additionalRequestMeta) {</span>
            <span class="s3">var </span><span class="s1">_fsChecker_getMiddlewareMatchers;</span>
            <span class="s0">// invokeRender expects /api routes to not be locale prefixed</span>
            <span class="s0">// so normalize here before continuing</span>
            <span class="s3">if </span><span class="s1">(config.i18n &amp;&amp; (</span><span class="s4">0</span><span class="s1">, _removepathprefix.removePathPrefix)(invokePath, config.basePath).startsWith(</span><span class="s2">`/</span><span class="s1">${(</span><span class="s4">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s2">'locale'</span><span class="s1">)}</span><span class="s2">/api`</span><span class="s1">)) {</span>
                <span class="s1">invokePath = fsChecker.handleLocale((</span><span class="s4">0</span><span class="s1">, _removepathprefix.removePathPrefix)(invokePath, config.basePath)).pathname;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(req.headers[</span><span class="s2">'x-nextjs-data'</span><span class="s1">] &amp;&amp; ((_fsChecker_getMiddlewareMatchers = fsChecker.getMiddlewareMatchers()) == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: _fsChecker_getMiddlewareMatchers.length) &amp;&amp; (</span><span class="s4">0</span><span class="s1">, _removepathprefix.removePathPrefix)(invokePath, config.basePath) === </span><span class="s2">'/404'</span><span class="s1">) {</span>
                <span class="s1">res.setHeader(</span><span class="s2">'x-nextjs-matched-path'</span><span class="s1">, parsedUrl.pathname || </span><span class="s2">''</span><span class="s1">);</span>
                <span class="s1">res.statusCode = </span><span class="s4">404</span><span class="s1">;</span>
                <span class="s1">res.setHeader(</span><span class="s2">'content-type'</span><span class="s1">, </span><span class="s2">'application/json'</span><span class="s1">);</span>
                <span class="s1">res.end(</span><span class="s2">'{}'</span><span class="s1">);</span>
                <span class="s3">return null</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(!handlers) {</span>
                <span class="s3">throw </span><span class="s1">Object.defineProperty(</span><span class="s3">new </span><span class="s1">Error(</span><span class="s2">'Failed to initialize render server'</span><span class="s1">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s2">&quot;E90&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s3">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s3">true</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s1">(</span><span class="s4">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s2">'invokePath'</span><span class="s1">, invokePath);</span>
            <span class="s1">(</span><span class="s4">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s2">'invokeQuery'</span><span class="s1">, parsedUrl.query);</span>
            <span class="s1">(</span><span class="s4">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s2">'middlewareInvoke'</span><span class="s1">, </span><span class="s3">false</span><span class="s1">);</span>
            <span class="s3">for</span><span class="s1">(</span><span class="s3">const </span><span class="s1">key </span><span class="s3">in </span><span class="s1">additionalRequestMeta || {}){</span>
                <span class="s1">(</span><span class="s4">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, key, additionalRequestMeta[key]);</span>
            <span class="s1">}</span>
            <span class="s1">debug(</span><span class="s2">'invokeRender'</span><span class="s1">, req.url, req.headers);</span>
            <span class="s3">try </span><span class="s1">{</span>
                <span class="s3">var </span><span class="s1">_renderServer_instance;</span>
                <span class="s3">const </span><span class="s1">initResult = </span><span class="s3">await </span><span class="s1">(renderServer == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: (_renderServer_instance = renderServer.instance) == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: _renderServer_instance.initialize(renderServerOpts));</span>
                <span class="s3">try </span><span class="s1">{</span>
                    <span class="s3">await </span><span class="s1">(initResult == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: initResult.requestHandler(req, res));</span>
                <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {</span>
                    <span class="s3">if </span><span class="s1">(err </span><span class="s3">instanceof </span><span class="s1">_nofallbackerrorexternal.NoFallbackError) {</span>
                        <span class="s0">// eslint-disable-next-line</span>
                        <span class="s3">await </span><span class="s1">handleRequest(handleIndex + </span><span class="s4">1</span><span class="s1">);</span>
                        <span class="s3">return</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s3">throw </span><span class="s1">err;</span>
                <span class="s1">}</span>
                <span class="s3">return</span><span class="s1">;</span>
            <span class="s1">} </span><span class="s3">catch </span><span class="s1">(e) {</span>
                <span class="s0">// If the client aborts before we can receive a response object (when</span>
                <span class="s0">// the headers are flushed), then we can early exit without further</span>
                <span class="s0">// processing.</span>
                <span class="s3">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _pipereadable.isAbortError)(e)) {</span>
                    <span class="s3">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">throw </span><span class="s1">e;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">const </span><span class="s1">handleRequest = async (handleIndex)=&gt;{</span>
            <span class="s3">if </span><span class="s1">(handleIndex &gt; </span><span class="s4">5</span><span class="s1">) {</span>
                <span class="s3">throw </span><span class="s1">Object.defineProperty(</span><span class="s3">new </span><span class="s1">Error(</span><span class="s2">`Attempted to handle request too many times </span><span class="s1">${req.url}</span><span class="s2">`</span><span class="s1">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s2">&quot;E283&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s3">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s3">true</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s0">// handle hot-reloader first</span>
            <span class="s3">if </span><span class="s1">(developmentBundler) {</span>
                <span class="s3">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _blockcrosssite.blockCrossSite)(req, res, config.allowedDevOrigins, opts.hostname)) {</span>
                    <span class="s3">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">const </span><span class="s1">origUrl = req.url || </span><span class="s2">'/'</span><span class="s1">;</span>
                <span class="s0">// both the basePath and assetPrefix need to be stripped from the URL</span>
                <span class="s0">// so that the development bundler can find the correct file</span>
                <span class="s3">if </span><span class="s1">(config.basePath &amp;&amp; (</span><span class="s4">0</span><span class="s1">, _pathhasprefix.pathHasPrefix)(origUrl, config.basePath)) {</span>
                    <span class="s1">req.url = (</span><span class="s4">0</span><span class="s1">, _removepathprefix.removePathPrefix)(origUrl, config.basePath);</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(config.assetPrefix &amp;&amp; (</span><span class="s4">0</span><span class="s1">, _pathhasprefix.pathHasPrefix)(origUrl, config.assetPrefix)) {</span>
                    <span class="s1">req.url = (</span><span class="s4">0</span><span class="s1">, _removepathprefix.removePathPrefix)(origUrl, config.assetPrefix);</span>
                <span class="s1">}</span>
                <span class="s3">const </span><span class="s1">parsedUrl = _url.default.parse(req.url || </span><span class="s2">'/'</span><span class="s1">);</span>
                <span class="s3">const </span><span class="s1">hotReloaderResult = </span><span class="s3">await </span><span class="s1">developmentBundler.hotReloader.run(req, res, parsedUrl);</span>
                <span class="s3">if </span><span class="s1">(hotReloaderResult.finished) {</span>
                    <span class="s3">return </span><span class="s1">hotReloaderResult;</span>
                <span class="s1">}</span>
                <span class="s1">req.url = origUrl;</span>
            <span class="s1">}</span>
            <span class="s3">const </span><span class="s1">{ finished, parsedUrl, statusCode, resHeaders, bodyStream, matchedOutput } = </span><span class="s3">await </span><span class="s1">resolveRoutes({</span>
                <span class="s1">req,</span>
                <span class="s1">res,</span>
                <span class="s1">isUpgradeReq: </span><span class="s3">false</span><span class="s1">,</span>
                <span class="s1">signal: (</span><span class="s4">0</span><span class="s1">, _nextrequest.signalFromNodeResponse)(res),</span>
                <span class="s1">invokedOutputs</span>
            <span class="s1">});</span>
            <span class="s3">if </span><span class="s1">(res.closed || res.finished) {</span>
                <span class="s3">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(developmentBundler &amp;&amp; (matchedOutput == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: matchedOutput.type) === </span><span class="s2">'devVirtualFsItem'</span><span class="s1">) {</span>
                <span class="s3">const </span><span class="s1">origUrl = req.url || </span><span class="s2">'/'</span><span class="s1">;</span>
                <span class="s3">if </span><span class="s1">(config.basePath &amp;&amp; (</span><span class="s4">0</span><span class="s1">, _pathhasprefix.pathHasPrefix)(origUrl, config.basePath)) {</span>
                    <span class="s1">req.url = (</span><span class="s4">0</span><span class="s1">, _removepathprefix.removePathPrefix)(origUrl, config.basePath);</span>
                <span class="s1">} </span><span class="s3">else if </span><span class="s1">(config.assetPrefix &amp;&amp; (</span><span class="s4">0</span><span class="s1">, _pathhasprefix.pathHasPrefix)(origUrl, config.assetPrefix)) {</span>
                    <span class="s1">req.url = (</span><span class="s4">0</span><span class="s1">, _removepathprefix.removePathPrefix)(origUrl, config.assetPrefix);</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(resHeaders) {</span>
                    <span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">key of Object.keys(resHeaders)){</span>
                        <span class="s1">res.setHeader(key, resHeaders[key]);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s3">const </span><span class="s1">result = </span><span class="s3">await </span><span class="s1">developmentBundler.requestHandler(req, res);</span>
                <span class="s3">if </span><span class="s1">(result.finished) {</span>
                    <span class="s3">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s0">// TODO: throw invariant if we resolved to this but it wasn't handled?</span>
                <span class="s1">req.url = origUrl;</span>
            <span class="s1">}</span>
            <span class="s1">debug(</span><span class="s2">'requestHandler!'</span><span class="s1">, req.url, {</span>
                <span class="s1">matchedOutput,</span>
                <span class="s1">statusCode,</span>
                <span class="s1">resHeaders,</span>
                <span class="s1">bodyStream: !!bodyStream,</span>
                <span class="s1">parsedUrl: {</span>
                    <span class="s1">pathname: parsedUrl.pathname,</span>
                    <span class="s1">query: parsedUrl.query</span>
                <span class="s1">},</span>
                <span class="s1">finished</span>
            <span class="s1">});</span>
            <span class="s0">// apply any response headers from routing</span>
            <span class="s3">for </span><span class="s1">(</span><span class="s3">const </span><span class="s1">key of Object.keys(resHeaders || {})){</span>
                <span class="s1">res.setHeader(key, resHeaders[key]);</span>
            <span class="s1">}</span>
            <span class="s0">// handle redirect</span>
            <span class="s3">if </span><span class="s1">(!bodyStream &amp;&amp; statusCode &amp;&amp; statusCode &gt; </span><span class="s4">300 </span><span class="s1">&amp;&amp; statusCode &lt; </span><span class="s4">400</span><span class="s1">) {</span>
                <span class="s3">const </span><span class="s1">destination = _url.default.format(parsedUrl);</span>
                <span class="s1">res.statusCode = statusCode;</span>
                <span class="s1">res.setHeader(</span><span class="s2">'location'</span><span class="s1">, destination);</span>
                <span class="s3">if </span><span class="s1">(statusCode === _redirectstatuscode.RedirectStatusCode.PermanentRedirect) {</span>
                    <span class="s1">res.setHeader(</span><span class="s2">'Refresh'</span><span class="s1">, </span><span class="s2">`0;url=</span><span class="s1">${destination}</span><span class="s2">`</span><span class="s1">);</span>
                <span class="s1">}</span>
                <span class="s3">return </span><span class="s1">res.end(destination);</span>
            <span class="s1">}</span>
            <span class="s0">// handle middleware body response</span>
            <span class="s3">if </span><span class="s1">(bodyStream) {</span>
                <span class="s1">res.statusCode = statusCode || </span><span class="s4">200</span><span class="s1">;</span>
                <span class="s3">return await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _pipereadable.pipeToNodeResponse)(bodyStream, res);</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(finished &amp;&amp; parsedUrl.protocol) {</span>
                <span class="s3">var </span><span class="s1">_getRequestMeta;</span>
                <span class="s3">return await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _proxyrequest.proxyRequest)(req, res, parsedUrl, undefined, (_getRequestMeta = (</span><span class="s4">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s2">'clonableBody'</span><span class="s1">)) == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: _getRequestMeta.cloneBodyStream(), config.experimental.proxyTimeout);</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">((matchedOutput == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: matchedOutput.fsPath) &amp;&amp; matchedOutput.itemPath) {</span>
                <span class="s3">if </span><span class="s1">(opts.dev &amp;&amp; (fsChecker.appFiles.has(matchedOutput.itemPath) || fsChecker.pageFiles.has(matchedOutput.itemPath))) {</span>
                    <span class="s1">res.statusCode = </span><span class="s4">500</span><span class="s1">;</span>
                    <span class="s3">const </span><span class="s1">message = </span><span class="s2">`A conflicting public file and page file was found for path </span><span class="s1">${matchedOutput.itemPath} </span><span class="s2">https://nextjs.org/docs/messages/conflicting-public-file-page`</span><span class="s1">;</span>
                    <span class="s3">await </span><span class="s1">invokeRender(parsedUrl, </span><span class="s2">'/_error'</span><span class="s1">, handleIndex, {</span>
                        <span class="s1">invokeStatus: </span><span class="s4">500</span><span class="s1">,</span>
                        <span class="s1">invokeError: Object.defineProperty(</span><span class="s3">new </span><span class="s1">Error(message), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                            <span class="s1">value: </span><span class="s2">&quot;E394&quot;</span><span class="s1">,</span>
                            <span class="s1">enumerable: </span><span class="s3">false</span><span class="s1">,</span>
                            <span class="s1">configurable: </span><span class="s3">true</span>
                        <span class="s1">})</span>
                    <span class="s1">});</span>
                    <span class="s1">_log.error(message);</span>
                    <span class="s3">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(!res.getHeader(</span><span class="s2">'cache-control'</span><span class="s1">) &amp;&amp; matchedOutput.type === </span><span class="s2">'nextStaticFolder'</span><span class="s1">) {</span>
                    <span class="s3">if </span><span class="s1">(opts.dev &amp;&amp; !isNextFont(parsedUrl.pathname)) {</span>
                        <span class="s1">res.setHeader(</span><span class="s2">'Cache-Control'</span><span class="s1">, </span><span class="s2">'no-store, must-revalidate'</span><span class="s1">);</span>
                    <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                        <span class="s1">res.setHeader(</span><span class="s2">'Cache-Control'</span><span class="s1">, </span><span class="s2">'public, max-age=31536000, immutable'</span><span class="s1">);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(!(req.method === </span><span class="s2">'GET' </span><span class="s1">|| req.method === </span><span class="s2">'HEAD'</span><span class="s1">)) {</span>
                    <span class="s1">res.setHeader(</span><span class="s2">'Allow'</span><span class="s1">, [</span>
                        <span class="s2">'GET'</span><span class="s1">,</span>
                        <span class="s2">'HEAD'</span>
                    <span class="s1">]);</span>
                    <span class="s1">res.statusCode = </span><span class="s4">405</span><span class="s1">;</span>
                    <span class="s3">return await </span><span class="s1">invokeRender(_url.default.parse(</span><span class="s2">'/405'</span><span class="s1">, </span><span class="s3">true</span><span class="s1">), </span><span class="s2">'/405'</span><span class="s1">, handleIndex, {</span>
                        <span class="s1">invokeStatus: </span><span class="s4">405</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s3">try </span><span class="s1">{</span>
                    <span class="s3">return await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _servestatic.serveStatic)(req, res, matchedOutput.itemPath, {</span>
                        <span class="s1">root: matchedOutput.itemsRoot,</span>
                        <span class="s0">// Ensures that etags are not generated for static files when disabled.</span>
                        <span class="s1">etag: config.generateEtags</span>
                    <span class="s1">});</span>
                <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {</span>
                    <span class="s0">/**</span>
           <span class="s0">* Hardcoded every possible error status code that could be thrown by &quot;serveStatic&quot; method</span>
           <span class="s0">* This is done by searching &quot;this.error&quot; inside &quot;send&quot; module's source code:</span>
           <span class="s0">* https://github.com/pillarjs/send/blob/master/index.js</span>
           <span class="s0">* https://github.com/pillarjs/send/blob/develop/index.js</span>
           <span class="s0">*/ </span><span class="s3">const </span><span class="s1">POSSIBLE_ERROR_CODE_FROM_SERVE_STATIC = </span><span class="s3">new </span><span class="s1">Set([</span>
                        <span class="s0">// send module will throw 500 when header is already sent or fs.stat error happens</span>
                        <span class="s0">// https://github.com/pillarjs/send/blob/53f0ab476145670a9bdd3dc722ab2fdc8d358fc6/index.js#L392</span>
                        <span class="s0">// Note: we will use Next.js built-in 500 page to handle 500 errors</span>
                        <span class="s0">// 500,</span>
                        <span class="s0">// send module will throw 404 when file is missing</span>
                        <span class="s0">// https://github.com/pillarjs/send/blob/53f0ab476145670a9bdd3dc722ab2fdc8d358fc6/index.js#L421</span>
                        <span class="s0">// Note: we will use Next.js built-in 404 page to handle 404 errors</span>
                        <span class="s0">// 404,</span>
                        <span class="s0">// send module will throw 403 when redirecting to a directory without enabling directory listing</span>
                        <span class="s0">// https://github.com/pillarjs/send/blob/53f0ab476145670a9bdd3dc722ab2fdc8d358fc6/index.js#L484</span>
                        <span class="s0">// Note: Next.js throws a different error (without status code) for directory listing</span>
                        <span class="s0">// 403,</span>
                        <span class="s0">// send module will throw 400 when fails to normalize the path</span>
                        <span class="s0">// https://github.com/pillarjs/send/blob/53f0ab476145670a9bdd3dc722ab2fdc8d358fc6/index.js#L520</span>
                        <span class="s4">400</span><span class="s1">,</span>
                        <span class="s0">// send module will throw 412 with conditional GET request</span>
                        <span class="s0">// https://github.com/pillarjs/send/blob/53f0ab476145670a9bdd3dc722ab2fdc8d358fc6/index.js#L632</span>
                        <span class="s4">412</span><span class="s1">,</span>
                        <span class="s0">// send module will throw 416 when range is not satisfiable</span>
                        <span class="s0">// https://github.com/pillarjs/send/blob/53f0ab476145670a9bdd3dc722ab2fdc8d358fc6/index.js#L669</span>
                        <span class="s4">416</span>
                    <span class="s1">]);</span>
                    <span class="s3">let </span><span class="s1">validErrorStatus = POSSIBLE_ERROR_CODE_FROM_SERVE_STATIC.has(err.statusCode);</span>
                    <span class="s0">// normalize non-allowed status codes</span>
                    <span class="s3">if </span><span class="s1">(!validErrorStatus) {</span>
                        <span class="s1">;</span>
                        <span class="s1">err.statusCode = </span><span class="s4">400</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s3">if </span><span class="s1">(</span><span class="s3">typeof </span><span class="s1">err.statusCode === </span><span class="s2">'number'</span><span class="s1">) {</span>
                        <span class="s3">const </span><span class="s1">invokePath = </span><span class="s2">`/</span><span class="s1">${err.statusCode}</span><span class="s2">`</span><span class="s1">;</span>
                        <span class="s3">const </span><span class="s1">invokeStatus = err.statusCode;</span>
                        <span class="s1">res.statusCode = err.statusCode;</span>
                        <span class="s3">return await </span><span class="s1">invokeRender(_url.default.parse(invokePath, </span><span class="s3">true</span><span class="s1">), invokePath, handleIndex, {</span>
                            <span class="s1">invokeStatus</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s3">throw </span><span class="s1">err;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(matchedOutput) {</span>
                <span class="s1">invokedOutputs.add(matchedOutput.itemPath);</span>
                <span class="s3">return await </span><span class="s1">invokeRender(parsedUrl, parsedUrl.pathname || </span><span class="s2">'/'</span><span class="s1">, handleIndex, {</span>
                    <span class="s1">invokeOutput: matchedOutput.itemPath</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(opts.dev &amp;&amp; (</span><span class="s4">0</span><span class="s1">, _chromedevtoolsworkspace.isChromeDevtoolsWorkspaceUrl)(parsedUrl)) {</span>
                <span class="s3">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _chromedevtoolsworkspace.handleChromeDevtoolsWorkspaceRequest)(res, opts, config);</span>
                <span class="s3">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">// 404 case</span>
            <span class="s1">res.setHeader(</span><span class="s2">'Cache-Control'</span><span class="s1">, </span><span class="s2">'private, no-cache, no-store, max-age=0, must-revalidate'</span><span class="s1">);</span>
            <span class="s3">let </span><span class="s1">realRequestPathname = parsedUrl.pathname ?? </span><span class="s2">''</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(realRequestPathname) {</span>
                <span class="s3">if </span><span class="s1">(config.basePath) {</span>
                    <span class="s1">realRequestPathname = (</span><span class="s4">0</span><span class="s1">, _removepathprefix.removePathPrefix)(realRequestPathname, config.basePath);</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(config.assetPrefix) {</span>
                    <span class="s1">realRequestPathname = (</span><span class="s4">0</span><span class="s1">, _removepathprefix.removePathPrefix)(realRequestPathname, config.assetPrefix);</span>
                <span class="s1">}</span>
                <span class="s3">if </span><span class="s1">(config.i18n) {</span>
                    <span class="s1">realRequestPathname = (</span><span class="s4">0</span><span class="s1">, _removepathprefix.removePathPrefix)(realRequestPathname, </span><span class="s2">'/' </span><span class="s1">+ ((</span><span class="s4">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s2">'locale'</span><span class="s1">) ?? </span><span class="s2">''</span><span class="s1">));</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s0">// For not found static assets, return plain text 404 instead of</span>
            <span class="s0">// full HTML 404 pages to save bandwidth.</span>
            <span class="s3">if </span><span class="s1">(realRequestPathname.startsWith(</span><span class="s2">'/_next/static/'</span><span class="s1">)) {</span>
                <span class="s1">res.statusCode = </span><span class="s4">404</span><span class="s1">;</span>
                <span class="s1">res.setHeader(</span><span class="s2">'Content-Type'</span><span class="s1">, </span><span class="s2">'text/plain; charset=utf-8'</span><span class="s1">);</span>
                <span class="s1">res.end(</span><span class="s2">'Not Found'</span><span class="s1">);</span>
                <span class="s3">return null</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s0">// Short-circuit favicon.ico serving so that the 404 page doesn't get built as favicon is requested by the browser when loading any route.</span>
            <span class="s3">if </span><span class="s1">(opts.dev &amp;&amp; !matchedOutput &amp;&amp; parsedUrl.pathname === </span><span class="s2">'/favicon.ico'</span><span class="s1">) {</span>
                <span class="s1">res.statusCode = </span><span class="s4">404</span><span class="s1">;</span>
                <span class="s1">res.end(</span><span class="s2">''</span><span class="s1">);</span>
                <span class="s3">return null</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">const </span><span class="s1">appNotFound = opts.dev ? developmentBundler == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: developmentBundler.serverFields.hasAppNotFound : </span><span class="s3">await </span><span class="s1">fsChecker.getItem(_constants.UNDERSCORE_NOT_FOUND_ROUTE);</span>
            <span class="s1">res.statusCode = </span><span class="s4">404</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s1">(appNotFound) {</span>
                <span class="s3">return await </span><span class="s1">invokeRender(parsedUrl, _constants.UNDERSCORE_NOT_FOUND_ROUTE, handleIndex, {</span>
                    <span class="s1">invokeStatus: </span><span class="s4">404</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s3">await </span><span class="s1">invokeRender(parsedUrl, </span><span class="s2">'/404'</span><span class="s1">, handleIndex, {</span>
                <span class="s1">invokeStatus: </span><span class="s4">404</span>
            <span class="s1">});</span>
        <span class="s1">};</span>
        <span class="s3">try </span><span class="s1">{</span>
            <span class="s3">await </span><span class="s1">handleRequest(</span><span class="s4">0</span><span class="s1">);</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {</span>
            <span class="s3">try </span><span class="s1">{</span>
                <span class="s3">let </span><span class="s1">invokePath = </span><span class="s2">'/500'</span><span class="s1">;</span>
                <span class="s3">let </span><span class="s1">invokeStatus = </span><span class="s2">'500'</span><span class="s1">;</span>
                <span class="s3">if </span><span class="s1">(err </span><span class="s3">instanceof </span><span class="s1">_utils.DecodeError) {</span>
                    <span class="s1">invokePath = </span><span class="s2">'/400'</span><span class="s1">;</span>
                    <span class="s1">invokeStatus = </span><span class="s2">'400'</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s3">else </span><span class="s1">{</span>
                    <span class="s1">console.error(err);</span>
                <span class="s1">}</span>
                <span class="s1">res.statusCode = Number(invokeStatus);</span>
                <span class="s3">return await </span><span class="s1">invokeRender(_url.default.parse(invokePath, </span><span class="s3">true</span><span class="s1">), invokePath, </span><span class="s4">0</span><span class="s1">, {</span>
                    <span class="s1">invokeStatus: res.statusCode</span>
                <span class="s1">});</span>
            <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err2) {</span>
                <span class="s1">console.error(err2);</span>
            <span class="s1">}</span>
            <span class="s1">res.statusCode = </span><span class="s4">500</span><span class="s1">;</span>
            <span class="s1">res.end(</span><span class="s2">'Internal Server Error'</span><span class="s1">);</span>
        <span class="s1">}</span>
    <span class="s1">};</span>
    <span class="s3">let </span><span class="s1">requestHandler = requestHandlerImpl;</span>
    <span class="s3">if </span><span class="s1">(config.experimental.testProxy) {</span>
        <span class="s0">// Intercept fetch and other testmode apis.</span>
        <span class="s3">const </span><span class="s1">{ wrapRequestHandlerWorker, interceptTestApis } = </span><span class="s0">// eslint-disable-next-line @next/internal/typechecked-require -- experimental/testmode is not built ins next/dist/esm</span>
        <span class="s1">require(</span><span class="s2">'next/dist/experimental/testmode/server'</span><span class="s1">);</span>
        <span class="s1">requestHandler = wrapRequestHandlerWorker(requestHandler);</span>
        <span class="s1">interceptTestApis();</span>
        <span class="s0">// We treat the intercepted fetch as &quot;original&quot; fetch that should be reset to during HMR.</span>
        <span class="s1">originalFetch = globalThis.fetch;</span>
    <span class="s1">}</span>
    <span class="s1">requestHandlers[opts.dir] = requestHandler;</span>
    <span class="s3">const </span><span class="s1">renderServerOpts = {</span>
        <span class="s1">port: opts.port,</span>
        <span class="s1">dir: opts.dir,</span>
        <span class="s1">hostname: opts.hostname,</span>
        <span class="s1">minimalMode: opts.minimalMode,</span>
        <span class="s1">dev: !!opts.dev,</span>
        <span class="s1">server: opts.server,</span>
        <span class="s1">serverFields: {</span>
            <span class="s1">...(developmentBundler == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: developmentBundler.serverFields) || {},</span>
            <span class="s1">setIsrStatus: devBundlerService == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: devBundlerService.setIsrStatus.bind(devBundlerService)</span>
        <span class="s1">},</span>
        <span class="s1">experimentalTestProxy: !!config.experimental.testProxy,</span>
        <span class="s1">experimentalHttpsServer: !!opts.experimentalHttpsServer,</span>
        <span class="s1">bundlerService: devBundlerService,</span>
        <span class="s1">startServerSpan: opts.startServerSpan,</span>
        <span class="s1">quiet: opts.quiet,</span>
        <span class="s1">onDevServerCleanup: opts.onDevServerCleanup</span>
    <span class="s1">};</span>
    <span class="s1">renderServerOpts.serverFields.routerServerHandler = requestHandlerImpl;</span>
    <span class="s0">// pre-initialize workers</span>
    <span class="s3">const </span><span class="s1">handlers = </span><span class="s3">await </span><span class="s1">renderServer.instance.initialize(renderServerOpts);</span>
    <span class="s0">// this must come after initialize of render server since it's</span>
    <span class="s0">// using initialized methods</span>
    <span class="s3">if </span><span class="s1">(!_routerservercontext.routerServerGlobal[_routerservercontext.RouterServerContextSymbol]) {</span>
        <span class="s1">_routerservercontext.routerServerGlobal[_routerservercontext.RouterServerContextSymbol] = {};</span>
    <span class="s1">}</span>
    <span class="s3">const </span><span class="s1">relativeProjectDir = _path.default.relative(process.cwd(), opts.dir);</span>
    <span class="s1">_routerservercontext.routerServerGlobal[_routerservercontext.RouterServerContextSymbol][relativeProjectDir] = {</span>
        <span class="s1">nextConfig: config,</span>
        <span class="s1">hostname: handlers.server.hostname,</span>
        <span class="s1">revalidate: handlers.server.revalidate.bind(handlers.server),</span>
        <span class="s1">render404: handlers.server.render404.bind(handlers.server),</span>
        <span class="s1">experimentalTestProxy: renderServerOpts.experimentalTestProxy,</span>
        <span class="s1">logErrorWithOriginalStack: opts.dev ? handlers.server.logErrorWithOriginalStack.bind(handlers.server) : (err)=&gt;!opts.quiet &amp;&amp; _log.error(err),</span>
        <span class="s1">setIsrStatus: devBundlerService == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: devBundlerService.setIsrStatus.bind(devBundlerService)</span>
    <span class="s1">};</span>
    <span class="s3">const </span><span class="s1">logError = async (type, err)=&gt;{</span>
        <span class="s3">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _ispostpone.isPostpone)(err)) {</span>
            <span class="s0">// React postpones that are unhandled might end up logged here but they're</span>
            <span class="s0">// not really errors. They're just part of rendering.</span>
            <span class="s3">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">(type === </span><span class="s2">'unhandledRejection'</span><span class="s1">) {</span>
            <span class="s1">_log.error(</span><span class="s2">'unhandledRejection: '</span><span class="s1">, err);</span>
        <span class="s1">} </span><span class="s3">else if </span><span class="s1">(type === </span><span class="s2">'uncaughtException'</span><span class="s1">) {</span>
            <span class="s1">_log.error(</span><span class="s2">'uncaughtException: '</span><span class="s1">, err);</span>
        <span class="s1">}</span>
    <span class="s1">};</span>
    <span class="s1">process.on(</span><span class="s2">'uncaughtException'</span><span class="s1">, logError.bind(</span><span class="s3">null</span><span class="s1">, </span><span class="s2">'uncaughtException'</span><span class="s1">));</span>
    <span class="s1">process.on(</span><span class="s2">'unhandledRejection'</span><span class="s1">, logError.bind(</span><span class="s3">null</span><span class="s1">, </span><span class="s2">'unhandledRejection'</span><span class="s1">));</span>
    <span class="s3">const </span><span class="s1">resolveRoutes = (</span><span class="s4">0</span><span class="s1">, _resolveroutes.getResolveRoutes)(fsChecker, config, opts, renderServer.instance, renderServerOpts, developmentBundler == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: developmentBundler.ensureMiddleware);</span>
    <span class="s3">const </span><span class="s1">upgradeHandler = async (req, socket, head)=&gt;{</span>
        <span class="s3">try </span><span class="s1">{</span>
            <span class="s1">req.on(</span><span class="s2">'error'</span><span class="s1">, (_err)=&gt;{</span>
            <span class="s0">// TODO: log socket errors?</span>
            <span class="s0">// console.error(_err);</span>
            <span class="s1">});</span>
            <span class="s1">socket.on(</span><span class="s2">'error'</span><span class="s1">, (_err)=&gt;{</span>
            <span class="s0">// TODO: log socket errors?</span>
            <span class="s0">// console.error(_err);</span>
            <span class="s1">});</span>
            <span class="s3">if </span><span class="s1">(opts.dev &amp;&amp; developmentBundler &amp;&amp; req.url) {</span>
                <span class="s3">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _blockcrosssite.blockCrossSite)(req, socket, config.allowedDevOrigins, opts.hostname)) {</span>
                    <span class="s3">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s3">const </span><span class="s1">{ basePath, assetPrefix } = config;</span>
                <span class="s3">let </span><span class="s1">hmrPrefix = basePath;</span>
                <span class="s0">// assetPrefix overrides basePath for HMR path</span>
                <span class="s3">if </span><span class="s1">(assetPrefix) {</span>
                    <span class="s1">hmrPrefix = (</span><span class="s4">0</span><span class="s1">, _normalizedassetprefix.normalizedAssetPrefix)(assetPrefix);</span>
                    <span class="s3">if </span><span class="s1">(URL.canParse(hmrPrefix)) {</span>
                        <span class="s0">// remove trailing slash from pathname</span>
                        <span class="s0">// return empty string if pathname is '/'</span>
                        <span class="s0">// to avoid conflicts with '/_next' below</span>
                        <span class="s1">hmrPrefix = </span><span class="s3">new </span><span class="s1">URL(hmrPrefix).pathname.replace(</span><span class="s5">/\/$/</span><span class="s1">, </span><span class="s2">''</span><span class="s1">);</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s3">const </span><span class="s1">isHMRRequest = req.url.startsWith((</span><span class="s4">0</span><span class="s1">, _ensureleadingslash.ensureLeadingSlash)(</span><span class="s2">`</span><span class="s1">${hmrPrefix}</span><span class="s2">/_next/webpack-hmr`</span><span class="s1">));</span>
                <span class="s0">// only handle HMR requests if the basePath in the request</span>
                <span class="s0">// matches the basePath for the handler responding to the request</span>
                <span class="s3">if </span><span class="s1">(isHMRRequest) {</span>
                    <span class="s3">return </span><span class="s1">developmentBundler.hotReloader.onHMR(req, socket, head, (client)=&gt;{</span>
                        <span class="s1">client.send(JSON.stringify({</span>
                            <span class="s1">action: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.ISR_MANIFEST,</span>
                            <span class="s1">data: (devBundlerService == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: devBundlerService.appIsrManifest) || {}</span>
                        <span class="s1">}));</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">const </span><span class="s1">res = </span><span class="s3">new </span><span class="s1">_mockrequest.MockedResponse({</span>
                <span class="s1">resWriter: ()=&gt;{</span>
                    <span class="s3">throw </span><span class="s1">Object.defineProperty(</span><span class="s3">new </span><span class="s1">Error(</span><span class="s2">'Invariant: did not expect response writer to be written to for upgrade request'</span><span class="s1">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                        <span class="s1">value: </span><span class="s2">&quot;E522&quot;</span><span class="s1">,</span>
                        <span class="s1">enumerable: </span><span class="s3">false</span><span class="s1">,</span>
                        <span class="s1">configurable: </span><span class="s3">true</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
            <span class="s3">const </span><span class="s1">{ matchedOutput, parsedUrl } = </span><span class="s3">await </span><span class="s1">resolveRoutes({</span>
                <span class="s1">req,</span>
                <span class="s1">res,</span>
                <span class="s1">isUpgradeReq: </span><span class="s3">true</span><span class="s1">,</span>
                <span class="s1">signal: (</span><span class="s4">0</span><span class="s1">, _nextrequest.signalFromNodeResponse)(socket)</span>
            <span class="s1">});</span>
            <span class="s0">// TODO: allow upgrade requests to pages/app paths?</span>
            <span class="s0">// this was not previously supported</span>
            <span class="s3">if </span><span class="s1">(matchedOutput) {</span>
                <span class="s3">return </span><span class="s1">socket.end();</span>
            <span class="s1">}</span>
            <span class="s3">if </span><span class="s1">(parsedUrl.protocol) {</span>
                <span class="s3">return await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _proxyrequest.proxyRequest)(req, socket, parsedUrl, head);</span>
            <span class="s1">}</span>
        <span class="s0">// If there's no matched output, we don't handle the request as user's</span>
        <span class="s0">// custom WS server may be listening on the same path.</span>
        <span class="s1">} </span><span class="s3">catch </span><span class="s1">(err) {</span>
            <span class="s1">console.error(</span><span class="s2">'Error handling upgrade request'</span><span class="s1">, err);</span>
            <span class="s1">socket.end();</span>
        <span class="s1">}</span>
    <span class="s1">};</span>
    <span class="s3">return </span><span class="s1">{</span>
        <span class="s1">requestHandler,</span>
        <span class="s1">upgradeHandler,</span>
        <span class="s1">server: handlers.server,</span>
        <span class="s1">closeUpgraded () {</span>
            <span class="s3">var </span><span class="s1">_developmentBundler_hotReloader;</span>
            <span class="s1">developmentBundler == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: (_developmentBundler_hotReloader = developmentBundler.hotReloader) == </span><span class="s3">null </span><span class="s1">? </span><span class="s3">void </span><span class="s4">0 </span><span class="s1">: _developmentBundler_hotReloader.close();</span>
        <span class="s1">}</span>
    <span class="s1">};</span>
<span class="s1">}</span>

<span class="s0">//# sourceMappingURL=router-server.js.map</span></pre>
</body>
</html>