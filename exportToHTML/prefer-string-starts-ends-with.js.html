<html>
<head>
<title>prefer-string-starts-ends-with.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #264eff;}
.s4 { color: #1750eb;}
.s5 { color: #8c8c8c; font-style: italic;}
.s6 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
prefer-string-starts-ends-with.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
<span class="s2">const </span><span class="s1">regexpp_1 = require(</span><span class="s0">&quot;@eslint-community/regexpp&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">utils_1 = require(</span><span class="s0">&quot;@typescript-eslint/utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">util_1 = require(</span><span class="s0">&quot;../util&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">EQ_OPERATORS = </span><span class="s3">/^[=!]=/</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">regexpp = </span><span class="s2">new </span><span class="s1">regexpp_1.RegExpParser();</span>
<span class="s1">exports.default = (</span><span class="s4">0</span><span class="s1">, util_1.createRule)({</span>
    <span class="s1">name: </span><span class="s0">'prefer-string-starts-ends-with'</span><span class="s1">,</span>
    <span class="s1">meta: {</span>
        <span class="s1">type: </span><span class="s0">'suggestion'</span><span class="s1">,</span>
        <span class="s1">docs: {</span>
            <span class="s1">description: </span><span class="s0">'Enforce using `String#startsWith` and `String#endsWith` over other equivalent methods of checking substrings'</span><span class="s1">,</span>
            <span class="s1">recommended: </span><span class="s0">'stylistic'</span><span class="s1">,</span>
            <span class="s1">requiresTypeChecking: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">},</span>
        <span class="s1">fixable: </span><span class="s0">'code'</span><span class="s1">,</span>
        <span class="s1">messages: {</span>
            <span class="s1">preferEndsWith: </span><span class="s0">&quot;Use the 'String#endsWith' method instead.&quot;</span><span class="s1">,</span>
            <span class="s1">preferStartsWith: </span><span class="s0">&quot;Use 'String#startsWith' method instead.&quot;</span><span class="s1">,</span>
        <span class="s1">},</span>
        <span class="s1">schema: [</span>
            <span class="s1">{</span>
                <span class="s1">type: </span><span class="s0">'object'</span><span class="s1">,</span>
                <span class="s1">additionalProperties: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">properties: {</span>
                    <span class="s1">allowSingleElementEquality: {</span>
                        <span class="s1">type: </span><span class="s0">'string'</span><span class="s1">,</span>
                        <span class="s1">description: </span><span class="s0">'Whether to allow equality checks against the first or last element of a string.'</span><span class="s1">,</span>
                        <span class="s2">enum</span><span class="s1">: [</span><span class="s0">'always'</span><span class="s1">, </span><span class="s0">'never'</span><span class="s1">],</span>
                    <span class="s1">},</span>
                <span class="s1">},</span>
            <span class="s1">},</span>
        <span class="s1">],</span>
    <span class="s1">},</span>
    <span class="s1">defaultOptions: [{ allowSingleElementEquality: </span><span class="s0">'never' </span><span class="s1">}],</span>
    <span class="s1">create(context, [{ allowSingleElementEquality }]) {</span>
        <span class="s2">const </span><span class="s1">globalScope = context.sourceCode.getScope(context.sourceCode.ast);</span>
        <span class="s2">const </span><span class="s1">services = (</span><span class="s4">0</span><span class="s1">, util_1.getParserServices)(context);</span>
        <span class="s2">const </span><span class="s1">checker = services.program.getTypeChecker();</span>
        <span class="s5">/**</span>
         <span class="s5">* Check if a given node is a string.</span>
         <span class="s5">* </span><span class="s6">@param </span><span class="s5">node The node to check.</span>
         <span class="s5">*/</span>
        <span class="s2">function </span><span class="s1">isStringType(node) {</span>
            <span class="s2">const </span><span class="s1">objectType = services.getTypeAtLocation(node);</span>
            <span class="s2">return </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, util_1.getTypeName)(checker, objectType) === </span><span class="s0">'string'</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s5">/**</span>
         <span class="s5">* Check if a given node is a `Literal` node that is null.</span>
         <span class="s5">* </span><span class="s6">@param </span><span class="s5">node The node to check.</span>
         <span class="s5">*/</span>
        <span class="s2">function </span><span class="s1">isNull(node) {</span>
            <span class="s2">const </span><span class="s1">evaluated = (</span><span class="s4">0</span><span class="s1">, util_1.getStaticValue)(node, globalScope);</span>
            <span class="s2">return </span><span class="s1">evaluated != </span><span class="s2">null </span><span class="s1">&amp;&amp; evaluated.value == </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s5">/**</span>
         <span class="s5">* Check if a given node is a `Literal` node that is a given value.</span>
         <span class="s5">* </span><span class="s6">@param </span><span class="s5">node The node to check.</span>
         <span class="s5">* </span><span class="s6">@param </span><span class="s5">value The expected value of the `Literal` node.</span>
         <span class="s5">*/</span>
        <span class="s2">function </span><span class="s1">isNumber(node, value) {</span>
            <span class="s2">const </span><span class="s1">evaluated = (</span><span class="s4">0</span><span class="s1">, util_1.getStaticValue)(node, globalScope);</span>
            <span class="s2">return </span><span class="s1">evaluated != </span><span class="s2">null </span><span class="s1">&amp;&amp; evaluated.value === value;</span>
        <span class="s1">}</span>
        <span class="s5">/**</span>
         <span class="s5">* Check if a given node is a `Literal` node that is a character.</span>
         <span class="s5">* </span><span class="s6">@param </span><span class="s5">node The node to check.</span>
         <span class="s5">*/</span>
        <span class="s2">function </span><span class="s1">isCharacter(node) {</span>
            <span class="s2">const </span><span class="s1">evaluated = (</span><span class="s4">0</span><span class="s1">, util_1.getStaticValue)(node, globalScope);</span>
            <span class="s2">return </span><span class="s1">(evaluated != </span><span class="s2">null </span><span class="s1">&amp;&amp;</span>
                <span class="s2">typeof </span><span class="s1">evaluated.value === </span><span class="s0">'string' </span><span class="s1">&amp;&amp;</span>
                <span class="s5">// checks if the string is a character long</span>
                <span class="s1">evaluated.value[</span><span class="s4">0</span><span class="s1">] === evaluated.value);</span>
        <span class="s1">}</span>
        <span class="s5">/**</span>
         <span class="s5">* Check if a given node is `==`, `===`, `!=`, or `!==`.</span>
         <span class="s5">* </span><span class="s6">@param </span><span class="s5">node The node to check.</span>
         <span class="s5">*/</span>
        <span class="s2">function </span><span class="s1">isEqualityComparison(node) {</span>
            <span class="s2">return </span><span class="s1">(node.type === utils_1.AST_NODE_TYPES.BinaryExpression &amp;&amp;</span>
                <span class="s1">EQ_OPERATORS.test(node.operator));</span>
        <span class="s1">}</span>
        <span class="s5">/**</span>
         <span class="s5">* Check if two given nodes are the same meaning.</span>
         <span class="s5">* </span><span class="s6">@param </span><span class="s5">node1 A node to compare.</span>
         <span class="s5">* </span><span class="s6">@param </span><span class="s5">node2 Another node to compare.</span>
         <span class="s5">*/</span>
        <span class="s2">function </span><span class="s1">isSameTokens(node1, node2) {</span>
            <span class="s2">const </span><span class="s1">tokens1 = context.sourceCode.getTokens(node1);</span>
            <span class="s2">const </span><span class="s1">tokens2 = context.sourceCode.getTokens(node2);</span>
            <span class="s2">if </span><span class="s1">(tokens1.length !== tokens2.length) {</span>
                <span class="s2">return false</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; tokens1.length; ++i) {</span>
                <span class="s2">const </span><span class="s1">token1 = tokens1[i];</span>
                <span class="s2">const </span><span class="s1">token2 = tokens2[i];</span>
                <span class="s2">if </span><span class="s1">(token1.type !== token2.type || token1.value !== token2.value) {</span>
                    <span class="s2">return false</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s5">/**</span>
         <span class="s5">* Check if a given node is the expression of the length of a string.</span>
         <span class="s5">*</span>
         <span class="s5">* - If `length` property access of `expectedObjectNode`, it's `true`.</span>
         <span class="s5">*   E.g., `foo` → `foo.length` / `&quot;foo&quot;` → `&quot;foo&quot;.length`</span>
         <span class="s5">* - If `expectedObjectNode` is a string literal, `node` can be a number.</span>
         <span class="s5">*   E.g., `&quot;foo&quot;` → `3`</span>
         <span class="s5">*</span>
         <span class="s5">* </span><span class="s6">@param </span><span class="s5">node The node to check.</span>
         <span class="s5">* </span><span class="s6">@param </span><span class="s5">expectedObjectNode The node which is expected as the receiver of `length` property.</span>
         <span class="s5">*/</span>
        <span class="s2">function </span><span class="s1">isLengthExpression(node, expectedObjectNode) {</span>
            <span class="s2">if </span><span class="s1">(node.type === utils_1.AST_NODE_TYPES.MemberExpression) {</span>
                <span class="s2">return </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, util_1.getPropertyName)(node, globalScope) === </span><span class="s0">'length' </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">isSameTokens(node.object, expectedObjectNode));</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">evaluatedLength = (</span><span class="s4">0</span><span class="s1">, util_1.getStaticValue)(node, globalScope);</span>
            <span class="s2">const </span><span class="s1">evaluatedString = (</span><span class="s4">0</span><span class="s1">, util_1.getStaticValue)(expectedObjectNode, globalScope);</span>
            <span class="s2">return </span><span class="s1">(evaluatedLength != </span><span class="s2">null </span><span class="s1">&amp;&amp;</span>
                <span class="s1">evaluatedString != </span><span class="s2">null </span><span class="s1">&amp;&amp;</span>
                <span class="s2">typeof </span><span class="s1">evaluatedLength.value === </span><span class="s0">'number' </span><span class="s1">&amp;&amp;</span>
                <span class="s2">typeof </span><span class="s1">evaluatedString.value === </span><span class="s0">'string' </span><span class="s1">&amp;&amp;</span>
                <span class="s1">evaluatedLength.value === evaluatedString.value.length);</span>
        <span class="s1">}</span>
        <span class="s5">/**</span>
         <span class="s5">* Returns true if `node` is `-substring.length` or</span>
         <span class="s5">* `parentString.length - substring.length`</span>
         <span class="s5">*/</span>
        <span class="s2">function </span><span class="s1">isLengthAheadOfEnd(node, substring, parentString) {</span>
            <span class="s2">return </span><span class="s1">((node.type === utils_1.AST_NODE_TYPES.UnaryExpression &amp;&amp;</span>
                <span class="s1">node.operator === </span><span class="s0">'-' </span><span class="s1">&amp;&amp;</span>
                <span class="s1">isLengthExpression(node.argument, substring)) ||</span>
                <span class="s1">(node.type === utils_1.AST_NODE_TYPES.BinaryExpression &amp;&amp;</span>
                    <span class="s1">node.operator === </span><span class="s0">'-' </span><span class="s1">&amp;&amp;</span>
                    <span class="s1">isLengthExpression(node.left, parentString) &amp;&amp;</span>
                    <span class="s1">isLengthExpression(node.right, substring)));</span>
        <span class="s1">}</span>
        <span class="s5">/**</span>
         <span class="s5">* Check if a given node is the expression of the last index.</span>
         <span class="s5">*</span>
         <span class="s5">* E.g. `foo.length - 1`</span>
         <span class="s5">*</span>
         <span class="s5">* </span><span class="s6">@param </span><span class="s5">node The node to check.</span>
         <span class="s5">* </span><span class="s6">@param </span><span class="s5">expectedObjectNode The node which is expected as the receiver of `length` property.</span>
         <span class="s5">*/</span>
        <span class="s2">function </span><span class="s1">isLastIndexExpression(node, expectedObjectNode) {</span>
            <span class="s2">return </span><span class="s1">(node.type === utils_1.AST_NODE_TYPES.BinaryExpression &amp;&amp;</span>
                <span class="s1">node.operator === </span><span class="s0">'-' </span><span class="s1">&amp;&amp;</span>
                <span class="s1">isLengthExpression(node.left, expectedObjectNode) &amp;&amp;</span>
                <span class="s1">isNumber(node.right, </span><span class="s4">1</span><span class="s1">));</span>
        <span class="s1">}</span>
        <span class="s5">/**</span>
         <span class="s5">* Get the range of the property of a given `MemberExpression` node.</span>
         <span class="s5">*</span>
         <span class="s5">* - `obj[foo]` → the range of `[foo]`</span>
         <span class="s5">* - `obf.foo` → the range of `.foo`</span>
         <span class="s5">* - `(obj).foo` → the range of `.foo`</span>
         <span class="s5">*</span>
         <span class="s5">* </span><span class="s6">@param </span><span class="s5">node The member expression node to get.</span>
         <span class="s5">*/</span>
        <span class="s2">function </span><span class="s1">getPropertyRange(node) {</span>
            <span class="s2">const </span><span class="s1">dotOrOpenBracket = (</span><span class="s4">0</span><span class="s1">, util_1.nullThrows)(context.sourceCode.getTokenAfter(node.object, util_1.isNotClosingParenToken), util_1.NullThrowsReasons.MissingToken(</span><span class="s0">'closing parenthesis'</span><span class="s1">, </span><span class="s0">'member'</span><span class="s1">));</span>
            <span class="s2">return </span><span class="s1">[dotOrOpenBracket.range[</span><span class="s4">0</span><span class="s1">], node.range[</span><span class="s4">1</span><span class="s1">]];</span>
        <span class="s1">}</span>
        <span class="s5">/**</span>
         <span class="s5">* Parse a given `RegExp` pattern to that string if it's a static string.</span>
         <span class="s5">* </span><span class="s6">@param </span><span class="s5">pattern The RegExp pattern text to parse.</span>
         <span class="s5">* </span><span class="s6">@param </span><span class="s5">unicode Whether the RegExp is unicode.</span>
         <span class="s5">*/</span>
        <span class="s2">function </span><span class="s1">parseRegExpText(pattern, unicode) {</span>
            <span class="s5">// Parse it.</span>
            <span class="s2">const </span><span class="s1">ast = regexpp.parsePattern(pattern, undefined, undefined, {</span>
                <span class="s1">unicode,</span>
            <span class="s1">});</span>
            <span class="s2">if </span><span class="s1">(ast.alternatives.length !== </span><span class="s4">1</span><span class="s1">) {</span>
                <span class="s2">return null</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s5">// Drop `^`/`$` assertion.</span>
            <span class="s2">const </span><span class="s1">chars = ast.alternatives[</span><span class="s4">0</span><span class="s1">].elements;</span>
            <span class="s2">const </span><span class="s1">first = chars[</span><span class="s4">0</span><span class="s1">];</span>
            <span class="s2">if </span><span class="s1">(first.type === </span><span class="s0">'Assertion' </span><span class="s1">&amp;&amp; first.kind === </span><span class="s0">'start'</span><span class="s1">) {</span>
                <span class="s1">chars.shift();</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s1">chars.pop();</span>
            <span class="s1">}</span>
            <span class="s5">// Check if it can determine a unique string.</span>
            <span class="s2">if </span><span class="s1">(!chars.every(c =&gt; c.type === </span><span class="s0">'Character'</span><span class="s1">)) {</span>
                <span class="s2">return null</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s5">// To string.</span>
            <span class="s2">return </span><span class="s1">String.fromCodePoint(...chars.map(c =&gt; c.value));</span>
        <span class="s1">}</span>
        <span class="s5">/**</span>
         <span class="s5">* Parse a given node if it's a `RegExp` instance.</span>
         <span class="s5">* </span><span class="s6">@param </span><span class="s5">node The node to parse.</span>
         <span class="s5">*/</span>
        <span class="s2">function </span><span class="s1">parseRegExp(node) {</span>
            <span class="s2">const </span><span class="s1">evaluated = (</span><span class="s4">0</span><span class="s1">, util_1.getStaticValue)(node, globalScope);</span>
            <span class="s2">if </span><span class="s1">(evaluated == </span><span class="s2">null </span><span class="s1">|| !(evaluated.value </span><span class="s2">instanceof </span><span class="s1">RegExp)) {</span>
                <span class="s2">return null</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">{ flags, source } = evaluated.value;</span>
            <span class="s2">const </span><span class="s1">isStartsWith = source.startsWith(</span><span class="s0">'^'</span><span class="s1">);</span>
            <span class="s2">const </span><span class="s1">isEndsWith = source.endsWith(</span><span class="s0">'$'</span><span class="s1">);</span>
            <span class="s2">if </span><span class="s1">(isStartsWith === isEndsWith ||</span>
                <span class="s1">flags.includes(</span><span class="s0">'i'</span><span class="s1">) ||</span>
                <span class="s1">flags.includes(</span><span class="s0">'m'</span><span class="s1">)) {</span>
                <span class="s2">return null</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">text = parseRegExpText(source, flags.includes(</span><span class="s0">'u'</span><span class="s1">));</span>
            <span class="s2">if </span><span class="s1">(text == </span><span class="s2">null</span><span class="s1">) {</span>
                <span class="s2">return null</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">{ isEndsWith, isStartsWith, text };</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">getLeftNode(init) {</span>
            <span class="s2">const </span><span class="s1">node = (</span><span class="s4">0</span><span class="s1">, util_1.skipChainExpression)(init);</span>
            <span class="s2">const </span><span class="s1">leftNode = node.type === utils_1.AST_NODE_TYPES.CallExpression ? node.callee : node;</span>
            <span class="s2">if </span><span class="s1">(leftNode.type !== utils_1.AST_NODE_TYPES.MemberExpression) {</span>
                <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">`Expected a MemberExpression, got </span><span class="s1">${leftNode.type}</span><span class="s0">`</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">leftNode;</span>
        <span class="s1">}</span>
        <span class="s5">/**</span>
         <span class="s5">* Fix code with using the right operand as the search string.</span>
         <span class="s5">* For example: `foo.slice(0, 3) === 'bar'` → `foo.startsWith('bar')`</span>
         <span class="s5">* </span><span class="s6">@param </span><span class="s5">fixer The rule fixer.</span>
         <span class="s5">* </span><span class="s6">@param </span><span class="s5">node The node which was reported.</span>
         <span class="s5">* </span><span class="s6">@param </span><span class="s5">kind The kind of the report.</span>
         <span class="s5">* </span><span class="s6">@param </span><span class="s5">isNegative The flag to fix to negative condition.</span>
         <span class="s5">*/</span>
        <span class="s2">function</span><span class="s1">* fixWithRightOperand(fixer, node, kind, isNegative, isOptional) {</span>
            <span class="s5">// left is CallExpression or MemberExpression.</span>
            <span class="s2">const </span><span class="s1">leftNode = getLeftNode(node.left);</span>
            <span class="s2">const </span><span class="s1">propertyRange = getPropertyRange(leftNode);</span>
            <span class="s2">if </span><span class="s1">(isNegative) {</span>
                <span class="s2">yield </span><span class="s1">fixer.insertTextBefore(node, </span><span class="s0">'!'</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">yield </span><span class="s1">fixer.replaceTextRange([propertyRange[</span><span class="s4">0</span><span class="s1">], node.right.range[</span><span class="s4">0</span><span class="s1">]], </span><span class="s0">`</span><span class="s1">${isOptional ? </span><span class="s0">'?.' </span><span class="s1">: </span><span class="s0">'.'</span><span class="s1">}${kind}</span><span class="s0">sWith(`</span><span class="s1">);</span>
            <span class="s2">yield </span><span class="s1">fixer.replaceTextRange([node.right.range[</span><span class="s4">1</span><span class="s1">], node.range[</span><span class="s4">1</span><span class="s1">]], </span><span class="s0">')'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s5">/**</span>
         <span class="s5">* Fix code with using the first argument as the search string.</span>
         <span class="s5">* For example: `foo.indexOf('bar') === 0` → `foo.startsWith('bar')`</span>
         <span class="s5">* </span><span class="s6">@param </span><span class="s5">fixer The rule fixer.</span>
         <span class="s5">* </span><span class="s6">@param </span><span class="s5">node The node which was reported.</span>
         <span class="s5">* </span><span class="s6">@param </span><span class="s5">kind The kind of the report.</span>
         <span class="s5">* </span><span class="s6">@param </span><span class="s5">negative The flag to fix to negative condition.</span>
         <span class="s5">*/</span>
        <span class="s2">function</span><span class="s1">* fixWithArgument(fixer, node, callNode, calleeNode, kind, negative, isOptional) {</span>
            <span class="s2">if </span><span class="s1">(negative) {</span>
                <span class="s2">yield </span><span class="s1">fixer.insertTextBefore(node, </span><span class="s0">'!'</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">yield </span><span class="s1">fixer.replaceTextRange(getPropertyRange(calleeNode), </span><span class="s0">`</span><span class="s1">${isOptional ? </span><span class="s0">'?.' </span><span class="s1">: </span><span class="s0">'.'</span><span class="s1">}${kind}</span><span class="s0">sWith`</span><span class="s1">);</span>
            <span class="s2">yield </span><span class="s1">fixer.removeRange([callNode.range[</span><span class="s4">1</span><span class="s1">], node.range[</span><span class="s4">1</span><span class="s1">]]);</span>
        <span class="s1">}</span>
        <span class="s2">function </span><span class="s1">getParent(node) {</span>
            <span class="s2">return </span><span class="s1">node.parent.type === utils_1.AST_NODE_TYPES.ChainExpression</span>
                <span class="s1">? node.parent.parent</span>
                <span class="s1">: node.parent;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s5">// foo[0] === &quot;a&quot;</span>
            <span class="s5">// foo.charAt(0) === &quot;a&quot;</span>
            <span class="s5">// foo[foo.length - 1] === &quot;a&quot;</span>
            <span class="s5">// foo.charAt(foo.length - 1) === &quot;a&quot;</span>
            <span class="s1">[[</span>
                <span class="s0">'BinaryExpression &gt; MemberExpression.left[computed=true]'</span><span class="s1">,</span>
                <span class="s0">'BinaryExpression &gt; CallExpression.left &gt; MemberExpression.callee[property.name=&quot;charAt&quot;][computed=false]'</span><span class="s1">,</span>
                <span class="s0">'BinaryExpression &gt; ChainExpression.left &gt; MemberExpression[computed=true]'</span><span class="s1">,</span>
                <span class="s0">'BinaryExpression &gt; ChainExpression.left &gt; CallExpression &gt; MemberExpression.callee[property.name=&quot;charAt&quot;][computed=false]'</span><span class="s1">,</span>
            <span class="s1">].join(</span><span class="s0">', '</span><span class="s1">)](node) {</span>
                <span class="s2">let </span><span class="s1">parentNode = getParent(node);</span>
                <span class="s2">let </span><span class="s1">indexNode = </span><span class="s2">null</span><span class="s1">;</span>
                <span class="s2">if </span><span class="s1">(parentNode.type === utils_1.AST_NODE_TYPES.CallExpression) {</span>
                    <span class="s2">if </span><span class="s1">(parentNode.arguments.length === </span><span class="s4">1</span><span class="s1">) {</span>
                        <span class="s1">indexNode = parentNode.arguments[</span><span class="s4">0</span><span class="s1">];</span>
                    <span class="s1">}</span>
                    <span class="s1">parentNode = getParent(parentNode);</span>
                <span class="s1">}</span>
                <span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">indexNode = node.property;</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(indexNode == </span><span class="s2">null </span><span class="s1">||</span>
                    <span class="s1">!isEqualityComparison(parentNode) ||</span>
                    <span class="s1">!isStringType(node.object)) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">isEndsWith = isLastIndexExpression(indexNode, node.object);</span>
                <span class="s2">if </span><span class="s1">(allowSingleElementEquality === </span><span class="s0">'always' </span><span class="s1">&amp;&amp; isEndsWith) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">isStartsWith = !isEndsWith &amp;&amp; isNumber(indexNode, </span><span class="s4">0</span><span class="s1">);</span>
                <span class="s2">if </span><span class="s1">((allowSingleElementEquality === </span><span class="s0">'always' </span><span class="s1">&amp;&amp; isStartsWith) ||</span>
                    <span class="s1">(!isStartsWith &amp;&amp; !isEndsWith)) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">eqNode = parentNode;</span>
                <span class="s1">context.report({</span>
                    <span class="s1">node: parentNode,</span>
                    <span class="s1">messageId: isStartsWith ? </span><span class="s0">'preferStartsWith' </span><span class="s1">: </span><span class="s0">'preferEndsWith'</span><span class="s1">,</span>
                    <span class="s1">fix(fixer) {</span>
                        <span class="s5">// Don't fix if it can change the behavior.</span>
                        <span class="s2">if </span><span class="s1">(!isCharacter(eqNode.right)) {</span>
                            <span class="s2">return null</span><span class="s1">;</span>
                        <span class="s1">}</span>
                        <span class="s2">return </span><span class="s1">fixWithRightOperand(fixer, eqNode, isStartsWith ? </span><span class="s0">'start' </span><span class="s1">: </span><span class="s0">'end'</span><span class="s1">, eqNode.operator.startsWith(</span><span class="s0">'!'</span><span class="s1">), node.optional);</span>
                    <span class="s1">},</span>
                <span class="s1">});</span>
            <span class="s1">},</span>
            <span class="s5">// foo.indexOf('bar') === 0</span>
            <span class="s1">[[</span>
                <span class="s0">'BinaryExpression &gt; CallExpression.left &gt; MemberExpression.callee[property.name=&quot;indexOf&quot;][computed=false]'</span><span class="s1">,</span>
                <span class="s0">'BinaryExpression &gt; ChainExpression.left &gt; CallExpression &gt; MemberExpression.callee[property.name=&quot;indexOf&quot;][computed=false]'</span><span class="s1">,</span>
            <span class="s1">].join(</span><span class="s0">', '</span><span class="s1">)](node) {</span>
                <span class="s2">const </span><span class="s1">callNode = getParent(node);</span>
                <span class="s2">const </span><span class="s1">parentNode = getParent(callNode);</span>
                <span class="s2">if </span><span class="s1">(callNode.arguments.length !== </span><span class="s4">1 </span><span class="s1">||</span>
                    <span class="s1">!isEqualityComparison(parentNode) ||</span>
                    <span class="s1">!isNumber(parentNode.right, </span><span class="s4">0</span><span class="s1">) ||</span>
                    <span class="s1">!isStringType(node.object)) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">context.report({</span>
                    <span class="s1">node: parentNode,</span>
                    <span class="s1">messageId: </span><span class="s0">'preferStartsWith'</span><span class="s1">,</span>
                    <span class="s1">fix(fixer) {</span>
                        <span class="s2">return </span><span class="s1">fixWithArgument(fixer, parentNode, callNode, node, </span><span class="s0">'start'</span><span class="s1">, parentNode.operator.startsWith(</span><span class="s0">'!'</span><span class="s1">), node.optional);</span>
                    <span class="s1">},</span>
                <span class="s1">});</span>
            <span class="s1">},</span>
            <span class="s5">// foo.lastIndexOf('bar') === foo.length - 3</span>
            <span class="s5">// foo.lastIndexOf(bar) === foo.length - bar.length</span>
            <span class="s1">[[</span>
                <span class="s0">'BinaryExpression &gt; CallExpression.left &gt; MemberExpression.callee[property.name=&quot;lastIndexOf&quot;][computed=false]'</span><span class="s1">,</span>
                <span class="s0">'BinaryExpression &gt; ChainExpression.left &gt; CallExpression &gt; MemberExpression.callee[property.name=&quot;lastIndexOf&quot;][computed=false]'</span><span class="s1">,</span>
            <span class="s1">].join(</span><span class="s0">', '</span><span class="s1">)](node) {</span>
                <span class="s2">const </span><span class="s1">callNode = getParent(node);</span>
                <span class="s2">const </span><span class="s1">parentNode = getParent(callNode);</span>
                <span class="s2">if </span><span class="s1">(callNode.arguments.length !== </span><span class="s4">1 </span><span class="s1">||</span>
                    <span class="s1">!isEqualityComparison(parentNode) ||</span>
                    <span class="s1">parentNode.right.type !== utils_1.AST_NODE_TYPES.BinaryExpression ||</span>
                    <span class="s1">parentNode.right.operator !== </span><span class="s0">'-' </span><span class="s1">||</span>
                    <span class="s1">!isLengthExpression(parentNode.right.left, node.object) ||</span>
                    <span class="s1">!isLengthExpression(parentNode.right.right, callNode.arguments[</span><span class="s4">0</span><span class="s1">]) ||</span>
                    <span class="s1">!isStringType(node.object)) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">context.report({</span>
                    <span class="s1">node: parentNode,</span>
                    <span class="s1">messageId: </span><span class="s0">'preferEndsWith'</span><span class="s1">,</span>
                    <span class="s1">fix(fixer) {</span>
                        <span class="s2">return </span><span class="s1">fixWithArgument(fixer, parentNode, callNode, node, </span><span class="s0">'end'</span><span class="s1">, parentNode.operator.startsWith(</span><span class="s0">'!'</span><span class="s1">), node.optional);</span>
                    <span class="s1">},</span>
                <span class="s1">});</span>
            <span class="s1">},</span>
            <span class="s5">// foo.match(/^bar/) === null</span>
            <span class="s5">// foo.match(/bar$/) === null</span>
            <span class="s1">[[</span>
                <span class="s0">'BinaryExpression &gt; CallExpression.left &gt; MemberExpression.callee[property.name=&quot;match&quot;][computed=false]'</span><span class="s1">,</span>
                <span class="s0">'BinaryExpression &gt; ChainExpression.left &gt; CallExpression &gt; MemberExpression.callee[property.name=&quot;match&quot;][computed=false]'</span><span class="s1">,</span>
            <span class="s1">].join(</span><span class="s0">', '</span><span class="s1">)](node) {</span>
                <span class="s2">const </span><span class="s1">callNode = getParent(node);</span>
                <span class="s2">const </span><span class="s1">parentNode = getParent(callNode);</span>
                <span class="s2">if </span><span class="s1">(!isNull(parentNode.right) || !isStringType(node.object)) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">parsed = callNode.arguments.length === </span><span class="s4">1</span>
                    <span class="s1">? parseRegExp(callNode.arguments[</span><span class="s4">0</span><span class="s1">])</span>
                    <span class="s1">: </span><span class="s2">null</span><span class="s1">;</span>
                <span class="s2">if </span><span class="s1">(parsed == </span><span class="s2">null</span><span class="s1">) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">{ isStartsWith, text } = parsed;</span>
                <span class="s1">context.report({</span>
                    <span class="s1">node: callNode,</span>
                    <span class="s1">messageId: isStartsWith ? </span><span class="s0">'preferStartsWith' </span><span class="s1">: </span><span class="s0">'preferEndsWith'</span><span class="s1">,</span>
                    <span class="s1">*fix(fixer) {</span>
                        <span class="s2">if </span><span class="s1">(!parentNode.operator.startsWith(</span><span class="s0">'!'</span><span class="s1">)) {</span>
                            <span class="s2">yield </span><span class="s1">fixer.insertTextBefore(parentNode, </span><span class="s0">'!'</span><span class="s1">);</span>
                        <span class="s1">}</span>
                        <span class="s2">yield </span><span class="s1">fixer.replaceTextRange(getPropertyRange(node), </span><span class="s0">`</span><span class="s1">${node.optional ? </span><span class="s0">'?.' </span><span class="s1">: </span><span class="s0">'.'</span><span class="s1">}${isStartsWith ? </span><span class="s0">'start' </span><span class="s1">: </span><span class="s0">'end'</span><span class="s1">}</span><span class="s0">sWith`</span><span class="s1">);</span>
                        <span class="s2">yield </span><span class="s1">fixer.replaceText(callNode.arguments[</span><span class="s4">0</span><span class="s1">], JSON.stringify(text));</span>
                        <span class="s2">yield </span><span class="s1">fixer.removeRange([callNode.range[</span><span class="s4">1</span><span class="s1">], parentNode.range[</span><span class="s4">1</span><span class="s1">]]);</span>
                    <span class="s1">},</span>
                <span class="s1">});</span>
            <span class="s1">},</span>
            <span class="s5">// foo.slice(0, 3) === 'bar'</span>
            <span class="s5">// foo.slice(-3) === 'bar'</span>
            <span class="s5">// foo.slice(-3, foo.length) === 'bar'</span>
            <span class="s5">// foo.substring(0, 3) === 'bar'</span>
            <span class="s5">// foo.substring(foo.length - 3) === 'bar'</span>
            <span class="s5">// foo.substring(foo.length - 3, foo.length) === 'bar'</span>
            <span class="s1">[[</span>
                <span class="s0">'BinaryExpression &gt; CallExpression.left &gt; MemberExpression'</span><span class="s1">,</span>
                <span class="s0">'BinaryExpression &gt; ChainExpression.left &gt; CallExpression &gt; MemberExpression'</span><span class="s1">,</span>
            <span class="s1">].join(</span><span class="s0">', '</span><span class="s1">)](node) {</span>
                <span class="s2">if </span><span class="s1">(!(</span><span class="s4">0</span><span class="s1">, util_1.isStaticMemberAccessOfValue)(node, context, </span><span class="s0">'slice'</span><span class="s1">, </span><span class="s0">'substring'</span><span class="s1">)) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">callNode = getParent(node);</span>
                <span class="s2">const </span><span class="s1">parentNode = getParent(callNode);</span>
                <span class="s2">if </span><span class="s1">(!isEqualityComparison(parentNode) || !isStringType(node.object)) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">let </span><span class="s1">isEndsWith = </span><span class="s2">false</span><span class="s1">;</span>
                <span class="s2">let </span><span class="s1">isStartsWith = </span><span class="s2">false</span><span class="s1">;</span>
                <span class="s2">if </span><span class="s1">(callNode.arguments.length === </span><span class="s4">1</span><span class="s1">) {</span>
                    <span class="s2">if </span><span class="s1">(</span>
                    <span class="s5">// foo.slice(-bar.length) === bar</span>
                    <span class="s5">// foo.slice(foo.length - bar.length) === bar</span>
                    <span class="s1">isLengthAheadOfEnd(callNode.arguments[</span><span class="s4">0</span><span class="s1">], parentNode.right, node.object)) {</span>
                        <span class="s1">isEndsWith = </span><span class="s2">true</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">else if </span><span class="s1">(callNode.arguments.length === </span><span class="s4">2</span><span class="s1">) {</span>
                    <span class="s2">if </span><span class="s1">(</span>
                    <span class="s5">// foo.slice(0, bar.length) === bar</span>
                    <span class="s1">isNumber(callNode.arguments[</span><span class="s4">0</span><span class="s1">], </span><span class="s4">0</span><span class="s1">) &amp;&amp;</span>
                        <span class="s1">isLengthExpression(callNode.arguments[</span><span class="s4">1</span><span class="s1">], parentNode.right)) {</span>
                        <span class="s1">isStartsWith = </span><span class="s2">true</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s2">else if </span><span class="s1">(</span>
                    <span class="s5">// foo.slice(foo.length - bar.length, foo.length) === bar</span>
                    <span class="s5">// foo.slice(foo.length - bar.length, 0) === bar</span>
                    <span class="s5">// foo.slice(-bar.length, foo.length) === bar</span>
                    <span class="s5">// foo.slice(-bar.length, 0) === bar</span>
                    <span class="s1">(isLengthExpression(callNode.arguments[</span><span class="s4">1</span><span class="s1">], node.object) ||</span>
                        <span class="s1">isNumber(callNode.arguments[</span><span class="s4">1</span><span class="s1">], </span><span class="s4">0</span><span class="s1">)) &amp;&amp;</span>
                        <span class="s1">isLengthAheadOfEnd(callNode.arguments[</span><span class="s4">0</span><span class="s1">], parentNode.right, node.object)) {</span>
                        <span class="s1">isEndsWith = </span><span class="s2">true</span><span class="s1">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">if </span><span class="s1">(!isStartsWith &amp;&amp; !isEndsWith) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">eqNode = parentNode;</span>
                <span class="s2">const </span><span class="s1">negativeIndexSupported = node.property.name === </span><span class="s0">'slice'</span><span class="s1">;</span>
                <span class="s1">context.report({</span>
                    <span class="s1">node: parentNode,</span>
                    <span class="s1">messageId: isStartsWith ? </span><span class="s0">'preferStartsWith' </span><span class="s1">: </span><span class="s0">'preferEndsWith'</span><span class="s1">,</span>
                    <span class="s1">fix(fixer) {</span>
                        <span class="s5">// Don't fix if it can change the behavior.</span>
                        <span class="s2">if </span><span class="s1">(eqNode.operator.length === </span><span class="s4">2 </span><span class="s1">&amp;&amp;</span>
                            <span class="s1">(eqNode.right.type !== utils_1.AST_NODE_TYPES.Literal ||</span>
                                <span class="s2">typeof </span><span class="s1">eqNode.right.value !== </span><span class="s0">'string'</span><span class="s1">)) {</span>
                            <span class="s2">return null</span><span class="s1">;</span>
                        <span class="s1">}</span>
                        <span class="s5">// code being checked is likely mistake:</span>
                        <span class="s5">// unequal length of strings being checked for equality</span>
                        <span class="s5">// or reliant on behavior of substring (negative indices interpreted as 0)</span>
                        <span class="s2">if </span><span class="s1">(isStartsWith) {</span>
                            <span class="s2">if </span><span class="s1">(!isLengthExpression(callNode.arguments[</span><span class="s4">1</span><span class="s1">], eqNode.right)) {</span>
                                <span class="s2">return null</span><span class="s1">;</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                        <span class="s2">else </span><span class="s1">{</span>
                            <span class="s2">const </span><span class="s1">posNode = callNode.arguments[</span><span class="s4">0</span><span class="s1">];</span>
                            <span class="s2">const </span><span class="s1">posNodeIsAbsolutelyValid = (posNode.type === utils_1.AST_NODE_TYPES.BinaryExpression &amp;&amp;</span>
                                <span class="s1">posNode.operator === </span><span class="s0">'-' </span><span class="s1">&amp;&amp;</span>
                                <span class="s1">isLengthExpression(posNode.left, node.object) &amp;&amp;</span>
                                <span class="s1">isLengthExpression(posNode.right, eqNode.right)) ||</span>
                                <span class="s1">(negativeIndexSupported &amp;&amp;</span>
                                    <span class="s1">posNode.type === utils_1.AST_NODE_TYPES.UnaryExpression &amp;&amp;</span>
                                    <span class="s1">posNode.operator === </span><span class="s0">'-' </span><span class="s1">&amp;&amp;</span>
                                    <span class="s1">isLengthExpression(posNode.argument, eqNode.right));</span>
                            <span class="s2">if </span><span class="s1">(!posNodeIsAbsolutelyValid) {</span>
                                <span class="s2">return null</span><span class="s1">;</span>
                            <span class="s1">}</span>
                        <span class="s1">}</span>
                        <span class="s2">return </span><span class="s1">fixWithRightOperand(fixer, parentNode, isStartsWith ? </span><span class="s0">'start' </span><span class="s1">: </span><span class="s0">'end'</span><span class="s1">, parentNode.operator.startsWith(</span><span class="s0">'!'</span><span class="s1">), node.optional);</span>
                    <span class="s1">},</span>
                <span class="s1">});</span>
            <span class="s1">},</span>
            <span class="s5">// /^bar/.test(foo)</span>
            <span class="s5">// /bar$/.test(foo)</span>
            <span class="s0">'CallExpression &gt; MemberExpression.callee[property.name=&quot;test&quot;][computed=false]'</span><span class="s1">(node) {</span>
                <span class="s2">const </span><span class="s1">callNode = getParent(node);</span>
                <span class="s2">const </span><span class="s1">parsed = callNode.arguments.length === </span><span class="s4">1 </span><span class="s1">? parseRegExp(node.object) : </span><span class="s2">null</span><span class="s1">;</span>
                <span class="s2">if </span><span class="s1">(parsed == </span><span class="s2">null</span><span class="s1">) {</span>
                    <span class="s2">return</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">{ isStartsWith, text } = parsed;</span>
                <span class="s2">const </span><span class="s1">messageId = isStartsWith ? </span><span class="s0">'preferStartsWith' </span><span class="s1">: </span><span class="s0">'preferEndsWith'</span><span class="s1">;</span>
                <span class="s2">const </span><span class="s1">methodName = isStartsWith ? </span><span class="s0">'startsWith' </span><span class="s1">: </span><span class="s0">'endsWith'</span><span class="s1">;</span>
                <span class="s1">context.report({</span>
                    <span class="s1">node: callNode,</span>
                    <span class="s1">messageId,</span>
                    <span class="s1">*fix(fixer) {</span>
                        <span class="s2">const </span><span class="s1">argNode = callNode.arguments[</span><span class="s4">0</span><span class="s1">];</span>
                        <span class="s2">const </span><span class="s1">needsParen = argNode.type !== utils_1.AST_NODE_TYPES.Literal &amp;&amp;</span>
                            <span class="s1">argNode.type !== utils_1.AST_NODE_TYPES.TemplateLiteral &amp;&amp;</span>
                            <span class="s1">argNode.type !== utils_1.AST_NODE_TYPES.Identifier &amp;&amp;</span>
                            <span class="s1">argNode.type !== utils_1.AST_NODE_TYPES.MemberExpression &amp;&amp;</span>
                            <span class="s1">argNode.type !== utils_1.AST_NODE_TYPES.CallExpression;</span>
                        <span class="s2">yield </span><span class="s1">fixer.removeRange([callNode.range[</span><span class="s4">0</span><span class="s1">], argNode.range[</span><span class="s4">0</span><span class="s1">]]);</span>
                        <span class="s2">if </span><span class="s1">(needsParen) {</span>
                            <span class="s2">yield </span><span class="s1">fixer.insertTextBefore(argNode, </span><span class="s0">'('</span><span class="s1">);</span>
                            <span class="s2">yield </span><span class="s1">fixer.insertTextAfter(argNode, </span><span class="s0">')'</span><span class="s1">);</span>
                        <span class="s1">}</span>
                        <span class="s2">yield </span><span class="s1">fixer.insertTextAfter(argNode, </span><span class="s0">`</span><span class="s1">${node.optional ? </span><span class="s0">'?.' </span><span class="s1">: </span><span class="s0">'.'</span><span class="s1">}${methodName}</span><span class="s0">(</span><span class="s1">${JSON.stringify(text)}</span><span class="s0">`</span><span class="s1">);</span>
                    <span class="s1">},</span>
                <span class="s1">});</span>
            <span class="s1">},</span>
        <span class="s1">};</span>
    <span class="s1">},</span>
<span class="s1">});</span>
</pre>
</body>
</html>