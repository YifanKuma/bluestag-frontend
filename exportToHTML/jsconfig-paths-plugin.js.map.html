<html>
<head>
<title>jsconfig-paths-plugin.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
jsconfig-paths-plugin.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../src/build/webpack/plugins/jsconfig-paths-plugin.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* This webpack resolver is largely based on TypeScript's </span><span class="s3">\&quot;</span><span class="s1">paths</span><span class="s3">\&quot; </span><span class="s1">handling</span><span class="s3">\n </span><span class="s1">* The TypeScript license can be found here:</span><span class="s3">\n </span><span class="s1">* https://github.com/microsoft/TypeScript/blob/214df64e287804577afa1fea0184c18c40f7d1ca/LICENSE.txt</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">import path from 'path'</span><span class="s3">\n</span><span class="s1">import type { webpack } from 'next/dist/compiled/webpack/webpack'</span><span class="s3">\n</span><span class="s1">import { debug } from 'next/dist/compiled/debug'</span><span class="s3">\n</span><span class="s1">import type { ResolvedBaseUrl } from '../../load-jsconfig'</span><span class="s3">\n\n</span><span class="s1">const log = debug('next:jsconfig-paths-plugin')</span><span class="s3">\n\n</span><span class="s1">export interface Pattern {</span><span class="s3">\n  </span><span class="s1">prefix: string</span><span class="s3">\n  </span><span class="s1">suffix: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const asterisk = 0x2a</span><span class="s3">\n\n</span><span class="s1">export function hasZeroOrOneAsteriskCharacter(str: string): boolean {</span><span class="s3">\n  </span><span class="s1">let seenAsterisk = false</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; str.length; i++) {</span><span class="s3">\n    </span><span class="s1">if (str.charCodeAt(i) === asterisk) {</span><span class="s3">\n      </span><span class="s1">if (!seenAsterisk) {</span><span class="s3">\n        </span><span class="s1">seenAsterisk = true</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// have already seen asterisk</span><span class="s3">\n        </span><span class="s1">return false</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return true</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Determines whether a path starts with a relative path component (i.e. `.` or `..`).</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function pathIsRelative(testPath: string): boolean {</span><span class="s3">\n  </span><span class="s1">return /^</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">.?($|[</span><span class="s3">\\\\</span><span class="s1">/])/.test(testPath)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function tryParsePattern(pattern: string): Pattern | undefined {</span><span class="s3">\n  </span><span class="s1">// This should be verified outside of here and a proper error thrown.</span><span class="s3">\n  </span><span class="s1">const indexOfStar = pattern.indexOf('*')</span><span class="s3">\n  </span><span class="s1">return indexOfStar === -1</span><span class="s3">\n    </span><span class="s1">? undefined</span><span class="s3">\n    </span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">prefix: pattern.slice(0, indexOfStar),</span><span class="s3">\n        </span><span class="s1">suffix: pattern.slice(indexOfStar + 1),</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isPatternMatch({ prefix, suffix }: Pattern, candidate: string) {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">candidate.length &gt;= prefix.length + suffix.length &amp;&amp;</span><span class="s3">\n    </span><span class="s1">candidate.startsWith(prefix) &amp;&amp;</span><span class="s3">\n    </span><span class="s1">candidate.endsWith(suffix)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/** Return the object corresponding to the best pattern to match `candidate`. */</span><span class="s3">\n</span><span class="s1">export function findBestPatternMatch&lt;T&gt;(</span><span class="s3">\n  </span><span class="s1">values: readonly T[],</span><span class="s3">\n  </span><span class="s1">getPattern: (value: T) =&gt; Pattern,</span><span class="s3">\n  </span><span class="s1">candidate: string</span><span class="s3">\n</span><span class="s1">): T | undefined {</span><span class="s3">\n  </span><span class="s1">let matchedValue: T | undefined</span><span class="s3">\n  </span><span class="s1">// use length of prefix as betterness criteria</span><span class="s3">\n  </span><span class="s1">let longestMatchPrefixLength = -1</span><span class="s3">\n\n  </span><span class="s1">for (const v of values) {</span><span class="s3">\n    </span><span class="s1">const pattern = getPattern(v)</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">isPatternMatch(pattern, candidate) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">pattern.prefix.length &gt; longestMatchPrefixLength</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">longestMatchPrefixLength = pattern.prefix.length</span><span class="s3">\n      </span><span class="s1">matchedValue = v</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return matchedValue</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* patternStrings contains both pattern strings (containing </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">) and regular strings.</span><span class="s3">\n </span><span class="s1">* Return an exact match if possible, or a pattern match, or undefined.</span><span class="s3">\n </span><span class="s1">* (These are verified by verifyCompilerOptions to have 0 or 1 </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot; </span><span class="s1">characters.)</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function matchPatternOrExact(</span><span class="s3">\n  </span><span class="s1">patternStrings: readonly string[],</span><span class="s3">\n  </span><span class="s1">candidate: string</span><span class="s3">\n</span><span class="s1">): string | Pattern | undefined {</span><span class="s3">\n  </span><span class="s1">const patterns: Pattern[] = []</span><span class="s3">\n  </span><span class="s1">for (const patternString of patternStrings) {</span><span class="s3">\n    </span><span class="s1">if (!hasZeroOrOneAsteriskCharacter(patternString)) continue</span><span class="s3">\n    </span><span class="s1">const pattern = tryParsePattern(patternString)</span><span class="s3">\n    </span><span class="s1">if (pattern) {</span><span class="s3">\n      </span><span class="s1">patterns.push(pattern)</span><span class="s3">\n    </span><span class="s1">} else if (patternString === candidate) {</span><span class="s3">\n      </span><span class="s1">// pattern was matched as is - no need to search further</span><span class="s3">\n      </span><span class="s1">return patternString</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return findBestPatternMatch(patterns, (_) =&gt; _, candidate)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests whether a value is string</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isString(text: unknown): text is string {</span><span class="s3">\n  </span><span class="s1">return typeof text === 'string'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Given that candidate matches pattern, returns the text matching the '*'.</span><span class="s3">\n </span><span class="s1">* E.g.: matchedText(tryParsePattern(</span><span class="s3">\&quot;</span><span class="s1">foo*baz</span><span class="s3">\&quot;</span><span class="s1">), </span><span class="s3">\&quot;</span><span class="s1">foobarbaz</span><span class="s3">\&quot;</span><span class="s1">) === </span><span class="s3">\&quot;</span><span class="s1">bar</span><span class="s3">\&quot;\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function matchedText(pattern: Pattern, candidate: string): string {</span><span class="s3">\n  </span><span class="s1">return candidate.substring(</span><span class="s3">\n    </span><span class="s1">pattern.prefix.length,</span><span class="s3">\n    </span><span class="s1">candidate.length - pattern.suffix.length</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function patternText({ prefix, suffix }: Pattern): string {</span><span class="s3">\n  </span><span class="s1">return `${prefix}*${suffix}`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Calls the iterator function for each entry of the array</span><span class="s3">\n </span><span class="s1">* until the first result or error is reached</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function forEachBail&lt;TEntry&gt;(</span><span class="s3">\n  </span><span class="s1">array: TEntry[],</span><span class="s3">\n  </span><span class="s1">iterator: (</span><span class="s3">\n    </span><span class="s1">entry: TEntry,</span><span class="s3">\n    </span><span class="s1">entryCallback: (err?: any, result?: any) =&gt; void</span><span class="s3">\n  </span><span class="s1">) =&gt; void,</span><span class="s3">\n  </span><span class="s1">callback: (err?: any, result?: any) =&gt; void</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">if (array.length === 0) return callback()</span><span class="s3">\n\n  </span><span class="s1">let i = 0</span><span class="s3">\n  </span><span class="s1">const next = () =&gt; {</span><span class="s3">\n    </span><span class="s1">let loop: boolean | undefined = undefined</span><span class="s3">\n    </span><span class="s1">iterator(array[i++], (err, result) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (err || result !== undefined || i &gt;= array.length) {</span><span class="s3">\n        </span><span class="s1">return callback(err, result)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (loop === false) while (next());</span><span class="s3">\n      </span><span class="s1">loop = true</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">if (!loop) loop = false</span><span class="s3">\n    </span><span class="s1">return loop</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">while (next());</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const NODE_MODULES_REGEX = /node_modules/</span><span class="s3">\n\n</span><span class="s1">type Paths = { [match: string]: string[] }</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Handles tsconfig.json or jsconfig.js </span><span class="s3">\&quot;</span><span class="s1">paths</span><span class="s3">\&quot; </span><span class="s1">option for webpack</span><span class="s3">\n </span><span class="s1">* Largely based on how the TypeScript compiler handles it:</span><span class="s3">\n </span><span class="s1">* https://github.com/microsoft/TypeScript/blob/1a9c8197fffe3dace5f8dca6633d450a88cba66d/src/compiler/moduleNameResolver.ts#L1362</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">type NonFunction&lt;T&gt; = T extends Function ? never : T</span><span class="s3">\n\n</span><span class="s1">// Pick the object type of ResolvePluginInstance</span><span class="s3">\n</span><span class="s1">type ResolvePluginPlugin = NonFunction&lt;webpack.ResolvePluginInstance&gt;</span><span class="s3">\n</span><span class="s1">export class JsConfigPathsPlugin implements ResolvePluginPlugin {</span><span class="s3">\n  </span><span class="s1">paths: Paths</span><span class="s3">\n  </span><span class="s1">resolvedBaseUrl: ResolvedBaseUrl</span><span class="s3">\n  </span><span class="s1">jsConfigPlugin: true</span><span class="s3">\n\n  </span><span class="s1">constructor(paths: Paths, resolvedBaseUrl: ResolvedBaseUrl) {</span><span class="s3">\n    </span><span class="s1">this.paths = paths</span><span class="s3">\n    </span><span class="s1">this.resolvedBaseUrl = resolvedBaseUrl</span><span class="s3">\n    </span><span class="s1">this.jsConfigPlugin = true</span><span class="s3">\n    </span><span class="s1">log('tsconfig.json or jsconfig.json paths: %O', paths)</span><span class="s3">\n    </span><span class="s1">log('resolved baseUrl: %s', resolvedBaseUrl)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">apply(resolver: webpack.Resolver) {</span><span class="s3">\n    </span><span class="s1">const target = resolver.ensureHook('resolve')</span><span class="s3">\n    </span><span class="s1">resolver</span><span class="s3">\n      </span><span class="s1">.getHook('described-resolve')</span><span class="s3">\n      </span><span class="s1">.tapAsync(</span><span class="s3">\n        </span><span class="s1">'JsConfigPathsPlugin',</span><span class="s3">\n        </span><span class="s1">(</span><span class="s3">\n          </span><span class="s1">request: any,</span><span class="s3">\n          </span><span class="s1">resolveContext: any,</span><span class="s3">\n          </span><span class="s1">callback: (err?: any, result?: any) =&gt; void</span><span class="s3">\n        </span><span class="s1">) =&gt; {</span><span class="s3">\n          </span><span class="s1">const resolvedBaseUrl = this.resolvedBaseUrl</span><span class="s3">\n          </span><span class="s1">if (resolvedBaseUrl === undefined) {</span><span class="s3">\n            </span><span class="s1">return callback()</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">const paths = this.paths</span><span class="s3">\n          </span><span class="s1">const pathsKeys = Object.keys(paths)</span><span class="s3">\n\n          </span><span class="s1">// If no aliases are added bail out</span><span class="s3">\n          </span><span class="s1">if (pathsKeys.length === 0) {</span><span class="s3">\n            </span><span class="s1">log('paths are empty, bailing out')</span><span class="s3">\n            </span><span class="s1">return callback()</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">const moduleName = request.request</span><span class="s3">\n\n          </span><span class="s1">// Exclude node_modules from paths support (speeds up resolving)</span><span class="s3">\n          </span><span class="s1">if (request.path.match(NODE_MODULES_REGEX)) {</span><span class="s3">\n            </span><span class="s1">log('skipping request as it is inside node_modules %s', moduleName)</span><span class="s3">\n            </span><span class="s1">return callback()</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">if (</span><span class="s3">\n            </span><span class="s1">path.posix.isAbsolute(moduleName) ||</span><span class="s3">\n            </span><span class="s1">(process.platform === 'win32' &amp;&amp; path.win32.isAbsolute(moduleName))</span><span class="s3">\n          </span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">log('skipping request as it is an absolute path %s', moduleName)</span><span class="s3">\n            </span><span class="s1">return callback()</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">if (pathIsRelative(moduleName)) {</span><span class="s3">\n            </span><span class="s1">log('skipping request as it is a relative path %s', moduleName)</span><span class="s3">\n            </span><span class="s1">return callback()</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">// log('starting to resolve request %s', moduleName)</span><span class="s3">\n\n          </span><span class="s1">// If the module name does not match any of the patterns in `paths` we hand off resolving to webpack</span><span class="s3">\n          </span><span class="s1">const matchedPattern = matchPatternOrExact(pathsKeys, moduleName)</span><span class="s3">\n          </span><span class="s1">if (!matchedPattern) {</span><span class="s3">\n            </span><span class="s1">log('moduleName did not match any paths pattern %s', moduleName)</span><span class="s3">\n            </span><span class="s1">return callback()</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">const matchedStar = isString(matchedPattern)</span><span class="s3">\n            </span><span class="s1">? undefined</span><span class="s3">\n            </span><span class="s1">: matchedText(matchedPattern, moduleName)</span><span class="s3">\n          </span><span class="s1">const matchedPatternText = isString(matchedPattern)</span><span class="s3">\n            </span><span class="s1">? matchedPattern</span><span class="s3">\n            </span><span class="s1">: patternText(matchedPattern)</span><span class="s3">\n\n          </span><span class="s1">let triedPaths = []</span><span class="s3">\n\n          </span><span class="s1">forEachBail(</span><span class="s3">\n            </span><span class="s1">paths[matchedPatternText],</span><span class="s3">\n            </span><span class="s1">(subst, pathCallback) =&gt; {</span><span class="s3">\n              </span><span class="s1">const curPath = matchedStar</span><span class="s3">\n                </span><span class="s1">? subst.replace('*', matchedStar)</span><span class="s3">\n                </span><span class="s1">: subst</span><span class="s3">\n              </span><span class="s1">// Ensure .d.ts is not matched</span><span class="s3">\n              </span><span class="s1">if (curPath.endsWith('.d.ts')) {</span><span class="s3">\n                </span><span class="s1">// try next path candidate</span><span class="s3">\n                </span><span class="s1">return pathCallback()</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">const candidate = path.join(resolvedBaseUrl.baseUrl, curPath)</span><span class="s3">\n              </span><span class="s1">const obj = Object.assign({}, request, {</span><span class="s3">\n                </span><span class="s1">request: candidate,</span><span class="s3">\n              </span><span class="s1">})</span><span class="s3">\n              </span><span class="s1">resolver.doResolve(</span><span class="s3">\n                </span><span class="s1">target,</span><span class="s3">\n                </span><span class="s1">obj,</span><span class="s3">\n                </span><span class="s1">`Aliased with tsconfig.json or jsconfig.json ${matchedPatternText} to ${candidate}`,</span><span class="s3">\n                </span><span class="s1">resolveContext,</span><span class="s3">\n                </span><span class="s1">(resolverErr: any, resolverResult: any) =&gt; {</span><span class="s3">\n                  </span><span class="s1">if (resolverErr || resolverResult === undefined) {</span><span class="s3">\n                    </span><span class="s1">triedPaths.push(candidate)</span><span class="s3">\n                    </span><span class="s1">// try next path candidate</span><span class="s3">\n                    </span><span class="s1">return pathCallback()</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                  </span><span class="s1">return pathCallback(resolverErr, resolverResult)</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">callback</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;JsConfigPathsPlugin&quot;</span><span class="s0">,</span><span class="s1">&quot;findBestPatternMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;hasZeroOrOneAsteriskCharacter&quot;</span><span class="s0">,</span><span class="s1">&quot;isString&quot;</span><span class="s0">,</span><span class="s1">&quot;matchPatternOrExact&quot;</span><span class="s0">,</span><span class="s1">&quot;matchedText&quot;</span><span class="s0">,</span><span class="s1">&quot;pathIsRelative&quot;</span><span class="s0">,</span><span class="s1">&quot;patternText&quot;</span><span class="s0">,</span><span class="s1">&quot;tryParsePattern&quot;</span><span class="s0">,</span><span class="s1">&quot;log&quot;</span><span class="s0">,</span><span class="s1">&quot;debug&quot;</span><span class="s0">,</span><span class="s1">&quot;asterisk&quot;</span><span class="s0">,</span><span class="s1">&quot;str&quot;</span><span class="s0">,</span><span class="s1">&quot;seenAsterisk&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;charCodeAt&quot;</span><span class="s0">,</span><span class="s1">&quot;testPath&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;pattern&quot;</span><span class="s0">,</span><span class="s1">&quot;indexOfStar&quot;</span><span class="s0">,</span><span class="s1">&quot;indexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;prefix&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;suffix&quot;</span><span class="s0">,</span><span class="s1">&quot;isPatternMatch&quot;</span><span class="s0">,</span><span class="s1">&quot;candidate&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;endsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;values&quot;</span><span class="s0">,</span><span class="s1">&quot;getPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;matchedValue&quot;</span><span class="s0">,</span><span class="s1">&quot;longestMatchPrefixLength&quot;</span><span class="s0">,</span><span class="s1">&quot;v&quot;</span><span class="s0">,</span><span class="s1">&quot;patternStrings&quot;</span><span class="s0">,</span><span class="s1">&quot;patterns&quot;</span><span class="s0">,</span><span class="s1">&quot;patternString&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;_&quot;</span><span class="s0">,</span><span class="s1">&quot;text&quot;</span><span class="s0">,</span><span class="s1">&quot;substring&quot;</span><span class="s0">,</span><span class="s1">&quot;forEachBail&quot;</span><span class="s0">,</span><span class="s1">&quot;array&quot;</span><span class="s0">,</span><span class="s1">&quot;iterator&quot;</span><span class="s0">,</span><span class="s1">&quot;callback&quot;</span><span class="s0">,</span><span class="s1">&quot;next&quot;</span><span class="s0">,</span><span class="s1">&quot;loop&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_MODULES_REGEX&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;paths&quot;</span><span class="s0">,</span><span class="s1">&quot;resolvedBaseUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;jsConfigPlugin&quot;</span><span class="s0">,</span><span class="s1">&quot;apply&quot;</span><span class="s0">,</span><span class="s1">&quot;resolver&quot;</span><span class="s0">,</span><span class="s1">&quot;target&quot;</span><span class="s0">,</span><span class="s1">&quot;ensureHook&quot;</span><span class="s0">,</span><span class="s1">&quot;getHook&quot;</span><span class="s0">,</span><span class="s1">&quot;tapAsync&quot;</span><span class="s0">,</span><span class="s1">&quot;request&quot;</span><span class="s0">,</span><span class="s1">&quot;resolveContext&quot;</span><span class="s0">,</span><span class="s1">&quot;pathsKeys&quot;</span><span class="s0">,</span><span class="s1">&quot;Object&quot;</span><span class="s0">,</span><span class="s1">&quot;keys&quot;</span><span class="s0">,</span><span class="s1">&quot;moduleName&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;match&quot;</span><span class="s0">,</span><span class="s1">&quot;posix&quot;</span><span class="s0">,</span><span class="s1">&quot;isAbsolute&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;platform&quot;</span><span class="s0">,</span><span class="s1">&quot;win32&quot;</span><span class="s0">,</span><span class="s1">&quot;matchedPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;matchedStar&quot;</span><span class="s0">,</span><span class="s1">&quot;matchedPatternText&quot;</span><span class="s0">,</span><span class="s1">&quot;triedPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;subst&quot;</span><span class="s0">,</span><span class="s1">&quot;pathCallback&quot;</span><span class="s0">,</span><span class="s1">&quot;curPath&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;baseUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;obj&quot;</span><span class="s0">,</span><span class="s1">&quot;assign&quot;</span><span class="s0">,</span><span class="s1">&quot;doResolve&quot;</span><span class="s0">,</span><span class="s1">&quot;resolverErr&quot;</span><span class="s0">,</span><span class="s1">&quot;resolverResult&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;AAAA;;;;CAIC;;;;;;;;;;;;;;;;;;;;;;IA0KYA,mBAAmB;eAAnBA;;IAjHGC,oBAAoB;eAApBA;;IA1CAC,6BAA6B;eAA7BA;;IA4FAC,QAAQ;eAARA;;IAtBAC,mBAAmB;eAAnBA;;IA8BAC,WAAW;eAAXA;;IAlFAC,cAAc;eAAdA;;IAyFAC,WAAW;eAAXA;;IArFAC,eAAe;eAAfA;;;6DApCC;uBAEK;;;;;;AAGtB,MAAMC,MAAMC,IAAAA,YAAK,EAAC;AAOlB,MAAMC,WAAW;AAEV,SAAST,8BAA8BU,GAAW;IACvD,IAAIC,eAAe;IACnB,IAAK,IAAIC,IAAI,GAAGA,IAAIF,IAAIG,MAAM,EAAED,IAAK;QACnC,IAAIF,IAAII,UAAU,CAACF,OAAOH,UAAU;YAClC,IAAI,CAACE,cAAc;gBACjBA,eAAe;YACjB,OAAO;gBACL,6BAA6B;gBAC7B,OAAO;YACT;QACF;IACF;IACA,OAAO;AACT;AAKO,SAASP,eAAeW,QAAgB;IAC7C,OAAO,kBAAkBC,IAAI,CAACD;AAChC;AAEO,SAAST,gBAAgBW,OAAe;IAC7C,qEAAqE;IACrE,MAAMC,cAAcD,QAAQE,OAAO,CAAC;IACpC,OAAOD,gBAAgB,CAAC,IACpBE,YACA;QACEC,QAAQJ,QAAQK,KAAK,CAAC,GAAGJ;QACzBK,QAAQN,QAAQK,KAAK,CAACJ,cAAc;IACtC;AACN;AAEA,SAASM,eAAe,EAAEH,MAAM,EAAEE,MAAM,EAAW,EAAEE,SAAiB;IACpE,OACEA,UAAUZ,MAAM,IAAIQ,OAAOR,MAAM,GAAGU,OAAOV,MAAM,IACjDY,UAAUC,UAAU,CAACL,WACrBI,UAAUE,QAAQ,CAACJ;AAEvB;AAGO,SAASxB,qBACd6B,MAAoB,EACpBC,UAAiC,EACjCJ,SAAiB;IAEjB,IAAIK;IACJ,8CAA8C;IAC9C,IAAIC,2BAA2B,CAAC;IAEhC,KAAK,MAAMC,KAAKJ,OAAQ;QACtB,MAAMX,UAAUY,WAAWG;QAC3B,IACER,eAAeP,SAASQ,cACxBR,QAAQI,MAAM,CAACR,MAAM,GAAGkB,0BACxB;YACAA,2BAA2Bd,QAAQI,MAAM,CAACR,MAAM;YAChDiB,eAAeE;QACjB;IACF;IAEA,OAAOF;AACT;AAOO,SAAS5B,oBACd+B,cAAiC,EACjCR,SAAiB;IAEjB,MAAMS,WAAsB,EAAE;IAC9B,KAAK,MAAMC,iBAAiBF,eAAgB;QAC1C,IAAI,CAACjC,8BAA8BmC,gBAAgB;QACnD,MAAMlB,UAAUX,gBAAgB6B;QAChC,IAAIlB,SAAS;YACXiB,SAASE,IAAI,CAACnB;QAChB,OAAO,IAAIkB,kBAAkBV,WAAW;YACtC,wDAAwD;YACxD,OAAOU;QACT;IACF;IAEA,OAAOpC,qBAAqBmC,UAAU,CAACG,IAAMA,GAAGZ;AAClD;AAKO,SAASxB,SAASqC,IAAa;IACpC,OAAO,OAAOA,SAAS;AACzB;AAMO,SAASnC,YAAYc,OAAgB,EAAEQ,SAAiB;IAC7D,OAAOA,UAAUc,SAAS,CACxBtB,QAAQI,MAAM,CAACR,MAAM,EACrBY,UAAUZ,MAAM,GAAGI,QAAQM,MAAM,CAACV,MAAM;AAE5C;AAEO,SAASR,YAAY,EAAEgB,MAAM,EAAEE,MAAM,EAAW;IACrD,OAAO,GAAGF,OAAO,CAAC,EAAEE,QAAQ;AAC9B;AAEA;;;CAGC,GACD,SAASiB,YACPC,KAAe,EACfC,QAGS,EACTC,QAA2C;IAE3C,IAAIF,MAAM5B,MAAM,KAAK,GAAG,OAAO8B;IAE/B,IAAI/B,IAAI;IACR,MAAMgC,OAAO;QACX,IAAIC,OAA4BzB;QAChCsB,SAASD,KAAK,CAAC7B,IAAI,EAAE,CAACkC,KAAKC;YACzB,IAAID,OAAOC,WAAW3B,aAAaR,KAAK6B,MAAM5B,MAAM,EAAE;gBACpD,OAAO8B,SAASG,KAAKC;YACvB;YACA,IAAIF,SAAS,OAAO,MAAOD;YAC3BC,OAAO;QACT;QACA,IAAI,CAACA,MAAMA,OAAO;QAClB,OAAOA;IACT;IACA,MAAOD;AACT;AAEA,MAAMI,qBAAqB;AAcpB,MAAMlD;IAKXmD,YAAYC,KAAY,EAAEC,eAAgC,CAAE;QAC1D,IAAI,CAACD,KAAK,GAAGA;QACb,IAAI,CAACC,eAAe,GAAGA;QACvB,IAAI,CAACC,cAAc,GAAG;QACtB7C,IAAI,4CAA4C2C;QAChD3C,IAAI,wBAAwB4C;IAC9B;IACAE,MAAMC,QAA0B,EAAE;QAChC,MAAMC,SAASD,SAASE,UAAU,CAAC;QACnCF,SACGG,OAAO,CAAC,qBACRC,QAAQ,CACP,uBACA,CACEC,SACAC,gBACAjB;YAEA,MAAMQ,kBAAkB,IAAI,CAACA,eAAe;YAC5C,IAAIA,oBAAoB/B,WAAW;gBACjC,OAAOuB;YACT;YACA,MAAMO,QAAQ,IAAI,CAACA,KAAK;YACxB,MAAMW,YAAYC,OAAOC,IAAI,CAACb;YAE9B,mCAAmC;YACnC,IAAIW,UAAUhD,MAAM,KAAK,GAAG;gBAC1BN,IAAI;gBACJ,OAAOoC;YACT;YAEA,MAAMqB,aAAaL,QAAQA,OAAO;YAElC,gEAAgE;YAChE,IAAIA,QAAQM,IAAI,CAACC,KAAK,CAAClB,qBAAqB;gBAC1CzC,IAAI,oDAAoDyD;gBACxD,OAAOrB;YACT;YAEA,IACEsB,aAAI,CAACE,KAAK,CAACC,UAAU,CAACJ,eACrBK,QAAQC,QAAQ,KAAK,WAAWL,aAAI,CAACM,KAAK,CAACH,UAAU,CAACJ,aACvD;gBACAzD,IAAI,iDAAiDyD;gBACrD,OAAOrB;YACT;YAEA,IAAIvC,eAAe4D,aAAa;gBAC9BzD,IAAI,gDAAgDyD;gBACpD,OAAOrB;YACT;YAEA,oDAAoD;YAEpD,oGAAoG;YACpG,MAAM6B,iBAAiBtE,oBAAoB2D,WAAWG;YACtD,IAAI,CAACQ,gBAAgB;gBACnBjE,IAAI,iDAAiDyD;gBACrD,OAAOrB;YACT;YAEA,MAAM8B,cAAcxE,SAASuE,kBACzBpD,YACAjB,YAAYqE,gBAAgBR;YAChC,MAAMU,qBAAqBzE,SAASuE,kBAChCA,iBACAnE,YAAYmE;YAEhB,IAAIG,aAAa,EAAE;YAEnBnC,YACEU,KAAK,CAACwB,mBAAmB,EACzB,CAACE,OAAOC;gBACN,MAAMC,UAAUL,cACZG,MAAMG,OAAO,CAAC,KAAKN,eACnBG;gBACJ,8BAA8B;gBAC9B,IAAIE,QAAQnD,QAAQ,CAAC,UAAU;oBAC7B,0BAA0B;oBAC1B,OAAOkD;gBACT;gBACA,MAAMpD,YAAYwC,aAAI,CAACe,IAAI,CAAC7B,gBAAgB8B,OAAO,EAAEH;gBACrD,MAAMI,MAAMpB,OAAOqB,MAAM,CAAC,CAAC,GAAGxB,SAAS;oBACrCA,SAASlC;gBACX;gBACA6B,SAAS8B,SAAS,CAChB7B,QACA2B,KACA,CAAC,4CAA4C,EAAER,mBAAmB,IAAI,EAAEjD,WAAW,EACnFmC,gBACA,CAACyB,aAAkBC;oBACjB,IAAID,eAAeC,mBAAmBlE,WAAW;wBAC/CuD,WAAWvC,IAAI,CAACX;wBAChB,0BAA0B;wBAC1B,OAAOoD;oBACT;oBACA,OAAOA,aAAaQ,aAAaC;gBACnC;YAEJ,GACA3C;QAEJ;IAEN;AACF&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>