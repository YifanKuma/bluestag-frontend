<html>
<head>
<title>i18n-provider.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
i18n-provider.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/server/lib/i18n-provider.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { DomainLocale, I18NConfig } from '../config-shared'</span><span class="s3">\n</span><span class="s1">import { getRequestMeta, type NextIncomingMessage } from '../request-meta'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The result of matching a locale aware route.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export interface LocaleAnalysisResult {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The pathname without the locale prefix (if any).</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">pathname: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The detected locale. If no locale was detected, this will be `undefined`.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">detectedLocale?: string</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* True if the locale was inferred from the default locale.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">inferredFromDefault: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">type LocaleAnalysisOptions = {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* When provided, it will be used as the default locale if the locale</span><span class="s3">\n   </span><span class="s1">* cannot be inferred from the pathname.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">defaultLocale?: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The I18NProvider is used to match locale aware routes, detect the locale from</span><span class="s3">\n </span><span class="s1">* the pathname and hostname and normalize the pathname by removing the locale</span><span class="s3">\n </span><span class="s1">* prefix.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class I18NProvider {</span><span class="s3">\n  </span><span class="s1">private readonly lowerCaseLocales: ReadonlyArray&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">private readonly lowerCaseDomains?: ReadonlyArray&lt;</span><span class="s3">\n    </span><span class="s1">DomainLocale &amp; {</span><span class="s3">\n      </span><span class="s1">// The configuration references a domain with an optional port, but the</span><span class="s3">\n      </span><span class="s1">// hostname is always the domain without the port and is used for</span><span class="s3">\n      </span><span class="s1">// matching.</span><span class="s3">\n      </span><span class="s1">hostname: string</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">&gt;</span><span class="s3">\n\n  </span><span class="s1">constructor(public readonly config: Readonly&lt;I18NConfig&gt;) {</span><span class="s3">\n    </span><span class="s1">if (!config.locales.length) {</span><span class="s3">\n      </span><span class="s1">throw new Error('Invariant: No locales provided')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.lowerCaseLocales = config.locales.map((locale) =&gt; locale.toLowerCase())</span><span class="s3">\n    </span><span class="s1">this.lowerCaseDomains = config.domains?.map((domainLocale) =&gt; {</span><span class="s3">\n      </span><span class="s1">const domain = domainLocale.domain.toLowerCase()</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">defaultLocale: domainLocale.defaultLocale.toLowerCase(),</span><span class="s3">\n        </span><span class="s1">hostname: domain.split(':', 1)[0],</span><span class="s3">\n        </span><span class="s1">domain,</span><span class="s3">\n        </span><span class="s1">locales: domainLocale.locales?.map((locale) =&gt; locale.toLowerCase()),</span><span class="s3">\n        </span><span class="s1">http: domainLocale.http,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Detects the domain locale from the hostname and the detected locale if</span><span class="s3">\n   </span><span class="s1">* provided.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param hostname The hostname to detect the domain locale from, this must be lowercased.</span><span class="s3">\n   </span><span class="s1">* @param detectedLocale The detected locale to use if the hostname does not match.</span><span class="s3">\n   </span><span class="s1">* @returns The domain locale if found, `undefined` otherwise.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public detectDomainLocale(</span><span class="s3">\n    </span><span class="s1">hostname?: string,</span><span class="s3">\n    </span><span class="s1">detectedLocale?: string</span><span class="s3">\n  </span><span class="s1">): DomainLocale | undefined {</span><span class="s3">\n    </span><span class="s1">if (!hostname || !this.lowerCaseDomains || !this.config.domains) return</span><span class="s3">\n\n    </span><span class="s1">if (detectedLocale) detectedLocale = detectedLocale.toLowerCase()</span><span class="s3">\n\n    </span><span class="s1">for (let i = 0; i &lt; this.lowerCaseDomains.length; i++) {</span><span class="s3">\n      </span><span class="s1">const domainLocale = this.lowerCaseDomains[i]</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">// We assume that the hostname is already lowercased.</span><span class="s3">\n        </span><span class="s1">domainLocale.hostname === hostname ||</span><span class="s3">\n        </span><span class="s1">// Configuration validation ensures that the locale is not repeated in</span><span class="s3">\n        </span><span class="s1">// other domains locales.</span><span class="s3">\n        </span><span class="s1">domainLocale.locales?.some((locale) =&gt; locale === detectedLocale)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return this.config.domains[i]</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Pulls the pre-computed locale and inference results from the query</span><span class="s3">\n   </span><span class="s1">* object.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param req the request object</span><span class="s3">\n   </span><span class="s1">* @param pathname the pathname that could contain a locale prefix</span><span class="s3">\n   </span><span class="s1">* @returns the locale analysis result</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public fromRequest(</span><span class="s3">\n    </span><span class="s1">req: NextIncomingMessage,</span><span class="s3">\n    </span><span class="s1">pathname: string</span><span class="s3">\n  </span><span class="s1">): LocaleAnalysisResult {</span><span class="s3">\n    </span><span class="s1">const detectedLocale = getRequestMeta(req, 'locale')</span><span class="s3">\n\n    </span><span class="s1">// If a locale was detected on the query, analyze the pathname to ensure</span><span class="s3">\n    </span><span class="s1">// that the locale matches.</span><span class="s3">\n    </span><span class="s1">if (detectedLocale) {</span><span class="s3">\n      </span><span class="s1">const analysis = this.analyze(pathname)</span><span class="s3">\n\n      </span><span class="s1">// If the analysis contained a locale we should validate it against the</span><span class="s3">\n      </span><span class="s1">// query and strip it from the pathname.</span><span class="s3">\n      </span><span class="s1">if (analysis.detectedLocale) {</span><span class="s3">\n        </span><span class="s1">if (analysis.detectedLocale !== detectedLocale) {</span><span class="s3">\n          </span><span class="s1">console.warn(</span><span class="s3">\n            </span><span class="s1">`The detected locale does not match the locale in the query. Expected to find '${detectedLocale}' in '${pathname}' but found '${analysis.detectedLocale}'}`</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">pathname = analysis.pathname</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">pathname,</span><span class="s3">\n      </span><span class="s1">detectedLocale,</span><span class="s3">\n      </span><span class="s1">inferredFromDefault:</span><span class="s3">\n        </span><span class="s1">getRequestMeta(req, 'localeInferredFromDefault') ?? false,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Analyzes the pathname for a locale and returns the pathname without it.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param pathname The pathname that could contain a locale prefix.</span><span class="s3">\n   </span><span class="s1">* @param options The options to use when matching the locale.</span><span class="s3">\n   </span><span class="s1">* @returns The matched locale and the pathname without the locale prefix</span><span class="s3">\n   </span><span class="s1">*          (if any).</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">public analyze(</span><span class="s3">\n    </span><span class="s1">pathname: string,</span><span class="s3">\n    </span><span class="s1">options: LocaleAnalysisOptions = {}</span><span class="s3">\n  </span><span class="s1">): LocaleAnalysisResult {</span><span class="s3">\n    </span><span class="s1">let detectedLocale: string | undefined = options.defaultLocale</span><span class="s3">\n\n    </span><span class="s1">// By default, we assume that the default locale was inferred if there was</span><span class="s3">\n    </span><span class="s1">// no detected locale.</span><span class="s3">\n    </span><span class="s1">let inferredFromDefault = typeof detectedLocale === 'string'</span><span class="s3">\n\n    </span><span class="s1">// The first segment will be empty, because it has a leading `/`. If</span><span class="s3">\n    </span><span class="s1">// there is no further segment, there is no locale (or it's the default).</span><span class="s3">\n    </span><span class="s1">const segments = pathname.split('/', 2)</span><span class="s3">\n    </span><span class="s1">if (!segments[1])</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">detectedLocale,</span><span class="s3">\n        </span><span class="s1">pathname,</span><span class="s3">\n        </span><span class="s1">inferredFromDefault,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// The second segment will contain the locale part if any.</span><span class="s3">\n    </span><span class="s1">const segment = segments[1].toLowerCase()</span><span class="s3">\n\n    </span><span class="s1">// See if the segment matches one of the locales. If it doesn't, there is</span><span class="s3">\n    </span><span class="s1">// no locale (or it's the default).</span><span class="s3">\n    </span><span class="s1">const index = this.lowerCaseLocales.indexOf(segment)</span><span class="s3">\n    </span><span class="s1">if (index &lt; 0)</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">detectedLocale,</span><span class="s3">\n        </span><span class="s1">pathname,</span><span class="s3">\n        </span><span class="s1">inferredFromDefault,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Return the case-sensitive locale.</span><span class="s3">\n    </span><span class="s1">detectedLocale = this.config.locales[index]</span><span class="s3">\n    </span><span class="s1">inferredFromDefault = false</span><span class="s3">\n\n    </span><span class="s1">// Remove the `/${locale}` part of the pathname.</span><span class="s3">\n    </span><span class="s1">pathname = pathname.slice(detectedLocale.length + 1) || '/'</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">detectedLocale,</span><span class="s3">\n      </span><span class="s1">pathname,</span><span class="s3">\n      </span><span class="s1">inferredFromDefault,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;I18NProvider&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;config&quot;</span><span class="s0">,</span><span class="s1">&quot;locales&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;lowerCaseLocales&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;locale&quot;</span><span class="s0">,</span><span class="s1">&quot;toLowerCase&quot;</span><span class="s0">,</span><span class="s1">&quot;lowerCaseDomains&quot;</span><span class="s0">,</span><span class="s1">&quot;domains&quot;</span><span class="s0">,</span><span class="s1">&quot;domainLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;domain&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;hostname&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;http&quot;</span><span class="s0">,</span><span class="s1">&quot;detectDomainLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;detectedLocale&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;some&quot;</span><span class="s0">,</span><span class="s1">&quot;fromRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;req&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;getRequestMeta&quot;</span><span class="s0">,</span><span class="s1">&quot;analysis&quot;</span><span class="s0">,</span><span class="s1">&quot;analyze&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;warn&quot;</span><span class="s0">,</span><span class="s1">&quot;inferredFromDefault&quot;</span><span class="s0">,</span><span class="s1">&quot;options&quot;</span><span class="s0">,</span><span class="s1">&quot;segments&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;index&quot;</span><span class="s0">,</span><span class="s1">&quot;indexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>