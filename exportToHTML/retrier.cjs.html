<html>
<head>
<title>retrier.cjs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #8c8c8c; font-style: italic;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #0033b3;}
.s5 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
retrier.cjs</font>
</center></td></tr></table>
<pre><span class="s0">'use strict'</span><span class="s1">;</span>

<span class="s2">/**</span>
 <span class="s2">* </span><span class="s3">@fileoverview </span><span class="s2">A utility for retrying failed async method calls.</span>
 <span class="s2">*/</span>

<span class="s2">/* global setTimeout, clearTimeout */</span>

<span class="s2">//-----------------------------------------------------------------------------</span>
<span class="s2">// Constants</span>
<span class="s2">//-----------------------------------------------------------------------------</span>

<span class="s4">const </span><span class="s1">MAX_TASK_TIMEOUT = </span><span class="s5">60000</span><span class="s1">;</span>
<span class="s4">const </span><span class="s1">MAX_TASK_DELAY = </span><span class="s5">100</span><span class="s1">;</span>
<span class="s4">const </span><span class="s1">MAX_CONCURRENCY = </span><span class="s5">1000</span><span class="s1">;</span>

<span class="s2">//-----------------------------------------------------------------------------</span>
<span class="s2">// Helpers</span>
<span class="s2">//-----------------------------------------------------------------------------</span>

<span class="s2">/**</span>
 <span class="s2">* Logs a message to the console if the DEBUG environment variable is set.</span>
 <span class="s2">* </span><span class="s3">@param </span><span class="s2">{string} message The message to log.</span>
 <span class="s2">* </span><span class="s3">@returns </span><span class="s2">{void}</span>
 <span class="s2">*/</span>
<span class="s4">function </span><span class="s1">debug(message) {</span>
    <span class="s4">if </span><span class="s1">(globalThis?.process?.env.DEBUG === </span><span class="s0">&quot;@hwc/retry&quot;</span><span class="s1">) {</span>
        <span class="s1">console.debug(message);</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">/* 
 * The following logic has been extracted from graceful-fs. 
 * 
 * The ISC License 
 * 
 * Copyright (c) 2011-2023 Isaac Z. Schlueter, Ben Noordhuis, and Contributors 
 * 
 * Permission to use, copy, modify, and/or distribute this software for any 
 * purpose with or without fee is hereby granted, provided that the above 
 * copyright notice and this permission notice appear in all copies. 
 * 
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES 
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF 
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR 
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES 
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN 
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR 
 * IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. 
 */</span>

<span class="s2">/**</span>
 <span class="s2">* Checks if it is time to retry a task based on the timestamp and last attempt time.</span>
 <span class="s2">* </span><span class="s3">@param </span><span class="s2">{RetryTask} task The task to check.</span>
 <span class="s2">* </span><span class="s3">@param </span><span class="s2">{number} maxDelay The maximum delay for the queue.</span>
 <span class="s2">* </span><span class="s3">@returns </span><span class="s2">{boolean} true if it is time to retry, false otherwise.</span>
 <span class="s2">*/</span>
<span class="s4">function </span><span class="s1">isTimeToRetry(task, maxDelay) {</span>
    <span class="s4">const </span><span class="s1">timeSinceLastAttempt = Date.now() - task.lastAttempt;</span>
    <span class="s4">const </span><span class="s1">timeSinceStart = Math.max(task.lastAttempt - task.timestamp, </span><span class="s5">1</span><span class="s1">);</span>
    <span class="s4">const </span><span class="s1">desiredDelay = Math.min(timeSinceStart * </span><span class="s5">1.2</span><span class="s1">, maxDelay);</span>

    <span class="s4">return </span><span class="s1">timeSinceLastAttempt &gt;= desiredDelay;</span>
<span class="s1">}</span>

<span class="s2">/**</span>
 <span class="s2">* Checks if it is time to bail out based on the given timestamp.</span>
 <span class="s2">* </span><span class="s3">@param </span><span class="s2">{RetryTask} task The task to check.</span>
 <span class="s2">* </span><span class="s3">@param </span><span class="s2">{number} timeout The timeout for the queue.</span>
 <span class="s2">* </span><span class="s3">@returns </span><span class="s2">{boolean} true if it is time to bail, false otherwise.</span>
 <span class="s2">*/</span>
<span class="s4">function </span><span class="s1">isTimeToBail(task, timeout) {</span>
    <span class="s4">return </span><span class="s1">task.age &gt; timeout;</span>
<span class="s1">}</span>

<span class="s2">/**</span>
 <span class="s2">* Creates a new promise with resolve and reject functions.</span>
 <span class="s2">* </span><span class="s3">@returns </span><span class="s2">{{promise:Promise&lt;any&gt;, resolve:(value:any) =&gt; any, reject: (value:any) =&gt; any}} A new promise.</span>
 <span class="s2">*/</span>
<span class="s4">function </span><span class="s1">createPromise() {</span>
    <span class="s4">if </span><span class="s1">(Promise.withResolvers) {</span>
        <span class="s4">return </span><span class="s1">Promise.withResolvers();</span>
    <span class="s1">}</span>

    <span class="s4">let </span><span class="s1">resolve, reject;</span>

    <span class="s4">const </span><span class="s1">promise = </span><span class="s4">new </span><span class="s1">Promise((res, rej) =&gt; {</span>
        <span class="s1">resolve = res;</span>
        <span class="s1">reject = rej;</span>
    <span class="s1">});</span>

    <span class="s4">if </span><span class="s1">(resolve === undefined || reject === undefined) {</span>
        <span class="s4">throw new </span><span class="s1">Error(</span><span class="s0">&quot;Promise executor did not initialize resolve or reject.&quot;</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s4">return </span><span class="s1">{ promise, resolve, reject };</span>
<span class="s1">}</span>


<span class="s2">/**</span>
 <span class="s2">* A class to represent a task in the retry queue.</span>
 <span class="s2">*/</span>
<span class="s4">class </span><span class="s1">RetryTask {</span>

    <span class="s2">/**</span>
     <span class="s2">* The unique ID for the task.</span>
     <span class="s2">* </span><span class="s3">@type </span><span class="s2">{string}</span>
     <span class="s2">*/</span>
    <span class="s1">id = Math.random().toString(</span><span class="s5">36</span><span class="s1">).slice(</span><span class="s5">2</span><span class="s1">);</span>

    <span class="s2">/**</span>
     <span class="s2">* The function to call.</span>
     <span class="s2">* </span><span class="s3">@type </span><span class="s2">{Function}</span>
     <span class="s2">*/</span>
    <span class="s1">fn;</span>

    <span class="s2">/**</span>
     <span class="s2">* The error that was thrown.</span>
     <span class="s2">* </span><span class="s3">@type </span><span class="s2">{Error}</span>
     <span class="s2">*/</span>
    <span class="s1">error;</span>
    
    <span class="s2">/**</span>
     <span class="s2">* The timestamp of the task.</span>
     <span class="s2">* </span><span class="s3">@type </span><span class="s2">{number}</span>
     <span class="s2">*/</span>
    <span class="s1">timestamp = Date.now();</span>

    <span class="s2">/**</span>
     <span class="s2">* The timestamp of the last attempt.</span>
     <span class="s2">* </span><span class="s3">@type </span><span class="s2">{number}</span>
     <span class="s2">*/</span>
    <span class="s1">lastAttempt = </span><span class="s4">this</span><span class="s1">.timestamp;</span>

    <span class="s2">/**</span>
     <span class="s2">* The resolve function for the promise.</span>
     <span class="s2">* </span><span class="s3">@type </span><span class="s2">{Function}</span>
     <span class="s2">*/</span>
    <span class="s1">resolve;</span>

    <span class="s2">/**</span>
     <span class="s2">* The reject function for the promise.</span>
     <span class="s2">* </span><span class="s3">@type </span><span class="s2">{Function}</span>
     <span class="s2">*/</span>
    <span class="s1">reject;</span>

    <span class="s2">/**</span>
     <span class="s2">* The AbortSignal to monitor for cancellation.</span>
     <span class="s2">* </span><span class="s3">@type </span><span class="s2">{AbortSignal|undefined}</span>
     <span class="s2">*/</span>
    <span class="s1">signal;</span>

    <span class="s2">/**</span>
     <span class="s2">* Creates a new instance.</span>
     <span class="s2">* </span><span class="s3">@param </span><span class="s2">{Function} fn The function to call.</span>
     <span class="s2">* </span><span class="s3">@param </span><span class="s2">{Error} error The error that was thrown.</span>
     <span class="s2">* </span><span class="s3">@param </span><span class="s2">{Function} resolve The resolve function for the promise.</span>
     <span class="s2">* </span><span class="s3">@param </span><span class="s2">{Function} reject The reject function for the promise.</span>
     <span class="s2">* </span><span class="s3">@param </span><span class="s2">{AbortSignal|undefined} signal The AbortSignal to monitor for cancellation.</span>
     <span class="s2">*/</span>
    <span class="s1">constructor(fn, error, resolve, reject, signal) {</span>
        <span class="s4">this</span><span class="s1">.fn = fn;</span>
        <span class="s4">this</span><span class="s1">.error = error;</span>
        <span class="s4">this</span><span class="s1">.timestamp = Date.now();</span>
        <span class="s4">this</span><span class="s1">.lastAttempt = Date.now();</span>
        <span class="s4">this</span><span class="s1">.resolve = resolve;</span>
        <span class="s4">this</span><span class="s1">.reject = reject;</span>
        <span class="s4">this</span><span class="s1">.signal = signal;</span>
    <span class="s1">}</span>
    
    <span class="s2">/**</span>
     <span class="s2">* Gets the age of the task.</span>
     <span class="s2">* </span><span class="s3">@returns </span><span class="s2">{number} The age of the task in milliseconds.</span>
     <span class="s2">* </span><span class="s3">@readonly</span>
     <span class="s2">*/</span>
    <span class="s1">get age() {</span>
        <span class="s4">return </span><span class="s1">Date.now() - </span><span class="s4">this</span><span class="s1">.timestamp;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s2">//-----------------------------------------------------------------------------</span>
<span class="s2">// Exports</span>
<span class="s2">//-----------------------------------------------------------------------------</span>

<span class="s2">/**</span>
 <span class="s2">* A class that manages a queue of retry jobs.</span>
 <span class="s2">*/</span>
<span class="s4">class </span><span class="s1">Retrier {</span>

    <span class="s2">/**</span>
     <span class="s2">* Represents the queue for processing tasks.</span>
     <span class="s2">* </span><span class="s3">@type </span><span class="s2">{Array&lt;RetryTask&gt;}</span>
     <span class="s2">*/</span>
    <span class="s1">#retrying = [];</span>

    <span class="s2">/**</span>
     <span class="s2">* Represents the queue for pending tasks.</span>
     <span class="s2">* </span><span class="s3">@type </span><span class="s2">{Array&lt;Function&gt;}</span>
     <span class="s2">*/</span>
    <span class="s1">#pending = [];</span>

    <span class="s2">/**</span>
     <span class="s2">* The number of tasks currently being processed.</span>
     <span class="s2">* </span><span class="s3">@type </span><span class="s2">{number}</span>
     <span class="s2">*/</span>
    <span class="s1">#working = </span><span class="s5">0</span><span class="s1">;</span>

    <span class="s2">/**</span>
     <span class="s2">* The timeout for the queue.</span>
     <span class="s2">* </span><span class="s3">@type </span><span class="s2">{number}</span>
     <span class="s2">*/</span>
    <span class="s1">#timeout;</span>

    <span class="s2">/**</span>
     <span class="s2">* The maximum delay for the queue.</span>
     <span class="s2">* </span><span class="s3">@type </span><span class="s2">{number}</span>
     <span class="s2">*/</span>
    <span class="s1">#maxDelay;</span>

    <span class="s2">/**</span>
     <span class="s2">* The setTimeout() timer ID.</span>
     <span class="s2">* </span><span class="s3">@type </span><span class="s2">{NodeJS.Timeout|undefined}</span>
     <span class="s2">*/</span>
    <span class="s1">#timerId;</span>

    <span class="s2">/**</span>
     <span class="s2">* The function to call.</span>
     <span class="s2">* </span><span class="s3">@type </span><span class="s2">{Function}</span>
     <span class="s2">*/</span>
    <span class="s1">#check;</span>

    <span class="s2">/**</span>
     <span class="s2">* The maximum number of concurrent tasks.</span>
     <span class="s2">* </span><span class="s3">@type </span><span class="s2">{number}</span>
     <span class="s2">*/</span>
    <span class="s1">#concurrency;</span>

    <span class="s2">/**</span>
     <span class="s2">* Creates a new instance.</span>
     <span class="s2">* </span><span class="s3">@param </span><span class="s2">{Function} check The function to call.</span>
     <span class="s2">* </span><span class="s3">@param </span><span class="s2">{object} [options] The options for the instance.</span>
     <span class="s2">* </span><span class="s3">@param </span><span class="s2">{number} [options.timeout] The timeout for the queue.</span>
     <span class="s2">* </span><span class="s3">@param </span><span class="s2">{number} [options.maxDelay] The maximum delay for the queue.</span>
     <span class="s2">* </span><span class="s3">@param </span><span class="s2">{number} [options.concurrency] The maximum number of concurrent tasks.</span>
     <span class="s2">*/</span>
    <span class="s1">constructor(check, { timeout = MAX_TASK_TIMEOUT, maxDelay = MAX_TASK_DELAY, concurrency = MAX_CONCURRENCY } = {}) {</span>

        <span class="s4">if </span><span class="s1">(</span><span class="s4">typeof </span><span class="s1">check !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) {</span>
            <span class="s4">throw new </span><span class="s1">Error(</span><span class="s0">&quot;Missing function to check errors&quot;</span><span class="s1">);</span>
        <span class="s1">}</span>

        <span class="s4">this</span><span class="s1">.#check = check;</span>
        <span class="s4">this</span><span class="s1">.#timeout = timeout;</span>
        <span class="s4">this</span><span class="s1">.#maxDelay = maxDelay;</span>
        <span class="s4">this</span><span class="s1">.#concurrency = concurrency;</span>
    <span class="s1">}</span>

    <span class="s2">/**</span>
     <span class="s2">* Gets the number of tasks waiting to be retried.</span>
     <span class="s2">* </span><span class="s3">@returns </span><span class="s2">{number} The number of tasks in the retry queue.</span>
     <span class="s2">*/</span>
    <span class="s1">get retrying() {</span>
        <span class="s4">return this</span><span class="s1">.#retrying.length;</span>
    <span class="s1">}</span>

    <span class="s2">/**</span>
     <span class="s2">* Gets the number of tasks waiting to be processed in the pending queue.</span>
     <span class="s2">* </span><span class="s3">@returns </span><span class="s2">{number} The number of tasks in the pending queue.</span>
     <span class="s2">*/</span>
    <span class="s1">get pending() {</span>
        <span class="s4">return this</span><span class="s1">.#pending.length;</span>
    <span class="s1">}</span>

    <span class="s2">/**</span>
     <span class="s2">* Gets the number of tasks currently being processed.</span>
     <span class="s2">* </span><span class="s3">@returns </span><span class="s2">{number} The number of tasks currently being processed.</span>
     <span class="s2">*/</span>
    <span class="s1">get working() {</span>
        <span class="s4">return this</span><span class="s1">.#working;</span>
    <span class="s1">}</span>

    <span class="s2">/**</span>
     <span class="s2">* Calls the function and retries if it fails.</span>
     <span class="s2">* </span><span class="s3">@param </span><span class="s2">{Function} fn The function to call.</span>
     <span class="s2">* </span><span class="s3">@param </span><span class="s2">{Object} options The options for the job.</span>
     <span class="s2">* </span><span class="s3">@param </span><span class="s2">{AbortSignal} [options.signal] The AbortSignal to monitor for cancellation.</span>
     <span class="s2">* </span><span class="s3">@param </span><span class="s2">{Promise&lt;any&gt;} options.promise The promise to return when the function settles.</span>
     <span class="s2">* </span><span class="s3">@param </span><span class="s2">{Function} options.resolve The resolve function for the promise.</span>
     <span class="s2">* </span><span class="s3">@param </span><span class="s2">{Function} options.reject The reject function for the promise.</span>
     <span class="s2">* </span><span class="s3">@returns </span><span class="s2">{Promise&lt;any&gt;} A promise that resolves when the function is</span>
     <span class="s2">* called successfully.</span>
     <span class="s2">*/</span>
    <span class="s1">#call(fn, { signal, promise, resolve, reject }) {</span>

        <span class="s4">let </span><span class="s1">result;</span>

        <span class="s4">try </span><span class="s1">{</span>
            <span class="s1">result = fn();</span>
        <span class="s1">} </span><span class="s4">catch </span><span class="s1">(</span><span class="s2">/** </span><span class="s3">@type </span><span class="s2">{any} */ </span><span class="s1">error) {</span>
            <span class="s1">reject(</span><span class="s4">new </span><span class="s1">Error(</span><span class="s0">`Synchronous error: </span><span class="s1">${error.message}</span><span class="s0">`</span><span class="s1">, { cause: error }));</span>
            <span class="s4">return </span><span class="s1">promise;</span>
        <span class="s1">}</span>

        <span class="s2">// if the result is not a promise then reject an error</span>
        <span class="s4">if </span><span class="s1">(!result || </span><span class="s4">typeof </span><span class="s1">result.then !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) {</span>
            <span class="s1">reject(</span><span class="s4">new </span><span class="s1">Error(</span><span class="s0">&quot;Result is not a promise.&quot;</span><span class="s1">));</span>
            <span class="s4">return </span><span class="s1">promise;</span>
        <span class="s1">}</span>

        <span class="s4">this</span><span class="s1">.#working++;</span>
        <span class="s1">promise.finally(() =&gt; {</span>
            <span class="s4">this</span><span class="s1">.#working--;</span>
            <span class="s4">this</span><span class="s1">.#processPending();</span>
        <span class="s1">})</span>
        <span class="s2">// `promise.finally` creates a new promise that may be rejected, so it must be handled.</span>
            <span class="s1">.catch(() =&gt; { });</span>

        <span class="s2">// call the original function and catch any ENFILE or EMFILE errors</span>
        <span class="s1">Promise.resolve(result)</span>
            <span class="s1">.then(value =&gt; {</span>
                <span class="s1">debug(</span><span class="s0">&quot;Function called successfully without retry.&quot;</span><span class="s1">);</span>
                <span class="s1">resolve(value);</span>
            <span class="s1">})</span>
            <span class="s1">.catch(error =&gt; {</span>
                <span class="s4">if </span><span class="s1">(!</span><span class="s4">this</span><span class="s1">.#check(error)) {</span>
                    <span class="s1">reject(error);</span>
                    <span class="s4">return</span><span class="s1">;</span>
                <span class="s1">}</span>

                <span class="s4">const </span><span class="s1">task = </span><span class="s4">new </span><span class="s1">RetryTask(fn, error, resolve, reject, signal);</span>
                
                <span class="s1">debug(</span><span class="s0">`Function failed, queuing for retry with task </span><span class="s1">${task.id}</span><span class="s0">.`</span><span class="s1">);</span>
                <span class="s4">this</span><span class="s1">.#retrying.push(task);</span>

                <span class="s1">signal?.addEventListener(</span><span class="s0">&quot;abort&quot;</span><span class="s1">, () =&gt; {</span>
                    <span class="s1">debug(</span><span class="s0">`Task </span><span class="s1">${task.id} </span><span class="s0">was aborted due to AbortSignal.`</span><span class="s1">);</span>
                    <span class="s1">reject(signal.reason);</span>
                <span class="s1">});</span>

                <span class="s4">this</span><span class="s1">.#processQueue();</span>
            <span class="s1">});</span>
        
        <span class="s4">return </span><span class="s1">promise;</span>
    <span class="s1">}</span>

    <span class="s2">/**</span>
     <span class="s2">* Adds a new retry job to the queue.</span>
     <span class="s2">* </span><span class="s3">@template </span><span class="s2">{(...args: unknown[]) =&gt; Promise&lt;unknown&gt;} Func</span>
     <span class="s2">* </span><span class="s3">@template </span><span class="s2">{Awaited&lt;ReturnType&lt;Func&gt;&gt;} RetVal</span>
     <span class="s2">* </span><span class="s3">@param </span><span class="s2">{Func} fn The function to call.</span>
     <span class="s2">* </span><span class="s3">@param </span><span class="s2">{object} [options] The options for the job.</span>
     <span class="s2">* </span><span class="s3">@param </span><span class="s2">{AbortSignal} [options.signal] The AbortSignal to monitor for cancellation.</span>
     <span class="s2">* </span><span class="s3">@returns </span><span class="s2">{Promise&lt;RetVal&gt;} A promise that resolves when the queue is processed.</span>
     <span class="s2">*/</span>
    <span class="s1">retry(fn, { signal } = {}) {</span>

        <span class="s1">signal?.throwIfAborted();</span>

        <span class="s4">const </span><span class="s1">{ promise, resolve, reject } = createPromise();</span>

        <span class="s4">this</span><span class="s1">.#pending.push(() =&gt; </span><span class="s4">this</span><span class="s1">.#call(fn, { signal, promise, resolve, reject }));</span>
        <span class="s4">this</span><span class="s1">.#processPending();</span>
        
        <span class="s4">return </span><span class="s1">promise;</span>
    <span class="s1">}</span>


    <span class="s2">/**</span>
     <span class="s2">* Processes the pending queue and the retry queue.</span>
     <span class="s2">* </span><span class="s3">@returns </span><span class="s2">{void}</span>
     <span class="s2">*/</span>
    <span class="s1">#processAll() {</span>
        <span class="s4">if </span><span class="s1">(</span><span class="s4">this</span><span class="s1">.pending) {</span>
            <span class="s4">this</span><span class="s1">.#processPending();</span>
        <span class="s1">}</span>

        <span class="s4">if </span><span class="s1">(</span><span class="s4">this</span><span class="s1">.retrying) {</span>
            <span class="s4">this</span><span class="s1">.#processQueue();</span>
        <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s2">/**</span>
     <span class="s2">* Processes the pending queue to see which tasks can be started.</span>
     <span class="s2">* </span><span class="s3">@returns </span><span class="s2">{void}</span>
     <span class="s2">*/</span>
    <span class="s1">#processPending() {</span>

        <span class="s1">debug(</span><span class="s0">`Processing pending tasks: </span><span class="s1">${</span><span class="s4">this</span><span class="s1">.pending} </span><span class="s0">pending, </span><span class="s1">${</span><span class="s4">this</span><span class="s1">.working} </span><span class="s0">working.`</span><span class="s1">);</span>

        <span class="s4">const </span><span class="s1">available = </span><span class="s4">this</span><span class="s1">.#concurrency - </span><span class="s4">this</span><span class="s1">.working;</span>

        <span class="s4">if </span><span class="s1">(available &lt;= </span><span class="s5">0</span><span class="s1">) {</span>
            <span class="s4">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s4">const </span><span class="s1">count = Math.min(</span><span class="s4">this</span><span class="s1">.pending, available);</span>

        <span class="s4">for </span><span class="s1">(</span><span class="s4">let </span><span class="s1">i = </span><span class="s5">0</span><span class="s1">; i &lt; count; i++) {</span>
            <span class="s4">const </span><span class="s1">task = </span><span class="s4">this</span><span class="s1">.#pending.shift();</span>
            <span class="s1">task?.();</span>
        <span class="s1">}</span>

        <span class="s1">debug(</span><span class="s0">`Processed pending tasks: </span><span class="s1">${</span><span class="s4">this</span><span class="s1">.pending} </span><span class="s0">pending, </span><span class="s1">${</span><span class="s4">this</span><span class="s1">.working} </span><span class="s0">working.`</span><span class="s1">);</span>
    <span class="s1">}</span>

    <span class="s2">/**</span>
     <span class="s2">* Processes the queue.</span>
     <span class="s2">* </span><span class="s3">@returns </span><span class="s2">{void}</span>
     <span class="s2">*/</span>
    <span class="s1">#processQueue() {</span>
        <span class="s2">// clear any timer because we're going to check right now</span>
        <span class="s1">clearTimeout(</span><span class="s4">this</span><span class="s1">.#timerId);</span>
        <span class="s4">this</span><span class="s1">.#timerId = undefined;</span>

        <span class="s1">debug(</span><span class="s0">`Processing retry queue: </span><span class="s1">${</span><span class="s4">this</span><span class="s1">.retrying} </span><span class="s0">retrying, </span><span class="s1">${</span><span class="s4">this</span><span class="s1">.working} </span><span class="s0">working.`</span><span class="s1">);</span>

        <span class="s4">const </span><span class="s1">processAgain = () =&gt; {</span>
            <span class="s4">this</span><span class="s1">.#timerId = setTimeout(() =&gt; </span><span class="s4">this</span><span class="s1">.#processAll(), </span><span class="s5">0</span><span class="s1">);</span>
        <span class="s1">};</span>

        <span class="s2">// if there's nothing in the queue, we're done</span>
        <span class="s4">const </span><span class="s1">task = </span><span class="s4">this</span><span class="s1">.#retrying.shift();</span>
        <span class="s4">if </span><span class="s1">(!task) {</span>
            <span class="s1">debug(</span><span class="s0">&quot;Queue is empty, exiting.&quot;</span><span class="s1">);</span>

            <span class="s4">if </span><span class="s1">(</span><span class="s4">this</span><span class="s1">.pending) {</span>
                <span class="s1">processAgain();</span>
            <span class="s1">}</span>
            <span class="s4">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">// if it's time to bail, then bail</span>
        <span class="s4">if </span><span class="s1">(isTimeToBail(task, </span><span class="s4">this</span><span class="s1">.#timeout)) {</span>
            <span class="s1">debug(</span><span class="s0">`Task </span><span class="s1">${task.id} </span><span class="s0">was abandoned due to timeout.`</span><span class="s1">);</span>
            <span class="s1">task.reject(task.error);</span>
            <span class="s1">processAgain();</span>
            <span class="s4">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">// if it's not time to retry, then wait and try again</span>
        <span class="s4">if </span><span class="s1">(!isTimeToRetry(task, </span><span class="s4">this</span><span class="s1">.#maxDelay)) {</span>
            <span class="s1">debug(</span><span class="s0">`Task </span><span class="s1">${task.id} </span><span class="s0">is not ready to retry, skipping.`</span><span class="s1">);</span>
            <span class="s4">this</span><span class="s1">.#retrying.push(task);</span>
            <span class="s1">processAgain();</span>
            <span class="s4">return</span><span class="s1">;</span>
        <span class="s1">}</span>

        <span class="s2">// otherwise, try again</span>
        <span class="s1">task.lastAttempt = Date.now();</span>
        
        <span class="s2">// Promise.resolve needed in case it's a thenable but not a Promise</span>
        <span class="s1">Promise.resolve(task.fn())</span>
            <span class="s2">// @ts-ignore because we know it's any</span>
            <span class="s1">.then(result =&gt; {</span>
                <span class="s1">debug(</span><span class="s0">`Task </span><span class="s1">${task.id} </span><span class="s0">succeeded after </span><span class="s1">${task.age}</span><span class="s0">ms.`</span><span class="s1">);</span>
                <span class="s1">task.resolve(result);</span>
            <span class="s1">})</span>

            <span class="s2">// @ts-ignore because we know it's any</span>
            <span class="s1">.catch(error =&gt; {</span>
                <span class="s4">if </span><span class="s1">(!</span><span class="s4">this</span><span class="s1">.#check(error)) {</span>
                    <span class="s1">debug(</span><span class="s0">`Task </span><span class="s1">${task.id} </span><span class="s0">failed with non-retryable error: </span><span class="s1">${error.message}</span><span class="s0">.`</span><span class="s1">);</span>
                    <span class="s1">task.reject(error);</span>
                    <span class="s4">return</span><span class="s1">;</span>
                <span class="s1">}</span>

                <span class="s2">// update the task timestamp and push to back of queue to try again</span>
                <span class="s1">task.lastAttempt = Date.now();</span>
                <span class="s4">this</span><span class="s1">.#retrying.push(task);</span>
                <span class="s1">debug(</span><span class="s0">`Task </span><span class="s1">${task.id} </span><span class="s0">failed, requeueing to try again.`</span><span class="s1">);</span>
            <span class="s1">})</span>
            <span class="s1">.finally(() =&gt; {</span>
                <span class="s4">this</span><span class="s1">.#processAll();</span>
            <span class="s1">});</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s1">exports.Retrier = Retrier;</span>
</pre>
</body>
</html>