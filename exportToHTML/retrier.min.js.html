<html>
<head>
<title>retrier.min.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
retrier.min.js</font>
</center></td></tr></table>
<pre><span class="s0">function </span><span class="s1">e(e){</span><span class="s2">&quot;@hwc/retry&quot;</span><span class="s1">===globalThis?.process?.env.DEBUG&amp;&amp;console.debug(e)}</span><span class="s0">class </span><span class="s1">RetryTask{id=Math.random().toString(</span><span class="s3">36</span><span class="s1">).slice(</span><span class="s3">2</span><span class="s1">);fn;error;timestamp=Date.now();lastAttempt=</span><span class="s0">this</span><span class="s1">.timestamp;resolve;reject;signal;constructor(e,t,r,i,s){</span><span class="s0">this</span><span class="s1">.fn=e,</span><span class="s0">this</span><span class="s1">.error=t,</span><span class="s0">this</span><span class="s1">.timestamp=Date.now(),</span><span class="s0">this</span><span class="s1">.lastAttempt=Date.now(),</span><span class="s0">this</span><span class="s1">.resolve=r,</span><span class="s0">this</span><span class="s1">.reject=i,</span><span class="s0">this</span><span class="s1">.signal=s}get age(){</span><span class="s0">return </span><span class="s1">Date.now()-</span><span class="s0">this</span><span class="s1">.timestamp}}</span><span class="s0">class </span><span class="s1">Retrier{#e=[];#t=[];#r=</span><span class="s3">0</span><span class="s1">;#i;#s;#n;#o;#c;constructor(e,{timeout:t=</span><span class="s3">6e4</span><span class="s1">,maxDelay:r=</span><span class="s3">100</span><span class="s1">,concurrency:i=</span><span class="s3">1e3</span><span class="s1">}={}){</span><span class="s0">if</span><span class="s1">(</span><span class="s2">&quot;function&quot;</span><span class="s1">!=</span><span class="s0">typeof </span><span class="s1">e)</span><span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Missing function to check errors&quot;</span><span class="s1">);</span><span class="s0">this</span><span class="s1">.#o=e,</span><span class="s0">this</span><span class="s1">.#i=t,</span><span class="s0">this</span><span class="s1">.#s=r,</span><span class="s0">this</span><span class="s1">.#c=i}get retrying(){</span><span class="s0">return this</span><span class="s1">.#e.length}get pending(){</span><span class="s0">return this</span><span class="s1">.#t.length}get working(){</span><span class="s0">return this</span><span class="s1">.#r}#a(t,{signal:r,promise:i,resolve:s,reject:n}){</span><span class="s0">let </span><span class="s1">o;</span><span class="s0">try</span><span class="s1">{o=t()}</span><span class="s0">catch</span><span class="s1">(e){</span><span class="s0">return </span><span class="s1">n(</span><span class="s0">new </span><span class="s1">Error(</span><span class="s2">`Synchronous error: </span><span class="s1">${e.message}</span><span class="s2">`</span><span class="s1">,{cause:e})),i}</span><span class="s0">return </span><span class="s1">o&amp;&amp;</span><span class="s2">&quot;function&quot;</span><span class="s1">==</span><span class="s0">typeof </span><span class="s1">o.then?(</span><span class="s0">this</span><span class="s1">.#r++,i.finally((()=&gt;{</span><span class="s0">this</span><span class="s1">.#r--,</span><span class="s0">this</span><span class="s1">.#h()})).catch((()=&gt;{})),Promise.resolve(o).then((t=&gt;{e(</span><span class="s2">&quot;Function called successfully without retry.&quot;</span><span class="s1">),s(t)})).catch((i=&gt;{</span><span class="s0">if</span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.#o(i))</span><span class="s0">return void </span><span class="s1">n(i);</span><span class="s0">const </span><span class="s1">o=</span><span class="s0">new </span><span class="s1">RetryTask(t,i,s,n,r);e(</span><span class="s2">`Function failed, queuing for retry with task </span><span class="s1">${o.id}</span><span class="s2">.`</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.#e.push(o),r?.addEventListener(</span><span class="s2">&quot;abort&quot;</span><span class="s1">,(()=&gt;{e(</span><span class="s2">`Task </span><span class="s1">${o.id} </span><span class="s2">was aborted due to AbortSignal.`</span><span class="s1">),n(r.reason)})),</span><span class="s0">this</span><span class="s1">.#g()})),i):(n(</span><span class="s0">new </span><span class="s1">Error(</span><span class="s2">&quot;Result is not a promise.&quot;</span><span class="s1">)),i)}retry(e,{signal:t}={}){t?.throwIfAborted();</span><span class="s0">const</span><span class="s1">{promise:r,resolve:i,reject:s}=</span><span class="s0">function</span><span class="s1">(){</span><span class="s0">if</span><span class="s1">(Promise.withResolvers)</span><span class="s0">return </span><span class="s1">Promise.withResolvers();</span><span class="s0">let </span><span class="s1">e,t;</span><span class="s0">const </span><span class="s1">r=</span><span class="s0">new </span><span class="s1">Promise(((r,i)=&gt;{e=r,t=i}));</span><span class="s0">if</span><span class="s1">(</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===e||</span><span class="s0">void </span><span class="s3">0</span><span class="s1">===t)</span><span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">&quot;Promise executor did not initialize resolve or reject.&quot;</span><span class="s1">);</span><span class="s0">return</span><span class="s1">{promise:r,resolve:e,reject:t}}();</span><span class="s0">return this</span><span class="s1">.#t.push((()=&gt;</span><span class="s0">this</span><span class="s1">.#a(e,{signal:t,promise:r,resolve:i,reject:s}))),</span><span class="s0">this</span><span class="s1">.#h(),r}#u(){</span><span class="s0">this</span><span class="s1">.pending&amp;&amp;</span><span class="s0">this</span><span class="s1">.#h(),</span><span class="s0">this</span><span class="s1">.retrying&amp;&amp;</span><span class="s0">this</span><span class="s1">.#g()}#h(){e(</span><span class="s2">`Processing pending tasks: </span><span class="s1">${</span><span class="s0">this</span><span class="s1">.pending} </span><span class="s2">pending, </span><span class="s1">${</span><span class="s0">this</span><span class="s1">.working} </span><span class="s2">working.`</span><span class="s1">);</span><span class="s0">const </span><span class="s1">t=</span><span class="s0">this</span><span class="s1">.#c-</span><span class="s0">this</span><span class="s1">.working;</span><span class="s0">if</span><span class="s1">(t&lt;=</span><span class="s3">0</span><span class="s1">)</span><span class="s0">return</span><span class="s1">;</span><span class="s0">const </span><span class="s1">r=Math.min(</span><span class="s0">this</span><span class="s1">.pending,t);</span><span class="s0">for</span><span class="s1">(</span><span class="s0">let </span><span class="s1">e=</span><span class="s3">0</span><span class="s1">;e&lt;r;e++){</span><span class="s0">const </span><span class="s1">e=</span><span class="s0">this</span><span class="s1">.#t.shift();e?.()}e(</span><span class="s2">`Processed pending tasks: </span><span class="s1">${</span><span class="s0">this</span><span class="s1">.pending} </span><span class="s2">pending, </span><span class="s1">${</span><span class="s0">this</span><span class="s1">.working} </span><span class="s2">working.`</span><span class="s1">)}#g(){clearTimeout(</span><span class="s0">this</span><span class="s1">.#n),</span><span class="s0">this</span><span class="s1">.#n=</span><span class="s0">void </span><span class="s3">0</span><span class="s1">,e(</span><span class="s2">`Processing retry queue: </span><span class="s1">${</span><span class="s0">this</span><span class="s1">.retrying} </span><span class="s2">retrying, </span><span class="s1">${</span><span class="s0">this</span><span class="s1">.working} </span><span class="s2">working.`</span><span class="s1">);</span><span class="s0">const </span><span class="s1">t=()=&gt;{</span><span class="s0">this</span><span class="s1">.#n=setTimeout((()=&gt;</span><span class="s0">this</span><span class="s1">.#u()),</span><span class="s3">0</span><span class="s1">)},r=</span><span class="s0">this</span><span class="s1">.#e.shift();</span><span class="s0">return </span><span class="s1">r?</span><span class="s0">function</span><span class="s1">(e,t){</span><span class="s0">return </span><span class="s1">e.age&gt;t}(r,</span><span class="s0">this</span><span class="s1">.#i)?(e(</span><span class="s2">`Task </span><span class="s1">${r.id} </span><span class="s2">was abandoned due to timeout.`</span><span class="s1">),r.reject(r.error),</span><span class="s0">void </span><span class="s1">t()):</span><span class="s0">function</span><span class="s1">(e,t){</span><span class="s0">const </span><span class="s1">r=Date.now()-e.lastAttempt,i=Math.max(e.lastAttempt-e.timestamp,</span><span class="s3">1</span><span class="s1">);</span><span class="s0">return </span><span class="s1">r&gt;=Math.min(</span><span class="s3">1.2</span><span class="s1">*i,t)}(r,</span><span class="s0">this</span><span class="s1">.#s)?(r.lastAttempt=Date.now(),</span><span class="s0">void </span><span class="s1">Promise.resolve(r.fn()).then((t=&gt;{e(</span><span class="s2">`Task </span><span class="s1">${r.id} </span><span class="s2">succeeded after </span><span class="s1">${r.age}</span><span class="s2">ms.`</span><span class="s1">),r.resolve(t)})).catch((t=&gt;{</span><span class="s0">if</span><span class="s1">(!</span><span class="s0">this</span><span class="s1">.#o(t))</span><span class="s0">return </span><span class="s1">e(</span><span class="s2">`Task </span><span class="s1">${r.id} </span><span class="s2">failed with non-retryable error: </span><span class="s1">${t.message}</span><span class="s2">.`</span><span class="s1">),</span><span class="s0">void </span><span class="s1">r.reject(t);r.lastAttempt=Date.now(),</span><span class="s0">this</span><span class="s1">.#e.push(r),e(</span><span class="s2">`Task </span><span class="s1">${r.id} </span><span class="s2">failed, requeueing to try again.`</span><span class="s1">)})).finally((()=&gt;{</span><span class="s0">this</span><span class="s1">.#u()}))):(e(</span><span class="s2">`Task </span><span class="s1">${r.id} </span><span class="s2">is not ready to retry, skipping.`</span><span class="s1">),</span><span class="s0">this</span><span class="s1">.#e.push(r),</span><span class="s0">void </span><span class="s1">t()):(e(</span><span class="s2">&quot;Queue is empty, exiting.&quot;</span><span class="s1">),</span><span class="s0">void</span><span class="s1">(</span><span class="s0">this</span><span class="s1">.pending&amp;&amp;t()))}}</span><span class="s0">export</span><span class="s1">{Retrier};</span>
</pre>
</body>
</html>