<html>
<head>
<title>no-irregular-whitespace.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #8c8c8c; font-style: italic;}
.s2 { color: #080808;}
.s3 { color: #067d17;}
.s4 { color: #0033b3;}
.s5 { color: #264eff;}
.s6 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
no-irregular-whitespace.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@fileoverview </span><span class="s0">Rule to disallow whitespace that is not a tab or space, whitespace inside strings and comments are allowed</span>
 <span class="s0">* </span><span class="s1">@author </span><span class="s0">Jonathan Kingston</span>
 <span class="s0">* </span><span class="s1">@author </span><span class="s0">Christophe Porteneuve</span>
 <span class="s0">*/</span>

<span class="s3">&quot;use strict&quot;</span><span class="s2">;</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Requirements</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s4">const </span><span class="s2">astUtils = require(</span><span class="s3">&quot;./utils/ast-utils&quot;</span><span class="s2">);</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Constants</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s4">const </span><span class="s2">ALL_IRREGULARS =</span>
	<span class="s5">/[\f\v\u0085\ufeff\u00a0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u202f\u205f\u3000\u2028\u2029]/u</span><span class="s2">;</span>
<span class="s4">const </span><span class="s2">IRREGULAR_WHITESPACE =</span>
	<span class="s5">/[\f\v\u0085\ufeff\u00a0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u202f\u205f\u3000]+/gu</span><span class="s2">;</span>
<span class="s4">const </span><span class="s2">IRREGULAR_LINE_TERMINATORS = </span><span class="s5">/[\u2028\u2029]/gu</span><span class="s2">;</span>
<span class="s4">const </span><span class="s2">LINE_BREAK = astUtils.createGlobalLinebreakMatcher();</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Rule Definition</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s0">/** </span><span class="s1">@type </span><span class="s0">{import('../types').Rule.RuleModule} */</span>
<span class="s2">module.exports = {</span>
	<span class="s2">meta: {</span>
		<span class="s2">type: </span><span class="s3">&quot;problem&quot;</span><span class="s2">,</span>

		<span class="s2">defaultOptions: [</span>
			<span class="s2">{</span>
				<span class="s2">skipComments: </span><span class="s4">false</span><span class="s2">,</span>
				<span class="s2">skipJSXText: </span><span class="s4">false</span><span class="s2">,</span>
				<span class="s2">skipRegExps: </span><span class="s4">false</span><span class="s2">,</span>
				<span class="s2">skipStrings: </span><span class="s4">true</span><span class="s2">,</span>
				<span class="s2">skipTemplates: </span><span class="s4">false</span><span class="s2">,</span>
			<span class="s2">},</span>
		<span class="s2">],</span>

		<span class="s2">docs: {</span>
			<span class="s2">description: </span><span class="s3">&quot;Disallow irregular whitespace&quot;</span><span class="s2">,</span>
			<span class="s2">recommended: </span><span class="s4">true</span><span class="s2">,</span>
			<span class="s2">url: </span><span class="s3">&quot;https://eslint.org/docs/latest/rules/no-irregular-whitespace&quot;</span><span class="s2">,</span>
		<span class="s2">},</span>

		<span class="s2">schema: [</span>
			<span class="s2">{</span>
				<span class="s2">type: </span><span class="s3">&quot;object&quot;</span><span class="s2">,</span>
				<span class="s2">properties: {</span>
					<span class="s2">skipComments: {</span>
						<span class="s2">type: </span><span class="s3">&quot;boolean&quot;</span><span class="s2">,</span>
					<span class="s2">},</span>
					<span class="s2">skipStrings: {</span>
						<span class="s2">type: </span><span class="s3">&quot;boolean&quot;</span><span class="s2">,</span>
					<span class="s2">},</span>
					<span class="s2">skipTemplates: {</span>
						<span class="s2">type: </span><span class="s3">&quot;boolean&quot;</span><span class="s2">,</span>
					<span class="s2">},</span>
					<span class="s2">skipRegExps: {</span>
						<span class="s2">type: </span><span class="s3">&quot;boolean&quot;</span><span class="s2">,</span>
					<span class="s2">},</span>
					<span class="s2">skipJSXText: {</span>
						<span class="s2">type: </span><span class="s3">&quot;boolean&quot;</span><span class="s2">,</span>
					<span class="s2">},</span>
				<span class="s2">},</span>
				<span class="s2">additionalProperties: </span><span class="s4">false</span><span class="s2">,</span>
			<span class="s2">},</span>
		<span class="s2">],</span>

		<span class="s2">messages: {</span>
			<span class="s2">noIrregularWhitespace: </span><span class="s3">&quot;Irregular whitespace not allowed.&quot;</span><span class="s2">,</span>
		<span class="s2">},</span>
	<span class="s2">},</span>

	<span class="s2">create(context) {</span>
		<span class="s4">const </span><span class="s2">[</span>
			<span class="s2">{</span>
				<span class="s2">skipComments,</span>
				<span class="s2">skipStrings,</span>
				<span class="s2">skipRegExps,</span>
				<span class="s2">skipTemplates,</span>
				<span class="s2">skipJSXText,</span>
			<span class="s2">},</span>
		<span class="s2">] = context.options;</span>

		<span class="s4">const </span><span class="s2">sourceCode = context.sourceCode;</span>
		<span class="s4">const </span><span class="s2">commentNodes = sourceCode.getAllComments();</span>

		<span class="s0">// Module store of errors that we have found</span>
		<span class="s4">let </span><span class="s2">errors = [];</span>

		<span class="s0">/**</span>
		 <span class="s0">* Removes errors that occur inside the given node</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node to check for matching errors.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">* </span><span class="s1">@private</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">removeWhitespaceError(node) {</span>
			<span class="s4">const </span><span class="s2">locStart = node.loc.start;</span>
			<span class="s4">const </span><span class="s2">locEnd = node.loc.end;</span>

			<span class="s2">errors = errors.filter(</span>
				<span class="s2">({ loc: { start: errorLocStart } }) =&gt;</span>
					<span class="s2">errorLocStart.line &lt; locStart.line ||</span>
					<span class="s2">(errorLocStart.line === locStart.line &amp;&amp;</span>
						<span class="s2">errorLocStart.column &lt; locStart.column) ||</span>
					<span class="s2">(errorLocStart.line === locEnd.line &amp;&amp;</span>
						<span class="s2">errorLocStart.column &gt;= locEnd.column) ||</span>
					<span class="s2">errorLocStart.line &gt; locEnd.line,</span>
			<span class="s2">);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Checks literal nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node to check for matching errors.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">* </span><span class="s1">@private</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">removeInvalidNodeErrorsInLiteral(node) {</span>
			<span class="s4">const </span><span class="s2">shouldCheckStrings =</span>
				<span class="s2">skipStrings &amp;&amp; </span><span class="s4">typeof </span><span class="s2">node.value === </span><span class="s3">&quot;string&quot;</span><span class="s2">;</span>
			<span class="s4">const </span><span class="s2">shouldCheckRegExps = skipRegExps &amp;&amp; Boolean(node.regex);</span>

			<span class="s4">if </span><span class="s2">(shouldCheckStrings || shouldCheckRegExps) {</span>
				<span class="s0">// If we have irregular characters remove them from the errors list</span>
				<span class="s4">if </span><span class="s2">(ALL_IRREGULARS.test(node.raw)) {</span>
					<span class="s2">removeWhitespaceError(node);</span>
				<span class="s2">}</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Checks template string literal nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node to check for matching errors.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">* </span><span class="s1">@private</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">removeInvalidNodeErrorsInTemplateLiteral(node) {</span>
			<span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">node.value.raw === </span><span class="s3">&quot;string&quot;</span><span class="s2">) {</span>
				<span class="s4">if </span><span class="s2">(ALL_IRREGULARS.test(node.value.raw)) {</span>
					<span class="s2">removeWhitespaceError(node);</span>
				<span class="s2">}</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Checks comment nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node to check for matching errors.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">* </span><span class="s1">@private</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">removeInvalidNodeErrorsInComment(node) {</span>
			<span class="s4">if </span><span class="s2">(ALL_IRREGULARS.test(node.value)) {</span>
				<span class="s2">removeWhitespaceError(node);</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Checks JSX nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node to check for matching errors.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">* </span><span class="s1">@private</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">removeInvalidNodeErrorsInJSXText(node) {</span>
			<span class="s4">if </span><span class="s2">(ALL_IRREGULARS.test(node.raw)) {</span>
				<span class="s2">removeWhitespaceError(node);</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Checks the program source for irregular whitespace</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The program node</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">* </span><span class="s1">@private</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">checkForIrregularWhitespace(node) {</span>
			<span class="s4">const </span><span class="s2">sourceLines = sourceCode.lines;</span>

			<span class="s2">sourceLines.forEach((sourceLine, lineIndex) =&gt; {</span>
				<span class="s4">const </span><span class="s2">lineNumber = lineIndex + </span><span class="s6">1</span><span class="s2">;</span>
				<span class="s4">let </span><span class="s2">match;</span>

				<span class="s4">while </span><span class="s2">(</span>
					<span class="s2">(match = IRREGULAR_WHITESPACE.exec(sourceLine)) !== </span><span class="s4">null</span>
				<span class="s2">) {</span>
					<span class="s2">errors.push({</span>
						<span class="s2">node,</span>
						<span class="s2">messageId: </span><span class="s3">&quot;noIrregularWhitespace&quot;</span><span class="s2">,</span>
						<span class="s2">loc: {</span>
							<span class="s2">start: {</span>
								<span class="s2">line: lineNumber,</span>
								<span class="s2">column: match.index,</span>
							<span class="s2">},</span>
							<span class="s2">end: {</span>
								<span class="s2">line: lineNumber,</span>
								<span class="s2">column: match.index + match[</span><span class="s6">0</span><span class="s2">].length,</span>
							<span class="s2">},</span>
						<span class="s2">},</span>
					<span class="s2">});</span>
				<span class="s2">}</span>
			<span class="s2">});</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Checks the program source for irregular line terminators</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The program node</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">* </span><span class="s1">@private</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">checkForIrregularLineTerminators(node) {</span>
			<span class="s4">const </span><span class="s2">source = sourceCode.getText(),</span>
				<span class="s2">sourceLines = sourceCode.lines,</span>
				<span class="s2">linebreaks = source.match(LINE_BREAK);</span>
			<span class="s4">let </span><span class="s2">lastLineIndex = -</span><span class="s6">1</span><span class="s2">,</span>
				<span class="s2">match;</span>

			<span class="s4">while </span><span class="s2">((match = IRREGULAR_LINE_TERMINATORS.exec(source)) !== </span><span class="s4">null</span><span class="s2">) {</span>
				<span class="s4">const </span><span class="s2">lineIndex =</span>
					<span class="s2">linebreaks.indexOf(match[</span><span class="s6">0</span><span class="s2">], lastLineIndex + </span><span class="s6">1</span><span class="s2">) || </span><span class="s6">0</span><span class="s2">;</span>

				<span class="s2">errors.push({</span>
					<span class="s2">node,</span>
					<span class="s2">messageId: </span><span class="s3">&quot;noIrregularWhitespace&quot;</span><span class="s2">,</span>
					<span class="s2">loc: {</span>
						<span class="s2">start: {</span>
							<span class="s2">line: lineIndex + </span><span class="s6">1</span><span class="s2">,</span>
							<span class="s2">column: sourceLines[lineIndex].length,</span>
						<span class="s2">},</span>
						<span class="s2">end: {</span>
							<span class="s2">line: lineIndex + </span><span class="s6">2</span><span class="s2">,</span>
							<span class="s2">column: </span><span class="s6">0</span><span class="s2">,</span>
						<span class="s2">},</span>
					<span class="s2">},</span>
				<span class="s2">});</span>

				<span class="s2">lastLineIndex = lineIndex;</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* A no-op function to act as placeholder for comment accumulation when the `skipComments` option is `false`.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">* </span><span class="s1">@private</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">noop() {}</span>

		<span class="s4">const </span><span class="s2">nodes = {};</span>

		<span class="s4">if </span><span class="s2">(ALL_IRREGULARS.test(sourceCode.getText())) {</span>
			<span class="s2">nodes.Program = </span><span class="s4">function </span><span class="s2">(node) {</span>
				<span class="s0">/* 
                 * As we can easily fire warnings for all white space issues with 
                 * all the source its simpler to fire them here. 
                 * This means we can check all the application code without having 
                 * to worry about issues caused in the parser tokens. 
                 * When writing this code also evaluating per node was missing out 
                 * connecting tokens in some cases. 
                 * We can later filter the errors when they are found to be not an 
                 * issue in nodes we don't care about. 
                 */</span>
				<span class="s2">checkForIrregularWhitespace(node);</span>
				<span class="s2">checkForIrregularLineTerminators(node);</span>
			<span class="s2">};</span>

			<span class="s2">nodes.Literal = removeInvalidNodeErrorsInLiteral;</span>
			<span class="s2">nodes.TemplateElement = skipTemplates</span>
				<span class="s2">? removeInvalidNodeErrorsInTemplateLiteral</span>
				<span class="s2">: noop;</span>
			<span class="s2">nodes.JSXText = skipJSXText</span>
				<span class="s2">? removeInvalidNodeErrorsInJSXText</span>
				<span class="s2">: noop;</span>
			<span class="s2">nodes[</span><span class="s3">&quot;Program:exit&quot;</span><span class="s2">] = </span><span class="s4">function </span><span class="s2">() {</span>
				<span class="s4">if </span><span class="s2">(skipComments) {</span>
					<span class="s0">// First strip errors occurring in comment nodes.</span>
					<span class="s2">commentNodes.forEach(removeInvalidNodeErrorsInComment);</span>
				<span class="s2">}</span>

				<span class="s0">// If we have any errors remaining report on them</span>
				<span class="s2">errors.forEach(error =&gt; context.report(error));</span>
			<span class="s2">};</span>
		<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
			<span class="s2">nodes.Program = noop;</span>
		<span class="s2">}</span>

		<span class="s4">return </span><span class="s2">nodes;</span>
	<span class="s2">},</span>
<span class="s2">};</span>
</pre>
</body>
</html>