<html>
<head>
<title>build-source-map-tree.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
.s5 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
build-source-map-tree.ts</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">{ TraceMap } from </span><span class="s2">'@jridgewell/trace-mapping'</span><span class="s1">;</span>

<span class="s0">import </span><span class="s1">{ OriginalSource, MapSource } from </span><span class="s2">'./source-map-tree'</span><span class="s1">;</span>

<span class="s0">import </span><span class="s1">type { Sources, MapSource as MapSourceType } from </span><span class="s2">'./source-map-tree'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { SourceMapInput, SourceMapLoader, LoaderContext } from </span><span class="s2">'./types'</span><span class="s1">;</span>

<span class="s0">function </span><span class="s1">asArray&lt;T&gt;(value: T | T[]): T[] {</span>
  <span class="s0">if </span><span class="s1">(Array.isArray(value)) </span><span class="s0">return </span><span class="s1">value;</span>
  <span class="s0">return </span><span class="s1">[value];</span>
<span class="s1">}</span>

<span class="s3">/**</span>
 <span class="s3">* Recursively builds a tree structure out of sourcemap files, with each node</span>
 <span class="s3">* being either an `OriginalSource` &quot;leaf&quot; or a `SourceMapTree` composed of</span>
 <span class="s3">* `OriginalSource`s and `SourceMapTree`s.</span>
 <span class="s3">*</span>
 <span class="s3">* Every sourcemap is composed of a collection of source files and mappings</span>
 <span class="s3">* into locations of those source files. When we generate a `SourceMapTree` for</span>
 <span class="s3">* the sourcemap, we attempt to load each source file's own sourcemap. If it</span>
 <span class="s3">* does not have an associated sourcemap, it is considered an original,</span>
 <span class="s3">* unmodified source file.</span>
 <span class="s3">*/</span>
<span class="s0">export default function </span><span class="s1">buildSourceMapTree(</span>
  <span class="s1">input: SourceMapInput | SourceMapInput[],</span>
  <span class="s1">loader: SourceMapLoader,</span>
<span class="s1">): MapSourceType {</span>
  <span class="s0">const </span><span class="s1">maps = asArray(input).map((m) =&gt; </span><span class="s0">new </span><span class="s1">TraceMap(m, </span><span class="s2">''</span><span class="s1">));</span>
  <span class="s0">const </span><span class="s1">map = maps.pop()!;</span>

  <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; maps.length; i++) {</span>
    <span class="s0">if </span><span class="s1">(maps[i].sources.length &gt; </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s0">throw new </span><span class="s1">Error(</span>
        <span class="s2">`Transformation map </span><span class="s1">${i} </span><span class="s2">must have exactly one source file.</span><span class="s5">\n</span><span class="s2">` </span><span class="s1">+</span>
          <span class="s2">'Did you specify these with the most recent transformation maps first?'</span><span class="s1">,</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">let </span><span class="s1">tree = build(map, loader, </span><span class="s2">''</span><span class="s1">, </span><span class="s4">0</span><span class="s1">);</span>
  <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = maps.length - </span><span class="s4">1</span><span class="s1">; i &gt;= </span><span class="s4">0</span><span class="s1">; i--) {</span>
    <span class="s1">tree = MapSource(maps[i], [tree]);</span>
  <span class="s1">}</span>
  <span class="s0">return </span><span class="s1">tree;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">build(</span>
  <span class="s1">map: TraceMap,</span>
  <span class="s1">loader: SourceMapLoader,</span>
  <span class="s1">importer: string,</span>
  <span class="s1">importerDepth: number,</span>
<span class="s1">): MapSourceType {</span>
  <span class="s0">const </span><span class="s1">{ resolvedSources, sourcesContent, ignoreList } = map;</span>

  <span class="s0">const </span><span class="s1">depth = importerDepth + </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s0">const </span><span class="s1">children = resolvedSources.map((sourceFile: string | </span><span class="s0">null</span><span class="s1">, i: number): Sources =&gt; {</span>
    <span class="s3">// The loading context gives the loader more information about why this file is being loaded</span>
    <span class="s3">// (eg, from which importer). It also allows the loader to override the location of the loaded</span>
    <span class="s3">// sourcemap/original source, or to override the content in the sourcesContent field if it's</span>
    <span class="s3">// an unmodified source file.</span>
    <span class="s0">const </span><span class="s1">ctx: LoaderContext = {</span>
      <span class="s1">importer,</span>
      <span class="s1">depth,</span>
      <span class="s1">source: sourceFile || </span><span class="s2">''</span><span class="s1">,</span>
      <span class="s1">content: undefined,</span>
      <span class="s1">ignore: undefined,</span>
    <span class="s1">};</span>

    <span class="s3">// Use the provided loader callback to retrieve the file's sourcemap.</span>
    <span class="s3">// TODO: We should eventually support async loading of sourcemap files.</span>
    <span class="s0">const </span><span class="s1">sourceMap = loader(ctx.source, ctx);</span>

    <span class="s0">const </span><span class="s1">{ source, content, ignore } = ctx;</span>

    <span class="s3">// If there is a sourcemap, then we need to recurse into it to load its source files.</span>
    <span class="s0">if </span><span class="s1">(sourceMap) </span><span class="s0">return </span><span class="s1">build(</span><span class="s0">new </span><span class="s1">TraceMap(sourceMap, source), loader, source, depth);</span>

    <span class="s3">// Else, it's an unmodified source file.</span>
    <span class="s3">// The contents of this unmodified source file can be overridden via the loader context,</span>
    <span class="s3">// allowing it to be explicitly null or a string. If it remains undefined, we fall back to</span>
    <span class="s3">// the importing sourcemap's `sourcesContent` field.</span>
    <span class="s0">const </span><span class="s1">sourceContent =</span>
      <span class="s1">content !== undefined ? content : sourcesContent ? sourcesContent[i] : </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s0">const </span><span class="s1">ignored = ignore !== undefined ? ignore : ignoreList ? ignoreList.includes(i) : </span><span class="s0">false</span><span class="s1">;</span>
    <span class="s0">return </span><span class="s1">OriginalSource(source, sourceContent, ignored);</span>
  <span class="s1">});</span>

  <span class="s0">return </span><span class="s1">MapSource(map, children);</span>
<span class="s1">}</span>
</pre>
</body>
</html>