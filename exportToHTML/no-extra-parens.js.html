<html>
<head>
<title>no-extra-parens.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #8c8c8c; font-style: italic;}
.s2 { color: #080808;}
.s3 { color: #067d17;}
.s4 { color: #0033b3;}
.s5 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
no-extra-parens.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@fileoverview </span><span class="s0">Disallow parenthesising higher precedence subexpressions.</span>
 <span class="s0">* </span><span class="s1">@author </span><span class="s0">Michael Ficarra</span>
 <span class="s0">* </span><span class="s1">@deprecated </span><span class="s0">in ESLint v8.53.0</span>
 <span class="s0">*/</span>
<span class="s3">&quot;use strict&quot;</span><span class="s2">;</span>

<span class="s0">//------------------------------------------------------------------------------</span>
<span class="s0">// Rule Definition</span>
<span class="s0">//------------------------------------------------------------------------------</span>

<span class="s4">const </span><span class="s2">{</span>
	<span class="s2">isParenthesized: isParenthesizedRaw,</span>
<span class="s2">} = require(</span><span class="s3">&quot;@eslint-community/eslint-utils&quot;</span><span class="s2">);</span>
<span class="s4">const </span><span class="s2">astUtils = require(</span><span class="s3">&quot;./utils/ast-utils.js&quot;</span><span class="s2">);</span>

<span class="s0">/** </span><span class="s1">@type </span><span class="s0">{import('../types').Rule.RuleModule} */</span>
<span class="s2">module.exports = {</span>
	<span class="s2">meta: {</span>
		<span class="s2">deprecated: {</span>
			<span class="s2">message: </span><span class="s3">&quot;Formatting rules are being moved out of ESLint core.&quot;</span><span class="s2">,</span>
			<span class="s2">url: </span><span class="s3">&quot;https://eslint.org/blog/2023/10/deprecating-formatting-rules/&quot;</span><span class="s2">,</span>
			<span class="s2">deprecatedSince: </span><span class="s3">&quot;8.53.0&quot;</span><span class="s2">,</span>
			<span class="s2">availableUntil: </span><span class="s3">&quot;10.0.0&quot;</span><span class="s2">,</span>
			<span class="s2">replacedBy: [</span>
				<span class="s2">{</span>
					<span class="s2">message:</span>
						<span class="s3">&quot;ESLint Stylistic now maintains deprecated stylistic core rules.&quot;</span><span class="s2">,</span>
					<span class="s2">url: </span><span class="s3">&quot;https://eslint.style/guide/migration&quot;</span><span class="s2">,</span>
					<span class="s2">plugin: {</span>
						<span class="s2">name: </span><span class="s3">&quot;@stylistic/eslint-plugin&quot;</span><span class="s2">,</span>
						<span class="s2">url: </span><span class="s3">&quot;https://eslint.style&quot;</span><span class="s2">,</span>
					<span class="s2">},</span>
					<span class="s2">rule: {</span>
						<span class="s2">name: </span><span class="s3">&quot;no-extra-parens&quot;</span><span class="s2">,</span>
						<span class="s2">url: </span><span class="s3">&quot;https://eslint.style/rules/no-extra-parens&quot;</span><span class="s2">,</span>
					<span class="s2">},</span>
				<span class="s2">},</span>
			<span class="s2">],</span>
		<span class="s2">},</span>
		<span class="s2">type: </span><span class="s3">&quot;layout&quot;</span><span class="s2">,</span>

		<span class="s2">docs: {</span>
			<span class="s2">description: </span><span class="s3">&quot;Disallow unnecessary parentheses&quot;</span><span class="s2">,</span>
			<span class="s2">recommended: </span><span class="s4">false</span><span class="s2">,</span>
			<span class="s2">url: </span><span class="s3">&quot;https://eslint.org/docs/latest/rules/no-extra-parens&quot;</span><span class="s2">,</span>
		<span class="s2">},</span>

		<span class="s2">fixable: </span><span class="s3">&quot;code&quot;</span><span class="s2">,</span>

		<span class="s2">schema: {</span>
			<span class="s2">anyOf: [</span>
				<span class="s2">{</span>
					<span class="s2">type: </span><span class="s3">&quot;array&quot;</span><span class="s2">,</span>
					<span class="s2">items: [</span>
						<span class="s2">{</span>
							<span class="s4">enum</span><span class="s2">: [</span><span class="s3">&quot;functions&quot;</span><span class="s2">],</span>
						<span class="s2">},</span>
					<span class="s2">],</span>
					<span class="s2">minItems: </span><span class="s5">0</span><span class="s2">,</span>
					<span class="s2">maxItems: </span><span class="s5">1</span><span class="s2">,</span>
				<span class="s2">},</span>
				<span class="s2">{</span>
					<span class="s2">type: </span><span class="s3">&quot;array&quot;</span><span class="s2">,</span>
					<span class="s2">items: [</span>
						<span class="s2">{</span>
							<span class="s4">enum</span><span class="s2">: [</span><span class="s3">&quot;all&quot;</span><span class="s2">],</span>
						<span class="s2">},</span>
						<span class="s2">{</span>
							<span class="s2">type: </span><span class="s3">&quot;object&quot;</span><span class="s2">,</span>
							<span class="s2">properties: {</span>
								<span class="s2">conditionalAssign: { type: </span><span class="s3">&quot;boolean&quot; </span><span class="s2">},</span>
								<span class="s2">ternaryOperandBinaryExpressions: {</span>
									<span class="s2">type: </span><span class="s3">&quot;boolean&quot;</span><span class="s2">,</span>
								<span class="s2">},</span>
								<span class="s2">nestedBinaryExpressions: { type: </span><span class="s3">&quot;boolean&quot; </span><span class="s2">},</span>
								<span class="s2">returnAssign: { type: </span><span class="s3">&quot;boolean&quot; </span><span class="s2">},</span>
								<span class="s2">ignoreJSX: {</span>
									<span class="s4">enum</span><span class="s2">: [</span>
										<span class="s3">&quot;none&quot;</span><span class="s2">,</span>
										<span class="s3">&quot;all&quot;</span><span class="s2">,</span>
										<span class="s3">&quot;single-line&quot;</span><span class="s2">,</span>
										<span class="s3">&quot;multi-line&quot;</span><span class="s2">,</span>
									<span class="s2">],</span>
								<span class="s2">},</span>
								<span class="s2">enforceForArrowConditionals: {</span>
									<span class="s2">type: </span><span class="s3">&quot;boolean&quot;</span><span class="s2">,</span>
								<span class="s2">},</span>
								<span class="s2">enforceForSequenceExpressions: {</span>
									<span class="s2">type: </span><span class="s3">&quot;boolean&quot;</span><span class="s2">,</span>
								<span class="s2">},</span>
								<span class="s2">enforceForNewInMemberExpressions: {</span>
									<span class="s2">type: </span><span class="s3">&quot;boolean&quot;</span><span class="s2">,</span>
								<span class="s2">},</span>
								<span class="s2">enforceForFunctionPrototypeMethods: {</span>
									<span class="s2">type: </span><span class="s3">&quot;boolean&quot;</span><span class="s2">,</span>
								<span class="s2">},</span>
								<span class="s2">allowParensAfterCommentPattern: {</span>
									<span class="s2">type: </span><span class="s3">&quot;string&quot;</span><span class="s2">,</span>
								<span class="s2">},</span>
							<span class="s2">},</span>
							<span class="s2">additionalProperties: </span><span class="s4">false</span><span class="s2">,</span>
						<span class="s2">},</span>
					<span class="s2">],</span>
					<span class="s2">minItems: </span><span class="s5">0</span><span class="s2">,</span>
					<span class="s2">maxItems: </span><span class="s5">2</span><span class="s2">,</span>
				<span class="s2">},</span>
			<span class="s2">],</span>
		<span class="s2">},</span>

		<span class="s2">messages: {</span>
			<span class="s2">unexpected: </span><span class="s3">&quot;Unnecessary parentheses around expression.&quot;</span><span class="s2">,</span>
		<span class="s2">},</span>
	<span class="s2">},</span>

	<span class="s2">create(context) {</span>
		<span class="s4">const </span><span class="s2">sourceCode = context.sourceCode;</span>

		<span class="s4">const </span><span class="s2">tokensToIgnore = </span><span class="s4">new </span><span class="s2">WeakSet();</span>
		<span class="s4">const </span><span class="s2">precedence = astUtils.getPrecedence;</span>
		<span class="s4">const </span><span class="s2">ALL_NODES = context.options[</span><span class="s5">0</span><span class="s2">] !== </span><span class="s3">&quot;functions&quot;</span><span class="s2">;</span>
		<span class="s4">const </span><span class="s2">EXCEPT_COND_ASSIGN =</span>
			<span class="s2">ALL_NODES &amp;&amp;</span>
			<span class="s2">context.options[</span><span class="s5">1</span><span class="s2">] &amp;&amp;</span>
			<span class="s2">context.options[</span><span class="s5">1</span><span class="s2">].conditionalAssign === </span><span class="s4">false</span><span class="s2">;</span>
		<span class="s4">const </span><span class="s2">EXCEPT_COND_TERNARY =</span>
			<span class="s2">ALL_NODES &amp;&amp;</span>
			<span class="s2">context.options[</span><span class="s5">1</span><span class="s2">] &amp;&amp;</span>
			<span class="s2">context.options[</span><span class="s5">1</span><span class="s2">].ternaryOperandBinaryExpressions === </span><span class="s4">false</span><span class="s2">;</span>
		<span class="s4">const </span><span class="s2">NESTED_BINARY =</span>
			<span class="s2">ALL_NODES &amp;&amp;</span>
			<span class="s2">context.options[</span><span class="s5">1</span><span class="s2">] &amp;&amp;</span>
			<span class="s2">context.options[</span><span class="s5">1</span><span class="s2">].nestedBinaryExpressions === </span><span class="s4">false</span><span class="s2">;</span>
		<span class="s4">const </span><span class="s2">EXCEPT_RETURN_ASSIGN =</span>
			<span class="s2">ALL_NODES &amp;&amp;</span>
			<span class="s2">context.options[</span><span class="s5">1</span><span class="s2">] &amp;&amp;</span>
			<span class="s2">context.options[</span><span class="s5">1</span><span class="s2">].returnAssign === </span><span class="s4">false</span><span class="s2">;</span>
		<span class="s4">const </span><span class="s2">IGNORE_JSX =</span>
			<span class="s2">ALL_NODES &amp;&amp; context.options[</span><span class="s5">1</span><span class="s2">] &amp;&amp; context.options[</span><span class="s5">1</span><span class="s2">].ignoreJSX;</span>
		<span class="s4">const </span><span class="s2">IGNORE_ARROW_CONDITIONALS =</span>
			<span class="s2">ALL_NODES &amp;&amp;</span>
			<span class="s2">context.options[</span><span class="s5">1</span><span class="s2">] &amp;&amp;</span>
			<span class="s2">context.options[</span><span class="s5">1</span><span class="s2">].enforceForArrowConditionals === </span><span class="s4">false</span><span class="s2">;</span>
		<span class="s4">const </span><span class="s2">IGNORE_SEQUENCE_EXPRESSIONS =</span>
			<span class="s2">ALL_NODES &amp;&amp;</span>
			<span class="s2">context.options[</span><span class="s5">1</span><span class="s2">] &amp;&amp;</span>
			<span class="s2">context.options[</span><span class="s5">1</span><span class="s2">].enforceForSequenceExpressions === </span><span class="s4">false</span><span class="s2">;</span>
		<span class="s4">const </span><span class="s2">IGNORE_NEW_IN_MEMBER_EXPR =</span>
			<span class="s2">ALL_NODES &amp;&amp;</span>
			<span class="s2">context.options[</span><span class="s5">1</span><span class="s2">] &amp;&amp;</span>
			<span class="s2">context.options[</span><span class="s5">1</span><span class="s2">].enforceForNewInMemberExpressions === </span><span class="s4">false</span><span class="s2">;</span>
		<span class="s4">const </span><span class="s2">IGNORE_FUNCTION_PROTOTYPE_METHODS =</span>
			<span class="s2">ALL_NODES &amp;&amp;</span>
			<span class="s2">context.options[</span><span class="s5">1</span><span class="s2">] &amp;&amp;</span>
			<span class="s2">context.options[</span><span class="s5">1</span><span class="s2">].enforceForFunctionPrototypeMethods === </span><span class="s4">false</span><span class="s2">;</span>
		<span class="s4">const </span><span class="s2">ALLOW_PARENS_AFTER_COMMENT_PATTERN =</span>
			<span class="s2">ALL_NODES &amp;&amp;</span>
			<span class="s2">context.options[</span><span class="s5">1</span><span class="s2">] &amp;&amp;</span>
			<span class="s2">context.options[</span><span class="s5">1</span><span class="s2">].allowParensAfterCommentPattern;</span>

		<span class="s4">const </span><span class="s2">PRECEDENCE_OF_ASSIGNMENT_EXPR = precedence({</span>
			<span class="s2">type: </span><span class="s3">&quot;AssignmentExpression&quot;</span><span class="s2">,</span>
		<span class="s2">});</span>
		<span class="s4">const </span><span class="s2">PRECEDENCE_OF_UPDATE_EXPR = precedence({</span>
			<span class="s2">type: </span><span class="s3">&quot;UpdateExpression&quot;</span><span class="s2">,</span>
		<span class="s2">});</span>

		<span class="s4">let </span><span class="s2">reportsBuffer;</span>

		<span class="s0">/**</span>
		 <span class="s0">* Determines whether the given node is a `call` or `apply` method call, invoked directly on a `FunctionExpression` node.</span>
		 <span class="s0">* Example: function(){}.call()</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The node to be checked.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if the node is an immediate `call` or `apply` method call.</span>
		 <span class="s0">* </span><span class="s1">@private</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">isImmediateFunctionPrototypeMethodCall(node) {</span>
			<span class="s4">const </span><span class="s2">callNode = astUtils.skipChainExpression(node);</span>

			<span class="s4">if </span><span class="s2">(callNode.type !== </span><span class="s3">&quot;CallExpression&quot;</span><span class="s2">) {</span>
				<span class="s4">return false</span><span class="s2">;</span>
			<span class="s2">}</span>
			<span class="s4">const </span><span class="s2">callee = astUtils.skipChainExpression(callNode.callee);</span>

			<span class="s4">return </span><span class="s2">(</span>
				<span class="s2">callee.type === </span><span class="s3">&quot;MemberExpression&quot; </span><span class="s2">&amp;&amp;</span>
				<span class="s2">callee.object.type === </span><span class="s3">&quot;FunctionExpression&quot; </span><span class="s2">&amp;&amp;</span>
				<span class="s2">[</span><span class="s3">&quot;call&quot;</span><span class="s2">, </span><span class="s3">&quot;apply&quot;</span><span class="s2">].includes(</span>
					<span class="s2">astUtils.getStaticPropertyName(callee),</span>
				<span class="s2">)</span>
			<span class="s2">);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Determines if this rule should be enforced for a node given the current configuration.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The node to be checked.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if the rule should be enforced for this node.</span>
		 <span class="s0">* </span><span class="s1">@private</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">ruleApplies(node) {</span>
			<span class="s4">if </span><span class="s2">(node.type === </span><span class="s3">&quot;JSXElement&quot; </span><span class="s2">|| node.type === </span><span class="s3">&quot;JSXFragment&quot;</span><span class="s2">) {</span>
				<span class="s4">const </span><span class="s2">isSingleLine = node.loc.start.line === node.loc.end.line;</span>

				<span class="s4">switch </span><span class="s2">(IGNORE_JSX) {</span>
					<span class="s0">// Exclude this JSX element from linting</span>
					<span class="s4">case </span><span class="s3">&quot;all&quot;</span><span class="s2">:</span>
						<span class="s4">return false</span><span class="s2">;</span>

					<span class="s0">// Exclude this JSX element if it is multi-line element</span>
					<span class="s4">case </span><span class="s3">&quot;multi-line&quot;</span><span class="s2">:</span>
						<span class="s4">return </span><span class="s2">isSingleLine;</span>

					<span class="s0">// Exclude this JSX element if it is single-line element</span>
					<span class="s4">case </span><span class="s3">&quot;single-line&quot;</span><span class="s2">:</span>
						<span class="s4">return </span><span class="s2">!isSingleLine;</span>

					<span class="s0">// Nothing special to be done for JSX elements</span>
					<span class="s4">case </span><span class="s3">&quot;none&quot;</span><span class="s2">:</span>
						<span class="s4">break</span><span class="s2">;</span>

					<span class="s0">// no default</span>
				<span class="s2">}</span>
			<span class="s2">}</span>

			<span class="s4">if </span><span class="s2">(</span>
				<span class="s2">node.type === </span><span class="s3">&quot;SequenceExpression&quot; </span><span class="s2">&amp;&amp;</span>
				<span class="s2">IGNORE_SEQUENCE_EXPRESSIONS</span>
			<span class="s2">) {</span>
				<span class="s4">return false</span><span class="s2">;</span>
			<span class="s2">}</span>

			<span class="s4">if </span><span class="s2">(</span>
				<span class="s2">isImmediateFunctionPrototypeMethodCall(node) &amp;&amp;</span>
				<span class="s2">IGNORE_FUNCTION_PROTOTYPE_METHODS</span>
			<span class="s2">) {</span>
				<span class="s4">return false</span><span class="s2">;</span>
			<span class="s2">}</span>

			<span class="s4">return </span><span class="s2">(</span>
				<span class="s2">ALL_NODES ||</span>
				<span class="s2">node.type === </span><span class="s3">&quot;FunctionExpression&quot; </span><span class="s2">||</span>
				<span class="s2">node.type === </span><span class="s3">&quot;ArrowFunctionExpression&quot;</span>
			<span class="s2">);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Determines if a node is surrounded by parentheses.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The node to be checked.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if the node is parenthesised.</span>
		 <span class="s0">* </span><span class="s1">@private</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">isParenthesised(node) {</span>
			<span class="s4">return </span><span class="s2">isParenthesizedRaw(</span><span class="s5">1</span><span class="s2">, node, sourceCode);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Determines if a node is surrounded by parentheses twice.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The node to be checked.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if the node is doubly parenthesised.</span>
		 <span class="s0">* </span><span class="s1">@private</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">isParenthesisedTwice(node) {</span>
			<span class="s4">return </span><span class="s2">isParenthesizedRaw(</span><span class="s5">2</span><span class="s2">, node, sourceCode);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Determines if a node is surrounded by (potentially) invalid parentheses.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The node to be checked.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if the node is incorrectly parenthesised.</span>
		 <span class="s0">* </span><span class="s1">@private</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">hasExcessParens(node) {</span>
			<span class="s4">return </span><span class="s2">ruleApplies(node) &amp;&amp; isParenthesised(node);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Determines if a node that is expected to be parenthesised is surrounded by</span>
		 <span class="s0">* (potentially) invalid extra parentheses.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The node to be checked.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if the node is has an unexpected extra pair of parentheses.</span>
		 <span class="s0">* </span><span class="s1">@private</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">hasDoubleExcessParens(node) {</span>
			<span class="s4">return </span><span class="s2">ruleApplies(node) &amp;&amp; isParenthesisedTwice(node);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Determines if a node that is expected to be parenthesised is surrounded by</span>
		 <span class="s0">* (potentially) invalid extra parentheses with considering precedence level of the node.</span>
		 <span class="s0">* If the preference level of the node is not higher or equal to precedence lower limit, it also checks</span>
		 <span class="s0">* whether the node is surrounded by parentheses twice or not.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The node to be checked.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{number} precedenceLowerLimit The lower limit of precedence.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if the node is has an unexpected extra pair of parentheses.</span>
		 <span class="s0">* </span><span class="s1">@private</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">hasExcessParensWithPrecedence(node, precedenceLowerLimit) {</span>
			<span class="s4">if </span><span class="s2">(ruleApplies(node) &amp;&amp; isParenthesised(node)) {</span>
				<span class="s4">if </span><span class="s2">(</span>
					<span class="s2">precedence(node) &gt;= precedenceLowerLimit ||</span>
					<span class="s2">isParenthesisedTwice(node)</span>
				<span class="s2">) {</span>
					<span class="s4">return true</span><span class="s2">;</span>
				<span class="s2">}</span>
			<span class="s2">}</span>
			<span class="s4">return false</span><span class="s2">;</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Determines if a node test expression is allowed to have a parenthesised assignment</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The node to be checked.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if the assignment can be parenthesised.</span>
		 <span class="s0">* </span><span class="s1">@private</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">isCondAssignException(node) {</span>
			<span class="s4">return </span><span class="s2">(</span>
				<span class="s2">EXCEPT_COND_ASSIGN &amp;&amp; node.test.type === </span><span class="s3">&quot;AssignmentExpression&quot;</span>
			<span class="s2">);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Determines if a node is in a return statement</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The node to be checked.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if the node is in a return statement.</span>
		 <span class="s0">* </span><span class="s1">@private</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">isInReturnStatement(node) {</span>
			<span class="s4">for </span><span class="s2">(</span>
				<span class="s4">let </span><span class="s2">currentNode = node;</span>
				<span class="s2">currentNode;</span>
				<span class="s2">currentNode = currentNode.parent</span>
			<span class="s2">) {</span>
				<span class="s4">if </span><span class="s2">(</span>
					<span class="s2">currentNode.type === </span><span class="s3">&quot;ReturnStatement&quot; </span><span class="s2">||</span>
					<span class="s2">(currentNode.type === </span><span class="s3">&quot;ArrowFunctionExpression&quot; </span><span class="s2">&amp;&amp;</span>
						<span class="s2">currentNode.body.type !== </span><span class="s3">&quot;BlockStatement&quot;</span><span class="s2">)</span>
				<span class="s2">) {</span>
					<span class="s4">return true</span><span class="s2">;</span>
				<span class="s2">}</span>
			<span class="s2">}</span>

			<span class="s4">return false</span><span class="s2">;</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Determines if a constructor function is newed-up with parens</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} newExpression The NewExpression node to be checked.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if the constructor is called with parens.</span>
		 <span class="s0">* </span><span class="s1">@private</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">isNewExpressionWithParens(newExpression) {</span>
			<span class="s4">const </span><span class="s2">lastToken = sourceCode.getLastToken(newExpression);</span>
			<span class="s4">const </span><span class="s2">penultimateToken = sourceCode.getTokenBefore(lastToken);</span>

			<span class="s4">return </span><span class="s2">(</span>
				<span class="s2">newExpression.arguments.length &gt; </span><span class="s5">0 </span><span class="s2">||</span>
				<span class="s0">// The expression should end with its own parens, e.g., new new foo() is not a new expression with parens</span>
				<span class="s2">(astUtils.isOpeningParenToken(penultimateToken) &amp;&amp;</span>
					<span class="s2">astUtils.isClosingParenToken(lastToken) &amp;&amp;</span>
					<span class="s2">newExpression.callee.range[</span><span class="s5">1</span><span class="s2">] &lt; newExpression.range[</span><span class="s5">1</span><span class="s2">])</span>
			<span class="s2">);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Determines if a node is or contains an assignment expression</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The node to be checked.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if the node is or contains an assignment expression.</span>
		 <span class="s0">* </span><span class="s1">@private</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">containsAssignment(node) {</span>
			<span class="s4">if </span><span class="s2">(node.type === </span><span class="s3">&quot;AssignmentExpression&quot;</span><span class="s2">) {</span>
				<span class="s4">return true</span><span class="s2">;</span>
			<span class="s2">}</span>
			<span class="s4">if </span><span class="s2">(</span>
				<span class="s2">node.type === </span><span class="s3">&quot;ConditionalExpression&quot; </span><span class="s2">&amp;&amp;</span>
				<span class="s2">(node.consequent.type === </span><span class="s3">&quot;AssignmentExpression&quot; </span><span class="s2">||</span>
					<span class="s2">node.alternate.type === </span><span class="s3">&quot;AssignmentExpression&quot;</span><span class="s2">)</span>
			<span class="s2">) {</span>
				<span class="s4">return true</span><span class="s2">;</span>
			<span class="s2">}</span>
			<span class="s4">if </span><span class="s2">(</span>
				<span class="s2">(node.left &amp;&amp; node.left.type === </span><span class="s3">&quot;AssignmentExpression&quot;</span><span class="s2">) ||</span>
				<span class="s2">(node.right &amp;&amp; node.right.type === </span><span class="s3">&quot;AssignmentExpression&quot;</span><span class="s2">)</span>
			<span class="s2">) {</span>
				<span class="s4">return true</span><span class="s2">;</span>
			<span class="s2">}</span>

			<span class="s4">return false</span><span class="s2">;</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Determines if a node is contained by or is itself a return statement and is allowed to have a parenthesised assignment</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The node to be checked.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if the assignment can be parenthesised.</span>
		 <span class="s0">* </span><span class="s1">@private</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">isReturnAssignException(node) {</span>
			<span class="s4">if </span><span class="s2">(!EXCEPT_RETURN_ASSIGN || !isInReturnStatement(node)) {</span>
				<span class="s4">return false</span><span class="s2">;</span>
			<span class="s2">}</span>

			<span class="s4">if </span><span class="s2">(node.type === </span><span class="s3">&quot;ReturnStatement&quot;</span><span class="s2">) {</span>
				<span class="s4">return </span><span class="s2">node.argument &amp;&amp; containsAssignment(node.argument);</span>
			<span class="s2">}</span>
			<span class="s4">if </span><span class="s2">(</span>
				<span class="s2">node.type === </span><span class="s3">&quot;ArrowFunctionExpression&quot; </span><span class="s2">&amp;&amp;</span>
				<span class="s2">node.body.type !== </span><span class="s3">&quot;BlockStatement&quot;</span>
			<span class="s2">) {</span>
				<span class="s4">return </span><span class="s2">containsAssignment(node.body);</span>
			<span class="s2">}</span>
			<span class="s4">return </span><span class="s2">containsAssignment(node);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Determines if a node following a [no LineTerminator here] restriction is</span>
		 <span class="s0">* surrounded by (potentially) invalid extra parentheses.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Token} token The token preceding the [no LineTerminator here] restriction.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The node to be checked.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if the node is incorrectly parenthesised.</span>
		 <span class="s0">* </span><span class="s1">@private</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">hasExcessParensNoLineTerminator(token, node) {</span>
			<span class="s4">if </span><span class="s2">(token.loc.end.line === node.loc.start.line) {</span>
				<span class="s4">return </span><span class="s2">hasExcessParens(node);</span>
			<span class="s2">}</span>

			<span class="s4">return </span><span class="s2">hasDoubleExcessParens(node);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Determines whether a node should be preceded by an additional space when removing parens</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node node to evaluate; must be surrounded by parentheses</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} `true` if a space should be inserted before the node</span>
		 <span class="s0">* </span><span class="s1">@private</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">requiresLeadingSpace(node) {</span>
			<span class="s4">const </span><span class="s2">leftParenToken = sourceCode.getTokenBefore(node);</span>
			<span class="s4">const </span><span class="s2">tokenBeforeLeftParen = sourceCode.getTokenBefore(</span>
				<span class="s2">leftParenToken,</span>
				<span class="s2">{ includeComments: </span><span class="s4">true </span><span class="s2">},</span>
			<span class="s2">);</span>
			<span class="s4">const </span><span class="s2">tokenAfterLeftParen = sourceCode.getTokenAfter(</span>
				<span class="s2">leftParenToken,</span>
				<span class="s2">{ includeComments: </span><span class="s4">true </span><span class="s2">},</span>
			<span class="s2">);</span>

			<span class="s4">return </span><span class="s2">(</span>
				<span class="s2">tokenBeforeLeftParen &amp;&amp;</span>
				<span class="s2">tokenBeforeLeftParen.range[</span><span class="s5">1</span><span class="s2">] === leftParenToken.range[</span><span class="s5">0</span><span class="s2">] &amp;&amp;</span>
				<span class="s2">leftParenToken.range[</span><span class="s5">1</span><span class="s2">] === tokenAfterLeftParen.range[</span><span class="s5">0</span><span class="s2">] &amp;&amp;</span>
				<span class="s2">!astUtils.canTokensBeAdjacent(</span>
					<span class="s2">tokenBeforeLeftParen,</span>
					<span class="s2">tokenAfterLeftParen,</span>
				<span class="s2">)</span>
			<span class="s2">);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Determines whether a node should be followed by an additional space when removing parens</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node node to evaluate; must be surrounded by parentheses</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} `true` if a space should be inserted after the node</span>
		 <span class="s0">* </span><span class="s1">@private</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">requiresTrailingSpace(node) {</span>
			<span class="s4">const </span><span class="s2">nextTwoTokens = sourceCode.getTokensAfter(node, { count: </span><span class="s5">2 </span><span class="s2">});</span>
			<span class="s4">const </span><span class="s2">rightParenToken = nextTwoTokens[</span><span class="s5">0</span><span class="s2">];</span>
			<span class="s4">const </span><span class="s2">tokenAfterRightParen = nextTwoTokens[</span><span class="s5">1</span><span class="s2">];</span>
			<span class="s4">const </span><span class="s2">tokenBeforeRightParen = sourceCode.getLastToken(node);</span>

			<span class="s4">return </span><span class="s2">(</span>
				<span class="s2">rightParenToken &amp;&amp;</span>
				<span class="s2">tokenAfterRightParen &amp;&amp;</span>
				<span class="s2">!sourceCode.isSpaceBetweenTokens(</span>
					<span class="s2">rightParenToken,</span>
					<span class="s2">tokenAfterRightParen,</span>
				<span class="s2">) &amp;&amp;</span>
				<span class="s2">!astUtils.canTokensBeAdjacent(</span>
					<span class="s2">tokenBeforeRightParen,</span>
					<span class="s2">tokenAfterRightParen,</span>
				<span class="s2">)</span>
			<span class="s2">);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Determines if a given expression node is an IIFE</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The node to check</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} `true` if the given node is an IIFE</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">isIIFE(node) {</span>
			<span class="s4">const </span><span class="s2">maybeCallNode = astUtils.skipChainExpression(node);</span>

			<span class="s4">return </span><span class="s2">(</span>
				<span class="s2">maybeCallNode.type === </span><span class="s3">&quot;CallExpression&quot; </span><span class="s2">&amp;&amp;</span>
				<span class="s2">maybeCallNode.callee.type === </span><span class="s3">&quot;FunctionExpression&quot;</span>
			<span class="s2">);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Determines if the given node can be the assignment target in destructuring or the LHS of an assignment.</span>
		 <span class="s0">* This is to avoid an autofix that could change behavior because parsers mistakenly allow invalid syntax,</span>
		 <span class="s0">* such as `(a = b) = c` and `[(a = b) = c] = []`. Ideally, this function shouldn't be necessary.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} [node] The node to check</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} `true` if the given node can be a valid assignment target</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">canBeAssignmentTarget(node) {</span>
			<span class="s4">return </span><span class="s2">(</span>
				<span class="s2">node &amp;&amp;</span>
				<span class="s2">(node.type === </span><span class="s3">&quot;Identifier&quot; </span><span class="s2">|| node.type === </span><span class="s3">&quot;MemberExpression&quot;</span><span class="s2">)</span>
			<span class="s2">);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Checks if a node is fixable.</span>
		 <span class="s0">* A node is fixable if removing a single pair of surrounding parentheses does not turn it</span>
		 <span class="s0">* into a directive after fixing other nodes.</span>
		 <span class="s0">* Almost all nodes are fixable, except if all of the following conditions are met:</span>
		 <span class="s0">* The node is a string Literal</span>
		 <span class="s0">* It has a single pair of parentheses</span>
		 <span class="s0">* It is the only child of an ExpressionStatement</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The node to evaluate.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} Whether or not the node is fixable.</span>
		 <span class="s0">* </span><span class="s1">@private</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">isFixable(node) {</span>
			<span class="s0">// if it's not a string literal it can be autofixed</span>
			<span class="s4">if </span><span class="s2">(node.type !== </span><span class="s3">&quot;Literal&quot; </span><span class="s2">|| </span><span class="s4">typeof </span><span class="s2">node.value !== </span><span class="s3">&quot;string&quot;</span><span class="s2">) {</span>
				<span class="s4">return true</span><span class="s2">;</span>
			<span class="s2">}</span>
			<span class="s4">if </span><span class="s2">(isParenthesisedTwice(node)) {</span>
				<span class="s4">return true</span><span class="s2">;</span>
			<span class="s2">}</span>
			<span class="s4">return </span><span class="s2">!astUtils.isTopLevelExpressionStatement(node.parent);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Report the node</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node node to evaluate</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">* </span><span class="s1">@private</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">report(node) {</span>
			<span class="s4">const </span><span class="s2">leftParenToken = sourceCode.getTokenBefore(node);</span>
			<span class="s4">const </span><span class="s2">rightParenToken = sourceCode.getTokenAfter(node);</span>

			<span class="s4">if </span><span class="s2">(!isParenthesisedTwice(node)) {</span>
				<span class="s4">if </span><span class="s2">(tokensToIgnore.has(sourceCode.getFirstToken(node))) {</span>
					<span class="s4">return</span><span class="s2">;</span>
				<span class="s2">}</span>

				<span class="s4">if </span><span class="s2">(isIIFE(node) &amp;&amp; !isParenthesised(node.callee)) {</span>
					<span class="s4">return</span><span class="s2">;</span>
				<span class="s2">}</span>

				<span class="s4">if </span><span class="s2">(ALLOW_PARENS_AFTER_COMMENT_PATTERN) {</span>
					<span class="s4">const </span><span class="s2">commentsBeforeLeftParenToken =</span>
						<span class="s2">sourceCode.getCommentsBefore(leftParenToken);</span>
					<span class="s4">const </span><span class="s2">totalCommentsBeforeLeftParenTokenCount =</span>
						<span class="s2">commentsBeforeLeftParenToken.length;</span>
					<span class="s4">const </span><span class="s2">ignorePattern = </span><span class="s4">new </span><span class="s2">RegExp(</span>
						<span class="s2">ALLOW_PARENS_AFTER_COMMENT_PATTERN,</span>
						<span class="s3">&quot;u&quot;</span><span class="s2">,</span>
					<span class="s2">);</span>

					<span class="s4">if </span><span class="s2">(</span>
						<span class="s2">totalCommentsBeforeLeftParenTokenCount &gt; </span><span class="s5">0 </span><span class="s2">&amp;&amp;</span>
						<span class="s2">ignorePattern.test(</span>
							<span class="s2">commentsBeforeLeftParenToken[</span>
								<span class="s2">totalCommentsBeforeLeftParenTokenCount - </span><span class="s5">1</span>
							<span class="s2">].value,</span>
						<span class="s2">)</span>
					<span class="s2">) {</span>
						<span class="s4">return</span><span class="s2">;</span>
					<span class="s2">}</span>
				<span class="s2">}</span>
			<span class="s2">}</span>

			<span class="s0">/**</span>
			 <span class="s0">* Finishes reporting</span>
			 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
			 <span class="s0">* </span><span class="s1">@private</span>
			 <span class="s0">*/</span>
			<span class="s4">function </span><span class="s2">finishReport() {</span>
				<span class="s2">context.report({</span>
					<span class="s2">node,</span>
					<span class="s2">loc: leftParenToken.loc,</span>
					<span class="s2">messageId: </span><span class="s3">&quot;unexpected&quot;</span><span class="s2">,</span>
					<span class="s2">fix: isFixable(node)</span>
						<span class="s2">? fixer =&gt; {</span>
								<span class="s4">const </span><span class="s2">parenthesizedSource =</span>
									<span class="s2">sourceCode.text.slice(</span>
										<span class="s2">leftParenToken.range[</span><span class="s5">1</span><span class="s2">],</span>
										<span class="s2">rightParenToken.range[</span><span class="s5">0</span><span class="s2">],</span>
									<span class="s2">);</span>

								<span class="s4">return </span><span class="s2">fixer.replaceTextRange(</span>
									<span class="s2">[</span>
										<span class="s2">leftParenToken.range[</span><span class="s5">0</span><span class="s2">],</span>
										<span class="s2">rightParenToken.range[</span><span class="s5">1</span><span class="s2">],</span>
									<span class="s2">],</span>
									<span class="s2">(requiresLeadingSpace(node) ? </span><span class="s3">&quot; &quot; </span><span class="s2">: </span><span class="s3">&quot;&quot;</span><span class="s2">) +</span>
										<span class="s2">parenthesizedSource +</span>
										<span class="s2">(requiresTrailingSpace(node)</span>
											<span class="s2">? </span><span class="s3">&quot; &quot;</span>
											<span class="s2">: </span><span class="s3">&quot;&quot;</span><span class="s2">),</span>
								<span class="s2">);</span>
							<span class="s2">}</span>
						<span class="s2">: </span><span class="s4">null</span><span class="s2">,</span>
				<span class="s2">});</span>
			<span class="s2">}</span>

			<span class="s4">if </span><span class="s2">(reportsBuffer) {</span>
				<span class="s2">reportsBuffer.reports.push({ node, finishReport });</span>
				<span class="s4">return</span><span class="s2">;</span>
			<span class="s2">}</span>

			<span class="s2">finishReport();</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Evaluate a argument of the node.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node node to evaluate</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">* </span><span class="s1">@private</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">checkArgumentWithPrecedence(node) {</span>
			<span class="s4">if </span><span class="s2">(</span>
				<span class="s2">hasExcessParensWithPrecedence(node.argument, precedence(node))</span>
			<span class="s2">) {</span>
				<span class="s2">report(node.argument);</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Check if a member expression contains a call expression</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node MemberExpression node to evaluate</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} true if found, false if not</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">doesMemberExpressionContainCallExpression(node) {</span>
			<span class="s4">let </span><span class="s2">currentNode = node.object;</span>
			<span class="s4">let </span><span class="s2">currentNodeType = node.object.type;</span>

			<span class="s4">while </span><span class="s2">(currentNodeType === </span><span class="s3">&quot;MemberExpression&quot;</span><span class="s2">) {</span>
				<span class="s2">currentNode = currentNode.object;</span>
				<span class="s2">currentNodeType = currentNode.type;</span>
			<span class="s2">}</span>

			<span class="s4">return </span><span class="s2">currentNodeType === </span><span class="s3">&quot;CallExpression&quot;</span><span class="s2">;</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Evaluate a new call</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node node to evaluate</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">* </span><span class="s1">@private</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">checkCallNew(node) {</span>
			<span class="s4">const </span><span class="s2">callee = node.callee;</span>

			<span class="s4">if </span><span class="s2">(hasExcessParensWithPrecedence(callee, precedence(node))) {</span>
				<span class="s4">if </span><span class="s2">(</span>
					<span class="s2">hasDoubleExcessParens(callee) ||</span>
					<span class="s2">!(</span>
						<span class="s2">isIIFE(node) ||</span>
						<span class="s0">// (new A)(); new (new A)();</span>
						<span class="s2">(callee.type === </span><span class="s3">&quot;NewExpression&quot; </span><span class="s2">&amp;&amp;</span>
							<span class="s2">!isNewExpressionWithParens(callee) &amp;&amp;</span>
							<span class="s2">!(</span>
								<span class="s2">node.type === </span><span class="s3">&quot;NewExpression&quot; </span><span class="s2">&amp;&amp;</span>
								<span class="s2">!isNewExpressionWithParens(node)</span>
							<span class="s2">)) ||</span>
						<span class="s0">// new (a().b)(); new (a.b().c);</span>
						<span class="s2">(node.type === </span><span class="s3">&quot;NewExpression&quot; </span><span class="s2">&amp;&amp;</span>
							<span class="s2">callee.type === </span><span class="s3">&quot;MemberExpression&quot; </span><span class="s2">&amp;&amp;</span>
							<span class="s2">doesMemberExpressionContainCallExpression(</span>
								<span class="s2">callee,</span>
							<span class="s2">)) ||</span>
						<span class="s0">// (a?.b)(); (a?.())();</span>
						<span class="s2">(!node.optional &amp;&amp; callee.type === </span><span class="s3">&quot;ChainExpression&quot;</span><span class="s2">)</span>
					<span class="s2">)</span>
				<span class="s2">) {</span>
					<span class="s2">report(node.callee);</span>
				<span class="s2">}</span>
			<span class="s2">}</span>
			<span class="s2">node.arguments</span>
				<span class="s2">.filter(arg =&gt;</span>
					<span class="s2">hasExcessParensWithPrecedence(</span>
						<span class="s2">arg,</span>
						<span class="s2">PRECEDENCE_OF_ASSIGNMENT_EXPR,</span>
					<span class="s2">),</span>
				<span class="s2">)</span>
				<span class="s2">.forEach(report);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Evaluate binary logicals</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node node to evaluate</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">* </span><span class="s1">@private</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">checkBinaryLogical(node) {</span>
			<span class="s4">const </span><span class="s2">prec = precedence(node);</span>
			<span class="s4">const </span><span class="s2">leftPrecedence = precedence(node.left);</span>
			<span class="s4">const </span><span class="s2">rightPrecedence = precedence(node.right);</span>
			<span class="s4">const </span><span class="s2">isExponentiation = node.operator === </span><span class="s3">&quot;**&quot;</span><span class="s2">;</span>
			<span class="s4">const </span><span class="s2">shouldSkipLeft =</span>
				<span class="s2">NESTED_BINARY &amp;&amp;</span>
				<span class="s2">(node.left.type === </span><span class="s3">&quot;BinaryExpression&quot; </span><span class="s2">||</span>
					<span class="s2">node.left.type === </span><span class="s3">&quot;LogicalExpression&quot;</span><span class="s2">);</span>
			<span class="s4">const </span><span class="s2">shouldSkipRight =</span>
				<span class="s2">NESTED_BINARY &amp;&amp;</span>
				<span class="s2">(node.right.type === </span><span class="s3">&quot;BinaryExpression&quot; </span><span class="s2">||</span>
					<span class="s2">node.right.type === </span><span class="s3">&quot;LogicalExpression&quot;</span><span class="s2">);</span>

			<span class="s4">if </span><span class="s2">(!shouldSkipLeft &amp;&amp; hasExcessParens(node.left)) {</span>
				<span class="s4">if </span><span class="s2">(</span>
					<span class="s2">(!(</span>
						<span class="s2">[</span><span class="s3">&quot;AwaitExpression&quot;</span><span class="s2">, </span><span class="s3">&quot;UnaryExpression&quot;</span><span class="s2">].includes(</span>
							<span class="s2">node.left.type,</span>
						<span class="s2">) &amp;&amp; isExponentiation</span>
					<span class="s2">) &amp;&amp;</span>
						<span class="s2">!astUtils.isMixedLogicalAndCoalesceExpressions(</span>
							<span class="s2">node.left,</span>
							<span class="s2">node,</span>
						<span class="s2">) &amp;&amp;</span>
						<span class="s2">(leftPrecedence &gt; prec ||</span>
							<span class="s2">(leftPrecedence === prec &amp;&amp; !isExponentiation))) ||</span>
					<span class="s2">isParenthesisedTwice(node.left)</span>
				<span class="s2">) {</span>
					<span class="s2">report(node.left);</span>
				<span class="s2">}</span>
			<span class="s2">}</span>

			<span class="s4">if </span><span class="s2">(!shouldSkipRight &amp;&amp; hasExcessParens(node.right)) {</span>
				<span class="s4">if </span><span class="s2">(</span>
					<span class="s2">(!astUtils.isMixedLogicalAndCoalesceExpressions(</span>
						<span class="s2">node.right,</span>
						<span class="s2">node,</span>
					<span class="s2">) &amp;&amp;</span>
						<span class="s2">(rightPrecedence &gt; prec ||</span>
							<span class="s2">(rightPrecedence === prec &amp;&amp; isExponentiation))) ||</span>
					<span class="s2">isParenthesisedTwice(node.right)</span>
				<span class="s2">) {</span>
					<span class="s2">report(node.right);</span>
				<span class="s2">}</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Check the parentheses around the super class of the given class definition.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The node of class declarations to check.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">checkClass(node) {</span>
			<span class="s4">if </span><span class="s2">(!node.superClass) {</span>
				<span class="s4">return</span><span class="s2">;</span>
			<span class="s2">}</span>

			<span class="s0">/* 
             * If `node.superClass` is a LeftHandSideExpression, parentheses are extra. 
             * Otherwise, parentheses are needed. 
             */</span>
			<span class="s4">const </span><span class="s2">hasExtraParens =</span>
				<span class="s2">precedence(node.superClass) &gt; PRECEDENCE_OF_UPDATE_EXPR</span>
					<span class="s2">? hasExcessParens(node.superClass)</span>
					<span class="s2">: hasDoubleExcessParens(node.superClass);</span>

			<span class="s4">if </span><span class="s2">(hasExtraParens) {</span>
				<span class="s2">report(node.superClass);</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Check the parentheses around the argument of the given spread operator.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The node of spread elements/properties to check.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">checkSpreadOperator(node) {</span>
			<span class="s4">if </span><span class="s2">(</span>
				<span class="s2">hasExcessParensWithPrecedence(</span>
					<span class="s2">node.argument,</span>
					<span class="s2">PRECEDENCE_OF_ASSIGNMENT_EXPR,</span>
				<span class="s2">)</span>
			<span class="s2">) {</span>
				<span class="s2">report(node.argument);</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Checks the parentheses for an ExpressionStatement or ExportDefaultDeclaration</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node The ExpressionStatement.expression or ExportDefaultDeclaration.declaration node</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">checkExpressionOrExportStatement(node) {</span>
			<span class="s4">const </span><span class="s2">firstToken = isParenthesised(node)</span>
				<span class="s2">? sourceCode.getTokenBefore(node)</span>
				<span class="s2">: sourceCode.getFirstToken(node);</span>
			<span class="s4">const </span><span class="s2">secondToken = sourceCode.getTokenAfter(</span>
				<span class="s2">firstToken,</span>
				<span class="s2">astUtils.isNotOpeningParenToken,</span>
			<span class="s2">);</span>
			<span class="s4">const </span><span class="s2">thirdToken = secondToken</span>
				<span class="s2">? sourceCode.getTokenAfter(secondToken)</span>
				<span class="s2">: </span><span class="s4">null</span><span class="s2">;</span>
			<span class="s4">const </span><span class="s2">tokenAfterClosingParens = secondToken</span>
				<span class="s2">? sourceCode.getTokenAfter(</span>
						<span class="s2">secondToken,</span>
						<span class="s2">astUtils.isNotClosingParenToken,</span>
					<span class="s2">)</span>
				<span class="s2">: </span><span class="s4">null</span><span class="s2">;</span>

			<span class="s4">if </span><span class="s2">(</span>
				<span class="s2">astUtils.isOpeningParenToken(firstToken) &amp;&amp;</span>
				<span class="s2">(astUtils.isOpeningBraceToken(secondToken) ||</span>
					<span class="s2">(secondToken.type === </span><span class="s3">&quot;Keyword&quot; </span><span class="s2">&amp;&amp;</span>
						<span class="s2">(secondToken.value === </span><span class="s3">&quot;function&quot; </span><span class="s2">||</span>
							<span class="s2">secondToken.value === </span><span class="s3">&quot;class&quot; </span><span class="s2">||</span>
							<span class="s2">(secondToken.value === </span><span class="s3">&quot;let&quot; </span><span class="s2">&amp;&amp;</span>
								<span class="s2">tokenAfterClosingParens &amp;&amp;</span>
								<span class="s2">(astUtils.isOpeningBracketToken(</span>
									<span class="s2">tokenAfterClosingParens,</span>
								<span class="s2">) ||</span>
									<span class="s2">tokenAfterClosingParens.type ===</span>
										<span class="s3">&quot;Identifier&quot;</span><span class="s2">)))) ||</span>
					<span class="s2">(secondToken &amp;&amp;</span>
						<span class="s2">secondToken.type === </span><span class="s3">&quot;Identifier&quot; </span><span class="s2">&amp;&amp;</span>
						<span class="s2">secondToken.value === </span><span class="s3">&quot;async&quot; </span><span class="s2">&amp;&amp;</span>
						<span class="s2">thirdToken &amp;&amp;</span>
						<span class="s2">thirdToken.type === </span><span class="s3">&quot;Keyword&quot; </span><span class="s2">&amp;&amp;</span>
						<span class="s2">thirdToken.value === </span><span class="s3">&quot;function&quot;</span><span class="s2">))</span>
			<span class="s2">) {</span>
				<span class="s2">tokensToIgnore.add(secondToken);</span>
			<span class="s2">}</span>

			<span class="s4">const </span><span class="s2">hasExtraParens =</span>
				<span class="s2">node.parent.type === </span><span class="s3">&quot;ExportDefaultDeclaration&quot;</span>
					<span class="s2">? hasExcessParensWithPrecedence(</span>
							<span class="s2">node,</span>
							<span class="s2">PRECEDENCE_OF_ASSIGNMENT_EXPR,</span>
						<span class="s2">)</span>
					<span class="s2">: hasExcessParens(node);</span>

			<span class="s4">if </span><span class="s2">(hasExtraParens) {</span>
				<span class="s2">report(node);</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Finds the path from the given node to the specified ancestor.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node First node in the path.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} ancestor Last node in the path.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ASTNode[]} Path, including both nodes.</span>
		 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} If the given node does not have the specified ancestor.</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">pathToAncestor(node, ancestor) {</span>
			<span class="s4">const </span><span class="s2">path = [node];</span>
			<span class="s4">let </span><span class="s2">currentNode = node;</span>

			<span class="s4">while </span><span class="s2">(currentNode !== ancestor) {</span>
				<span class="s2">currentNode = currentNode.parent;</span>

				<span class="s0">/* c8 ignore start */</span>
				<span class="s4">if </span><span class="s2">(currentNode === </span><span class="s4">null</span><span class="s2">) {</span>
					<span class="s4">throw new </span><span class="s2">Error(</span>
						<span class="s3">&quot;Nodes are not in the ancestor-descendant relationship.&quot;</span><span class="s2">,</span>
					<span class="s2">);</span>
				<span class="s2">} </span><span class="s0">/* c8 ignore stop */</span>

				<span class="s2">path.push(currentNode);</span>
			<span class="s2">}</span>

			<span class="s4">return </span><span class="s2">path;</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Finds the path from the given node to the specified descendant.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node First node in the path.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} descendant Last node in the path.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ASTNode[]} Path, including both nodes.</span>
		 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} If the given node does not have the specified descendant.</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">pathToDescendant(node, descendant) {</span>
			<span class="s4">return </span><span class="s2">pathToAncestor(descendant, node).reverse();</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Checks whether the syntax of the given ancestor of an 'in' expression inside a for-loop initializer</span>
		 <span class="s0">* is preventing the 'in' keyword from being interpreted as a part of an ill-formed for-in loop.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node Ancestor of an 'in' expression.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} child Child of the node, ancestor of the same 'in' expression or the 'in' expression itself.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if the keyword 'in' would be interpreted as the 'in' operator, without any parenthesis.</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">isSafelyEnclosingInExpression(node, child) {</span>
			<span class="s4">switch </span><span class="s2">(node.type) {</span>
				<span class="s4">case </span><span class="s3">&quot;ArrayExpression&quot;</span><span class="s2">:</span>
				<span class="s4">case </span><span class="s3">&quot;ArrayPattern&quot;</span><span class="s2">:</span>
				<span class="s4">case </span><span class="s3">&quot;BlockStatement&quot;</span><span class="s2">:</span>
				<span class="s4">case </span><span class="s3">&quot;ObjectExpression&quot;</span><span class="s2">:</span>
				<span class="s4">case </span><span class="s3">&quot;ObjectPattern&quot;</span><span class="s2">:</span>
				<span class="s4">case </span><span class="s3">&quot;TemplateLiteral&quot;</span><span class="s2">:</span>
					<span class="s4">return true</span><span class="s2">;</span>
				<span class="s4">case </span><span class="s3">&quot;ArrowFunctionExpression&quot;</span><span class="s2">:</span>
				<span class="s4">case </span><span class="s3">&quot;FunctionExpression&quot;</span><span class="s2">:</span>
					<span class="s4">return </span><span class="s2">node.params.includes(child);</span>
				<span class="s4">case </span><span class="s3">&quot;CallExpression&quot;</span><span class="s2">:</span>
				<span class="s4">case </span><span class="s3">&quot;NewExpression&quot;</span><span class="s2">:</span>
					<span class="s4">return </span><span class="s2">node.arguments.includes(child);</span>
				<span class="s4">case </span><span class="s3">&quot;MemberExpression&quot;</span><span class="s2">:</span>
					<span class="s4">return </span><span class="s2">node.computed &amp;&amp; node.property === child;</span>
				<span class="s4">case </span><span class="s3">&quot;ConditionalExpression&quot;</span><span class="s2">:</span>
					<span class="s4">return </span><span class="s2">node.consequent === child;</span>
				<span class="s4">default</span><span class="s2">:</span>
					<span class="s4">return false</span><span class="s2">;</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Starts a new reports buffering. Warnings will be stored in a buffer instead of being reported immediately.</span>
		 <span class="s0">* An additional logic that requires multiple nodes (e.g. a whole subtree) may dismiss some of the stored warnings.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">startNewReportsBuffering() {</span>
			<span class="s2">reportsBuffer = {</span>
				<span class="s2">upper: reportsBuffer,</span>
				<span class="s2">inExpressionNodes: [],</span>
				<span class="s2">reports: [],</span>
			<span class="s2">};</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Ends the current reports buffering.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">endCurrentReportsBuffering() {</span>
			<span class="s4">const </span><span class="s2">{ upper, inExpressionNodes, reports } = reportsBuffer;</span>

			<span class="s4">if </span><span class="s2">(upper) {</span>
				<span class="s2">upper.inExpressionNodes.push(...inExpressionNodes);</span>
				<span class="s2">upper.reports.push(...reports);</span>
			<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
				<span class="s0">// flush remaining reports</span>
				<span class="s2">reports.forEach(({ finishReport }) =&gt; finishReport());</span>
			<span class="s2">}</span>

			<span class="s2">reportsBuffer = upper;</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Checks whether the given node is in the current reports buffer.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node Node to check.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if the node is in the current buffer, false otherwise.</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">isInCurrentReportsBuffer(node) {</span>
			<span class="s4">return </span><span class="s2">reportsBuffer.reports.some(r =&gt; r.node === node);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Removes the given node from the current reports buffer.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node Node to remove.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">removeFromCurrentReportsBuffer(node) {</span>
			<span class="s2">reportsBuffer.reports = reportsBuffer.reports.filter(</span>
				<span class="s2">r =&gt; r.node !== node,</span>
			<span class="s2">);</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Checks whether a node is a MemberExpression at NewExpression's callee.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node node to check.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if the node is a MemberExpression at NewExpression's callee. false otherwise.</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">isMemberExpInNewCallee(node) {</span>
			<span class="s4">if </span><span class="s2">(node.type === </span><span class="s3">&quot;MemberExpression&quot;</span><span class="s2">) {</span>
				<span class="s4">return </span><span class="s2">node.parent.type === </span><span class="s3">&quot;NewExpression&quot; </span><span class="s2">&amp;&amp;</span>
					<span class="s2">node.parent.callee === node</span>
					<span class="s2">? </span><span class="s4">true</span>
					<span class="s2">: node.parent.object === node &amp;&amp;</span>
							<span class="s2">isMemberExpInNewCallee(node.parent);</span>
			<span class="s2">}</span>
			<span class="s4">return false</span><span class="s2">;</span>
		<span class="s2">}</span>

		<span class="s0">/**</span>
		 <span class="s0">* Checks if the left-hand side of an assignment is an identifier, the operator is one of</span>
		 <span class="s0">* `=`, `&amp;&amp;=`, `||=` or `??=` and the right-hand side is an anonymous class or function.</span>
		 <span class="s0">*</span>
		 <span class="s0">* As per https://tc39.es/ecma262/#sec-assignment-operators-runtime-semantics-evaluation, an</span>
		 <span class="s0">* assignment involving one of the operators `=`, `&amp;&amp;=`, `||=` or `??=` where the right-hand</span>
		 <span class="s0">* side is an anonymous class or function and the left-hand side is an *unparenthesized*</span>
		 <span class="s0">* identifier has different semantics than other assignments.</span>
		 <span class="s0">* Specifically, when an expression like `foo = function () {}` is evaluated, `foo.name`</span>
		 <span class="s0">* will be set to the string &quot;foo&quot;, i.e. the identifier name. The same thing does not happen</span>
		 <span class="s0">* when evaluating `(foo) = function () {}`.</span>
		 <span class="s0">* Since the parenthesizing of the identifier in the left-hand side is significant in this</span>
		 <span class="s0">* special case, the parentheses, if present, should not be flagged as unnecessary.</span>
		 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{ASTNode} node an AssignmentExpression node.</span>
		 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} `true` if the left-hand side of the assignment is an identifier, the</span>
		 <span class="s0">* operator is one of `=`, `&amp;&amp;=`, `||=` or `??=` and the right-hand side is an anonymous</span>
		 <span class="s0">* class or function; otherwise, `false`.</span>
		 <span class="s0">*/</span>
		<span class="s4">function </span><span class="s2">isAnonymousFunctionAssignmentException({</span>
			<span class="s2">left,</span>
			<span class="s2">operator,</span>
			<span class="s2">right,</span>
		<span class="s2">}) {</span>
			<span class="s4">if </span><span class="s2">(</span>
				<span class="s2">left.type === </span><span class="s3">&quot;Identifier&quot; </span><span class="s2">&amp;&amp;</span>
				<span class="s2">[</span><span class="s3">&quot;=&quot;</span><span class="s2">, </span><span class="s3">&quot;&amp;&amp;=&quot;</span><span class="s2">, </span><span class="s3">&quot;||=&quot;</span><span class="s2">, </span><span class="s3">&quot;??=&quot;</span><span class="s2">].includes(operator)</span>
			<span class="s2">) {</span>
				<span class="s4">const </span><span class="s2">rhsType = right.type;</span>

				<span class="s4">if </span><span class="s2">(rhsType === </span><span class="s3">&quot;ArrowFunctionExpression&quot;</span><span class="s2">) {</span>
					<span class="s4">return true</span><span class="s2">;</span>
				<span class="s2">}</span>
				<span class="s4">if </span><span class="s2">(</span>
					<span class="s2">(rhsType === </span><span class="s3">&quot;FunctionExpression&quot; </span><span class="s2">||</span>
						<span class="s2">rhsType === </span><span class="s3">&quot;ClassExpression&quot;</span><span class="s2">) &amp;&amp;</span>
					<span class="s2">!right.id</span>
				<span class="s2">) {</span>
					<span class="s4">return true</span><span class="s2">;</span>
				<span class="s2">}</span>
			<span class="s2">}</span>
			<span class="s4">return false</span><span class="s2">;</span>
		<span class="s2">}</span>

		<span class="s4">return </span><span class="s2">{</span>
			<span class="s2">ArrayExpression(node) {</span>
				<span class="s2">node.elements</span>
					<span class="s2">.filter(</span>
						<span class="s2">e =&gt;</span>
							<span class="s2">e &amp;&amp;</span>
							<span class="s2">hasExcessParensWithPrecedence(</span>
								<span class="s2">e,</span>
								<span class="s2">PRECEDENCE_OF_ASSIGNMENT_EXPR,</span>
							<span class="s2">),</span>
					<span class="s2">)</span>
					<span class="s2">.forEach(report);</span>
			<span class="s2">},</span>

			<span class="s2">ArrayPattern(node) {</span>
				<span class="s2">node.elements</span>
					<span class="s2">.filter(e =&gt; canBeAssignmentTarget(e) &amp;&amp; hasExcessParens(e))</span>
					<span class="s2">.forEach(report);</span>
			<span class="s2">},</span>

			<span class="s2">ArrowFunctionExpression(node) {</span>
				<span class="s4">if </span><span class="s2">(isReturnAssignException(node)) {</span>
					<span class="s4">return</span><span class="s2">;</span>
				<span class="s2">}</span>

				<span class="s4">if </span><span class="s2">(</span>
					<span class="s2">node.body.type === </span><span class="s3">&quot;ConditionalExpression&quot; </span><span class="s2">&amp;&amp;</span>
					<span class="s2">IGNORE_ARROW_CONDITIONALS</span>
				<span class="s2">) {</span>
					<span class="s4">return</span><span class="s2">;</span>
				<span class="s2">}</span>

				<span class="s4">if </span><span class="s2">(node.body.type !== </span><span class="s3">&quot;BlockStatement&quot;</span><span class="s2">) {</span>
					<span class="s4">const </span><span class="s2">firstBodyToken = sourceCode.getFirstToken(</span>
						<span class="s2">node.body,</span>
						<span class="s2">astUtils.isNotOpeningParenToken,</span>
					<span class="s2">);</span>
					<span class="s4">const </span><span class="s2">tokenBeforeFirst =</span>
						<span class="s2">sourceCode.getTokenBefore(firstBodyToken);</span>

					<span class="s4">if </span><span class="s2">(</span>
						<span class="s2">astUtils.isOpeningParenToken(tokenBeforeFirst) &amp;&amp;</span>
						<span class="s2">astUtils.isOpeningBraceToken(firstBodyToken)</span>
					<span class="s2">) {</span>
						<span class="s2">tokensToIgnore.add(firstBodyToken);</span>
					<span class="s2">}</span>
					<span class="s4">if </span><span class="s2">(</span>
						<span class="s2">hasExcessParensWithPrecedence(</span>
							<span class="s2">node.body,</span>
							<span class="s2">PRECEDENCE_OF_ASSIGNMENT_EXPR,</span>
						<span class="s2">)</span>
					<span class="s2">) {</span>
						<span class="s2">report(node.body);</span>
					<span class="s2">}</span>
				<span class="s2">}</span>
			<span class="s2">},</span>

			<span class="s2">AssignmentExpression(node) {</span>
				<span class="s4">if </span><span class="s2">(</span>
					<span class="s2">canBeAssignmentTarget(node.left) &amp;&amp;</span>
					<span class="s2">hasExcessParens(node.left) &amp;&amp;</span>
					<span class="s2">(!isAnonymousFunctionAssignmentException(node) ||</span>
						<span class="s2">isParenthesisedTwice(node.left))</span>
				<span class="s2">) {</span>
					<span class="s2">report(node.left);</span>
				<span class="s2">}</span>

				<span class="s4">if </span><span class="s2">(</span>
					<span class="s2">!isReturnAssignException(node) &amp;&amp;</span>
					<span class="s2">hasExcessParensWithPrecedence(node.right, precedence(node))</span>
				<span class="s2">) {</span>
					<span class="s2">report(node.right);</span>
				<span class="s2">}</span>
			<span class="s2">},</span>

			<span class="s2">BinaryExpression(node) {</span>
				<span class="s4">if </span><span class="s2">(reportsBuffer &amp;&amp; node.operator === </span><span class="s3">&quot;in&quot;</span><span class="s2">) {</span>
					<span class="s2">reportsBuffer.inExpressionNodes.push(node);</span>
				<span class="s2">}</span>

				<span class="s2">checkBinaryLogical(node);</span>
			<span class="s2">},</span>

			<span class="s2">CallExpression: checkCallNew,</span>

			<span class="s2">ConditionalExpression(node) {</span>
				<span class="s4">if </span><span class="s2">(isReturnAssignException(node)) {</span>
					<span class="s4">return</span><span class="s2">;</span>
				<span class="s2">}</span>

				<span class="s4">const </span><span class="s2">availableTypes = </span><span class="s4">new </span><span class="s2">Set([</span>
					<span class="s3">&quot;BinaryExpression&quot;</span><span class="s2">,</span>
					<span class="s3">&quot;LogicalExpression&quot;</span><span class="s2">,</span>
				<span class="s2">]);</span>

				<span class="s4">if </span><span class="s2">(</span>
					<span class="s2">!(</span>
						<span class="s2">EXCEPT_COND_TERNARY &amp;&amp;</span>
						<span class="s2">availableTypes.has(node.test.type)</span>
					<span class="s2">) &amp;&amp;</span>
					<span class="s2">!isCondAssignException(node) &amp;&amp;</span>
					<span class="s2">hasExcessParensWithPrecedence(</span>
						<span class="s2">node.test,</span>
						<span class="s2">precedence({</span>
							<span class="s2">type: </span><span class="s3">&quot;LogicalExpression&quot;</span><span class="s2">,</span>
							<span class="s2">operator: </span><span class="s3">&quot;||&quot;</span><span class="s2">,</span>
						<span class="s2">}),</span>
					<span class="s2">)</span>
				<span class="s2">) {</span>
					<span class="s2">report(node.test);</span>
				<span class="s2">}</span>

				<span class="s4">if </span><span class="s2">(</span>
					<span class="s2">!(</span>
						<span class="s2">EXCEPT_COND_TERNARY &amp;&amp;</span>
						<span class="s2">availableTypes.has(node.consequent.type)</span>
					<span class="s2">) &amp;&amp;</span>
					<span class="s2">hasExcessParensWithPrecedence(</span>
						<span class="s2">node.consequent,</span>
						<span class="s2">PRECEDENCE_OF_ASSIGNMENT_EXPR,</span>
					<span class="s2">)</span>
				<span class="s2">) {</span>
					<span class="s2">report(node.consequent);</span>
				<span class="s2">}</span>

				<span class="s4">if </span><span class="s2">(</span>
					<span class="s2">!(</span>
						<span class="s2">EXCEPT_COND_TERNARY &amp;&amp;</span>
						<span class="s2">availableTypes.has(node.alternate.type)</span>
					<span class="s2">) &amp;&amp;</span>
					<span class="s2">hasExcessParensWithPrecedence(</span>
						<span class="s2">node.alternate,</span>
						<span class="s2">PRECEDENCE_OF_ASSIGNMENT_EXPR,</span>
					<span class="s2">)</span>
				<span class="s2">) {</span>
					<span class="s2">report(node.alternate);</span>
				<span class="s2">}</span>
			<span class="s2">},</span>

			<span class="s2">DoWhileStatement(node) {</span>
				<span class="s4">if </span><span class="s2">(</span>
					<span class="s2">hasExcessParens(node.test) &amp;&amp;</span>
					<span class="s2">!isCondAssignException(node)</span>
				<span class="s2">) {</span>
					<span class="s2">report(node.test);</span>
				<span class="s2">}</span>
			<span class="s2">},</span>

			<span class="s2">ExportDefaultDeclaration: node =&gt;</span>
				<span class="s2">checkExpressionOrExportStatement(node.declaration),</span>
			<span class="s2">ExpressionStatement: node =&gt;</span>
				<span class="s2">checkExpressionOrExportStatement(node.expression),</span>

			<span class="s2">ForInStatement(node) {</span>
				<span class="s4">if </span><span class="s2">(node.left.type !== </span><span class="s3">&quot;VariableDeclaration&quot;</span><span class="s2">) {</span>
					<span class="s4">const </span><span class="s2">firstLeftToken = sourceCode.getFirstToken(</span>
						<span class="s2">node.left,</span>
						<span class="s2">astUtils.isNotOpeningParenToken,</span>
					<span class="s2">);</span>

					<span class="s4">if </span><span class="s2">(</span>
						<span class="s2">firstLeftToken.value === </span><span class="s3">&quot;let&quot; </span><span class="s2">&amp;&amp;</span>
						<span class="s2">astUtils.isOpeningBracketToken(</span>
							<span class="s2">sourceCode.getTokenAfter(</span>
								<span class="s2">firstLeftToken,</span>
								<span class="s2">astUtils.isNotClosingParenToken,</span>
							<span class="s2">),</span>
						<span class="s2">)</span>
					<span class="s2">) {</span>
						<span class="s0">// ForInStatement#left expression cannot start with `let[`.</span>
						<span class="s2">tokensToIgnore.add(firstLeftToken);</span>
					<span class="s2">}</span>
				<span class="s2">}</span>

				<span class="s4">if </span><span class="s2">(hasExcessParens(node.left)) {</span>
					<span class="s2">report(node.left);</span>
				<span class="s2">}</span>

				<span class="s4">if </span><span class="s2">(hasExcessParens(node.right)) {</span>
					<span class="s2">report(node.right);</span>
				<span class="s2">}</span>
			<span class="s2">},</span>

			<span class="s2">ForOfStatement(node) {</span>
				<span class="s4">if </span><span class="s2">(node.left.type !== </span><span class="s3">&quot;VariableDeclaration&quot;</span><span class="s2">) {</span>
					<span class="s4">const </span><span class="s2">firstLeftToken = sourceCode.getFirstToken(</span>
						<span class="s2">node.left,</span>
						<span class="s2">astUtils.isNotOpeningParenToken,</span>
					<span class="s2">);</span>

					<span class="s4">if </span><span class="s2">(firstLeftToken.value === </span><span class="s3">&quot;let&quot;</span><span class="s2">) {</span>
						<span class="s0">// ForOfStatement#left expression cannot start with `let`.</span>
						<span class="s2">tokensToIgnore.add(firstLeftToken);</span>
					<span class="s2">}</span>
				<span class="s2">}</span>

				<span class="s4">if </span><span class="s2">(hasExcessParens(node.left)) {</span>
					<span class="s2">report(node.left);</span>
				<span class="s2">}</span>

				<span class="s4">if </span><span class="s2">(</span>
					<span class="s2">hasExcessParensWithPrecedence(</span>
						<span class="s2">node.right,</span>
						<span class="s2">PRECEDENCE_OF_ASSIGNMENT_EXPR,</span>
					<span class="s2">)</span>
				<span class="s2">) {</span>
					<span class="s2">report(node.right);</span>
				<span class="s2">}</span>
			<span class="s2">},</span>

			<span class="s2">ForStatement(node) {</span>
				<span class="s4">if </span><span class="s2">(</span>
					<span class="s2">node.test &amp;&amp;</span>
					<span class="s2">hasExcessParens(node.test) &amp;&amp;</span>
					<span class="s2">!isCondAssignException(node)</span>
				<span class="s2">) {</span>
					<span class="s2">report(node.test);</span>
				<span class="s2">}</span>

				<span class="s4">if </span><span class="s2">(node.update &amp;&amp; hasExcessParens(node.update)) {</span>
					<span class="s2">report(node.update);</span>
				<span class="s2">}</span>

				<span class="s4">if </span><span class="s2">(node.init) {</span>
					<span class="s4">if </span><span class="s2">(node.init.type !== </span><span class="s3">&quot;VariableDeclaration&quot;</span><span class="s2">) {</span>
						<span class="s4">const </span><span class="s2">firstToken = sourceCode.getFirstToken(</span>
							<span class="s2">node.init,</span>
							<span class="s2">astUtils.isNotOpeningParenToken,</span>
						<span class="s2">);</span>

						<span class="s4">if </span><span class="s2">(</span>
							<span class="s2">firstToken.value === </span><span class="s3">&quot;let&quot; </span><span class="s2">&amp;&amp;</span>
							<span class="s2">astUtils.isOpeningBracketToken(</span>
								<span class="s2">sourceCode.getTokenAfter(</span>
									<span class="s2">firstToken,</span>
									<span class="s2">astUtils.isNotClosingParenToken,</span>
								<span class="s2">),</span>
							<span class="s2">)</span>
						<span class="s2">) {</span>
							<span class="s0">// ForStatement#init expression cannot start with `let[`.</span>
							<span class="s2">tokensToIgnore.add(firstToken);</span>
						<span class="s2">}</span>
					<span class="s2">}</span>

					<span class="s2">startNewReportsBuffering();</span>

					<span class="s4">if </span><span class="s2">(hasExcessParens(node.init)) {</span>
						<span class="s2">report(node.init);</span>
					<span class="s2">}</span>
				<span class="s2">}</span>
			<span class="s2">},</span>

			<span class="s3">&quot;ForStatement &gt; *.init:exit&quot;</span><span class="s2">(node) {</span>
				<span class="s0">/* 
                 * Removing parentheses around `in` expressions might change semantics and cause errors. 
                 * 
                 * For example, this valid for loop: 
                 *      for (let a = (b in c); ;); 
                 * after removing parentheses would be treated as an invalid for-in loop: 
                 *      for (let a = b in c; ;); 
                 */</span>

				<span class="s4">if </span><span class="s2">(reportsBuffer.reports.length) {</span>
					<span class="s2">reportsBuffer.inExpressionNodes.forEach(</span>
						<span class="s2">inExpressionNode =&gt; {</span>
							<span class="s4">const </span><span class="s2">path = pathToDescendant(</span>
								<span class="s2">node,</span>
								<span class="s2">inExpressionNode,</span>
							<span class="s2">);</span>
							<span class="s4">let </span><span class="s2">nodeToExclude;</span>

							<span class="s4">for </span><span class="s2">(</span><span class="s4">let </span><span class="s2">i = </span><span class="s5">0</span><span class="s2">; i &lt; path.length; i++) {</span>
								<span class="s4">const </span><span class="s2">pathNode = path[i];</span>

								<span class="s4">if </span><span class="s2">(i &lt; path.length - </span><span class="s5">1</span><span class="s2">) {</span>
									<span class="s4">const </span><span class="s2">nextPathNode = path[i + </span><span class="s5">1</span><span class="s2">];</span>

									<span class="s4">if </span><span class="s2">(</span>
										<span class="s2">isSafelyEnclosingInExpression(</span>
											<span class="s2">pathNode,</span>
											<span class="s2">nextPathNode,</span>
										<span class="s2">)</span>
									<span class="s2">) {</span>
										<span class="s0">// The 'in' expression in safely enclosed by the syntax of its ancestor nodes (e.g. by '{}' or '[]').</span>
										<span class="s4">return</span><span class="s2">;</span>
									<span class="s2">}</span>
								<span class="s2">}</span>

								<span class="s4">if </span><span class="s2">(isParenthesised(pathNode)) {</span>
									<span class="s4">if </span><span class="s2">(isInCurrentReportsBuffer(pathNode)) {</span>
										<span class="s0">// This node was supposed to be reported, but parentheses might be necessary.</span>

										<span class="s4">if </span><span class="s2">(isParenthesisedTwice(pathNode)) {</span>
											<span class="s0">/* 
                                             * This node is parenthesised twice, it certainly has at least one pair of `extra` parentheses. 
                                             * If the --fix option is on, the current fixing iteration will remove only one pair of parentheses. 
                                             * The remaining pair is safely enclosing the 'in' expression. 
                                             */</span>
											<span class="s4">return</span><span class="s2">;</span>
										<span class="s2">}</span>

										<span class="s0">// Exclude the outermost node only.</span>
										<span class="s4">if </span><span class="s2">(!nodeToExclude) {</span>
											<span class="s2">nodeToExclude = pathNode;</span>
										<span class="s2">}</span>

										<span class="s0">// Don't break the loop here, there might be some safe nodes or parentheses that will stay inside.</span>
									<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
										<span class="s0">// This node will stay parenthesised, the 'in' expression in safely enclosed by '()'.</span>
										<span class="s4">return</span><span class="s2">;</span>
									<span class="s2">}</span>
								<span class="s2">}</span>
							<span class="s2">}</span>

							<span class="s0">// Exclude the node from the list (i.e. treat parentheses as necessary)</span>
							<span class="s2">removeFromCurrentReportsBuffer(nodeToExclude);</span>
						<span class="s2">},</span>
					<span class="s2">);</span>
				<span class="s2">}</span>

				<span class="s2">endCurrentReportsBuffering();</span>
			<span class="s2">},</span>

			<span class="s2">IfStatement(node) {</span>
				<span class="s4">if </span><span class="s2">(</span>
					<span class="s2">hasExcessParens(node.test) &amp;&amp;</span>
					<span class="s2">!isCondAssignException(node)</span>
				<span class="s2">) {</span>
					<span class="s2">report(node.test);</span>
				<span class="s2">}</span>
			<span class="s2">},</span>

			<span class="s2">ImportExpression(node) {</span>
				<span class="s4">const </span><span class="s2">{ source } = node;</span>

				<span class="s4">if </span><span class="s2">(source.type === </span><span class="s3">&quot;SequenceExpression&quot;</span><span class="s2">) {</span>
					<span class="s4">if </span><span class="s2">(hasDoubleExcessParens(source)) {</span>
						<span class="s2">report(source);</span>
					<span class="s2">}</span>
				<span class="s2">} </span><span class="s4">else if </span><span class="s2">(hasExcessParens(source)) {</span>
					<span class="s2">report(source);</span>
				<span class="s2">}</span>
			<span class="s2">},</span>

			<span class="s2">LogicalExpression: checkBinaryLogical,</span>

			<span class="s2">MemberExpression(node) {</span>
				<span class="s4">const </span><span class="s2">shouldAllowWrapOnce =</span>
					<span class="s2">isMemberExpInNewCallee(node) &amp;&amp;</span>
					<span class="s2">doesMemberExpressionContainCallExpression(node);</span>
				<span class="s4">const </span><span class="s2">nodeObjHasExcessParens = shouldAllowWrapOnce</span>
					<span class="s2">? hasDoubleExcessParens(node.object)</span>
					<span class="s2">: hasExcessParens(node.object) &amp;&amp;</span>
						<span class="s2">!(</span>
							<span class="s2">isImmediateFunctionPrototypeMethodCall(</span>
								<span class="s2">node.parent,</span>
							<span class="s2">) &amp;&amp;</span>
							<span class="s2">node.parent.callee === node &amp;&amp;</span>
							<span class="s2">IGNORE_FUNCTION_PROTOTYPE_METHODS</span>
						<span class="s2">);</span>

				<span class="s4">if </span><span class="s2">(</span>
					<span class="s2">nodeObjHasExcessParens &amp;&amp;</span>
					<span class="s2">precedence(node.object) &gt;= precedence(node) &amp;&amp;</span>
					<span class="s2">(node.computed ||</span>
						<span class="s2">!(</span>
							<span class="s2">astUtils.isDecimalInteger(node.object) ||</span>
							<span class="s0">// RegExp literal is allowed to have parens (#1589)</span>
							<span class="s2">(node.object.type === </span><span class="s3">&quot;Literal&quot; </span><span class="s2">&amp;&amp;</span>
								<span class="s2">node.object.regex)</span>
						<span class="s2">))</span>
				<span class="s2">) {</span>
					<span class="s2">report(node.object);</span>
				<span class="s2">}</span>

				<span class="s4">if </span><span class="s2">(</span>
					<span class="s2">nodeObjHasExcessParens &amp;&amp;</span>
					<span class="s2">node.object.type === </span><span class="s3">&quot;CallExpression&quot;</span>
				<span class="s2">) {</span>
					<span class="s2">report(node.object);</span>
				<span class="s2">}</span>

				<span class="s4">if </span><span class="s2">(</span>
					<span class="s2">nodeObjHasExcessParens &amp;&amp;</span>
					<span class="s2">!IGNORE_NEW_IN_MEMBER_EXPR &amp;&amp;</span>
					<span class="s2">node.object.type === </span><span class="s3">&quot;NewExpression&quot; </span><span class="s2">&amp;&amp;</span>
					<span class="s2">isNewExpressionWithParens(node.object)</span>
				<span class="s2">) {</span>
					<span class="s2">report(node.object);</span>
				<span class="s2">}</span>

				<span class="s4">if </span><span class="s2">(</span>
					<span class="s2">nodeObjHasExcessParens &amp;&amp;</span>
					<span class="s2">node.optional &amp;&amp;</span>
					<span class="s2">node.object.type === </span><span class="s3">&quot;ChainExpression&quot;</span>
				<span class="s2">) {</span>
					<span class="s2">report(node.object);</span>
				<span class="s2">}</span>

				<span class="s4">if </span><span class="s2">(node.computed &amp;&amp; hasExcessParens(node.property)) {</span>
					<span class="s2">report(node.property);</span>
				<span class="s2">}</span>
			<span class="s2">},</span>

			<span class="s3">&quot;MethodDefinition[computed=true]&quot;</span><span class="s2">(node) {</span>
				<span class="s4">if </span><span class="s2">(</span>
					<span class="s2">hasExcessParensWithPrecedence(</span>
						<span class="s2">node.key,</span>
						<span class="s2">PRECEDENCE_OF_ASSIGNMENT_EXPR,</span>
					<span class="s2">)</span>
				<span class="s2">) {</span>
					<span class="s2">report(node.key);</span>
				<span class="s2">}</span>
			<span class="s2">},</span>

			<span class="s2">NewExpression: checkCallNew,</span>

			<span class="s2">ObjectExpression(node) {</span>
				<span class="s2">node.properties</span>
					<span class="s2">.filter(</span>
						<span class="s2">property =&gt;</span>
							<span class="s2">property.value &amp;&amp;</span>
							<span class="s2">hasExcessParensWithPrecedence(</span>
								<span class="s2">property.value,</span>
								<span class="s2">PRECEDENCE_OF_ASSIGNMENT_EXPR,</span>
							<span class="s2">),</span>
					<span class="s2">)</span>
					<span class="s2">.forEach(property =&gt; report(property.value));</span>
			<span class="s2">},</span>

			<span class="s2">ObjectPattern(node) {</span>
				<span class="s2">node.properties</span>
					<span class="s2">.filter(property =&gt; {</span>
						<span class="s4">const </span><span class="s2">value = property.value;</span>

						<span class="s4">return </span><span class="s2">(</span>
							<span class="s2">canBeAssignmentTarget(value) &amp;&amp;</span>
							<span class="s2">hasExcessParens(value)</span>
						<span class="s2">);</span>
					<span class="s2">})</span>
					<span class="s2">.forEach(property =&gt; report(property.value));</span>
			<span class="s2">},</span>

			<span class="s2">Property(node) {</span>
				<span class="s4">if </span><span class="s2">(node.computed) {</span>
					<span class="s4">const </span><span class="s2">{ key } = node;</span>

					<span class="s4">if </span><span class="s2">(</span>
						<span class="s2">key &amp;&amp;</span>
						<span class="s2">hasExcessParensWithPrecedence(</span>
							<span class="s2">key,</span>
							<span class="s2">PRECEDENCE_OF_ASSIGNMENT_EXPR,</span>
						<span class="s2">)</span>
					<span class="s2">) {</span>
						<span class="s2">report(key);</span>
					<span class="s2">}</span>
				<span class="s2">}</span>
			<span class="s2">},</span>

			<span class="s2">PropertyDefinition(node) {</span>
				<span class="s4">if </span><span class="s2">(</span>
					<span class="s2">node.computed &amp;&amp;</span>
					<span class="s2">hasExcessParensWithPrecedence(</span>
						<span class="s2">node.key,</span>
						<span class="s2">PRECEDENCE_OF_ASSIGNMENT_EXPR,</span>
					<span class="s2">)</span>
				<span class="s2">) {</span>
					<span class="s2">report(node.key);</span>
				<span class="s2">}</span>

				<span class="s4">if </span><span class="s2">(</span>
					<span class="s2">node.value &amp;&amp;</span>
					<span class="s2">hasExcessParensWithPrecedence(</span>
						<span class="s2">node.value,</span>
						<span class="s2">PRECEDENCE_OF_ASSIGNMENT_EXPR,</span>
					<span class="s2">)</span>
				<span class="s2">) {</span>
					<span class="s2">report(node.value);</span>
				<span class="s2">}</span>
			<span class="s2">},</span>

			<span class="s2">RestElement(node) {</span>
				<span class="s4">const </span><span class="s2">argument = node.argument;</span>

				<span class="s4">if </span><span class="s2">(</span>
					<span class="s2">canBeAssignmentTarget(argument) &amp;&amp;</span>
					<span class="s2">hasExcessParens(argument)</span>
				<span class="s2">) {</span>
					<span class="s2">report(argument);</span>
				<span class="s2">}</span>
			<span class="s2">},</span>

			<span class="s2">ReturnStatement(node) {</span>
				<span class="s4">const </span><span class="s2">returnToken = sourceCode.getFirstToken(node);</span>

				<span class="s4">if </span><span class="s2">(isReturnAssignException(node)) {</span>
					<span class="s4">return</span><span class="s2">;</span>
				<span class="s2">}</span>

				<span class="s4">if </span><span class="s2">(</span>
					<span class="s2">node.argument &amp;&amp;</span>
					<span class="s2">hasExcessParensNoLineTerminator(</span>
						<span class="s2">returnToken,</span>
						<span class="s2">node.argument,</span>
					<span class="s2">) &amp;&amp;</span>
					<span class="s0">// RegExp literal is allowed to have parens (#1589)</span>
					<span class="s2">!(node.argument.type === </span><span class="s3">&quot;Literal&quot; </span><span class="s2">&amp;&amp; node.argument.regex)</span>
				<span class="s2">) {</span>
					<span class="s2">report(node.argument);</span>
				<span class="s2">}</span>
			<span class="s2">},</span>

			<span class="s2">SequenceExpression(node) {</span>
				<span class="s4">const </span><span class="s2">precedenceOfNode = precedence(node);</span>

				<span class="s2">node.expressions</span>
					<span class="s2">.filter(e =&gt;</span>
						<span class="s2">hasExcessParensWithPrecedence(e, precedenceOfNode),</span>
					<span class="s2">)</span>
					<span class="s2">.forEach(report);</span>
			<span class="s2">},</span>

			<span class="s2">SwitchCase(node) {</span>
				<span class="s4">if </span><span class="s2">(node.test &amp;&amp; hasExcessParens(node.test)) {</span>
					<span class="s2">report(node.test);</span>
				<span class="s2">}</span>
			<span class="s2">},</span>

			<span class="s2">SwitchStatement(node) {</span>
				<span class="s4">if </span><span class="s2">(hasExcessParens(node.discriminant)) {</span>
					<span class="s2">report(node.discriminant);</span>
				<span class="s2">}</span>
			<span class="s2">},</span>

			<span class="s2">ThrowStatement(node) {</span>
				<span class="s4">const </span><span class="s2">throwToken = sourceCode.getFirstToken(node);</span>

				<span class="s4">if </span><span class="s2">(</span>
					<span class="s2">hasExcessParensNoLineTerminator(throwToken, node.argument)</span>
				<span class="s2">) {</span>
					<span class="s2">report(node.argument);</span>
				<span class="s2">}</span>
			<span class="s2">},</span>

			<span class="s2">UnaryExpression: checkArgumentWithPrecedence,</span>
			<span class="s2">UpdateExpression(node) {</span>
				<span class="s4">if </span><span class="s2">(node.prefix) {</span>
					<span class="s2">checkArgumentWithPrecedence(node);</span>
				<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
					<span class="s4">const </span><span class="s2">{ argument } = node;</span>
					<span class="s4">const </span><span class="s2">operatorToken = sourceCode.getLastToken(node);</span>

					<span class="s4">if </span><span class="s2">(</span>
						<span class="s2">argument.loc.end.line === operatorToken.loc.start.line</span>
					<span class="s2">) {</span>
						<span class="s2">checkArgumentWithPrecedence(node);</span>
					<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
						<span class="s4">if </span><span class="s2">(hasDoubleExcessParens(argument)) {</span>
							<span class="s2">report(argument);</span>
						<span class="s2">}</span>
					<span class="s2">}</span>
				<span class="s2">}</span>
			<span class="s2">},</span>
			<span class="s2">AwaitExpression: checkArgumentWithPrecedence,</span>

			<span class="s2">VariableDeclarator(node) {</span>
				<span class="s4">if </span><span class="s2">(</span>
					<span class="s2">node.init &amp;&amp;</span>
					<span class="s2">hasExcessParensWithPrecedence(</span>
						<span class="s2">node.init,</span>
						<span class="s2">PRECEDENCE_OF_ASSIGNMENT_EXPR,</span>
					<span class="s2">) &amp;&amp;</span>
					<span class="s0">// RegExp literal is allowed to have parens (#1589)</span>
					<span class="s2">!(node.init.type === </span><span class="s3">&quot;Literal&quot; </span><span class="s2">&amp;&amp; node.init.regex)</span>
				<span class="s2">) {</span>
					<span class="s2">report(node.init);</span>
				<span class="s2">}</span>
			<span class="s2">},</span>

			<span class="s2">WhileStatement(node) {</span>
				<span class="s4">if </span><span class="s2">(</span>
					<span class="s2">hasExcessParens(node.test) &amp;&amp;</span>
					<span class="s2">!isCondAssignException(node)</span>
				<span class="s2">) {</span>
					<span class="s2">report(node.test);</span>
				<span class="s2">}</span>
			<span class="s2">},</span>

			<span class="s2">WithStatement(node) {</span>
				<span class="s4">if </span><span class="s2">(hasExcessParens(node.object)) {</span>
					<span class="s2">report(node.object);</span>
				<span class="s2">}</span>
			<span class="s2">},</span>

			<span class="s2">YieldExpression(node) {</span>
				<span class="s4">if </span><span class="s2">(node.argument) {</span>
					<span class="s4">const </span><span class="s2">yieldToken = sourceCode.getFirstToken(node);</span>

					<span class="s4">if </span><span class="s2">(</span>
						<span class="s2">(precedence(node.argument) &gt;= precedence(node) &amp;&amp;</span>
							<span class="s2">hasExcessParensNoLineTerminator(</span>
								<span class="s2">yieldToken,</span>
								<span class="s2">node.argument,</span>
							<span class="s2">)) ||</span>
						<span class="s2">hasDoubleExcessParens(node.argument)</span>
					<span class="s2">) {</span>
						<span class="s2">report(node.argument);</span>
					<span class="s2">}</span>
				<span class="s2">}</span>
			<span class="s2">},</span>

			<span class="s2">ClassDeclaration: checkClass,</span>
			<span class="s2">ClassExpression: checkClass,</span>

			<span class="s2">SpreadElement: checkSpreadOperator,</span>
			<span class="s2">SpreadProperty: checkSpreadOperator,</span>
			<span class="s2">ExperimentalSpreadProperty: checkSpreadOperator,</span>

			<span class="s2">TemplateLiteral(node) {</span>
				<span class="s2">node.expressions</span>
					<span class="s2">.filter(e =&gt; e &amp;&amp; hasExcessParens(e))</span>
					<span class="s2">.forEach(report);</span>
			<span class="s2">},</span>

			<span class="s2">AssignmentPattern(node) {</span>
				<span class="s4">const </span><span class="s2">{ left, right } = node;</span>

				<span class="s4">if </span><span class="s2">(canBeAssignmentTarget(left) &amp;&amp; hasExcessParens(left)) {</span>
					<span class="s2">report(left);</span>
				<span class="s2">}</span>

				<span class="s4">if </span><span class="s2">(</span>
					<span class="s2">right &amp;&amp;</span>
					<span class="s2">hasExcessParensWithPrecedence(</span>
						<span class="s2">right,</span>
						<span class="s2">PRECEDENCE_OF_ASSIGNMENT_EXPR,</span>
					<span class="s2">)</span>
				<span class="s2">) {</span>
					<span class="s2">report(right);</span>
				<span class="s2">}</span>
			<span class="s2">},</span>
		<span class="s2">};</span>
	<span class="s2">},</span>
<span class="s2">};</span>
</pre>
</body>
</html>