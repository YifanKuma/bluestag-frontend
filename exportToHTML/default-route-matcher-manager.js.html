<html>
<head>
<title>default-route-matcher-manager.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
.s5 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
default-route-matcher-manager.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;DefaultRouteMatcherManager&quot;</span><span class="s1">, {</span>
    <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
    <span class="s1">get: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">DefaultRouteMatcherManager;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_utils = require(</span><span class="s0">&quot;../../shared/lib/router/utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_localeroutematcher = require(</span><span class="s0">&quot;../route-matchers/locale-route-matcher&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_ensureleadingslash = require(</span><span class="s0">&quot;../../shared/lib/page-path/ensure-leading-slash&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_detachedpromise = require(</span><span class="s0">&quot;../../lib/detached-promise&quot;</span><span class="s1">);</span>
<span class="s2">class </span><span class="s1">DefaultRouteMatcherManager {</span>
    <span class="s3">/**</span>
   <span class="s3">* When this value changes, it indicates that a change has been introduced</span>
   <span class="s3">* that requires recompilation.</span>
   <span class="s3">*/ </span><span class="s1">get compilationID() {</span>
        <span class="s2">return this</span><span class="s1">.providers.length;</span>
    <span class="s1">}</span>
    <span class="s1">async waitTillReady() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.waitTillReadyPromise) {</span>
            <span class="s2">await this</span><span class="s1">.waitTillReadyPromise;</span>
            <span class="s2">delete this</span><span class="s1">.waitTillReadyPromise;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">async reload() {</span>
        <span class="s2">const </span><span class="s1">{ promise, resolve, reject } = </span><span class="s2">new </span><span class="s1">_detachedpromise.DetachedPromise();</span>
        <span class="s2">this</span><span class="s1">.waitTillReadyPromise = promise;</span>
        <span class="s3">// Grab the compilation ID for this run, we'll verify it at the end to</span>
        <span class="s3">// ensure that if any routes were added before reloading is finished that</span>
        <span class="s3">// we error out.</span>
        <span class="s2">const </span><span class="s1">compilationID = </span><span class="s2">this</span><span class="s1">.compilationID;</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s3">// Collect all the matchers from each provider.</span>
            <span class="s2">const </span><span class="s1">matchers = [];</span>
            <span class="s3">// Get all the providers matchers.</span>
            <span class="s2">const </span><span class="s1">providersMatchers = </span><span class="s2">await </span><span class="s1">Promise.all(</span><span class="s2">this</span><span class="s1">.providers.map((provider)=&gt;provider.matchers()));</span>
            <span class="s3">// Use this to detect duplicate pathnames.</span>
            <span class="s2">const </span><span class="s1">all = </span><span class="s2">new </span><span class="s1">Map();</span>
            <span class="s2">const </span><span class="s1">duplicates = {};</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">providerMatchers of providersMatchers){</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">matcher of providerMatchers){</span>
                    <span class="s3">// Reset duplicated matches when reloading from pages conflicting state.</span>
                    <span class="s2">if </span><span class="s1">(matcher.duplicated) </span><span class="s2">delete </span><span class="s1">matcher.duplicated;</span>
                    <span class="s3">// Test to see if the matcher being added is a duplicate.</span>
                    <span class="s2">const </span><span class="s1">duplicate = all.get(matcher.definition.pathname);</span>
                    <span class="s2">if </span><span class="s1">(duplicate) {</span>
                        <span class="s3">// This looks a little weird, but essentially if the pathname</span>
                        <span class="s3">// already exists in the duplicates map, then we got that array</span>
                        <span class="s3">// reference. Otherwise, we create a new array with the original</span>
                        <span class="s3">// duplicate first. Then we push the new matcher into the duplicate</span>
                        <span class="s3">// array, and reset it to the duplicates object (which may be a</span>
                        <span class="s3">// no-op if the pathname already existed in the duplicates object).</span>
                        <span class="s3">// Then we set the array of duplicates on both the original</span>
                        <span class="s3">// duplicate object and the new one, so we can keep them in sync.</span>
                        <span class="s3">// If a new duplicate is found, and it matches an existing pathname,</span>
                        <span class="s3">// the retrieval of the `other` will actually return the array</span>
                        <span class="s3">// reference used by all other duplicates. This is why ReadonlyArray</span>
                        <span class="s3">// is so important! Array's are always references!</span>
                        <span class="s2">const </span><span class="s1">others = duplicates[matcher.definition.pathname] ?? [</span>
                            <span class="s1">duplicate</span>
                        <span class="s1">];</span>
                        <span class="s1">others.push(matcher);</span>
                        <span class="s1">duplicates[matcher.definition.pathname] = others;</span>
                        <span class="s3">// Add duplicated details to each route.</span>
                        <span class="s1">duplicate.duplicated = others;</span>
                        <span class="s1">matcher.duplicated = others;</span>
                    <span class="s3">// TODO: see if we should error for duplicates in production?</span>
                    <span class="s1">}</span>
                    <span class="s1">matchers.push(matcher);</span>
                    <span class="s3">// Add the matcher's pathname to the set.</span>
                    <span class="s1">all.set(matcher.definition.pathname, matcher);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s3">// Update the duplicate matchers. This is used in the development manager</span>
            <span class="s3">// to warn about duplicates.</span>
            <span class="s2">this</span><span class="s1">.matchers.duplicates = duplicates;</span>
            <span class="s3">// If the cache is the same as what we just parsed, we can exit now. We</span>
            <span class="s3">// can tell by using the `===` which compares object identity, which for</span>
            <span class="s3">// the manifest matchers, will return the same matcher each time.</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.previousMatchers.length === matchers.length &amp;&amp; </span><span class="s2">this</span><span class="s1">.previousMatchers.every((cachedMatcher, index)=&gt;cachedMatcher === matchers[index])) {</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">this</span><span class="s1">.previousMatchers = matchers;</span>
            <span class="s3">// For matchers that are for static routes, filter them now.</span>
            <span class="s2">this</span><span class="s1">.matchers.static = matchers.filter((matcher)=&gt;!matcher.isDynamic);</span>
            <span class="s3">// For matchers that are for dynamic routes, filter them and sort them now.</span>
            <span class="s2">const </span><span class="s1">dynamic = matchers.filter((matcher)=&gt;matcher.isDynamic);</span>
            <span class="s3">// As `getSortedRoutes` only takes an array of strings, we need to create</span>
            <span class="s3">// a map of the pathnames (used for sorting) and the matchers. When we</span>
            <span class="s3">// have locales, there may be multiple matches for the same pathname. To</span>
            <span class="s3">// handle this, we keep a map of all the indexes (in `reference`) and</span>
            <span class="s3">// merge them in later.</span>
            <span class="s2">const </span><span class="s1">reference = </span><span class="s2">new </span><span class="s1">Map();</span>
            <span class="s2">const </span><span class="s1">pathnames = </span><span class="s2">new </span><span class="s1">Array();</span>
            <span class="s2">for</span><span class="s1">(</span><span class="s2">let </span><span class="s1">index = </span><span class="s4">0</span><span class="s1">; index &lt; dynamic.length; index++){</span>
                <span class="s3">// Grab the pathname from the definition.</span>
                <span class="s2">const </span><span class="s1">pathname = dynamic[index].definition.pathname;</span>
                <span class="s3">// Grab the index in the dynamic array, push it into the reference.</span>
                <span class="s2">const </span><span class="s1">indexes = reference.get(pathname) ?? [];</span>
                <span class="s1">indexes.push(index);</span>
                <span class="s3">// If this is the first one set it. If it isn't, we don't need to</span>
                <span class="s3">// because pushing above on the array will mutate the array already</span>
                <span class="s3">// stored there because array's are always a reference!</span>
                <span class="s2">if </span><span class="s1">(indexes.length === </span><span class="s4">1</span><span class="s1">) reference.set(pathname, indexes);</span>
                <span class="s2">else continue</span><span class="s1">;</span>
                <span class="s1">pathnames.push(pathname);</span>
            <span class="s1">}</span>
            <span class="s3">// Sort the array of pathnames.</span>
            <span class="s2">const </span><span class="s1">sorted = (</span><span class="s4">0</span><span class="s1">, _utils.getSortedRoutes)(pathnames);</span>
            <span class="s3">// For each of the sorted pathnames, iterate over them, grabbing the list</span>
            <span class="s3">// of indexes and merging them back into the new `sortedDynamicMatchers`</span>
            <span class="s3">// array. The order of the same matching pathname doesn't matter because</span>
            <span class="s3">// they will have other matching characteristics (like the locale) that</span>
            <span class="s3">// is considered.</span>
            <span class="s2">const </span><span class="s1">sortedDynamicMatchers = [];</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">pathname of sorted){</span>
                <span class="s2">const </span><span class="s1">indexes = reference.get(pathname);</span>
                <span class="s2">if </span><span class="s1">(!Array.isArray(indexes)) {</span>
                    <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Invariant: expected to find identity in indexes map'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                        <span class="s1">value: </span><span class="s0">&quot;E271&quot;</span><span class="s1">,</span>
                        <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">configurable: </span><span class="s2">true</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
                <span class="s2">const </span><span class="s1">dynamicMatches = indexes.map((index)=&gt;dynamic[index]);</span>
                <span class="s1">sortedDynamicMatchers.push(...dynamicMatches);</span>
            <span class="s1">}</span>
            <span class="s2">this</span><span class="s1">.matchers.dynamic = sortedDynamicMatchers;</span>
            <span class="s3">// This means that there was a new matcher pushed while we were waiting</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.compilationID !== compilationID) {</span>
                <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Invariant: expected compilation to finish before new matchers were added, possible missing await'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s0">&quot;E242&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s2">true</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
            <span class="s1">reject(err);</span>
        <span class="s1">} </span><span class="s2">finally</span><span class="s1">{</span>
            <span class="s3">// The compilation ID matched, so mark the complication as finished.</span>
            <span class="s2">this</span><span class="s1">.lastCompilationID = compilationID;</span>
            <span class="s1">resolve();</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">push(provider) {</span>
        <span class="s2">this</span><span class="s1">.providers.push(provider);</span>
    <span class="s1">}</span>
    <span class="s1">async test(pathname, options) {</span>
        <span class="s3">// See if there's a match for the pathname...</span>
        <span class="s2">const </span><span class="s1">match = </span><span class="s2">await this</span><span class="s1">.match(pathname, options);</span>
        <span class="s3">// This default implementation only needs to check to see if there _was_ a</span>
        <span class="s3">// match. The development matcher actually changes it's behavior by not</span>
        <span class="s3">// recompiling the routes.</span>
        <span class="s2">return </span><span class="s1">match !== </span><span class="s2">null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">async match(pathname, options) {</span>
        <span class="s3">// &quot;Iterate&quot; over the match options. Once we found a single match, exit with</span>
        <span class="s3">// it, otherwise return null below. If no match is found, the inner block</span>
        <span class="s3">// won't be called.</span>
        <span class="s2">for await </span><span class="s1">(</span><span class="s2">const </span><span class="s1">match of </span><span class="s2">this</span><span class="s1">.matchAll(pathname, options)){</span>
            <span class="s2">return </span><span class="s1">match;</span>
        <span class="s1">}</span>
        <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
   <span class="s3">* This is a point for other managers to override to inject other checking</span>
   <span class="s3">* behavior like duplicate route checking on a per-request basis.</span>
   <span class="s3">*</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">pathname the pathname to validate against</span>
   <span class="s3">* </span><span class="s5">@param </span><span class="s3">matcher the matcher to validate/test with</span>
   <span class="s3">* </span><span class="s5">@returns </span><span class="s3">the match if found</span>
   <span class="s3">*/ </span><span class="s1">validate(pathname, matcher, options) {</span>
        <span class="s2">var </span><span class="s1">_options_i18n;</span>
        <span class="s2">if </span><span class="s1">(matcher </span><span class="s2">instanceof </span><span class="s1">_localeroutematcher.LocaleRouteMatcher) {</span>
            <span class="s2">return </span><span class="s1">matcher.match(pathname, options);</span>
        <span class="s1">}</span>
        <span class="s3">// If the locale was inferred from the default locale, then it will have</span>
        <span class="s3">// already added a locale to the pathname. We need to remove it before</span>
        <span class="s3">// matching because this matcher is not locale aware.</span>
        <span class="s2">if </span><span class="s1">((_options_i18n = options.i18n) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _options_i18n.inferredFromDefault) {</span>
            <span class="s2">return </span><span class="s1">matcher.match(options.i18n.pathname);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">matcher.match(pathname);</span>
    <span class="s1">}</span>
    <span class="s1">async *matchAll(pathname, options) {</span>
        <span class="s3">// Guard against the matcher manager from being run before it needs to be</span>
        <span class="s3">// recompiled. This was preferred to re-running the compilation here because</span>
        <span class="s3">// it should be re-ran only when it changes. If a match is attempted before</span>
        <span class="s3">// this is done, it indicates that there is a case where a provider is added</span>
        <span class="s3">// before it was recompiled (an error). We also don't want to affect request</span>
        <span class="s3">// times.</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.lastCompilationID !== </span><span class="s2">this</span><span class="s1">.compilationID) {</span>
            <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'Invariant: expected routes to have been loaded before match'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                <span class="s1">value: </span><span class="s0">&quot;E235&quot;</span><span class="s1">,</span>
                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s2">true</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s3">// Ensure that path matching is done with a leading slash.</span>
        <span class="s1">pathname = (</span><span class="s4">0</span><span class="s1">, _ensureleadingslash.ensureLeadingSlash)(pathname);</span>
        <span class="s3">// If this pathname doesn't look like a dynamic route, and this pathname is</span>
        <span class="s3">// listed in the normalized list of routes, then return it. This ensures</span>
        <span class="s3">// that when a route like `/user/[id]` is encountered, it doesn't just match</span>
        <span class="s3">// with the list of normalized routes.</span>
        <span class="s2">if </span><span class="s1">(!(</span><span class="s4">0</span><span class="s1">, _utils.isDynamicRoute)(pathname)) {</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">matcher of </span><span class="s2">this</span><span class="s1">.matchers.static){</span>
                <span class="s2">const </span><span class="s1">match = </span><span class="s2">this</span><span class="s1">.validate(pathname, matcher, options);</span>
                <span class="s2">if </span><span class="s1">(!match) </span><span class="s2">continue</span><span class="s1">;</span>
                <span class="s2">yield </span><span class="s1">match;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s3">// If we should skip handling dynamic routes, exit now.</span>
        <span class="s2">if </span><span class="s1">(options == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: options.skipDynamic) </span><span class="s2">return null</span><span class="s1">;</span>
        <span class="s3">// Loop over the dynamic matchers, yielding each match.</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">matcher of </span><span class="s2">this</span><span class="s1">.matchers.dynamic){</span>
            <span class="s2">const </span><span class="s1">match = </span><span class="s2">this</span><span class="s1">.validate(pathname, matcher, options);</span>
            <span class="s2">if </span><span class="s1">(!match) </span><span class="s2">continue</span><span class="s1">;</span>
            <span class="s2">yield </span><span class="s1">match;</span>
        <span class="s1">}</span>
        <span class="s3">// We tried direct matching against the pathname and against all the dynamic</span>
        <span class="s3">// paths, so there was no match.</span>
        <span class="s2">return null</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">constructor(){</span>
        <span class="s2">this</span><span class="s1">.providers = [];</span>
        <span class="s2">this</span><span class="s1">.matchers = {</span>
            <span class="s2">static</span><span class="s1">: [],</span>
            <span class="s1">dynamic: [],</span>
            <span class="s1">duplicates: {}</span>
        <span class="s1">};</span>
        <span class="s2">this</span><span class="s1">.lastCompilationID = </span><span class="s2">this</span><span class="s1">.compilationID;</span>
        <span class="s2">this</span><span class="s1">.previousMatchers = [];</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">//# sourceMappingURL=default-route-matcher-manager.js.map</span></pre>
</body>
</html>