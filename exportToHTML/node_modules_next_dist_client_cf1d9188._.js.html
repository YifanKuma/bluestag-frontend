<html>
<head>
<title>node_modules_next_dist_client_cf1d9188._.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #0033b3;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
.s5 { color: #8c8c8c; font-style: italic;}
.s6 { color: #0037a6;}
.s7 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
node_modules_next_dist_client_cf1d9188._.js</font>
</center></td></tr></table>
<pre><span class="s0">(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([</span><span class="s1">typeof </span><span class="s0">document === </span><span class="s2">&quot;object&quot; </span><span class="s0">? document.currentScript : undefined,</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/set-attributes-from-props.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;setAttributesFromProps&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">setAttributesFromProps;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">DOMAttributeNames = {</span>
    <span class="s0">acceptCharset: </span><span class="s2">'accept-charset'</span><span class="s0">,</span>
    <span class="s0">className: </span><span class="s2">'class'</span><span class="s0">,</span>
    <span class="s0">htmlFor: </span><span class="s2">'for'</span><span class="s0">,</span>
    <span class="s0">httpEquiv: </span><span class="s2">'http-equiv'</span><span class="s0">,</span>
    <span class="s0">noModule: </span><span class="s2">'noModule'</span>
<span class="s0">};</span>
<span class="s1">const </span><span class="s0">ignoreProps = [</span>
    <span class="s2">'onLoad'</span><span class="s0">,</span>
    <span class="s2">'onReady'</span><span class="s0">,</span>
    <span class="s2">'dangerouslySetInnerHTML'</span><span class="s0">,</span>
    <span class="s2">'children'</span><span class="s0">,</span>
    <span class="s2">'onError'</span><span class="s0">,</span>
    <span class="s2">'strategy'</span><span class="s0">,</span>
    <span class="s2">'stylesheets'</span>
<span class="s0">];</span>
<span class="s1">function </span><span class="s0">isBooleanScriptAttribute(attr) {</span>
    <span class="s1">return </span><span class="s0">[</span>
        <span class="s2">'async'</span><span class="s0">,</span>
        <span class="s2">'defer'</span><span class="s0">,</span>
        <span class="s2">'noModule'</span>
    <span class="s0">].includes(attr);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">setAttributesFromProps(el, props) {</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">[p, value] of Object.entries(props)){</span>
        <span class="s1">if </span><span class="s0">(!props.hasOwnProperty(p)) </span><span class="s1">continue</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(ignoreProps.includes(p)) </span><span class="s1">continue</span><span class="s0">;</span>
        <span class="s3">// we don't render undefined props to the DOM</span>
        <span class="s1">if </span><span class="s0">(value === undefined) {</span>
            <span class="s1">continue</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">attr = DOMAttributeNames[p] || p.toLowerCase();</span>
        <span class="s1">if </span><span class="s0">(el.tagName === </span><span class="s2">'SCRIPT' </span><span class="s0">&amp;&amp; isBooleanScriptAttribute(attr)) {</span>
            <span class="s3">// Correctly assign boolean script attributes</span>
            <span class="s3">// https://github.com/vercel/next.js/pull/20748</span>
            <span class="s0">;</span>
            <span class="s0">el[attr] = !!value;</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">el.setAttribute(attr, String(value));</span>
        <span class="s0">}</span>
        <span class="s3">// Remove falsy non-zero boolean attributes so they are correctly interpreted</span>
        <span class="s3">// (e.g. if we set them to false, this coerces to the string &quot;false&quot;, which the browser interprets as true)</span>
        <span class="s1">if </span><span class="s0">(value === </span><span class="s1">false </span><span class="s0">|| el.tagName === </span><span class="s2">'SCRIPT' </span><span class="s0">&amp;&amp; isBooleanScriptAttribute(attr) &amp;&amp; (!value || value === </span><span class="s2">'false'</span><span class="s0">)) {</span>
            <span class="s3">// Call setAttribute before, as we need to set and unset the attribute to override force async:</span>
            <span class="s3">// https://html.spec.whatwg.org/multipage/scripting.html#script-force-async</span>
            <span class="s0">el.setAttribute(attr, </span><span class="s2">''</span><span class="s0">);</span>
            <span class="s0">el.removeAttribute(attr);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=set-attributes-from-props.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/app-bootstrap.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s3">/**</span>
 <span class="s3">* Before starting the Next.js runtime and requiring any module, we need to make</span>
 <span class="s3">* sure the following scripts are executed in the correct order:</span>
 <span class="s3">* - Polyfills</span>
 <span class="s3">* - next/script with `beforeInteractive` strategy</span>
 <span class="s3">*/ </span><span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;appBootstrap&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">appBootstrap;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_setattributesfromprops = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/set-attributes-from-props.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">version = </span><span class="s2">&quot;15.5.4&quot;</span><span class="s0">;</span>
<span class="s0">window.next = {</span>
    <span class="s0">version,</span>
    <span class="s0">appDir: </span><span class="s1">true</span>
<span class="s0">};</span>
<span class="s1">function </span><span class="s0">loadScriptsInSequence(scripts, hydrate) {</span>
    <span class="s1">if </span><span class="s0">(!scripts || !scripts.length) {</span>
        <span class="s1">return </span><span class="s0">hydrate();</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">scripts.reduce((promise, param)=&gt;{</span>
        <span class="s1">let </span><span class="s0">[src, props] = param;</span>
        <span class="s1">return </span><span class="s0">promise.then(()=&gt;{</span>
            <span class="s1">return new </span><span class="s0">Promise((resolve, reject)=&gt;{</span>
                <span class="s1">const </span><span class="s0">el = document.createElement(</span><span class="s2">'script'</span><span class="s0">);</span>
                <span class="s1">if </span><span class="s0">(props) {</span>
                    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _setattributesfromprops.setAttributesFromProps)(el, props);</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(src) {</span>
                    <span class="s0">el.src = src;</span>
                    <span class="s0">el.onload = ()=&gt;resolve();</span>
                    <span class="s0">el.onerror = reject;</span>
                <span class="s0">} </span><span class="s1">else if </span><span class="s0">(props) {</span>
                    <span class="s0">el.innerHTML = props.children;</span>
                    <span class="s0">setTimeout(resolve);</span>
                <span class="s0">}</span>
                <span class="s0">document.head.appendChild(el);</span>
            <span class="s0">});</span>
        <span class="s0">});</span>
    <span class="s0">}, Promise.resolve()).catch((err)=&gt;{</span>
        <span class="s0">console.error(err);</span>
    <span class="s3">// Still try to hydrate even if there's an error.</span>
    <span class="s0">}).then(()=&gt;{</span>
        <span class="s0">hydrate();</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">appBootstrap(hydrate) {</span>
    <span class="s0">loadScriptsInSequence(self.__next_s, ()=&gt;{</span>
        <span class="s3">// If the static shell is being debugged, skip hydration if the</span>
        <span class="s3">// `__nextppronly` query is present. This is only enabled when the</span>
        <span class="s3">// environment variable `__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING` is</span>
        <span class="s3">// set to `1`. Otherwise the following is optimized out.</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) </span><span class="s3">//TURBOPACK unreachable</span>
        <span class="s0">;</span>
        <span class="s0">hydrate();</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=app-bootstrap.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/react-client-callbacks/report-global-error.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;reportGlobalError&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">reportGlobalError;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">reportGlobalError = </span><span class="s1">typeof </span><span class="s0">reportError === </span><span class="s2">'function' </span><span class="s0">? reportError : (error)=&gt;{</span>
    <span class="s3">// TODO: Dispatch error event</span>
    <span class="s0">globalThis.console.error(error);</span>
<span class="s0">};</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=report-global-error.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/react-client-callbacks/on-recoverable-error.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s3">// This module can be shared between both pages router and app router</span>
<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s0">isRecoverableError: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">onRecoverableError: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s0">isRecoverableError: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">isRecoverableError;</span>
    <span class="s0">},</span>
    <span class="s0">onRecoverableError: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">onRecoverableError;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_interop_require_default = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_bailouttocsr = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_iserror = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">_interop_require_default._(__turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/lib/is-error.js [app-client] (ecmascript)&quot;</span><span class="s0">));</span>
<span class="s1">const </span><span class="s0">_reportglobalerror = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/react-client-callbacks/report-global-error.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">recoverableErrors = </span><span class="s1">new </span><span class="s0">WeakSet();</span>
<span class="s1">function </span><span class="s0">isRecoverableError(error) {</span>
    <span class="s1">return </span><span class="s0">recoverableErrors.has(error);</span>
<span class="s0">}</span>
<span class="s1">const </span><span class="s0">onRecoverableError = (error)=&gt;{</span>
    <span class="s3">// x-ref: https://github.com/facebook/react/pull/28736</span>
    <span class="s1">let </span><span class="s0">cause = (</span><span class="s4">0</span><span class="s0">, _iserror.default)(error) &amp;&amp; </span><span class="s2">'cause' </span><span class="s1">in </span><span class="s0">error ? error.cause : error;</span>
    <span class="s3">// Skip certain custom errors which are not expected to be reported on client</span>
    <span class="s1">if </span><span class="s0">((</span><span class="s4">0</span><span class="s0">, _bailouttocsr.isBailoutToCSRError)(cause)) </span><span class="s1">return</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s0">) {</span>
        <span class="s1">const </span><span class="s0">{ decorateDevError } = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/next-devtools/userspace/app/errors/stitched-error.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
        <span class="s1">const </span><span class="s0">causeError = decorateDevError(cause);</span>
        <span class="s0">recoverableErrors.add(causeError);</span>
        <span class="s0">cause = causeError;</span>
    <span class="s0">}</span>
    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _reportglobalerror.reportGlobalError)(cause);</span>
<span class="s0">};</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=on-recoverable-error.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s0">HTTPAccessErrorStatus: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">HTTP_ERROR_FALLBACK_ERROR_CODE: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">getAccessFallbackErrorTypeByStatus: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">getAccessFallbackHTTPStatus: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">isHTTPAccessFallbackError: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s0">HTTPAccessErrorStatus: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">HTTPAccessErrorStatus;</span>
    <span class="s0">},</span>
    <span class="s0">HTTP_ERROR_FALLBACK_ERROR_CODE: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">HTTP_ERROR_FALLBACK_ERROR_CODE;</span>
    <span class="s0">},</span>
    <span class="s0">getAccessFallbackErrorTypeByStatus: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">getAccessFallbackErrorTypeByStatus;</span>
    <span class="s0">},</span>
    <span class="s0">getAccessFallbackHTTPStatus: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">getAccessFallbackHTTPStatus;</span>
    <span class="s0">},</span>
    <span class="s0">isHTTPAccessFallbackError: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">isHTTPAccessFallbackError;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">HTTPAccessErrorStatus = {</span>
    <span class="s0">NOT_FOUND: </span><span class="s4">404</span><span class="s0">,</span>
    <span class="s0">FORBIDDEN: </span><span class="s4">403</span><span class="s0">,</span>
    <span class="s0">UNAUTHORIZED: </span><span class="s4">401</span>
<span class="s0">};</span>
<span class="s1">const </span><span class="s0">ALLOWED_CODES = </span><span class="s1">new </span><span class="s0">Set(Object.values(HTTPAccessErrorStatus));</span>
<span class="s1">const </span><span class="s0">HTTP_ERROR_FALLBACK_ERROR_CODE = </span><span class="s2">'NEXT_HTTP_ERROR_FALLBACK'</span><span class="s0">;</span>
<span class="s1">function </span><span class="s0">isHTTPAccessFallbackError(error) {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">error !== </span><span class="s2">'object' </span><span class="s0">|| error === </span><span class="s1">null </span><span class="s0">|| !(</span><span class="s2">'digest' </span><span class="s1">in </span><span class="s0">error) || </span><span class="s1">typeof </span><span class="s0">error.digest !== </span><span class="s2">'string'</span><span class="s0">) {</span>
        <span class="s1">return false</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">[prefix, httpStatus] = error.digest.split(</span><span class="s2">';'</span><span class="s0">);</span>
    <span class="s1">return </span><span class="s0">prefix === HTTP_ERROR_FALLBACK_ERROR_CODE &amp;&amp; ALLOWED_CODES.has(Number(httpStatus));</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">getAccessFallbackHTTPStatus(error) {</span>
    <span class="s1">const </span><span class="s0">httpStatus = error.digest.split(</span><span class="s2">';'</span><span class="s0">)[</span><span class="s4">1</span><span class="s0">];</span>
    <span class="s1">return </span><span class="s0">Number(httpStatus);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">getAccessFallbackErrorTypeByStatus(status) {</span>
    <span class="s1">switch</span><span class="s0">(status){</span>
        <span class="s1">case </span><span class="s4">401</span><span class="s0">:</span>
            <span class="s1">return </span><span class="s2">'unauthorized'</span><span class="s0">;</span>
        <span class="s1">case </span><span class="s4">403</span><span class="s0">:</span>
            <span class="s1">return </span><span class="s2">'forbidden'</span><span class="s0">;</span>
        <span class="s1">case </span><span class="s4">404</span><span class="s0">:</span>
            <span class="s1">return </span><span class="s2">'not-found'</span><span class="s0">;</span>
        <span class="s1">default</span><span class="s0">:</span>
            <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=http-access-fallback.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/redirect-status-code.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;RedirectStatusCode&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">RedirectStatusCode;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">var </span><span class="s0">RedirectStatusCode = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">function</span><span class="s0">(RedirectStatusCode) {</span>
    <span class="s0">RedirectStatusCode[RedirectStatusCode[</span><span class="s2">&quot;SeeOther&quot;</span><span class="s0">] = </span><span class="s4">303</span><span class="s0">] = </span><span class="s2">&quot;SeeOther&quot;</span><span class="s0">;</span>
    <span class="s0">RedirectStatusCode[RedirectStatusCode[</span><span class="s2">&quot;TemporaryRedirect&quot;</span><span class="s0">] = </span><span class="s4">307</span><span class="s0">] = </span><span class="s2">&quot;TemporaryRedirect&quot;</span><span class="s0">;</span>
    <span class="s0">RedirectStatusCode[RedirectStatusCode[</span><span class="s2">&quot;PermanentRedirect&quot;</span><span class="s0">] = </span><span class="s4">308</span><span class="s0">] = </span><span class="s2">&quot;PermanentRedirect&quot;</span><span class="s0">;</span>
    <span class="s1">return </span><span class="s0">RedirectStatusCode;</span>
<span class="s0">}({});</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=redirect-status-code.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/redirect-error.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s0">REDIRECT_ERROR_CODE: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">RedirectType: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">isRedirectError: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s0">REDIRECT_ERROR_CODE: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">REDIRECT_ERROR_CODE;</span>
    <span class="s0">},</span>
    <span class="s0">RedirectType: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">RedirectType;</span>
    <span class="s0">},</span>
    <span class="s0">isRedirectError: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">isRedirectError;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_redirectstatuscode = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/redirect-status-code.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">REDIRECT_ERROR_CODE = </span><span class="s2">'NEXT_REDIRECT'</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">RedirectType = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">function</span><span class="s0">(RedirectType) {</span>
    <span class="s0">RedirectType[</span><span class="s2">&quot;push&quot;</span><span class="s0">] = </span><span class="s2">&quot;push&quot;</span><span class="s0">;</span>
    <span class="s0">RedirectType[</span><span class="s2">&quot;replace&quot;</span><span class="s0">] = </span><span class="s2">&quot;replace&quot;</span><span class="s0">;</span>
    <span class="s1">return </span><span class="s0">RedirectType;</span>
<span class="s0">}({});</span>
<span class="s1">function </span><span class="s0">isRedirectError(error) {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">error !== </span><span class="s2">'object' </span><span class="s0">|| error === </span><span class="s1">null </span><span class="s0">|| !(</span><span class="s2">'digest' </span><span class="s1">in </span><span class="s0">error) || </span><span class="s1">typeof </span><span class="s0">error.digest !== </span><span class="s2">'string'</span><span class="s0">) {</span>
        <span class="s1">return false</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">digest = error.digest.split(</span><span class="s2">';'</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">[errorCode, type] = digest;</span>
    <span class="s1">const </span><span class="s0">destination = digest.slice(</span><span class="s4">2</span><span class="s0">, -</span><span class="s4">2</span><span class="s0">).join(</span><span class="s2">';'</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">status = digest.at(-</span><span class="s4">2</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">statusCode = Number(status);</span>
    <span class="s1">return </span><span class="s0">errorCode === REDIRECT_ERROR_CODE &amp;&amp; (type === </span><span class="s2">'replace' </span><span class="s0">|| type === </span><span class="s2">'push'</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">destination === </span><span class="s2">'string' </span><span class="s0">&amp;&amp; !isNaN(statusCode) &amp;&amp; statusCode </span><span class="s1">in </span><span class="s0">_redirectstatuscode.RedirectStatusCode;</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=redirect-error.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/is-next-router-error.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;isNextRouterError&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">isNextRouterError;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_httpaccessfallback = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_redirecterror = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/redirect-error.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">isNextRouterError(error) {</span>
    <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _redirecterror.isRedirectError)(error) || (</span><span class="s4">0</span><span class="s0">, _httpaccessfallback.isHTTPAccessFallbackError)(error);</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=is-next-router-error.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/lib/console.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s0">formatConsoleArgs: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">parseConsoleArgs: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s0">formatConsoleArgs: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">formatConsoleArgs;</span>
    <span class="s0">},</span>
    <span class="s0">parseConsoleArgs: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">parseConsoleArgs;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_interop_require_default = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_iserror = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">_interop_require_default._(__turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/lib/is-error.js [app-client] (ecmascript)&quot;</span><span class="s0">));</span>
<span class="s1">function </span><span class="s0">formatObject(arg, depth) {</span>
    <span class="s1">switch</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">arg){</span>
        <span class="s1">case </span><span class="s2">'object'</span><span class="s0">:</span>
            <span class="s1">if </span><span class="s0">(arg === </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s1">return </span><span class="s2">'null'</span><span class="s0">;</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(Array.isArray(arg)) {</span>
                <span class="s1">let </span><span class="s0">result = </span><span class="s2">'['</span><span class="s0">;</span>
                <span class="s1">if </span><span class="s0">(depth &lt; </span><span class="s4">1</span><span class="s0">) {</span>
                    <span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; arg.length; i++){</span>
                        <span class="s1">if </span><span class="s0">(result !== </span><span class="s2">'['</span><span class="s0">) {</span>
                            <span class="s0">result += </span><span class="s2">','</span><span class="s0">;</span>
                        <span class="s0">}</span>
                        <span class="s1">if </span><span class="s0">(Object.prototype.hasOwnProperty.call(arg, i)) {</span>
                            <span class="s0">result += formatObject(arg[i], depth + </span><span class="s4">1</span><span class="s0">);</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">result += arg.length &gt; </span><span class="s4">0 </span><span class="s0">? </span><span class="s2">'...' </span><span class="s0">: </span><span class="s2">''</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s0">result += </span><span class="s2">']'</span><span class="s0">;</span>
                <span class="s1">return </span><span class="s0">result;</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(arg </span><span class="s1">instanceof </span><span class="s0">Error) {</span>
                <span class="s1">return </span><span class="s0">arg + </span><span class="s2">''</span><span class="s0">;</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s1">const </span><span class="s0">keys = Object.keys(arg);</span>
                <span class="s1">let </span><span class="s0">result = </span><span class="s2">'{'</span><span class="s0">;</span>
                <span class="s1">if </span><span class="s0">(depth &lt; </span><span class="s4">1</span><span class="s0">) {</span>
                    <span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; keys.length; i++){</span>
                        <span class="s1">const </span><span class="s0">key = keys[i];</span>
                        <span class="s1">const </span><span class="s0">desc = Object.getOwnPropertyDescriptor(arg, </span><span class="s2">'key'</span><span class="s0">);</span>
                        <span class="s1">if </span><span class="s0">(desc &amp;&amp; !desc.get &amp;&amp; !desc.set) {</span>
                            <span class="s1">const </span><span class="s0">jsonKey = JSON.stringify(key);</span>
                            <span class="s1">if </span><span class="s0">(jsonKey !== </span><span class="s2">'&quot;' </span><span class="s0">+ key + </span><span class="s2">'&quot;'</span><span class="s0">) {</span>
                                <span class="s0">result += jsonKey + </span><span class="s2">': '</span><span class="s0">;</span>
                            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                                <span class="s0">result += key + </span><span class="s2">': '</span><span class="s0">;</span>
                            <span class="s0">}</span>
                            <span class="s0">result += formatObject(desc.value, depth + </span><span class="s4">1</span><span class="s0">);</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">result += keys.length &gt; </span><span class="s4">0 </span><span class="s0">? </span><span class="s2">'...' </span><span class="s0">: </span><span class="s2">''</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s0">result += </span><span class="s2">'}'</span><span class="s0">;</span>
                <span class="s1">return </span><span class="s0">result;</span>
            <span class="s0">}</span>
        <span class="s1">case </span><span class="s2">'string'</span><span class="s0">:</span>
            <span class="s1">return </span><span class="s0">JSON.stringify(arg);</span>
        <span class="s1">case </span><span class="s2">'number'</span><span class="s0">:</span>
        <span class="s1">case </span><span class="s2">'bigint'</span><span class="s0">:</span>
        <span class="s1">case </span><span class="s2">'boolean'</span><span class="s0">:</span>
        <span class="s1">case </span><span class="s2">'symbol'</span><span class="s0">:</span>
        <span class="s1">case </span><span class="s2">'undefined'</span><span class="s0">:</span>
        <span class="s1">case </span><span class="s2">'function'</span><span class="s0">:</span>
        <span class="s1">default</span><span class="s0">:</span>
            <span class="s1">return </span><span class="s0">String(arg);</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">formatConsoleArgs(args) {</span>
    <span class="s1">let </span><span class="s0">message;</span>
    <span class="s1">let </span><span class="s0">idx;</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">args[</span><span class="s4">0</span><span class="s0">] === </span><span class="s2">'string'</span><span class="s0">) {</span>
        <span class="s0">message = args[</span><span class="s4">0</span><span class="s0">];</span>
        <span class="s0">idx = </span><span class="s4">1</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">message = </span><span class="s2">''</span><span class="s0">;</span>
        <span class="s0">idx = </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">let </span><span class="s0">result = </span><span class="s2">''</span><span class="s0">;</span>
    <span class="s1">let </span><span class="s0">startQuote = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; message.length; ++i){</span>
        <span class="s1">const </span><span class="s0">char = message[i];</span>
        <span class="s1">if </span><span class="s0">(char !== </span><span class="s2">'%' </span><span class="s0">|| i === message.length - </span><span class="s4">1 </span><span class="s0">|| idx &gt;= args.length) {</span>
            <span class="s0">result += char;</span>
            <span class="s1">continue</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">code = message[++i];</span>
        <span class="s1">switch</span><span class="s0">(code){</span>
            <span class="s1">case </span><span class="s2">'c'</span><span class="s0">:</span>
                <span class="s0">{</span>
                    <span class="s3">// TODO: We should colorize with HTML instead of turning into a string.</span>
                    <span class="s3">// Ignore for now.</span>
                    <span class="s0">result = startQuote ? </span><span class="s2">&quot;&quot; </span><span class="s0">+ result + </span><span class="s2">&quot;]&quot; </span><span class="s0">: </span><span class="s2">&quot;[&quot; </span><span class="s0">+ result;</span>
                    <span class="s0">startQuote = !startQuote;</span>
                    <span class="s0">idx++;</span>
                    <span class="s1">break</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s1">case </span><span class="s2">'O'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'o'</span><span class="s0">:</span>
                <span class="s0">{</span>
                    <span class="s0">result += formatObject(args[idx++], </span><span class="s4">0</span><span class="s0">);</span>
                    <span class="s1">break</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s1">case </span><span class="s2">'d'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'i'</span><span class="s0">:</span>
                <span class="s0">{</span>
                    <span class="s0">result += parseInt(args[idx++], </span><span class="s4">10</span><span class="s0">);</span>
                    <span class="s1">break</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s1">case </span><span class="s2">'f'</span><span class="s0">:</span>
                <span class="s0">{</span>
                    <span class="s0">result += parseFloat(args[idx++]);</span>
                    <span class="s1">break</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s1">case </span><span class="s2">'s'</span><span class="s0">:</span>
                <span class="s0">{</span>
                    <span class="s0">result += String(args[idx++]);</span>
                    <span class="s1">break</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s1">default</span><span class="s0">:</span>
                <span class="s0">result += </span><span class="s2">'%' </span><span class="s0">+ code;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">for</span><span class="s0">(; idx &lt; args.length; idx++){</span>
        <span class="s0">result += (idx &gt; </span><span class="s4">0 </span><span class="s0">? </span><span class="s2">' ' </span><span class="s0">: </span><span class="s2">''</span><span class="s0">) + formatObject(args[idx], </span><span class="s4">0</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">result;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">parseConsoleArgs(args) {</span>
    <span class="s3">// See</span>
    <span class="s3">// https://github.com/facebook/react/blob/65a56d0e99261481c721334a3ec4561d173594cd/packages/react-devtools-shared/src/backend/flight/renderer.js#L88-L93</span>
    <span class="s3">//</span>
    <span class="s3">// Logs replayed from the server look like this:</span>
    <span class="s3">// [</span>
    <span class="s3">//   &quot;%c%s%c%o\n\n%s\n\n%s\n&quot;,</span>
    <span class="s3">//   &quot;background: #e6e6e6; ...&quot;,</span>
    <span class="s3">//   &quot; Server &quot;, // can also be e.g. &quot; Prerender &quot;</span>
    <span class="s3">//   &quot;&quot;,</span>
    <span class="s3">//   Error,</span>
    <span class="s3">//   &quot;The above error occurred in the &lt;Page&gt; component.&quot;,</span>
    <span class="s3">//   ...</span>
    <span class="s3">// ]</span>
    <span class="s1">if </span><span class="s0">(args.length &gt; </span><span class="s4">3 </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">args[</span><span class="s4">0</span><span class="s0">] === </span><span class="s2">'string' </span><span class="s0">&amp;&amp; args[</span><span class="s4">0</span><span class="s0">].startsWith(</span><span class="s2">'%c%s%c'</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">args[</span><span class="s4">1</span><span class="s0">] === </span><span class="s2">'string' </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">args[</span><span class="s4">2</span><span class="s0">] === </span><span class="s2">'string' </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">args[</span><span class="s4">3</span><span class="s0">] === </span><span class="s2">'string'</span><span class="s0">) {</span>
        <span class="s1">const </span><span class="s0">environmentName = args[</span><span class="s4">2</span><span class="s0">];</span>
        <span class="s1">const </span><span class="s0">maybeError = args[</span><span class="s4">4</span><span class="s0">];</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">environmentName: environmentName.trim(),</span>
            <span class="s0">error: (</span><span class="s4">0</span><span class="s0">, _iserror.default)(maybeError) ? maybeError : </span><span class="s1">null</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">{</span>
        <span class="s0">environmentName: </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">error: </span><span class="s1">null</span>
    <span class="s0">};</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=console.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/app-globals.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s3">// imports polyfill from `@next/polyfill-module` after build.</span>
<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">__turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/polyfill-module.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s3">// Only setup devtools in development</span>
<span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s0">) {</span>
    <span class="s0">__turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/next-devtools/userspace/app/app-dev-overlay-setup.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=app-globals.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/app-router-headers.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s0">ACTION_HEADER: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">FLIGHT_HEADERS: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">NEXT_ACTION_NOT_FOUND_HEADER: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">NEXT_DID_POSTPONE_HEADER: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">NEXT_HMR_REFRESH_HASH_COOKIE: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">NEXT_HMR_REFRESH_HEADER: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">NEXT_IS_PRERENDER_HEADER: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">NEXT_REWRITTEN_PATH_HEADER: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">NEXT_REWRITTEN_QUERY_HEADER: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">NEXT_ROUTER_PREFETCH_HEADER: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">NEXT_ROUTER_SEGMENT_PREFETCH_HEADER: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">NEXT_ROUTER_STALE_TIME_HEADER: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">NEXT_ROUTER_STATE_TREE_HEADER: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">NEXT_RSC_UNION_QUERY: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">NEXT_URL: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">RSC_CONTENT_TYPE_HEADER: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">RSC_HEADER: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s0">ACTION_HEADER: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">ACTION_HEADER;</span>
    <span class="s0">},</span>
    <span class="s0">FLIGHT_HEADERS: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">FLIGHT_HEADERS;</span>
    <span class="s0">},</span>
    <span class="s0">NEXT_ACTION_NOT_FOUND_HEADER: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">NEXT_ACTION_NOT_FOUND_HEADER;</span>
    <span class="s0">},</span>
    <span class="s0">NEXT_DID_POSTPONE_HEADER: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">NEXT_DID_POSTPONE_HEADER;</span>
    <span class="s0">},</span>
    <span class="s0">NEXT_HMR_REFRESH_HASH_COOKIE: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">NEXT_HMR_REFRESH_HASH_COOKIE;</span>
    <span class="s0">},</span>
    <span class="s0">NEXT_HMR_REFRESH_HEADER: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">NEXT_HMR_REFRESH_HEADER;</span>
    <span class="s0">},</span>
    <span class="s0">NEXT_IS_PRERENDER_HEADER: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">NEXT_IS_PRERENDER_HEADER;</span>
    <span class="s0">},</span>
    <span class="s0">NEXT_REWRITTEN_PATH_HEADER: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">NEXT_REWRITTEN_PATH_HEADER;</span>
    <span class="s0">},</span>
    <span class="s0">NEXT_REWRITTEN_QUERY_HEADER: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">NEXT_REWRITTEN_QUERY_HEADER;</span>
    <span class="s0">},</span>
    <span class="s0">NEXT_ROUTER_PREFETCH_HEADER: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">NEXT_ROUTER_PREFETCH_HEADER;</span>
    <span class="s0">},</span>
    <span class="s0">NEXT_ROUTER_SEGMENT_PREFETCH_HEADER: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">NEXT_ROUTER_SEGMENT_PREFETCH_HEADER;</span>
    <span class="s0">},</span>
    <span class="s0">NEXT_ROUTER_STALE_TIME_HEADER: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">NEXT_ROUTER_STALE_TIME_HEADER;</span>
    <span class="s0">},</span>
    <span class="s0">NEXT_ROUTER_STATE_TREE_HEADER: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">NEXT_ROUTER_STATE_TREE_HEADER;</span>
    <span class="s0">},</span>
    <span class="s0">NEXT_RSC_UNION_QUERY: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">NEXT_RSC_UNION_QUERY;</span>
    <span class="s0">},</span>
    <span class="s0">NEXT_URL: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">NEXT_URL;</span>
    <span class="s0">},</span>
    <span class="s0">RSC_CONTENT_TYPE_HEADER: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">RSC_CONTENT_TYPE_HEADER;</span>
    <span class="s0">},</span>
    <span class="s0">RSC_HEADER: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">RSC_HEADER;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">RSC_HEADER = </span><span class="s2">'rsc'</span><span class="s0">;</span>
<span class="s1">const </span><span class="s0">ACTION_HEADER = </span><span class="s2">'next-action'</span><span class="s0">;</span>
<span class="s1">const </span><span class="s0">NEXT_ROUTER_STATE_TREE_HEADER = </span><span class="s2">'next-router-state-tree'</span><span class="s0">;</span>
<span class="s1">const </span><span class="s0">NEXT_ROUTER_PREFETCH_HEADER = </span><span class="s2">'next-router-prefetch'</span><span class="s0">;</span>
<span class="s1">const </span><span class="s0">NEXT_ROUTER_SEGMENT_PREFETCH_HEADER = </span><span class="s2">'next-router-segment-prefetch'</span><span class="s0">;</span>
<span class="s1">const </span><span class="s0">NEXT_HMR_REFRESH_HEADER = </span><span class="s2">'next-hmr-refresh'</span><span class="s0">;</span>
<span class="s1">const </span><span class="s0">NEXT_HMR_REFRESH_HASH_COOKIE = </span><span class="s2">'__next_hmr_refresh_hash__'</span><span class="s0">;</span>
<span class="s1">const </span><span class="s0">NEXT_URL = </span><span class="s2">'next-url'</span><span class="s0">;</span>
<span class="s1">const </span><span class="s0">RSC_CONTENT_TYPE_HEADER = </span><span class="s2">'text/x-component'</span><span class="s0">;</span>
<span class="s1">const </span><span class="s0">FLIGHT_HEADERS = [</span>
    <span class="s0">RSC_HEADER,</span>
    <span class="s0">NEXT_ROUTER_STATE_TREE_HEADER,</span>
    <span class="s0">NEXT_ROUTER_PREFETCH_HEADER,</span>
    <span class="s0">NEXT_HMR_REFRESH_HEADER,</span>
    <span class="s0">NEXT_ROUTER_SEGMENT_PREFETCH_HEADER</span>
<span class="s0">];</span>
<span class="s1">const </span><span class="s0">NEXT_RSC_UNION_QUERY = </span><span class="s2">'_rsc'</span><span class="s0">;</span>
<span class="s1">const </span><span class="s0">NEXT_ROUTER_STALE_TIME_HEADER = </span><span class="s2">'x-nextjs-stale-time'</span><span class="s0">;</span>
<span class="s1">const </span><span class="s0">NEXT_DID_POSTPONE_HEADER = </span><span class="s2">'x-nextjs-postponed'</span><span class="s0">;</span>
<span class="s1">const </span><span class="s0">NEXT_REWRITTEN_PATH_HEADER = </span><span class="s2">'x-nextjs-rewritten-path'</span><span class="s0">;</span>
<span class="s1">const </span><span class="s0">NEXT_REWRITTEN_QUERY_HEADER = </span><span class="s2">'x-nextjs-rewritten-query'</span><span class="s0">;</span>
<span class="s1">const </span><span class="s0">NEXT_IS_PRERENDER_HEADER = </span><span class="s2">'x-nextjs-prerender'</span><span class="s0">;</span>
<span class="s1">const </span><span class="s0">NEXT_ACTION_NOT_FOUND_HEADER = </span><span class="s2">'x-nextjs-action-not-found'</span><span class="s0">;</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=app-router-headers.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/navigation-untracked.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;useUntrackedPathname&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">useUntrackedPathname;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_react = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_hooksclientcontextsharedruntime = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s3">/**</span>
 <span class="s3">* This checks to see if the current render has any unknown route parameters.</span>
 <span class="s3">* It's used to trigger a different render path in the error boundary.</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s5">@returns </span><span class="s3">true if there are any unknown route parameters, false otherwise</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">hasFallbackRouteParams() {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">window === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
        <span class="s3">// AsyncLocalStorage should not be included in the client bundle.</span>
        <span class="s1">const </span><span class="s0">{ workUnitAsyncStorage } = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/server/app-render/work-unit-async-storage.external.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
        <span class="s1">const </span><span class="s0">workUnitStore = workUnitAsyncStorage.getStore();</span>
        <span class="s1">if </span><span class="s0">(!workUnitStore) </span><span class="s1">return false</span><span class="s0">;</span>
        <span class="s1">switch</span><span class="s0">(workUnitStore.type){</span>
            <span class="s1">case </span><span class="s2">'prerender'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'prerender-client'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'prerender-ppr'</span><span class="s0">:</span>
                <span class="s1">const </span><span class="s0">fallbackParams = workUnitStore.fallbackRouteParams;</span>
                <span class="s1">return </span><span class="s0">fallbackParams ? fallbackParams.size &gt; </span><span class="s4">0 </span><span class="s0">: </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s1">case </span><span class="s2">'prerender-legacy'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'request'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'prerender-runtime'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'cache'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'private-cache'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'unstable-cache'</span><span class="s0">:</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s1">default</span><span class="s0">:</span>
                <span class="s0">workUnitStore;</span>
        <span class="s0">}</span>
        <span class="s1">return false</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">return false</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">useUntrackedPathname() {</span>
    <span class="s3">// If there are any unknown route parameters we would typically throw</span>
    <span class="s3">// an error, but this internal method allows us to return a null value instead</span>
    <span class="s3">// for components that do not propagate the pathname to the static shell (like</span>
    <span class="s3">// the error boundary).</span>
    <span class="s1">if </span><span class="s0">(hasFallbackRouteParams()) {</span>
        <span class="s1">return null</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s3">// This shouldn't cause any issues related to conditional rendering because</span>
    <span class="s3">// the environment will be consistent for the render.</span>
    <span class="s3">// eslint-disable-next-line react-hooks/rules-of-hooks</span>
    <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _react.useContext)(_hooksclientcontextsharedruntime.PathnameContext);</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=navigation-untracked.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;createHrefFromUrl&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">createHrefFromUrl;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">createHrefFromUrl(url, includeHash) {</span>
    <span class="s1">if </span><span class="s0">(includeHash === </span><span class="s1">void </span><span class="s4">0</span><span class="s0">) includeHash = </span><span class="s1">true</span><span class="s0">;</span>
    <span class="s1">return </span><span class="s0">url.pathname + url.search + (includeHash ? url.hash : </span><span class="s2">''</span><span class="s0">);</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=create-href-from-url.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/nav-failure-handler.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s0">handleHardNavError: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">useNavFailureHandler: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s0">handleHardNavError: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">handleHardNavError;</span>
    <span class="s0">},</span>
    <span class="s0">useNavFailureHandler: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">useNavFailureHandler;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_react = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_createhreffromurl = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">handleHardNavError(error) {</span>
    <span class="s1">if </span><span class="s0">(error &amp;&amp; </span><span class="s1">typeof </span><span class="s0">window !== </span><span class="s2">'undefined' </span><span class="s0">&amp;&amp; window.next.__pendingUrl &amp;&amp; (</span><span class="s4">0</span><span class="s0">, _createhreffromurl.createHrefFromUrl)(</span><span class="s1">new </span><span class="s0">URL(window.location.href)) !== (</span><span class="s4">0</span><span class="s0">, _createhreffromurl.createHrefFromUrl)(window.next.__pendingUrl)) {</span>
        <span class="s0">console.error(</span><span class="s2">&quot;Error occurred during navigation, falling back to hard navigation&quot;</span><span class="s0">, error);</span>
        <span class="s0">window.location.href = window.next.__pendingUrl.toString();</span>
        <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">return false</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">useNavFailureHandler() {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) </span><span class="s3">//TURBOPACK unreachable</span>
    <span class="s0">;</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=nav-failure-handler.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/handle-isr-error.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;HandleISRError&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">HandleISRError;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">workAsyncStorage = </span><span class="s1">typeof </span><span class="s0">window === </span><span class="s2">'undefined' </span><span class="s0">? __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/server/app-render/work-async-storage.external.js [app-client] (ecmascript)&quot;</span><span class="s0">).workAsyncStorage : undefined;</span>
<span class="s1">function </span><span class="s0">HandleISRError(param) {</span>
    <span class="s1">let </span><span class="s0">{ error } = param;</span>
    <span class="s1">if </span><span class="s0">(workAsyncStorage) {</span>
        <span class="s1">const </span><span class="s0">store = workAsyncStorage.getStore();</span>
        <span class="s1">if </span><span class="s0">((store == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: store.isRevalidate) || (store == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: store.isStaticGeneration)) {</span>
            <span class="s0">console.error(error);</span>
            <span class="s1">throw </span><span class="s0">error;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">return null</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=handle-isr-error.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/error-boundary.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">'use client'</span><span class="s0">;</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s0">ErrorBoundary: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">ErrorBoundaryHandler: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s0">ErrorBoundary: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">ErrorBoundary;</span>
    <span class="s0">},</span>
    <span class="s0">ErrorBoundaryHandler: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">ErrorBoundaryHandler;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_interop_require_default = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_jsxruntime = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_react = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">_interop_require_default._(__turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)&quot;</span><span class="s0">));</span>
<span class="s1">const </span><span class="s0">_navigationuntracked = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/navigation-untracked.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_isnextroutererror = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/is-next-router-error.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_navfailurehandler = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/nav-failure-handler.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_handleisrerror = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/handle-isr-error.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_isbot = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/router/utils/is-bot.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">isBotUserAgent = </span><span class="s1">typeof </span><span class="s0">window !== </span><span class="s2">'undefined' </span><span class="s0">&amp;&amp; (</span><span class="s4">0</span><span class="s0">, _isbot.isBot)(window.navigator.userAgent);</span>
<span class="s1">class </span><span class="s0">ErrorBoundaryHandler </span><span class="s1">extends </span><span class="s0">_react.default.Component {</span>
    <span class="s1">static </span><span class="s0">getDerivedStateFromError(error) {</span>
        <span class="s1">if </span><span class="s0">((</span><span class="s4">0</span><span class="s0">, _isnextroutererror.isNextRouterError)(error)) {</span>
            <span class="s3">// Re-throw if an expected internal Next.js router error occurs</span>
            <span class="s3">// this means it should be handled by a different boundary (such as a NotFound boundary in a parent segment)</span>
            <span class="s1">throw </span><span class="s0">error;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">error</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s1">static </span><span class="s0">getDerivedStateFromProps(props, state) {</span>
        <span class="s1">const </span><span class="s0">{ error } = state;</span>
        <span class="s3">// if we encounter an error while</span>
        <span class="s3">// a navigation is pending we shouldn't render</span>
        <span class="s3">// the error boundary and instead should fallback</span>
        <span class="s3">// to a hard navigation to attempt recovering</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) </span><span class="s3">//TURBOPACK unreachable</span>
        <span class="s0">;</span>
        <span class="s3">/**</span>
     <span class="s3">* Handles reset of the error boundary when a navigation happens.</span>
     <span class="s3">* Ensures the error boundary does not stay enabled when navigating to a new page.</span>
     <span class="s3">* Approach of setState in render is safe as it checks the previous pathname and then overrides</span>
     <span class="s3">* it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders</span>
     <span class="s3">*/ </span><span class="s1">if </span><span class="s0">(props.pathname !== state.previousPathname &amp;&amp; state.error) {</span>
            <span class="s1">return </span><span class="s0">{</span>
                <span class="s0">error: </span><span class="s1">null</span><span class="s0">,</span>
                <span class="s0">previousPathname: props.pathname</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">error: state.error,</span>
            <span class="s0">previousPathname: props.pathname</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s3">// Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific to the `@types/react` version.</span>
    <span class="s0">render() {</span>
        <span class="s3">//When it's bot request, segment level error boundary will keep rendering the children,</span>
        <span class="s3">// the final error will be caught by the root error boundary and determine wether need to apply graceful degrade.</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.error &amp;&amp; !isBotUserAgent) {</span>
            <span class="s1">return </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsxs)(_jsxruntime.Fragment, {</span>
                <span class="s0">children: [</span>
                    <span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(_handleisrerror.HandleISRError, {</span>
                        <span class="s0">error: </span><span class="s1">this</span><span class="s0">.state.error</span>
                    <span class="s0">}),</span>
                    <span class="s1">this</span><span class="s0">.props.errorStyles,</span>
                    <span class="s1">this</span><span class="s0">.props.errorScripts,</span>
                    <span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(</span><span class="s1">this</span><span class="s0">.props.errorComponent, {</span>
                        <span class="s0">error: </span><span class="s1">this</span><span class="s0">.state.error,</span>
                        <span class="s0">reset: </span><span class="s1">this</span><span class="s0">.reset</span>
                    <span class="s0">})</span>
                <span class="s0">]</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s1">return this</span><span class="s0">.props.children;</span>
    <span class="s0">}</span>
    <span class="s0">constructor(props){</span>
        <span class="s1">super</span><span class="s0">(props), </span><span class="s1">this</span><span class="s0">.reset = ()=&gt;{</span>
            <span class="s1">this</span><span class="s0">.setState({</span>
                <span class="s0">error: </span><span class="s1">null</span>
            <span class="s0">});</span>
        <span class="s0">};</span>
        <span class="s1">this</span><span class="s0">.state = {</span>
            <span class="s0">error: </span><span class="s1">null</span><span class="s0">,</span>
            <span class="s0">previousPathname: </span><span class="s1">this</span><span class="s0">.props.pathname</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">ErrorBoundary(param) {</span>
    <span class="s1">let </span><span class="s0">{ errorComponent, errorStyles, errorScripts, children } = param;</span>
    <span class="s3">// When we're rendering the missing params shell, this will return null. This</span>
    <span class="s3">// is because we won't be rendering any not found boundaries or error</span>
    <span class="s3">// boundaries for the missing params shell. When this runs on the client</span>
    <span class="s3">// (where these errors can occur), we will get the correct pathname.</span>
    <span class="s1">const </span><span class="s0">pathname = (</span><span class="s4">0</span><span class="s0">, _navigationuntracked.useUntrackedPathname)();</span>
    <span class="s1">if </span><span class="s0">(errorComponent) {</span>
        <span class="s1">return </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(ErrorBoundaryHandler, {</span>
            <span class="s0">pathname: pathname,</span>
            <span class="s0">errorComponent: errorComponent,</span>
            <span class="s0">errorStyles: errorStyles,</span>
            <span class="s0">errorScripts: errorScripts,</span>
            <span class="s0">children: children</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(_jsxruntime.Fragment, {</span>
        <span class="s0">children: children</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=error-boundary.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/builtin/global-error.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s3">// supplied custom global error signatures.</span>
<span class="s2">&quot;default&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">_default;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_jsxruntime = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_handleisrerror = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/handle-isr-error.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">styles = {</span>
    <span class="s0">error: {</span>
        <span class="s3">// https://github.com/sindresorhus/modern-normalize/blob/main/modern-normalize.css#L38-L52</span>
        <span class="s0">fontFamily: </span><span class="s2">'system-ui,&quot;Segoe UI&quot;,Roboto,Helvetica,Arial,sans-serif,&quot;Apple Color Emoji&quot;,&quot;Segoe UI Emoji&quot;'</span><span class="s0">,</span>
        <span class="s0">height: </span><span class="s2">'100vh'</span><span class="s0">,</span>
        <span class="s0">textAlign: </span><span class="s2">'center'</span><span class="s0">,</span>
        <span class="s0">display: </span><span class="s2">'flex'</span><span class="s0">,</span>
        <span class="s0">flexDirection: </span><span class="s2">'column'</span><span class="s0">,</span>
        <span class="s0">alignItems: </span><span class="s2">'center'</span><span class="s0">,</span>
        <span class="s0">justifyContent: </span><span class="s2">'center'</span>
    <span class="s0">},</span>
    <span class="s0">text: {</span>
        <span class="s0">fontSize: </span><span class="s2">'14px'</span><span class="s0">,</span>
        <span class="s0">fontWeight: </span><span class="s4">400</span><span class="s0">,</span>
        <span class="s0">lineHeight: </span><span class="s2">'28px'</span><span class="s0">,</span>
        <span class="s0">margin: </span><span class="s2">'0 8px'</span>
    <span class="s0">}</span>
<span class="s0">};</span>
<span class="s1">function </span><span class="s0">DefaultGlobalError(param) {</span>
    <span class="s1">let </span><span class="s0">{ error } = param;</span>
    <span class="s1">const </span><span class="s0">digest = error == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: error.digest;</span>
    <span class="s1">return </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsxs)(</span><span class="s2">&quot;html&quot;</span><span class="s0">, {</span>
        <span class="s0">id: </span><span class="s2">&quot;__next_error__&quot;</span><span class="s0">,</span>
        <span class="s0">children: [</span>
            <span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(</span><span class="s2">&quot;head&quot;</span><span class="s0">, {}),</span>
            <span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsxs)(</span><span class="s2">&quot;body&quot;</span><span class="s0">, {</span>
                <span class="s0">children: [</span>
                    <span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(_handleisrerror.HandleISRError, {</span>
                        <span class="s0">error: error</span>
                    <span class="s0">}),</span>
                    <span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(</span><span class="s2">&quot;div&quot;</span><span class="s0">, {</span>
                        <span class="s0">style: styles.error,</span>
                        <span class="s0">children: </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsxs)(</span><span class="s2">&quot;div&quot;</span><span class="s0">, {</span>
                            <span class="s0">children: [</span>
                                <span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsxs)(</span><span class="s2">&quot;h2&quot;</span><span class="s0">, {</span>
                                    <span class="s0">style: styles.text,</span>
                                    <span class="s0">children: [</span>
                                        <span class="s2">&quot;Application error: a &quot;</span><span class="s0">,</span>
                                        <span class="s0">digest ? </span><span class="s2">'server' </span><span class="s0">: </span><span class="s2">'client'</span><span class="s0">,</span>
                                        <span class="s2">&quot;-side exception has occurred while loading &quot;</span><span class="s0">,</span>
                                        <span class="s0">window.location.hostname,</span>
                                        <span class="s2">&quot; (see the&quot;</span><span class="s0">,</span>
                                        <span class="s2">' '</span><span class="s0">,</span>
                                        <span class="s0">digest ? </span><span class="s2">'server logs' </span><span class="s0">: </span><span class="s2">'browser console'</span><span class="s0">,</span>
                                        <span class="s2">&quot; for more information).&quot;</span>
                                    <span class="s0">]</span>
                                <span class="s0">}),</span>
                                <span class="s0">digest ? </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(</span><span class="s2">&quot;p&quot;</span><span class="s0">, {</span>
                                    <span class="s0">style: styles.text,</span>
                                    <span class="s0">children: </span><span class="s2">&quot;Digest: &quot; </span><span class="s0">+ digest</span>
                                <span class="s0">}) : </span><span class="s1">null</span>
                            <span class="s0">]</span>
                        <span class="s0">})</span>
                    <span class="s0">})</span>
                <span class="s0">]</span>
            <span class="s0">})</span>
        <span class="s0">]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s1">const </span><span class="s0">_default = DefaultGlobalError;</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=global-error.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/dev/runtime-error-handler.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;RuntimeErrorHandler&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">RuntimeErrorHandler;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">RuntimeErrorHandler = {</span>
    <span class="s0">hadRuntimeError: </span><span class="s1">false</span>
<span class="s0">};</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=runtime-error-handler.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/not-found.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;notFound&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">notFound;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_httpaccessfallback = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s3">/**</span>
 <span class="s3">* This function allows you to render the [not-found.js file](https://nextjs.org/docs/app/api-reference/file-conventions/not-found)</span>
 <span class="s3">* within a route segment as well as inject a tag.</span>
 <span class="s3">*</span>
 <span class="s3">* `notFound()` can be used in</span>
 <span class="s3">* [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),</span>
 <span class="s3">* [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and</span>
 <span class="s3">* [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).</span>
 <span class="s3">*</span>
 <span class="s3">* - In a Server Component, this will insert a `&lt;meta name=&quot;robots&quot; content=&quot;noindex&quot; /&gt;` meta tag and set the status code to 404.</span>
 <span class="s3">* - In a Route Handler or Server Action, it will serve a 404 to the caller.</span>
 <span class="s3">*</span>
 <span class="s3">* Read more: [Next.js Docs: `notFound`](https://nextjs.org/docs/app/api-reference/functions/not-found)</span>
 <span class="s3">*/ </span><span class="s1">const </span><span class="s0">DIGEST = </span><span class="s2">&quot;&quot; </span><span class="s0">+ _httpaccessfallback.HTTP_ERROR_FALLBACK_ERROR_CODE + </span><span class="s2">&quot;;404&quot;</span><span class="s0">;</span>
<span class="s1">function </span><span class="s0">notFound() {</span>
    <span class="s3">// eslint-disable-next-line no-throw-literal</span>
    <span class="s1">const </span><span class="s0">error = Object.defineProperty(</span><span class="s1">new </span><span class="s0">Error(DIGEST), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s2">&quot;E394&quot;</span><span class="s0">,</span>
        <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">configurable: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">error.digest = DIGEST;</span>
    <span class="s1">throw </span><span class="s0">error;</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=not-found.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/react-client-callbacks/error-boundary-callbacks.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s3">// This file is only used in app router due to the specific error state handling.</span>
<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s0">onCaughtError: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">onUncaughtError: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s0">onCaughtError: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">onCaughtError;</span>
    <span class="s0">},</span>
    <span class="s0">onUncaughtError: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">onUncaughtError;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_interop_require_default = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_isnextroutererror = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/is-next-router-error.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_bailouttocsr = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_reportglobalerror = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/react-client-callbacks/report-global-error.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_errorboundary = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/error-boundary.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_globalerror = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">_interop_require_default._(__turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/builtin/global-error.js [app-client] (ecmascript)&quot;</span><span class="s0">));</span>
<span class="s1">const </span><span class="s0">devToolErrorMod = (</span><span class="s2">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s0">) ? __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/next-devtools/userspace/app/errors/index.js [app-client] (ecmascript)&quot;</span><span class="s0">) : </span><span class="s2">&quot;TURBOPACK unreachable&quot;</span><span class="s0">;</span>
<span class="s1">function </span><span class="s0">onCaughtError(thrownValue, errorInfo) {</span>
    <span class="s1">var </span><span class="s0">_errorInfo_errorBoundary;</span>
    <span class="s1">const </span><span class="s0">errorBoundaryComponent = (_errorInfo_errorBoundary = errorInfo.errorBoundary) == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: _errorInfo_errorBoundary.constructor;</span>
    <span class="s1">let </span><span class="s0">isImplicitErrorBoundary;</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s0">) {</span>
        <span class="s1">const </span><span class="s0">{ AppDevOverlayErrorBoundary } = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/next-devtools/userspace/app/app-dev-overlay-error-boundary.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
        <span class="s0">isImplicitErrorBoundary = errorBoundaryComponent === AppDevOverlayErrorBoundary;</span>
    <span class="s0">}</span>
    <span class="s0">isImplicitErrorBoundary = isImplicitErrorBoundary || errorBoundaryComponent === _errorboundary.ErrorBoundaryHandler &amp;&amp; errorInfo.errorBoundary.props.errorComponent === _globalerror.default;</span>
    <span class="s3">// Skip the segment explorer triggered error</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s0">) {</span>
        <span class="s1">const </span><span class="s0">{ SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE } = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/next-devtools/userspace/app/segment-explorer-node.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
        <span class="s1">if </span><span class="s0">(thrownValue </span><span class="s1">instanceof </span><span class="s0">Error &amp;&amp; thrownValue.message === SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE) {</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(isImplicitErrorBoundary) {</span>
        <span class="s3">// We don't consider errors caught unless they're caught by an explicit error</span>
        <span class="s3">// boundary. The built-in ones are considered implicit.</span>
        <span class="s3">// This mimics how the same app would behave without Next.js.</span>
        <span class="s1">return </span><span class="s0">onUncaughtError(thrownValue);</span>
    <span class="s0">}</span>
    <span class="s3">// Skip certain custom errors which are not expected to be reported on client</span>
    <span class="s1">if </span><span class="s0">((</span><span class="s4">0</span><span class="s0">, _bailouttocsr.isBailoutToCSRError)(thrownValue) || (</span><span class="s4">0</span><span class="s0">, _isnextroutererror.isNextRouterError)(thrownValue)) </span><span class="s1">return</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s0">) {</span>
        <span class="s1">var </span><span class="s0">_errorInfo_componentStack;</span>
        <span class="s1">const </span><span class="s0">errorBoundaryName = (errorBoundaryComponent == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: errorBoundaryComponent.displayName) || (errorBoundaryComponent == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: errorBoundaryComponent.name) || </span><span class="s2">'Unknown'</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">componentThatErroredFrame = errorInfo == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: (_errorInfo_componentStack = errorInfo.componentStack) == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: _errorInfo_componentStack.split(</span><span class="s2">'</span><span class="s6">\n</span><span class="s2">'</span><span class="s0">)[</span><span class="s4">1</span><span class="s0">];</span>
        <span class="s1">var </span><span class="s3">// example 1: at Page (http://localhost:3000/_next/static/chunks/pages/index.js?ts=1631600000000:2:1)</span>
        <span class="s3">// example 2: Page@http://localhost:3000/_next/static/chunks/pages/index.js?ts=1631600000000:2:1</span>
        <span class="s0">_componentThatErroredFrame_match;</span>
        <span class="s3">// Match chrome or safari stack trace</span>
        <span class="s1">const </span><span class="s0">matches = (_componentThatErroredFrame_match = componentThatErroredFrame == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: componentThatErroredFrame.match(</span><span class="s7">/\s+at (\w+)\s+|(\w+)@/</span><span class="s0">)) != </span><span class="s1">null </span><span class="s0">? _componentThatErroredFrame_match : [];</span>
        <span class="s1">const </span><span class="s0">componentThatErroredName = matches[</span><span class="s4">1</span><span class="s0">] || matches[</span><span class="s4">2</span><span class="s0">] || </span><span class="s2">'Unknown'</span><span class="s0">;</span>
        <span class="s3">// Create error location with errored component and error boundary, to match the behavior of default React onCaughtError handler.</span>
        <span class="s1">const </span><span class="s0">errorBoundaryMessage = </span><span class="s2">&quot;It was handled by the &lt;&quot; </span><span class="s0">+ errorBoundaryName + </span><span class="s2">&quot;&gt; error boundary.&quot;</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">componentErrorMessage = (</span><span class="s2">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s0">) ? </span><span class="s2">&quot;The above error occurred in the &lt;&quot; </span><span class="s0">+ componentThatErroredName + </span><span class="s2">&quot;&gt; component.&quot; </span><span class="s0">: </span><span class="s2">&quot;TURBOPACK unreachable&quot;</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">errorLocation = componentErrorMessage + </span><span class="s2">&quot; &quot; </span><span class="s0">+ errorBoundaryMessage;</span>
        <span class="s1">const </span><span class="s0">error = devToolErrorMod.decorateDevError(thrownValue);</span>
        <span class="s3">// Log and report the error with location but without modifying the error stack</span>
        <span class="s0">devToolErrorMod.originConsoleError(</span><span class="s2">'%o</span><span class="s6">\n\n</span><span class="s2">%s'</span><span class="s0">, thrownValue, errorLocation);</span>
        <span class="s0">devToolErrorMod.handleClientError(error);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s3">//TURBOPACK unreachable</span>
    <span class="s0">;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">onUncaughtError(thrownValue) {</span>
    <span class="s3">// Skip certain custom errors which are not expected to be reported on client</span>
    <span class="s1">if </span><span class="s0">((</span><span class="s4">0</span><span class="s0">, _bailouttocsr.isBailoutToCSRError)(thrownValue) || (</span><span class="s4">0</span><span class="s0">, _isnextroutererror.isNextRouterError)(thrownValue)) </span><span class="s1">return</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s0">) {</span>
        <span class="s1">const </span><span class="s0">error = devToolErrorMod.decorateDevError(thrownValue);</span>
        <span class="s3">// TODO: Add an adendum to the overlay telling people about custom error boundaries.</span>
        <span class="s0">(</span><span class="s4">0</span><span class="s0">, _reportglobalerror.reportGlobalError)(error);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s3">//TURBOPACK unreachable</span>
    <span class="s0">;</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=error-boundary-callbacks.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s0">ACTION_HMR_REFRESH: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">ACTION_NAVIGATE: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">ACTION_PREFETCH: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">ACTION_REFRESH: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">ACTION_RESTORE: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">ACTION_SERVER_ACTION: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">ACTION_SERVER_PATCH: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">PrefetchCacheEntryStatus: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">PrefetchKind: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s0">ACTION_HMR_REFRESH: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">ACTION_HMR_REFRESH;</span>
    <span class="s0">},</span>
    <span class="s0">ACTION_NAVIGATE: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">ACTION_NAVIGATE;</span>
    <span class="s0">},</span>
    <span class="s0">ACTION_PREFETCH: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">ACTION_PREFETCH;</span>
    <span class="s0">},</span>
    <span class="s0">ACTION_REFRESH: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">ACTION_REFRESH;</span>
    <span class="s0">},</span>
    <span class="s0">ACTION_RESTORE: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">ACTION_RESTORE;</span>
    <span class="s0">},</span>
    <span class="s0">ACTION_SERVER_ACTION: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">ACTION_SERVER_ACTION;</span>
    <span class="s0">},</span>
    <span class="s0">ACTION_SERVER_PATCH: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">ACTION_SERVER_PATCH;</span>
    <span class="s0">},</span>
    <span class="s0">PrefetchCacheEntryStatus: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">PrefetchCacheEntryStatus;</span>
    <span class="s0">},</span>
    <span class="s0">PrefetchKind: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">PrefetchKind;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">ACTION_REFRESH = </span><span class="s2">'refresh'</span><span class="s0">;</span>
<span class="s1">const </span><span class="s0">ACTION_NAVIGATE = </span><span class="s2">'navigate'</span><span class="s0">;</span>
<span class="s1">const </span><span class="s0">ACTION_RESTORE = </span><span class="s2">'restore'</span><span class="s0">;</span>
<span class="s1">const </span><span class="s0">ACTION_SERVER_PATCH = </span><span class="s2">'server-patch'</span><span class="s0">;</span>
<span class="s1">const </span><span class="s0">ACTION_PREFETCH = </span><span class="s2">'prefetch'</span><span class="s0">;</span>
<span class="s1">const </span><span class="s0">ACTION_HMR_REFRESH = </span><span class="s2">'hmr-refresh'</span><span class="s0">;</span>
<span class="s1">const </span><span class="s0">ACTION_SERVER_ACTION = </span><span class="s2">'server-action'</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">PrefetchKind = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">function</span><span class="s0">(PrefetchKind) {</span>
    <span class="s0">PrefetchKind[</span><span class="s2">&quot;AUTO&quot;</span><span class="s0">] = </span><span class="s2">&quot;auto&quot;</span><span class="s0">;</span>
    <span class="s0">PrefetchKind[</span><span class="s2">&quot;FULL&quot;</span><span class="s0">] = </span><span class="s2">&quot;full&quot;</span><span class="s0">;</span>
    <span class="s0">PrefetchKind[</span><span class="s2">&quot;TEMPORARY&quot;</span><span class="s0">] = </span><span class="s2">&quot;temporary&quot;</span><span class="s0">;</span>
    <span class="s1">return </span><span class="s0">PrefetchKind;</span>
<span class="s0">}({});</span>
<span class="s1">var </span><span class="s0">PrefetchCacheEntryStatus = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">function</span><span class="s0">(PrefetchCacheEntryStatus) {</span>
    <span class="s0">PrefetchCacheEntryStatus[</span><span class="s2">&quot;fresh&quot;</span><span class="s0">] = </span><span class="s2">&quot;fresh&quot;</span><span class="s0">;</span>
    <span class="s0">PrefetchCacheEntryStatus[</span><span class="s2">&quot;reusable&quot;</span><span class="s0">] = </span><span class="s2">&quot;reusable&quot;</span><span class="s0">;</span>
    <span class="s0">PrefetchCacheEntryStatus[</span><span class="s2">&quot;expired&quot;</span><span class="s0">] = </span><span class="s2">&quot;expired&quot;</span><span class="s0">;</span>
    <span class="s0">PrefetchCacheEntryStatus[</span><span class="s2">&quot;stale&quot;</span><span class="s0">] = </span><span class="s2">&quot;stale&quot;</span><span class="s0">;</span>
    <span class="s1">return </span><span class="s0">PrefetchCacheEntryStatus;</span>
<span class="s0">}({});</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=router-reducer-types.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/use-action-queue.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s0">dispatchAppRouterAction: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">useActionQueue: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s0">dispatchAppRouterAction: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">dispatchAppRouterAction;</span>
    <span class="s0">},</span>
    <span class="s0">useActionQueue: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">useActionQueue;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_interop_require_wildcard = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_react = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">_interop_require_wildcard._(__turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)&quot;</span><span class="s0">));</span>
<span class="s1">const </span><span class="s0">_isthenable = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/is-thenable.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s3">// The app router state lives outside of React, so we can import the dispatch</span>
<span class="s3">// method directly wherever we need it, rather than passing it around via props</span>
<span class="s3">// or context.</span>
<span class="s1">let </span><span class="s0">dispatch = </span><span class="s1">null</span><span class="s0">;</span>
<span class="s1">function </span><span class="s0">dispatchAppRouterAction(action) {</span>
    <span class="s1">if </span><span class="s0">(dispatch === </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s1">throw </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">Error(</span><span class="s2">'Internal Next.js error: Router action dispatched before initialization.'</span><span class="s0">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
            <span class="s0">value: </span><span class="s2">&quot;E668&quot;</span><span class="s0">,</span>
            <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">configurable: </span><span class="s1">true</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s0">dispatch(action);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">useActionQueue(actionQueue) {</span>
    <span class="s1">const </span><span class="s0">[state, setState] = _react.default.useState(actionQueue.state);</span>
    <span class="s3">// Because of a known issue that requires to decode Flight streams inside the</span>
    <span class="s3">// render phase, we have to be a bit clever and assign the dispatch method to</span>
    <span class="s3">// a module-level variable upon initialization. The useState hook in this</span>
    <span class="s3">// module only exists to synchronize state that lives outside of React.</span>
    <span class="s3">// Ideally, what we'd do instead is pass the state as a prop to root.render;</span>
    <span class="s3">// this is conceptually how we're modeling the app router state, despite the</span>
    <span class="s3">// weird implementation details.</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s0">) {</span>
        <span class="s1">const </span><span class="s0">{ useAppDevRenderingIndicator } = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/next-devtools/userspace/use-app-dev-rendering-indicator.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
        <span class="s3">// eslint-disable-next-line react-hooks/rules-of-hooks</span>
        <span class="s1">const </span><span class="s0">appDevRenderingIndicator = useAppDevRenderingIndicator();</span>
        <span class="s0">dispatch = (action)=&gt;{</span>
            <span class="s0">appDevRenderingIndicator(()=&gt;{</span>
                <span class="s0">actionQueue.dispatch(action, setState);</span>
            <span class="s0">});</span>
        <span class="s0">};</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s3">//TURBOPACK unreachable</span>
    <span class="s0">;</span>
    <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _isthenable.isThenable)(state) ? (</span><span class="s4">0</span><span class="s0">, _react.use)(state) : state;</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=use-action-queue.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/app-call-server.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;callServer&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">callServer;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_react = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_routerreducertypes = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_useactionqueue = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/use-action-queue.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s0">async </span><span class="s1">function </span><span class="s0">callServer(actionId, actionArgs) {</span>
    <span class="s1">return new </span><span class="s0">Promise((resolve, reject)=&gt;{</span>
        <span class="s0">(</span><span class="s4">0</span><span class="s0">, _react.startTransition)(()=&gt;{</span>
            <span class="s0">(</span><span class="s4">0</span><span class="s0">, _useactionqueue.dispatchAppRouterAction)({</span>
                <span class="s0">type: _routerreducertypes.ACTION_SERVER_ACTION,</span>
                <span class="s0">actionId,</span>
                <span class="s0">actionArgs,</span>
                <span class="s0">resolve,</span>
                <span class="s0">reject</span>
            <span class="s0">});</span>
        <span class="s0">});</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=app-call-server.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/app-find-source-map-url.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;findSourceMapURL&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">findSourceMapURL;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">basePath = (</span><span class="s2">&quot;TURBOPACK compile-time value&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s0">) || </span><span class="s2">''</span><span class="s0">;</span>
<span class="s1">const </span><span class="s0">pathname = </span><span class="s2">&quot;&quot; </span><span class="s0">+ basePath + </span><span class="s2">&quot;/__nextjs_source-map&quot;</span><span class="s0">;</span>
<span class="s1">const </span><span class="s0">findSourceMapURL = (</span><span class="s2">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s0">) ? </span><span class="s1">function </span><span class="s0">findSourceMapURL(filename) {</span>
    <span class="s1">if </span><span class="s0">(filename === </span><span class="s2">''</span><span class="s0">) {</span>
        <span class="s1">return null</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(filename.startsWith(document.location.origin) &amp;&amp; filename.includes(</span><span class="s2">'/_next/static'</span><span class="s0">)) {</span>
        <span class="s3">// This is a request for a client chunk. This can only happen when</span>
        <span class="s3">// using Turbopack. In this case, since we control how those source</span>
        <span class="s3">// maps are generated, we can safely assume that the sourceMappingURL</span>
        <span class="s3">// is relative to the filename, with an added `.map` extension. The</span>
        <span class="s3">// browser can just request this file, and it gets served through the</span>
        <span class="s3">// normal dev server, without the need to route this through</span>
        <span class="s3">// the `/__nextjs_source-map` dev middleware.</span>
        <span class="s1">return </span><span class="s2">&quot;&quot; </span><span class="s0">+ filename + </span><span class="s2">&quot;.map&quot;</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">url = </span><span class="s1">new </span><span class="s0">URL(pathname, document.location.origin);</span>
    <span class="s0">url.searchParams.set(</span><span class="s2">'filename'</span><span class="s0">, filename);</span>
    <span class="s1">return </span><span class="s0">url.href;</span>
<span class="s0">} : </span><span class="s2">&quot;TURBOPACK unreachable&quot;</span><span class="s0">;</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=app-find-source-map-url.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/flight-data-helpers.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s0">getFlightDataPartsFromPath: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">getNextFlightSegmentPath: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">normalizeFlightData: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">prepareFlightRouterStateForRequest: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s0">getFlightDataPartsFromPath: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">getFlightDataPartsFromPath;</span>
    <span class="s0">},</span>
    <span class="s0">getNextFlightSegmentPath: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">getNextFlightSegmentPath;</span>
    <span class="s0">},</span>
    <span class="s0">normalizeFlightData: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">normalizeFlightData;</span>
    <span class="s0">},</span>
    <span class="s0">prepareFlightRouterStateForRequest: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">prepareFlightRouterStateForRequest;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_segment = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/segment.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">getFlightDataPartsFromPath(flightDataPath) {</span>
    <span class="s3">// Pick the last 4 items from the `FlightDataPath` to get the [tree, seedData, viewport, isHeadPartial].</span>
    <span class="s1">const </span><span class="s0">flightDataPathLength = </span><span class="s4">4</span><span class="s0">;</span>
    <span class="s3">// tree, seedData, and head are *always* the last three items in the `FlightDataPath`.</span>
    <span class="s1">const </span><span class="s0">[tree, seedData, head, isHeadPartial] = flightDataPath.slice(-flightDataPathLength);</span>
    <span class="s3">// The `FlightSegmentPath` is everything except the last three items. For a root render, it won't be present.</span>
    <span class="s1">const </span><span class="s0">segmentPath = flightDataPath.slice(</span><span class="s4">0</span><span class="s0">, -flightDataPathLength);</span>
    <span class="s1">var </span><span class="s0">_segmentPath_;</span>
    <span class="s1">return </span><span class="s0">{</span>
        <span class="s3">// TODO: Unify these two segment path helpers. We are inconsistently pushing an empty segment (&quot;&quot;)</span>
        <span class="s3">// to the start of the segment path in some places which makes it hard to use solely the segment path.</span>
        <span class="s3">// Look for &quot;// TODO-APP: remove ''&quot; in the codebase.</span>
        <span class="s0">pathToSegment: segmentPath.slice(</span><span class="s4">0</span><span class="s0">, -</span><span class="s4">1</span><span class="s0">),</span>
        <span class="s0">segmentPath,</span>
        <span class="s3">// if the `FlightDataPath` corresponds with the root, there'll be no segment path,</span>
        <span class="s3">// in which case we default to ''.</span>
        <span class="s0">segment: (_segmentPath_ = segmentPath[segmentPath.length - </span><span class="s4">1</span><span class="s0">]) != </span><span class="s1">null </span><span class="s0">? _segmentPath_ : </span><span class="s2">''</span><span class="s0">,</span>
        <span class="s0">tree,</span>
        <span class="s0">seedData,</span>
        <span class="s0">head,</span>
        <span class="s0">isHeadPartial,</span>
        <span class="s0">isRootRender: flightDataPath.length === flightDataPathLength</span>
    <span class="s0">};</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">getNextFlightSegmentPath(flightSegmentPath) {</span>
    <span class="s3">// Since `FlightSegmentPath` is a repeated tuple of `Segment` and `ParallelRouteKey`, we slice off two items</span>
    <span class="s3">// to get the next segment path.</span>
    <span class="s1">return </span><span class="s0">flightSegmentPath.slice(</span><span class="s4">2</span><span class="s0">);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">normalizeFlightData(flightData) {</span>
    <span class="s3">// FlightData can be a string when the server didn't respond with a proper flight response,</span>
    <span class="s3">// or when a redirect happens, to signal to the client that it needs to perform an MPA navigation.</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">flightData === </span><span class="s2">'string'</span><span class="s0">) {</span>
        <span class="s1">return </span><span class="s0">flightData;</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">flightData.map((flightDataPath)=&gt;getFlightDataPartsFromPath(flightDataPath));</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">prepareFlightRouterStateForRequest(flightRouterState, isHmrRefresh) {</span>
    <span class="s3">// HMR requests need the complete, unmodified state for proper functionality</span>
    <span class="s1">if </span><span class="s0">(isHmrRefresh) {</span>
        <span class="s1">return </span><span class="s0">encodeURIComponent(JSON.stringify(flightRouterState));</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">encodeURIComponent(JSON.stringify(stripClientOnlyDataFromFlightRouterState(flightRouterState)));</span>
<span class="s0">}</span>
<span class="s3">/**</span>
 <span class="s3">* Recursively strips client-only data from FlightRouterState while preserving</span>
 <span class="s3">* server-needed information for proper rendering decisions.</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">stripClientOnlyDataFromFlightRouterState(flightRouterState) {</span>
    <span class="s1">const </span><span class="s0">[segment, parallelRoutes, _url, refreshMarker, isRootLayout, hasLoadingBoundary] = flightRouterState;</span>
    <span class="s3">// __PAGE__ segments are always fetched from the server, so there's</span>
    <span class="s3">// no need to send them up</span>
    <span class="s1">const </span><span class="s0">cleanedSegment = stripSearchParamsFromPageSegment(segment);</span>
    <span class="s3">// Recursively process parallel routes</span>
    <span class="s1">const </span><span class="s0">cleanedParallelRoutes = {};</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">[key, childState] of Object.entries(parallelRoutes)){</span>
        <span class="s0">cleanedParallelRoutes[key] = stripClientOnlyDataFromFlightRouterState(childState);</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">result = [</span>
        <span class="s0">cleanedSegment,</span>
        <span class="s0">cleanedParallelRoutes,</span>
        <span class="s1">null</span><span class="s0">,</span>
        <span class="s0">shouldPreserveRefreshMarker(refreshMarker) ? refreshMarker : </span><span class="s1">null</span>
    <span class="s0">];</span>
    <span class="s3">// Append optional fields if present</span>
    <span class="s1">if </span><span class="s0">(isRootLayout !== undefined) {</span>
        <span class="s0">result[</span><span class="s4">4</span><span class="s0">] = isRootLayout;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(hasLoadingBoundary !== undefined) {</span>
        <span class="s0">result[</span><span class="s4">5</span><span class="s0">] = hasLoadingBoundary;</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">result;</span>
<span class="s0">}</span>
<span class="s3">/**</span>
 <span class="s3">* Strips search parameters from __PAGE__ segments to prevent sensitive</span>
 <span class="s3">* client-side data from being sent to the server.</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">stripSearchParamsFromPageSegment(segment) {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">segment === </span><span class="s2">'string' </span><span class="s0">&amp;&amp; segment.startsWith(_segment.PAGE_SEGMENT_KEY + </span><span class="s2">'?'</span><span class="s0">)) {</span>
        <span class="s1">return </span><span class="s0">_segment.PAGE_SEGMENT_KEY;</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">segment;</span>
<span class="s0">}</span>
<span class="s3">/**</span>
 <span class="s3">* Determines whether the refresh marker should be sent to the server</span>
 <span class="s3">* Client-only markers like 'refresh' are stripped, while server-needed markers</span>
 <span class="s3">* like 'refetch' and 'inside-shared-layout' are preserved.</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">shouldPreserveRefreshMarker(refreshMarker) {</span>
    <span class="s1">return </span><span class="s0">Boolean(refreshMarker &amp;&amp; refreshMarker !== </span><span class="s2">'refresh'</span><span class="s0">);</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=flight-data-helpers.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/app-build-id.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s3">// This gets assigned as a side-effect during app initialization. Because it</span>
<span class="s3">// represents the build used to create the JS bundle, it should never change</span>
<span class="s3">// after being set, so we store it in a global variable.</span>
<span class="s3">//</span>
<span class="s3">// When performing RSC requests, if the incoming data has a different build ID,</span>
<span class="s3">// we perform an MPA navigation/refresh to load the updated build and ensure</span>
<span class="s3">// that the client and server in sync.</span>
<span class="s3">// Starts as an empty string. In practice, because setAppBuildId is called</span>
<span class="s3">// during initialization before hydration starts, this will always get</span>
<span class="s3">// reassigned to the actual build ID before it's ever needed by a navigation.</span>
<span class="s3">// If for some reasons it didn't, due to a bug or race condition, then on</span>
<span class="s3">// navigation the build comparision would fail and trigger an MPA navigation.</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s0">getAppBuildId: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">setAppBuildId: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s0">getAppBuildId: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">getAppBuildId;</span>
    <span class="s0">},</span>
    <span class="s0">setAppBuildId: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">setAppBuildId;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">let </span><span class="s0">globalBuildId = </span><span class="s2">''</span><span class="s0">;</span>
<span class="s1">function </span><span class="s0">setAppBuildId(buildId) {</span>
    <span class="s0">globalBuildId = buildId;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">getAppBuildId() {</span>
    <span class="s1">return </span><span class="s0">globalBuildId;</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=app-build-id.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/set-cache-busting-search-param.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s0">setCacheBustingSearchParam: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">setCacheBustingSearchParamWithHash: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s0">setCacheBustingSearchParam: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">setCacheBustingSearchParam;</span>
    <span class="s0">},</span>
    <span class="s0">setCacheBustingSearchParamWithHash: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">setCacheBustingSearchParamWithHash;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_cachebustingsearchparam = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/router/utils/cache-busting-search-param.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_approuterheaders = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/app-router-headers.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">setCacheBustingSearchParam = (url, headers)=&gt;{</span>
    <span class="s1">const </span><span class="s0">uniqueCacheKey = (</span><span class="s4">0</span><span class="s0">, _cachebustingsearchparam.computeCacheBustingSearchParam)(headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER], headers[_approuterheaders.NEXT_ROUTER_SEGMENT_PREFETCH_HEADER], headers[_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER], headers[_approuterheaders.NEXT_URL]);</span>
    <span class="s0">setCacheBustingSearchParamWithHash(url, uniqueCacheKey);</span>
<span class="s0">};</span>
<span class="s1">const </span><span class="s0">setCacheBustingSearchParamWithHash = (url, hash)=&gt;{</span>
    <span class="s3">/**</span>
   <span class="s3">* Note that we intentionally do not use `url.searchParams.set` here:</span>
   <span class="s3">*</span>
   <span class="s3">* const url = new URL('https://example.com/search?q=custom%20spacing');</span>
   <span class="s3">* url.searchParams.set('_rsc', 'abc123');</span>
   <span class="s3">* console.log(url.toString()); // Outputs: https://example.com/search?q=custom+spacing&amp;_rsc=abc123</span>
   <span class="s3">*                                                                             ^ &lt;--- this is causing confusion</span>
   <span class="s3">* This is in fact intended based on https://url.spec.whatwg.org/#interface-urlsearchparams, but</span>
   <span class="s3">* we want to preserve the %20 as %20 if that's what the user passed in, hence the custom</span>
   <span class="s3">* logic below.</span>
   <span class="s3">*/ </span><span class="s1">const </span><span class="s0">existingSearch = url.search;</span>
    <span class="s1">const </span><span class="s0">rawQuery = existingSearch.startsWith(</span><span class="s2">'?'</span><span class="s0">) ? existingSearch.slice(</span><span class="s4">1</span><span class="s0">) : existingSearch;</span>
    <span class="s3">// Always remove any existing cache busting param and add a fresh one to ensure</span>
    <span class="s3">// we have the correct value based on current request headers</span>
    <span class="s1">const </span><span class="s0">pairs = rawQuery.split(</span><span class="s2">'&amp;'</span><span class="s0">).filter((pair)=&gt;pair &amp;&amp; !pair.startsWith(</span><span class="s2">&quot;&quot; </span><span class="s0">+ _approuterheaders.NEXT_RSC_UNION_QUERY + </span><span class="s2">&quot;=&quot;</span><span class="s0">));</span>
    <span class="s1">if </span><span class="s0">(hash.length &gt; </span><span class="s4">0</span><span class="s0">) {</span>
        <span class="s0">pairs.push(_approuterheaders.NEXT_RSC_UNION_QUERY + </span><span class="s2">&quot;=&quot; </span><span class="s0">+ hash);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">pairs.push(</span><span class="s2">&quot;&quot; </span><span class="s0">+ _approuterheaders.NEXT_RSC_UNION_QUERY);</span>
    <span class="s0">}</span>
    <span class="s0">url.search = pairs.length ? </span><span class="s2">&quot;?&quot; </span><span class="s0">+ pairs.join(</span><span class="s2">'&amp;'</span><span class="s0">) : </span><span class="s2">''</span><span class="s0">;</span>
<span class="s0">};</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=set-cache-busting-search-param.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/route-params.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s0">doesStaticSegmentAppearInURL: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">getCacheKeyForDynamicParam: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">getParamValueFromCacheKey: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">getRenderedPathname: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">getRenderedSearch: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">parseDynamicParamFromURLPart: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">urlToUrlWithoutFlightMarker: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s0">doesStaticSegmentAppearInURL: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">doesStaticSegmentAppearInURL;</span>
    <span class="s0">},</span>
    <span class="s0">getCacheKeyForDynamicParam: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">getCacheKeyForDynamicParam;</span>
    <span class="s0">},</span>
    <span class="s0">getParamValueFromCacheKey: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">getParamValueFromCacheKey;</span>
    <span class="s0">},</span>
    <span class="s0">getRenderedPathname: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">getRenderedPathname;</span>
    <span class="s0">},</span>
    <span class="s0">getRenderedSearch: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">getRenderedSearch;</span>
    <span class="s0">},</span>
    <span class="s0">parseDynamicParamFromURLPart: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">parseDynamicParamFromURLPart;</span>
    <span class="s0">},</span>
    <span class="s0">urlToUrlWithoutFlightMarker: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">urlToUrlWithoutFlightMarker;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_segment = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/segment.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_segmentvalueencoding = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/segment-cache/segment-value-encoding.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_approuterheaders = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/app-router-headers.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">getRenderedSearch(response) {</span>
    <span class="s3">// If the server performed a rewrite, the search params used to render the</span>
    <span class="s3">// page will be different from the params in the request URL. In this case,</span>
    <span class="s3">// the response will include a header that gives the rewritten search query.</span>
    <span class="s1">const </span><span class="s0">rewrittenQuery = response.headers.get(_approuterheaders.NEXT_REWRITTEN_QUERY_HEADER);</span>
    <span class="s1">if </span><span class="s0">(rewrittenQuery !== </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s1">return </span><span class="s0">rewrittenQuery === </span><span class="s2">'' </span><span class="s0">? </span><span class="s2">'' </span><span class="s0">: </span><span class="s2">'?' </span><span class="s0">+ rewrittenQuery;</span>
    <span class="s0">}</span>
    <span class="s3">// If the header is not present, there was no rewrite, so we use the search</span>
    <span class="s3">// query of the response URL.</span>
    <span class="s1">return </span><span class="s0">urlToUrlWithoutFlightMarker(</span><span class="s1">new </span><span class="s0">URL(response.url)).search;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">getRenderedPathname(response) {</span>
    <span class="s3">// If the server performed a rewrite, the pathname used to render the</span>
    <span class="s3">// page will be different from the pathname in the request URL. In this case,</span>
    <span class="s3">// the response will include a header that gives the rewritten pathname.</span>
    <span class="s1">const </span><span class="s0">rewrittenPath = response.headers.get(_approuterheaders.NEXT_REWRITTEN_PATH_HEADER);</span>
    <span class="s1">return </span><span class="s0">rewrittenPath != </span><span class="s1">null </span><span class="s0">? rewrittenPath : urlToUrlWithoutFlightMarker(</span><span class="s1">new </span><span class="s0">URL(response.url)).pathname;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">parseDynamicParamFromURLPart(paramType, pathnameParts, partIndex) {</span>
    <span class="s3">// This needs to match the behavior in get-dynamic-param.ts.</span>
    <span class="s1">switch</span><span class="s0">(paramType){</span>
        <span class="s3">// Catchalls</span>
        <span class="s1">case </span><span class="s2">'c'</span><span class="s0">:</span>
        <span class="s1">case </span><span class="s2">'ci'</span><span class="s0">:</span>
            <span class="s0">{</span>
                <span class="s3">// Catchalls receive all the remaining URL parts. If there are no</span>
                <span class="s3">// remaining pathname parts, return an empty array.</span>
                <span class="s1">return </span><span class="s0">partIndex &lt; pathnameParts.length ? pathnameParts.slice(partIndex).map((s)=&gt;encodeURIComponent(s)) : [];</span>
            <span class="s0">}</span>
        <span class="s3">// Optional catchalls</span>
        <span class="s1">case </span><span class="s2">'oc'</span><span class="s0">:</span>
            <span class="s0">{</span>
                <span class="s3">// Optional catchalls receive all the remaining URL parts, unless this is</span>
                <span class="s3">// the end of the pathname, in which case they return null.</span>
                <span class="s1">return </span><span class="s0">partIndex &lt; pathnameParts.length ? pathnameParts.slice(partIndex).map((s)=&gt;encodeURIComponent(s)) : </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s3">// Dynamic</span>
        <span class="s1">case </span><span class="s2">'d'</span><span class="s0">:</span>
        <span class="s1">case </span><span class="s2">'di'</span><span class="s0">:</span>
            <span class="s0">{</span>
                <span class="s1">if </span><span class="s0">(partIndex &gt;= pathnameParts.length) {</span>
                    <span class="s3">// The route tree expected there to be more parts in the URL than there</span>
                    <span class="s3">// actually are. This could happen if the x-nextjs-rewritten-path header</span>
                    <span class="s3">// is incorrectly set, or potentially due to bug in Next.js. TODO:</span>
                    <span class="s3">// Should this be a hard error? During a prefetch, we can just abort.</span>
                    <span class="s3">// During a client navigation, we could trigger a hard refresh. But if</span>
                    <span class="s3">// it happens during initial render, we don't really have any</span>
                    <span class="s3">// recovery options.</span>
                    <span class="s1">return </span><span class="s2">''</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">return </span><span class="s0">encodeURIComponent(pathnameParts[partIndex]);</span>
            <span class="s0">}</span>
        <span class="s1">default</span><span class="s0">:</span>
            <span class="s0">paramType;</span>
            <span class="s1">return </span><span class="s2">''</span><span class="s0">;</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">doesStaticSegmentAppearInURL(segment) {</span>
    <span class="s3">// This is not a parameterized segment; however, we need to determine</span>
    <span class="s3">// whether or not this segment appears in the URL. For example, this route</span>
    <span class="s3">// groups do not appear in the URL, so they should be skipped. Any other</span>
    <span class="s3">// special cases must be handled here.</span>
    <span class="s3">// TODO: Consider encoding this directly into the router tree instead of</span>
    <span class="s3">// inferring it on the client based on the segment type. Something like</span>
    <span class="s3">// a `doesAppearInURL` flag in FlightRouterState.</span>
    <span class="s1">if </span><span class="s0">(segment === _segmentvalueencoding.ROOT_SEGMENT_REQUEST_KEY || </span><span class="s3">// For some reason, the loader tree sometimes includes extra __PAGE__</span>
    <span class="s3">// &quot;layouts&quot; when part of a parallel route. But it's not a leaf node.</span>
    <span class="s3">// Otherwise, we wouldn't need this special case because pages are</span>
    <span class="s3">// always leaf nodes.</span>
    <span class="s3">// TODO: Investigate why the loader produces these fake page segments.</span>
    <span class="s0">segment.startsWith(_segment.PAGE_SEGMENT_KEY) || </span><span class="s3">// Route groups.</span>
    <span class="s0">segment[</span><span class="s4">0</span><span class="s0">] === </span><span class="s2">'(' </span><span class="s0">&amp;&amp; segment.endsWith(</span><span class="s2">')'</span><span class="s0">) || segment === _segment.DEFAULT_SEGMENT_KEY || segment === </span><span class="s2">'/_not-found'</span><span class="s0">) {</span>
        <span class="s1">return false</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s3">// All other segment types appear in the URL</span>
        <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">getCacheKeyForDynamicParam(paramValue, renderedSearch) {</span>
    <span class="s3">// This needs to match the logic in get-dynamic-param.ts, until we're able to</span>
    <span class="s3">// unify the various implementations so that these are always computed on</span>
    <span class="s3">// the client.</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">paramValue === </span><span class="s2">'string'</span><span class="s0">) {</span>
        <span class="s3">// TODO: Refactor or remove this helper function to accept a string rather</span>
        <span class="s3">// than the whole segment type. Also we can probably just append the</span>
        <span class="s3">// search string instead of turning it into JSON.</span>
        <span class="s1">const </span><span class="s0">pageSegmentWithSearchParams = (</span><span class="s4">0</span><span class="s0">, _segment.addSearchParamsIfPageSegment)(paramValue, Object.fromEntries(</span><span class="s1">new </span><span class="s0">URLSearchParams(renderedSearch)));</span>
        <span class="s1">return </span><span class="s0">pageSegmentWithSearchParams;</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(paramValue === </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s1">return </span><span class="s2">''</span><span class="s0">;</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">return </span><span class="s0">paramValue.join(</span><span class="s2">'/'</span><span class="s0">);</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">urlToUrlWithoutFlightMarker(url) {</span>
    <span class="s1">const </span><span class="s0">urlWithoutFlightParameters = </span><span class="s1">new </span><span class="s0">URL(url);</span>
    <span class="s0">urlWithoutFlightParameters.searchParams.delete(_approuterheaders.NEXT_RSC_UNION_QUERY);</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) </span><span class="s3">//TURBOPACK unreachable</span>
    <span class="s0">;</span>
    <span class="s1">return </span><span class="s0">urlWithoutFlightParameters;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">getParamValueFromCacheKey(paramCacheKey, paramType) {</span>
    <span class="s3">// Turn the cache key string sent by the server (as part of FlightRouterState)</span>
    <span class="s3">// into a value that can be passed to `useParams` and client components.</span>
    <span class="s1">const </span><span class="s0">isCatchAll = paramType === </span><span class="s2">'c' </span><span class="s0">|| paramType === </span><span class="s2">'oc'</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(isCatchAll) {</span>
        <span class="s3">// Catch-all param keys are a concatenation of the path segments.</span>
        <span class="s3">// See equivalent logic in `getSelectedParams`.</span>
        <span class="s3">// TODO: We should just pass the array directly, rather than concatenate</span>
        <span class="s3">// it to a string and then split it back to an array. It needs to be an</span>
        <span class="s3">// array in some places, like when passing a key React, but we can convert</span>
        <span class="s3">// it at runtime in those places.</span>
        <span class="s1">return </span><span class="s0">paramCacheKey.split(</span><span class="s2">'/'</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">paramCacheKey;</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=route-params.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/fetch-server-response.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">'use client'</span><span class="s0">;</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s0">createFetch: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">createFromNextReadableStream: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">fetchServerResponse: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s0">createFetch: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">createFetch;</span>
    <span class="s0">},</span>
    <span class="s0">createFromNextReadableStream: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">createFromNextReadableStream;</span>
    <span class="s0">},</span>
    <span class="s0">fetchServerResponse: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">fetchServerResponse;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_client = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react-server-dom-turbopack/client.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_approuterheaders = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/app-router-headers.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_appcallserver = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/app-call-server.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_appfindsourcemapurl = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/app-find-source-map-url.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_routerreducertypes = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_flightdatahelpers = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/flight-data-helpers.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_appbuildid = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/app-build-id.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_setcachebustingsearchparam = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/set-cache-busting-search-param.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_routeparams = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/route-params.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">createFromReadableStream = _client.createFromReadableStream;</span>
<span class="s1">function </span><span class="s0">doMpaNavigation(url) {</span>
    <span class="s1">return </span><span class="s0">{</span>
        <span class="s0">flightData: (</span><span class="s4">0</span><span class="s0">, _routeparams.urlToUrlWithoutFlightMarker)(</span><span class="s1">new </span><span class="s0">URL(url, location.origin)).toString(),</span>
        <span class="s0">canonicalUrl: undefined,</span>
        <span class="s0">couldBeIntercepted: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">prerendered: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">postponed: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">staleTime: -</span><span class="s4">1</span>
    <span class="s0">};</span>
<span class="s0">}</span>
<span class="s1">let </span><span class="s0">abortController = </span><span class="s1">new </span><span class="s0">AbortController();</span>
<span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">window !== </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s3">// Abort any in-flight requests when the page is unloaded, e.g. due to</span>
    <span class="s3">// reloading the page or performing hard navigations. This allows us to ignore</span>
    <span class="s3">// what would otherwise be a thrown TypeError when the browser cancels the</span>
    <span class="s3">// requests.</span>
    <span class="s0">window.addEventListener(</span><span class="s2">'pagehide'</span><span class="s0">, ()=&gt;{</span>
        <span class="s0">abortController.abort();</span>
    <span class="s0">});</span>
    <span class="s3">// Use a fresh AbortController instance on pageshow, e.g. when navigating back</span>
    <span class="s3">// and the JavaScript execution context is restored by the browser.</span>
    <span class="s0">window.addEventListener(</span><span class="s2">'pageshow'</span><span class="s0">, ()=&gt;{</span>
        <span class="s0">abortController = </span><span class="s1">new </span><span class="s0">AbortController();</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">async </span><span class="s1">function </span><span class="s0">fetchServerResponse(url, options) {</span>
    <span class="s1">const </span><span class="s0">{ flightRouterState, nextUrl, prefetchKind } = options;</span>
    <span class="s1">const </span><span class="s0">headers = {</span>
        <span class="s3">// Enable flight response</span>
        <span class="s0">[_approuterheaders.RSC_HEADER]: </span><span class="s2">'1'</span><span class="s0">,</span>
        <span class="s3">// Provide the current router state</span>
        <span class="s0">[_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER]: (</span><span class="s4">0</span><span class="s0">, _flightdatahelpers.prepareFlightRouterStateForRequest)(flightRouterState, options.isHmrRefresh)</span>
    <span class="s0">};</span>
    <span class="s3">/**</span>
   <span class="s3">* Three cases:</span>
   <span class="s3">* - `prefetchKind` is `undefined`, it means it's a normal navigation, so we want to prefetch the page data fully</span>
   <span class="s3">* - `prefetchKind` is `full` - we want to prefetch the whole page so same as above</span>
   <span class="s3">* - `prefetchKind` is `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully</span>
   <span class="s3">*/ </span><span class="s1">if </span><span class="s0">(prefetchKind === _routerreducertypes.PrefetchKind.AUTO) {</span>
        <span class="s0">headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER] = </span><span class="s2">'1'</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">((</span><span class="s2">&quot;TURBOPACK compile-time value&quot;</span><span class="s0">, </span><span class="s2">&quot;development&quot;</span><span class="s0">) === </span><span class="s2">'development' </span><span class="s0">&amp;&amp; options.isHmrRefresh) {</span>
        <span class="s0">headers[_approuterheaders.NEXT_HMR_REFRESH_HEADER] = </span><span class="s2">'1'</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(nextUrl) {</span>
        <span class="s0">headers[_approuterheaders.NEXT_URL] = nextUrl;</span>
    <span class="s0">}</span>
    <span class="s1">try </span><span class="s0">{</span>
        <span class="s1">var </span><span class="s0">_res_headers_get;</span>
        <span class="s3">// When creating a &quot;temporary&quot; prefetch (the &quot;on-demand&quot; prefetch that gets created on navigation, if one doesn't exist)</span>
        <span class="s3">// we send the request with a &quot;high&quot; priority as it's in response to a user interaction that could be blocking a transition.</span>
        <span class="s3">// Otherwise, all other prefetches are sent with a &quot;low&quot; priority.</span>
        <span class="s3">// We use &quot;auto&quot; for in all other cases to match the existing default, as this function is shared outside of prefetching.</span>
        <span class="s1">const </span><span class="s0">fetchPriority = prefetchKind ? prefetchKind === _routerreducertypes.PrefetchKind.TEMPORARY ? </span><span class="s2">'high' </span><span class="s0">: </span><span class="s2">'low' </span><span class="s0">: </span><span class="s2">'auto'</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) </span><span class="s3">//TURBOPACK unreachable</span>
        <span class="s0">;</span>
        <span class="s1">const </span><span class="s0">res = </span><span class="s1">await </span><span class="s0">createFetch(url, headers, fetchPriority, abortController.signal);</span>
        <span class="s1">const </span><span class="s0">responseUrl = (</span><span class="s4">0</span><span class="s0">, _routeparams.urlToUrlWithoutFlightMarker)(</span><span class="s1">new </span><span class="s0">URL(res.url));</span>
        <span class="s1">const </span><span class="s0">canonicalUrl = res.redirected ? responseUrl : undefined;</span>
        <span class="s1">const </span><span class="s0">contentType = res.headers.get(</span><span class="s2">'content-type'</span><span class="s0">) || </span><span class="s2">''</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">interception = !!((_res_headers_get = res.headers.get(</span><span class="s2">'vary'</span><span class="s0">)) == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: _res_headers_get.includes(_approuterheaders.NEXT_URL));</span>
        <span class="s1">const </span><span class="s0">postponed = !!res.headers.get(_approuterheaders.NEXT_DID_POSTPONE_HEADER);</span>
        <span class="s1">const </span><span class="s0">staleTimeHeaderSeconds = res.headers.get(_approuterheaders.NEXT_ROUTER_STALE_TIME_HEADER);</span>
        <span class="s1">const </span><span class="s0">staleTime = staleTimeHeaderSeconds !== </span><span class="s1">null </span><span class="s0">? parseInt(staleTimeHeaderSeconds, </span><span class="s4">10</span><span class="s0">) * </span><span class="s4">1000 </span><span class="s0">: -</span><span class="s4">1</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">isFlightResponse = contentType.startsWith(_approuterheaders.RSC_CONTENT_TYPE_HEADER);</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) </span><span class="s3">//TURBOPACK unreachable</span>
        <span class="s0">;</span>
        <span class="s3">// If fetch returns something different than flight response handle it like a mpa navigation</span>
        <span class="s3">// If the fetch was not 200, we also handle it like a mpa navigation</span>
        <span class="s1">if </span><span class="s0">(!isFlightResponse || !res.ok || !res.body) {</span>
            <span class="s3">// in case the original URL came with a hash, preserve it before redirecting to the new URL</span>
            <span class="s1">if </span><span class="s0">(url.hash) {</span>
                <span class="s0">responseUrl.hash = url.hash;</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">doMpaNavigation(responseUrl.toString());</span>
        <span class="s0">}</span>
        <span class="s3">// We may navigate to a page that requires a different Webpack runtime.</span>
        <span class="s3">// In prod, every page will have the same Webpack runtime.</span>
        <span class="s3">// In dev, the Webpack runtime is minimal for each page.</span>
        <span class="s3">// We need to ensure the Webpack runtime is updated before executing client-side JS of the new page.</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) </span><span class="s3">//TURBOPACK unreachable</span>
        <span class="s0">;</span>
        <span class="s3">// Handle the `fetch` readable stream that can be unwrapped by `React.use`.</span>
        <span class="s1">const </span><span class="s0">flightStream = postponed ? createUnclosingPrefetchStream(res.body) : res.body;</span>
        <span class="s1">const </span><span class="s0">response = </span><span class="s1">await </span><span class="s0">createFromNextReadableStream(flightStream);</span>
        <span class="s1">if </span><span class="s0">((</span><span class="s4">0</span><span class="s0">, _appbuildid.getAppBuildId)() !== response.b) {</span>
            <span class="s1">return </span><span class="s0">doMpaNavigation(res.url);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">flightData: (</span><span class="s4">0</span><span class="s0">, _flightdatahelpers.normalizeFlightData)(response.f),</span>
            <span class="s0">canonicalUrl: canonicalUrl,</span>
            <span class="s0">couldBeIntercepted: interception,</span>
            <span class="s0">prerendered: response.S,</span>
            <span class="s0">postponed,</span>
            <span class="s0">staleTime</span>
        <span class="s0">};</span>
    <span class="s0">} </span><span class="s1">catch </span><span class="s0">(err) {</span>
        <span class="s1">if </span><span class="s0">(!abortController.signal.aborted) {</span>
            <span class="s0">console.error(</span><span class="s2">&quot;Failed to fetch RSC payload for &quot; </span><span class="s0">+ url + </span><span class="s2">&quot;. Falling back to browser navigation.&quot;</span><span class="s0">, err);</span>
        <span class="s0">}</span>
        <span class="s3">// If fetch fails handle it like a mpa navigation</span>
        <span class="s3">// TODO-APP: Add a test for the case where a CORS request fails, e.g. external url redirect coming from the response.</span>
        <span class="s3">// See https://github.com/vercel/next.js/issues/43605#issuecomment-1451617521 for a reproduction.</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">flightData: url.toString(),</span>
            <span class="s0">canonicalUrl: undefined,</span>
            <span class="s0">couldBeIntercepted: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">prerendered: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">postponed: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">staleTime: -</span><span class="s4">1</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s0">async </span><span class="s1">function </span><span class="s0">createFetch(url, headers, fetchPriority, signal) {</span>
    <span class="s3">// TODO: In output: &quot;export&quot; mode, the headers do nothing. Omit them (and the</span>
    <span class="s3">// cache busting search param) from the request so they're</span>
    <span class="s3">// maximally cacheable.</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) </span><span class="s3">//TURBOPACK unreachable</span>
    <span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) </span><span class="s3">//TURBOPACK unreachable</span>
    <span class="s0">;</span>
    <span class="s1">const </span><span class="s0">fetchOptions = {</span>
        <span class="s3">// Backwards compat for older browsers. `same-origin` is the default in modern browsers.</span>
        <span class="s0">credentials: </span><span class="s2">'same-origin'</span><span class="s0">,</span>
        <span class="s0">headers,</span>
        <span class="s0">priority: fetchPriority || undefined,</span>
        <span class="s0">signal</span>
    <span class="s0">};</span>
    <span class="s3">// `fetchUrl` is slightly different from `url` because we add a cache-busting</span>
    <span class="s3">// search param to it. This should not leak outside of this function, so we</span>
    <span class="s3">// track them separately.</span>
    <span class="s1">let </span><span class="s0">fetchUrl = </span><span class="s1">new </span><span class="s0">URL(url);</span>
    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _setcachebustingsearchparam.setCacheBustingSearchParam)(fetchUrl, headers);</span>
    <span class="s1">let </span><span class="s0">browserResponse = </span><span class="s1">await </span><span class="s0">fetch(fetchUrl, fetchOptions);</span>
    <span class="s3">// If the server responds with a redirect (e.g. 307), and the redirected</span>
    <span class="s3">// location does not contain the cache busting search param set in the</span>
    <span class="s3">// original request, the response is likely invalid  when following the</span>
    <span class="s3">// redirect, the browser forwards the request headers, but since the cache</span>
    <span class="s3">// busting search param is missing, the server will reject the request due to</span>
    <span class="s3">// a mismatch.</span>
    <span class="s3">//</span>
    <span class="s3">// Ideally, we would be able to intercept the redirect response and perform it</span>
    <span class="s3">// manually, instead of letting the browser automatically follow it, but this</span>
    <span class="s3">// is not allowed by the fetch API.</span>
    <span class="s3">//</span>
    <span class="s3">// So instead, we must &quot;replay&quot; the redirect by fetching the new location</span>
    <span class="s3">// again, but this time we'll append the cache busting search param to prevent</span>
    <span class="s3">// a mismatch.</span>
    <span class="s3">//</span>
    <span class="s3">// TODO: We can optimize Next.js's built-in middleware APIs by returning a</span>
    <span class="s3">// custom status code, to prevent the browser from automatically following it.</span>
    <span class="s3">//</span>
    <span class="s3">// This does not affect Server Action-based redirects; those are encoded</span>
    <span class="s3">// differently, as part of the Flight body. It only affects redirects that</span>
    <span class="s3">// occur in a middleware or a third-party proxy.</span>
    <span class="s1">let </span><span class="s0">redirected = browserResponse.redirected;</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) </span><span class="s3">//TURBOPACK unreachable</span>
    <span class="s0">;</span>
    <span class="s3">// Remove the cache busting search param from the response URL, to prevent it</span>
    <span class="s3">// from leaking outside of this function.</span>
    <span class="s1">const </span><span class="s0">responseUrl = </span><span class="s1">new </span><span class="s0">URL(browserResponse.url, fetchUrl);</span>
    <span class="s0">responseUrl.searchParams.delete(_approuterheaders.NEXT_RSC_UNION_QUERY);</span>
    <span class="s1">const </span><span class="s0">rscResponse = {</span>
        <span class="s0">url: responseUrl.href,</span>
        <span class="s3">// This is true if any redirects occurred, either automatically by the</span>
        <span class="s3">// browser, or manually by us. So it's different from</span>
        <span class="s3">// `browserResponse.redirected`, which only tells us whether the browser</span>
        <span class="s3">// followed a redirect, and only for the last response in the chain.</span>
        <span class="s0">redirected,</span>
        <span class="s3">// These can be copied from the last browser response we received. We</span>
        <span class="s3">// intentionally only expose the subset of fields that are actually used</span>
        <span class="s3">// elsewhere in the codebase.</span>
        <span class="s0">ok: browserResponse.ok,</span>
        <span class="s0">headers: browserResponse.headers,</span>
        <span class="s0">body: browserResponse.body,</span>
        <span class="s0">status: browserResponse.status</span>
    <span class="s0">};</span>
    <span class="s1">return </span><span class="s0">rscResponse;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">createFromNextReadableStream(flightStream) {</span>
    <span class="s1">return </span><span class="s0">createFromReadableStream(flightStream, {</span>
        <span class="s0">callServer: _appcallserver.callServer,</span>
        <span class="s0">findSourceMapURL: _appfindsourcemapurl.findSourceMapURL</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">createUnclosingPrefetchStream(originalFlightStream) {</span>
    <span class="s3">// When PPR is enabled, prefetch streams may contain references that never</span>
    <span class="s3">// resolve, because that's how we encode dynamic data access. In the decoded</span>
    <span class="s3">// object returned by the Flight client, these are reified into hanging</span>
    <span class="s3">// promises that suspend during render, which is effectively what we want.</span>
    <span class="s3">// The UI resolves when it switches to the dynamic data stream</span>
    <span class="s3">// (via useDeferredValue(dynamic, static)).</span>
    <span class="s3">//</span>
    <span class="s3">// However, the Flight implementation currently errors if the server closes</span>
    <span class="s3">// the response before all the references are resolved. As a cheat to work</span>
    <span class="s3">// around this, we wrap the original stream in a new stream that never closes,</span>
    <span class="s3">// and therefore doesn't error.</span>
    <span class="s1">const </span><span class="s0">reader = originalFlightStream.getReader();</span>
    <span class="s1">return new </span><span class="s0">ReadableStream({</span>
        <span class="s0">async pull (controller) {</span>
            <span class="s1">while</span><span class="s0">(</span><span class="s1">true</span><span class="s0">){</span>
                <span class="s1">const </span><span class="s0">{ done, value } = </span><span class="s1">await </span><span class="s0">reader.read();</span>
                <span class="s1">if </span><span class="s0">(!done) {</span>
                    <span class="s3">// Pass to the target stream and keep consuming the Flight response</span>
                    <span class="s3">// from the server.</span>
                    <span class="s0">controller.enqueue(value);</span>
                    <span class="s1">continue</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s3">// The server stream has closed. Exit, but intentionally do not close</span>
                <span class="s3">// the target stream.</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=fetch-server-response.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;createRouterCacheKey&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">createRouterCacheKey;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_segment = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/segment.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">createRouterCacheKey(segment, withoutSearchParameters) {</span>
    <span class="s1">if </span><span class="s0">(withoutSearchParameters === </span><span class="s1">void </span><span class="s4">0</span><span class="s0">) withoutSearchParameters = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s3">// if the segment is an array, it means it's a dynamic segment</span>
    <span class="s3">// for example, ['lang', 'en', 'd']. We need to convert it to a string to store it as a cache node key.</span>
    <span class="s1">if </span><span class="s0">(Array.isArray(segment)) {</span>
        <span class="s1">return </span><span class="s0">segment[</span><span class="s4">0</span><span class="s0">] + </span><span class="s2">&quot;|&quot; </span><span class="s0">+ segment[</span><span class="s4">1</span><span class="s0">] + </span><span class="s2">&quot;|&quot; </span><span class="s0">+ segment[</span><span class="s4">2</span><span class="s0">];</span>
    <span class="s0">}</span>
    <span class="s3">// Page segments might have search parameters, ie __PAGE__?foo=bar</span>
    <span class="s3">// When `withoutSearchParameters` is true, we only want to return the page segment</span>
    <span class="s1">if </span><span class="s0">(withoutSearchParameters &amp;&amp; segment.startsWith(_segment.PAGE_SEGMENT_KEY)) {</span>
        <span class="s1">return </span><span class="s0">_segment.PAGE_SEGMENT_KEY;</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">segment;</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=create-router-cache-key.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/invalidate-cache-below-flight-segmentpath.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;invalidateCacheBelowFlightSegmentPath&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">invalidateCacheBelowFlightSegmentPath;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_createroutercachekey = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_flightdatahelpers = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/flight-data-helpers.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">invalidateCacheBelowFlightSegmentPath(newCache, existingCache, flightSegmentPath) {</span>
    <span class="s1">const </span><span class="s0">isLastEntry = flightSegmentPath.length &lt;= </span><span class="s4">2</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">[parallelRouteKey, segment] = flightSegmentPath;</span>
    <span class="s1">const </span><span class="s0">cacheKey = (</span><span class="s4">0</span><span class="s0">, _createroutercachekey.createRouterCacheKey)(segment);</span>
    <span class="s1">const </span><span class="s0">existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);</span>
    <span class="s1">if </span><span class="s0">(!existingChildSegmentMap) {</span>
        <span class="s3">// Bailout because the existing cache does not have the path to the leaf node</span>
        <span class="s3">// Will trigger lazy fetch in layout-router because of missing segment</span>
        <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">let </span><span class="s0">childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);</span>
    <span class="s1">if </span><span class="s0">(!childSegmentMap || childSegmentMap === existingChildSegmentMap) {</span>
        <span class="s0">childSegmentMap = </span><span class="s1">new </span><span class="s0">Map(existingChildSegmentMap);</span>
        <span class="s0">newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);</span>
    <span class="s0">}</span>
    <span class="s3">// In case of last entry don't copy further down.</span>
    <span class="s1">if </span><span class="s0">(isLastEntry) {</span>
        <span class="s0">childSegmentMap.delete(cacheKey);</span>
        <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">existingChildCacheNode = existingChildSegmentMap.get(cacheKey);</span>
    <span class="s1">let </span><span class="s0">childCacheNode = childSegmentMap.get(cacheKey);</span>
    <span class="s1">if </span><span class="s0">(!childCacheNode || !existingChildCacheNode) {</span>
        <span class="s3">// Bailout because the existing cache does not have the path to the leaf node</span>
        <span class="s3">// Will trigger lazy fetch in layout-router because of missing segment</span>
        <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(childCacheNode === existingChildCacheNode) {</span>
        <span class="s0">childCacheNode = {</span>
            <span class="s0">lazyData: childCacheNode.lazyData,</span>
            <span class="s0">rsc: childCacheNode.rsc,</span>
            <span class="s0">prefetchRsc: childCacheNode.prefetchRsc,</span>
            <span class="s0">head: childCacheNode.head,</span>
            <span class="s0">prefetchHead: childCacheNode.prefetchHead,</span>
            <span class="s0">parallelRoutes: </span><span class="s1">new </span><span class="s0">Map(childCacheNode.parallelRoutes)</span>
        <span class="s0">};</span>
        <span class="s0">childSegmentMap.set(cacheKey, childCacheNode);</span>
    <span class="s0">}</span>
    <span class="s0">invalidateCacheBelowFlightSegmentPath(childCacheNode, existingChildCacheNode, (</span><span class="s4">0</span><span class="s0">, _flightdatahelpers.getNextFlightSegmentPath)(flightSegmentPath));</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=invalidate-cache-below-flight-segmentpath.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/match-segments.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;matchSegment&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">matchSegment;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">matchSegment = (existingSegment, segment)=&gt;{</span>
    <span class="s3">// segment is either Array or string</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">existingSegment === </span><span class="s2">'string'</span><span class="s0">) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">segment === </span><span class="s2">'string'</span><span class="s0">) {</span>
            <span class="s3">// Common case: segment is just a string</span>
            <span class="s1">return </span><span class="s0">existingSegment === segment;</span>
        <span class="s0">}</span>
        <span class="s1">return false</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">segment === </span><span class="s2">'string'</span><span class="s0">) {</span>
        <span class="s1">return false</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">existingSegment[</span><span class="s4">0</span><span class="s0">] === segment[</span><span class="s4">0</span><span class="s0">] &amp;&amp; existingSegment[</span><span class="s4">1</span><span class="s0">] === segment[</span><span class="s4">1</span><span class="s0">];</span>
<span class="s0">};</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=match-segments.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;fillLazyItemsTillLeafWithHead&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">fillLazyItemsTillLeafWithHead;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_createroutercachekey = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_routerreducertypes = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">fillLazyItemsTillLeafWithHead(navigatedAt, newCache, existingCache, routerState, cacheNodeSeedData, head, prefetchEntry) {</span>
    <span class="s1">const </span><span class="s0">isLastSegment = Object.keys(routerState[</span><span class="s4">1</span><span class="s0">]).length === </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(isLastSegment) {</span>
        <span class="s0">newCache.head = head;</span>
        <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s3">// Remove segment that we got data for so that it is filled in during rendering of rsc.</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in </span><span class="s0">routerState[</span><span class="s4">1</span><span class="s0">]){</span>
        <span class="s1">const </span><span class="s0">parallelRouteState = routerState[</span><span class="s4">1</span><span class="s0">][key];</span>
        <span class="s1">const </span><span class="s0">segmentForParallelRoute = parallelRouteState[</span><span class="s4">0</span><span class="s0">];</span>
        <span class="s1">const </span><span class="s0">cacheKey = (</span><span class="s4">0</span><span class="s0">, _createroutercachekey.createRouterCacheKey)(segmentForParallelRoute);</span>
        <span class="s3">// TODO: We should traverse the cacheNodeSeedData tree instead of the router</span>
        <span class="s3">// state tree. Ideally, they would always be the same shape, but because of</span>
        <span class="s3">// the loading.js pattern, cacheNodeSeedData sometimes only represents a</span>
        <span class="s3">// partial tree. That's why this node is sometimes null. Once PPR lands,</span>
        <span class="s3">// loading.js will no longer have special behavior and we can traverse the</span>
        <span class="s3">// data tree instead.</span>
        <span class="s3">//</span>
        <span class="s3">// We should also consider merging the router state tree and the data tree</span>
        <span class="s3">// in the response format, so that we don't have to send the keys twice.</span>
        <span class="s3">// Then the client can convert them into separate representations.</span>
        <span class="s1">const </span><span class="s0">parallelSeedData = cacheNodeSeedData !== </span><span class="s1">null </span><span class="s0">&amp;&amp; cacheNodeSeedData[</span><span class="s4">2</span><span class="s0">][key] !== undefined ? cacheNodeSeedData[</span><span class="s4">2</span><span class="s0">][key] : </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(existingCache) {</span>
            <span class="s1">const </span><span class="s0">existingParallelRoutesCacheNode = existingCache.parallelRoutes.get(key);</span>
            <span class="s1">if </span><span class="s0">(existingParallelRoutesCacheNode) {</span>
                <span class="s1">const </span><span class="s0">hasReusablePrefetch = (prefetchEntry == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: prefetchEntry.kind) === </span><span class="s2">'auto' </span><span class="s0">&amp;&amp; prefetchEntry.status === _routerreducertypes.PrefetchCacheEntryStatus.reusable;</span>
                <span class="s1">let </span><span class="s0">parallelRouteCacheNode = </span><span class="s1">new </span><span class="s0">Map(existingParallelRoutesCacheNode);</span>
                <span class="s1">const </span><span class="s0">existingCacheNode = parallelRouteCacheNode.get(cacheKey);</span>
                <span class="s1">let </span><span class="s0">newCacheNode;</span>
                <span class="s1">if </span><span class="s0">(parallelSeedData !== </span><span class="s1">null</span><span class="s0">) {</span>
                    <span class="s3">// New data was sent from the server.</span>
                    <span class="s1">const </span><span class="s0">seedNode = parallelSeedData[</span><span class="s4">1</span><span class="s0">];</span>
                    <span class="s1">const </span><span class="s0">loading = parallelSeedData[</span><span class="s4">3</span><span class="s0">];</span>
                    <span class="s0">newCacheNode = {</span>
                        <span class="s0">lazyData: </span><span class="s1">null</span><span class="s0">,</span>
                        <span class="s0">rsc: seedNode,</span>
                        <span class="s3">// This is a PPR-only field. When PPR is enabled, we shouldn't hit</span>
                        <span class="s3">// this path during a navigation, but until PPR is fully implemented</span>
                        <span class="s3">// yet it's possible the existing node does have a non-null</span>
                        <span class="s3">// `prefetchRsc`. As an incremental step, we'll just de-opt to the</span>
                        <span class="s3">// old behavior  no PPR value.</span>
                        <span class="s0">prefetchRsc: </span><span class="s1">null</span><span class="s0">,</span>
                        <span class="s0">head: </span><span class="s1">null</span><span class="s0">,</span>
                        <span class="s0">prefetchHead: </span><span class="s1">null</span><span class="s0">,</span>
                        <span class="s0">loading,</span>
                        <span class="s0">parallelRoutes: </span><span class="s1">new </span><span class="s0">Map(existingCacheNode == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: existingCacheNode.parallelRoutes),</span>
                        <span class="s0">navigatedAt</span>
                    <span class="s0">};</span>
                <span class="s0">} </span><span class="s1">else if </span><span class="s0">(hasReusablePrefetch &amp;&amp; existingCacheNode) {</span>
                    <span class="s3">// No new data was sent from the server, but the existing cache node</span>
                    <span class="s3">// was prefetched, so we should reuse that.</span>
                    <span class="s0">newCacheNode = {</span>
                        <span class="s0">lazyData: existingCacheNode.lazyData,</span>
                        <span class="s0">rsc: existingCacheNode.rsc,</span>
                        <span class="s3">// This is a PPR-only field. Unlike the previous branch, since we're</span>
                        <span class="s3">// just cloning the existing cache node, we might as well keep the</span>
                        <span class="s3">// PPR value, if it exists.</span>
                        <span class="s0">prefetchRsc: existingCacheNode.prefetchRsc,</span>
                        <span class="s0">head: existingCacheNode.head,</span>
                        <span class="s0">prefetchHead: existingCacheNode.prefetchHead,</span>
                        <span class="s0">parallelRoutes: </span><span class="s1">new </span><span class="s0">Map(existingCacheNode.parallelRoutes),</span>
                        <span class="s0">loading: existingCacheNode.loading</span>
                    <span class="s0">};</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                    <span class="s3">// No data available for this node. This will trigger a lazy fetch</span>
                    <span class="s3">// during render.</span>
                    <span class="s0">newCacheNode = {</span>
                        <span class="s0">lazyData: </span><span class="s1">null</span><span class="s0">,</span>
                        <span class="s0">rsc: </span><span class="s1">null</span><span class="s0">,</span>
                        <span class="s0">prefetchRsc: </span><span class="s1">null</span><span class="s0">,</span>
                        <span class="s0">head: </span><span class="s1">null</span><span class="s0">,</span>
                        <span class="s0">prefetchHead: </span><span class="s1">null</span><span class="s0">,</span>
                        <span class="s0">parallelRoutes: </span><span class="s1">new </span><span class="s0">Map(existingCacheNode == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: existingCacheNode.parallelRoutes),</span>
                        <span class="s0">loading: </span><span class="s1">null</span><span class="s0">,</span>
                        <span class="s0">navigatedAt</span>
                    <span class="s0">};</span>
                <span class="s0">}</span>
                <span class="s3">// Overrides the cache key with the new cache node.</span>
                <span class="s0">parallelRouteCacheNode.set(cacheKey, newCacheNode);</span>
                <span class="s3">// Traverse deeper to apply the head / fill lazy items till the head.</span>
                <span class="s0">fillLazyItemsTillLeafWithHead(navigatedAt, newCacheNode, existingCacheNode, parallelRouteState, parallelSeedData ? parallelSeedData : </span><span class="s1">null</span><span class="s0">, head, prefetchEntry);</span>
                <span class="s0">newCache.parallelRoutes.set(key, parallelRouteCacheNode);</span>
                <span class="s1">continue</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">let </span><span class="s0">newCacheNode;</span>
        <span class="s1">if </span><span class="s0">(parallelSeedData !== </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s3">// New data was sent from the server.</span>
            <span class="s1">const </span><span class="s0">seedNode = parallelSeedData[</span><span class="s4">1</span><span class="s0">];</span>
            <span class="s1">const </span><span class="s0">loading = parallelSeedData[</span><span class="s4">3</span><span class="s0">];</span>
            <span class="s0">newCacheNode = {</span>
                <span class="s0">lazyData: </span><span class="s1">null</span><span class="s0">,</span>
                <span class="s0">rsc: seedNode,</span>
                <span class="s0">prefetchRsc: </span><span class="s1">null</span><span class="s0">,</span>
                <span class="s0">head: </span><span class="s1">null</span><span class="s0">,</span>
                <span class="s0">prefetchHead: </span><span class="s1">null</span><span class="s0">,</span>
                <span class="s0">parallelRoutes: </span><span class="s1">new </span><span class="s0">Map(),</span>
                <span class="s0">loading,</span>
                <span class="s0">navigatedAt</span>
            <span class="s0">};</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s3">// No data available for this node. This will trigger a lazy fetch</span>
            <span class="s3">// during render.</span>
            <span class="s0">newCacheNode = {</span>
                <span class="s0">lazyData: </span><span class="s1">null</span><span class="s0">,</span>
                <span class="s0">rsc: </span><span class="s1">null</span><span class="s0">,</span>
                <span class="s0">prefetchRsc: </span><span class="s1">null</span><span class="s0">,</span>
                <span class="s0">head: </span><span class="s1">null</span><span class="s0">,</span>
                <span class="s0">prefetchHead: </span><span class="s1">null</span><span class="s0">,</span>
                <span class="s0">parallelRoutes: </span><span class="s1">new </span><span class="s0">Map(),</span>
                <span class="s0">loading: </span><span class="s1">null</span><span class="s0">,</span>
                <span class="s0">navigatedAt</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">existingParallelRoutes = newCache.parallelRoutes.get(key);</span>
        <span class="s1">if </span><span class="s0">(existingParallelRoutes) {</span>
            <span class="s0">existingParallelRoutes.set(cacheKey, newCacheNode);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">newCache.parallelRoutes.set(key, </span><span class="s1">new </span><span class="s0">Map([</span>
                <span class="s0">[</span>
                    <span class="s0">cacheKey,</span>
                    <span class="s0">newCacheNode</span>
                <span class="s0">]</span>
            <span class="s0">]));</span>
        <span class="s0">}</span>
        <span class="s0">fillLazyItemsTillLeafWithHead(navigatedAt, newCacheNode, undefined, parallelRouteState, parallelSeedData, head, prefetchEntry);</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=fill-lazy-items-till-leaf-with-head.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/invalidate-cache-by-router-state.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;invalidateCacheByRouterState&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">invalidateCacheByRouterState;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_createroutercachekey = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">invalidateCacheByRouterState(newCache, existingCache, routerState) {</span>
    <span class="s3">// Remove segment that we got data for so that it is filled in during rendering of rsc.</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in </span><span class="s0">routerState[</span><span class="s4">1</span><span class="s0">]){</span>
        <span class="s1">const </span><span class="s0">segmentForParallelRoute = routerState[</span><span class="s4">1</span><span class="s0">][key][</span><span class="s4">0</span><span class="s0">];</span>
        <span class="s1">const </span><span class="s0">cacheKey = (</span><span class="s4">0</span><span class="s0">, _createroutercachekey.createRouterCacheKey)(segmentForParallelRoute);</span>
        <span class="s1">const </span><span class="s0">existingParallelRoutesCacheNode = existingCache.parallelRoutes.get(key);</span>
        <span class="s1">if </span><span class="s0">(existingParallelRoutesCacheNode) {</span>
            <span class="s1">let </span><span class="s0">parallelRouteCacheNode = </span><span class="s1">new </span><span class="s0">Map(existingParallelRoutesCacheNode);</span>
            <span class="s0">parallelRouteCacheNode.delete(cacheKey);</span>
            <span class="s0">newCache.parallelRoutes.set(key, parallelRouteCacheNode);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=invalidate-cache-by-router-state.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/fill-cache-with-new-subtree-data.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s0">fillCacheWithNewSubTreeData: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">fillCacheWithNewSubTreeDataButOnlyLoading: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s0">fillCacheWithNewSubTreeData: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">fillCacheWithNewSubTreeData;</span>
    <span class="s0">},</span>
    <span class="s0">fillCacheWithNewSubTreeDataButOnlyLoading: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">fillCacheWithNewSubTreeDataButOnlyLoading;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_invalidatecachebyrouterstate = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/invalidate-cache-by-router-state.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_filllazyitemstillleafwithhead = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_createroutercachekey = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_segment = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/segment.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s3">/**</span>
 <span class="s3">* Common logic for filling cache with new sub tree data.</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">fillCacheHelper(navigatedAt, newCache, existingCache, flightData, prefetchEntry, fillLazyItems) {</span>
    <span class="s1">const </span><span class="s0">{ segmentPath, seedData: cacheNodeSeedData, tree: treePatch, head } = flightData;</span>
    <span class="s1">let </span><span class="s0">newCacheNode = newCache;</span>
    <span class="s1">let </span><span class="s0">existingCacheNode = existingCache;</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; segmentPath.length; i += </span><span class="s4">2</span><span class="s0">){</span>
        <span class="s1">const </span><span class="s0">parallelRouteKey = segmentPath[i];</span>
        <span class="s1">const </span><span class="s0">segment = segmentPath[i + </span><span class="s4">1</span><span class="s0">];</span>
        <span class="s3">// segmentPath is a repeating tuple of parallelRouteKey and segment</span>
        <span class="s3">// we know we've hit the last entry we've reached our final pair</span>
        <span class="s1">const </span><span class="s0">isLastEntry = i === segmentPath.length - </span><span class="s4">2</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">cacheKey = (</span><span class="s4">0</span><span class="s0">, _createroutercachekey.createRouterCacheKey)(segment);</span>
        <span class="s1">const </span><span class="s0">existingChildSegmentMap = existingCacheNode.parallelRoutes.get(parallelRouteKey);</span>
        <span class="s1">if </span><span class="s0">(!existingChildSegmentMap) {</span>
            <span class="s1">continue</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">let </span><span class="s0">childSegmentMap = newCacheNode.parallelRoutes.get(parallelRouteKey);</span>
        <span class="s1">if </span><span class="s0">(!childSegmentMap || childSegmentMap === existingChildSegmentMap) {</span>
            <span class="s0">childSegmentMap = </span><span class="s1">new </span><span class="s0">Map(existingChildSegmentMap);</span>
            <span class="s0">newCacheNode.parallelRoutes.set(parallelRouteKey, childSegmentMap);</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">existingChildCacheNode = existingChildSegmentMap.get(cacheKey);</span>
        <span class="s1">let </span><span class="s0">childCacheNode = childSegmentMap.get(cacheKey);</span>
        <span class="s1">if </span><span class="s0">(isLastEntry) {</span>
            <span class="s1">if </span><span class="s0">(cacheNodeSeedData &amp;&amp; (!childCacheNode || !childCacheNode.lazyData || childCacheNode === existingChildCacheNode)) {</span>
                <span class="s1">const </span><span class="s0">incomingSegment = cacheNodeSeedData[</span><span class="s4">0</span><span class="s0">];</span>
                <span class="s1">const </span><span class="s0">rsc = cacheNodeSeedData[</span><span class="s4">1</span><span class="s0">];</span>
                <span class="s1">const </span><span class="s0">loading = cacheNodeSeedData[</span><span class="s4">3</span><span class="s0">];</span>
                <span class="s0">childCacheNode = {</span>
                    <span class="s0">lazyData: </span><span class="s1">null</span><span class="s0">,</span>
                    <span class="s3">// When `fillLazyItems` is false, we only want to fill the RSC data for the layout,</span>
                    <span class="s3">// not the page segment.</span>
                    <span class="s0">rsc: fillLazyItems || incomingSegment !== _segment.PAGE_SEGMENT_KEY ? rsc : </span><span class="s1">null</span><span class="s0">,</span>
                    <span class="s0">prefetchRsc: </span><span class="s1">null</span><span class="s0">,</span>
                    <span class="s0">head: </span><span class="s1">null</span><span class="s0">,</span>
                    <span class="s0">prefetchHead: </span><span class="s1">null</span><span class="s0">,</span>
                    <span class="s0">loading,</span>
                    <span class="s0">parallelRoutes: fillLazyItems &amp;&amp; existingChildCacheNode ? </span><span class="s1">new </span><span class="s0">Map(existingChildCacheNode.parallelRoutes) : </span><span class="s1">new </span><span class="s0">Map(),</span>
                    <span class="s0">navigatedAt</span>
                <span class="s0">};</span>
                <span class="s1">if </span><span class="s0">(existingChildCacheNode &amp;&amp; fillLazyItems) {</span>
                    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _invalidatecachebyrouterstate.invalidateCacheByRouterState)(childCacheNode, existingChildCacheNode, treePatch);</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(fillLazyItems) {</span>
                    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(navigatedAt, childCacheNode, existingChildCacheNode, treePatch, cacheNodeSeedData, head, prefetchEntry);</span>
                <span class="s0">}</span>
                <span class="s0">childSegmentMap.set(cacheKey, childCacheNode);</span>
            <span class="s0">}</span>
            <span class="s1">continue</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(!childCacheNode || !existingChildCacheNode) {</span>
            <span class="s1">continue</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(childCacheNode === existingChildCacheNode) {</span>
            <span class="s0">childCacheNode = {</span>
                <span class="s0">lazyData: childCacheNode.lazyData,</span>
                <span class="s0">rsc: childCacheNode.rsc,</span>
                <span class="s0">prefetchRsc: childCacheNode.prefetchRsc,</span>
                <span class="s0">head: childCacheNode.head,</span>
                <span class="s0">prefetchHead: childCacheNode.prefetchHead,</span>
                <span class="s0">parallelRoutes: </span><span class="s1">new </span><span class="s0">Map(childCacheNode.parallelRoutes),</span>
                <span class="s0">loading: childCacheNode.loading</span>
            <span class="s0">};</span>
            <span class="s0">childSegmentMap.set(cacheKey, childCacheNode);</span>
        <span class="s0">}</span>
        <span class="s3">// Move deeper into the cache nodes</span>
        <span class="s0">newCacheNode = childCacheNode;</span>
        <span class="s0">existingCacheNode = existingChildCacheNode;</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">fillCacheWithNewSubTreeData(navigatedAt, newCache, existingCache, flightData, prefetchEntry) {</span>
    <span class="s0">fillCacheHelper(navigatedAt, newCache, existingCache, flightData, prefetchEntry, </span><span class="s1">true</span><span class="s0">);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">fillCacheWithNewSubTreeDataButOnlyLoading(navigatedAt, newCache, existingCache, flightData, prefetchEntry) {</span>
    <span class="s0">fillCacheHelper(navigatedAt, newCache, existingCache, flightData, prefetchEntry, </span><span class="s1">false</span><span class="s0">);</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=fill-cache-with-new-subtree-data.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/apply-flight-data.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;applyFlightData&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">applyFlightData;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_filllazyitemstillleafwithhead = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_fillcachewithnewsubtreedata = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/fill-cache-with-new-subtree-data.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">applyFlightData(navigatedAt, existingCache, cache, flightData, prefetchEntry) {</span>
    <span class="s3">// The one before last item is the router state tree patch</span>
    <span class="s1">const </span><span class="s0">{ tree: treePatch, seedData, head, isRootRender } = flightData;</span>
    <span class="s3">// Handles case where prefetch only returns the router tree patch without rendered components.</span>
    <span class="s1">if </span><span class="s0">(seedData === </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s1">return false</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(isRootRender) {</span>
        <span class="s1">const </span><span class="s0">rsc = seedData[</span><span class="s4">1</span><span class="s0">];</span>
        <span class="s1">const </span><span class="s0">loading = seedData[</span><span class="s4">3</span><span class="s0">];</span>
        <span class="s0">cache.loading = loading;</span>
        <span class="s0">cache.rsc = rsc;</span>
        <span class="s3">// This is a PPR-only field. When PPR is enabled, we shouldn't hit</span>
        <span class="s3">// this path during a navigation, but until PPR is fully implemented</span>
        <span class="s3">// yet it's possible the existing node does have a non-null</span>
        <span class="s3">// `prefetchRsc`. As an incremental step, we'll just de-opt to the</span>
        <span class="s3">// old behavior  no PPR value.</span>
        <span class="s0">cache.prefetchRsc = </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s0">(</span><span class="s4">0</span><span class="s0">, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(navigatedAt, cache, existingCache, treePatch, seedData, head, prefetchEntry);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s3">// Copy rsc for the root node of the cache.</span>
        <span class="s0">cache.rsc = existingCache.rsc;</span>
        <span class="s3">// This is a PPR-only field. Unlike the previous branch, since we're</span>
        <span class="s3">// just cloning the existing cache node, we might as well keep the</span>
        <span class="s3">// PPR value, if it exists.</span>
        <span class="s0">cache.prefetchRsc = existingCache.prefetchRsc;</span>
        <span class="s0">cache.parallelRoutes = </span><span class="s1">new </span><span class="s0">Map(existingCache.parallelRoutes);</span>
        <span class="s0">cache.loading = existingCache.loading;</span>
        <span class="s3">// Create a copy of the existing cache with the rsc applied.</span>
        <span class="s0">(</span><span class="s4">0</span><span class="s0">, _fillcachewithnewsubtreedata.fillCacheWithNewSubTreeData)(navigatedAt, cache, existingCache, flightData, prefetchEntry);</span>
    <span class="s0">}</span>
    <span class="s1">return true</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=apply-flight-data.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s0">addRefreshMarkerToActiveParallelSegments: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">refreshInactiveParallelSegments: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s0">addRefreshMarkerToActiveParallelSegments: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">addRefreshMarkerToActiveParallelSegments;</span>
    <span class="s0">},</span>
    <span class="s0">refreshInactiveParallelSegments: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">refreshInactiveParallelSegments;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_applyflightdata = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/apply-flight-data.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_fetchserverresponse = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/fetch-server-response.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_segment = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/segment.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s0">async </span><span class="s1">function </span><span class="s0">refreshInactiveParallelSegments(options) {</span>
    <span class="s1">const </span><span class="s0">fetchedSegments = </span><span class="s1">new </span><span class="s0">Set();</span>
    <span class="s1">await </span><span class="s0">refreshInactiveParallelSegmentsImpl({</span>
        <span class="s0">...options,</span>
        <span class="s0">rootTree: options.updatedTree,</span>
        <span class="s0">fetchedSegments</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">async </span><span class="s1">function </span><span class="s0">refreshInactiveParallelSegmentsImpl(param) {</span>
    <span class="s1">let </span><span class="s0">{ navigatedAt, state, updatedTree, updatedCache, includeNextUrl, fetchedSegments, rootTree = updatedTree, canonicalUrl } = param;</span>
    <span class="s1">const </span><span class="s0">[, parallelRoutes, refetchPath, refetchMarker] = updatedTree;</span>
    <span class="s1">const </span><span class="s0">fetchPromises = [];</span>
    <span class="s1">if </span><span class="s0">(refetchPath &amp;&amp; refetchPath !== canonicalUrl &amp;&amp; refetchMarker === </span><span class="s2">'refresh' </span><span class="s0">&amp;&amp; </span><span class="s3">// it's possible for the tree to contain multiple segments that contain data at the same URL</span>
    <span class="s3">// we keep track of them so we can dedupe the requests</span>
    <span class="s0">!fetchedSegments.has(refetchPath)) {</span>
        <span class="s0">fetchedSegments.add(refetchPath) </span><span class="s3">// Mark this URL as fetched</span>
        <span class="s0">;</span>
        <span class="s3">// Eagerly kick off the fetch for the refetch path &amp; the parallel routes. This should be fine to do as they each operate</span>
        <span class="s3">// independently on their own cache nodes, and `applyFlightData` will copy anything it doesn't care about from the existing cache.</span>
        <span class="s1">const </span><span class="s0">fetchPromise = (</span><span class="s4">0</span><span class="s0">, _fetchserverresponse.fetchServerResponse)(</span><span class="s1">new </span><span class="s0">URL(refetchPath, location.origin), {</span>
            <span class="s3">// refetch from the root of the updated tree, otherwise it will be scoped to the current segment</span>
            <span class="s3">// and might not contain the data we need to patch in interception route data (such as dynamic params from a previous segment)</span>
            <span class="s0">flightRouterState: [</span>
                <span class="s0">rootTree[</span><span class="s4">0</span><span class="s0">],</span>
                <span class="s0">rootTree[</span><span class="s4">1</span><span class="s0">],</span>
                <span class="s0">rootTree[</span><span class="s4">2</span><span class="s0">],</span>
                <span class="s2">'refetch'</span>
            <span class="s0">],</span>
            <span class="s0">nextUrl: includeNextUrl ? state.nextUrl : </span><span class="s1">null</span>
        <span class="s0">}).then((param)=&gt;{</span>
            <span class="s1">let </span><span class="s0">{ flightData } = param;</span>
            <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">flightData !== </span><span class="s2">'string'</span><span class="s0">) {</span>
                <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">flightDataPath of flightData){</span>
                    <span class="s3">// we only pass the new cache as this function is called after clearing the router cache</span>
                    <span class="s3">// and filling in the new page data from the server. Meaning the existing cache is actually the cache that's</span>
                    <span class="s3">// just been created &amp; has been written to, but hasn't been &quot;committed&quot; yet.</span>
                    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _applyflightdata.applyFlightData)(navigatedAt, updatedCache, updatedCache, flightDataPath);</span>
                <span class="s0">}</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s3">// When flightData is a string, it suggests that the server response should have triggered an MPA navigation</span>
            <span class="s3">// I'm not 100% sure of this decision, but it seems unlikely that we'd want to introduce a redirect side effect</span>
            <span class="s3">// when refreshing on-screen data, so handling this has been ommitted.</span>
            <span class="s0">}</span>
        <span class="s0">});</span>
        <span class="s0">fetchPromises.push(fetchPromise);</span>
    <span class="s0">}</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in </span><span class="s0">parallelRoutes){</span>
        <span class="s1">const </span><span class="s0">parallelFetchPromise = refreshInactiveParallelSegmentsImpl({</span>
            <span class="s0">navigatedAt,</span>
            <span class="s0">state,</span>
            <span class="s0">updatedTree: parallelRoutes[key],</span>
            <span class="s0">updatedCache,</span>
            <span class="s0">includeNextUrl,</span>
            <span class="s0">fetchedSegments,</span>
            <span class="s0">rootTree,</span>
            <span class="s0">canonicalUrl</span>
        <span class="s0">});</span>
        <span class="s0">fetchPromises.push(parallelFetchPromise);</span>
    <span class="s0">}</span>
    <span class="s1">await </span><span class="s0">Promise.all(fetchPromises);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">addRefreshMarkerToActiveParallelSegments(tree, path) {</span>
    <span class="s1">const </span><span class="s0">[segment, parallelRoutes, , refetchMarker] = tree;</span>
    <span class="s3">// a page segment might also contain concatenated search params, so we do a partial match on the key</span>
    <span class="s1">if </span><span class="s0">(segment.includes(_segment.PAGE_SEGMENT_KEY) &amp;&amp; refetchMarker !== </span><span class="s2">'refresh'</span><span class="s0">) {</span>
        <span class="s0">tree[</span><span class="s4">2</span><span class="s0">] = path;</span>
        <span class="s0">tree[</span><span class="s4">3</span><span class="s0">] = </span><span class="s2">'refresh'</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in </span><span class="s0">parallelRoutes){</span>
        <span class="s0">addRefreshMarkerToActiveParallelSegments(parallelRoutes[key], path);</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=refetch-inactive-parallel-segments.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;applyRouterStatePatchToTree&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">applyRouterStatePatchToTree;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_segment = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/segment.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_flightdatahelpers = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/flight-data-helpers.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_matchsegments = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/match-segments.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_refetchinactiveparallelsegments = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s3">/**</span>
 <span class="s3">* Deep merge of the two router states. Parallel route keys are preserved if the patch doesn't have them.</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">applyPatch(initialTree, patchTree) {</span>
    <span class="s1">const </span><span class="s0">[initialSegment, initialParallelRoutes] = initialTree;</span>
    <span class="s1">const </span><span class="s0">[patchSegment, patchParallelRoutes] = patchTree;</span>
    <span class="s3">// if the applied patch segment is __DEFAULT__ then it can be ignored in favor of the initial tree</span>
    <span class="s3">// this is because the __DEFAULT__ segment is used as a placeholder on navigation</span>
    <span class="s1">if </span><span class="s0">(patchSegment === _segment.DEFAULT_SEGMENT_KEY &amp;&amp; initialSegment !== _segment.DEFAULT_SEGMENT_KEY) {</span>
        <span class="s1">return </span><span class="s0">initialTree;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">((</span><span class="s4">0</span><span class="s0">, _matchsegments.matchSegment)(initialSegment, patchSegment)) {</span>
        <span class="s1">const </span><span class="s0">newParallelRoutes = {};</span>
        <span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in </span><span class="s0">initialParallelRoutes){</span>
            <span class="s1">const </span><span class="s0">isInPatchTreeParallelRoutes = </span><span class="s1">typeof </span><span class="s0">patchParallelRoutes[key] !== </span><span class="s2">'undefined'</span><span class="s0">;</span>
            <span class="s1">if </span><span class="s0">(isInPatchTreeParallelRoutes) {</span>
                <span class="s0">newParallelRoutes[key] = applyPatch(initialParallelRoutes[key], patchParallelRoutes[key]);</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">newParallelRoutes[key] = initialParallelRoutes[key];</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in </span><span class="s0">patchParallelRoutes){</span>
            <span class="s1">if </span><span class="s0">(newParallelRoutes[key]) {</span>
                <span class="s1">continue</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s0">newParallelRoutes[key] = patchParallelRoutes[key];</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">tree = [</span>
            <span class="s0">initialSegment,</span>
            <span class="s0">newParallelRoutes</span>
        <span class="s0">];</span>
        <span class="s3">// Copy over the existing tree</span>
        <span class="s1">if </span><span class="s0">(initialTree[</span><span class="s4">2</span><span class="s0">]) {</span>
            <span class="s0">tree[</span><span class="s4">2</span><span class="s0">] = initialTree[</span><span class="s4">2</span><span class="s0">];</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(initialTree[</span><span class="s4">3</span><span class="s0">]) {</span>
            <span class="s0">tree[</span><span class="s4">3</span><span class="s0">] = initialTree[</span><span class="s4">3</span><span class="s0">];</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(initialTree[</span><span class="s4">4</span><span class="s0">]) {</span>
            <span class="s0">tree[</span><span class="s4">4</span><span class="s0">] = initialTree[</span><span class="s4">4</span><span class="s0">];</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">tree;</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">patchTree;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">applyRouterStatePatchToTree(flightSegmentPath, flightRouterState, treePatch, path) {</span>
    <span class="s1">const </span><span class="s0">[segment, parallelRoutes, url, refetch, isRootLayout] = flightRouterState;</span>
    <span class="s3">// Root refresh</span>
    <span class="s1">if </span><span class="s0">(flightSegmentPath.length === </span><span class="s4">1</span><span class="s0">) {</span>
        <span class="s1">const </span><span class="s0">tree = applyPatch(flightRouterState, treePatch);</span>
        <span class="s0">(</span><span class="s4">0</span><span class="s0">, _refetchinactiveparallelsegments.addRefreshMarkerToActiveParallelSegments)(tree, path);</span>
        <span class="s1">return </span><span class="s0">tree;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">[currentSegment, parallelRouteKey] = flightSegmentPath;</span>
    <span class="s3">// Tree path returned from the server should always match up with the current tree in the browser</span>
    <span class="s1">if </span><span class="s0">(!(</span><span class="s4">0</span><span class="s0">, _matchsegments.matchSegment)(currentSegment, segment)) {</span>
        <span class="s1">return null</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">lastSegment = flightSegmentPath.length === </span><span class="s4">2</span><span class="s0">;</span>
    <span class="s1">let </span><span class="s0">parallelRoutePatch;</span>
    <span class="s1">if </span><span class="s0">(lastSegment) {</span>
        <span class="s0">parallelRoutePatch = applyPatch(parallelRoutes[parallelRouteKey], treePatch);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">parallelRoutePatch = applyRouterStatePatchToTree((</span><span class="s4">0</span><span class="s0">, _flightdatahelpers.getNextFlightSegmentPath)(flightSegmentPath), parallelRoutes[parallelRouteKey], treePatch, path);</span>
        <span class="s1">if </span><span class="s0">(parallelRoutePatch === </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s1">return null</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">tree = [</span>
        <span class="s0">flightSegmentPath[</span><span class="s4">0</span><span class="s0">],</span>
        <span class="s0">{</span>
            <span class="s0">...parallelRoutes,</span>
            <span class="s0">[parallelRouteKey]: parallelRoutePatch</span>
        <span class="s0">},</span>
        <span class="s0">url,</span>
        <span class="s0">refetch</span>
    <span class="s0">];</span>
    <span class="s3">// Current segment is the root layout</span>
    <span class="s1">if </span><span class="s0">(isRootLayout) {</span>
        <span class="s0">tree[</span><span class="s4">4</span><span class="s0">] = </span><span class="s1">true</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _refetchinactiveparallelsegments.addRefreshMarkerToActiveParallelSegments)(tree, path);</span>
    <span class="s1">return </span><span class="s0">tree;</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=apply-router-state-patch-to-tree.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/should-hard-navigate.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;shouldHardNavigate&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">shouldHardNavigate;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_flightdatahelpers = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/flight-data-helpers.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_matchsegments = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/match-segments.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">shouldHardNavigate(flightSegmentPath, flightRouterState) {</span>
    <span class="s1">const </span><span class="s0">[segment, parallelRoutes] = flightRouterState;</span>
    <span class="s3">// TODO-APP: Check if `as` can be replaced.</span>
    <span class="s1">const </span><span class="s0">[currentSegment, parallelRouteKey] = flightSegmentPath;</span>
    <span class="s3">// Check if current segment matches the existing segment.</span>
    <span class="s1">if </span><span class="s0">(!(</span><span class="s4">0</span><span class="s0">, _matchsegments.matchSegment)(currentSegment, segment)) {</span>
        <span class="s3">// If dynamic parameter in tree doesn't match up with segment path a hard navigation is triggered.</span>
        <span class="s1">if </span><span class="s0">(Array.isArray(currentSegment)) {</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s3">// If the existing segment did not match soft navigation is triggered.</span>
        <span class="s1">return false</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">lastSegment = flightSegmentPath.length &lt;= </span><span class="s4">2</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(lastSegment) {</span>
        <span class="s1">return false</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">shouldHardNavigate((</span><span class="s4">0</span><span class="s0">, _flightdatahelpers.getNextFlightSegmentPath)(flightSegmentPath), parallelRoutes[parallelRouteKey]);</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=should-hard-navigate.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;isNavigatingToNewRootLayout&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">isNavigatingToNewRootLayout;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">isNavigatingToNewRootLayout(currentTree, nextTree) {</span>
    <span class="s3">// Compare segments</span>
    <span class="s1">const </span><span class="s0">currentTreeSegment = currentTree[</span><span class="s4">0</span><span class="s0">];</span>
    <span class="s1">const </span><span class="s0">nextTreeSegment = nextTree[</span><span class="s4">0</span><span class="s0">];</span>
    <span class="s3">// If any segment is different before we find the root layout, the root layout has changed.</span>
    <span class="s3">// E.g. /same/(group1)/layout.js -&gt; /same/(group2)/layout.js</span>
    <span class="s3">// First segment is 'same' for both, keep looking. (group1) changed to (group2) before the root layout was found, it must have changed.</span>
    <span class="s1">if </span><span class="s0">(Array.isArray(currentTreeSegment) &amp;&amp; Array.isArray(nextTreeSegment)) {</span>
        <span class="s3">// Compare dynamic param name and type but ignore the value, different values would not affect the current root layout</span>
        <span class="s3">// /[name] - /slug1 and /slug2, both values (slug1 &amp; slug2) still has the same layout /[name]/layout.js</span>
        <span class="s1">if </span><span class="s0">(currentTreeSegment[</span><span class="s4">0</span><span class="s0">] !== nextTreeSegment[</span><span class="s4">0</span><span class="s0">] || currentTreeSegment[</span><span class="s4">2</span><span class="s0">] !== nextTreeSegment[</span><span class="s4">2</span><span class="s0">]) {</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(currentTreeSegment !== nextTreeSegment) {</span>
        <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s3">// Current tree root layout found</span>
    <span class="s1">if </span><span class="s0">(currentTree[</span><span class="s4">4</span><span class="s0">]) {</span>
        <span class="s3">// If the next tree doesn't have the root layout flag, it must have changed.</span>
        <span class="s1">return </span><span class="s0">!nextTree[</span><span class="s4">4</span><span class="s0">];</span>
    <span class="s0">}</span>
    <span class="s3">// Current tree didn't have its root layout here, must have changed.</span>
    <span class="s1">if </span><span class="s0">(nextTree[</span><span class="s4">4</span><span class="s0">]) {</span>
        <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s3">// We can't assume it's `parallelRoutes.children` here in case the root layout is `app/@something/layout.js`</span>
    <span class="s3">// But it's not possible to be more than one parallelRoutes before the root layout is found</span>
    <span class="s3">// TODO-APP: change to traverse all parallel routes</span>
    <span class="s1">const </span><span class="s0">currentTreeChild = Object.values(currentTree[</span><span class="s4">1</span><span class="s0">])[</span><span class="s4">0</span><span class="s0">];</span>
    <span class="s1">const </span><span class="s0">nextTreeChild = Object.values(nextTree[</span><span class="s4">1</span><span class="s0">])[</span><span class="s4">0</span><span class="s0">];</span>
    <span class="s1">if </span><span class="s0">(!currentTreeChild || !nextTreeChild) </span><span class="s1">return true</span><span class="s0">;</span>
    <span class="s1">return </span><span class="s0">isNavigatingToNewRootLayout(currentTreeChild, nextTreeChild);</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=is-navigating-to-new-root-layout.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/compute-changed-path.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s0">computeChangedPath: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">extractPathFromFlightRouterState: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">getSelectedParams: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s0">computeChangedPath: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">computeChangedPath;</span>
    <span class="s0">},</span>
    <span class="s0">extractPathFromFlightRouterState: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">extractPathFromFlightRouterState;</span>
    <span class="s0">},</span>
    <span class="s0">getSelectedParams: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">getSelectedParams;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_interceptionroutes = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/router/utils/interception-routes.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_segment = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/segment.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_matchsegments = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/match-segments.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">removeLeadingSlash = (segment)=&gt;{</span>
    <span class="s1">return </span><span class="s0">segment[</span><span class="s4">0</span><span class="s0">] === </span><span class="s2">'/' </span><span class="s0">? segment.slice(</span><span class="s4">1</span><span class="s0">) : segment;</span>
<span class="s0">};</span>
<span class="s1">const </span><span class="s0">segmentToPathname = (segment)=&gt;{</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">segment === </span><span class="s2">'string'</span><span class="s0">) {</span>
        <span class="s3">// 'children' is not a valid path -- it's technically a parallel route that corresponds with the current segment's page</span>
        <span class="s3">// if we don't skip it, then the computed pathname might be something like `/children` which doesn't make sense.</span>
        <span class="s1">if </span><span class="s0">(segment === </span><span class="s2">'children'</span><span class="s0">) </span><span class="s1">return </span><span class="s2">''</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">segment;</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">segment[</span><span class="s4">1</span><span class="s0">];</span>
<span class="s0">};</span>
<span class="s1">function </span><span class="s0">normalizeSegments(segments) {</span>
    <span class="s1">return </span><span class="s0">segments.reduce((acc, segment)=&gt;{</span>
        <span class="s0">segment = removeLeadingSlash(segment);</span>
        <span class="s1">if </span><span class="s0">(segment === </span><span class="s2">'' </span><span class="s0">|| (</span><span class="s4">0</span><span class="s0">, _segment.isGroupSegment)(segment)) {</span>
            <span class="s1">return </span><span class="s0">acc;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">acc + </span><span class="s2">&quot;/&quot; </span><span class="s0">+ segment;</span>
    <span class="s0">}, </span><span class="s2">''</span><span class="s0">) || </span><span class="s2">'/'</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">extractPathFromFlightRouterState(flightRouterState) {</span>
    <span class="s1">const </span><span class="s0">segment = Array.isArray(flightRouterState[</span><span class="s4">0</span><span class="s0">]) ? flightRouterState[</span><span class="s4">0</span><span class="s0">][</span><span class="s4">1</span><span class="s0">] : flightRouterState[</span><span class="s4">0</span><span class="s0">];</span>
    <span class="s1">if </span><span class="s0">(segment === _segment.DEFAULT_SEGMENT_KEY || _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some((m)=&gt;segment.startsWith(m))) </span><span class="s1">return </span><span class="s0">undefined;</span>
    <span class="s1">if </span><span class="s0">(segment.startsWith(_segment.PAGE_SEGMENT_KEY)) </span><span class="s1">return </span><span class="s2">''</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">segments = [</span>
        <span class="s0">segmentToPathname(segment)</span>
    <span class="s0">];</span>
    <span class="s1">var </span><span class="s0">_flightRouterState_;</span>
    <span class="s1">const </span><span class="s0">parallelRoutes = (_flightRouterState_ = flightRouterState[</span><span class="s4">1</span><span class="s0">]) != </span><span class="s1">null </span><span class="s0">? _flightRouterState_ : {};</span>
    <span class="s1">const </span><span class="s0">childrenPath = parallelRoutes.children ? extractPathFromFlightRouterState(parallelRoutes.children) : undefined;</span>
    <span class="s1">if </span><span class="s0">(childrenPath !== undefined) {</span>
        <span class="s0">segments.push(childrenPath);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">[key, value] of Object.entries(parallelRoutes)){</span>
            <span class="s1">if </span><span class="s0">(key === </span><span class="s2">'children'</span><span class="s0">) </span><span class="s1">continue</span><span class="s0">;</span>
            <span class="s1">const </span><span class="s0">childPath = extractPathFromFlightRouterState(value);</span>
            <span class="s1">if </span><span class="s0">(childPath !== undefined) {</span>
                <span class="s0">segments.push(childPath);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">normalizeSegments(segments);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">computeChangedPathImpl(treeA, treeB) {</span>
    <span class="s1">const </span><span class="s0">[segmentA, parallelRoutesA] = treeA;</span>
    <span class="s1">const </span><span class="s0">[segmentB, parallelRoutesB] = treeB;</span>
    <span class="s1">const </span><span class="s0">normalizedSegmentA = segmentToPathname(segmentA);</span>
    <span class="s1">const </span><span class="s0">normalizedSegmentB = segmentToPathname(segmentB);</span>
    <span class="s1">if </span><span class="s0">(_interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some((m)=&gt;normalizedSegmentA.startsWith(m) || normalizedSegmentB.startsWith(m))) {</span>
        <span class="s1">return </span><span class="s2">''</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(!(</span><span class="s4">0</span><span class="s0">, _matchsegments.matchSegment)(segmentA, segmentB)) {</span>
        <span class="s1">var </span><span class="s0">_extractPathFromFlightRouterState;</span>
        <span class="s3">// once we find where the tree changed, we compute the rest of the path by traversing the tree</span>
        <span class="s1">return </span><span class="s0">(_extractPathFromFlightRouterState = extractPathFromFlightRouterState(treeB)) != </span><span class="s1">null </span><span class="s0">? _extractPathFromFlightRouterState : </span><span class="s2">''</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">parallelRouterKey </span><span class="s1">in </span><span class="s0">parallelRoutesA){</span>
        <span class="s1">if </span><span class="s0">(parallelRoutesB[parallelRouterKey]) {</span>
            <span class="s1">const </span><span class="s0">changedPath = computeChangedPathImpl(parallelRoutesA[parallelRouterKey], parallelRoutesB[parallelRouterKey]);</span>
            <span class="s1">if </span><span class="s0">(changedPath !== </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s1">return </span><span class="s0">segmentToPathname(segmentB) + </span><span class="s2">&quot;/&quot; </span><span class="s0">+ changedPath;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">return null</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">computeChangedPath(treeA, treeB) {</span>
    <span class="s1">const </span><span class="s0">changedPath = computeChangedPathImpl(treeA, treeB);</span>
    <span class="s1">if </span><span class="s0">(changedPath == </span><span class="s1">null </span><span class="s0">|| changedPath === </span><span class="s2">'/'</span><span class="s0">) {</span>
        <span class="s1">return </span><span class="s0">changedPath;</span>
    <span class="s0">}</span>
    <span class="s3">// lightweight normalization to remove route groups</span>
    <span class="s1">return </span><span class="s0">normalizeSegments(changedPath.split(</span><span class="s2">'/'</span><span class="s0">));</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">getSelectedParams(currentTree, params) {</span>
    <span class="s1">if </span><span class="s0">(params === </span><span class="s1">void </span><span class="s4">0</span><span class="s0">) params = {};</span>
    <span class="s1">const </span><span class="s0">parallelRoutes = currentTree[</span><span class="s4">1</span><span class="s0">];</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">parallelRoute of Object.values(parallelRoutes)){</span>
        <span class="s1">const </span><span class="s0">segment = parallelRoute[</span><span class="s4">0</span><span class="s0">];</span>
        <span class="s1">const </span><span class="s0">isDynamicParameter = Array.isArray(segment);</span>
        <span class="s1">const </span><span class="s0">segmentValue = isDynamicParameter ? segment[</span><span class="s4">1</span><span class="s0">] : segment;</span>
        <span class="s1">if </span><span class="s0">(!segmentValue || segmentValue.startsWith(_segment.PAGE_SEGMENT_KEY)) </span><span class="s1">continue</span><span class="s0">;</span>
        <span class="s3">// Ensure catchAll and optional catchall are turned into an array</span>
        <span class="s1">const </span><span class="s0">isCatchAll = isDynamicParameter &amp;&amp; (segment[</span><span class="s4">2</span><span class="s0">] === </span><span class="s2">'c' </span><span class="s0">|| segment[</span><span class="s4">2</span><span class="s0">] === </span><span class="s2">'oc'</span><span class="s0">);</span>
        <span class="s1">if </span><span class="s0">(isCatchAll) {</span>
            <span class="s0">params[segment[</span><span class="s4">0</span><span class="s0">]] = segment[</span><span class="s4">1</span><span class="s0">].split(</span><span class="s2">'/'</span><span class="s0">);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(isDynamicParameter) {</span>
            <span class="s0">params[segment[</span><span class="s4">0</span><span class="s0">]] = segment[</span><span class="s4">1</span><span class="s0">];</span>
        <span class="s0">}</span>
        <span class="s0">params = getSelectedParams(parallelRoute, params);</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">params;</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=compute-changed-path.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/handle-mutable.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;handleMutable&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">handleMutable;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_computechangedpath = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/compute-changed-path.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">isNotUndefined(value) {</span>
    <span class="s1">return typeof </span><span class="s0">value !== </span><span class="s2">'undefined'</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">handleMutable(state, mutable) {</span>
    <span class="s1">var </span><span class="s0">_mutable_shouldScroll;</span>
    <span class="s3">// shouldScroll is true by default, can override to false.</span>
    <span class="s1">const </span><span class="s0">shouldScroll = (_mutable_shouldScroll = mutable.shouldScroll) != </span><span class="s1">null </span><span class="s0">? _mutable_shouldScroll : </span><span class="s1">true</span><span class="s0">;</span>
    <span class="s1">let </span><span class="s0">nextUrl = state.nextUrl;</span>
    <span class="s1">if </span><span class="s0">(isNotUndefined(mutable.patchedTree)) {</span>
        <span class="s3">// If we received a patched tree, we need to compute the changed path.</span>
        <span class="s1">const </span><span class="s0">changedPath = (</span><span class="s4">0</span><span class="s0">, _computechangedpath.computeChangedPath)(state.tree, mutable.patchedTree);</span>
        <span class="s1">if </span><span class="s0">(changedPath) {</span>
            <span class="s3">// If the tree changed, we need to update the nextUrl</span>
            <span class="s0">nextUrl = changedPath;</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(!nextUrl) {</span>
            <span class="s3">// if the tree ends up being the same (ie, no changed path), and we don't have a nextUrl, then we should use the canonicalUrl</span>
            <span class="s0">nextUrl = state.canonicalUrl;</span>
        <span class="s0">}</span>
    <span class="s3">// otherwise this will be a no-op and continue to use the existing nextUrl</span>
    <span class="s0">}</span>
    <span class="s1">var </span><span class="s0">_mutable_scrollableSegments;</span>
    <span class="s1">return </span><span class="s0">{</span>
        <span class="s3">// Set href.</span>
        <span class="s0">canonicalUrl: isNotUndefined(mutable.canonicalUrl) ? mutable.canonicalUrl === state.canonicalUrl ? state.canonicalUrl : mutable.canonicalUrl : state.canonicalUrl,</span>
        <span class="s0">pushRef: {</span>
            <span class="s0">pendingPush: isNotUndefined(mutable.pendingPush) ? mutable.pendingPush : state.pushRef.pendingPush,</span>
            <span class="s0">mpaNavigation: isNotUndefined(mutable.mpaNavigation) ? mutable.mpaNavigation : state.pushRef.mpaNavigation,</span>
            <span class="s0">preserveCustomHistoryState: isNotUndefined(mutable.preserveCustomHistoryState) ? mutable.preserveCustomHistoryState : state.pushRef.preserveCustomHistoryState</span>
        <span class="s0">},</span>
        <span class="s3">// All navigation requires scroll and focus management to trigger.</span>
        <span class="s0">focusAndScrollRef: {</span>
            <span class="s0">apply: shouldScroll ? isNotUndefined(mutable == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: mutable.scrollableSegments) ? </span><span class="s1">true </span><span class="s0">: state.focusAndScrollRef.apply : </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">onlyHashChange: mutable.onlyHashChange || </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">hashFragment: shouldScroll ? mutable.hashFragment &amp;&amp; mutable.hashFragment !== </span><span class="s2">'' </span><span class="s0">? decodeURIComponent(mutable.hashFragment.slice(</span><span class="s4">1</span><span class="s0">)) : state.focusAndScrollRef.hashFragment : </span><span class="s1">null</span><span class="s0">,</span>
            <span class="s0">segmentPaths: shouldScroll ? (_mutable_scrollableSegments = mutable == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: mutable.scrollableSegments) != </span><span class="s1">null </span><span class="s0">? _mutable_scrollableSegments : state.focusAndScrollRef.segmentPaths : []</span>
        <span class="s0">},</span>
        <span class="s3">// Apply cache.</span>
        <span class="s0">cache: mutable.cache ? mutable.cache : state.cache,</span>
        <span class="s0">prefetchCache: mutable.prefetchCache ? mutable.prefetchCache : state.prefetchCache,</span>
        <span class="s3">// Apply patched router state.</span>
        <span class="s0">tree: isNotUndefined(mutable.patchedTree) ? mutable.patchedTree : state.tree,</span>
        <span class="s0">nextUrl</span>
    <span class="s0">};</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=handle-mutable.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/promise-queue.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s3">/* 
    This is a simple promise queue that allows you to limit the number of concurrent promises 
    that are running at any given time. It's used to limit the number of concurrent 
    prefetch requests that are being made to the server but could be used for other 
    things as well. 
*/ </span><span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;PromiseQueue&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">PromiseQueue;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_class_private_field_loose_base = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/@swc/helpers/cjs/_class_private_field_loose_base.cjs [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_class_private_field_loose_key = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/@swc/helpers/cjs/_class_private_field_loose_key.cjs [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">var </span><span class="s0">_maxConcurrency = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">_class_private_field_loose_key._(</span><span class="s2">&quot;_maxConcurrency&quot;</span><span class="s0">), _runningCount = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">_class_private_field_loose_key._(</span><span class="s2">&quot;_runningCount&quot;</span><span class="s0">), _queue = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">_class_private_field_loose_key._(</span><span class="s2">&quot;_queue&quot;</span><span class="s0">), _processNext = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">_class_private_field_loose_key._(</span><span class="s2">&quot;_processNext&quot;</span><span class="s0">);</span>
<span class="s1">class </span><span class="s0">PromiseQueue {</span>
    <span class="s0">enqueue(promiseFn) {</span>
        <span class="s1">let </span><span class="s0">taskResolve;</span>
        <span class="s1">let </span><span class="s0">taskReject;</span>
        <span class="s1">const </span><span class="s0">taskPromise = </span><span class="s1">new </span><span class="s0">Promise((resolve, reject)=&gt;{</span>
            <span class="s0">taskResolve = resolve;</span>
            <span class="s0">taskReject = reject;</span>
        <span class="s0">});</span>
        <span class="s1">const </span><span class="s0">task = async ()=&gt;{</span>
            <span class="s1">try </span><span class="s0">{</span>
                <span class="s0">_class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _runningCount)[_runningCount]++;</span>
                <span class="s1">const </span><span class="s0">result = </span><span class="s1">await </span><span class="s0">promiseFn();</span>
                <span class="s0">taskResolve(result);</span>
            <span class="s0">} </span><span class="s1">catch </span><span class="s0">(error) {</span>
                <span class="s0">taskReject(error);</span>
            <span class="s0">} </span><span class="s1">finally</span><span class="s0">{</span>
                <span class="s0">_class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _runningCount)[_runningCount]--;</span>
                <span class="s0">_class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _processNext)[_processNext]();</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
        <span class="s1">const </span><span class="s0">enqueueResult = {</span>
            <span class="s0">promiseFn: taskPromise,</span>
            <span class="s0">task</span>
        <span class="s0">};</span>
        <span class="s3">// wonder if we should take a LIFO approach here</span>
        <span class="s0">_class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _queue)[_queue].push(enqueueResult);</span>
        <span class="s0">_class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _processNext)[_processNext]();</span>
        <span class="s1">return </span><span class="s0">taskPromise;</span>
    <span class="s0">}</span>
    <span class="s0">bump(promiseFn) {</span>
        <span class="s1">const </span><span class="s0">index = _class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _queue)[_queue].findIndex((item)=&gt;item.promiseFn === promiseFn);</span>
        <span class="s1">if </span><span class="s0">(index &gt; -</span><span class="s4">1</span><span class="s0">) {</span>
            <span class="s1">const </span><span class="s0">bumpedItem = _class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _queue)[_queue].splice(index, </span><span class="s4">1</span><span class="s0">)[</span><span class="s4">0</span><span class="s0">];</span>
            <span class="s0">_class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _queue)[_queue].unshift(bumpedItem);</span>
            <span class="s0">_class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _processNext)[_processNext](</span><span class="s1">true</span><span class="s0">);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">constructor(maxConcurrency = </span><span class="s4">5</span><span class="s0">){</span>
        <span class="s0">Object.defineProperty(</span><span class="s1">this</span><span class="s0">, _processNext, {</span>
            <span class="s0">value: processNext</span>
        <span class="s0">});</span>
        <span class="s0">Object.defineProperty(</span><span class="s1">this</span><span class="s0">, _maxConcurrency, {</span>
            <span class="s0">writable: </span><span class="s1">true</span><span class="s0">,</span>
            <span class="s0">value: </span><span class="s1">void </span><span class="s4">0</span>
        <span class="s0">});</span>
        <span class="s0">Object.defineProperty(</span><span class="s1">this</span><span class="s0">, _runningCount, {</span>
            <span class="s0">writable: </span><span class="s1">true</span><span class="s0">,</span>
            <span class="s0">value: </span><span class="s1">void </span><span class="s4">0</span>
        <span class="s0">});</span>
        <span class="s0">Object.defineProperty(</span><span class="s1">this</span><span class="s0">, _queue, {</span>
            <span class="s0">writable: </span><span class="s1">true</span><span class="s0">,</span>
            <span class="s0">value: </span><span class="s1">void </span><span class="s4">0</span>
        <span class="s0">});</span>
        <span class="s0">_class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _maxConcurrency)[_maxConcurrency] = maxConcurrency;</span>
        <span class="s0">_class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _runningCount)[_runningCount] = </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s0">_class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _queue)[_queue] = [];</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">processNext(forced) {</span>
    <span class="s1">if </span><span class="s0">(forced === </span><span class="s1">void </span><span class="s4">0</span><span class="s0">) forced = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">((_class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _runningCount)[_runningCount] &lt; _class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _maxConcurrency)[_maxConcurrency] || forced) &amp;&amp; _class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _queue)[_queue].length &gt; </span><span class="s4">0</span><span class="s0">) {</span>
        <span class="s1">var </span><span class="s0">_class_private_field_loose_base__queue_shift;</span>
        <span class="s0">(_class_private_field_loose_base__queue_shift = _class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _queue)[_queue].shift()) == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: _class_private_field_loose_base__queue_shift.task();</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=promise-queue.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s0">DYNAMIC_STALETIME_MS: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">STATIC_STALETIME_MS: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">createSeededPrefetchCacheEntry: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">getOrCreatePrefetchCacheEntry: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">prunePrefetchCache: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s0">DYNAMIC_STALETIME_MS: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">DYNAMIC_STALETIME_MS;</span>
    <span class="s0">},</span>
    <span class="s0">STATIC_STALETIME_MS: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">STATIC_STALETIME_MS;</span>
    <span class="s0">},</span>
    <span class="s0">createSeededPrefetchCacheEntry: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">createSeededPrefetchCacheEntry;</span>
    <span class="s0">},</span>
    <span class="s0">getOrCreatePrefetchCacheEntry: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">getOrCreatePrefetchCacheEntry;</span>
    <span class="s0">},</span>
    <span class="s0">prunePrefetchCache: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">prunePrefetchCache;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_fetchserverresponse = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/fetch-server-response.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_routerreducertypes = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_prefetchreducer = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">INTERCEPTION_CACHE_KEY_MARKER = </span><span class="s2">'%'</span><span class="s0">;</span>
<span class="s3">/**</span>
 <span class="s3">* Creates a cache key for the router prefetch cache</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s5">@param </span><span class="s3">url - The URL being navigated to</span>
 <span class="s3">* </span><span class="s5">@param </span><span class="s3">nextUrl - an internal URL, primarily used for handling rewrites. Defaults to '/'.</span>
 <span class="s3">* </span><span class="s5">@return </span><span class="s3">The generated prefetch cache key.</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">createPrefetchCacheKeyImpl(url, includeSearchParams, prefix) {</span>
    <span class="s3">// Initially we only use the pathname as the cache key. We don't want to include</span>
    <span class="s3">// search params so that multiple URLs with the same search parameter can re-use</span>
    <span class="s3">// loading states.</span>
    <span class="s1">let </span><span class="s0">pathnameFromUrl = url.pathname;</span>
    <span class="s3">// RSC responses can differ based on search params, specifically in the case where we aren't</span>
    <span class="s3">// returning a partial response (ie with `PrefetchKind.AUTO`).</span>
    <span class="s3">// In the auto case, since loading.js &amp; layout.js won't have access to search params,</span>
    <span class="s3">// we can safely re-use that cache entry. But for full prefetches, we should not</span>
    <span class="s3">// re-use the cache entry as the response may differ.</span>
    <span class="s1">if </span><span class="s0">(includeSearchParams) {</span>
        <span class="s3">// if we have a full prefetch, we can include the search param in the key,</span>
        <span class="s3">// as we'll be getting back a full response. The server might have read the search</span>
        <span class="s3">// params when generating the full response.</span>
        <span class="s0">pathnameFromUrl += url.search;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(prefix) {</span>
        <span class="s1">return </span><span class="s2">&quot;&quot; </span><span class="s0">+ prefix + INTERCEPTION_CACHE_KEY_MARKER + pathnameFromUrl;</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">pathnameFromUrl;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">createPrefetchCacheKey(url, kind, nextUrl) {</span>
    <span class="s1">return </span><span class="s0">createPrefetchCacheKeyImpl(url, kind === _routerreducertypes.PrefetchKind.FULL, nextUrl);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">getExistingCacheEntry(url, kind, nextUrl, prefetchCache, allowAliasing) {</span>
    <span class="s1">if </span><span class="s0">(kind === </span><span class="s1">void </span><span class="s4">0</span><span class="s0">) kind = _routerreducertypes.PrefetchKind.TEMPORARY;</span>
    <span class="s3">// We first check if there's a more specific interception route prefetch entry</span>
    <span class="s3">// This is because when we detect a prefetch that corresponds with an interception route, we prefix it with nextUrl (see `createPrefetchCacheKey`)</span>
    <span class="s3">// to avoid conflicts with other pages that may have the same URL but render different things depending on the `Next-URL` header.</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">maybeNextUrl of [</span>
        <span class="s0">nextUrl,</span>
        <span class="s1">null</span>
    <span class="s0">]){</span>
        <span class="s1">const </span><span class="s0">cacheKeyWithParams = createPrefetchCacheKeyImpl(url, </span><span class="s1">true</span><span class="s0">, maybeNextUrl);</span>
        <span class="s1">const </span><span class="s0">cacheKeyWithoutParams = createPrefetchCacheKeyImpl(url, </span><span class="s1">false</span><span class="s0">, maybeNextUrl);</span>
        <span class="s3">// First, we check if we have a cache entry that exactly matches the URL</span>
        <span class="s1">const </span><span class="s0">cacheKeyToUse = url.search ? cacheKeyWithParams : cacheKeyWithoutParams;</span>
        <span class="s1">const </span><span class="s0">existingEntry = prefetchCache.get(cacheKeyToUse);</span>
        <span class="s1">if </span><span class="s0">(existingEntry &amp;&amp; allowAliasing) {</span>
            <span class="s3">// We know we're returning an aliased entry when the pathname matches but the search params don't,</span>
            <span class="s1">const </span><span class="s0">isAliased = existingEntry.url.pathname === url.pathname &amp;&amp; existingEntry.url.search !== url.search;</span>
            <span class="s1">if </span><span class="s0">(isAliased) {</span>
                <span class="s1">return </span><span class="s0">{</span>
                    <span class="s0">...existingEntry,</span>
                    <span class="s0">aliased: </span><span class="s1">true</span>
                <span class="s0">};</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">existingEntry;</span>
        <span class="s0">}</span>
        <span class="s3">// If the request contains search params, and we're not doing a full prefetch, we can return the</span>
        <span class="s3">// param-less entry if it exists.</span>
        <span class="s3">// This is technically covered by the check at the bottom of this function, which iterates over cache entries,</span>
        <span class="s3">// but lets us arrive there quicker in the param-full case.</span>
        <span class="s1">const </span><span class="s0">entryWithoutParams = prefetchCache.get(cacheKeyWithoutParams);</span>
        <span class="s1">if </span><span class="s0">((</span><span class="s2">&quot;TURBOPACK compile-time value&quot;</span><span class="s0">, </span><span class="s2">&quot;development&quot;</span><span class="s0">) !== </span><span class="s2">'development' </span><span class="s0">&amp;&amp; allowAliasing &amp;&amp; url.search &amp;&amp; kind !== _routerreducertypes.PrefetchKind.FULL &amp;&amp; entryWithoutParams &amp;&amp; </span><span class="s3">// We shouldn't return the aliased entry if it was relocated to a new cache key.</span>
        <span class="s3">// Since it's rewritten, it could respond with a completely different loading state.</span>
        <span class="s0">!entryWithoutParams.key.includes(INTERCEPTION_CACHE_KEY_MARKER)) </span><span class="s3">//TURBOPACK unreachable</span>
        <span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s3">// If we've gotten to this point, we didn't find a specific cache entry that matched</span>
    <span class="s3">// the request URL.</span>
    <span class="s3">// We attempt a partial match by checking if there's a cache entry with the same pathname.</span>
    <span class="s3">// Regardless of what we find, since it doesn't correspond with the requested URL, we'll mark it &quot;aliased&quot;.</span>
    <span class="s3">// This will signal to the router that it should only apply the loading state on the prefetched data.</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) </span><span class="s3">//TURBOPACK unreachable</span>
    <span class="s0">;</span>
    <span class="s1">return </span><span class="s0">undefined;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">getOrCreatePrefetchCacheEntry(param) {</span>
    <span class="s1">let </span><span class="s0">{ url, nextUrl, tree, prefetchCache, kind, allowAliasing = </span><span class="s1">true </span><span class="s0">} = param;</span>
    <span class="s1">const </span><span class="s0">existingCacheEntry = getExistingCacheEntry(url, kind, nextUrl, prefetchCache, allowAliasing);</span>
    <span class="s1">if </span><span class="s0">(existingCacheEntry) {</span>
        <span class="s3">// Grab the latest status of the cache entry and update it</span>
        <span class="s0">existingCacheEntry.status = getPrefetchEntryCacheStatus(existingCacheEntry);</span>
        <span class="s3">// when `kind` is provided, an explicit prefetch was requested.</span>
        <span class="s3">// if the requested prefetch is &quot;full&quot; and the current cache entry wasn't, we want to re-prefetch with the new intent</span>
        <span class="s1">const </span><span class="s0">switchedToFullPrefetch = existingCacheEntry.kind !== _routerreducertypes.PrefetchKind.FULL &amp;&amp; kind === _routerreducertypes.PrefetchKind.FULL;</span>
        <span class="s1">if </span><span class="s0">(switchedToFullPrefetch) {</span>
            <span class="s3">// If we switched to a full prefetch, validate that the existing cache entry contained partial data.</span>
            <span class="s3">// It's possible that the cache entry was seeded with full data but has a cache type of &quot;auto&quot; (ie when cache entries</span>
            <span class="s3">// are seeded but without a prefetch intent)</span>
            <span class="s0">existingCacheEntry.data.then((prefetchResponse)=&gt;{</span>
                <span class="s1">const </span><span class="s0">isFullPrefetch = Array.isArray(prefetchResponse.flightData) &amp;&amp; prefetchResponse.flightData.some((flightData)=&gt;{</span>
                    <span class="s3">// If we started rendering from the root and we returned RSC data (seedData), we already had a full prefetch.</span>
                    <span class="s1">return </span><span class="s0">flightData.isRootRender &amp;&amp; flightData.seedData !== </span><span class="s1">null</span><span class="s0">;</span>
                <span class="s0">});</span>
                <span class="s1">if </span><span class="s0">(!isFullPrefetch) {</span>
                    <span class="s1">return </span><span class="s0">createLazyPrefetchEntry({</span>
                        <span class="s0">tree,</span>
                        <span class="s0">url,</span>
                        <span class="s0">nextUrl,</span>
                        <span class="s0">prefetchCache,</span>
                        <span class="s3">// If we didn't get an explicit prefetch kind, we want to set a temporary kind</span>
                        <span class="s3">// rather than assuming the same intent as the previous entry, to be consistent with how we</span>
                        <span class="s3">// lazily create prefetch entries when intent is left unspecified.</span>
                        <span class="s0">kind: kind != </span><span class="s1">null </span><span class="s0">? kind : _routerreducertypes.PrefetchKind.TEMPORARY</span>
                    <span class="s0">});</span>
                <span class="s0">}</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s3">// If the existing cache entry was marked as temporary, it means it was lazily created when attempting to get an entry,</span>
        <span class="s3">// where we didn't have the prefetch intent. Now that we have the intent (in `kind`), we want to update the entry to the more accurate kind.</span>
        <span class="s1">if </span><span class="s0">(kind &amp;&amp; existingCacheEntry.kind === _routerreducertypes.PrefetchKind.TEMPORARY) {</span>
            <span class="s0">existingCacheEntry.kind = kind;</span>
        <span class="s0">}</span>
        <span class="s3">// We've determined that the existing entry we found is still valid, so we return it.</span>
        <span class="s1">return </span><span class="s0">existingCacheEntry;</span>
    <span class="s0">}</span>
    <span class="s3">// If we didn't return an entry, create a new one.</span>
    <span class="s1">return </span><span class="s0">createLazyPrefetchEntry({</span>
        <span class="s0">tree,</span>
        <span class="s0">url,</span>
        <span class="s0">nextUrl,</span>
        <span class="s0">prefetchCache,</span>
        <span class="s0">kind: kind || _routerreducertypes.PrefetchKind.TEMPORARY</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s3">/* 
 * Used to take an existing cache entry and prefix it with the nextUrl, if it exists. 
 * This ensures that we don't have conflicting cache entries for the same URL (as is the case with route interception). 
 */ </span><span class="s1">function </span><span class="s0">prefixExistingPrefetchCacheEntry(param) {</span>
    <span class="s1">let </span><span class="s0">{ url, nextUrl, prefetchCache, existingCacheKey } = param;</span>
    <span class="s1">const </span><span class="s0">existingCacheEntry = prefetchCache.get(existingCacheKey);</span>
    <span class="s1">if </span><span class="s0">(!existingCacheEntry) {</span>
        <span class="s3">// no-op -- there wasn't an entry to move</span>
        <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">newCacheKey = createPrefetchCacheKey(url, existingCacheEntry.kind, nextUrl);</span>
    <span class="s0">prefetchCache.set(newCacheKey, {</span>
        <span class="s0">...existingCacheEntry,</span>
        <span class="s0">key: newCacheKey</span>
    <span class="s0">});</span>
    <span class="s0">prefetchCache.delete(existingCacheKey);</span>
    <span class="s1">return </span><span class="s0">newCacheKey;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">createSeededPrefetchCacheEntry(param) {</span>
    <span class="s1">let </span><span class="s0">{ nextUrl, tree, prefetchCache, url, data, kind } = param;</span>
    <span class="s3">// The initial cache entry technically includes full data, but it isn't explicitly prefetched -- we just seed the</span>
    <span class="s3">// prefetch cache so that we can skip an extra prefetch request later, since we already have the data.</span>
    <span class="s3">// if the prefetch corresponds with an interception route, we use the nextUrl to prefix the cache key</span>
    <span class="s1">const </span><span class="s0">prefetchCacheKey = data.couldBeIntercepted ? createPrefetchCacheKey(url, kind, nextUrl) : createPrefetchCacheKey(url, kind);</span>
    <span class="s1">const </span><span class="s0">prefetchEntry = {</span>
        <span class="s0">treeAtTimeOfPrefetch: tree,</span>
        <span class="s0">data: Promise.resolve(data),</span>
        <span class="s0">kind,</span>
        <span class="s0">prefetchTime: Date.now(),</span>
        <span class="s0">lastUsedTime: Date.now(),</span>
        <span class="s0">staleTime: data.staleTime,</span>
        <span class="s0">key: prefetchCacheKey,</span>
        <span class="s0">status: _routerreducertypes.PrefetchCacheEntryStatus.fresh,</span>
        <span class="s0">url</span>
    <span class="s0">};</span>
    <span class="s0">prefetchCache.set(prefetchCacheKey, prefetchEntry);</span>
    <span class="s1">return </span><span class="s0">prefetchEntry;</span>
<span class="s0">}</span>
<span class="s3">/**</span>
 <span class="s3">* Creates a prefetch entry entry and enqueues a fetch request to retrieve the data.</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">createLazyPrefetchEntry(param) {</span>
    <span class="s1">let </span><span class="s0">{ url, kind, tree, nextUrl, prefetchCache } = param;</span>
    <span class="s1">const </span><span class="s0">prefetchCacheKey = createPrefetchCacheKey(url, kind);</span>
    <span class="s3">// initiates the fetch request for the prefetch and attaches a listener</span>
    <span class="s3">// to the promise to update the prefetch cache entry when the promise resolves (if necessary)</span>
    <span class="s1">const </span><span class="s0">data = _prefetchreducer.prefetchQueue.enqueue(()=&gt;(</span><span class="s4">0</span><span class="s0">, _fetchserverresponse.fetchServerResponse)(url, {</span>
            <span class="s0">flightRouterState: tree,</span>
            <span class="s0">nextUrl,</span>
            <span class="s0">prefetchKind: kind</span>
        <span class="s0">}).then((prefetchResponse)=&gt;{</span>
            <span class="s3">// TODO: `fetchServerResponse` should be more tighly coupled to these prefetch cache operations</span>
            <span class="s3">// to avoid drift between this cache key prefixing logic</span>
            <span class="s3">// (which is currently directly influenced by the server response)</span>
            <span class="s1">let </span><span class="s0">newCacheKey;</span>
            <span class="s1">if </span><span class="s0">(prefetchResponse.couldBeIntercepted) {</span>
                <span class="s3">// Determine if we need to prefix the cache key with the nextUrl</span>
                <span class="s0">newCacheKey = prefixExistingPrefetchCacheEntry({</span>
                    <span class="s0">url,</span>
                    <span class="s0">existingCacheKey: prefetchCacheKey,</span>
                    <span class="s0">nextUrl,</span>
                    <span class="s0">prefetchCache</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
            <span class="s3">// If the prefetch was a cache hit, we want to update the existing cache entry to reflect that it was a full prefetch.</span>
            <span class="s3">// This is because we know that a static response will contain the full RSC payload, and can be updated to respect the `static`</span>
            <span class="s3">// staleTime.</span>
            <span class="s1">if </span><span class="s0">(prefetchResponse.prerendered) {</span>
                <span class="s1">const </span><span class="s0">existingCacheEntry = prefetchCache.get(newCacheKey != </span><span class="s1">null </span><span class="s0">? newCacheKey : prefetchCacheKey);</span>
                <span class="s1">if </span><span class="s0">(existingCacheEntry) {</span>
                    <span class="s0">existingCacheEntry.kind = _routerreducertypes.PrefetchKind.FULL;</span>
                    <span class="s1">if </span><span class="s0">(prefetchResponse.staleTime !== -</span><span class="s4">1</span><span class="s0">) {</span>
                        <span class="s3">// This is the stale time that was collected by the server during</span>
                        <span class="s3">// static generation. Use this in place of the default stale time.</span>
                        <span class="s0">existingCacheEntry.staleTime = prefetchResponse.staleTime;</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">prefetchResponse;</span>
        <span class="s0">}));</span>
    <span class="s1">const </span><span class="s0">prefetchEntry = {</span>
        <span class="s0">treeAtTimeOfPrefetch: tree,</span>
        <span class="s0">data,</span>
        <span class="s0">kind,</span>
        <span class="s0">prefetchTime: Date.now(),</span>
        <span class="s0">lastUsedTime: </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">staleTime: -</span><span class="s4">1</span><span class="s0">,</span>
        <span class="s0">key: prefetchCacheKey,</span>
        <span class="s0">status: _routerreducertypes.PrefetchCacheEntryStatus.fresh,</span>
        <span class="s0">url</span>
    <span class="s0">};</span>
    <span class="s0">prefetchCache.set(prefetchCacheKey, prefetchEntry);</span>
    <span class="s1">return </span><span class="s0">prefetchEntry;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">prunePrefetchCache(prefetchCache) {</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">[href, prefetchCacheEntry] of prefetchCache){</span>
        <span class="s1">if </span><span class="s0">(getPrefetchEntryCacheStatus(prefetchCacheEntry) === _routerreducertypes.PrefetchCacheEntryStatus.expired) {</span>
            <span class="s0">prefetchCache.delete(href);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">const </span><span class="s0">DYNAMIC_STALETIME_MS = Number((</span><span class="s2">&quot;TURBOPACK compile-time value&quot;</span><span class="s0">, </span><span class="s2">&quot;0&quot;</span><span class="s0">)) * </span><span class="s4">1000</span><span class="s0">;</span>
<span class="s1">const </span><span class="s0">STATIC_STALETIME_MS = Number((</span><span class="s2">&quot;TURBOPACK compile-time value&quot;</span><span class="s0">, </span><span class="s2">&quot;300&quot;</span><span class="s0">)) * </span><span class="s4">1000</span><span class="s0">;</span>
<span class="s1">function </span><span class="s0">getPrefetchEntryCacheStatus(param) {</span>
    <span class="s1">let </span><span class="s0">{ kind, prefetchTime, lastUsedTime } = param;</span>
    <span class="s3">// We will re-use the cache entry data for up to the `dynamic` staletime window.</span>
    <span class="s1">if </span><span class="s0">(Date.now() &lt; (lastUsedTime != </span><span class="s1">null </span><span class="s0">? lastUsedTime : prefetchTime) + DYNAMIC_STALETIME_MS) {</span>
        <span class="s1">return </span><span class="s0">lastUsedTime ? _routerreducertypes.PrefetchCacheEntryStatus.reusable : _routerreducertypes.PrefetchCacheEntryStatus.fresh;</span>
    <span class="s0">}</span>
    <span class="s3">// For &quot;auto&quot; prefetching, we'll re-use only the loading boundary for up to `static` staletime window.</span>
    <span class="s3">// A stale entry will only re-use the `loading` boundary, not the full data.</span>
    <span class="s3">// This will trigger a &quot;lazy fetch&quot; for the full data.</span>
    <span class="s1">if </span><span class="s0">(kind === _routerreducertypes.PrefetchKind.AUTO) {</span>
        <span class="s1">if </span><span class="s0">(Date.now() &lt; prefetchTime + STATIC_STALETIME_MS) {</span>
            <span class="s1">return </span><span class="s0">_routerreducertypes.PrefetchCacheEntryStatus.stale;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s3">// for &quot;full&quot; prefetching, we'll re-use the cache entry data for up to `static` staletime window.</span>
    <span class="s1">if </span><span class="s0">(kind === _routerreducertypes.PrefetchKind.FULL) {</span>
        <span class="s1">if </span><span class="s0">(Date.now() &lt; prefetchTime + STATIC_STALETIME_MS) {</span>
            <span class="s1">return </span><span class="s0">_routerreducertypes.PrefetchCacheEntryStatus.reusable;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">_routerreducertypes.PrefetchCacheEntryStatus.expired;</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=prefetch-cache-utils.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s0">prefetchQueue: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">prefetchReducer: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s0">prefetchQueue: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">prefetchQueue;</span>
    <span class="s0">},</span>
    <span class="s0">prefetchReducer: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">prefetchReducer;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_promisequeue = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/promise-queue.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_prefetchcacheutils = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">prefetchQueue = </span><span class="s1">new </span><span class="s0">_promisequeue.PromiseQueue(</span><span class="s4">5</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">prefetchReducer = (</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) ? </span><span class="s2">&quot;TURBOPACK unreachable&quot; </span><span class="s0">: prefetchReducerImpl;</span>
<span class="s1">function </span><span class="s0">identityReducerWhenSegmentCacheIsEnabled(state) {</span>
    <span class="s3">// Unlike the old implementation, the Segment Cache doesn't store its data in</span>
    <span class="s3">// the router reducer state.</span>
    <span class="s3">//</span>
    <span class="s3">// This shouldn't be reachable because we wrap the prefetch API in a check,</span>
    <span class="s3">// too, which prevents the action from being dispatched. But it's here for</span>
    <span class="s3">// clarity + code elimination.</span>
    <span class="s1">return </span><span class="s0">state;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">prefetchReducerImpl(state, action) {</span>
    <span class="s3">// let's prune the prefetch cache before we do anything else</span>
    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _prefetchcacheutils.prunePrefetchCache)(state.prefetchCache);</span>
    <span class="s1">const </span><span class="s0">{ url } = action;</span>
    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _prefetchcacheutils.getOrCreatePrefetchCacheEntry)({</span>
        <span class="s0">url,</span>
        <span class="s0">nextUrl: state.nextUrl,</span>
        <span class="s0">prefetchCache: state.prefetchCache,</span>
        <span class="s0">kind: action.kind,</span>
        <span class="s0">tree: state.tree,</span>
        <span class="s0">allowAliasing: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s1">return </span><span class="s0">state;</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=prefetch-reducer.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/normalize-trailing-slash.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;normalizePathTrailingSlash&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">normalizePathTrailingSlash;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_removetrailingslash = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_parsepath = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/router/utils/parse-path.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">normalizePathTrailingSlash = (path)=&gt;{</span>
    <span class="s1">if </span><span class="s0">(!path.startsWith(</span><span class="s2">'/'</span><span class="s0">) || (</span><span class="s2">&quot;TURBOPACK compile-time value&quot;</span><span class="s0">, </span><span class="s1">void </span><span class="s4">0</span><span class="s0">)) {</span>
        <span class="s1">return </span><span class="s0">path;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">{ pathname, query, hash } = (</span><span class="s4">0</span><span class="s0">, _parsepath.parsePath)(path);</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) </span><span class="s3">//TURBOPACK unreachable</span>
    <span class="s0">;</span>
    <span class="s1">return </span><span class="s2">&quot;&quot; </span><span class="s0">+ (</span><span class="s4">0</span><span class="s0">, _removetrailingslash.removeTrailingSlash)(pathname) + query + hash;</span>
<span class="s0">};</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=normalize-trailing-slash.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/add-base-path.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;addBasePath&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">addBasePath;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_addpathprefix = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_normalizetrailingslash = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/normalize-trailing-slash.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">basePath = (</span><span class="s2">&quot;TURBOPACK compile-time value&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s0">) || </span><span class="s2">''</span><span class="s0">;</span>
<span class="s1">function </span><span class="s0">addBasePath(path, required) {</span>
    <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _normalizetrailingslash.normalizePathTrailingSlash)((</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) ? </span><span class="s2">&quot;TURBOPACK unreachable&quot; </span><span class="s0">: (</span><span class="s4">0</span><span class="s0">, _addpathprefix.addPathPrefix)(path, basePath));</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=add-base-path.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/app-router-announcer.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;AppRouterAnnouncer&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">AppRouterAnnouncer;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_react = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_reactdom = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react-dom/index.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">ANNOUNCER_TYPE = </span><span class="s2">'next-route-announcer'</span><span class="s0">;</span>
<span class="s1">const </span><span class="s0">ANNOUNCER_ID = </span><span class="s2">'__next-route-announcer__'</span><span class="s0">;</span>
<span class="s1">function </span><span class="s0">getAnnouncerNode() {</span>
    <span class="s1">var </span><span class="s0">_existingAnnouncer_shadowRoot;</span>
    <span class="s1">const </span><span class="s0">existingAnnouncer = document.getElementsByName(ANNOUNCER_TYPE)[</span><span class="s4">0</span><span class="s0">];</span>
    <span class="s1">if </span><span class="s0">(existingAnnouncer == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: (_existingAnnouncer_shadowRoot = existingAnnouncer.shadowRoot) == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: _existingAnnouncer_shadowRoot.childNodes[</span><span class="s4">0</span><span class="s0">]) {</span>
        <span class="s1">return </span><span class="s0">existingAnnouncer.shadowRoot.childNodes[</span><span class="s4">0</span><span class="s0">];</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">const </span><span class="s0">container = document.createElement(ANNOUNCER_TYPE);</span>
        <span class="s0">container.style.cssText = </span><span class="s2">'position:absolute'</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">announcer = document.createElement(</span><span class="s2">'div'</span><span class="s0">);</span>
        <span class="s0">announcer.ariaLive = </span><span class="s2">'assertive'</span><span class="s0">;</span>
        <span class="s0">announcer.id = ANNOUNCER_ID;</span>
        <span class="s0">announcer.role = </span><span class="s2">'alert'</span><span class="s0">;</span>
        <span class="s0">announcer.style.cssText = </span><span class="s2">'position:absolute;border:0;height:1px;margin:-1px;padding:0;width:1px;clip:rect(0 0 0 0);overflow:hidden;white-space:nowrap;word-wrap:normal'</span><span class="s0">;</span>
        <span class="s3">// Use shadow DOM here to avoid any potential CSS bleed</span>
        <span class="s1">const </span><span class="s0">shadow = container.attachShadow({</span>
            <span class="s0">mode: </span><span class="s2">'open'</span>
        <span class="s0">});</span>
        <span class="s0">shadow.appendChild(announcer);</span>
        <span class="s0">document.body.appendChild(container);</span>
        <span class="s1">return </span><span class="s0">announcer;</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">AppRouterAnnouncer(param) {</span>
    <span class="s1">let </span><span class="s0">{ tree } = param;</span>
    <span class="s1">const </span><span class="s0">[portalNode, setPortalNode] = (</span><span class="s4">0</span><span class="s0">, _react.useState)(</span><span class="s1">null</span><span class="s0">);</span>
    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _react.useEffect)(()=&gt;{</span>
        <span class="s1">const </span><span class="s0">announcer = getAnnouncerNode();</span>
        <span class="s0">setPortalNode(announcer);</span>
        <span class="s1">return </span><span class="s0">()=&gt;{</span>
            <span class="s1">const </span><span class="s0">container = document.getElementsByTagName(ANNOUNCER_TYPE)[</span><span class="s4">0</span><span class="s0">];</span>
            <span class="s1">if </span><span class="s0">(container == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: container.isConnected) {</span>
                <span class="s0">document.body.removeChild(container);</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
    <span class="s0">}, []);</span>
    <span class="s1">const </span><span class="s0">[routeAnnouncement, setRouteAnnouncement] = (</span><span class="s4">0</span><span class="s0">, _react.useState)(</span><span class="s2">''</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">previousTitle = (</span><span class="s4">0</span><span class="s0">, _react.useRef)(undefined);</span>
    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _react.useEffect)(()=&gt;{</span>
        <span class="s1">let </span><span class="s0">currentTitle = </span><span class="s2">''</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(document.title) {</span>
            <span class="s0">currentTitle = document.title;</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s1">const </span><span class="s0">pageHeader = document.querySelector(</span><span class="s2">'h1'</span><span class="s0">);</span>
            <span class="s1">if </span><span class="s0">(pageHeader) {</span>
                <span class="s0">currentTitle = pageHeader.innerText || pageHeader.textContent || </span><span class="s2">''</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s3">// Only announce the title change, but not for the first load because screen</span>
        <span class="s3">// readers do that automatically.</span>
        <span class="s1">if </span><span class="s0">(previousTitle.current !== undefined &amp;&amp; previousTitle.current !== currentTitle) {</span>
            <span class="s0">setRouteAnnouncement(currentTitle);</span>
        <span class="s0">}</span>
        <span class="s0">previousTitle.current = currentTitle;</span>
    <span class="s0">}, [</span>
        <span class="s0">tree</span>
    <span class="s0">]);</span>
    <span class="s1">return </span><span class="s0">portalNode ? </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _reactdom.createPortal)(routeAnnouncement, portalNode) : </span><span class="s1">null</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=app-router-announcer.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/reducers/get-segment-value.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;getSegmentValue&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">getSegmentValue;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">getSegmentValue(segment) {</span>
    <span class="s1">return </span><span class="s0">Array.isArray(segment) ? segment[</span><span class="s4">1</span><span class="s0">] : segment;</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=get-segment-value.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/redirect.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s0">getRedirectError: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">getRedirectStatusCodeFromError: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">getRedirectTypeFromError: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">getURLFromRedirectError: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">permanentRedirect: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">redirect: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s0">getRedirectError: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">getRedirectError;</span>
    <span class="s0">},</span>
    <span class="s0">getRedirectStatusCodeFromError: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">getRedirectStatusCodeFromError;</span>
    <span class="s0">},</span>
    <span class="s0">getRedirectTypeFromError: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">getRedirectTypeFromError;</span>
    <span class="s0">},</span>
    <span class="s0">getURLFromRedirectError: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">getURLFromRedirectError;</span>
    <span class="s0">},</span>
    <span class="s0">permanentRedirect: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">permanentRedirect;</span>
    <span class="s0">},</span>
    <span class="s0">redirect: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">redirect;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_redirectstatuscode = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/redirect-status-code.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_redirecterror = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/redirect-error.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">actionAsyncStorage = </span><span class="s1">typeof </span><span class="s0">window === </span><span class="s2">'undefined' </span><span class="s0">? __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/server/app-render/action-async-storage.external.js [app-client] (ecmascript)&quot;</span><span class="s0">).actionAsyncStorage : undefined;</span>
<span class="s1">function </span><span class="s0">getRedirectError(url, type, statusCode) {</span>
    <span class="s1">if </span><span class="s0">(statusCode === </span><span class="s1">void </span><span class="s4">0</span><span class="s0">) statusCode = _redirectstatuscode.RedirectStatusCode.TemporaryRedirect;</span>
    <span class="s1">const </span><span class="s0">error = Object.defineProperty(</span><span class="s1">new </span><span class="s0">Error(_redirecterror.REDIRECT_ERROR_CODE), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s2">&quot;E394&quot;</span><span class="s0">,</span>
        <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">configurable: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">error.digest = _redirecterror.REDIRECT_ERROR_CODE + </span><span class="s2">&quot;;&quot; </span><span class="s0">+ type + </span><span class="s2">&quot;;&quot; </span><span class="s0">+ url + </span><span class="s2">&quot;;&quot; </span><span class="s0">+ statusCode + </span><span class="s2">&quot;;&quot;</span><span class="s0">;</span>
    <span class="s1">return </span><span class="s0">error;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">redirect(</span><span class="s3">/** The URL to redirect to */ </span><span class="s0">url, type) {</span>
    <span class="s1">var </span><span class="s0">_actionAsyncStorage_getStore;</span>
    <span class="s0">type != </span><span class="s1">null </span><span class="s0">? type : type = (actionAsyncStorage == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: (_actionAsyncStorage_getStore = actionAsyncStorage.getStore()) == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: _actionAsyncStorage_getStore.isAction) ? _redirecterror.RedirectType.push : _redirecterror.RedirectType.replace;</span>
    <span class="s1">throw </span><span class="s0">getRedirectError(url, type, _redirectstatuscode.RedirectStatusCode.TemporaryRedirect);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">permanentRedirect(</span><span class="s3">/** The URL to redirect to */ </span><span class="s0">url, type) {</span>
    <span class="s1">if </span><span class="s0">(type === </span><span class="s1">void </span><span class="s4">0</span><span class="s0">) type = _redirecterror.RedirectType.replace;</span>
    <span class="s1">throw </span><span class="s0">getRedirectError(url, type, _redirectstatuscode.RedirectStatusCode.PermanentRedirect);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">getURLFromRedirectError(error) {</span>
    <span class="s1">if </span><span class="s0">(!(</span><span class="s4">0</span><span class="s0">, _redirecterror.isRedirectError)(error)) </span><span class="s1">return null</span><span class="s0">;</span>
    <span class="s3">// Slices off the beginning of the digest that contains the code and the</span>
    <span class="s3">// separating ';'.</span>
    <span class="s1">return </span><span class="s0">error.digest.split(</span><span class="s2">';'</span><span class="s0">).slice(</span><span class="s4">2</span><span class="s0">, -</span><span class="s4">2</span><span class="s0">).join(</span><span class="s2">';'</span><span class="s0">);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">getRedirectTypeFromError(error) {</span>
    <span class="s1">if </span><span class="s0">(!(</span><span class="s4">0</span><span class="s0">, _redirecterror.isRedirectError)(error)) {</span>
        <span class="s1">throw </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">Error(</span><span class="s2">'Not a redirect error'</span><span class="s0">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
            <span class="s0">value: </span><span class="s2">&quot;E260&quot;</span><span class="s0">,</span>
            <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">configurable: </span><span class="s1">true</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">error.digest.split(</span><span class="s2">';'</span><span class="s0">, </span><span class="s4">2</span><span class="s0">)[</span><span class="s4">1</span><span class="s0">];</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">getRedirectStatusCodeFromError(error) {</span>
    <span class="s1">if </span><span class="s0">(!(</span><span class="s4">0</span><span class="s0">, _redirecterror.isRedirectError)(error)) {</span>
        <span class="s1">throw </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">Error(</span><span class="s2">'Not a redirect error'</span><span class="s0">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
            <span class="s0">value: </span><span class="s2">&quot;E260&quot;</span><span class="s0">,</span>
            <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">configurable: </span><span class="s1">true</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">Number(error.digest.split(</span><span class="s2">';'</span><span class="s0">).at(-</span><span class="s4">2</span><span class="s0">));</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=redirect.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/forbidden.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;forbidden&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">forbidden;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_httpaccessfallback = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s3">// TODO: Add `forbidden` docs</span>
<span class="s3">/**</span>
 <span class="s3">* </span><span class="s5">@experimental</span>
 <span class="s3">* This function allows you to render the [forbidden.js file](https://nextjs.org/docs/app/api-reference/file-conventions/forbidden)</span>
 <span class="s3">* within a route segment as well as inject a tag.</span>
 <span class="s3">*</span>
 <span class="s3">* `forbidden()` can be used in</span>
 <span class="s3">* [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),</span>
 <span class="s3">* [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and</span>
 <span class="s3">* [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).</span>
 <span class="s3">*</span>
 <span class="s3">* Read more: [Next.js Docs: `forbidden`](https://nextjs.org/docs/app/api-reference/functions/forbidden)</span>
 <span class="s3">*/ </span><span class="s1">const </span><span class="s0">DIGEST = </span><span class="s2">&quot;&quot; </span><span class="s0">+ _httpaccessfallback.HTTP_ERROR_FALLBACK_ERROR_CODE + </span><span class="s2">&quot;;403&quot;</span><span class="s0">;</span>
<span class="s1">function </span><span class="s0">forbidden() {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s0">) {</span>
        <span class="s1">throw </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">Error(</span><span class="s2">&quot;`forbidden()` is experimental and only allowed to be enabled when `experimental.authInterrupts` is enabled.&quot;</span><span class="s0">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
            <span class="s0">value: </span><span class="s2">&quot;E488&quot;</span><span class="s0">,</span>
            <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">configurable: </span><span class="s1">true</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s3">// eslint-disable-next-line no-throw-literal</span>
    <span class="s1">const </span><span class="s0">error = Object.defineProperty(</span><span class="s1">new </span><span class="s0">Error(DIGEST), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s2">&quot;E394&quot;</span><span class="s0">,</span>
        <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">configurable: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">error.digest = DIGEST;</span>
    <span class="s1">throw </span><span class="s0">error;</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=forbidden.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/unauthorized.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;unauthorized&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">unauthorized;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_httpaccessfallback = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s3">// TODO: Add `unauthorized` docs</span>
<span class="s3">/**</span>
 <span class="s3">* </span><span class="s5">@experimental</span>
 <span class="s3">* This function allows you to render the [unauthorized.js file](https://nextjs.org/docs/app/api-reference/file-conventions/unauthorized)</span>
 <span class="s3">* within a route segment as well as inject a tag.</span>
 <span class="s3">*</span>
 <span class="s3">* `unauthorized()` can be used in</span>
 <span class="s3">* [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),</span>
 <span class="s3">* [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and</span>
 <span class="s3">* [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).</span>
 <span class="s3">*</span>
 <span class="s3">*</span>
 <span class="s3">* Read more: [Next.js Docs: `unauthorized`](https://nextjs.org/docs/app/api-reference/functions/unauthorized)</span>
 <span class="s3">*/ </span><span class="s1">const </span><span class="s0">DIGEST = </span><span class="s2">&quot;&quot; </span><span class="s0">+ _httpaccessfallback.HTTP_ERROR_FALLBACK_ERROR_CODE + </span><span class="s2">&quot;;401&quot;</span><span class="s0">;</span>
<span class="s1">function </span><span class="s0">unauthorized() {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s0">) {</span>
        <span class="s1">throw </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">Error(</span><span class="s2">&quot;`unauthorized()` is experimental and only allowed to be used when `experimental.authInterrupts` is enabled.&quot;</span><span class="s0">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
            <span class="s0">value: </span><span class="s2">&quot;E411&quot;</span><span class="s0">,</span>
            <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">configurable: </span><span class="s1">true</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s3">// eslint-disable-next-line no-throw-literal</span>
    <span class="s1">const </span><span class="s0">error = Object.defineProperty(</span><span class="s1">new </span><span class="s0">Error(DIGEST), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s2">&quot;E394&quot;</span><span class="s0">,</span>
        <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">configurable: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">error.digest = DIGEST;</span>
    <span class="s1">throw </span><span class="s0">error;</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=unauthorized.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/unstable-rethrow.browser.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;unstable_rethrow&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">unstable_rethrow;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_bailouttocsr = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_isnextroutererror = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/is-next-router-error.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">unstable_rethrow(error) {</span>
    <span class="s1">if </span><span class="s0">((</span><span class="s4">0</span><span class="s0">, _isnextroutererror.isNextRouterError)(error) || (</span><span class="s4">0</span><span class="s0">, _bailouttocsr.isBailoutToCSRError)(error)) {</span>
        <span class="s1">throw </span><span class="s0">error;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(error </span><span class="s1">instanceof </span><span class="s0">Error &amp;&amp; </span><span class="s2">'cause' </span><span class="s1">in </span><span class="s0">error) {</span>
        <span class="s0">unstable_rethrow(error.cause);</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=unstable-rethrow.browser.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/hooks-server-context.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s0">DynamicServerError: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">isDynamicServerError: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s0">DynamicServerError: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">DynamicServerError;</span>
    <span class="s0">},</span>
    <span class="s0">isDynamicServerError: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">isDynamicServerError;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">DYNAMIC_ERROR_CODE = </span><span class="s2">'DYNAMIC_SERVER_USAGE'</span><span class="s0">;</span>
<span class="s1">class </span><span class="s0">DynamicServerError </span><span class="s1">extends </span><span class="s0">Error {</span>
    <span class="s0">constructor(description){</span>
        <span class="s1">super</span><span class="s0">(</span><span class="s2">&quot;Dynamic server usage: &quot; </span><span class="s0">+ description), </span><span class="s1">this</span><span class="s0">.description = description, </span><span class="s1">this</span><span class="s0">.digest = DYNAMIC_ERROR_CODE;</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">isDynamicServerError(err) {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">err !== </span><span class="s2">'object' </span><span class="s0">|| err === </span><span class="s1">null </span><span class="s0">|| !(</span><span class="s2">'digest' </span><span class="s1">in </span><span class="s0">err) || </span><span class="s1">typeof </span><span class="s0">err.digest !== </span><span class="s2">'string'</span><span class="s0">) {</span>
        <span class="s1">return false</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">err.digest === DYNAMIC_ERROR_CODE;</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=hooks-server-context.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/static-generation-bailout.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s0">StaticGenBailoutError: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">isStaticGenBailoutError: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s0">StaticGenBailoutError: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">StaticGenBailoutError;</span>
    <span class="s0">},</span>
    <span class="s0">isStaticGenBailoutError: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">isStaticGenBailoutError;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">NEXT_STATIC_GEN_BAILOUT = </span><span class="s2">'NEXT_STATIC_GEN_BAILOUT'</span><span class="s0">;</span>
<span class="s1">class </span><span class="s0">StaticGenBailoutError </span><span class="s1">extends </span><span class="s0">Error {</span>
    <span class="s0">constructor(...args){</span>
        <span class="s1">super</span><span class="s0">(...args), </span><span class="s1">this</span><span class="s0">.code = NEXT_STATIC_GEN_BAILOUT;</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">isStaticGenBailoutError(error) {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">error !== </span><span class="s2">'object' </span><span class="s0">|| error === </span><span class="s1">null </span><span class="s0">|| !(</span><span class="s2">'code' </span><span class="s1">in </span><span class="s0">error)) {</span>
        <span class="s1">return false</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">error.code === NEXT_STATIC_GEN_BAILOUT;</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=static-generation-bailout.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/unstable-rethrow.server.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;unstable_rethrow&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">unstable_rethrow;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_dynamicrenderingutils = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/server/dynamic-rendering-utils.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_ispostpone = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/server/lib/router-utils/is-postpone.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_bailouttocsr = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_isnextroutererror = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/is-next-router-error.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_dynamicrendering = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/server/app-render/dynamic-rendering.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_hooksservercontext = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/hooks-server-context.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">unstable_rethrow(error) {</span>
    <span class="s1">if </span><span class="s0">((</span><span class="s4">0</span><span class="s0">, _isnextroutererror.isNextRouterError)(error) || (</span><span class="s4">0</span><span class="s0">, _bailouttocsr.isBailoutToCSRError)(error) || (</span><span class="s4">0</span><span class="s0">, _hooksservercontext.isDynamicServerError)(error) || (</span><span class="s4">0</span><span class="s0">, _dynamicrendering.isDynamicPostpone)(error) || (</span><span class="s4">0</span><span class="s0">, _ispostpone.isPostpone)(error) || (</span><span class="s4">0</span><span class="s0">, _dynamicrenderingutils.isHangingPromiseRejectionError)(error)) {</span>
        <span class="s1">throw </span><span class="s0">error;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(error </span><span class="s1">instanceof </span><span class="s0">Error &amp;&amp; </span><span class="s2">'cause' </span><span class="s1">in </span><span class="s0">error) {</span>
        <span class="s0">unstable_rethrow(error.cause);</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=unstable-rethrow.server.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/unstable-rethrow.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s3">/**</span>
 <span class="s3">* This function should be used to rethrow internal Next.js errors so that they can be handled by the framework.</span>
 <span class="s3">* When wrapping an API that uses errors to interrupt control flow, you should use this function before you do any error handling.</span>
 <span class="s3">* This function will rethrow the error if it is a Next.js error so it can be handled, otherwise it will do nothing.</span>
 <span class="s3">*</span>
 <span class="s3">* Read more: [Next.js Docs: `unstable_rethrow`](https://nextjs.org/docs/app/api-reference/functions/unstable_rethrow)</span>
 <span class="s3">*/ </span><span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;unstable_rethrow&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">unstable_rethrow;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">unstable_rethrow = </span><span class="s1">typeof </span><span class="s0">window === </span><span class="s2">'undefined' </span><span class="s0">? __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/unstable-rethrow.server.js [app-client] (ecmascript)&quot;</span><span class="s0">).unstable_rethrow : __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/unstable-rethrow.browser.js [app-client] (ecmascript)&quot;</span><span class="s0">).unstable_rethrow;</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=unstable-rethrow.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/navigation.react-server.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s3">/** </span><span class="s5">@internal </span><span class="s3">*/ </span><span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s0">ReadonlyURLSearchParams: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">RedirectType: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">forbidden: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">notFound: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">permanentRedirect: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">redirect: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">unauthorized: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">unstable_isUnrecognizedActionError: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">unstable_rethrow: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s0">ReadonlyURLSearchParams: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">ReadonlyURLSearchParams;</span>
    <span class="s0">},</span>
    <span class="s0">RedirectType: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">_redirecterror.RedirectType;</span>
    <span class="s0">},</span>
    <span class="s0">forbidden: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">_forbidden.forbidden;</span>
    <span class="s0">},</span>
    <span class="s0">notFound: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">_notfound.notFound;</span>
    <span class="s0">},</span>
    <span class="s0">permanentRedirect: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">_redirect.permanentRedirect;</span>
    <span class="s0">},</span>
    <span class="s0">redirect: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">_redirect.redirect;</span>
    <span class="s0">},</span>
    <span class="s0">unauthorized: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">_unauthorized.unauthorized;</span>
    <span class="s0">},</span>
    <span class="s0">unstable_isUnrecognizedActionError: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">unstable_isUnrecognizedActionError;</span>
    <span class="s0">},</span>
    <span class="s0">unstable_rethrow: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">_unstablerethrow.unstable_rethrow;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_redirect = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/redirect.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_redirecterror = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/redirect-error.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_notfound = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/not-found.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_forbidden = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/forbidden.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_unauthorized = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/unauthorized.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_unstablerethrow = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/unstable-rethrow.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">class </span><span class="s0">ReadonlyURLSearchParamsError </span><span class="s1">extends </span><span class="s0">Error {</span>
    <span class="s0">constructor(){</span>
        <span class="s1">super</span><span class="s0">(</span><span class="s2">'Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams'</span><span class="s0">);</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">class </span><span class="s0">ReadonlyURLSearchParams </span><span class="s1">extends </span><span class="s0">URLSearchParams {</span>
    <span class="s3">/** </span><span class="s5">@deprecated </span><span class="s3">Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */ </span><span class="s0">append() {</span>
        <span class="s1">throw new </span><span class="s0">ReadonlyURLSearchParamsError();</span>
    <span class="s0">}</span>
    <span class="s3">/** </span><span class="s5">@deprecated </span><span class="s3">Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */ </span><span class="s1">delete</span><span class="s0">() {</span>
        <span class="s1">throw new </span><span class="s0">ReadonlyURLSearchParamsError();</span>
    <span class="s0">}</span>
    <span class="s3">/** </span><span class="s5">@deprecated </span><span class="s3">Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */ </span><span class="s0">set() {</span>
        <span class="s1">throw new </span><span class="s0">ReadonlyURLSearchParamsError();</span>
    <span class="s0">}</span>
    <span class="s3">/** </span><span class="s5">@deprecated </span><span class="s3">Method unavailable on `ReadonlyURLSearchParams`. Read more: https://nextjs.org/docs/app/api-reference/functions/use-search-params#updating-searchparams */ </span><span class="s0">sort() {</span>
        <span class="s1">throw new </span><span class="s0">ReadonlyURLSearchParamsError();</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">unstable_isUnrecognizedActionError() {</span>
    <span class="s1">throw </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">Error(</span><span class="s2">'`unstable_isUnrecognizedActionError` can only be used on the client.'</span><span class="s0">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s2">&quot;E776&quot;</span><span class="s0">,</span>
        <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">configurable: </span><span class="s1">true</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=navigation.react-server.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/unrecognized-action-error.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s0">UnrecognizedActionError: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">unstable_isUnrecognizedActionError: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s0">UnrecognizedActionError: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">UnrecognizedActionError;</span>
    <span class="s0">},</span>
    <span class="s0">unstable_isUnrecognizedActionError: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">unstable_isUnrecognizedActionError;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">class </span><span class="s0">UnrecognizedActionError </span><span class="s1">extends </span><span class="s0">Error {</span>
    <span class="s0">constructor(...args){</span>
        <span class="s1">super</span><span class="s0">(...args);</span>
        <span class="s1">this</span><span class="s0">.name = </span><span class="s2">'UnrecognizedActionError'</span><span class="s0">;</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">unstable_isUnrecognizedActionError(error) {</span>
    <span class="s1">return </span><span class="s0">!!(error &amp;&amp; </span><span class="s1">typeof </span><span class="s0">error === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; error </span><span class="s1">instanceof </span><span class="s0">UnrecognizedActionError);</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=unrecognized-action-error.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/bailout-to-client-rendering.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;bailoutToClientRendering&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">bailoutToClientRendering;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_bailouttocsr = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_workasyncstorageexternal = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/server/app-render/work-async-storage.external.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_workunitasyncstorageexternal = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/server/app-render/work-unit-async-storage.external.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">bailoutToClientRendering(reason) {</span>
    <span class="s1">const </span><span class="s0">workStore = _workasyncstorageexternal.workAsyncStorage.getStore();</span>
    <span class="s1">if </span><span class="s0">(workStore == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: workStore.forceStatic) </span><span class="s1">return</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();</span>
    <span class="s1">if </span><span class="s0">(workUnitStore) {</span>
        <span class="s1">switch</span><span class="s0">(workUnitStore.type){</span>
            <span class="s1">case </span><span class="s2">'prerender'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'prerender-runtime'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'prerender-client'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'prerender-ppr'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'prerender-legacy'</span><span class="s0">:</span>
                <span class="s1">throw </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">_bailouttocsr.BailoutToCSRError(reason), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
                    <span class="s0">value: </span><span class="s2">&quot;E394&quot;</span><span class="s0">,</span>
                    <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
                    <span class="s0">configurable: </span><span class="s1">true</span>
                <span class="s0">});</span>
            <span class="s1">case </span><span class="s2">'request'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'cache'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'private-cache'</span><span class="s0">:</span>
            <span class="s1">case </span><span class="s2">'unstable-cache'</span><span class="s0">:</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s1">default</span><span class="s0">:</span>
                <span class="s0">workUnitStore;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=bailout-to-client-rendering.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/navigation.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s0">ReadonlyURLSearchParams: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">RedirectType: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">ServerInsertedHTMLContext: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">forbidden: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">notFound: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">permanentRedirect: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">redirect: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">unauthorized: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">unstable_isUnrecognizedActionError: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">unstable_rethrow: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">useParams: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">usePathname: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">useRouter: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">useSearchParams: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">useSelectedLayoutSegment: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">useSelectedLayoutSegments: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">useServerInsertedHTML: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s0">ReadonlyURLSearchParams: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">_navigationreactserver.ReadonlyURLSearchParams;</span>
    <span class="s0">},</span>
    <span class="s0">RedirectType: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">_navigationreactserver.RedirectType;</span>
    <span class="s0">},</span>
    <span class="s0">ServerInsertedHTMLContext: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">_serverinsertedhtmlsharedruntime.ServerInsertedHTMLContext;</span>
    <span class="s0">},</span>
    <span class="s0">forbidden: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">_navigationreactserver.forbidden;</span>
    <span class="s0">},</span>
    <span class="s0">notFound: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">_navigationreactserver.notFound;</span>
    <span class="s0">},</span>
    <span class="s0">permanentRedirect: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">_navigationreactserver.permanentRedirect;</span>
    <span class="s0">},</span>
    <span class="s0">redirect: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">_navigationreactserver.redirect;</span>
    <span class="s0">},</span>
    <span class="s0">unauthorized: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">_navigationreactserver.unauthorized;</span>
    <span class="s0">},</span>
    <span class="s0">unstable_isUnrecognizedActionError: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">_unrecognizedactionerror.unstable_isUnrecognizedActionError;</span>
    <span class="s0">},</span>
    <span class="s0">unstable_rethrow: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">_navigationreactserver.unstable_rethrow;</span>
    <span class="s0">},</span>
    <span class="s0">useParams: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">useParams;</span>
    <span class="s0">},</span>
    <span class="s0">usePathname: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">usePathname;</span>
    <span class="s0">},</span>
    <span class="s0">useRouter: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">useRouter;</span>
    <span class="s0">},</span>
    <span class="s0">useSearchParams: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">useSearchParams;</span>
    <span class="s0">},</span>
    <span class="s0">useSelectedLayoutSegment: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">useSelectedLayoutSegment;</span>
    <span class="s0">},</span>
    <span class="s0">useSelectedLayoutSegments: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">useSelectedLayoutSegments;</span>
    <span class="s0">},</span>
    <span class="s0">useServerInsertedHTML: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">_serverinsertedhtmlsharedruntime.useServerInsertedHTML;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_react = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_approutercontextsharedruntime = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_hooksclientcontextsharedruntime = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_getsegmentvalue = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/reducers/get-segment-value.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_segment = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/segment.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_navigationreactserver = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/navigation.react-server.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_serverinsertedhtmlsharedruntime = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/server-inserted-html.shared-runtime.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_unrecognizedactionerror = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/unrecognized-action-error.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">useDynamicRouteParams = </span><span class="s1">typeof </span><span class="s0">window === </span><span class="s2">'undefined' </span><span class="s0">? __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/server/app-render/dynamic-rendering.js [app-client] (ecmascript)&quot;</span><span class="s0">).useDynamicRouteParams : undefined;</span>
<span class="s1">function </span><span class="s0">useSearchParams() {</span>
    <span class="s1">const </span><span class="s0">searchParams = (</span><span class="s4">0</span><span class="s0">, _react.useContext)(_hooksclientcontextsharedruntime.SearchParamsContext);</span>
    <span class="s3">// In the case where this is `null`, the compat types added in</span>
    <span class="s3">// `next-env.d.ts` will add a new overload that changes the return type to</span>
    <span class="s3">// include `null`.</span>
    <span class="s1">const </span><span class="s0">readonlySearchParams = (</span><span class="s4">0</span><span class="s0">, _react.useMemo)(()=&gt;{</span>
        <span class="s1">if </span><span class="s0">(!searchParams) {</span>
            <span class="s3">// When the router is not ready in pages, we won't have the search params</span>
            <span class="s3">// available.</span>
            <span class="s1">return null</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">return new </span><span class="s0">_navigationreactserver.ReadonlyURLSearchParams(searchParams);</span>
    <span class="s0">}, [</span>
        <span class="s0">searchParams</span>
    <span class="s0">]);</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">window === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
        <span class="s3">// AsyncLocalStorage should not be included in the client bundle.</span>
        <span class="s1">const </span><span class="s0">{ bailoutToClientRendering } = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/bailout-to-client-rendering.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
        <span class="s3">// TODO-APP: handle dynamic = 'force-static' here and on the client</span>
        <span class="s0">bailoutToClientRendering(</span><span class="s2">'useSearchParams()'</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">readonlySearchParams;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">usePathname() {</span>
    <span class="s0">useDynamicRouteParams == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: useDynamicRouteParams(</span><span class="s2">'usePathname()'</span><span class="s0">);</span>
    <span class="s3">// In the case where this is `null`, the compat types added in `next-env.d.ts`</span>
    <span class="s3">// will add a new overload that changes the return type to include `null`.</span>
    <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _react.useContext)(_hooksclientcontextsharedruntime.PathnameContext);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">useRouter() {</span>
    <span class="s1">const </span><span class="s0">router = (</span><span class="s4">0</span><span class="s0">, _react.useContext)(_approutercontextsharedruntime.AppRouterContext);</span>
    <span class="s1">if </span><span class="s0">(router === </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s1">throw </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">Error(</span><span class="s2">'invariant expected app router to be mounted'</span><span class="s0">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
            <span class="s0">value: </span><span class="s2">&quot;E238&quot;</span><span class="s0">,</span>
            <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">configurable: </span><span class="s1">true</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">router;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">useParams() {</span>
    <span class="s0">useDynamicRouteParams == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: useDynamicRouteParams(</span><span class="s2">'useParams()'</span><span class="s0">);</span>
    <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _react.useContext)(_hooksclientcontextsharedruntime.PathParamsContext);</span>
<span class="s0">}</span>
<span class="s3">/** Get the canonical parameters from the current level to the leaf node. */ // Client components API</span>
<span class="s1">function </span><span class="s0">getSelectedLayoutSegmentPath(tree, parallelRouteKey, first, segmentPath) {</span>
    <span class="s1">if </span><span class="s0">(first === </span><span class="s1">void </span><span class="s4">0</span><span class="s0">) first = </span><span class="s1">true</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(segmentPath === </span><span class="s1">void </span><span class="s4">0</span><span class="s0">) segmentPath = [];</span>
    <span class="s1">let </span><span class="s0">node;</span>
    <span class="s1">if </span><span class="s0">(first) {</span>
        <span class="s3">// Use the provided parallel route key on the first parallel route</span>
        <span class="s0">node = tree[</span><span class="s4">1</span><span class="s0">][parallelRouteKey];</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s3">// After first parallel route prefer children, if there's no children pick the first parallel route.</span>
        <span class="s1">const </span><span class="s0">parallelRoutes = tree[</span><span class="s4">1</span><span class="s0">];</span>
        <span class="s1">var </span><span class="s0">_parallelRoutes_children;</span>
        <span class="s0">node = (_parallelRoutes_children = parallelRoutes.children) != </span><span class="s1">null </span><span class="s0">? _parallelRoutes_children : Object.values(parallelRoutes)[</span><span class="s4">0</span><span class="s0">];</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(!node) </span><span class="s1">return </span><span class="s0">segmentPath;</span>
    <span class="s1">const </span><span class="s0">segment = node[</span><span class="s4">0</span><span class="s0">];</span>
    <span class="s1">let </span><span class="s0">segmentValue = (</span><span class="s4">0</span><span class="s0">, _getsegmentvalue.getSegmentValue)(segment);</span>
    <span class="s1">if </span><span class="s0">(!segmentValue || segmentValue.startsWith(_segment.PAGE_SEGMENT_KEY)) {</span>
        <span class="s1">return </span><span class="s0">segmentPath;</span>
    <span class="s0">}</span>
    <span class="s0">segmentPath.push(segmentValue);</span>
    <span class="s1">return </span><span class="s0">getSelectedLayoutSegmentPath(node, parallelRouteKey, </span><span class="s1">false</span><span class="s0">, segmentPath);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">useSelectedLayoutSegments(parallelRouteKey) {</span>
    <span class="s1">if </span><span class="s0">(parallelRouteKey === </span><span class="s1">void </span><span class="s4">0</span><span class="s0">) parallelRouteKey = </span><span class="s2">'children'</span><span class="s0">;</span>
    <span class="s0">useDynamicRouteParams == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: useDynamicRouteParams(</span><span class="s2">'useSelectedLayoutSegments()'</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">context = (</span><span class="s4">0</span><span class="s0">, _react.useContext)(_approutercontextsharedruntime.LayoutRouterContext);</span>
    <span class="s3">// @ts-expect-error This only happens in `pages`. Type is overwritten in navigation.d.ts</span>
    <span class="s1">if </span><span class="s0">(!context) </span><span class="s1">return null</span><span class="s0">;</span>
    <span class="s1">return </span><span class="s0">getSelectedLayoutSegmentPath(context.parentTree, parallelRouteKey);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">useSelectedLayoutSegment(parallelRouteKey) {</span>
    <span class="s1">if </span><span class="s0">(parallelRouteKey === </span><span class="s1">void </span><span class="s4">0</span><span class="s0">) parallelRouteKey = </span><span class="s2">'children'</span><span class="s0">;</span>
    <span class="s0">useDynamicRouteParams == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: useDynamicRouteParams(</span><span class="s2">'useSelectedLayoutSegment()'</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">selectedLayoutSegments = useSelectedLayoutSegments(parallelRouteKey);</span>
    <span class="s1">if </span><span class="s0">(!selectedLayoutSegments || selectedLayoutSegments.length === </span><span class="s4">0</span><span class="s0">) {</span>
        <span class="s1">return null</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">selectedLayoutSegment = parallelRouteKey === </span><span class="s2">'children' </span><span class="s0">? selectedLayoutSegments[</span><span class="s4">0</span><span class="s0">] : selectedLayoutSegments[selectedLayoutSegments.length - </span><span class="s4">1</span><span class="s0">];</span>
    <span class="s3">// if the default slot is showing, we return null since it's not technically &quot;selected&quot; (it's a fallback)</span>
    <span class="s3">// and returning an internal value like `__DEFAULT__` would be confusing.</span>
    <span class="s1">return </span><span class="s0">selectedLayoutSegment === _segment.DEFAULT_SEGMENT_KEY ? </span><span class="s1">null </span><span class="s0">: selectedLayoutSegment;</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=navigation.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/redirect-boundary.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s0">RedirectBoundary: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">RedirectErrorBoundary: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s0">RedirectBoundary: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">RedirectBoundary;</span>
    <span class="s0">},</span>
    <span class="s0">RedirectErrorBoundary: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">RedirectErrorBoundary;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_interop_require_wildcard = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_jsxruntime = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_react = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">_interop_require_wildcard._(__turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)&quot;</span><span class="s0">));</span>
<span class="s1">const </span><span class="s0">_navigation = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/navigation.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_redirect = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/redirect.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_redirecterror = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/redirect-error.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">HandleRedirect(param) {</span>
    <span class="s1">let </span><span class="s0">{ redirect, reset, redirectType } = param;</span>
    <span class="s1">const </span><span class="s0">router = (</span><span class="s4">0</span><span class="s0">, _navigation.useRouter)();</span>
    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _react.useEffect)(()=&gt;{</span>
        <span class="s0">_react.default.startTransition(()=&gt;{</span>
            <span class="s1">if </span><span class="s0">(redirectType === _redirecterror.RedirectType.push) {</span>
                <span class="s0">router.push(redirect, {});</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">router.replace(redirect, {});</span>
            <span class="s0">}</span>
            <span class="s0">reset();</span>
        <span class="s0">});</span>
    <span class="s0">}, [</span>
        <span class="s0">redirect,</span>
        <span class="s0">redirectType,</span>
        <span class="s0">reset,</span>
        <span class="s0">router</span>
    <span class="s0">]);</span>
    <span class="s1">return null</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s1">class </span><span class="s0">RedirectErrorBoundary </span><span class="s1">extends </span><span class="s0">_react.default.Component {</span>
    <span class="s1">static </span><span class="s0">getDerivedStateFromError(error) {</span>
        <span class="s1">if </span><span class="s0">((</span><span class="s4">0</span><span class="s0">, _redirecterror.isRedirectError)(error)) {</span>
            <span class="s1">const </span><span class="s0">url = (</span><span class="s4">0</span><span class="s0">, _redirect.getURLFromRedirectError)(error);</span>
            <span class="s1">const </span><span class="s0">redirectType = (</span><span class="s4">0</span><span class="s0">, _redirect.getRedirectTypeFromError)(error);</span>
            <span class="s1">return </span><span class="s0">{</span>
                <span class="s0">redirect: url,</span>
                <span class="s0">redirectType</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s3">// Re-throw if error is not for redirect</span>
        <span class="s1">throw </span><span class="s0">error;</span>
    <span class="s0">}</span>
    <span class="s3">// Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific to the `@types/react` version.</span>
    <span class="s0">render() {</span>
        <span class="s1">const </span><span class="s0">{ redirect, redirectType } = </span><span class="s1">this</span><span class="s0">.state;</span>
        <span class="s1">if </span><span class="s0">(redirect !== </span><span class="s1">null </span><span class="s0">&amp;&amp; redirectType !== </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(HandleRedirect, {</span>
                <span class="s0">redirect: redirect,</span>
                <span class="s0">redirectType: redirectType,</span>
                <span class="s0">reset: ()=&gt;</span><span class="s1">this</span><span class="s0">.setState({</span>
                        <span class="s0">redirect: </span><span class="s1">null</span>
                    <span class="s0">})</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s1">return this</span><span class="s0">.props.children;</span>
    <span class="s0">}</span>
    <span class="s0">constructor(props){</span>
        <span class="s1">super</span><span class="s0">(props);</span>
        <span class="s1">this</span><span class="s0">.state = {</span>
            <span class="s0">redirect: </span><span class="s1">null</span><span class="s0">,</span>
            <span class="s0">redirectType: </span><span class="s1">null</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">RedirectBoundary(param) {</span>
    <span class="s1">let </span><span class="s0">{ children } = param;</span>
    <span class="s1">const </span><span class="s0">router = (</span><span class="s4">0</span><span class="s0">, _navigation.useRouter)();</span>
    <span class="s1">return </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(RedirectErrorBoundary, {</span>
        <span class="s0">router: router,</span>
        <span class="s0">children: children</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=redirect-boundary.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/reducers/find-head-in-cache.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;findHeadInCache&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">findHeadInCache;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_segment = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/segment.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_createroutercachekey = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">findHeadInCache(cache, parallelRoutes) {</span>
    <span class="s1">return </span><span class="s0">findHeadInCacheImpl(cache, parallelRoutes, </span><span class="s2">''</span><span class="s0">, </span><span class="s2">''</span><span class="s0">);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">findHeadInCacheImpl(cache, parallelRoutes, keyPrefix, keyPrefixWithoutSearchParams) {</span>
    <span class="s1">const </span><span class="s0">isLastItem = Object.keys(parallelRoutes).length === </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(isLastItem) {</span>
        <span class="s3">// Returns the entire Cache Node of the segment whose head we will render.</span>
        <span class="s1">return </span><span class="s0">[</span>
            <span class="s0">cache,</span>
            <span class="s0">keyPrefix,</span>
            <span class="s0">keyPrefixWithoutSearchParams</span>
        <span class="s0">];</span>
    <span class="s0">}</span>
    <span class="s3">// First try the 'children' parallel route if it exists</span>
    <span class="s3">// when starting from the &quot;root&quot;, this corresponds with the main page component</span>
    <span class="s1">const </span><span class="s0">parallelRoutesKeys = Object.keys(parallelRoutes).filter((key)=&gt;key !== </span><span class="s2">'children'</span><span class="s0">);</span>
    <span class="s3">// if we are at the root, we need to check the children slot first</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">'children' </span><span class="s1">in </span><span class="s0">parallelRoutes) {</span>
        <span class="s0">parallelRoutesKeys.unshift(</span><span class="s2">'children'</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">key of parallelRoutesKeys){</span>
        <span class="s1">const </span><span class="s0">[segment, childParallelRoutes] = parallelRoutes[key];</span>
        <span class="s3">// If the parallel is not matched and using the default segment,</span>
        <span class="s3">// skip searching the head from it.</span>
        <span class="s1">if </span><span class="s0">(segment === _segment.DEFAULT_SEGMENT_KEY) {</span>
            <span class="s1">continue</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">childSegmentMap = cache.parallelRoutes.get(key);</span>
        <span class="s1">if </span><span class="s0">(!childSegmentMap) {</span>
            <span class="s1">continue</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">cacheKey = (</span><span class="s4">0</span><span class="s0">, _createroutercachekey.createRouterCacheKey)(segment);</span>
        <span class="s1">const </span><span class="s0">cacheKeyWithoutSearchParams = (</span><span class="s4">0</span><span class="s0">, _createroutercachekey.createRouterCacheKey)(segment, </span><span class="s1">true</span><span class="s0">);</span>
        <span class="s1">const </span><span class="s0">cacheNode = childSegmentMap.get(cacheKey);</span>
        <span class="s1">if </span><span class="s0">(!cacheNode) {</span>
            <span class="s1">continue</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">item = findHeadInCacheImpl(cacheNode, childParallelRoutes, keyPrefix + </span><span class="s2">'/' </span><span class="s0">+ cacheKey, keyPrefix + </span><span class="s2">'/' </span><span class="s0">+ cacheKeyWithoutSearchParams);</span>
        <span class="s1">if </span><span class="s0">(item) {</span>
            <span class="s1">return </span><span class="s0">item;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">return null</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=find-head-in-cache.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/unresolved-thenable.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s3">/**</span>
 <span class="s3">* Create a &quot;Thenable&quot; that does not resolve. This is used to suspend indefinitely when data is not available yet.</span>
 <span class="s3">*/ </span><span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;unresolvedThenable&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">unresolvedThenable;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">unresolvedThenable = {</span>
    <span class="s0">then: ()=&gt;{}</span>
<span class="s0">};</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=unresolved-thenable.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/has-base-path.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;hasBasePath&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">hasBasePath;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_pathhasprefix = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">basePath = (</span><span class="s2">&quot;TURBOPACK compile-time value&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s0">) || </span><span class="s2">''</span><span class="s0">;</span>
<span class="s1">function </span><span class="s0">hasBasePath(path) {</span>
    <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _pathhasprefix.pathHasPrefix)(path, basePath);</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=has-base-path.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/remove-base-path.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;removeBasePath&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">removeBasePath;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_hasbasepath = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/has-base-path.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">basePath = (</span><span class="s2">&quot;TURBOPACK compile-time value&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s0">) || </span><span class="s2">''</span><span class="s0">;</span>
<span class="s1">function </span><span class="s0">removeBasePath(path) {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) </span><span class="s3">//TURBOPACK unreachable</span>
    <span class="s0">;</span>
    <span class="s3">// Can't trim the basePath if it has zero length!</span>
    <span class="s1">if </span><span class="s0">(basePath.length === </span><span class="s4">0</span><span class="s0">) </span><span class="s1">return </span><span class="s0">path;</span>
    <span class="s0">path = path.slice(basePath.length);</span>
    <span class="s1">if </span><span class="s0">(!path.startsWith(</span><span class="s2">'/'</span><span class="s0">)) path = </span><span class="s2">&quot;/&quot; </span><span class="s0">+ path;</span>
    <span class="s1">return </span><span class="s0">path;</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=remove-base-path.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/segment-cache.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s3">/**</span>
 <span class="s3">* Entry point to the Segment Cache implementation.</span>
 <span class="s3">*</span>
 <span class="s3">* All code related to the Segment Cache lives `segment-cache-impl` directory.</span>
 <span class="s3">* Callers access it through this indirection.</span>
 <span class="s3">*</span>
 <span class="s3">* This is to ensure the code is dead code eliminated from the bundle if the</span>
 <span class="s3">* flag is disabled.</span>
 <span class="s3">*</span>
 <span class="s3">* TODO: This is super tedious. Since experimental flags are an essential part</span>
 <span class="s3">* of our workflow, we should establish a better pattern for dead code</span>
 <span class="s3">* elimination. Ideally it would be done at the bundler level, like how React's</span>
 <span class="s3">* build process works. In the React repo, you don't even need to add any extra</span>
 <span class="s3">* configuration per experiment  if the code is not reachable, it gets stripped</span>
 <span class="s3">* from the build automatically by Rollup. Or, shorter term, we could stub out</span>
 <span class="s3">* experimental modules at build time by updating the build config, i.e. a more</span>
 <span class="s3">* automated version of what I'm doing manually in this file.</span>
 <span class="s3">*/ </span><span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s0">FetchStrategy: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">NavigationResultTag: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">PrefetchPriority: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">cancelPrefetchTask: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">createCacheKey: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">getCurrentCacheVersion: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">isPrefetchTaskDirty: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">navigate: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">prefetch: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">reschedulePrefetchTask: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">revalidateEntireCache: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">schedulePrefetchTask: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s0">FetchStrategy: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">FetchStrategy;</span>
    <span class="s0">},</span>
    <span class="s0">NavigationResultTag: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">NavigationResultTag;</span>
    <span class="s0">},</span>
    <span class="s0">PrefetchPriority: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">PrefetchPriority;</span>
    <span class="s0">},</span>
    <span class="s0">cancelPrefetchTask: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">cancelPrefetchTask;</span>
    <span class="s0">},</span>
    <span class="s0">createCacheKey: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">createCacheKey;</span>
    <span class="s0">},</span>
    <span class="s0">getCurrentCacheVersion: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">getCurrentCacheVersion;</span>
    <span class="s0">},</span>
    <span class="s0">isPrefetchTaskDirty: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">isPrefetchTaskDirty;</span>
    <span class="s0">},</span>
    <span class="s0">navigate: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">navigate;</span>
    <span class="s0">},</span>
    <span class="s0">prefetch: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">prefetch;</span>
    <span class="s0">},</span>
    <span class="s0">reschedulePrefetchTask: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">reschedulePrefetchTask;</span>
    <span class="s0">},</span>
    <span class="s0">revalidateEntireCache: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">revalidateEntireCache;</span>
    <span class="s0">},</span>
    <span class="s0">schedulePrefetchTask: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">schedulePrefetchTask;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">notEnabled = ()=&gt;{</span>
    <span class="s1">throw </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">Error(</span><span class="s2">'Segment Cache experiment is not enabled. This is a bug in Next.js.'</span><span class="s0">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s2">&quot;E654&quot;</span><span class="s0">,</span>
        <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">configurable: </span><span class="s1">true</span>
    <span class="s0">});</span>
<span class="s0">};</span>
<span class="s1">const </span><span class="s0">prefetch = (</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) ? </span><span class="s2">&quot;TURBOPACK unreachable&quot; </span><span class="s0">: notEnabled;</span>
<span class="s1">const </span><span class="s0">navigate = (</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) ? </span><span class="s2">&quot;TURBOPACK unreachable&quot; </span><span class="s0">: notEnabled;</span>
<span class="s1">const </span><span class="s0">revalidateEntireCache = (</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) ? </span><span class="s2">&quot;TURBOPACK unreachable&quot; </span><span class="s0">: notEnabled;</span>
<span class="s1">const </span><span class="s0">getCurrentCacheVersion = (</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) ? </span><span class="s2">&quot;TURBOPACK unreachable&quot; </span><span class="s0">: notEnabled;</span>
<span class="s1">const </span><span class="s0">schedulePrefetchTask = (</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) ? </span><span class="s2">&quot;TURBOPACK unreachable&quot; </span><span class="s0">: notEnabled;</span>
<span class="s1">const </span><span class="s0">cancelPrefetchTask = (</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) ? </span><span class="s2">&quot;TURBOPACK unreachable&quot; </span><span class="s0">: notEnabled;</span>
<span class="s1">const </span><span class="s0">reschedulePrefetchTask = (</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) ? </span><span class="s2">&quot;TURBOPACK unreachable&quot; </span><span class="s0">: notEnabled;</span>
<span class="s1">const </span><span class="s0">isPrefetchTaskDirty = (</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) ? </span><span class="s2">&quot;TURBOPACK unreachable&quot; </span><span class="s0">: notEnabled;</span>
<span class="s1">const </span><span class="s0">createCacheKey = (</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) ? </span><span class="s2">&quot;TURBOPACK unreachable&quot; </span><span class="s0">: notEnabled;</span>
<span class="s1">var </span><span class="s0">NavigationResultTag = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">function</span><span class="s0">(NavigationResultTag) {</span>
    <span class="s0">NavigationResultTag[NavigationResultTag[</span><span class="s2">&quot;MPA&quot;</span><span class="s0">] = </span><span class="s4">0</span><span class="s0">] = </span><span class="s2">&quot;MPA&quot;</span><span class="s0">;</span>
    <span class="s0">NavigationResultTag[NavigationResultTag[</span><span class="s2">&quot;Success&quot;</span><span class="s0">] = </span><span class="s4">1</span><span class="s0">] = </span><span class="s2">&quot;Success&quot;</span><span class="s0">;</span>
    <span class="s0">NavigationResultTag[NavigationResultTag[</span><span class="s2">&quot;NoOp&quot;</span><span class="s0">] = </span><span class="s4">2</span><span class="s0">] = </span><span class="s2">&quot;NoOp&quot;</span><span class="s0">;</span>
    <span class="s0">NavigationResultTag[NavigationResultTag[</span><span class="s2">&quot;Async&quot;</span><span class="s0">] = </span><span class="s4">3</span><span class="s0">] = </span><span class="s2">&quot;Async&quot;</span><span class="s0">;</span>
    <span class="s1">return </span><span class="s0">NavigationResultTag;</span>
<span class="s0">}({});</span>
<span class="s1">var </span><span class="s0">PrefetchPriority = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">function</span><span class="s0">(PrefetchPriority) {</span>
    <span class="s3">/**</span>
   <span class="s3">* Assigned to the most recently hovered/touched link. Special network</span>
   <span class="s3">* bandwidth is reserved for this task only. There's only ever one Intent-</span>
   <span class="s3">* priority task at a time; when a new Intent task is scheduled, the previous</span>
   <span class="s3">* one is bumped down to Default.</span>
   <span class="s3">*/ </span><span class="s0">PrefetchPriority[PrefetchPriority[</span><span class="s2">&quot;Intent&quot;</span><span class="s0">] = </span><span class="s4">2</span><span class="s0">] = </span><span class="s2">&quot;Intent&quot;</span><span class="s0">;</span>
    <span class="s3">/**</span>
   <span class="s3">* The default priority for prefetch tasks.</span>
   <span class="s3">*/ </span><span class="s0">PrefetchPriority[PrefetchPriority[</span><span class="s2">&quot;Default&quot;</span><span class="s0">] = </span><span class="s4">1</span><span class="s0">] = </span><span class="s2">&quot;Default&quot;</span><span class="s0">;</span>
    <span class="s3">/**</span>
   <span class="s3">* Assigned to tasks when they spawn non-blocking background work, like</span>
   <span class="s3">* revalidating a partially cached entry to see if more data is available.</span>
   <span class="s3">*/ </span><span class="s0">PrefetchPriority[PrefetchPriority[</span><span class="s2">&quot;Background&quot;</span><span class="s0">] = </span><span class="s4">0</span><span class="s0">] = </span><span class="s2">&quot;Background&quot;</span><span class="s0">;</span>
    <span class="s1">return </span><span class="s0">PrefetchPriority;</span>
<span class="s0">}({});</span>
<span class="s1">var </span><span class="s0">FetchStrategy = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">function</span><span class="s0">(FetchStrategy) {</span>
    <span class="s3">// Deliberately ordered so we can easily compare two segments</span>
    <span class="s3">// and determine if one segment is &quot;more specific&quot; than another</span>
    <span class="s3">// (i.e. if it's likely that it contains more data)</span>
    <span class="s0">FetchStrategy[FetchStrategy[</span><span class="s2">&quot;LoadingBoundary&quot;</span><span class="s0">] = </span><span class="s4">0</span><span class="s0">] = </span><span class="s2">&quot;LoadingBoundary&quot;</span><span class="s0">;</span>
    <span class="s0">FetchStrategy[FetchStrategy[</span><span class="s2">&quot;PPR&quot;</span><span class="s0">] = </span><span class="s4">1</span><span class="s0">] = </span><span class="s2">&quot;PPR&quot;</span><span class="s0">;</span>
    <span class="s0">FetchStrategy[FetchStrategy[</span><span class="s2">&quot;PPRRuntime&quot;</span><span class="s0">] = </span><span class="s4">2</span><span class="s0">] = </span><span class="s2">&quot;PPRRuntime&quot;</span><span class="s0">;</span>
    <span class="s0">FetchStrategy[FetchStrategy[</span><span class="s2">&quot;Full&quot;</span><span class="s0">] = </span><span class="s4">3</span><span class="s0">] = </span><span class="s2">&quot;Full&quot;</span><span class="s0">;</span>
    <span class="s1">return </span><span class="s0">FetchStrategy;</span>
<span class="s0">}({});</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=segment-cache.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/links.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s0">IDLE_LINK_STATUS: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">PENDING_LINK_STATUS: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">mountFormInstance: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">mountLinkInstance: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">onLinkVisibilityChanged: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">onNavigationIntent: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">pingVisibleLinks: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">setLinkForCurrentNavigation: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">unmountLinkForCurrentNavigation: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">unmountPrefetchableInstance: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s0">IDLE_LINK_STATUS: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">IDLE_LINK_STATUS;</span>
    <span class="s0">},</span>
    <span class="s0">PENDING_LINK_STATUS: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">PENDING_LINK_STATUS;</span>
    <span class="s0">},</span>
    <span class="s0">mountFormInstance: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">mountFormInstance;</span>
    <span class="s0">},</span>
    <span class="s0">mountLinkInstance: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">mountLinkInstance;</span>
    <span class="s0">},</span>
    <span class="s0">onLinkVisibilityChanged: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">onLinkVisibilityChanged;</span>
    <span class="s0">},</span>
    <span class="s0">onNavigationIntent: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">onNavigationIntent;</span>
    <span class="s0">},</span>
    <span class="s0">pingVisibleLinks: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">pingVisibleLinks;</span>
    <span class="s0">},</span>
    <span class="s0">setLinkForCurrentNavigation: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">setLinkForCurrentNavigation;</span>
    <span class="s0">},</span>
    <span class="s0">unmountLinkForCurrentNavigation: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">unmountLinkForCurrentNavigation;</span>
    <span class="s0">},</span>
    <span class="s0">unmountPrefetchableInstance: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">unmountPrefetchableInstance;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_approuterinstance = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/app-router-instance.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_approuter = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/app-router.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_segmentcache = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/segment-cache.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_react = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_routerreducertypes = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_invarianterror = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/invariant-error.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s3">// Tracks the most recently navigated link instance. When null, indicates</span>
<span class="s3">// the current navigation was not initiated by a link click.</span>
<span class="s1">let </span><span class="s0">linkForMostRecentNavigation = </span><span class="s1">null</span><span class="s0">;</span>
<span class="s1">const </span><span class="s0">PENDING_LINK_STATUS = {</span>
    <span class="s0">pending: </span><span class="s1">true</span>
<span class="s0">};</span>
<span class="s1">const </span><span class="s0">IDLE_LINK_STATUS = {</span>
    <span class="s0">pending: </span><span class="s1">false</span>
<span class="s0">};</span>
<span class="s1">function </span><span class="s0">setLinkForCurrentNavigation(link) {</span>
    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _react.startTransition)(()=&gt;{</span>
        <span class="s0">linkForMostRecentNavigation == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: linkForMostRecentNavigation.setOptimisticLinkStatus(IDLE_LINK_STATUS);</span>
        <span class="s0">link == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: link.setOptimisticLinkStatus(PENDING_LINK_STATUS);</span>
        <span class="s0">linkForMostRecentNavigation = link;</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">unmountLinkForCurrentNavigation(link) {</span>
    <span class="s1">if </span><span class="s0">(linkForMostRecentNavigation === link) {</span>
        <span class="s0">linkForMostRecentNavigation = </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s3">// Use a WeakMap to associate a Link instance with its DOM element. This is</span>
<span class="s3">// used by the IntersectionObserver to track the link's visibility.</span>
<span class="s1">const </span><span class="s0">prefetchable = </span><span class="s1">typeof </span><span class="s0">WeakMap === </span><span class="s2">'function' </span><span class="s0">? </span><span class="s1">new </span><span class="s0">WeakMap() : </span><span class="s1">new </span><span class="s0">Map();</span>
<span class="s3">// A Set of the currently visible links. We re-prefetch visible links after a</span>
<span class="s3">// cache invalidation, or when the current URL changes. It's a separate data</span>
<span class="s3">// structure from the WeakMap above because only the visible links need to</span>
<span class="s3">// be enumerated.</span>
<span class="s1">const </span><span class="s0">prefetchableAndVisible = </span><span class="s1">new </span><span class="s0">Set();</span>
<span class="s3">// A single IntersectionObserver instance shared by all &lt;Link&gt; components.</span>
<span class="s1">const </span><span class="s0">observer = </span><span class="s1">typeof </span><span class="s0">IntersectionObserver === </span><span class="s2">'function' </span><span class="s0">? </span><span class="s1">new </span><span class="s0">IntersectionObserver(handleIntersect, {</span>
    <span class="s0">rootMargin: </span><span class="s2">'200px'</span>
<span class="s0">}) : </span><span class="s1">null</span><span class="s0">;</span>
<span class="s1">function </span><span class="s0">observeVisibility(element, instance) {</span>
    <span class="s1">const </span><span class="s0">existingInstance = prefetchable.get(element);</span>
    <span class="s1">if </span><span class="s0">(existingInstance !== undefined) {</span>
        <span class="s3">// This shouldn't happen because each &lt;Link&gt; component should have its own</span>
        <span class="s3">// anchor tag instance, but it's defensive coding to avoid a memory leak in</span>
        <span class="s3">// case there's a logical error somewhere else.</span>
        <span class="s0">unmountPrefetchableInstance(element);</span>
    <span class="s0">}</span>
    <span class="s3">// Only track prefetchable links that have a valid prefetch URL</span>
    <span class="s0">prefetchable.set(element, instance);</span>
    <span class="s1">if </span><span class="s0">(observer !== </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">observer.observe(element);</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">coercePrefetchableUrl(href) {</span>
    <span class="s1">try </span><span class="s0">{</span>
        <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _approuter.createPrefetchURL)(href);</span>
    <span class="s0">} </span><span class="s1">catch </span><span class="s0">(e) {</span>
        <span class="s3">// createPrefetchURL sometimes throws an error if an invalid URL is</span>
        <span class="s3">// provided, though I'm not sure if it's actually necessary.</span>
        <span class="s3">// TODO: Consider removing the throw from the inner function, or change it</span>
        <span class="s3">// to reportError. Or maybe the error isn't even necessary for automatic</span>
        <span class="s3">// prefetches, just navigations.</span>
        <span class="s1">const </span><span class="s0">reportErrorFn = </span><span class="s1">typeof </span><span class="s0">reportError === </span><span class="s2">'function' </span><span class="s0">? reportError : console.error;</span>
        <span class="s0">reportErrorFn(</span><span class="s2">&quot;Cannot prefetch '&quot; </span><span class="s0">+ href + </span><span class="s2">&quot;' because it cannot be converted to a URL.&quot;</span><span class="s0">);</span>
        <span class="s1">return null</span><span class="s0">;</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">mountLinkInstance(element, href, router, fetchStrategy, prefetchEnabled, setOptimisticLinkStatus) {</span>
    <span class="s1">if </span><span class="s0">(prefetchEnabled) {</span>
        <span class="s1">const </span><span class="s0">prefetchURL = coercePrefetchableUrl(href);</span>
        <span class="s1">if </span><span class="s0">(prefetchURL !== </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s1">const </span><span class="s0">instance = {</span>
                <span class="s0">router,</span>
                <span class="s0">fetchStrategy,</span>
                <span class="s0">isVisible: </span><span class="s1">false</span><span class="s0">,</span>
                <span class="s0">prefetchTask: </span><span class="s1">null</span><span class="s0">,</span>
                <span class="s0">prefetchHref: prefetchURL.href,</span>
                <span class="s0">setOptimisticLinkStatus</span>
            <span class="s0">};</span>
            <span class="s3">// We only observe the link's visibility if it's prefetchable. For</span>
            <span class="s3">// example, this excludes links to external URLs.</span>
            <span class="s0">observeVisibility(element, instance);</span>
            <span class="s1">return </span><span class="s0">instance;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s3">// If the link is not prefetchable, we still create an instance so we can</span>
    <span class="s3">// track its optimistic state (i.e. useLinkStatus).</span>
    <span class="s1">const </span><span class="s0">instance = {</span>
        <span class="s0">router,</span>
        <span class="s0">fetchStrategy,</span>
        <span class="s0">isVisible: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">prefetchTask: </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">prefetchHref: </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">setOptimisticLinkStatus</span>
    <span class="s0">};</span>
    <span class="s1">return </span><span class="s0">instance;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">mountFormInstance(element, href, router, fetchStrategy) {</span>
    <span class="s1">const </span><span class="s0">prefetchURL = coercePrefetchableUrl(href);</span>
    <span class="s1">if </span><span class="s0">(prefetchURL === </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s3">// This href is not prefetchable, so we don't track it.</span>
        <span class="s3">// TODO: We currently observe/unobserve a form every time its href changes.</span>
        <span class="s3">// For Links, this isn't a big deal because the href doesn't usually change,</span>
        <span class="s3">// but for forms it's extremely common. We should optimize this.</span>
        <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">instance = {</span>
        <span class="s0">router,</span>
        <span class="s0">fetchStrategy,</span>
        <span class="s0">isVisible: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">prefetchTask: </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">prefetchHref: prefetchURL.href,</span>
        <span class="s0">setOptimisticLinkStatus: </span><span class="s1">null</span>
    <span class="s0">};</span>
    <span class="s0">observeVisibility(element, instance);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">unmountPrefetchableInstance(element) {</span>
    <span class="s1">const </span><span class="s0">instance = prefetchable.get(element);</span>
    <span class="s1">if </span><span class="s0">(instance !== undefined) {</span>
        <span class="s0">prefetchable.delete(element);</span>
        <span class="s0">prefetchableAndVisible.delete(instance);</span>
        <span class="s1">const </span><span class="s0">prefetchTask = instance.prefetchTask;</span>
        <span class="s1">if </span><span class="s0">(prefetchTask !== </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s0">(</span><span class="s4">0</span><span class="s0">, _segmentcache.cancelPrefetchTask)(prefetchTask);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(observer !== </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">observer.unobserve(element);</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">handleIntersect(entries) {</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">entry of entries){</span>
        <span class="s3">// Some extremely old browsers or polyfills don't reliably support</span>
        <span class="s3">// isIntersecting so we check intersectionRatio instead. (Do we care? Not</span>
        <span class="s3">// really. But whatever this is fine.)</span>
        <span class="s1">const </span><span class="s0">isVisible = entry.intersectionRatio &gt; </span><span class="s4">0</span><span class="s0">;</span>
        <span class="s0">onLinkVisibilityChanged(entry.target, isVisible);</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">onLinkVisibilityChanged(element, isVisible) {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s0">) {</span>
        <span class="s3">// Prefetching on viewport is disabled in development for performance</span>
        <span class="s3">// reasons, because it requires compiling the target page.</span>
        <span class="s3">// TODO: Investigate re-enabling this.</span>
        <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s3">//TURBOPACK unreachable</span>
    <span class="s0">;</span>
    <span class="s1">const </span><span class="s0">instance = undefined;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">onNavigationIntent(element, unstable_upgradeToDynamicPrefetch) {</span>
    <span class="s1">const </span><span class="s0">instance = prefetchable.get(element);</span>
    <span class="s1">if </span><span class="s0">(instance === undefined) {</span>
        <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s3">// Prefetch the link on hover/touchstart.</span>
    <span class="s1">if </span><span class="s0">(instance !== undefined) {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) </span><span class="s3">//TURBOPACK unreachable</span>
        <span class="s0">;</span>
        <span class="s0">rescheduleLinkPrefetch(instance, _segmentcache.PrefetchPriority.Intent);</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">rescheduleLinkPrefetch(instance, priority) {</span>
    <span class="s1">const </span><span class="s0">existingPrefetchTask = instance.prefetchTask;</span>
    <span class="s1">if </span><span class="s0">(!instance.isVisible) {</span>
        <span class="s3">// Cancel any in-progress prefetch task. (If it already finished then this</span>
        <span class="s3">// is a no-op.)</span>
        <span class="s1">if </span><span class="s0">(existingPrefetchTask !== </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s0">(</span><span class="s4">0</span><span class="s0">, _segmentcache.cancelPrefetchTask)(existingPrefetchTask);</span>
        <span class="s0">}</span>
        <span class="s3">// We don't need to reset the prefetchTask to null upon cancellation; an</span>
        <span class="s3">// old task object can be rescheduled with reschedulePrefetchTask. This is a</span>
        <span class="s3">// micro-optimization but also makes the code simpler (don't need to</span>
        <span class="s3">// worry about whether an old task object is stale).</span>
        <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s0">) {</span>
        <span class="s3">// The old prefetch implementation does not have different priority levels.</span>
        <span class="s3">// Just schedule a new prefetch task.</span>
        <span class="s0">prefetchWithOldCacheImplementation(instance);</span>
        <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s3">//TURBOPACK unreachable</span>
    <span class="s0">;</span>
    <span class="s1">const </span><span class="s0">appRouterState = undefined;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">pingVisibleLinks(nextUrl, tree) {</span>
    <span class="s3">// For each currently visible link, cancel the existing prefetch task (if it</span>
    <span class="s3">// exists) and schedule a new one. This is effectively the same as if all the</span>
    <span class="s3">// visible links left and then re-entered the viewport.</span>
    <span class="s3">//</span>
    <span class="s3">// This is called when the Next-Url or the base tree changes, since those</span>
    <span class="s3">// may affect the result of a prefetch task. It's also called after a</span>
    <span class="s3">// cache invalidation.</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">instance of prefetchableAndVisible){</span>
        <span class="s1">const </span><span class="s0">task = instance.prefetchTask;</span>
        <span class="s1">if </span><span class="s0">(task !== </span><span class="s1">null </span><span class="s0">&amp;&amp; !(</span><span class="s4">0</span><span class="s0">, _segmentcache.isPrefetchTaskDirty)(task, nextUrl, tree)) {</span>
            <span class="s1">continue</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s3">// Something changed. Cancel the existing prefetch task and schedule a</span>
        <span class="s3">// new one.</span>
        <span class="s1">if </span><span class="s0">(task !== </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s0">(</span><span class="s4">0</span><span class="s0">, _segmentcache.cancelPrefetchTask)(task);</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">cacheKey = (</span><span class="s4">0</span><span class="s0">, _segmentcache.createCacheKey)(instance.prefetchHref, nextUrl);</span>
        <span class="s0">instance.prefetchTask = (</span><span class="s4">0</span><span class="s0">, _segmentcache.schedulePrefetchTask)(cacheKey, tree, instance.fetchStrategy, _segmentcache.PrefetchPriority.Default, </span><span class="s1">null</span><span class="s0">);</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">prefetchWithOldCacheImplementation(instance) {</span>
    <span class="s3">// This is the path used when the Segment Cache is not enabled.</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">window === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
        <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">doPrefetch = async ()=&gt;{</span>
        <span class="s3">// note that `appRouter.prefetch()` is currently sync,</span>
        <span class="s3">// so we have to wrap this call in an async function to be able to catch() errors below.</span>
        <span class="s1">let </span><span class="s0">prefetchKind;</span>
        <span class="s1">switch</span><span class="s0">(instance.fetchStrategy){</span>
            <span class="s1">case </span><span class="s0">_segmentcache.FetchStrategy.PPR:</span>
                <span class="s0">{</span>
                    <span class="s0">prefetchKind = _routerreducertypes.PrefetchKind.AUTO;</span>
                    <span class="s1">break</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s1">case </span><span class="s0">_segmentcache.FetchStrategy.Full:</span>
                <span class="s0">{</span>
                    <span class="s0">prefetchKind = _routerreducertypes.PrefetchKind.FULL;</span>
                    <span class="s1">break</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s1">case </span><span class="s0">_segmentcache.FetchStrategy.PPRRuntime:</span>
                <span class="s0">{</span>
                    <span class="s3">// We can only get here if Client Segment Cache is off, and in that case</span>
                    <span class="s3">// it shouldn't be possible for a link to request a runtime prefetch.</span>
                    <span class="s1">throw </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">_invarianterror.InvariantError(</span><span class="s2">'FetchStrategy.PPRRuntime should never be used when `experimental.clientSegmentCache` is disabled'</span><span class="s0">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
                        <span class="s0">value: </span><span class="s2">&quot;E772&quot;</span><span class="s0">,</span>
                        <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
                        <span class="s0">configurable: </span><span class="s1">true</span>
                    <span class="s0">});</span>
                <span class="s0">}</span>
            <span class="s1">default</span><span class="s0">:</span>
                <span class="s0">{</span>
                    <span class="s0">instance.fetchStrategy;</span>
                    <span class="s3">// Unreachable, but otherwise typescript will consider the variable unassigned</span>
                    <span class="s0">prefetchKind = undefined;</span>
                <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">instance.router.prefetch(instance.prefetchHref, {</span>
            <span class="s0">kind: prefetchKind</span>
        <span class="s0">});</span>
    <span class="s0">};</span>
    <span class="s3">// Prefetch the page if asked (only in the client)</span>
    <span class="s3">// We need to handle a prefetch error here since we may be</span>
    <span class="s3">// loading with priority which can reject but we don't</span>
    <span class="s3">// want to force navigation since this is only a prefetch</span>
    <span class="s0">doPrefetch().catch((err)=&gt;{</span>
        <span class="s1">if </span><span class="s0">((</span><span class="s2">&quot;TURBOPACK compile-time value&quot;</span><span class="s0">, </span><span class="s2">&quot;development&quot;</span><span class="s0">) !== </span><span class="s2">'production'</span><span class="s0">) {</span>
            <span class="s3">// rethrow to show invalid URL errors</span>
            <span class="s1">throw </span><span class="s0">err;</span>
        <span class="s0">}</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=links.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/errors/graceful-degrade-boundary.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s0">GracefulDegradeBoundary: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s1">default</span><span class="s0">: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s0">GracefulDegradeBoundary: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">GracefulDegradeBoundary;</span>
    <span class="s0">},</span>
    <span class="s1">default</span><span class="s0">: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">_default;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_jsxruntime = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_react = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">getDomNodeAttributes(node) {</span>
    <span class="s1">const </span><span class="s0">result = {};</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; node.attributes.length; i++){</span>
        <span class="s1">const </span><span class="s0">attr = node.attributes[i];</span>
        <span class="s0">result[attr.name] = attr.value;</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">result;</span>
<span class="s0">}</span>
<span class="s1">class </span><span class="s0">GracefulDegradeBoundary </span><span class="s1">extends </span><span class="s0">_react.Component {</span>
    <span class="s1">static </span><span class="s0">getDerivedStateFromError(_) {</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">hasError: </span><span class="s1">true</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s0">componentDidMount() {</span>
        <span class="s1">const </span><span class="s0">htmlNode = </span><span class="s1">this</span><span class="s0">.htmlRef.current;</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.state.hasError &amp;&amp; htmlNode) {</span>
            <span class="s3">// Reapply the cached HTML attributes to the root element</span>
            <span class="s0">Object.entries(</span><span class="s1">this</span><span class="s0">.htmlAttributes).forEach((param)=&gt;{</span>
                <span class="s1">let </span><span class="s0">[key, value] = param;</span>
                <span class="s0">htmlNode.setAttribute(key, value);</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">render() {</span>
        <span class="s1">const </span><span class="s0">{ hasError } = </span><span class="s1">this</span><span class="s0">.state;</span>
        <span class="s3">// Cache the root HTML content on the first render</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">window !== </span><span class="s2">'undefined' </span><span class="s0">&amp;&amp; !</span><span class="s1">this</span><span class="s0">.rootHtml) {</span>
            <span class="s1">this</span><span class="s0">.rootHtml = document.documentElement.innerHTML;</span>
            <span class="s1">this</span><span class="s0">.htmlAttributes = getDomNodeAttributes(document.documentElement);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(hasError) {</span>
            <span class="s3">// Render the current HTML content without hydration</span>
            <span class="s1">return </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(</span><span class="s2">&quot;html&quot;</span><span class="s0">, {</span>
                <span class="s0">ref: </span><span class="s1">this</span><span class="s0">.htmlRef,</span>
                <span class="s0">suppressHydrationWarning: </span><span class="s1">true</span><span class="s0">,</span>
                <span class="s0">dangerouslySetInnerHTML: {</span>
                    <span class="s0">__html: </span><span class="s1">this</span><span class="s0">.rootHtml</span>
                <span class="s0">}</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s1">return this</span><span class="s0">.props.children;</span>
    <span class="s0">}</span>
    <span class="s0">constructor(props){</span>
        <span class="s1">super</span><span class="s0">(props);</span>
        <span class="s1">this</span><span class="s0">.state = {</span>
            <span class="s0">hasError: </span><span class="s1">false</span>
        <span class="s0">};</span>
        <span class="s1">this</span><span class="s0">.rootHtml = </span><span class="s2">''</span><span class="s0">;</span>
        <span class="s1">this</span><span class="s0">.htmlAttributes = {};</span>
        <span class="s1">this</span><span class="s0">.htmlRef = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _react.createRef)();</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">const </span><span class="s0">_default = GracefulDegradeBoundary;</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=graceful-degrade-boundary.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/errors/root-error-boundary.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;default&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">RootErrorBoundary;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_interop_require_default = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_jsxruntime = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_react = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">_interop_require_default._(__turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)&quot;</span><span class="s0">));</span>
<span class="s1">const </span><span class="s0">_gracefuldegradeboundary = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">_interop_require_default._(__turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/errors/graceful-degrade-boundary.js [app-client] (ecmascript)&quot;</span><span class="s0">));</span>
<span class="s1">const </span><span class="s0">_errorboundary = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/error-boundary.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_isbot = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/router/utils/is-bot.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">isBotUserAgent = </span><span class="s1">typeof </span><span class="s0">window !== </span><span class="s2">'undefined' </span><span class="s0">&amp;&amp; (</span><span class="s4">0</span><span class="s0">, _isbot.isBot)(window.navigator.userAgent);</span>
<span class="s1">function </span><span class="s0">RootErrorBoundary(param) {</span>
    <span class="s1">let </span><span class="s0">{ children, errorComponent, errorStyles, errorScripts } = param;</span>
    <span class="s1">if </span><span class="s0">(isBotUserAgent) {</span>
        <span class="s3">// Preserve existing DOM/HTML for bots to avoid replacing content with an error UI</span>
        <span class="s3">// and to keep the original SSR output intact.</span>
        <span class="s1">return </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(_gracefuldegradeboundary.default, {</span>
            <span class="s0">children: children</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(_errorboundary.ErrorBoundary, {</span>
        <span class="s0">errorComponent: errorComponent,</span>
        <span class="s0">errorStyles: errorStyles,</span>
        <span class="s0">errorScripts: errorScripts,</span>
        <span class="s0">children: children</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=root-error-boundary.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/http-access-fallback/error-boundary.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">'use client'</span><span class="s0">;</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;HTTPAccessFallbackBoundary&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">HTTPAccessFallbackBoundary;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_interop_require_wildcard = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_jsxruntime = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_react = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">_interop_require_wildcard._(__turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)&quot;</span><span class="s0">));</span>
<span class="s1">const </span><span class="s0">_navigationuntracked = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/navigation-untracked.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_httpaccessfallback = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/http-access-fallback/http-access-fallback.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_warnonce = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/utils/warn-once.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_approutercontextsharedruntime = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">class </span><span class="s0">HTTPAccessFallbackErrorBoundary </span><span class="s1">extends </span><span class="s0">_react.default.Component {</span>
    <span class="s0">componentDidCatch() {</span>
        <span class="s1">if </span><span class="s0">((</span><span class="s2">&quot;TURBOPACK compile-time value&quot;</span><span class="s0">, </span><span class="s2">&quot;development&quot;</span><span class="s0">) === </span><span class="s2">'development' </span><span class="s0">&amp;&amp; </span><span class="s1">this</span><span class="s0">.props.missingSlots &amp;&amp; </span><span class="s1">this</span><span class="s0">.props.missingSlots.size &gt; </span><span class="s4">0 </span><span class="s0">&amp;&amp; </span><span class="s3">// A missing children slot is the typical not-found case, so no need to warn</span>
        <span class="s0">!</span><span class="s1">this</span><span class="s0">.props.missingSlots.has(</span><span class="s2">'children'</span><span class="s0">)) {</span>
            <span class="s1">let </span><span class="s0">warningMessage = </span><span class="s2">'No default component was found for a parallel route rendered on this page. Falling back to nearest NotFound boundary.</span><span class="s6">\n</span><span class="s2">' </span><span class="s0">+ </span><span class="s2">'Learn more: https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#defaultjs</span><span class="s6">\n\n</span><span class="s2">'</span><span class="s0">;</span>
            <span class="s1">const </span><span class="s0">formattedSlots = Array.from(</span><span class="s1">this</span><span class="s0">.props.missingSlots).sort((a, b)=&gt;a.localeCompare(b)).map((slot)=&gt;</span><span class="s2">&quot;@&quot; </span><span class="s0">+ slot).join(</span><span class="s2">', '</span><span class="s0">);</span>
            <span class="s0">warningMessage += </span><span class="s2">'Missing slots: ' </span><span class="s0">+ formattedSlots;</span>
            <span class="s0">(</span><span class="s4">0</span><span class="s0">, _warnonce.warnOnce)(warningMessage);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">static </span><span class="s0">getDerivedStateFromError(error) {</span>
        <span class="s1">if </span><span class="s0">((</span><span class="s4">0</span><span class="s0">, _httpaccessfallback.isHTTPAccessFallbackError)(error)) {</span>
            <span class="s1">const </span><span class="s0">httpStatus = (</span><span class="s4">0</span><span class="s0">, _httpaccessfallback.getAccessFallbackHTTPStatus)(error);</span>
            <span class="s1">return </span><span class="s0">{</span>
                <span class="s0">triggeredStatus: httpStatus</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s3">// Re-throw if error is not for 404</span>
        <span class="s1">throw </span><span class="s0">error;</span>
    <span class="s0">}</span>
    <span class="s1">static </span><span class="s0">getDerivedStateFromProps(props, state) {</span>
        <span class="s3">/**</span>
     <span class="s3">* Handles reset of the error boundary when a navigation happens.</span>
     <span class="s3">* Ensures the error boundary does not stay enabled when navigating to a new page.</span>
     <span class="s3">* Approach of setState in render is safe as it checks the previous pathname and then overrides</span>
     <span class="s3">* it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders</span>
     <span class="s3">*/ </span><span class="s1">if </span><span class="s0">(props.pathname !== state.previousPathname &amp;&amp; state.triggeredStatus) {</span>
            <span class="s1">return </span><span class="s0">{</span>
                <span class="s0">triggeredStatus: undefined,</span>
                <span class="s0">previousPathname: props.pathname</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">triggeredStatus: state.triggeredStatus,</span>
            <span class="s0">previousPathname: props.pathname</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
    <span class="s0">render() {</span>
        <span class="s1">const </span><span class="s0">{ notFound, forbidden, unauthorized, children } = </span><span class="s1">this</span><span class="s0">.props;</span>
        <span class="s1">const </span><span class="s0">{ triggeredStatus } = </span><span class="s1">this</span><span class="s0">.state;</span>
        <span class="s1">const </span><span class="s0">errorComponents = {</span>
            <span class="s0">[_httpaccessfallback.HTTPAccessErrorStatus.NOT_FOUND]: notFound,</span>
            <span class="s0">[_httpaccessfallback.HTTPAccessErrorStatus.FORBIDDEN]: forbidden,</span>
            <span class="s0">[_httpaccessfallback.HTTPAccessErrorStatus.UNAUTHORIZED]: unauthorized</span>
        <span class="s0">};</span>
        <span class="s1">if </span><span class="s0">(triggeredStatus) {</span>
            <span class="s1">const </span><span class="s0">isNotFound = triggeredStatus === _httpaccessfallback.HTTPAccessErrorStatus.NOT_FOUND &amp;&amp; notFound;</span>
            <span class="s1">const </span><span class="s0">isForbidden = triggeredStatus === _httpaccessfallback.HTTPAccessErrorStatus.FORBIDDEN &amp;&amp; forbidden;</span>
            <span class="s1">const </span><span class="s0">isUnauthorized = triggeredStatus === _httpaccessfallback.HTTPAccessErrorStatus.UNAUTHORIZED &amp;&amp; unauthorized;</span>
            <span class="s3">// If there's no matched boundary in this layer, keep throwing the error by rendering the children</span>
            <span class="s1">if </span><span class="s0">(!(isNotFound || isForbidden || isUnauthorized)) {</span>
                <span class="s1">return </span><span class="s0">children;</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsxs)(_jsxruntime.Fragment, {</span>
                <span class="s0">children: [</span>
                    <span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(</span><span class="s2">&quot;meta&quot;</span><span class="s0">, {</span>
                        <span class="s0">name: </span><span class="s2">&quot;robots&quot;</span><span class="s0">,</span>
                        <span class="s0">content: </span><span class="s2">&quot;noindex&quot;</span>
                    <span class="s0">}),</span>
                    <span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time value&quot;</span><span class="s0">, </span><span class="s2">&quot;development&quot;</span><span class="s0">) === </span><span class="s2">'development' </span><span class="s0">&amp;&amp; </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(</span><span class="s2">&quot;meta&quot;</span><span class="s0">, {</span>
                        <span class="s0">name: </span><span class="s2">&quot;boundary-next-error&quot;</span><span class="s0">,</span>
                        <span class="s0">content: (</span><span class="s4">0</span><span class="s0">, _httpaccessfallback.getAccessFallbackErrorTypeByStatus)(triggeredStatus)</span>
                    <span class="s0">}),</span>
                    <span class="s0">errorComponents[triggeredStatus]</span>
                <span class="s0">]</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">children;</span>
    <span class="s0">}</span>
    <span class="s0">constructor(props){</span>
        <span class="s1">super</span><span class="s0">(props);</span>
        <span class="s1">this</span><span class="s0">.state = {</span>
            <span class="s0">triggeredStatus: undefined,</span>
            <span class="s0">previousPathname: props.pathname</span>
        <span class="s0">};</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">HTTPAccessFallbackBoundary(param) {</span>
    <span class="s1">let </span><span class="s0">{ notFound, forbidden, unauthorized, children } = param;</span>
    <span class="s3">// When we're rendering the missing params shell, this will return null. This</span>
    <span class="s3">// is because we won't be rendering any not found boundaries or error</span>
    <span class="s3">// boundaries for the missing params shell. When this runs on the client</span>
    <span class="s3">// (where these error can occur), we will get the correct pathname.</span>
    <span class="s1">const </span><span class="s0">pathname = (</span><span class="s4">0</span><span class="s0">, _navigationuntracked.useUntrackedPathname)();</span>
    <span class="s1">const </span><span class="s0">missingSlots = (</span><span class="s4">0</span><span class="s0">, _react.useContext)(_approutercontextsharedruntime.MissingSlotContext);</span>
    <span class="s1">const </span><span class="s0">hasErrorFallback = !!(notFound || forbidden || unauthorized);</span>
    <span class="s1">if </span><span class="s0">(hasErrorFallback) {</span>
        <span class="s1">return </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(HTTPAccessFallbackErrorBoundary, {</span>
            <span class="s0">pathname: pathname,</span>
            <span class="s0">notFound: notFound,</span>
            <span class="s0">forbidden: forbidden,</span>
            <span class="s0">unauthorized: unauthorized,</span>
            <span class="s0">missingSlots: missingSlots,</span>
            <span class="s0">children: children</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(_jsxruntime.Fragment, {</span>
        <span class="s0">children: children</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=error-boundary.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/dev-root-http-access-fallback-boundary.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s0">DevRootHTTPAccessFallbackBoundary: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">bailOnRootNotFound: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s0">DevRootHTTPAccessFallbackBoundary: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">DevRootHTTPAccessFallbackBoundary;</span>
    <span class="s0">},</span>
    <span class="s0">bailOnRootNotFound: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">bailOnRootNotFound;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_interop_require_default = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_jsxruntime = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_react = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">_interop_require_default._(__turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)&quot;</span><span class="s0">));</span>
<span class="s1">const </span><span class="s0">_errorboundary = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/http-access-fallback/error-boundary.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">bailOnRootNotFound() {</span>
    <span class="s1">throw </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">Error(</span><span class="s2">'notFound() is not allowed to use in root layout'</span><span class="s0">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s2">&quot;E192&quot;</span><span class="s0">,</span>
        <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s0">configurable: </span><span class="s1">true</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">NotAllowedRootHTTPFallbackError() {</span>
    <span class="s0">bailOnRootNotFound();</span>
    <span class="s1">return null</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">DevRootHTTPAccessFallbackBoundary(param) {</span>
    <span class="s1">let </span><span class="s0">{ children } = param;</span>
    <span class="s1">return </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(_errorboundary.HTTPAccessFallbackBoundary, {</span>
        <span class="s0">notFound: </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(NotAllowedRootHTTPFallbackError, {}),</span>
        <span class="s0">children: children</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=dev-root-http-access-fallback-boundary.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/dev/hot-reloader/shared.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s0">REACT_REFRESH_FULL_RELOAD: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">REACT_REFRESH_FULL_RELOAD_FROM_ERROR: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">reportInvalidHmrMessage: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s0">REACT_REFRESH_FULL_RELOAD: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">REACT_REFRESH_FULL_RELOAD;</span>
    <span class="s0">},</span>
    <span class="s0">REACT_REFRESH_FULL_RELOAD_FROM_ERROR: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">REACT_REFRESH_FULL_RELOAD_FROM_ERROR;</span>
    <span class="s0">},</span>
    <span class="s0">reportInvalidHmrMessage: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">reportInvalidHmrMessage;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">REACT_REFRESH_FULL_RELOAD = </span><span class="s2">'[Fast Refresh] performing full reload</span><span class="s6">\n\n</span><span class="s2">' </span><span class="s0">+ </span><span class="s2">&quot;Fast Refresh will perform a full reload when you edit a file that's imported by modules outside of the React rendering tree.</span><span class="s6">\n</span><span class="s2">&quot; </span><span class="s0">+ </span><span class="s2">'You might have a file which exports a React component but also exports a value that is imported by a non-React component file.</span><span class="s6">\n</span><span class="s2">' </span><span class="s0">+ </span><span class="s2">'Consider migrating the non-React component export to a separate file and importing it into both files.</span><span class="s6">\n\n</span><span class="s2">' </span><span class="s0">+ </span><span class="s2">'It is also possible the parent component of the component you edited is a class component, which disables Fast Refresh.</span><span class="s6">\n</span><span class="s2">' </span><span class="s0">+ </span><span class="s2">'Fast Refresh requires at least one parent function component in your React tree.'</span><span class="s0">;</span>
<span class="s1">const </span><span class="s0">REACT_REFRESH_FULL_RELOAD_FROM_ERROR = </span><span class="s2">'[Fast Refresh] performing full reload because your application had an unrecoverable error'</span><span class="s0">;</span>
<span class="s1">function </span><span class="s0">reportInvalidHmrMessage(message, err) {</span>
    <span class="s0">console.warn(</span><span class="s2">'[HMR] Invalid message: ' </span><span class="s0">+ JSON.stringify(message) + </span><span class="s2">'</span><span class="s6">\n</span><span class="s2">' </span><span class="s0">+ (err </span><span class="s1">instanceof </span><span class="s0">Error &amp;&amp; (err == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: err.stack) || </span><span class="s2">''</span><span class="s0">));</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=shared.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/dev/hot-reloader/get-socket-url.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;getSocketUrl&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">getSocketUrl;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_normalizedassetprefix = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/normalized-asset-prefix.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">getSocketProtocol(assetPrefix) {</span>
    <span class="s1">let </span><span class="s0">protocol = window.location.protocol;</span>
    <span class="s1">try </span><span class="s0">{</span>
        <span class="s3">// assetPrefix is a url</span>
        <span class="s0">protocol = </span><span class="s1">new </span><span class="s0">URL(assetPrefix).protocol;</span>
    <span class="s0">} </span><span class="s1">catch </span><span class="s0">(e) {}</span>
    <span class="s1">return </span><span class="s0">protocol === </span><span class="s2">'http:' </span><span class="s0">? </span><span class="s2">'ws:' </span><span class="s0">: </span><span class="s2">'wss:'</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">getSocketUrl(assetPrefix) {</span>
    <span class="s1">const </span><span class="s0">prefix = (</span><span class="s4">0</span><span class="s0">, _normalizedassetprefix.normalizedAssetPrefix)(assetPrefix);</span>
    <span class="s1">const </span><span class="s0">protocol = getSocketProtocol(assetPrefix || </span><span class="s2">''</span><span class="s0">);</span>
    <span class="s1">if </span><span class="s0">(URL.canParse(prefix)) {</span>
        <span class="s3">// since normalized asset prefix is ensured to be a URL format,</span>
        <span class="s3">// we can safely replace the protocol</span>
        <span class="s1">return </span><span class="s0">prefix.replace(</span><span class="s7">/^http/</span><span class="s0">, </span><span class="s2">'ws'</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">{ hostname, port } = window.location;</span>
    <span class="s1">return </span><span class="s0">protocol + </span><span class="s2">&quot;//&quot; </span><span class="s0">+ hostname + (port ? </span><span class="s2">&quot;:&quot; </span><span class="s0">+ port : </span><span class="s2">''</span><span class="s0">) + prefix;</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=get-socket-url.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/dev/hot-reloader/app/use-websocket.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s0">useSendMessage: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">useTurbopack: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">useWebsocket: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">useWebsocketPing: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s0">useSendMessage: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">useSendMessage;</span>
    <span class="s0">},</span>
    <span class="s0">useTurbopack: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">useTurbopack;</span>
    <span class="s0">},</span>
    <span class="s0">useWebsocket: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">useWebsocket;</span>
    <span class="s0">},</span>
    <span class="s0">useWebsocketPing: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">useWebsocketPing;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_react = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_approutercontextsharedruntime = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_getsocketurl = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/dev/hot-reloader/get-socket-url.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">useWebsocket(assetPrefix) {</span>
    <span class="s1">const </span><span class="s0">webSocketRef = (</span><span class="s4">0</span><span class="s0">, _react.useRef)(undefined);</span>
    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _react.useEffect)(()=&gt;{</span>
        <span class="s1">if </span><span class="s0">(webSocketRef.current) {</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">url = (</span><span class="s4">0</span><span class="s0">, _getsocketurl.getSocketUrl)(assetPrefix);</span>
        <span class="s0">webSocketRef.current = </span><span class="s1">new </span><span class="s0">window.WebSocket(</span><span class="s2">&quot;&quot; </span><span class="s0">+ url + </span><span class="s2">&quot;/_next/webpack-hmr&quot;</span><span class="s0">);</span>
    <span class="s0">}, [</span>
        <span class="s0">assetPrefix</span>
    <span class="s0">]);</span>
    <span class="s1">return </span><span class="s0">webSocketRef;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">useSendMessage(webSocketRef) {</span>
    <span class="s1">const </span><span class="s0">sendMessage = (</span><span class="s4">0</span><span class="s0">, _react.useCallback)((data)=&gt;{</span>
        <span class="s1">const </span><span class="s0">socket = webSocketRef.current;</span>
        <span class="s1">if </span><span class="s0">(!socket || socket.readyState !== socket.OPEN) {</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">socket.send(data);</span>
    <span class="s0">}, [</span>
        <span class="s0">webSocketRef</span>
    <span class="s0">]);</span>
    <span class="s1">return </span><span class="s0">sendMessage;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">useTurbopack(sendMessage, onUpdateError) {</span>
    <span class="s1">const </span><span class="s0">turbopackState = (</span><span class="s4">0</span><span class="s0">, _react.useRef)({</span>
        <span class="s0">init: </span><span class="s1">false</span><span class="s0">,</span>
        <span class="s3">// Until the dynamic import resolves, queue any turbopack messages which will be replayed.</span>
        <span class="s0">queue: [],</span>
        <span class="s0">callback: undefined</span>
    <span class="s0">});</span>
    <span class="s1">const </span><span class="s0">processTurbopackMessage = (</span><span class="s4">0</span><span class="s0">, _react.useCallback)((msg)=&gt;{</span>
        <span class="s1">const </span><span class="s0">{ callback, queue } = turbopackState.current;</span>
        <span class="s1">if </span><span class="s0">(callback) {</span>
            <span class="s0">callback(msg);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">queue.push(msg);</span>
        <span class="s0">}</span>
    <span class="s0">}, []);</span>
    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _react.useEffect)(()=&gt;{</span>
        <span class="s1">const </span><span class="s0">{ current: initCurrent } = turbopackState;</span>
        <span class="s3">// TODO(WEB-1589): only install if `process.turbopack` set.</span>
        <span class="s1">if </span><span class="s0">(initCurrent.init) {</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">initCurrent.init = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s0">__turbopack_context__.A(</span><span class="s2">&quot;[turbopack]/browser/dev/hmr-client/hmr-client.ts [app-client] (ecmascript, async loader)&quot;</span><span class="s0">).then((param)=&gt;{</span>
            <span class="s1">let </span><span class="s0">{ connect } = param;</span>
            <span class="s1">const </span><span class="s0">{ current } = turbopackState;</span>
            <span class="s0">connect({</span>
                <span class="s0">addMessageListener (cb) {</span>
                    <span class="s0">current.callback = cb;</span>
                    <span class="s3">// Replay all Turbopack messages before we were able to establish the HMR client.</span>
                    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">msg of current.queue){</span>
                        <span class="s0">cb(msg);</span>
                    <span class="s0">}</span>
                    <span class="s0">current.queue = undefined;</span>
                <span class="s0">},</span>
                <span class="s0">sendMessage,</span>
                <span class="s0">onUpdateError</span>
            <span class="s0">});</span>
        <span class="s0">});</span>
    <span class="s0">}, [</span>
        <span class="s0">sendMessage,</span>
        <span class="s0">onUpdateError</span>
    <span class="s0">]);</span>
    <span class="s1">return </span><span class="s0">processTurbopackMessage;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">useWebsocketPing(websocketRef) {</span>
    <span class="s1">const </span><span class="s0">sendMessage = useSendMessage(websocketRef);</span>
    <span class="s1">const </span><span class="s0">{ tree } = (</span><span class="s4">0</span><span class="s0">, _react.useContext)(_approutercontextsharedruntime.GlobalLayoutRouterContext);</span>
    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _react.useEffect)(()=&gt;{</span>
        <span class="s3">// Never send pings when using Turbopack as it's not used.</span>
        <span class="s3">// Pings were originally used to keep track of active routes in on-demand-entries with webpack.</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s0">) {</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s3">//TURBOPACK unreachable</span>
        <span class="s0">;</span>
        <span class="s3">// Taken from on-demand-entries-client.js</span>
        <span class="s1">const </span><span class="s0">interval = undefined;</span>
    <span class="s0">}, [</span>
        <span class="s0">tree,</span>
        <span class="s0">sendMessage</span>
    <span class="s0">]);</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=use-websocket.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/dev/report-hmr-latency.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s3">/**</span>
 <span class="s3">* Logs information about a completed HMR to the console, the server (via a</span>
 <span class="s3">* `client-hmr-latency` event), and to `self.__NEXT_HMR_LATENCY_CB` (a debugging</span>
 <span class="s3">* hook).</span>
 <span class="s3">*</span>
 <span class="s3">* </span><span class="s5">@param </span><span class="s3">hasUpdate Set this to `false` to avoid reporting the HMR event via a</span>
 <span class="s3">*   `client-hmr-latency` event or to `self.__NEXT_HMR_LATENCY_CB`. Used by</span>
 <span class="s3">*   turbopack when we must report a message to the browser console (because we</span>
 <span class="s3">*   already logged a &quot;rebuilding&quot; message), but it's not a real HMR, so we</span>
 <span class="s3">*   don't want to impact our telemetry.</span>
 <span class="s3">*/ </span><span class="s2">&quot;default&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">reportHmrLatency;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">reportHmrLatency(sendMessage, updatedModules, startMsSinceEpoch, endMsSinceEpoch, hasUpdate) {</span>
    <span class="s1">if </span><span class="s0">(hasUpdate === </span><span class="s1">void </span><span class="s4">0</span><span class="s0">) hasUpdate = </span><span class="s1">true</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">latencyMs = endMsSinceEpoch - startMsSinceEpoch;</span>
    <span class="s0">console.log(</span><span class="s2">&quot;[Fast Refresh] done in &quot; </span><span class="s0">+ latencyMs + </span><span class="s2">&quot;ms&quot;</span><span class="s0">);</span>
    <span class="s1">if </span><span class="s0">(!hasUpdate) {</span>
        <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">sendMessage(JSON.stringify({</span>
        <span class="s0">event: </span><span class="s2">'client-hmr-latency'</span><span class="s0">,</span>
        <span class="s0">id: window.__nextDevClientId,</span>
        <span class="s0">startTime: startMsSinceEpoch,</span>
        <span class="s0">endTime: endMsSinceEpoch,</span>
        <span class="s0">page: window.location.pathname,</span>
        <span class="s0">updatedModules,</span>
        <span class="s3">// Whether the page (tab) was hidden at the time the event occurred.</span>
        <span class="s3">// This can impact the accuracy of the event's timing.</span>
        <span class="s0">isPageHidden: document.visibilityState === </span><span class="s2">'hidden'</span>
    <span class="s0">}));</span>
    <span class="s1">if </span><span class="s0">(self.__NEXT_HMR_LATENCY_CB) {</span>
        <span class="s0">self.__NEXT_HMR_LATENCY_CB(latencyMs);</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=report-hmr-latency.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/dev/hot-reloader/turbopack-hot-reloader-common.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;TurbopackHmr&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">TurbopackHmr;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_class_private_field_loose_base = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/@swc/helpers/cjs/_class_private_field_loose_base.cjs [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_class_private_field_loose_key = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/@swc/helpers/cjs/_class_private_field_loose_key.cjs [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s3">// How long to wait before reporting the HMR start, used to suppress irrelevant</span>
<span class="s3">// `BUILDING` events. Does not impact reported latency.</span>
<span class="s1">const </span><span class="s0">TURBOPACK_HMR_START_DELAY_MS = </span><span class="s4">100</span><span class="s0">;</span>
<span class="s1">var </span><span class="s0">_updatedModules = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">_class_private_field_loose_key._(</span><span class="s2">&quot;_updatedModules&quot;</span><span class="s0">), _startMsSinceEpoch = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">_class_private_field_loose_key._(</span><span class="s2">&quot;_startMsSinceEpoch&quot;</span><span class="s0">), _lastUpdateMsSinceEpoch = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">_class_private_field_loose_key._(</span><span class="s2">&quot;_lastUpdateMsSinceEpoch&quot;</span><span class="s0">), _deferredReportHmrStartId = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">_class_private_field_loose_key._(</span><span class="s2">&quot;_deferredReportHmrStartId&quot;</span><span class="s0">), _reportedHmrStart = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">_class_private_field_loose_key._(</span><span class="s2">&quot;_reportedHmrStart&quot;</span><span class="s0">), </span><span class="s3">// as it reports *any* compilation, including fully no-op/cached compilations</span>
<span class="s3">// and those unrelated to HMR. Fixing this would require significant</span>
<span class="s3">// architectural changes.</span>
<span class="s3">//</span>
<span class="s3">// Work around this by deferring any &quot;rebuilding&quot; message by 100ms. If we get</span>
<span class="s3">// a BUILT event within that threshold and nothing has changed, just suppress</span>
<span class="s3">// the message entirely.</span>
<span class="s0">_runDeferredReportHmrStart = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">_class_private_field_loose_key._(</span><span class="s2">&quot;_runDeferredReportHmrStart&quot;</span><span class="s0">), _cancelDeferredReportHmrStart = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">_class_private_field_loose_key._(</span><span class="s2">&quot;_cancelDeferredReportHmrStart&quot;</span><span class="s0">), </span><span class="s3">/** Helper for other `onEvent` methods. */ </span><span class="s0">_onUpdate = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">_class_private_field_loose_key._(</span><span class="s2">&quot;_onUpdate&quot;</span><span class="s0">);</span>
<span class="s1">class </span><span class="s0">TurbopackHmr {</span>
    <span class="s0">onBuilding() {</span>
        <span class="s0">_class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _lastUpdateMsSinceEpoch)[_lastUpdateMsSinceEpoch] = undefined;</span>
        <span class="s0">_class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _cancelDeferredReportHmrStart)[_cancelDeferredReportHmrStart]();</span>
        <span class="s0">_class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _startMsSinceEpoch)[_startMsSinceEpoch] = Date.now();</span>
        <span class="s3">// report the HMR start after a short delay</span>
        <span class="s0">_class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _deferredReportHmrStartId)[_deferredReportHmrStartId] = setTimeout(()=&gt;_class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _runDeferredReportHmrStart)[_runDeferredReportHmrStart](), self.__NEXT_HMR_TURBOPACK_REPORT_NOISY_NOOP_EVENTS ? </span><span class="s4">0 </span><span class="s0">: TURBOPACK_HMR_START_DELAY_MS);</span>
    <span class="s0">}</span>
    <span class="s0">onTurbopackMessage(msg) {</span>
        <span class="s0">_class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _onUpdate)[_onUpdate]();</span>
        <span class="s1">const </span><span class="s0">updatedModules = extractModulesFromTurbopackMessage(msg.data);</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">module1 of updatedModules){</span>
            <span class="s0">_class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _updatedModules)[_updatedModules].add(module1);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">onServerComponentChanges() {</span>
        <span class="s0">_class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _onUpdate)[_onUpdate]();</span>
    <span class="s0">}</span>
    <span class="s0">onReloadPage() {</span>
        <span class="s0">_class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _onUpdate)[_onUpdate]();</span>
    <span class="s0">}</span>
    <span class="s0">onPageAddRemove() {</span>
        <span class="s0">_class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _onUpdate)[_onUpdate]();</span>
    <span class="s0">}</span>
    <span class="s3">/**</span>
   <span class="s3">* </span><span class="s5">@returns </span><span class="s3">`null` if the caller should ignore the update entirely. Returns an</span>
   <span class="s3">*   object with `hasUpdates: false` if the caller should report the end of</span>
   <span class="s3">*   the HMR in the browser console, but the HMR was a no-op.</span>
   <span class="s3">*/ </span><span class="s0">onBuilt() {</span>
        <span class="s3">// Check that we got *any* `TurbopackMessageAction`, even if</span>
        <span class="s3">// `updatedModules` is empty (not everything gets recorded there).</span>
        <span class="s3">//</span>
        <span class="s3">// There's also a case where `onBuilt` gets called before `onBuilding`,</span>
        <span class="s3">// which can happen during initial page load. Ignore that too!</span>
        <span class="s1">const </span><span class="s0">hasUpdates = _class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _lastUpdateMsSinceEpoch)[_lastUpdateMsSinceEpoch] != </span><span class="s1">null </span><span class="s0">&amp;&amp; _class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _startMsSinceEpoch)[_startMsSinceEpoch] != </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(!hasUpdates &amp;&amp; !_class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _reportedHmrStart)[_reportedHmrStart]) {</span>
            <span class="s3">// suppress the update entirely</span>
            <span class="s0">_class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _cancelDeferredReportHmrStart)[_cancelDeferredReportHmrStart]();</span>
            <span class="s1">return null</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">_class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _runDeferredReportHmrStart)[_runDeferredReportHmrStart]();</span>
        <span class="s1">var </span><span class="s0">_class_private_field_loose_base__lastUpdateMsSinceEpoch;</span>
        <span class="s1">const </span><span class="s0">result = {</span>
            <span class="s0">hasUpdates,</span>
            <span class="s0">updatedModules: _class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _updatedModules)[_updatedModules],</span>
            <span class="s0">startMsSinceEpoch: _class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _startMsSinceEpoch)[_startMsSinceEpoch],</span>
            <span class="s0">endMsSinceEpoch: (_class_private_field_loose_base__lastUpdateMsSinceEpoch = _class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _lastUpdateMsSinceEpoch)[_lastUpdateMsSinceEpoch]) != </span><span class="s1">null </span><span class="s0">? _class_private_field_loose_base__lastUpdateMsSinceEpoch : Date.now()</span>
        <span class="s0">};</span>
        <span class="s0">_class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _updatedModules)[_updatedModules] = </span><span class="s1">new </span><span class="s0">Set();</span>
        <span class="s0">_class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _reportedHmrStart)[_reportedHmrStart] = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s1">return </span><span class="s0">result;</span>
    <span class="s0">}</span>
    <span class="s0">constructor(){</span>
        <span class="s0">Object.defineProperty(</span><span class="s1">this</span><span class="s0">, _runDeferredReportHmrStart, {</span>
            <span class="s0">value: runDeferredReportHmrStart</span>
        <span class="s0">});</span>
        <span class="s0">Object.defineProperty(</span><span class="s1">this</span><span class="s0">, _cancelDeferredReportHmrStart, {</span>
            <span class="s0">value: cancelDeferredReportHmrStart</span>
        <span class="s0">});</span>
        <span class="s0">Object.defineProperty(</span><span class="s1">this</span><span class="s0">, _onUpdate, {</span>
            <span class="s0">value: onUpdate</span>
        <span class="s0">});</span>
        <span class="s0">Object.defineProperty(</span><span class="s1">this</span><span class="s0">, _updatedModules, {</span>
            <span class="s0">writable: </span><span class="s1">true</span><span class="s0">,</span>
            <span class="s0">value: </span><span class="s1">void </span><span class="s4">0</span>
        <span class="s0">});</span>
        <span class="s0">Object.defineProperty(</span><span class="s1">this</span><span class="s0">, _startMsSinceEpoch, {</span>
            <span class="s0">writable: </span><span class="s1">true</span><span class="s0">,</span>
            <span class="s0">value: </span><span class="s1">void </span><span class="s4">0</span>
        <span class="s0">});</span>
        <span class="s0">Object.defineProperty(</span><span class="s1">this</span><span class="s0">, _lastUpdateMsSinceEpoch, {</span>
            <span class="s0">writable: </span><span class="s1">true</span><span class="s0">,</span>
            <span class="s0">value: </span><span class="s1">void </span><span class="s4">0</span>
        <span class="s0">});</span>
        <span class="s0">Object.defineProperty(</span><span class="s1">this</span><span class="s0">, _deferredReportHmrStartId, {</span>
            <span class="s0">writable: </span><span class="s1">true</span><span class="s0">,</span>
            <span class="s0">value: </span><span class="s1">void </span><span class="s4">0</span>
        <span class="s0">});</span>
        <span class="s0">Object.defineProperty(</span><span class="s1">this</span><span class="s0">, _reportedHmrStart, {</span>
            <span class="s0">writable: </span><span class="s1">true</span><span class="s0">,</span>
            <span class="s0">value: </span><span class="s1">void </span><span class="s4">0</span>
        <span class="s0">});</span>
        <span class="s0">_class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _updatedModules)[_updatedModules] = </span><span class="s1">new </span><span class="s0">Set();</span>
        <span class="s0">_class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _reportedHmrStart)[_reportedHmrStart] = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">runDeferredReportHmrStart() {</span>
    <span class="s1">if </span><span class="s0">(_class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _deferredReportHmrStartId)[_deferredReportHmrStartId] != </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">console.log(</span><span class="s2">'[Fast Refresh] rebuilding'</span><span class="s0">);</span>
        <span class="s0">_class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _reportedHmrStart)[_reportedHmrStart] = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s0">_class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _cancelDeferredReportHmrStart)[_cancelDeferredReportHmrStart]();</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">cancelDeferredReportHmrStart() {</span>
    <span class="s0">clearTimeout(_class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _deferredReportHmrStartId)[_deferredReportHmrStartId]);</span>
    <span class="s0">_class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _deferredReportHmrStartId)[_deferredReportHmrStartId] = undefined;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">onUpdate() {</span>
    <span class="s0">_class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _runDeferredReportHmrStart)[_runDeferredReportHmrStart]();</span>
    <span class="s0">_class_private_field_loose_base._(</span><span class="s1">this</span><span class="s0">, _lastUpdateMsSinceEpoch)[_lastUpdateMsSinceEpoch] = Date.now();</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">extractModulesFromTurbopackMessage(data) {</span>
    <span class="s1">const </span><span class="s0">updatedModules = </span><span class="s1">new </span><span class="s0">Set();</span>
    <span class="s1">const </span><span class="s0">updates = Array.isArray(data) ? data : [</span>
        <span class="s0">data</span>
    <span class="s0">];</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">update of updates){</span>
        <span class="s3">// TODO this won't capture changes to CSS since they don't result in a &quot;merged&quot; update</span>
        <span class="s1">if </span><span class="s0">(update.type !== </span><span class="s2">'partial' </span><span class="s0">|| update.instruction.type !== </span><span class="s2">'ChunkListUpdate' </span><span class="s0">|| update.instruction.merged === undefined) {</span>
            <span class="s1">continue</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">mergedUpdate of update.instruction.merged){</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">name of Object.keys(mergedUpdate.entries)){</span>
                <span class="s1">const </span><span class="s0">res = </span><span class="s7">/(.*)\s+\[.*/</span><span class="s0">.exec(name);</span>
                <span class="s1">if </span><span class="s0">(res === </span><span class="s1">null</span><span class="s0">) {</span>
                    <span class="s0">console.error(</span><span class="s2">'[Turbopack HMR] Expected module to match pattern: ' </span><span class="s0">+ name);</span>
                    <span class="s1">continue</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s0">updatedModules.add(res[</span><span class="s4">1</span><span class="s0">]);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">updatedModules;</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=turbopack-hot-reloader-common.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/dev/hot-reloader/app/hot-reloader-app.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s3">/// &lt;reference types=&quot;webpack/module.d.ts&quot; /&gt;</span>
<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s1">default</span><span class="s0">: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">waitForWebpackRuntimeHotUpdate: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s1">default</span><span class="s0">: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">HotReload;</span>
    <span class="s0">},</span>
    <span class="s0">waitForWebpackRuntimeHotUpdate: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">waitForWebpackRuntimeHotUpdate;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_interop_require_default = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_jsxruntime = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_react = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_stripansi = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">_interop_require_default._(__turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/strip-ansi/index.js [app-client] (ecmascript)&quot;</span><span class="s0">));</span>
<span class="s1">const </span><span class="s0">_formatwebpackmessages = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">_interop_require_default._(__turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/format-webpack-messages.js [app-client] (ecmascript)&quot;</span><span class="s0">));</span>
<span class="s1">const </span><span class="s0">_navigation = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/navigation.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_shared = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/dev/hot-reloader/shared.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_nextdevtools = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/next-devtools/index.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_replayssronlyerrors = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/next-devtools/userspace/app/errors/replay-ssr-only-errors.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_appdevoverlayerrorboundary = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/next-devtools/userspace/app/app-dev-overlay-error-boundary.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_useerrorhandler = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/next-devtools/userspace/app/errors/use-error-handler.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_runtimeerrorhandler = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/dev/runtime-error-handler.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_usewebsocket = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/dev/hot-reloader/app/use-websocket.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_hotreloadertypes = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/server/dev/hot-reloader-types.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_navigationuntracked = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/navigation-untracked.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_reporthmrlatency = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">_interop_require_default._(__turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/dev/report-hmr-latency.js [app-client] (ecmascript)&quot;</span><span class="s0">));</span>
<span class="s1">const </span><span class="s0">_turbopackhotreloadercommon = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/dev/hot-reloader/turbopack-hot-reloader-common.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_approuterheaders = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/app-router-headers.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_useforwardconsolelog = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/next-devtools/userspace/app/errors/use-forward-console-log.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">let </span><span class="s0">mostRecentCompilationHash = </span><span class="s1">null</span><span class="s0">;</span>
<span class="s1">let </span><span class="s0">__nextDevClientId = Math.round(Math.random() * </span><span class="s4">100 </span><span class="s0">+ Date.now());</span>
<span class="s1">let </span><span class="s0">reloading = </span><span class="s1">false</span><span class="s0">;</span>
<span class="s1">let </span><span class="s0">webpackStartMsSinceEpoch = </span><span class="s1">null</span><span class="s0">;</span>
<span class="s1">const </span><span class="s0">turbopackHmr = (</span><span class="s2">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s0">) ? </span><span class="s1">new </span><span class="s0">_turbopackhotreloadercommon.TurbopackHmr() : </span><span class="s2">&quot;TURBOPACK unreachable&quot;</span><span class="s0">;</span>
<span class="s1">let </span><span class="s0">pendingHotUpdateWebpack = Promise.resolve();</span>
<span class="s1">let </span><span class="s0">resolvePendingHotUpdateWebpack = ()=&gt;{};</span>
<span class="s1">function </span><span class="s0">setPendingHotUpdateWebpack() {</span>
    <span class="s0">pendingHotUpdateWebpack = </span><span class="s1">new </span><span class="s0">Promise((resolve)=&gt;{</span>
        <span class="s0">resolvePendingHotUpdateWebpack = ()=&gt;{</span>
            <span class="s0">resolve();</span>
        <span class="s0">};</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">waitForWebpackRuntimeHotUpdate() {</span>
    <span class="s1">return </span><span class="s0">pendingHotUpdateWebpack;</span>
<span class="s0">}</span>
<span class="s3">// There is a newer version of the code available.</span>
<span class="s1">function </span><span class="s0">handleAvailableHash(hash) {</span>
    <span class="s3">// Update last known compilation hash.</span>
    <span class="s0">mostRecentCompilationHash = hash;</span>
<span class="s0">}</span>
<span class="s3">/**</span>
 <span class="s3">* Is there a newer version of this code available?</span>
 <span class="s3">* For webpack: Check if the hash changed compared to __webpack_hash__</span>
 <span class="s3">* For Turbopack: Always true because it doesn't have __webpack_hash__</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">isUpdateAvailable() {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s0">) {</span>
        <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s3">//TURBOPACK unreachable</span>
    <span class="s0">;</span>
<span class="s0">}</span>
<span class="s3">// Webpack disallows updates in other states.</span>
<span class="s1">function </span><span class="s0">canApplyUpdates() {</span>
    <span class="s1">return </span><span class="s0">module.hot.status() === </span><span class="s2">'idle'</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">afterApplyUpdates(fn) {</span>
    <span class="s1">if </span><span class="s0">(canApplyUpdates()) {</span>
        <span class="s0">fn();</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">function </span><span class="s0">handler(status) {</span>
            <span class="s1">if </span><span class="s0">(status === </span><span class="s2">'idle'</span><span class="s0">) {</span>
                <span class="s0">module.hot.removeStatusHandler(handler);</span>
                <span class="s0">fn();</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">module.hot.addStatusHandler(handler);</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">performFullReload(err, sendMessage) {</span>
    <span class="s1">const </span><span class="s0">stackTrace = err &amp;&amp; (err.stack &amp;&amp; err.stack.split(</span><span class="s2">'</span><span class="s6">\n</span><span class="s2">'</span><span class="s0">).slice(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">5</span><span class="s0">).join(</span><span class="s2">'</span><span class="s6">\n</span><span class="s2">'</span><span class="s0">) || err.message || err + </span><span class="s2">''</span><span class="s0">);</span>
    <span class="s0">sendMessage(JSON.stringify({</span>
        <span class="s0">event: </span><span class="s2">'client-full-reload'</span><span class="s0">,</span>
        <span class="s0">stackTrace,</span>
        <span class="s0">hadRuntimeError: !!_runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError,</span>
        <span class="s0">dependencyChain: err ? err.dependencyChain : undefined</span>
    <span class="s0">}));</span>
    <span class="s1">if </span><span class="s0">(reloading) </span><span class="s1">return</span><span class="s0">;</span>
    <span class="s0">reloading = </span><span class="s1">true</span><span class="s0">;</span>
    <span class="s0">window.location.reload();</span>
<span class="s0">}</span>
<span class="s3">// Attempt to update code on the fly, fall back to a hard reload.</span>
<span class="s1">function </span><span class="s0">tryApplyUpdatesWebpack(sendMessage) {</span>
    <span class="s1">if </span><span class="s0">(!isUpdateAvailable() || !canApplyUpdates()) {</span>
        <span class="s0">resolvePendingHotUpdateWebpack();</span>
        <span class="s0">_nextdevtools.dispatcher.onBuildOk();</span>
        <span class="s0">(</span><span class="s4">0</span><span class="s0">, _reporthmrlatency.default)(sendMessage, [], webpackStartMsSinceEpoch, Date.now());</span>
        <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">handleApplyUpdates(err, updatedModules) {</span>
        <span class="s1">if </span><span class="s0">(err || _runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError || updatedModules == </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s1">if </span><span class="s0">(err) {</span>
                <span class="s0">console.warn(_shared.REACT_REFRESH_FULL_RELOAD);</span>
            <span class="s0">} </span><span class="s1">else if </span><span class="s0">(_runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError) {</span>
                <span class="s0">console.warn(_shared.REACT_REFRESH_FULL_RELOAD_FROM_ERROR);</span>
            <span class="s0">}</span>
            <span class="s0">performFullReload(err, sendMessage);</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">_nextdevtools.dispatcher.onBuildOk();</span>
        <span class="s1">if </span><span class="s0">(isUpdateAvailable()) {</span>
            <span class="s3">// While we were updating, there was a new update! Do it again.</span>
            <span class="s0">tryApplyUpdatesWebpack(sendMessage);</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">_nextdevtools.dispatcher.onRefresh();</span>
        <span class="s0">resolvePendingHotUpdateWebpack();</span>
        <span class="s0">(</span><span class="s4">0</span><span class="s0">, _reporthmrlatency.default)(sendMessage, updatedModules, webpackStartMsSinceEpoch, Date.now());</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) </span><span class="s3">//TURBOPACK unreachable</span>
        <span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s3">// https://webpack.js.org/api/hot-module-replacement/#check</span>
    <span class="s0">module.hot.check(</span><span class="s3">/* autoApply */ </span><span class="s1">false</span><span class="s0">).then((updatedModules)=&gt;{</span>
        <span class="s1">if </span><span class="s0">(updatedModules == </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s1">return null</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s3">// We should always handle an update, even if updatedModules is empty (but</span>
        <span class="s3">// non-null) for any reason. That's what webpack would normally do:</span>
        <span class="s3">// https://github.com/webpack/webpack/blob/3aa6b6bc3a64/lib/hmr/HotModuleReplacement.runtime.js#L296-L298</span>
        <span class="s0">_nextdevtools.dispatcher.onBeforeRefresh();</span>
        <span class="s3">// https://webpack.js.org/api/hot-module-replacement/#apply</span>
        <span class="s1">return </span><span class="s0">module.hot.apply();</span>
    <span class="s0">}).then((updatedModules)=&gt;{</span>
        <span class="s0">handleApplyUpdates(</span><span class="s1">null</span><span class="s0">, updatedModules);</span>
    <span class="s0">}, (err)=&gt;{</span>
        <span class="s0">handleApplyUpdates(err, </span><span class="s1">null</span><span class="s0">);</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s3">/** Handles messages from the server for the App Router. */ </span><span class="s1">function </span><span class="s0">processMessage(obj, sendMessage, processTurbopackMessage, router, appIsrManifestRef, pathnameRef) {</span>
    <span class="s1">if </span><span class="s0">(!(</span><span class="s2">'action' </span><span class="s1">in </span><span class="s0">obj)) {</span>
        <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">handleErrors(errors) {</span>
        <span class="s3">// &quot;Massage&quot; webpack messages.</span>
        <span class="s1">const </span><span class="s0">formatted = (</span><span class="s4">0</span><span class="s0">, _formatwebpackmessages.default)({</span>
            <span class="s0">errors: errors,</span>
            <span class="s0">warnings: []</span>
        <span class="s0">});</span>
        <span class="s3">// Only show the first error.</span>
        <span class="s0">_nextdevtools.dispatcher.onBuildError(formatted.errors[</span><span class="s4">0</span><span class="s0">]);</span>
        <span class="s3">// Also log them to the console.</span>
        <span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; formatted.errors.length; i++){</span>
            <span class="s0">console.error((</span><span class="s4">0</span><span class="s0">, _stripansi.default)(formatted.errors[i]));</span>
        <span class="s0">}</span>
        <span class="s3">// Do not attempt to reload now.</span>
        <span class="s3">// We will reload on next success instead.</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) </span><span class="s3">//TURBOPACK unreachable</span>
        <span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">function </span><span class="s0">handleHotUpdate() {</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s0">) {</span>
            <span class="s1">const </span><span class="s0">hmrUpdate = turbopackHmr.onBuilt();</span>
            <span class="s1">if </span><span class="s0">(hmrUpdate != </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s0">(</span><span class="s4">0</span><span class="s0">, _reporthmrlatency.default)(sendMessage, [</span>
                    <span class="s0">...hmrUpdate.updatedModules</span>
                <span class="s0">], hmrUpdate.startMsSinceEpoch, hmrUpdate.endMsSinceEpoch, hmrUpdate.hasUpdates);</span>
            <span class="s0">}</span>
            <span class="s0">_nextdevtools.dispatcher.onBuildOk();</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s3">//TURBOPACK unreachable</span>
        <span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">switch</span><span class="s0">(obj.action){</span>
        <span class="s1">case </span><span class="s0">_hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.ISR_MANIFEST:</span>
            <span class="s0">{</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s0">) {</span>
                    <span class="s1">if </span><span class="s0">(appIsrManifestRef) {</span>
                        <span class="s0">appIsrManifestRef.current = obj.data;</span>
                        <span class="s3">// handle initial status on receiving manifest</span>
                        <span class="s3">// navigation is handled in useEffect for pathname changes</span>
                        <span class="s3">// as we'll receive the updated manifest before usePathname</span>
                        <span class="s3">// triggers for new value</span>
                        <span class="s1">if </span><span class="s0">(pathnameRef.current </span><span class="s1">in </span><span class="s0">obj.data) {</span>
                            <span class="s0">_nextdevtools.dispatcher.onStaticIndicator(</span><span class="s1">true</span><span class="s0">);</span>
                        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                            <span class="s0">_nextdevtools.dispatcher.onStaticIndicator(</span><span class="s1">false</span><span class="s0">);</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s1">case </span><span class="s0">_hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.BUILDING:</span>
            <span class="s0">{</span>
                <span class="s0">_nextdevtools.dispatcher.buildingIndicatorShow();</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s0">) {</span>
                    <span class="s0">turbopackHmr.onBuilding();</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s3">//TURBOPACK unreachable</span>
                <span class="s0">;</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s1">case </span><span class="s0">_hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.BUILT:</span>
        <span class="s1">case </span><span class="s0">_hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.SYNC:</span>
            <span class="s0">{</span>
                <span class="s0">_nextdevtools.dispatcher.buildingIndicatorHide();</span>
                <span class="s1">if </span><span class="s0">(obj.hash) {</span>
                    <span class="s0">handleAvailableHash(obj.hash);</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">{ errors, warnings } = obj;</span>
                <span class="s3">// Is undefined when it's a 'built' event</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s2">'versionInfo' </span><span class="s1">in </span><span class="s0">obj) _nextdevtools.dispatcher.onVersionInfo(obj.versionInfo);</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s2">'debug' </span><span class="s1">in </span><span class="s0">obj &amp;&amp; obj.debug) _nextdevtools.dispatcher.onDebugInfo(obj.debug);</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s2">'devIndicator' </span><span class="s1">in </span><span class="s0">obj) _nextdevtools.dispatcher.onDevIndicator(obj.devIndicator);</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s2">'devToolsConfig' </span><span class="s1">in </span><span class="s0">obj) _nextdevtools.dispatcher.onDevToolsConfig(obj.devToolsConfig);</span>
                <span class="s1">const </span><span class="s0">hasErrors = Boolean(errors &amp;&amp; errors.length);</span>
                <span class="s3">// Compilation with errors (e.g. syntax error or missing modules).</span>
                <span class="s1">if </span><span class="s0">(hasErrors) {</span>
                    <span class="s0">sendMessage(JSON.stringify({</span>
                        <span class="s0">event: </span><span class="s2">'client-error'</span><span class="s0">,</span>
                        <span class="s0">errorCount: errors.length,</span>
                        <span class="s0">clientId: __nextDevClientId</span>
                    <span class="s0">}));</span>
                    <span class="s0">handleErrors(errors);</span>
                    <span class="s1">return</span><span class="s0">;</span>
                <span class="s0">}</span>
                <span class="s1">const </span><span class="s0">hasWarnings = Boolean(warnings &amp;&amp; warnings.length);</span>
                <span class="s1">if </span><span class="s0">(hasWarnings) {</span>
                    <span class="s0">sendMessage(JSON.stringify({</span>
                        <span class="s0">event: </span><span class="s2">'client-warning'</span><span class="s0">,</span>
                        <span class="s0">warningCount: warnings.length,</span>
                        <span class="s0">clientId: __nextDevClientId</span>
                    <span class="s0">}));</span>
                    <span class="s3">// Print warnings to the console.</span>
                    <span class="s1">const </span><span class="s0">formattedMessages = (</span><span class="s4">0</span><span class="s0">, _formatwebpackmessages.default)({</span>
                        <span class="s0">warnings: warnings,</span>
                        <span class="s0">errors: []</span>
                    <span class="s0">});</span>
                    <span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; formattedMessages.warnings.length; i++){</span>
                        <span class="s1">if </span><span class="s0">(i === </span><span class="s4">5</span><span class="s0">) {</span>
                            <span class="s0">console.warn(</span><span class="s2">'There were more warnings in other files.</span><span class="s6">\n</span><span class="s2">' </span><span class="s0">+ </span><span class="s2">'You can find a complete log in the terminal.'</span><span class="s0">);</span>
                            <span class="s1">break</span><span class="s0">;</span>
                        <span class="s0">}</span>
                        <span class="s0">console.warn((</span><span class="s4">0</span><span class="s0">, _stripansi.default)(formattedMessages.warnings[i]));</span>
                    <span class="s0">}</span>
                <span class="s3">// No early return here as we need to apply modules in the same way between warnings only and compiles without warnings</span>
                <span class="s0">}</span>
                <span class="s0">sendMessage(JSON.stringify({</span>
                    <span class="s0">event: </span><span class="s2">'client-success'</span><span class="s0">,</span>
                    <span class="s0">clientId: __nextDevClientId</span>
                <span class="s0">}));</span>
                <span class="s1">if </span><span class="s0">(obj.action === _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.BUILT) {</span>
                    <span class="s0">handleHotUpdate();</span>
                <span class="s0">}</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s1">case </span><span class="s0">_hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_CONNECTED:</span>
            <span class="s0">{</span>
                <span class="s0">processTurbopackMessage({</span>
                    <span class="s0">type: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_CONNECTED,</span>
                    <span class="s0">data: {</span>
                        <span class="s0">sessionId: obj.data.sessionId</span>
                    <span class="s0">}</span>
                <span class="s0">});</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s1">case </span><span class="s0">_hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_MESSAGE:</span>
            <span class="s0">{</span>
                <span class="s0">turbopackHmr.onTurbopackMessage(obj);</span>
                <span class="s0">_nextdevtools.dispatcher.onBeforeRefresh();</span>
                <span class="s0">processTurbopackMessage({</span>
                    <span class="s0">type: _hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.TURBOPACK_MESSAGE,</span>
                    <span class="s0">data: obj.data</span>
                <span class="s0">});</span>
                <span class="s1">if </span><span class="s0">(_runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError) {</span>
                    <span class="s0">console.warn(_shared.REACT_REFRESH_FULL_RELOAD_FROM_ERROR);</span>
                    <span class="s0">performFullReload(</span><span class="s1">null</span><span class="s0">, sendMessage);</span>
                <span class="s0">}</span>
                <span class="s0">_nextdevtools.dispatcher.onRefresh();</span>
                <span class="s1">break</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s3">// TODO-APP: make server component change more granular</span>
        <span class="s1">case </span><span class="s0">_hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.SERVER_COMPONENT_CHANGES:</span>
            <span class="s0">{</span>
                <span class="s0">turbopackHmr == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: turbopackHmr.onServerComponentChanges();</span>
                <span class="s0">sendMessage(JSON.stringify({</span>
                    <span class="s0">event: </span><span class="s2">'server-component-reload-page'</span><span class="s0">,</span>
                    <span class="s0">clientId: __nextDevClientId,</span>
                    <span class="s0">hash: obj.hash</span>
                <span class="s0">}));</span>
                <span class="s3">// Store the latest hash in a session cookie so that it's sent back to the</span>
                <span class="s3">// server with any subsequent requests.</span>
                <span class="s0">document.cookie = _approuterheaders.NEXT_HMR_REFRESH_HASH_COOKIE + </span><span class="s2">&quot;=&quot; </span><span class="s0">+ obj.hash + </span><span class="s2">&quot;;path=/&quot;</span><span class="s0">;</span>
                <span class="s1">if </span><span class="s0">(_runtimeerrorhandler.RuntimeErrorHandler.hadRuntimeError || document.documentElement.id === </span><span class="s2">'__next_error__'</span><span class="s0">) {</span>
                    <span class="s1">if </span><span class="s0">(reloading) </span><span class="s1">return</span><span class="s0">;</span>
                    <span class="s0">reloading = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s1">return </span><span class="s0">window.location.reload();</span>
                <span class="s0">}</span>
                <span class="s0">(</span><span class="s4">0</span><span class="s0">, _react.startTransition)(()=&gt;{</span>
                    <span class="s0">router.hmrRefresh();</span>
                    <span class="s0">_nextdevtools.dispatcher.onRefresh();</span>
                <span class="s0">});</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) </span><span class="s3">//TURBOPACK unreachable</span>
                <span class="s0">;</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s1">case </span><span class="s0">_hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.RELOAD_PAGE:</span>
            <span class="s0">{</span>
                <span class="s0">turbopackHmr == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: turbopackHmr.onReloadPage();</span>
                <span class="s0">sendMessage(JSON.stringify({</span>
                    <span class="s0">event: </span><span class="s2">'client-reload-page'</span><span class="s0">,</span>
                    <span class="s0">clientId: __nextDevClientId</span>
                <span class="s0">}));</span>
                <span class="s1">if </span><span class="s0">(reloading) </span><span class="s1">return</span><span class="s0">;</span>
                <span class="s0">reloading = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s1">return </span><span class="s0">window.location.reload();</span>
            <span class="s0">}</span>
        <span class="s1">case </span><span class="s0">_hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.ADDED_PAGE:</span>
        <span class="s1">case </span><span class="s0">_hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.REMOVED_PAGE:</span>
            <span class="s0">{</span>
                <span class="s0">turbopackHmr == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: turbopackHmr.onPageAddRemove();</span>
                <span class="s3">// TODO-APP: potentially only refresh if the currently viewed page was added/removed.</span>
                <span class="s1">return </span><span class="s0">router.hmrRefresh();</span>
            <span class="s0">}</span>
        <span class="s1">case </span><span class="s0">_hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.SERVER_ERROR:</span>
            <span class="s0">{</span>
                <span class="s1">const </span><span class="s0">{ errorJSON } = obj;</span>
                <span class="s1">if </span><span class="s0">(errorJSON) {</span>
                    <span class="s1">const </span><span class="s0">{ message, stack } = JSON.parse(errorJSON);</span>
                    <span class="s1">const </span><span class="s0">error = Object.defineProperty(</span><span class="s1">new </span><span class="s0">Error(message), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
                        <span class="s0">value: </span><span class="s2">&quot;E394&quot;</span><span class="s0">,</span>
                        <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
                        <span class="s0">configurable: </span><span class="s1">true</span>
                    <span class="s0">});</span>
                    <span class="s0">error.stack = stack;</span>
                    <span class="s0">handleErrors([</span>
                        <span class="s0">error</span>
                    <span class="s0">]);</span>
                <span class="s0">}</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s1">case </span><span class="s0">_hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.DEV_PAGES_MANIFEST_UPDATE:</span>
            <span class="s0">{</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s1">case </span><span class="s0">_hotreloadertypes.HMR_ACTIONS_SENT_TO_BROWSER.DEVTOOLS_CONFIG:</span>
            <span class="s0">{</span>
                <span class="s0">_nextdevtools.dispatcher.onDevToolsConfig(obj.data);</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s1">default</span><span class="s0">:</span>
            <span class="s0">{</span>
                <span class="s0">obj;</span>
            <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">HotReload(param) {</span>
    <span class="s1">let </span><span class="s0">{ assetPrefix, children, globalError } = param;</span>
    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _useerrorhandler.useErrorHandler)(_nextdevtools.dispatcher.onUnhandledError, _nextdevtools.dispatcher.onUnhandledRejection);</span>
    <span class="s1">const </span><span class="s0">webSocketRef = (</span><span class="s4">0</span><span class="s0">, _usewebsocket.useWebsocket)(assetPrefix);</span>
    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _usewebsocket.useWebsocketPing)(webSocketRef);</span>
    <span class="s1">const </span><span class="s0">sendMessage = (</span><span class="s4">0</span><span class="s0">, _usewebsocket.useSendMessage)(webSocketRef);</span>
    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _useforwardconsolelog.useForwardConsoleLog)(webSocketRef);</span>
    <span class="s1">const </span><span class="s0">processTurbopackMessage = (</span><span class="s4">0</span><span class="s0">, _usewebsocket.useTurbopack)(sendMessage, (err)=&gt;performFullReload(err, sendMessage));</span>
    <span class="s1">const </span><span class="s0">router = (</span><span class="s4">0</span><span class="s0">, _navigation.useRouter)();</span>
    <span class="s3">// We don't want access of the pathname for the dev tools to trigger a dynamic</span>
    <span class="s3">// access (as the dev overlay will never be present in production).</span>
    <span class="s1">const </span><span class="s0">pathname = (</span><span class="s4">0</span><span class="s0">, _navigationuntracked.useUntrackedPathname)();</span>
    <span class="s1">const </span><span class="s0">appIsrManifestRef = (</span><span class="s4">0</span><span class="s0">, _react.useRef)({});</span>
    <span class="s1">const </span><span class="s0">pathnameRef = (</span><span class="s4">0</span><span class="s0">, _react.useRef)(pathname);</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s0">) {</span>
        <span class="s3">// this conditional is only for dead-code elimination which</span>
        <span class="s3">// isn't a runtime conditional only build-time so ignore hooks rule</span>
        <span class="s3">// eslint-disable-next-line react-hooks/rules-of-hooks</span>
        <span class="s0">(</span><span class="s4">0</span><span class="s0">, _react.useEffect)(()=&gt;{</span>
            <span class="s0">pathnameRef.current = pathname;</span>
            <span class="s1">const </span><span class="s0">appIsrManifest = appIsrManifestRef.current;</span>
            <span class="s1">if </span><span class="s0">(appIsrManifest) {</span>
                <span class="s1">if </span><span class="s0">(pathname &amp;&amp; pathname </span><span class="s1">in </span><span class="s0">appIsrManifest) {</span>
                    <span class="s1">try </span><span class="s0">{</span>
                        <span class="s0">_nextdevtools.dispatcher.onStaticIndicator(</span><span class="s1">true</span><span class="s0">);</span>
                    <span class="s0">} </span><span class="s1">catch </span><span class="s0">(reason) {</span>
                        <span class="s1">let </span><span class="s0">message = </span><span class="s2">''</span><span class="s0">;</span>
                        <span class="s1">if </span><span class="s0">(reason </span><span class="s1">instanceof </span><span class="s0">DOMException) {</span>
                            <span class="s1">var </span><span class="s0">_reason_stack;</span>
                            <span class="s3">// Most likely a SecurityError, because of an unavailable localStorage</span>
                            <span class="s0">message = (_reason_stack = reason.stack) != </span><span class="s1">null </span><span class="s0">? _reason_stack : reason.message;</span>
                        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(reason </span><span class="s1">instanceof </span><span class="s0">Error) {</span>
                            <span class="s1">var </span><span class="s0">_reason_stack1;</span>
                            <span class="s0">message = </span><span class="s2">'Error: ' </span><span class="s0">+ reason.message + </span><span class="s2">'</span><span class="s6">\n</span><span class="s2">' </span><span class="s0">+ ((_reason_stack1 = reason.stack) != </span><span class="s1">null </span><span class="s0">? _reason_stack1 : </span><span class="s2">''</span><span class="s0">);</span>
                        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                            <span class="s0">message = </span><span class="s2">'Unexpected Exception: ' </span><span class="s0">+ reason;</span>
                        <span class="s0">}</span>
                        <span class="s0">console.warn(</span><span class="s2">'[HMR] ' </span><span class="s0">+ message);</span>
                    <span class="s0">}</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">_nextdevtools.dispatcher.onStaticIndicator(</span><span class="s1">false</span><span class="s0">);</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}, [</span>
            <span class="s0">pathname</span>
        <span class="s0">]);</span>
    <span class="s0">}</span>
    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _react.useEffect)(()=&gt;{</span>
        <span class="s1">const </span><span class="s0">websocket = webSocketRef.current;</span>
        <span class="s1">if </span><span class="s0">(!websocket) </span><span class="s1">return</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">handler = (event)=&gt;{</span>
            <span class="s1">try </span><span class="s0">{</span>
                <span class="s1">const </span><span class="s0">obj = JSON.parse(event.data);</span>
                <span class="s0">processMessage(obj, sendMessage, processTurbopackMessage, router, appIsrManifestRef, pathnameRef);</span>
            <span class="s0">} </span><span class="s1">catch </span><span class="s0">(err) {</span>
                <span class="s0">(</span><span class="s4">0</span><span class="s0">, _shared.reportInvalidHmrMessage)(event, err);</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
        <span class="s0">websocket.addEventListener(</span><span class="s2">'message'</span><span class="s0">, handler);</span>
        <span class="s1">return </span><span class="s0">()=&gt;websocket.removeEventListener(</span><span class="s2">'message'</span><span class="s0">, handler);</span>
    <span class="s0">}, [</span>
        <span class="s0">sendMessage,</span>
        <span class="s0">router,</span>
        <span class="s0">webSocketRef,</span>
        <span class="s0">processTurbopackMessage,</span>
        <span class="s0">appIsrManifestRef</span>
    <span class="s0">]);</span>
    <span class="s1">return </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsxs)(_appdevoverlayerrorboundary.AppDevOverlayErrorBoundary, {</span>
        <span class="s0">globalError: globalError,</span>
        <span class="s0">children: [</span>
            <span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(_replayssronlyerrors.ReplaySsrOnlyErrors, {</span>
                <span class="s0">onBlockingError: _nextdevtools.dispatcher.openErrorOverlay</span>
            <span class="s0">}),</span>
            <span class="s0">children</span>
        <span class="s0">]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=hot-reloader-app.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/app-router.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">'use client'</span><span class="s0">;</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s0">createEmptyCacheNode: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">createPrefetchURL: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s1">default</span><span class="s0">: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">isExternalURL: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s0">createEmptyCacheNode: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">createEmptyCacheNode;</span>
    <span class="s0">},</span>
    <span class="s0">createPrefetchURL: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">createPrefetchURL;</span>
    <span class="s0">},</span>
    <span class="s1">default</span><span class="s0">: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">AppRouter;</span>
    <span class="s0">},</span>
    <span class="s0">isExternalURL: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">isExternalURL;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_interop_require_default = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_interop_require_wildcard = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_jsxruntime = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_react = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">_interop_require_wildcard._(__turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)&quot;</span><span class="s0">));</span>
<span class="s1">const </span><span class="s0">_approutercontextsharedruntime = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_routerreducertypes = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_createhreffromurl = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_hooksclientcontextsharedruntime = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_useactionqueue = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/use-action-queue.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_isbot = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/router/utils/is-bot.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_addbasepath = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/add-base-path.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_approuterannouncer = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/app-router-announcer.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_redirectboundary = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/redirect-boundary.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_findheadincache = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/reducers/find-head-in-cache.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_unresolvedthenable = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/unresolved-thenable.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_removebasepath = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/remove-base-path.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_hasbasepath = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/has-base-path.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_computechangedpath = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/compute-changed-path.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_navfailurehandler = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/nav-failure-handler.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_approuterinstance = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/app-router-instance.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_redirect = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/redirect.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_redirecterror = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/redirect-error.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_links = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/links.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_rooterrorboundary = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">_interop_require_default._(__turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/errors/root-error-boundary.js [app-client] (ecmascript)&quot;</span><span class="s0">));</span>
<span class="s1">const </span><span class="s0">_globalerror = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">_interop_require_default._(__turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/builtin/global-error.js [app-client] (ecmascript)&quot;</span><span class="s0">));</span>
<span class="s1">const </span><span class="s0">_boundarycomponents = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/lib/framework/boundary-components.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">globalMutable = {};</span>
<span class="s1">function </span><span class="s0">isExternalURL(url) {</span>
    <span class="s1">return </span><span class="s0">url.origin !== window.location.origin;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">createPrefetchURL(href) {</span>
    <span class="s3">// Don't prefetch for bots as they don't navigate.</span>
    <span class="s1">if </span><span class="s0">((</span><span class="s4">0</span><span class="s0">, _isbot.isBot)(window.navigator.userAgent)) {</span>
        <span class="s1">return null</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">let </span><span class="s0">url;</span>
    <span class="s1">try </span><span class="s0">{</span>
        <span class="s0">url = </span><span class="s1">new </span><span class="s0">URL((</span><span class="s4">0</span><span class="s0">, _addbasepath.addBasePath)(href), window.location.href);</span>
    <span class="s0">} </span><span class="s1">catch </span><span class="s0">(_) {</span>
        <span class="s3">// TODO: Does this need to throw or can we just console.error instead? Does</span>
        <span class="s3">// anyone rely on this throwing? (Seems unlikely.)</span>
        <span class="s1">throw </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">Error(</span><span class="s2">&quot;Cannot prefetch '&quot; </span><span class="s0">+ href + </span><span class="s2">&quot;' because it cannot be converted to a URL.&quot;</span><span class="s0">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
            <span class="s0">value: </span><span class="s2">&quot;E234&quot;</span><span class="s0">,</span>
            <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">configurable: </span><span class="s1">true</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s3">// Don't prefetch during development (improves compilation performance)</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s0">) {</span>
        <span class="s1">return null</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s3">//TURBOPACK unreachable</span>
    <span class="s0">;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">HistoryUpdater(param) {</span>
    <span class="s1">let </span><span class="s0">{ appRouterState } = param;</span>
    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _react.useInsertionEffect)(()=&gt;{</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) </span><span class="s3">//TURBOPACK unreachable</span>
        <span class="s0">;</span>
        <span class="s1">const </span><span class="s0">{ tree, pushRef, canonicalUrl } = appRouterState;</span>
        <span class="s1">const </span><span class="s0">historyState = {</span>
            <span class="s0">...pushRef.preserveCustomHistoryState ? window.history.state : {},</span>
            <span class="s3">// Identifier is shortened intentionally.</span>
            <span class="s3">// __NA is used to identify if the history entry can be handled by the app-router.</span>
            <span class="s3">// __N is used to identify if the history entry can be handled by the old router.</span>
            <span class="s0">__NA: </span><span class="s1">true</span><span class="s0">,</span>
            <span class="s0">__PRIVATE_NEXTJS_INTERNALS_TREE: tree</span>
        <span class="s0">};</span>
        <span class="s1">if </span><span class="s0">(pushRef.pendingPush &amp;&amp; </span><span class="s3">// Skip pushing an additional history entry if the canonicalUrl is the same as the current url.</span>
        <span class="s3">// This mirrors the browser behavior for normal navigation.</span>
        <span class="s0">(</span><span class="s4">0</span><span class="s0">, _createhreffromurl.createHrefFromUrl)(</span><span class="s1">new </span><span class="s0">URL(window.location.href)) !== canonicalUrl) {</span>
            <span class="s3">// This intentionally mutates React state, pushRef is overwritten to ensure additional push/replace calls do not trigger an additional history entry.</span>
            <span class="s0">pushRef.pendingPush = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s0">window.history.pushState(historyState, </span><span class="s2">''</span><span class="s0">, canonicalUrl);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">window.history.replaceState(historyState, </span><span class="s2">''</span><span class="s0">, canonicalUrl);</span>
        <span class="s0">}</span>
    <span class="s0">}, [</span>
        <span class="s0">appRouterState</span>
    <span class="s0">]);</span>
    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _react.useEffect)(()=&gt;{</span>
        <span class="s3">// The Next-Url and the base tree may affect the result of a prefetch</span>
        <span class="s3">// task. Re-prefetch all visible links with the updated values. In most</span>
        <span class="s3">// cases, this will not result in any new network requests, only if</span>
        <span class="s3">// the prefetch result actually varies on one of these inputs.</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) </span><span class="s3">//TURBOPACK unreachable</span>
        <span class="s0">;</span>
    <span class="s0">}, [</span>
        <span class="s0">appRouterState.nextUrl,</span>
        <span class="s0">appRouterState.tree</span>
    <span class="s0">]);</span>
    <span class="s1">return null</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">createEmptyCacheNode() {</span>
    <span class="s1">return </span><span class="s0">{</span>
        <span class="s0">lazyData: </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">rsc: </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">prefetchRsc: </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">head: </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">prefetchHead: </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">parallelRoutes: </span><span class="s1">new </span><span class="s0">Map(),</span>
        <span class="s0">loading: </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">navigatedAt: -</span><span class="s4">1</span>
    <span class="s0">};</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">copyNextJsInternalHistoryState(data) {</span>
    <span class="s1">if </span><span class="s0">(data == </span><span class="s1">null</span><span class="s0">) data = {};</span>
    <span class="s1">const </span><span class="s0">currentState = window.history.state;</span>
    <span class="s1">const </span><span class="s0">__NA = currentState == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: currentState.__NA;</span>
    <span class="s1">if </span><span class="s0">(__NA) {</span>
        <span class="s0">data.__NA = __NA;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">__PRIVATE_NEXTJS_INTERNALS_TREE = currentState == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: currentState.__PRIVATE_NEXTJS_INTERNALS_TREE;</span>
    <span class="s1">if </span><span class="s0">(__PRIVATE_NEXTJS_INTERNALS_TREE) {</span>
        <span class="s0">data.__PRIVATE_NEXTJS_INTERNALS_TREE = __PRIVATE_NEXTJS_INTERNALS_TREE;</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">data;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">Head(param) {</span>
    <span class="s1">let </span><span class="s0">{ headCacheNode } = param;</span>
    <span class="s3">// If this segment has a `prefetchHead`, it's the statically prefetched data.</span>
    <span class="s3">// We should use that on initial render instead of `head`. Then we'll switch</span>
    <span class="s3">// to `head` when the dynamic response streams in.</span>
    <span class="s1">const </span><span class="s0">head = headCacheNode !== </span><span class="s1">null </span><span class="s0">? headCacheNode.head : </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">prefetchHead = headCacheNode !== </span><span class="s1">null </span><span class="s0">? headCacheNode.prefetchHead : </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s3">// If no prefetch data is available, then we go straight to rendering `head`.</span>
    <span class="s1">const </span><span class="s0">resolvedPrefetchRsc = prefetchHead !== </span><span class="s1">null </span><span class="s0">? prefetchHead : head;</span>
    <span class="s3">// We use `useDeferredValue` to handle switching between the prefetched and</span>
    <span class="s3">// final values. The second argument is returned on initial render, then it</span>
    <span class="s3">// re-renders with the first argument.</span>
    <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _react.useDeferredValue)(head, resolvedPrefetchRsc);</span>
<span class="s0">}</span>
<span class="s3">/**</span>
 <span class="s3">* The global router that wraps the application components.</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">Router(param) {</span>
    <span class="s1">let </span><span class="s0">{ actionQueue, assetPrefix, globalError } = param;</span>
    <span class="s1">const </span><span class="s0">state = (</span><span class="s4">0</span><span class="s0">, _useactionqueue.useActionQueue)(actionQueue);</span>
    <span class="s1">const </span><span class="s0">{ canonicalUrl } = state;</span>
    <span class="s3">// Add memoized pathname/query for useSearchParams and usePathname.</span>
    <span class="s1">const </span><span class="s0">{ searchParams, pathname } = (</span><span class="s4">0</span><span class="s0">, _react.useMemo)(()=&gt;{</span>
        <span class="s1">const </span><span class="s0">url = </span><span class="s1">new </span><span class="s0">URL(canonicalUrl, </span><span class="s1">typeof </span><span class="s0">window === </span><span class="s2">'undefined' </span><span class="s0">? </span><span class="s2">'http://n' </span><span class="s0">: window.location.href);</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s3">// This is turned into a readonly class in `useSearchParams`</span>
            <span class="s0">searchParams: url.searchParams,</span>
            <span class="s0">pathname: (</span><span class="s4">0</span><span class="s0">, _hasbasepath.hasBasePath)(url.pathname) ? (</span><span class="s4">0</span><span class="s0">, _removebasepath.removeBasePath)(url.pathname) : url.pathname</span>
        <span class="s0">};</span>
    <span class="s0">}, [</span>
        <span class="s0">canonicalUrl</span>
    <span class="s0">]);</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s0">) {</span>
        <span class="s3">// eslint-disable-next-line react-hooks/rules-of-hooks</span>
        <span class="s1">const </span><span class="s0">{ cache, prefetchCache, tree } = state;</span>
        <span class="s3">// This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes</span>
        <span class="s3">// eslint-disable-next-line react-hooks/rules-of-hooks</span>
        <span class="s0">(</span><span class="s4">0</span><span class="s0">, _react.useEffect)(()=&gt;{</span>
            <span class="s3">// Add `window.nd` for debugging purposes.</span>
            <span class="s3">// This is not meant for use in applications as concurrent rendering will affect the cache/tree/router.</span>
            <span class="s3">// @ts-ignore this is for debugging</span>
            <span class="s0">window.nd = {</span>
                <span class="s0">router: _approuterinstance.publicAppRouterInstance,</span>
                <span class="s0">cache,</span>
                <span class="s0">prefetchCache,</span>
                <span class="s0">tree</span>
            <span class="s0">};</span>
        <span class="s0">}, [</span>
            <span class="s0">cache,</span>
            <span class="s0">prefetchCache,</span>
            <span class="s0">tree</span>
        <span class="s0">]);</span>
    <span class="s0">}</span>
    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _react.useEffect)(()=&gt;{</span>
        <span class="s3">// If the app is restored from bfcache, it's possible that</span>
        <span class="s3">// pushRef.mpaNavigation is true, which would mean that any re-render of this component</span>
        <span class="s3">// would trigger the mpa navigation logic again from the lines below.</span>
        <span class="s3">// This will restore the router to the initial state in the event that the app is restored from bfcache.</span>
        <span class="s1">function </span><span class="s0">handlePageShow(event) {</span>
            <span class="s1">var </span><span class="s0">_window_history_state;</span>
            <span class="s1">if </span><span class="s0">(!event.persisted || !((_window_history_state = window.history.state) == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: _window_history_state.__PRIVATE_NEXTJS_INTERNALS_TREE)) {</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s3">// Clear the pendingMpaPath value so that a subsequent MPA navigation to the same URL can be triggered.</span>
            <span class="s3">// This is necessary because if the browser restored from bfcache, the pendingMpaPath would still be set to the value</span>
            <span class="s3">// of the last MPA navigation.</span>
            <span class="s0">globalMutable.pendingMpaPath = undefined;</span>
            <span class="s0">(</span><span class="s4">0</span><span class="s0">, _useactionqueue.dispatchAppRouterAction)({</span>
                <span class="s0">type: _routerreducertypes.ACTION_RESTORE,</span>
                <span class="s0">url: </span><span class="s1">new </span><span class="s0">URL(window.location.href),</span>
                <span class="s0">tree: window.history.state.__PRIVATE_NEXTJS_INTERNALS_TREE</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s0">window.addEventListener(</span><span class="s2">'pageshow'</span><span class="s0">, handlePageShow);</span>
        <span class="s1">return </span><span class="s0">()=&gt;{</span>
            <span class="s0">window.removeEventListener(</span><span class="s2">'pageshow'</span><span class="s0">, handlePageShow);</span>
        <span class="s0">};</span>
    <span class="s0">}, []);</span>
    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _react.useEffect)(()=&gt;{</span>
        <span class="s3">// Ensure that any redirect errors that bubble up outside of the RedirectBoundary</span>
        <span class="s3">// are caught and handled by the router.</span>
        <span class="s1">function </span><span class="s0">handleUnhandledRedirect(event) {</span>
            <span class="s1">const </span><span class="s0">error = </span><span class="s2">'reason' </span><span class="s1">in </span><span class="s0">event ? event.reason : event.error;</span>
            <span class="s1">if </span><span class="s0">((</span><span class="s4">0</span><span class="s0">, _redirecterror.isRedirectError)(error)) {</span>
                <span class="s0">event.preventDefault();</span>
                <span class="s1">const </span><span class="s0">url = (</span><span class="s4">0</span><span class="s0">, _redirect.getURLFromRedirectError)(error);</span>
                <span class="s1">const </span><span class="s0">redirectType = (</span><span class="s4">0</span><span class="s0">, _redirect.getRedirectTypeFromError)(error);</span>
                <span class="s3">// TODO: This should access the router methods directly, rather than</span>
                <span class="s3">// go through the public interface.</span>
                <span class="s1">if </span><span class="s0">(redirectType === _redirecterror.RedirectType.push) {</span>
                    <span class="s0">_approuterinstance.publicAppRouterInstance.push(url, {});</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">_approuterinstance.publicAppRouterInstance.replace(url, {});</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">window.addEventListener(</span><span class="s2">'error'</span><span class="s0">, handleUnhandledRedirect);</span>
        <span class="s0">window.addEventListener(</span><span class="s2">'unhandledrejection'</span><span class="s0">, handleUnhandledRedirect);</span>
        <span class="s1">return </span><span class="s0">()=&gt;{</span>
            <span class="s0">window.removeEventListener(</span><span class="s2">'error'</span><span class="s0">, handleUnhandledRedirect);</span>
            <span class="s0">window.removeEventListener(</span><span class="s2">'unhandledrejection'</span><span class="s0">, handleUnhandledRedirect);</span>
        <span class="s0">};</span>
    <span class="s0">}, []);</span>
    <span class="s3">// When mpaNavigation flag is set do a hard navigation to the new url.</span>
    <span class="s3">// Infinitely suspend because we don't actually want to rerender any child</span>
    <span class="s3">// components with the new URL and any entangled state updates shouldn't</span>
    <span class="s3">// commit either (eg: useTransition isPending should stay true until the page</span>
    <span class="s3">// unloads).</span>
    <span class="s3">//</span>
    <span class="s3">// This is a side effect in render. Don't try this at home, kids. It's</span>
    <span class="s3">// probably safe because we know this is a singleton component and it's never</span>
    <span class="s3">// in &lt;Offscreen&gt;. At least I hope so. (It will run twice in dev strict mode,</span>
    <span class="s3">// but that's... fine?)</span>
    <span class="s1">const </span><span class="s0">{ pushRef } = state;</span>
    <span class="s1">if </span><span class="s0">(pushRef.mpaNavigation) {</span>
        <span class="s3">// if there's a re-render, we don't want to trigger another redirect if one is already in flight to the same URL</span>
        <span class="s1">if </span><span class="s0">(globalMutable.pendingMpaPath !== canonicalUrl) {</span>
            <span class="s1">const </span><span class="s0">location = window.location;</span>
            <span class="s1">if </span><span class="s0">(pushRef.pendingPush) {</span>
                <span class="s0">location.assign(canonicalUrl);</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">location.replace(canonicalUrl);</span>
            <span class="s0">}</span>
            <span class="s0">globalMutable.pendingMpaPath = canonicalUrl;</span>
        <span class="s0">}</span>
        <span class="s3">// TODO-APP: Should we listen to navigateerror here to catch failed</span>
        <span class="s3">// navigations somehow? And should we call window.stop() if a SPA navigation</span>
        <span class="s3">// should interrupt an MPA one?</span>
        <span class="s3">// NOTE: This is intentionally using `throw` instead of `use` because we're</span>
        <span class="s3">// inside an externally mutable condition (pushRef.mpaNavigation), which</span>
        <span class="s3">// violates the rules of hooks.</span>
        <span class="s1">throw </span><span class="s0">_unresolvedthenable.unresolvedThenable;</span>
    <span class="s0">}</span>
    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _react.useEffect)(()=&gt;{</span>
        <span class="s1">const </span><span class="s0">originalPushState = window.history.pushState.bind(window.history);</span>
        <span class="s1">const </span><span class="s0">originalReplaceState = window.history.replaceState.bind(window.history);</span>
        <span class="s3">// Ensure the canonical URL in the Next.js Router is updated when the URL is changed so that `usePathname` and `useSearchParams` hold the pushed values.</span>
        <span class="s1">const </span><span class="s0">applyUrlFromHistoryPushReplace = (url)=&gt;{</span>
            <span class="s1">var </span><span class="s0">_window_history_state;</span>
            <span class="s1">const </span><span class="s0">href = window.location.href;</span>
            <span class="s1">const </span><span class="s0">tree = (_window_history_state = window.history.state) == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: _window_history_state.__PRIVATE_NEXTJS_INTERNALS_TREE;</span>
            <span class="s0">(</span><span class="s4">0</span><span class="s0">, _react.startTransition)(()=&gt;{</span>
                <span class="s0">(</span><span class="s4">0</span><span class="s0">, _useactionqueue.dispatchAppRouterAction)({</span>
                    <span class="s0">type: _routerreducertypes.ACTION_RESTORE,</span>
                    <span class="s0">url: </span><span class="s1">new </span><span class="s0">URL(url != </span><span class="s1">null </span><span class="s0">? url : href, href),</span>
                    <span class="s0">tree</span>
                <span class="s0">});</span>
            <span class="s0">});</span>
        <span class="s0">};</span>
        <span class="s3">/**</span>
     <span class="s3">* Patch pushState to ensure external changes to the history are reflected in the Next.js Router.</span>
     <span class="s3">* Ensures Next.js internal history state is copied to the new history entry.</span>
     <span class="s3">* Ensures usePathname and useSearchParams hold the newly provided url.</span>
     <span class="s3">*/ </span><span class="s0">window.history.pushState = </span><span class="s1">function </span><span class="s0">pushState(data, _unused, url) {</span>
            <span class="s3">// Avoid a loop when Next.js internals trigger pushState/replaceState</span>
            <span class="s1">if </span><span class="s0">((data == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: data.__NA) || (data == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: data._N)) {</span>
                <span class="s1">return </span><span class="s0">originalPushState(data, _unused, url);</span>
            <span class="s0">}</span>
            <span class="s0">data = copyNextJsInternalHistoryState(data);</span>
            <span class="s1">if </span><span class="s0">(url) {</span>
                <span class="s0">applyUrlFromHistoryPushReplace(url);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">originalPushState(data, _unused, url);</span>
        <span class="s0">};</span>
        <span class="s3">/**</span>
     <span class="s3">* Patch replaceState to ensure external changes to the history are reflected in the Next.js Router.</span>
     <span class="s3">* Ensures Next.js internal history state is copied to the new history entry.</span>
     <span class="s3">* Ensures usePathname and useSearchParams hold the newly provided url.</span>
     <span class="s3">*/ </span><span class="s0">window.history.replaceState = </span><span class="s1">function </span><span class="s0">replaceState(data, _unused, url) {</span>
            <span class="s3">// Avoid a loop when Next.js internals trigger pushState/replaceState</span>
            <span class="s1">if </span><span class="s0">((data == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: data.__NA) || (data == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: data._N)) {</span>
                <span class="s1">return </span><span class="s0">originalReplaceState(data, _unused, url);</span>
            <span class="s0">}</span>
            <span class="s0">data = copyNextJsInternalHistoryState(data);</span>
            <span class="s1">if </span><span class="s0">(url) {</span>
                <span class="s0">applyUrlFromHistoryPushReplace(url);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">originalReplaceState(data, _unused, url);</span>
        <span class="s0">};</span>
        <span class="s3">/**</span>
     <span class="s3">* Handle popstate event, this is used to handle back/forward in the browser.</span>
     <span class="s3">* By default dispatches ACTION_RESTORE, however if the history entry was not pushed/replaced by app-router it will reload the page.</span>
     <span class="s3">* That case can happen when the old router injected the history entry.</span>
     <span class="s3">*/ </span><span class="s1">const </span><span class="s0">onPopState = (event)=&gt;{</span>
            <span class="s1">if </span><span class="s0">(!event.state) {</span>
                <span class="s3">// TODO-APP: this case only happens when pushState/replaceState was called outside of Next.js. It should probably reload the page in this case.</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s3">// This case happens when the history entry was pushed by the `pages` router.</span>
            <span class="s1">if </span><span class="s0">(!event.state.__NA) {</span>
                <span class="s0">window.location.reload();</span>
                <span class="s1">return</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s3">// TODO-APP: Ideally the back button should not use startTransition as it should apply the updates synchronously</span>
            <span class="s3">// Without startTransition works if the cache is there for this path</span>
            <span class="s0">(</span><span class="s4">0</span><span class="s0">, _react.startTransition)(()=&gt;{</span>
                <span class="s0">(</span><span class="s4">0</span><span class="s0">, _approuterinstance.dispatchTraverseAction)(window.location.href, event.state.__PRIVATE_NEXTJS_INTERNALS_TREE);</span>
            <span class="s0">});</span>
        <span class="s0">};</span>
        <span class="s3">// Register popstate event to call onPopstate.</span>
        <span class="s0">window.addEventListener(</span><span class="s2">'popstate'</span><span class="s0">, onPopState);</span>
        <span class="s1">return </span><span class="s0">()=&gt;{</span>
            <span class="s0">window.history.pushState = originalPushState;</span>
            <span class="s0">window.history.replaceState = originalReplaceState;</span>
            <span class="s0">window.removeEventListener(</span><span class="s2">'popstate'</span><span class="s0">, onPopState);</span>
        <span class="s0">};</span>
    <span class="s0">}, []);</span>
    <span class="s1">const </span><span class="s0">{ cache, tree, nextUrl, focusAndScrollRef } = state;</span>
    <span class="s1">const </span><span class="s0">matchingHead = (</span><span class="s4">0</span><span class="s0">, _react.useMemo)(()=&gt;{</span>
        <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _findheadincache.findHeadInCache)(cache, tree[</span><span class="s4">1</span><span class="s0">]);</span>
    <span class="s0">}, [</span>
        <span class="s0">cache,</span>
        <span class="s0">tree</span>
    <span class="s0">]);</span>
    <span class="s3">// Add memoized pathParams for useParams.</span>
    <span class="s1">const </span><span class="s0">pathParams = (</span><span class="s4">0</span><span class="s0">, _react.useMemo)(()=&gt;{</span>
        <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _computechangedpath.getSelectedParams)(tree);</span>
    <span class="s0">}, [</span>
        <span class="s0">tree</span>
    <span class="s0">]);</span>
    <span class="s1">const </span><span class="s0">layoutRouterContext = (</span><span class="s4">0</span><span class="s0">, _react.useMemo)(()=&gt;{</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">parentTree: tree,</span>
            <span class="s0">parentCacheNode: cache,</span>
            <span class="s0">parentSegmentPath: </span><span class="s1">null</span><span class="s0">,</span>
            <span class="s3">// Root node always has `url`</span>
            <span class="s3">// Provided in AppTreeContext to ensure it can be overwritten in layout-router</span>
            <span class="s0">url: canonicalUrl</span>
        <span class="s0">};</span>
    <span class="s0">}, [</span>
        <span class="s0">tree,</span>
        <span class="s0">cache,</span>
        <span class="s0">canonicalUrl</span>
    <span class="s0">]);</span>
    <span class="s1">const </span><span class="s0">globalLayoutRouterContext = (</span><span class="s4">0</span><span class="s0">, _react.useMemo)(()=&gt;{</span>
        <span class="s1">return </span><span class="s0">{</span>
            <span class="s0">tree,</span>
            <span class="s0">focusAndScrollRef,</span>
            <span class="s0">nextUrl</span>
        <span class="s0">};</span>
    <span class="s0">}, [</span>
        <span class="s0">tree,</span>
        <span class="s0">focusAndScrollRef,</span>
        <span class="s0">nextUrl</span>
    <span class="s0">]);</span>
    <span class="s1">let </span><span class="s0">head;</span>
    <span class="s1">if </span><span class="s0">(matchingHead !== </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s3">// The head is wrapped in an extra component so we can use</span>
        <span class="s3">// `useDeferredValue` to swap between the prefetched and final versions of</span>
        <span class="s3">// the head. (This is what LayoutRouter does for segment data, too.)</span>
        <span class="s3">//</span>
        <span class="s3">// The `key` is used to remount the component whenever the head moves to</span>
        <span class="s3">// a different segment.</span>
        <span class="s1">const </span><span class="s0">[headCacheNode, headKey, headKeyWithoutSearchParams] = matchingHead;</span>
        <span class="s0">head = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(Head, {</span>
            <span class="s0">headCacheNode: headCacheNode</span>
        <span class="s0">}, </span><span class="s1">typeof </span><span class="s0">window === </span><span class="s2">'undefined' </span><span class="s0">? headKeyWithoutSearchParams : headKey);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">head = </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">let </span><span class="s0">content = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsxs)(_redirectboundary.RedirectBoundary, {</span>
        <span class="s0">children: [</span>
            <span class="s0">head,</span>
            <span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(_boundarycomponents.RootLayoutBoundary, {</span>
                <span class="s0">children: cache.rsc</span>
            <span class="s0">}),</span>
            <span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(_approuterannouncer.AppRouterAnnouncer, {</span>
                <span class="s0">tree: tree</span>
            <span class="s0">})</span>
        <span class="s0">]</span>
    <span class="s0">});</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s0">) {</span>
        <span class="s3">// In development, we apply few error boundaries and hot-reloader:</span>
        <span class="s3">// - DevRootHTTPAccessFallbackBoundary: avoid using navigation API like notFound() in root layout</span>
        <span class="s3">// - HotReloader:</span>
        <span class="s3">//  - hot-reload the app when the code changes</span>
        <span class="s3">//  - render dev overlay</span>
        <span class="s3">//  - catch runtime errors and display global-error when necessary</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">window !== </span><span class="s2">'undefined'</span><span class="s0">) {</span>
            <span class="s1">const </span><span class="s0">{ DevRootHTTPAccessFallbackBoundary } = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/dev-root-http-access-fallback-boundary.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
            <span class="s0">content = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(DevRootHTTPAccessFallbackBoundary, {</span>
                <span class="s0">children: content</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">HotReloader = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/dev/hot-reloader/app/hot-reloader-app.js [app-client] (ecmascript)&quot;</span><span class="s0">).default;</span>
        <span class="s0">content = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(HotReloader, {</span>
            <span class="s0">assetPrefix: assetPrefix,</span>
            <span class="s0">globalError: globalError,</span>
            <span class="s0">children: content</span>
        <span class="s0">});</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s3">//TURBOPACK unreachable</span>
    <span class="s0">;</span>
    <span class="s1">return </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsxs)(_jsxruntime.Fragment, {</span>
        <span class="s0">children: [</span>
            <span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(HistoryUpdater, {</span>
                <span class="s0">appRouterState: state</span>
            <span class="s0">}),</span>
            <span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(RuntimeStyles, {}),</span>
            <span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.PathParamsContext.Provider, {</span>
                <span class="s0">value: pathParams,</span>
                <span class="s0">children: </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.PathnameContext.Provider, {</span>
                    <span class="s0">value: pathname,</span>
                    <span class="s0">children: </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.SearchParamsContext.Provider, {</span>
                        <span class="s0">value: searchParams,</span>
                        <span class="s0">children: </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(_approutercontextsharedruntime.GlobalLayoutRouterContext.Provider, {</span>
                            <span class="s0">value: globalLayoutRouterContext,</span>
                            <span class="s0">children: </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(_approutercontextsharedruntime.AppRouterContext.Provider, {</span>
                                <span class="s0">value: _approuterinstance.publicAppRouterInstance,</span>
                                <span class="s0">children: </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(_approutercontextsharedruntime.LayoutRouterContext.Provider, {</span>
                                    <span class="s0">value: layoutRouterContext,</span>
                                    <span class="s0">children: content</span>
                                <span class="s0">})</span>
                            <span class="s0">})</span>
                        <span class="s0">})</span>
                    <span class="s0">})</span>
                <span class="s0">})</span>
            <span class="s0">})</span>
        <span class="s0">]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">AppRouter(param) {</span>
    <span class="s1">let </span><span class="s0">{ actionQueue, globalErrorState, assetPrefix } = param;</span>
    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _navfailurehandler.useNavFailureHandler)();</span>
    <span class="s1">const </span><span class="s0">router = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(Router, {</span>
        <span class="s0">actionQueue: actionQueue,</span>
        <span class="s0">assetPrefix: assetPrefix,</span>
        <span class="s0">globalError: globalErrorState</span>
    <span class="s0">});</span>
    <span class="s3">// At the very top level, use the default GlobalError component as the final fallback.</span>
    <span class="s3">// When the app router itself fails, which means the framework itself fails, we show the default error.</span>
    <span class="s1">return </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(_rooterrorboundary.default, {</span>
        <span class="s0">errorComponent: _globalerror.default,</span>
        <span class="s0">children: router</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s1">const </span><span class="s0">runtimeStyles = </span><span class="s1">new </span><span class="s0">Set();</span>
<span class="s1">let </span><span class="s0">runtimeStyleChanged = </span><span class="s1">new </span><span class="s0">Set();</span>
<span class="s0">globalThis._N_E_STYLE_LOAD = </span><span class="s1">function</span><span class="s0">(href) {</span>
    <span class="s1">let </span><span class="s0">len = runtimeStyles.size;</span>
    <span class="s0">runtimeStyles.add(href);</span>
    <span class="s1">if </span><span class="s0">(runtimeStyles.size !== len) {</span>
        <span class="s0">runtimeStyleChanged.forEach((cb)=&gt;cb());</span>
    <span class="s0">}</span>
    <span class="s3">// TODO figure out how to get a promise here</span>
    <span class="s3">// But maybe it's not necessary as react would block rendering until it's loaded</span>
    <span class="s1">return </span><span class="s0">Promise.resolve();</span>
<span class="s0">};</span>
<span class="s1">function </span><span class="s0">RuntimeStyles() {</span>
    <span class="s1">const </span><span class="s0">[, forceUpdate] = _react.default.useState(</span><span class="s4">0</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">renderedStylesSize = runtimeStyles.size;</span>
    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _react.useEffect)(()=&gt;{</span>
        <span class="s1">const </span><span class="s0">changed = ()=&gt;forceUpdate((c)=&gt;c + </span><span class="s4">1</span><span class="s0">);</span>
        <span class="s0">runtimeStyleChanged.add(changed);</span>
        <span class="s1">if </span><span class="s0">(renderedStylesSize !== runtimeStyles.size) {</span>
            <span class="s0">changed();</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">()=&gt;{</span>
            <span class="s0">runtimeStyleChanged.delete(changed);</span>
        <span class="s0">};</span>
    <span class="s0">}, [</span>
        <span class="s0">renderedStylesSize,</span>
        <span class="s0">forceUpdate</span>
    <span class="s0">]);</span>
    <span class="s1">const </span><span class="s0">dplId = (</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) ? </span><span class="s2">&quot;TURBOPACK unreachable&quot; </span><span class="s0">: </span><span class="s2">''</span><span class="s0">;</span>
    <span class="s1">return </span><span class="s0">[</span>
        <span class="s0">...runtimeStyles</span>
    <span class="s0">].map((href, i)=&gt;</span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(</span><span class="s2">&quot;link&quot;</span><span class="s0">, {</span>
            <span class="s0">rel: </span><span class="s2">&quot;stylesheet&quot;</span><span class="s0">,</span>
            <span class="s0">href: </span><span class="s2">&quot;&quot; </span><span class="s0">+ href + dplId,</span>
            <span class="s3">// @ts-ignore</span>
            <span class="s0">precedence: </span><span class="s2">&quot;next&quot;</span>
        <span class="s0">}, i));</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=app-router.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/ppr-navigations.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s0">abortTask: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">listenForDynamicRequest: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">startPPRNavigation: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">updateCacheNodeOnPopstateRestoration: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s0">abortTask: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">abortTask;</span>
    <span class="s0">},</span>
    <span class="s0">listenForDynamicRequest: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">listenForDynamicRequest;</span>
    <span class="s0">},</span>
    <span class="s0">startPPRNavigation: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">startPPRNavigation;</span>
    <span class="s0">},</span>
    <span class="s0">updateCacheNodeOnPopstateRestoration: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">updateCacheNodeOnPopstateRestoration;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_segment = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/segment.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_matchsegments = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/match-segments.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_createroutercachekey = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_isnavigatingtonewrootlayout = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_prefetchcacheutils = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">MPA_NAVIGATION_TASK = {</span>
    <span class="s0">route: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">node: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">dynamicRequestTree: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">children: </span><span class="s1">null</span>
<span class="s0">};</span>
<span class="s1">function </span><span class="s0">startPPRNavigation(navigatedAt, oldCacheNode, oldRouterState, newRouterState, prefetchData, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, scrollableSegmentsResult) {</span>
    <span class="s1">const </span><span class="s0">segmentPath = [];</span>
    <span class="s1">return </span><span class="s0">updateCacheNodeOnNavigation(navigatedAt, oldCacheNode, oldRouterState, newRouterState, </span><span class="s1">false</span><span class="s0">, prefetchData, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, segmentPath, scrollableSegmentsResult);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">updateCacheNodeOnNavigation(navigatedAt, oldCacheNode, oldRouterState, newRouterState, didFindRootLayout, prefetchData, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, segmentPath, scrollableSegmentsResult) {</span>
    <span class="s3">// Diff the old and new trees to reuse the shared layouts.</span>
    <span class="s1">const </span><span class="s0">oldRouterStateChildren = oldRouterState[</span><span class="s4">1</span><span class="s0">];</span>
    <span class="s1">const </span><span class="s0">newRouterStateChildren = newRouterState[</span><span class="s4">1</span><span class="s0">];</span>
    <span class="s1">const </span><span class="s0">prefetchDataChildren = prefetchData !== </span><span class="s1">null </span><span class="s0">? prefetchData[</span><span class="s4">2</span><span class="s0">] : </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(!didFindRootLayout) {</span>
        <span class="s3">// We're currently traversing the part of the tree that was also part of</span>
        <span class="s3">// the previous route. If we discover a root layout, then we don't need to</span>
        <span class="s3">// trigger an MPA navigation. See beginRenderingNewRouteTree for context.</span>
        <span class="s1">const </span><span class="s0">isRootLayout = newRouterState[</span><span class="s4">4</span><span class="s0">] === </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s1">if </span><span class="s0">(isRootLayout) {</span>
            <span class="s3">// Found a matching root layout.</span>
            <span class="s0">didFindRootLayout = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">oldParallelRoutes = oldCacheNode.parallelRoutes;</span>
    <span class="s3">// Clone the current set of segment children, even if they aren't active in</span>
    <span class="s3">// the new tree.</span>
    <span class="s3">// TODO: We currently retain all the inactive segments indefinitely, until</span>
    <span class="s3">// there's an explicit refresh, or a parent layout is lazily refreshed. We</span>
    <span class="s3">// rely on this for popstate navigations, which update the Router State Tree</span>
    <span class="s3">// but do not eagerly perform a data fetch, because they expect the segment</span>
    <span class="s3">// data to already be in the Cache Node tree. For highly static sites that</span>
    <span class="s3">// are mostly read-only, this may happen only rarely, causing memory to</span>
    <span class="s3">// leak. We should figure out a better model for the lifetime of inactive</span>
    <span class="s3">// segments, so we can maintain instant back/forward navigations without</span>
    <span class="s3">// leaking memory indefinitely.</span>
    <span class="s1">const </span><span class="s0">prefetchParallelRoutes = </span><span class="s1">new </span><span class="s0">Map(oldParallelRoutes);</span>
    <span class="s3">// As we diff the trees, we may sometimes modify (copy-on-write, not mutate)</span>
    <span class="s3">// the Route Tree that was returned by the server  for example, in the case</span>
    <span class="s3">// of default parallel routes, we preserve the currently active segment. To</span>
    <span class="s3">// avoid mutating the original tree, we clone the router state children along</span>
    <span class="s3">// the return path.</span>
    <span class="s1">let </span><span class="s0">patchedRouterStateChildren = {};</span>
    <span class="s1">let </span><span class="s0">taskChildren = </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s3">// Most navigations require a request to fetch additional data from the</span>
    <span class="s3">// server, either because the data was not already prefetched, or because the</span>
    <span class="s3">// target route contains dynamic data that cannot be prefetched.</span>
    <span class="s3">//</span>
    <span class="s3">// However, if the target route is fully static, and it's already completely</span>
    <span class="s3">// loaded into the segment cache, then we can skip the server request.</span>
    <span class="s3">//</span>
    <span class="s3">// This starts off as `false`, and is set to `true` if any of the child</span>
    <span class="s3">// routes requires a dynamic request.</span>
    <span class="s1">let </span><span class="s0">needsDynamicRequest = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s3">// As we traverse the children, we'll construct a FlightRouterState that can</span>
    <span class="s3">// be sent to the server to request the dynamic data. If it turns out that</span>
    <span class="s3">// nothing in the subtree is dynamic (i.e. needsDynamicRequest is false at the</span>
    <span class="s3">// end), then this will be discarded.</span>
    <span class="s3">// TODO: We can probably optimize the format of this data structure to only</span>
    <span class="s3">// include paths that are dynamic. Instead of reusing the</span>
    <span class="s3">// FlightRouterState type.</span>
    <span class="s1">let </span><span class="s0">dynamicRequestTreeChildren = {};</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">parallelRouteKey </span><span class="s1">in </span><span class="s0">newRouterStateChildren){</span>
        <span class="s1">const </span><span class="s0">newRouterStateChild = newRouterStateChildren[parallelRouteKey];</span>
        <span class="s1">const </span><span class="s0">oldRouterStateChild = oldRouterStateChildren[parallelRouteKey];</span>
        <span class="s1">const </span><span class="s0">oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey);</span>
        <span class="s1">const </span><span class="s0">prefetchDataChild = prefetchDataChildren !== </span><span class="s1">null </span><span class="s0">? prefetchDataChildren[parallelRouteKey] : </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">newSegmentChild = newRouterStateChild[</span><span class="s4">0</span><span class="s0">];</span>
        <span class="s1">const </span><span class="s0">newSegmentPathChild = segmentPath.concat([</span>
            <span class="s0">parallelRouteKey,</span>
            <span class="s0">newSegmentChild</span>
        <span class="s0">]);</span>
        <span class="s1">const </span><span class="s0">newSegmentKeyChild = (</span><span class="s4">0</span><span class="s0">, _createroutercachekey.createRouterCacheKey)(newSegmentChild);</span>
        <span class="s1">const </span><span class="s0">oldSegmentChild = oldRouterStateChild !== undefined ? oldRouterStateChild[</span><span class="s4">0</span><span class="s0">] : undefined;</span>
        <span class="s1">const </span><span class="s0">oldCacheNodeChild = oldSegmentMapChild !== undefined ? oldSegmentMapChild.get(newSegmentKeyChild) : undefined;</span>
        <span class="s1">let </span><span class="s0">taskChild;</span>
        <span class="s1">if </span><span class="s0">(newSegmentChild === _segment.DEFAULT_SEGMENT_KEY) {</span>
            <span class="s3">// This is another kind of leaf segment  a default route.</span>
            <span class="s3">//</span>
            <span class="s3">// Default routes have special behavior. When there's no matching segment</span>
            <span class="s3">// for a parallel route, Next.js preserves the currently active segment</span>
            <span class="s3">// during a client navigation  but not for initial render. The server</span>
            <span class="s3">// leaves it to the client to account for this. So we need to handle</span>
            <span class="s3">// it here.</span>
            <span class="s1">if </span><span class="s0">(oldRouterStateChild !== undefined) {</span>
                <span class="s3">// Reuse the existing Router State for this segment. We spawn a &quot;task&quot;</span>
                <span class="s3">// just to keep track of the updated router state; unlike most, it's</span>
                <span class="s3">// already fulfilled and won't be affected by the dynamic response.</span>
                <span class="s0">taskChild = spawnReusedTask(oldRouterStateChild);</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s3">// There's no currently active segment. Switch to the &quot;create&quot; path.</span>
                <span class="s0">taskChild = beginRenderingNewRouteTree(navigatedAt, oldRouterStateChild, newRouterStateChild, oldCacheNodeChild, didFindRootLayout, prefetchDataChild !== undefined ? prefetchDataChild : </span><span class="s1">null</span><span class="s0">, prefetchHead, isPrefetchHeadPartial, newSegmentPathChild, scrollableSegmentsResult);</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(isSamePageNavigation &amp;&amp; </span><span class="s3">// Check if this is a page segment.</span>
        <span class="s3">// TODO: We're not consistent about how we do this check. Some places</span>
        <span class="s3">// check if the segment starts with PAGE_SEGMENT_KEY, but most seem to</span>
        <span class="s3">// check if there any any children, which is why I'm doing it here. We</span>
        <span class="s3">// should probably encode an empty children set as `null` though. Either</span>
        <span class="s3">// way, we should update all the checks to be consistent.</span>
        <span class="s0">Object.keys(newRouterStateChild[</span><span class="s4">1</span><span class="s0">]).length === </span><span class="s4">0</span><span class="s0">) {</span>
            <span class="s3">// We special case navigations to the exact same URL as the current</span>
            <span class="s3">// location. It's a common UI pattern for apps to refresh when you click a</span>
            <span class="s3">// link to the current page. So when this happens, we refresh the dynamic</span>
            <span class="s3">// data in the page segments.</span>
            <span class="s3">//</span>
            <span class="s3">// Note that this does not apply if the any part of the hash or search</span>
            <span class="s3">// query has changed. This might feel a bit weird but it makes more sense</span>
            <span class="s3">// when you consider that the way to trigger this behavior is to click</span>
            <span class="s3">// the same link multiple times.</span>
            <span class="s3">//</span>
            <span class="s3">// TODO: We should probably refresh the *entire* route when this case</span>
            <span class="s3">// occurs, not just the page segments. Essentially treating it the same as</span>
            <span class="s3">// a refresh() triggered by an action, which is the more explicit way of</span>
            <span class="s3">// modeling the UI pattern described above.</span>
            <span class="s3">//</span>
            <span class="s3">// Also note that this only refreshes the dynamic data, not static/</span>
            <span class="s3">// cached data. If the page segment is fully static and prefetched, the</span>
            <span class="s3">// request is skipped. (This is also how refresh() works.)</span>
            <span class="s0">taskChild = beginRenderingNewRouteTree(navigatedAt, oldRouterStateChild, newRouterStateChild, oldCacheNodeChild, didFindRootLayout, prefetchDataChild !== undefined ? prefetchDataChild : </span><span class="s1">null</span><span class="s0">, prefetchHead, isPrefetchHeadPartial, newSegmentPathChild, scrollableSegmentsResult);</span>
        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(oldRouterStateChild !== undefined &amp;&amp; oldSegmentChild !== undefined &amp;&amp; (</span><span class="s4">0</span><span class="s0">, _matchsegments.matchSegment)(newSegmentChild, oldSegmentChild)) {</span>
            <span class="s1">if </span><span class="s0">(oldCacheNodeChild !== undefined &amp;&amp; oldRouterStateChild !== undefined) {</span>
                <span class="s3">// This segment exists in both the old and new trees. Recursively update</span>
                <span class="s3">// the children.</span>
                <span class="s0">taskChild = updateCacheNodeOnNavigation(navigatedAt, oldCacheNodeChild, oldRouterStateChild, newRouterStateChild, didFindRootLayout, prefetchDataChild, prefetchHead, isPrefetchHeadPartial, isSamePageNavigation, newSegmentPathChild, scrollableSegmentsResult);</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s3">// There's no existing Cache Node for this segment. Switch to the</span>
                <span class="s3">// &quot;create&quot; path.</span>
                <span class="s0">taskChild = beginRenderingNewRouteTree(navigatedAt, oldRouterStateChild, newRouterStateChild, oldCacheNodeChild, didFindRootLayout, prefetchDataChild !== undefined ? prefetchDataChild : </span><span class="s1">null</span><span class="s0">, prefetchHead, isPrefetchHeadPartial, newSegmentPathChild, scrollableSegmentsResult);</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s3">// This is a new tree. Switch to the &quot;create&quot; path.</span>
            <span class="s0">taskChild = beginRenderingNewRouteTree(navigatedAt, oldRouterStateChild, newRouterStateChild, oldCacheNodeChild, didFindRootLayout, prefetchDataChild !== undefined ? prefetchDataChild : </span><span class="s1">null</span><span class="s0">, prefetchHead, isPrefetchHeadPartial, newSegmentPathChild, scrollableSegmentsResult);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(taskChild !== </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s3">// Recursively propagate up the child tasks.</span>
            <span class="s1">if </span><span class="s0">(taskChild.route === </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s3">// One of the child tasks discovered a change to the root layout.</span>
                <span class="s3">// Immediately unwind from this recursive traversal.</span>
                <span class="s1">return </span><span class="s0">MPA_NAVIGATION_TASK;</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(taskChildren === </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s0">taskChildren = </span><span class="s1">new </span><span class="s0">Map();</span>
            <span class="s0">}</span>
            <span class="s0">taskChildren.set(parallelRouteKey, taskChild);</span>
            <span class="s1">const </span><span class="s0">newCacheNodeChild = taskChild.node;</span>
            <span class="s1">if </span><span class="s0">(newCacheNodeChild !== </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s1">const </span><span class="s0">newSegmentMapChild = </span><span class="s1">new </span><span class="s0">Map(oldSegmentMapChild);</span>
                <span class="s0">newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild);</span>
                <span class="s0">prefetchParallelRoutes.set(parallelRouteKey, newSegmentMapChild);</span>
            <span class="s0">}</span>
            <span class="s3">// The child tree's route state may be different from the prefetched</span>
            <span class="s3">// route sent by the server. We need to clone it as we traverse back up</span>
            <span class="s3">// the tree.</span>
            <span class="s1">const </span><span class="s0">taskChildRoute = taskChild.route;</span>
            <span class="s0">patchedRouterStateChildren[parallelRouteKey] = taskChildRoute;</span>
            <span class="s1">const </span><span class="s0">dynamicRequestTreeChild = taskChild.dynamicRequestTree;</span>
            <span class="s1">if </span><span class="s0">(dynamicRequestTreeChild !== </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s3">// Something in the child tree is dynamic.</span>
                <span class="s0">needsDynamicRequest = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s0">dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild;</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">dynamicRequestTreeChildren[parallelRouteKey] = taskChildRoute;</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s3">// The child didn't change. We can use the prefetched router state.</span>
            <span class="s0">patchedRouterStateChildren[parallelRouteKey] = newRouterStateChild;</span>
            <span class="s0">dynamicRequestTreeChildren[parallelRouteKey] = newRouterStateChild;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(taskChildren === </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s3">// No new tasks were spawned.</span>
        <span class="s1">return null</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">newCacheNode = {</span>
        <span class="s0">lazyData: </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">rsc: oldCacheNode.rsc,</span>
        <span class="s3">// We intentionally aren't updating the prefetchRsc field, since this node</span>
        <span class="s3">// is already part of the current tree, because it would be weird for</span>
        <span class="s3">// prefetch data to be newer than the final data. It probably won't ever be</span>
        <span class="s3">// observable anyway, but it could happen if the segment is unmounted then</span>
        <span class="s3">// mounted again, because LayoutRouter will momentarily switch to rendering</span>
        <span class="s3">// prefetchRsc, via useDeferredValue.</span>
        <span class="s0">prefetchRsc: oldCacheNode.prefetchRsc,</span>
        <span class="s0">head: oldCacheNode.head,</span>
        <span class="s0">prefetchHead: oldCacheNode.prefetchHead,</span>
        <span class="s0">loading: oldCacheNode.loading,</span>
        <span class="s3">// Everything is cloned except for the children, which we computed above.</span>
        <span class="s0">parallelRoutes: prefetchParallelRoutes,</span>
        <span class="s0">navigatedAt</span>
    <span class="s0">};</span>
    <span class="s1">return </span><span class="s0">{</span>
        <span class="s3">// Return a cloned copy of the router state with updated children.</span>
        <span class="s0">route: patchRouterStateWithNewChildren(newRouterState, patchedRouterStateChildren),</span>
        <span class="s0">node: newCacheNode,</span>
        <span class="s0">dynamicRequestTree: needsDynamicRequest ? patchRouterStateWithNewChildren(newRouterState, dynamicRequestTreeChildren) : </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">children: taskChildren</span>
    <span class="s0">};</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">beginRenderingNewRouteTree(navigatedAt, oldRouterState, newRouterState, existingCacheNode, didFindRootLayout, prefetchData, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult) {</span>
    <span class="s1">if </span><span class="s0">(!didFindRootLayout) {</span>
        <span class="s3">// The route tree changed before we reached a layout. (The highest-level</span>
        <span class="s3">// layout in a route tree is referred to as the &quot;root&quot; layout.) This could</span>
        <span class="s3">// mean that we're navigating between two different root layouts. When this</span>
        <span class="s3">// happens, we perform a full-page (MPA-style) navigation.</span>
        <span class="s3">//</span>
        <span class="s3">// However, the algorithm for deciding where to start rendering a route</span>
        <span class="s3">// (i.e. the one performed in order to reach this function) is stricter</span>
        <span class="s3">// than the one used to detect a change in the root layout. So just because</span>
        <span class="s3">// we're re-rendering a segment outside of the root layout does not mean we</span>
        <span class="s3">// should trigger a full-page navigation.</span>
        <span class="s3">//</span>
        <span class="s3">// Specifically, we handle dynamic parameters differently: two segments are</span>
        <span class="s3">// considered the same even if their parameter values are different.</span>
        <span class="s3">//</span>
        <span class="s3">// Refer to isNavigatingToNewRootLayout for details.</span>
        <span class="s3">//</span>
        <span class="s3">// Note that we only have to perform this extra traversal if we didn't</span>
        <span class="s3">// already discover a root layout in the part of the tree that is unchanged.</span>
        <span class="s3">// In the common case, this branch is skipped completely.</span>
        <span class="s1">if </span><span class="s0">(oldRouterState === undefined || (</span><span class="s4">0</span><span class="s0">, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(oldRouterState, newRouterState)) {</span>
            <span class="s3">// The root layout changed. Perform a full-page navigation.</span>
            <span class="s1">return </span><span class="s0">MPA_NAVIGATION_TASK;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">createCacheNodeOnNavigation(navigatedAt, newRouterState, existingCacheNode, prefetchData, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">createCacheNodeOnNavigation(navigatedAt, routerState, existingCacheNode, prefetchData, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult) {</span>
    <span class="s3">// Same traversal as updateCacheNodeNavigation, but we switch to this path</span>
    <span class="s3">// once we reach the part of the tree that was not in the previous route. We</span>
    <span class="s3">// don't need to diff against the old tree, we just need to create a new one.</span>
    <span class="s3">// The head is assigned to every leaf segment delivered by the server. Based</span>
    <span class="s3">// on corresponding logic in fill-lazy-items-till-leaf-with-head.ts</span>
    <span class="s1">const </span><span class="s0">routerStateChildren = routerState[</span><span class="s4">1</span><span class="s0">];</span>
    <span class="s1">const </span><span class="s0">isLeafSegment = Object.keys(routerStateChildren).length === </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s3">// Even we're rendering inside the &quot;new&quot; part of the target tree, we may have</span>
    <span class="s3">// a locally cached segment that we can reuse. This may come from either 1)</span>
    <span class="s3">// the CacheNode tree, which lives in React state and is populated by previous</span>
    <span class="s3">// navigations; or 2) the prefetch cache, which is a separate cache that is</span>
    <span class="s3">// populated by prefetches.</span>
    <span class="s1">let </span><span class="s0">rsc;</span>
    <span class="s1">let </span><span class="s0">loading;</span>
    <span class="s1">let </span><span class="s0">head;</span>
    <span class="s1">let </span><span class="s0">cacheNodeNavigatedAt;</span>
    <span class="s1">if </span><span class="s0">(existingCacheNode !== undefined &amp;&amp; </span><span class="s3">// DYNAMIC_STALETIME_MS defaults to 0, but it can be increased using</span>
    <span class="s3">// the experimental.staleTimes.dynamic config. When set, we'll avoid</span>
    <span class="s3">// refetching dynamic data if it was fetched within the given threshold.</span>
    <span class="s0">existingCacheNode.navigatedAt + _prefetchcacheutils.DYNAMIC_STALETIME_MS &gt; navigatedAt) {</span>
        <span class="s3">// We have an existing CacheNode for this segment, and it's not stale. We</span>
        <span class="s3">// should reuse it rather than request a new one.</span>
        <span class="s0">rsc = existingCacheNode.rsc;</span>
        <span class="s0">loading = existingCacheNode.loading;</span>
        <span class="s0">head = existingCacheNode.head;</span>
        <span class="s3">// Don't update the navigatedAt timestamp, since we're reusing stale data.</span>
        <span class="s0">cacheNodeNavigatedAt = existingCacheNode.navigatedAt;</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(prefetchData !== </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s3">// There's no existing CacheNode for this segment, but we do have prefetch</span>
        <span class="s3">// data. If the prefetch data is fully static (i.e. does not contain any</span>
        <span class="s3">// dynamic holes), we don't need to request it from the server.</span>
        <span class="s0">rsc = prefetchData[</span><span class="s4">1</span><span class="s0">];</span>
        <span class="s0">loading = prefetchData[</span><span class="s4">3</span><span class="s0">];</span>
        <span class="s0">head = isLeafSegment ? possiblyPartialPrefetchHead : </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s3">// Even though we're accessing the data from the prefetch cache, this is</span>
        <span class="s3">// conceptually a new segment, not a reused one. So we should update the</span>
        <span class="s3">// navigatedAt timestamp.</span>
        <span class="s0">cacheNodeNavigatedAt = navigatedAt;</span>
        <span class="s1">const </span><span class="s0">isPrefetchRscPartial = prefetchData[</span><span class="s4">4</span><span class="s0">];</span>
        <span class="s1">if </span><span class="s0">(isPrefetchRscPartial || </span><span class="s3">// Check if the head is partial (only relevant if this is a leaf segment)</span>
        <span class="s0">isPrefetchHeadPartial &amp;&amp; isLeafSegment) {</span>
            <span class="s3">// We only have partial data from this segment. Like missing segments, we</span>
            <span class="s3">// must request the full data from the server.</span>
            <span class="s1">return </span><span class="s0">spawnPendingTask(navigatedAt, routerState, prefetchData, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s3">// The prefetch data is fully static, so we can omit it from the</span>
        <span class="s3">// navigation request.</span>
        <span class="s0">}</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s3">// There's no prefetch for this segment. Everything from this point will be</span>
        <span class="s3">// requested from the server, even if there are static children below it.</span>
        <span class="s3">// Create a terminal task node that will later be fulfilled by</span>
        <span class="s3">// server response.</span>
        <span class="s1">return </span><span class="s0">spawnPendingTask(navigatedAt, routerState, </span><span class="s1">null</span><span class="s0">, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult);</span>
    <span class="s0">}</span>
    <span class="s3">// We already have a full segment we can render, so we don't need to request a</span>
    <span class="s3">// new one from the server. Keep traversing down the tree until we reach</span>
    <span class="s3">// something that requires a dynamic request.</span>
    <span class="s1">const </span><span class="s0">prefetchDataChildren = prefetchData !== </span><span class="s1">null </span><span class="s0">? prefetchData[</span><span class="s4">2</span><span class="s0">] : </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">taskChildren = </span><span class="s1">new </span><span class="s0">Map();</span>
    <span class="s1">const </span><span class="s0">existingCacheNodeChildren = existingCacheNode !== undefined ? existingCacheNode.parallelRoutes : </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">cacheNodeChildren = </span><span class="s1">new </span><span class="s0">Map(existingCacheNodeChildren);</span>
    <span class="s1">let </span><span class="s0">dynamicRequestTreeChildren = {};</span>
    <span class="s1">let </span><span class="s0">needsDynamicRequest = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(isLeafSegment) {</span>
        <span class="s3">// The segment path of every leaf segment (i.e. page) is collected into</span>
        <span class="s3">// a result array. This is used by the LayoutRouter to scroll to ensure that</span>
        <span class="s3">// new pages are visible after a navigation.</span>
        <span class="s3">// TODO: We should use a string to represent the segment path instead of</span>
        <span class="s3">// an array. We already use a string representation for the path when</span>
        <span class="s3">// accessing the Segment Cache, so we can use the same one.</span>
        <span class="s0">scrollableSegmentsResult.push(segmentPath);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">parallelRouteKey </span><span class="s1">in </span><span class="s0">routerStateChildren){</span>
            <span class="s1">const </span><span class="s0">routerStateChild = routerStateChildren[parallelRouteKey];</span>
            <span class="s1">const </span><span class="s0">prefetchDataChild = prefetchDataChildren !== </span><span class="s1">null </span><span class="s0">? prefetchDataChildren[parallelRouteKey] : </span><span class="s1">null</span><span class="s0">;</span>
            <span class="s1">const </span><span class="s0">existingSegmentMapChild = existingCacheNodeChildren !== </span><span class="s1">null </span><span class="s0">? existingCacheNodeChildren.get(parallelRouteKey) : undefined;</span>
            <span class="s1">const </span><span class="s0">segmentChild = routerStateChild[</span><span class="s4">0</span><span class="s0">];</span>
            <span class="s1">const </span><span class="s0">segmentPathChild = segmentPath.concat([</span>
                <span class="s0">parallelRouteKey,</span>
                <span class="s0">segmentChild</span>
            <span class="s0">]);</span>
            <span class="s1">const </span><span class="s0">segmentKeyChild = (</span><span class="s4">0</span><span class="s0">, _createroutercachekey.createRouterCacheKey)(segmentChild);</span>
            <span class="s1">const </span><span class="s0">existingCacheNodeChild = existingSegmentMapChild !== undefined ? existingSegmentMapChild.get(segmentKeyChild) : undefined;</span>
            <span class="s1">const </span><span class="s0">taskChild = createCacheNodeOnNavigation(navigatedAt, routerStateChild, existingCacheNodeChild, prefetchDataChild, possiblyPartialPrefetchHead, isPrefetchHeadPartial, segmentPathChild, scrollableSegmentsResult);</span>
            <span class="s0">taskChildren.set(parallelRouteKey, taskChild);</span>
            <span class="s1">const </span><span class="s0">dynamicRequestTreeChild = taskChild.dynamicRequestTree;</span>
            <span class="s1">if </span><span class="s0">(dynamicRequestTreeChild !== </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s3">// Something in the child tree is dynamic.</span>
                <span class="s0">needsDynamicRequest = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s0">dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild;</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">dynamicRequestTreeChildren[parallelRouteKey] = routerStateChild;</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">newCacheNodeChild = taskChild.node;</span>
            <span class="s1">if </span><span class="s0">(newCacheNodeChild !== </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s1">const </span><span class="s0">newSegmentMapChild = </span><span class="s1">new </span><span class="s0">Map();</span>
                <span class="s0">newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild);</span>
                <span class="s0">cacheNodeChildren.set(parallelRouteKey, newSegmentMapChild);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">{</span>
        <span class="s3">// Since we're inside a new route tree, unlike the</span>
        <span class="s3">// `updateCacheNodeOnNavigation` path, the router state on the children</span>
        <span class="s3">// tasks is always the same as the router state we pass in. So we don't need</span>
        <span class="s3">// to clone/modify it.</span>
        <span class="s0">route: routerState,</span>
        <span class="s0">node: {</span>
            <span class="s0">lazyData: </span><span class="s1">null</span><span class="s0">,</span>
            <span class="s3">// Since this segment is already full, we don't need to use the</span>
            <span class="s3">// `prefetchRsc` field.</span>
            <span class="s0">rsc,</span>
            <span class="s0">prefetchRsc: </span><span class="s1">null</span><span class="s0">,</span>
            <span class="s0">head,</span>
            <span class="s0">prefetchHead: </span><span class="s1">null</span><span class="s0">,</span>
            <span class="s0">loading,</span>
            <span class="s0">parallelRoutes: cacheNodeChildren,</span>
            <span class="s0">navigatedAt: cacheNodeNavigatedAt</span>
        <span class="s0">},</span>
        <span class="s0">dynamicRequestTree: needsDynamicRequest ? patchRouterStateWithNewChildren(routerState, dynamicRequestTreeChildren) : </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">children: taskChildren</span>
    <span class="s0">};</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">patchRouterStateWithNewChildren(baseRouterState, newChildren) {</span>
    <span class="s1">const </span><span class="s0">clone = [</span>
        <span class="s0">baseRouterState[</span><span class="s4">0</span><span class="s0">],</span>
        <span class="s0">newChildren</span>
    <span class="s0">];</span>
    <span class="s3">// Based on equivalent logic in apply-router-state-patch-to-tree, but should</span>
    <span class="s3">// confirm whether we need to copy all of these fields. Not sure the server</span>
    <span class="s3">// ever sends, e.g. the refetch marker.</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s4">2 </span><span class="s1">in </span><span class="s0">baseRouterState) {</span>
        <span class="s0">clone[</span><span class="s4">2</span><span class="s0">] = baseRouterState[</span><span class="s4">2</span><span class="s0">];</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s4">3 </span><span class="s1">in </span><span class="s0">baseRouterState) {</span>
        <span class="s0">clone[</span><span class="s4">3</span><span class="s0">] = baseRouterState[</span><span class="s4">3</span><span class="s0">];</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s4">4 </span><span class="s1">in </span><span class="s0">baseRouterState) {</span>
        <span class="s0">clone[</span><span class="s4">4</span><span class="s0">] = baseRouterState[</span><span class="s4">4</span><span class="s0">];</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">clone;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">spawnPendingTask(navigatedAt, routerState, prefetchData, prefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult) {</span>
    <span class="s3">// Create a task that will later be fulfilled by data from the server.</span>
    <span class="s3">// Clone the prefetched route tree and the `refetch` marker to it. We'll send</span>
    <span class="s3">// this to the server so it knows where to start rendering.</span>
    <span class="s1">const </span><span class="s0">dynamicRequestTree = patchRouterStateWithNewChildren(routerState, routerState[</span><span class="s4">1</span><span class="s0">]);</span>
    <span class="s0">dynamicRequestTree[</span><span class="s4">3</span><span class="s0">] = </span><span class="s2">'refetch'</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">newTask = {</span>
        <span class="s0">route: routerState,</span>
        <span class="s3">// Corresponds to the part of the route that will be rendered on the server.</span>
        <span class="s0">node: createPendingCacheNode(navigatedAt, routerState, prefetchData, prefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult),</span>
        <span class="s3">// Because this is non-null, and it gets propagated up through the parent</span>
        <span class="s3">// tasks, the root task will know that it needs to perform a server request.</span>
        <span class="s0">dynamicRequestTree,</span>
        <span class="s0">children: </span><span class="s1">null</span>
    <span class="s0">};</span>
    <span class="s1">return </span><span class="s0">newTask;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">spawnReusedTask(reusedRouterState) {</span>
    <span class="s3">// Create a task that reuses an existing segment, e.g. when reusing</span>
    <span class="s3">// the current active segment in place of a default route.</span>
    <span class="s1">return </span><span class="s0">{</span>
        <span class="s0">route: reusedRouterState,</span>
        <span class="s0">node: </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">dynamicRequestTree: </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">children: </span><span class="s1">null</span>
    <span class="s0">};</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">listenForDynamicRequest(task, responsePromise) {</span>
    <span class="s0">responsePromise.then((param)=&gt;{</span>
        <span class="s1">let </span><span class="s0">{ flightData } = param;</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">flightData === </span><span class="s2">'string'</span><span class="s0">) {</span>
            <span class="s3">// Happens when navigating to page in `pages` from `app`. We shouldn't</span>
            <span class="s3">// get here because should have already handled this during</span>
            <span class="s3">// the prefetch.</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">normalizedFlightData of flightData){</span>
            <span class="s1">const </span><span class="s0">{ segmentPath, tree: serverRouterState, seedData: dynamicData, head: dynamicHead } = normalizedFlightData;</span>
            <span class="s1">if </span><span class="s0">(!dynamicData) {</span>
                <span class="s1">continue</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s0">writeDynamicDataIntoPendingTask(task, segmentPath, serverRouterState, dynamicData, dynamicHead);</span>
        <span class="s0">}</span>
        <span class="s3">// Now that we've exhausted all the data we received from the server, if</span>
        <span class="s3">// there are any remaining pending tasks in the tree, abort them now.</span>
        <span class="s3">// If there's any missing data, it will trigger a lazy fetch.</span>
        <span class="s0">abortTask(task, </span><span class="s1">null</span><span class="s0">);</span>
    <span class="s0">}, (error)=&gt;{</span>
        <span class="s3">// This will trigger an error during render</span>
        <span class="s0">abortTask(task, error);</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">writeDynamicDataIntoPendingTask(rootTask, segmentPath, serverRouterState, dynamicData, dynamicHead) {</span>
    <span class="s3">// The data sent by the server represents only a subtree of the app. We need</span>
    <span class="s3">// to find the part of the task tree that matches the server response, and</span>
    <span class="s3">// fulfill it using the dynamic data.</span>
    <span class="s3">//</span>
    <span class="s3">// segmentPath represents the parent path of subtree. It's a repeating pattern</span>
    <span class="s3">// of parallel route key and segment:</span>
    <span class="s3">//</span>
    <span class="s3">//   [string, Segment, string, Segment, string, Segment, ...]</span>
    <span class="s3">//</span>
    <span class="s3">// Iterate through the path and finish any tasks that match this payload.</span>
    <span class="s1">let </span><span class="s0">task = rootTask;</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; segmentPath.length; i += </span><span class="s4">2</span><span class="s0">){</span>
        <span class="s1">const </span><span class="s0">parallelRouteKey = segmentPath[i];</span>
        <span class="s1">const </span><span class="s0">segment = segmentPath[i + </span><span class="s4">1</span><span class="s0">];</span>
        <span class="s1">const </span><span class="s0">taskChildren = task.children;</span>
        <span class="s1">if </span><span class="s0">(taskChildren !== </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s1">const </span><span class="s0">taskChild = taskChildren.get(parallelRouteKey);</span>
            <span class="s1">if </span><span class="s0">(taskChild !== undefined) {</span>
                <span class="s1">const </span><span class="s0">taskSegment = taskChild.route[</span><span class="s4">0</span><span class="s0">];</span>
                <span class="s1">if </span><span class="s0">((</span><span class="s4">0</span><span class="s0">, _matchsegments.matchSegment)(segment, taskSegment)) {</span>
                    <span class="s3">// Found a match for this task. Keep traversing down the task tree.</span>
                    <span class="s0">task = taskChild;</span>
                    <span class="s1">continue</span><span class="s0">;</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s3">// We didn't find a child task that matches the server data. Exit. We won't</span>
        <span class="s3">// abort the task, though, because a different FlightDataPath may be able to</span>
        <span class="s3">// fulfill it (see loop in listenForDynamicRequest). We only abort tasks</span>
        <span class="s3">// once we've run out of data.</span>
        <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">finishTaskUsingDynamicDataPayload(task, serverRouterState, dynamicData, dynamicHead);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">finishTaskUsingDynamicDataPayload(task, serverRouterState, dynamicData, dynamicHead) {</span>
    <span class="s1">if </span><span class="s0">(task.dynamicRequestTree === </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s3">// Everything in this subtree is already complete. Bail out.</span>
        <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s3">// dynamicData may represent a larger subtree than the task. Before we can</span>
    <span class="s3">// finish the task, we need to line them up.</span>
    <span class="s1">const </span><span class="s0">taskChildren = task.children;</span>
    <span class="s1">const </span><span class="s0">taskNode = task.node;</span>
    <span class="s1">if </span><span class="s0">(taskChildren === </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s3">// We've reached the leaf node of the pending task. The server data tree</span>
        <span class="s3">// lines up the pending Cache Node tree. We can now switch to the</span>
        <span class="s3">// normal algorithm.</span>
        <span class="s1">if </span><span class="s0">(taskNode !== </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s0">finishPendingCacheNode(taskNode, task.route, serverRouterState, dynamicData, dynamicHead);</span>
            <span class="s3">// Set this to null to indicate that this task is now complete.</span>
            <span class="s0">task.dynamicRequestTree = </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s3">// The server returned more data than we need to finish the task. Skip over</span>
    <span class="s3">// the extra segments until we reach the leaf task node.</span>
    <span class="s1">const </span><span class="s0">serverChildren = serverRouterState[</span><span class="s4">1</span><span class="s0">];</span>
    <span class="s1">const </span><span class="s0">dynamicDataChildren = dynamicData[</span><span class="s4">2</span><span class="s0">];</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">parallelRouteKey </span><span class="s1">in </span><span class="s0">serverRouterState){</span>
        <span class="s1">const </span><span class="s0">serverRouterStateChild = serverChildren[parallelRouteKey];</span>
        <span class="s1">const </span><span class="s0">dynamicDataChild = dynamicDataChildren[parallelRouteKey];</span>
        <span class="s1">const </span><span class="s0">taskChild = taskChildren.get(parallelRouteKey);</span>
        <span class="s1">if </span><span class="s0">(taskChild !== undefined) {</span>
            <span class="s1">const </span><span class="s0">taskSegment = taskChild.route[</span><span class="s4">0</span><span class="s0">];</span>
            <span class="s1">if </span><span class="s0">((</span><span class="s4">0</span><span class="s0">, _matchsegments.matchSegment)(serverRouterStateChild[</span><span class="s4">0</span><span class="s0">], taskSegment) &amp;&amp; dynamicDataChild !== </span><span class="s1">null </span><span class="s0">&amp;&amp; dynamicDataChild !== undefined) {</span>
                <span class="s3">// Found a match for this task. Keep traversing down the task tree.</span>
                <span class="s1">return </span><span class="s0">finishTaskUsingDynamicDataPayload(taskChild, serverRouterStateChild, dynamicDataChild, dynamicHead);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s3">// We didn't find a child task that matches the server data. We won't abort</span>
    <span class="s3">// the task, though, because a different FlightDataPath may be able to</span>
    <span class="s3">// fulfill it (see loop in listenForDynamicRequest). We only abort tasks</span>
    <span class="s3">// once we've run out of data.</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">createPendingCacheNode(navigatedAt, routerState, prefetchData, prefetchHead, isPrefetchHeadPartial, segmentPath, scrollableSegmentsResult) {</span>
    <span class="s1">const </span><span class="s0">routerStateChildren = routerState[</span><span class="s4">1</span><span class="s0">];</span>
    <span class="s1">const </span><span class="s0">prefetchDataChildren = prefetchData !== </span><span class="s1">null </span><span class="s0">? prefetchData[</span><span class="s4">2</span><span class="s0">] : </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">parallelRoutes = </span><span class="s1">new </span><span class="s0">Map();</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">parallelRouteKey </span><span class="s1">in </span><span class="s0">routerStateChildren){</span>
        <span class="s1">const </span><span class="s0">routerStateChild = routerStateChildren[parallelRouteKey];</span>
        <span class="s1">const </span><span class="s0">prefetchDataChild = prefetchDataChildren !== </span><span class="s1">null </span><span class="s0">? prefetchDataChildren[parallelRouteKey] : </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s1">const </span><span class="s0">segmentChild = routerStateChild[</span><span class="s4">0</span><span class="s0">];</span>
        <span class="s1">const </span><span class="s0">segmentPathChild = segmentPath.concat([</span>
            <span class="s0">parallelRouteKey,</span>
            <span class="s0">segmentChild</span>
        <span class="s0">]);</span>
        <span class="s1">const </span><span class="s0">segmentKeyChild = (</span><span class="s4">0</span><span class="s0">, _createroutercachekey.createRouterCacheKey)(segmentChild);</span>
        <span class="s1">const </span><span class="s0">newCacheNodeChild = createPendingCacheNode(navigatedAt, routerStateChild, prefetchDataChild === undefined ? </span><span class="s1">null </span><span class="s0">: prefetchDataChild, prefetchHead, isPrefetchHeadPartial, segmentPathChild, scrollableSegmentsResult);</span>
        <span class="s1">const </span><span class="s0">newSegmentMapChild = </span><span class="s1">new </span><span class="s0">Map();</span>
        <span class="s0">newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild);</span>
        <span class="s0">parallelRoutes.set(parallelRouteKey, newSegmentMapChild);</span>
    <span class="s0">}</span>
    <span class="s3">// The head is assigned to every leaf segment delivered by the server. Based</span>
    <span class="s3">// on corresponding logic in fill-lazy-items-till-leaf-with-head.ts</span>
    <span class="s1">const </span><span class="s0">isLeafSegment = parallelRoutes.size === </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(isLeafSegment) {</span>
        <span class="s3">// The segment path of every leaf segment (i.e. page) is collected into</span>
        <span class="s3">// a result array. This is used by the LayoutRouter to scroll to ensure that</span>
        <span class="s3">// new pages are visible after a navigation.</span>
        <span class="s3">// TODO: We should use a string to represent the segment path instead of</span>
        <span class="s3">// an array. We already use a string representation for the path when</span>
        <span class="s3">// accessing the Segment Cache, so we can use the same one.</span>
        <span class="s0">scrollableSegmentsResult.push(segmentPath);</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">maybePrefetchRsc = prefetchData !== </span><span class="s1">null </span><span class="s0">? prefetchData[</span><span class="s4">1</span><span class="s0">] : </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">maybePrefetchLoading = prefetchData !== </span><span class="s1">null </span><span class="s0">? prefetchData[</span><span class="s4">3</span><span class="s0">] : </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s1">return </span><span class="s0">{</span>
        <span class="s0">lazyData: </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">parallelRoutes: parallelRoutes,</span>
        <span class="s0">prefetchRsc: maybePrefetchRsc !== undefined ? maybePrefetchRsc : </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">prefetchHead: isLeafSegment ? prefetchHead : [</span>
            <span class="s1">null</span><span class="s0">,</span>
            <span class="s1">null</span>
        <span class="s0">],</span>
        <span class="s3">// TODO: Technically, a loading boundary could contain dynamic data. We must</span>
        <span class="s3">// have separate `loading` and `prefetchLoading` fields to handle this, like</span>
        <span class="s3">// we do for the segment data and head.</span>
        <span class="s0">loading: maybePrefetchLoading !== undefined ? maybePrefetchLoading : </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s3">// Create a deferred promise. This will be fulfilled once the dynamic</span>
        <span class="s3">// response is received from the server.</span>
        <span class="s0">rsc: createDeferredRsc(),</span>
        <span class="s0">head: isLeafSegment ? createDeferredRsc() : </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">navigatedAt</span>
    <span class="s0">};</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">finishPendingCacheNode(cacheNode, taskState, serverState, dynamicData, dynamicHead) {</span>
    <span class="s3">// Writes a dynamic response into an existing Cache Node tree. This does _not_</span>
    <span class="s3">// create a new tree, it updates the existing tree in-place. So it must follow</span>
    <span class="s3">// the Suspense rules of cache safety  it can resolve pending promises, but</span>
    <span class="s3">// it cannot overwrite existing data. It can add segments to the tree (because</span>
    <span class="s3">// a missing segment will cause the layout router to suspend).</span>
    <span class="s3">// but it cannot delete them.</span>
    <span class="s3">//</span>
    <span class="s3">// We must resolve every promise in the tree, or else it will suspend</span>
    <span class="s3">// indefinitely. If we did not receive data for a segment, we will resolve its</span>
    <span class="s3">// data promise to `null` to trigger a lazy fetch during render.</span>
    <span class="s1">const </span><span class="s0">taskStateChildren = taskState[</span><span class="s4">1</span><span class="s0">];</span>
    <span class="s1">const </span><span class="s0">serverStateChildren = serverState[</span><span class="s4">1</span><span class="s0">];</span>
    <span class="s1">const </span><span class="s0">dataChildren = dynamicData[</span><span class="s4">2</span><span class="s0">];</span>
    <span class="s3">// The router state that we traverse the tree with (taskState) is the same one</span>
    <span class="s3">// that we used to construct the pending Cache Node tree. That way we're sure</span>
    <span class="s3">// to resolve all the pending promises.</span>
    <span class="s1">const </span><span class="s0">parallelRoutes = cacheNode.parallelRoutes;</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">parallelRouteKey </span><span class="s1">in </span><span class="s0">taskStateChildren){</span>
        <span class="s1">const </span><span class="s0">taskStateChild = taskStateChildren[parallelRouteKey];</span>
        <span class="s1">const </span><span class="s0">serverStateChild = serverStateChildren[parallelRouteKey];</span>
        <span class="s1">const </span><span class="s0">dataChild = dataChildren[parallelRouteKey];</span>
        <span class="s1">const </span><span class="s0">segmentMapChild = parallelRoutes.get(parallelRouteKey);</span>
        <span class="s1">const </span><span class="s0">taskSegmentChild = taskStateChild[</span><span class="s4">0</span><span class="s0">];</span>
        <span class="s1">const </span><span class="s0">taskSegmentKeyChild = (</span><span class="s4">0</span><span class="s0">, _createroutercachekey.createRouterCacheKey)(taskSegmentChild);</span>
        <span class="s1">const </span><span class="s0">cacheNodeChild = segmentMapChild !== undefined ? segmentMapChild.get(taskSegmentKeyChild) : undefined;</span>
        <span class="s1">if </span><span class="s0">(cacheNodeChild !== undefined) {</span>
            <span class="s1">if </span><span class="s0">(serverStateChild !== undefined &amp;&amp; (</span><span class="s4">0</span><span class="s0">, _matchsegments.matchSegment)(taskSegmentChild, serverStateChild[</span><span class="s4">0</span><span class="s0">])) {</span>
                <span class="s1">if </span><span class="s0">(dataChild !== undefined &amp;&amp; dataChild !== </span><span class="s1">null</span><span class="s0">) {</span>
                    <span class="s3">// This is the happy path. Recursively update all the children.</span>
                    <span class="s0">finishPendingCacheNode(cacheNodeChild, taskStateChild, serverStateChild, dataChild, dynamicHead);</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                    <span class="s3">// The server never returned data for this segment. Trigger a lazy</span>
                    <span class="s3">// fetch during render. This shouldn't happen because the Route Tree</span>
                    <span class="s3">// and the Seed Data tree sent by the server should always be the same</span>
                    <span class="s3">// shape when part of the same server response.</span>
                    <span class="s0">abortPendingCacheNode(taskStateChild, cacheNodeChild, </span><span class="s1">null</span><span class="s0">);</span>
                <span class="s0">}</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s3">// The server never returned data for this segment. Trigger a lazy</span>
                <span class="s3">// fetch during render.</span>
                <span class="s0">abortPendingCacheNode(taskStateChild, cacheNodeChild, </span><span class="s1">null</span><span class="s0">);</span>
            <span class="s0">}</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s3">// The server response matches what was expected to receive, but there's</span>
        <span class="s3">// no matching Cache Node in the task tree. This is a bug in the</span>
        <span class="s3">// implementation because we should have created a node for every</span>
        <span class="s3">// segment in the tree that's associated with this task.</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s3">// Use the dynamic data from the server to fulfill the deferred RSC promise</span>
    <span class="s3">// on the Cache Node.</span>
    <span class="s1">const </span><span class="s0">rsc = cacheNode.rsc;</span>
    <span class="s1">const </span><span class="s0">dynamicSegmentData = dynamicData[</span><span class="s4">1</span><span class="s0">];</span>
    <span class="s1">if </span><span class="s0">(rsc === </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s3">// This is a lazy cache node. We can overwrite it. This is only safe</span>
        <span class="s3">// because we know that the LayoutRouter suspends if `rsc` is `null`.</span>
        <span class="s0">cacheNode.rsc = dynamicSegmentData;</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(isDeferredRsc(rsc)) {</span>
        <span class="s3">// This is a deferred RSC promise. We can fulfill it with the data we just</span>
        <span class="s3">// received from the server. If it was already resolved by a different</span>
        <span class="s3">// navigation, then this does nothing because we can't overwrite data.</span>
        <span class="s0">rsc.resolve(dynamicSegmentData);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
    <span class="s3">// This is not a deferred RSC promise, nor is it empty, so it must have</span>
    <span class="s3">// been populated by a different navigation. We must not overwrite it.</span>
    <span class="s0">}</span>
    <span class="s3">// Check if this is a leaf segment. If so, it will have a `head` property with</span>
    <span class="s3">// a pending promise that needs to be resolved with the dynamic head from</span>
    <span class="s3">// the server.</span>
    <span class="s1">const </span><span class="s0">head = cacheNode.head;</span>
    <span class="s1">if </span><span class="s0">(isDeferredRsc(head)) {</span>
        <span class="s0">head.resolve(dynamicHead);</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">abortTask(task, error) {</span>
    <span class="s1">const </span><span class="s0">cacheNode = task.node;</span>
    <span class="s1">if </span><span class="s0">(cacheNode === </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s3">// This indicates the task is already complete.</span>
        <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">taskChildren = task.children;</span>
    <span class="s1">if </span><span class="s0">(taskChildren === </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s3">// Reached the leaf task node. This is the root of a pending cache</span>
        <span class="s3">// node tree.</span>
        <span class="s0">abortPendingCacheNode(task.route, cacheNode, error);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s3">// This is an intermediate task node. Keep traversing until we reach a</span>
        <span class="s3">// task node with no children. That will be the root of the cache node tree</span>
        <span class="s3">// that needs to be resolved.</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">taskChild of taskChildren.values()){</span>
            <span class="s0">abortTask(taskChild, error);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s3">// Set this to null to indicate that this task is now complete.</span>
    <span class="s0">task.dynamicRequestTree = </span><span class="s1">null</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">abortPendingCacheNode(routerState, cacheNode, error) {</span>
    <span class="s3">// For every pending segment in the tree, resolve its `rsc` promise to `null`</span>
    <span class="s3">// to trigger a lazy fetch during render.</span>
    <span class="s3">//</span>
    <span class="s3">// Or, if an error object is provided, it will error instead.</span>
    <span class="s1">const </span><span class="s0">routerStateChildren = routerState[</span><span class="s4">1</span><span class="s0">];</span>
    <span class="s1">const </span><span class="s0">parallelRoutes = cacheNode.parallelRoutes;</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">parallelRouteKey </span><span class="s1">in </span><span class="s0">routerStateChildren){</span>
        <span class="s1">const </span><span class="s0">routerStateChild = routerStateChildren[parallelRouteKey];</span>
        <span class="s1">const </span><span class="s0">segmentMapChild = parallelRoutes.get(parallelRouteKey);</span>
        <span class="s1">if </span><span class="s0">(segmentMapChild === undefined) {</span>
            <span class="s1">continue</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">segmentChild = routerStateChild[</span><span class="s4">0</span><span class="s0">];</span>
        <span class="s1">const </span><span class="s0">segmentKeyChild = (</span><span class="s4">0</span><span class="s0">, _createroutercachekey.createRouterCacheKey)(segmentChild);</span>
        <span class="s1">const </span><span class="s0">cacheNodeChild = segmentMapChild.get(segmentKeyChild);</span>
        <span class="s1">if </span><span class="s0">(cacheNodeChild !== undefined) {</span>
            <span class="s0">abortPendingCacheNode(routerStateChild, cacheNodeChild, error);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s3">// This shouldn't happen because we're traversing the same tree that was</span>
        <span class="s3">// used to construct the cache nodes in the first place.</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">rsc = cacheNode.rsc;</span>
    <span class="s1">if </span><span class="s0">(isDeferredRsc(rsc)) {</span>
        <span class="s1">if </span><span class="s0">(error === </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s3">// This will trigger a lazy fetch during render.</span>
            <span class="s0">rsc.resolve(</span><span class="s1">null</span><span class="s0">);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s3">// This will trigger an error during rendering.</span>
            <span class="s0">rsc.reject(error);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s3">// Check if this is a leaf segment. If so, it will have a `head` property with</span>
    <span class="s3">// a pending promise that needs to be resolved. If an error was provided, we</span>
    <span class="s3">// will not resolve it with an error, since this is rendered at the root of</span>
    <span class="s3">// the app. We want the segment to error, not the entire app.</span>
    <span class="s1">const </span><span class="s0">head = cacheNode.head;</span>
    <span class="s1">if </span><span class="s0">(isDeferredRsc(head)) {</span>
        <span class="s0">head.resolve(</span><span class="s1">null</span><span class="s0">);</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">updateCacheNodeOnPopstateRestoration(oldCacheNode, routerState) {</span>
    <span class="s3">// A popstate navigation reads data from the local cache. It does not issue</span>
    <span class="s3">// new network requests (unless the cache entries have been evicted). So, we</span>
    <span class="s3">// update the cache to drop the prefetch data for any segment whose dynamic</span>
    <span class="s3">// data was already received. This prevents an unnecessary flash back to PPR</span>
    <span class="s3">// state during a back/forward navigation.</span>
    <span class="s3">//</span>
    <span class="s3">// This function clones the entire cache node tree and sets the `prefetchRsc`</span>
    <span class="s3">// field to `null` to prevent it from being rendered. We can't mutate the node</span>
    <span class="s3">// in place because this is a concurrent data structure.</span>
    <span class="s1">const </span><span class="s0">routerStateChildren = routerState[</span><span class="s4">1</span><span class="s0">];</span>
    <span class="s1">const </span><span class="s0">oldParallelRoutes = oldCacheNode.parallelRoutes;</span>
    <span class="s1">const </span><span class="s0">newParallelRoutes = </span><span class="s1">new </span><span class="s0">Map(oldParallelRoutes);</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">parallelRouteKey </span><span class="s1">in </span><span class="s0">routerStateChildren){</span>
        <span class="s1">const </span><span class="s0">routerStateChild = routerStateChildren[parallelRouteKey];</span>
        <span class="s1">const </span><span class="s0">segmentChild = routerStateChild[</span><span class="s4">0</span><span class="s0">];</span>
        <span class="s1">const </span><span class="s0">segmentKeyChild = (</span><span class="s4">0</span><span class="s0">, _createroutercachekey.createRouterCacheKey)(segmentChild);</span>
        <span class="s1">const </span><span class="s0">oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey);</span>
        <span class="s1">if </span><span class="s0">(oldSegmentMapChild !== undefined) {</span>
            <span class="s1">const </span><span class="s0">oldCacheNodeChild = oldSegmentMapChild.get(segmentKeyChild);</span>
            <span class="s1">if </span><span class="s0">(oldCacheNodeChild !== undefined) {</span>
                <span class="s1">const </span><span class="s0">newCacheNodeChild = updateCacheNodeOnPopstateRestoration(oldCacheNodeChild, routerStateChild);</span>
                <span class="s1">const </span><span class="s0">newSegmentMapChild = </span><span class="s1">new </span><span class="s0">Map(oldSegmentMapChild);</span>
                <span class="s0">newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild);</span>
                <span class="s0">newParallelRoutes.set(parallelRouteKey, newSegmentMapChild);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s3">// Only show prefetched data if the dynamic data is still pending.</span>
    <span class="s3">//</span>
    <span class="s3">// Tehnically, what we're actually checking is whether the dynamic network</span>
    <span class="s3">// response was received. But since it's a streaming response, this does not</span>
    <span class="s3">// mean that all the dynamic data has fully streamed in. It just means that</span>
    <span class="s3">// _some_ of the dynamic data was received. But as a heuristic, we assume that</span>
    <span class="s3">// the rest dynamic data will stream in quickly, so it's still better to skip</span>
    <span class="s3">// the prefetch state.</span>
    <span class="s1">const </span><span class="s0">rsc = oldCacheNode.rsc;</span>
    <span class="s1">const </span><span class="s0">shouldUsePrefetch = isDeferredRsc(rsc) &amp;&amp; rsc.status === </span><span class="s2">'pending'</span><span class="s0">;</span>
    <span class="s1">return </span><span class="s0">{</span>
        <span class="s0">lazyData: </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">rsc,</span>
        <span class="s0">head: oldCacheNode.head,</span>
        <span class="s0">prefetchHead: shouldUsePrefetch ? oldCacheNode.prefetchHead : [</span>
            <span class="s1">null</span><span class="s0">,</span>
            <span class="s1">null</span>
        <span class="s0">],</span>
        <span class="s0">prefetchRsc: shouldUsePrefetch ? oldCacheNode.prefetchRsc : </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">loading: oldCacheNode.loading,</span>
        <span class="s3">// These are the cloned children we computed above</span>
        <span class="s0">parallelRoutes: newParallelRoutes,</span>
        <span class="s0">navigatedAt: oldCacheNode.navigatedAt</span>
    <span class="s0">};</span>
<span class="s0">}</span>
<span class="s1">const </span><span class="s0">DEFERRED = Symbol();</span>
<span class="s3">// This type exists to distinguish a DeferredRsc from a Flight promise. It's a</span>
<span class="s3">// compromise to avoid adding an extra field on every Cache Node, which would be</span>
<span class="s3">// awkward because the pre-PPR parts of codebase would need to account for it,</span>
<span class="s3">// too. We can remove it once type Cache Node type is more settled.</span>
<span class="s1">function </span><span class="s0">isDeferredRsc(value) {</span>
    <span class="s1">return </span><span class="s0">value &amp;&amp; value.tag === DEFERRED;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">createDeferredRsc() {</span>
    <span class="s1">let </span><span class="s0">resolve;</span>
    <span class="s1">let </span><span class="s0">reject;</span>
    <span class="s1">const </span><span class="s0">pendingRsc = </span><span class="s1">new </span><span class="s0">Promise((res, rej)=&gt;{</span>
        <span class="s0">resolve = res;</span>
        <span class="s0">reject = rej;</span>
    <span class="s0">});</span>
    <span class="s0">pendingRsc.status = </span><span class="s2">'pending'</span><span class="s0">;</span>
    <span class="s0">pendingRsc.resolve = (value)=&gt;{</span>
        <span class="s1">if </span><span class="s0">(pendingRsc.status === </span><span class="s2">'pending'</span><span class="s0">) {</span>
            <span class="s1">const </span><span class="s0">fulfilledRsc = pendingRsc;</span>
            <span class="s0">fulfilledRsc.status = </span><span class="s2">'fulfilled'</span><span class="s0">;</span>
            <span class="s0">fulfilledRsc.value = value;</span>
            <span class="s0">resolve(value);</span>
        <span class="s0">}</span>
    <span class="s0">};</span>
    <span class="s0">pendingRsc.reject = (error)=&gt;{</span>
        <span class="s1">if </span><span class="s0">(pendingRsc.status === </span><span class="s2">'pending'</span><span class="s0">) {</span>
            <span class="s1">const </span><span class="s0">rejectedRsc = pendingRsc;</span>
            <span class="s0">rejectedRsc.status = </span><span class="s2">'rejected'</span><span class="s0">;</span>
            <span class="s0">rejectedRsc.reason = error;</span>
            <span class="s0">reject(error);</span>
        <span class="s0">}</span>
    <span class="s0">};</span>
    <span class="s0">pendingRsc.tag = DEFERRED;</span>
    <span class="s1">return </span><span class="s0">pendingRsc;</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=ppr-navigations.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/clear-cache-node-data-for-segment-path.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;clearCacheNodeDataForSegmentPath&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">clearCacheNodeDataForSegmentPath;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_flightdatahelpers = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/flight-data-helpers.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_createroutercachekey = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">clearCacheNodeDataForSegmentPath(newCache, existingCache, flightSegmentPath) {</span>
    <span class="s1">const </span><span class="s0">isLastEntry = flightSegmentPath.length &lt;= </span><span class="s4">2</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">[parallelRouteKey, segment] = flightSegmentPath;</span>
    <span class="s1">const </span><span class="s0">cacheKey = (</span><span class="s4">0</span><span class="s0">, _createroutercachekey.createRouterCacheKey)(segment);</span>
    <span class="s1">const </span><span class="s0">existingChildSegmentMap = existingCache.parallelRoutes.get(parallelRouteKey);</span>
    <span class="s1">let </span><span class="s0">childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey);</span>
    <span class="s1">if </span><span class="s0">(!childSegmentMap || childSegmentMap === existingChildSegmentMap) {</span>
        <span class="s0">childSegmentMap = </span><span class="s1">new </span><span class="s0">Map(existingChildSegmentMap);</span>
        <span class="s0">newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap);</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">existingChildCacheNode = existingChildSegmentMap == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: existingChildSegmentMap.get(cacheKey);</span>
    <span class="s1">let </span><span class="s0">childCacheNode = childSegmentMap.get(cacheKey);</span>
    <span class="s3">// In case of last segment start off the fetch at this level and don't copy further down.</span>
    <span class="s1">if </span><span class="s0">(isLastEntry) {</span>
        <span class="s1">if </span><span class="s0">(!childCacheNode || !childCacheNode.lazyData || childCacheNode === existingChildCacheNode) {</span>
            <span class="s0">childSegmentMap.set(cacheKey, {</span>
                <span class="s0">lazyData: </span><span class="s1">null</span><span class="s0">,</span>
                <span class="s0">rsc: </span><span class="s1">null</span><span class="s0">,</span>
                <span class="s0">prefetchRsc: </span><span class="s1">null</span><span class="s0">,</span>
                <span class="s0">head: </span><span class="s1">null</span><span class="s0">,</span>
                <span class="s0">prefetchHead: </span><span class="s1">null</span><span class="s0">,</span>
                <span class="s0">parallelRoutes: </span><span class="s1">new </span><span class="s0">Map(),</span>
                <span class="s0">loading: </span><span class="s1">null</span><span class="s0">,</span>
                <span class="s0">navigatedAt: -</span><span class="s4">1</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(!childCacheNode || !existingChildCacheNode) {</span>
        <span class="s3">// Start fetch in the place where the existing cache doesn't have the data yet.</span>
        <span class="s1">if </span><span class="s0">(!childCacheNode) {</span>
            <span class="s0">childSegmentMap.set(cacheKey, {</span>
                <span class="s0">lazyData: </span><span class="s1">null</span><span class="s0">,</span>
                <span class="s0">rsc: </span><span class="s1">null</span><span class="s0">,</span>
                <span class="s0">prefetchRsc: </span><span class="s1">null</span><span class="s0">,</span>
                <span class="s0">head: </span><span class="s1">null</span><span class="s0">,</span>
                <span class="s0">prefetchHead: </span><span class="s1">null</span><span class="s0">,</span>
                <span class="s0">parallelRoutes: </span><span class="s1">new </span><span class="s0">Map(),</span>
                <span class="s0">loading: </span><span class="s1">null</span><span class="s0">,</span>
                <span class="s0">navigatedAt: -</span><span class="s4">1</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(childCacheNode === existingChildCacheNode) {</span>
        <span class="s0">childCacheNode = {</span>
            <span class="s0">lazyData: childCacheNode.lazyData,</span>
            <span class="s0">rsc: childCacheNode.rsc,</span>
            <span class="s0">prefetchRsc: childCacheNode.prefetchRsc,</span>
            <span class="s0">head: childCacheNode.head,</span>
            <span class="s0">prefetchHead: childCacheNode.prefetchHead,</span>
            <span class="s0">parallelRoutes: </span><span class="s1">new </span><span class="s0">Map(childCacheNode.parallelRoutes),</span>
            <span class="s0">loading: childCacheNode.loading</span>
        <span class="s0">};</span>
        <span class="s0">childSegmentMap.set(cacheKey, childCacheNode);</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">clearCacheNodeDataForSegmentPath(childCacheNode, existingChildCacheNode, (</span><span class="s4">0</span><span class="s0">, _flightdatahelpers.getNextFlightSegmentPath)(flightSegmentPath));</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=clear-cache-node-data-for-segment-path.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/aliased-prefetch-navigations.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s0">addSearchParamsToPageSegments: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">handleAliasedPrefetchEntry: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s0">addSearchParamsToPageSegments: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">addSearchParamsToPageSegments;</span>
    <span class="s0">},</span>
    <span class="s0">handleAliasedPrefetchEntry: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">handleAliasedPrefetchEntry;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_segment = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/segment.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_approuter = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/app-router.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_applyrouterstatepatchtotree = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_createhreffromurl = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_createroutercachekey = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_fillcachewithnewsubtreedata = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/fill-cache-with-new-subtree-data.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_handlemutable = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/handle-mutable.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_navigatereducer = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">handleAliasedPrefetchEntry(navigatedAt, state, flightData, url, mutable) {</span>
    <span class="s1">let </span><span class="s0">currentTree = state.tree;</span>
    <span class="s1">let </span><span class="s0">currentCache = state.cache;</span>
    <span class="s1">const </span><span class="s0">href = (</span><span class="s4">0</span><span class="s0">, _createhreffromurl.createHrefFromUrl)(url);</span>
    <span class="s1">let </span><span class="s0">applied;</span>
    <span class="s1">let </span><span class="s0">scrollableSegments = [];</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">flightData === </span><span class="s2">'string'</span><span class="s0">) {</span>
        <span class="s1">return false</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">normalizedFlightData of flightData){</span>
        <span class="s3">// If the segment doesn't have a loading component, we don't need to do anything.</span>
        <span class="s1">if </span><span class="s0">(!hasLoadingComponentInSeedData(normalizedFlightData.seedData)) {</span>
            <span class="s1">continue</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">let </span><span class="s0">treePatch = normalizedFlightData.tree;</span>
        <span class="s3">// Segments are keyed by searchParams (e.g. __PAGE__?{&quot;foo&quot;:&quot;bar&quot;}). We might return a less specific, param-less entry,</span>
        <span class="s3">// so we ensure that the final tree contains the correct searchParams (reflected in the URL) are provided in the updated FlightRouterState tree.</span>
        <span class="s3">// We only do this on the first read, as otherwise we'd be overwriting the searchParams that may have already been set</span>
        <span class="s0">treePatch = addSearchParamsToPageSegments(treePatch, Object.fromEntries(url.searchParams));</span>
        <span class="s1">const </span><span class="s0">{ seedData, isRootRender, pathToSegment } = normalizedFlightData;</span>
        <span class="s3">// TODO-APP: remove ''</span>
        <span class="s1">const </span><span class="s0">flightSegmentPathWithLeadingEmpty = [</span>
            <span class="s2">''</span><span class="s0">,</span>
            <span class="s0">...pathToSegment</span>
        <span class="s0">];</span>
        <span class="s3">// Segments are keyed by searchParams (e.g. __PAGE__?{&quot;foo&quot;:&quot;bar&quot;}). We might return a less specific, param-less entry,</span>
        <span class="s3">// so we ensure that the final tree contains the correct searchParams (reflected in the URL) are provided in the updated FlightRouterState tree.</span>
        <span class="s3">// We only do this on the first read, as otherwise we'd be overwriting the searchParams that may have already been set</span>
        <span class="s0">treePatch = addSearchParamsToPageSegments(treePatch, Object.fromEntries(url.searchParams));</span>
        <span class="s1">let </span><span class="s0">newTree = (</span><span class="s4">0</span><span class="s0">, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(flightSegmentPathWithLeadingEmpty, currentTree, treePatch, href);</span>
        <span class="s1">const </span><span class="s0">newCache = (</span><span class="s4">0</span><span class="s0">, _approuter.createEmptyCacheNode)();</span>
        <span class="s3">// The prefetch cache entry was aliased -- this signals that we only fill in the cache with the</span>
        <span class="s3">// loading state and not the actual parallel route seed data.</span>
        <span class="s1">if </span><span class="s0">(isRootRender &amp;&amp; seedData) {</span>
            <span class="s3">// Fill in the cache with the new loading / rsc data</span>
            <span class="s1">const </span><span class="s0">rsc = seedData[</span><span class="s4">1</span><span class="s0">];</span>
            <span class="s1">const </span><span class="s0">loading = seedData[</span><span class="s4">3</span><span class="s0">];</span>
            <span class="s0">newCache.loading = loading;</span>
            <span class="s0">newCache.rsc = rsc;</span>
            <span class="s3">// Construct a new tree and apply the aliased loading state for each parallel route</span>
            <span class="s0">fillNewTreeWithOnlyLoadingSegments(navigatedAt, newCache, currentCache, treePatch, seedData);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s3">// Copy rsc for the root node of the cache.</span>
            <span class="s0">newCache.rsc = currentCache.rsc;</span>
            <span class="s0">newCache.prefetchRsc = currentCache.prefetchRsc;</span>
            <span class="s0">newCache.loading = currentCache.loading;</span>
            <span class="s0">newCache.parallelRoutes = </span><span class="s1">new </span><span class="s0">Map(currentCache.parallelRoutes);</span>
            <span class="s3">// copy the loading state only into the leaf node (the part that changed)</span>
            <span class="s0">(</span><span class="s4">0</span><span class="s0">, _fillcachewithnewsubtreedata.fillCacheWithNewSubTreeDataButOnlyLoading)(navigatedAt, newCache, currentCache, normalizedFlightData);</span>
        <span class="s0">}</span>
        <span class="s3">// If we don't have an updated tree, there's no reason to update the cache, as the tree</span>
        <span class="s3">// dictates what cache nodes to render.</span>
        <span class="s1">if </span><span class="s0">(newTree) {</span>
            <span class="s0">currentTree = newTree;</span>
            <span class="s0">currentCache = newCache;</span>
            <span class="s0">applied = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">subSegment of (</span><span class="s4">0</span><span class="s0">, _navigatereducer.generateSegmentsFromPatch)(treePatch)){</span>
            <span class="s1">const </span><span class="s0">scrollableSegmentPath = [</span>
                <span class="s0">...normalizedFlightData.pathToSegment,</span>
                <span class="s0">...subSegment</span>
            <span class="s0">];</span>
            <span class="s3">// Filter out the __DEFAULT__ paths as they shouldn't be scrolled to in this case.</span>
            <span class="s1">if </span><span class="s0">(scrollableSegmentPath[scrollableSegmentPath.length - </span><span class="s4">1</span><span class="s0">] !== _segment.DEFAULT_SEGMENT_KEY) {</span>
                <span class="s0">scrollableSegments.push(scrollableSegmentPath);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(!applied) {</span>
        <span class="s1">return false</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s0">mutable.patchedTree = currentTree;</span>
    <span class="s0">mutable.cache = currentCache;</span>
    <span class="s0">mutable.canonicalUrl = href;</span>
    <span class="s0">mutable.hashFragment = url.hash;</span>
    <span class="s0">mutable.scrollableSegments = scrollableSegments;</span>
    <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _handlemutable.handleMutable)(state, mutable);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">hasLoadingComponentInSeedData(seedData) {</span>
    <span class="s1">if </span><span class="s0">(!seedData) </span><span class="s1">return false</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">parallelRoutes = seedData[</span><span class="s4">2</span><span class="s0">];</span>
    <span class="s1">const </span><span class="s0">loading = seedData[</span><span class="s4">3</span><span class="s0">];</span>
    <span class="s1">if </span><span class="s0">(loading) {</span>
        <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in </span><span class="s0">parallelRoutes){</span>
        <span class="s1">if </span><span class="s0">(hasLoadingComponentInSeedData(parallelRoutes[key])) {</span>
            <span class="s1">return true</span><span class="s0">;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">return false</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">fillNewTreeWithOnlyLoadingSegments(navigatedAt, newCache, existingCache, routerState, cacheNodeSeedData) {</span>
    <span class="s1">const </span><span class="s0">isLastSegment = Object.keys(routerState[</span><span class="s4">1</span><span class="s0">]).length === </span><span class="s4">0</span><span class="s0">;</span>
    <span class="s1">if </span><span class="s0">(isLastSegment) {</span>
        <span class="s1">return</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in </span><span class="s0">routerState[</span><span class="s4">1</span><span class="s0">]){</span>
        <span class="s1">const </span><span class="s0">parallelRouteState = routerState[</span><span class="s4">1</span><span class="s0">][key];</span>
        <span class="s1">const </span><span class="s0">segmentForParallelRoute = parallelRouteState[</span><span class="s4">0</span><span class="s0">];</span>
        <span class="s1">const </span><span class="s0">cacheKey = (</span><span class="s4">0</span><span class="s0">, _createroutercachekey.createRouterCacheKey)(segmentForParallelRoute);</span>
        <span class="s1">const </span><span class="s0">parallelSeedData = cacheNodeSeedData !== </span><span class="s1">null </span><span class="s0">&amp;&amp; cacheNodeSeedData[</span><span class="s4">2</span><span class="s0">][key] !== undefined ? cacheNodeSeedData[</span><span class="s4">2</span><span class="s0">][key] : </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">newCacheNode;</span>
        <span class="s1">if </span><span class="s0">(parallelSeedData !== </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s3">// New data was sent from the server.</span>
            <span class="s1">const </span><span class="s0">rsc = parallelSeedData[</span><span class="s4">1</span><span class="s0">];</span>
            <span class="s1">const </span><span class="s0">loading = parallelSeedData[</span><span class="s4">3</span><span class="s0">];</span>
            <span class="s0">newCacheNode = {</span>
                <span class="s0">lazyData: </span><span class="s1">null</span><span class="s0">,</span>
                <span class="s3">// copy the layout but null the page segment as that's not meant to be used</span>
                <span class="s0">rsc: segmentForParallelRoute.includes(_segment.PAGE_SEGMENT_KEY) ? </span><span class="s1">null </span><span class="s0">: rsc,</span>
                <span class="s0">prefetchRsc: </span><span class="s1">null</span><span class="s0">,</span>
                <span class="s0">head: </span><span class="s1">null</span><span class="s0">,</span>
                <span class="s0">prefetchHead: </span><span class="s1">null</span><span class="s0">,</span>
                <span class="s0">parallelRoutes: </span><span class="s1">new </span><span class="s0">Map(),</span>
                <span class="s0">loading,</span>
                <span class="s0">navigatedAt</span>
            <span class="s0">};</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s3">// No data available for this node. This will trigger a lazy fetch</span>
            <span class="s3">// during render.</span>
            <span class="s0">newCacheNode = {</span>
                <span class="s0">lazyData: </span><span class="s1">null</span><span class="s0">,</span>
                <span class="s0">rsc: </span><span class="s1">null</span><span class="s0">,</span>
                <span class="s0">prefetchRsc: </span><span class="s1">null</span><span class="s0">,</span>
                <span class="s0">head: </span><span class="s1">null</span><span class="s0">,</span>
                <span class="s0">prefetchHead: </span><span class="s1">null</span><span class="s0">,</span>
                <span class="s0">parallelRoutes: </span><span class="s1">new </span><span class="s0">Map(),</span>
                <span class="s0">loading: </span><span class="s1">null</span><span class="s0">,</span>
                <span class="s0">navigatedAt: -</span><span class="s4">1</span>
            <span class="s0">};</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">existingParallelRoutes = newCache.parallelRoutes.get(key);</span>
        <span class="s1">if </span><span class="s0">(existingParallelRoutes) {</span>
            <span class="s0">existingParallelRoutes.set(cacheKey, newCacheNode);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">newCache.parallelRoutes.set(key, </span><span class="s1">new </span><span class="s0">Map([</span>
                <span class="s0">[</span>
                    <span class="s0">cacheKey,</span>
                    <span class="s0">newCacheNode</span>
                <span class="s0">]</span>
            <span class="s0">]));</span>
        <span class="s0">}</span>
        <span class="s0">fillNewTreeWithOnlyLoadingSegments(navigatedAt, newCacheNode, existingCache, parallelRouteState, parallelSeedData);</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">addSearchParamsToPageSegments(flightRouterState, searchParams) {</span>
    <span class="s1">const </span><span class="s0">[segment, parallelRoutes, ...rest] = flightRouterState;</span>
    <span class="s3">// If it's a page segment, modify the segment by adding search params</span>
    <span class="s1">if </span><span class="s0">(segment.includes(_segment.PAGE_SEGMENT_KEY)) {</span>
        <span class="s1">const </span><span class="s0">newSegment = (</span><span class="s4">0</span><span class="s0">, _segment.addSearchParamsIfPageSegment)(segment, searchParams);</span>
        <span class="s1">return </span><span class="s0">[</span>
            <span class="s0">newSegment,</span>
            <span class="s0">parallelRoutes,</span>
            <span class="s0">...rest</span>
        <span class="s0">];</span>
    <span class="s0">}</span>
    <span class="s3">// Otherwise, recurse through the parallel routes and return a new tree</span>
    <span class="s1">const </span><span class="s0">updatedParallelRoutes = {};</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">[key, parallelRoute] of Object.entries(parallelRoutes)){</span>
        <span class="s0">updatedParallelRoutes[key] = addSearchParamsToPageSegments(parallelRoute, searchParams);</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">[</span>
        <span class="s0">segment,</span>
        <span class="s0">updatedParallelRoutes,</span>
        <span class="s0">...rest</span>
    <span class="s0">];</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=aliased-prefetch-navigations.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s0">generateSegmentsFromPatch: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">handleExternalUrl: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">navigateReducer: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s0">generateSegmentsFromPatch: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">generateSegmentsFromPatch;</span>
    <span class="s0">},</span>
    <span class="s0">handleExternalUrl: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">handleExternalUrl;</span>
    <span class="s0">},</span>
    <span class="s0">navigateReducer: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">navigateReducer;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_fetchserverresponse = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/fetch-server-response.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_createhreffromurl = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_invalidatecachebelowflightsegmentpath = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/invalidate-cache-below-flight-segmentpath.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_applyrouterstatepatchtotree = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_shouldhardnavigate = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/should-hard-navigate.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_isnavigatingtonewrootlayout = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_routerreducertypes = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_handlemutable = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/handle-mutable.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_applyflightdata = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/apply-flight-data.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_prefetchreducer = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_approuter = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/app-router.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_segment = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/segment.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_pprnavigations = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/ppr-navigations.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_prefetchcacheutils = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_clearcachenodedataforsegmentpath = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/clear-cache-node-data-for-segment-path.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_aliasedprefetchnavigations = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/aliased-prefetch-navigations.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_segmentcache = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/segment-cache.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">handleExternalUrl(state, mutable, url, pendingPush) {</span>
    <span class="s0">mutable.mpaNavigation = </span><span class="s1">true</span><span class="s0">;</span>
    <span class="s0">mutable.canonicalUrl = url;</span>
    <span class="s0">mutable.pendingPush = pendingPush;</span>
    <span class="s0">mutable.scrollableSegments = undefined;</span>
    <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _handlemutable.handleMutable)(state, mutable);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">generateSegmentsFromPatch(flightRouterPatch) {</span>
    <span class="s1">const </span><span class="s0">segments = [];</span>
    <span class="s1">const </span><span class="s0">[segment, parallelRoutes] = flightRouterPatch;</span>
    <span class="s1">if </span><span class="s0">(Object.keys(parallelRoutes).length === </span><span class="s4">0</span><span class="s0">) {</span>
        <span class="s1">return </span><span class="s0">[</span>
            <span class="s0">[</span>
                <span class="s0">segment</span>
            <span class="s0">]</span>
        <span class="s0">];</span>
    <span class="s0">}</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">[parallelRouteKey, parallelRoute] of Object.entries(parallelRoutes)){</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">childSegment of generateSegmentsFromPatch(parallelRoute)){</span>
            <span class="s3">// If the segment is empty, it means we are at the root of the tree</span>
            <span class="s1">if </span><span class="s0">(segment === </span><span class="s2">''</span><span class="s0">) {</span>
                <span class="s0">segments.push([</span>
                    <span class="s0">parallelRouteKey,</span>
                    <span class="s0">...childSegment</span>
                <span class="s0">]);</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">segments.push([</span>
                    <span class="s0">segment,</span>
                    <span class="s0">parallelRouteKey,</span>
                    <span class="s0">...childSegment</span>
                <span class="s0">]);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">segments;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">triggerLazyFetchForLeafSegments(newCache, currentCache, flightSegmentPath, treePatch) {</span>
    <span class="s1">let </span><span class="s0">appliedPatch = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s0">newCache.rsc = currentCache.rsc;</span>
    <span class="s0">newCache.prefetchRsc = currentCache.prefetchRsc;</span>
    <span class="s0">newCache.loading = currentCache.loading;</span>
    <span class="s0">newCache.parallelRoutes = </span><span class="s1">new </span><span class="s0">Map(currentCache.parallelRoutes);</span>
    <span class="s1">const </span><span class="s0">segmentPathsToFill = generateSegmentsFromPatch(treePatch).map((segment)=&gt;[</span>
            <span class="s0">...flightSegmentPath,</span>
            <span class="s0">...segment</span>
        <span class="s0">]);</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">segmentPaths of segmentPathsToFill){</span>
        <span class="s0">(</span><span class="s4">0</span><span class="s0">, _clearcachenodedataforsegmentpath.clearCacheNodeDataForSegmentPath)(newCache, currentCache, segmentPaths);</span>
        <span class="s0">appliedPatch = </span><span class="s1">true</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">appliedPatch;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">handleNavigationResult(url, state, mutable, pendingPush, result) {</span>
    <span class="s1">switch</span><span class="s0">(result.tag){</span>
        <span class="s1">case </span><span class="s0">_segmentcache.NavigationResultTag.MPA:</span>
            <span class="s0">{</span>
                <span class="s3">// Perform an MPA navigation.</span>
                <span class="s1">const </span><span class="s0">newUrl = result.data;</span>
                <span class="s1">return </span><span class="s0">handleExternalUrl(state, mutable, newUrl, pendingPush);</span>
            <span class="s0">}</span>
        <span class="s1">case </span><span class="s0">_segmentcache.NavigationResultTag.NoOp:</span>
            <span class="s0">{</span>
                <span class="s3">// The server responded with no change to the current page. However, if</span>
                <span class="s3">// the URL changed, we still need to update that.</span>
                <span class="s1">const </span><span class="s0">newCanonicalUrl = result.data.canonicalUrl;</span>
                <span class="s0">mutable.canonicalUrl = newCanonicalUrl;</span>
                <span class="s3">// Check if the only thing that changed was the hash fragment.</span>
                <span class="s1">const </span><span class="s0">oldUrl = </span><span class="s1">new </span><span class="s0">URL(state.canonicalUrl, url);</span>
                <span class="s1">const </span><span class="s0">onlyHashChange = </span><span class="s3">// navigations are always same-origin.</span>
                <span class="s0">url.pathname === oldUrl.pathname &amp;&amp; url.search === oldUrl.search &amp;&amp; url.hash !== oldUrl.hash;</span>
                <span class="s1">if </span><span class="s0">(onlyHashChange) {</span>
                    <span class="s3">// The only updated part of the URL is the hash.</span>
                    <span class="s0">mutable.onlyHashChange = </span><span class="s1">true</span><span class="s0">;</span>
                    <span class="s0">mutable.shouldScroll = result.data.shouldScroll;</span>
                    <span class="s0">mutable.hashFragment = url.hash;</span>
                    <span class="s3">// Setting this to an empty array triggers a scroll for all new and</span>
                    <span class="s3">// updated segments. See `ScrollAndFocusHandler` for more details.</span>
                    <span class="s0">mutable.scrollableSegments = [];</span>
                <span class="s0">}</span>
                <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _handlemutable.handleMutable)(state, mutable);</span>
            <span class="s0">}</span>
        <span class="s1">case </span><span class="s0">_segmentcache.NavigationResultTag.Success:</span>
            <span class="s0">{</span>
                <span class="s3">// Received a new result.</span>
                <span class="s0">mutable.cache = result.data.cacheNode;</span>
                <span class="s0">mutable.patchedTree = result.data.flightRouterState;</span>
                <span class="s0">mutable.canonicalUrl = result.data.canonicalUrl;</span>
                <span class="s0">mutable.scrollableSegments = result.data.scrollableSegments;</span>
                <span class="s0">mutable.shouldScroll = result.data.shouldScroll;</span>
                <span class="s0">mutable.hashFragment = result.data.hash;</span>
                <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _handlemutable.handleMutable)(state, mutable);</span>
            <span class="s0">}</span>
        <span class="s1">case </span><span class="s0">_segmentcache.NavigationResultTag.Async:</span>
            <span class="s0">{</span>
                <span class="s1">return </span><span class="s0">result.data.then((asyncResult)=&gt;handleNavigationResult(url, state, mutable, pendingPush, asyncResult), </span><span class="s3">// TODO: This matches the current behavior but we need to do something</span>
                <span class="s3">// better here if the network fails.</span>
                <span class="s0">()=&gt;{</span>
                    <span class="s1">return </span><span class="s0">state;</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
        <span class="s1">default</span><span class="s0">:</span>
            <span class="s0">{</span>
                <span class="s0">result;</span>
                <span class="s1">return </span><span class="s0">state;</span>
            <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">navigateReducer(state, action) {</span>
    <span class="s1">const </span><span class="s0">{ url, isExternalUrl, navigateType, shouldScroll, allowAliasing } = action;</span>
    <span class="s1">const </span><span class="s0">mutable = {};</span>
    <span class="s1">const </span><span class="s0">{ hash } = url;</span>
    <span class="s1">const </span><span class="s0">href = (</span><span class="s4">0</span><span class="s0">, _createhreffromurl.createHrefFromUrl)(url);</span>
    <span class="s1">const </span><span class="s0">pendingPush = navigateType === </span><span class="s2">'push'</span><span class="s0">;</span>
    <span class="s3">// we want to prune the prefetch cache on every navigation to avoid it growing too large</span>
    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _prefetchcacheutils.prunePrefetchCache)(state.prefetchCache);</span>
    <span class="s0">mutable.preserveCustomHistoryState = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s0">mutable.pendingPush = pendingPush;</span>
    <span class="s1">if </span><span class="s0">(isExternalUrl) {</span>
        <span class="s1">return </span><span class="s0">handleExternalUrl(state, mutable, url.toString(), pendingPush);</span>
    <span class="s0">}</span>
    <span class="s3">// Handles case where `&lt;meta http-equiv=&quot;refresh&quot;&gt;` tag is present,</span>
    <span class="s3">// which will trigger an MPA navigation.</span>
    <span class="s1">if </span><span class="s0">(document.getElementById(</span><span class="s2">'__next-page-redirect'</span><span class="s0">)) {</span>
        <span class="s1">return </span><span class="s0">handleExternalUrl(state, mutable, href, pendingPush);</span>
    <span class="s0">}</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) </span><span class="s3">//TURBOPACK unreachable</span>
    <span class="s0">;</span>
    <span class="s1">const </span><span class="s0">prefetchValues = (</span><span class="s4">0</span><span class="s0">, _prefetchcacheutils.getOrCreatePrefetchCacheEntry)({</span>
        <span class="s0">url,</span>
        <span class="s0">nextUrl: state.nextUrl,</span>
        <span class="s0">tree: state.tree,</span>
        <span class="s0">prefetchCache: state.prefetchCache,</span>
        <span class="s0">allowAliasing</span>
    <span class="s0">});</span>
    <span class="s1">const </span><span class="s0">{ treeAtTimeOfPrefetch, data } = prefetchValues;</span>
    <span class="s0">_prefetchreducer.prefetchQueue.bump(data);</span>
    <span class="s1">return </span><span class="s0">data.then((param)=&gt;{</span>
        <span class="s1">let </span><span class="s0">{ flightData, canonicalUrl: canonicalUrlOverride, postponed } = param;</span>
        <span class="s1">const </span><span class="s0">navigatedAt = Date.now();</span>
        <span class="s1">let </span><span class="s0">isFirstRead = </span><span class="s1">false</span><span class="s0">;</span>
        <span class="s3">// we only want to mark this once</span>
        <span class="s1">if </span><span class="s0">(!prefetchValues.lastUsedTime) {</span>
            <span class="s3">// important: we should only mark the cache node as dirty after we unsuspend from the call above</span>
            <span class="s0">prefetchValues.lastUsedTime = navigatedAt;</span>
            <span class="s0">isFirstRead = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(prefetchValues.aliased) {</span>
            <span class="s3">// When alias is enabled, search param may not be included in the canonicalUrl.</span>
            <span class="s3">// But we want to set url to canonicalUrl so that we use redirected path for fetching dynamic data.</span>
            <span class="s1">const </span><span class="s0">urlWithCanonicalPathname = </span><span class="s1">new </span><span class="s0">URL(url.href);</span>
            <span class="s1">if </span><span class="s0">(canonicalUrlOverride) {</span>
                <span class="s0">urlWithCanonicalPathname.pathname = canonicalUrlOverride.pathname;</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">result = (</span><span class="s4">0</span><span class="s0">, _aliasedprefetchnavigations.handleAliasedPrefetchEntry)(navigatedAt, state, flightData, urlWithCanonicalPathname, mutable);</span>
            <span class="s3">// We didn't return new router state because we didn't apply the aliased entry for some reason.</span>
            <span class="s3">// We'll re-invoke the navigation handler but ensure that we don't attempt to use the aliased entry. This</span>
            <span class="s3">// will create an on-demand prefetch entry.</span>
            <span class="s1">if </span><span class="s0">(result === </span><span class="s1">false</span><span class="s0">) {</span>
                <span class="s1">return </span><span class="s0">navigateReducer(state, {</span>
                    <span class="s0">...action,</span>
                    <span class="s0">allowAliasing: </span><span class="s1">false</span>
                <span class="s0">});</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">result;</span>
        <span class="s0">}</span>
        <span class="s3">// Handle case when navigating to page in `pages` from `app`</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">flightData === </span><span class="s2">'string'</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">handleExternalUrl(state, mutable, flightData, pendingPush);</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">updatedCanonicalUrl = canonicalUrlOverride ? (</span><span class="s4">0</span><span class="s0">, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : href;</span>
        <span class="s1">const </span><span class="s0">onlyHashChange = !!hash &amp;&amp; state.canonicalUrl.split(</span><span class="s2">'#'</span><span class="s0">, </span><span class="s4">1</span><span class="s0">)[</span><span class="s4">0</span><span class="s0">] === updatedCanonicalUrl.split(</span><span class="s2">'#'</span><span class="s0">, </span><span class="s4">1</span><span class="s0">)[</span><span class="s4">0</span><span class="s0">];</span>
        <span class="s3">// If only the hash has changed, the server hasn't sent us any new data. We can just update</span>
        <span class="s3">// the mutable properties responsible for URL and scroll handling and return early.</span>
        <span class="s1">if </span><span class="s0">(onlyHashChange) {</span>
            <span class="s0">mutable.onlyHashChange = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">mutable.canonicalUrl = updatedCanonicalUrl;</span>
            <span class="s0">mutable.shouldScroll = shouldScroll;</span>
            <span class="s0">mutable.hashFragment = hash;</span>
            <span class="s0">mutable.scrollableSegments = [];</span>
            <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _handlemutable.handleMutable)(state, mutable);</span>
        <span class="s0">}</span>
        <span class="s1">let </span><span class="s0">currentTree = state.tree;</span>
        <span class="s1">let </span><span class="s0">currentCache = state.cache;</span>
        <span class="s1">let </span><span class="s0">scrollableSegments = [];</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">normalizedFlightData of flightData){</span>
            <span class="s1">const </span><span class="s0">{ pathToSegment: flightSegmentPath, seedData, head, isHeadPartial, isRootRender } = normalizedFlightData;</span>
            <span class="s1">let </span><span class="s0">treePatch = normalizedFlightData.tree;</span>
            <span class="s3">// TODO-APP: remove ''</span>
            <span class="s1">const </span><span class="s0">flightSegmentPathWithLeadingEmpty = [</span>
                <span class="s2">''</span><span class="s0">,</span>
                <span class="s0">...flightSegmentPath</span>
            <span class="s0">];</span>
            <span class="s3">// Create new tree based on the flightSegmentPath and router state patch</span>
            <span class="s1">let </span><span class="s0">newTree = (</span><span class="s4">0</span><span class="s0">, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(flightSegmentPathWithLeadingEmpty, currentTree, treePatch, href);</span>
            <span class="s3">// If the tree patch can't be applied to the current tree then we use the tree at time of prefetch</span>
            <span class="s3">// TODO-APP: This should instead fill in the missing pieces in `currentTree` with the data from `treeAtTimeOfPrefetch`, then apply the patch.</span>
            <span class="s1">if </span><span class="s0">(newTree === </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s0">newTree = (</span><span class="s4">0</span><span class="s0">, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)(flightSegmentPathWithLeadingEmpty, treeAtTimeOfPrefetch, treePatch, href);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">(newTree !== </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s3">// will send back a static response that's rendered from</span>
                <span class="s3">// the root. If for some reason it doesn't, we fall back to the</span>
                <span class="s3">// non-PPR implementation.</span>
                <span class="s3">// TODO: We should get rid of the else branch and do all navigations</span>
                <span class="s3">// via startPPRNavigation. The current structure is just</span>
                <span class="s3">// an incremental step.</span>
                <span class="s0">seedData &amp;&amp; isRootRender &amp;&amp; postponed) {</span>
                    <span class="s1">const </span><span class="s0">task = (</span><span class="s4">0</span><span class="s0">, _pprnavigations.startPPRNavigation)(navigatedAt, currentCache, currentTree, treePatch, seedData, head, isHeadPartial, </span><span class="s1">false</span><span class="s0">, scrollableSegments);</span>
                    <span class="s1">if </span><span class="s0">(task !== </span><span class="s1">null</span><span class="s0">) {</span>
                        <span class="s1">if </span><span class="s0">(task.route === </span><span class="s1">null</span><span class="s0">) {</span>
                            <span class="s3">// Detected a change to the root layout. Perform an full-</span>
                            <span class="s3">// page navigation.</span>
                            <span class="s1">return </span><span class="s0">handleExternalUrl(state, mutable, href, pendingPush);</span>
                        <span class="s0">}</span>
                        <span class="s3">// Use the tree computed by startPPRNavigation instead</span>
                        <span class="s3">// of the one computed by applyRouterStatePatchToTree.</span>
                        <span class="s3">// TODO: We should remove applyRouterStatePatchToTree</span>
                        <span class="s3">// from the PPR path entirely.</span>
                        <span class="s1">const </span><span class="s0">patchedRouterState = task.route;</span>
                        <span class="s0">newTree = patchedRouterState;</span>
                        <span class="s1">const </span><span class="s0">newCache = task.node;</span>
                        <span class="s1">if </span><span class="s0">(newCache !== </span><span class="s1">null</span><span class="s0">) {</span>
                            <span class="s3">// We've created a new Cache Node tree that contains a prefetched</span>
                            <span class="s3">// version of the next page. This can be rendered instantly.</span>
                            <span class="s0">mutable.cache = newCache;</span>
                        <span class="s0">}</span>
                        <span class="s1">const </span><span class="s0">dynamicRequestTree = task.dynamicRequestTree;</span>
                        <span class="s1">if </span><span class="s0">(dynamicRequestTree !== </span><span class="s1">null</span><span class="s0">) {</span>
                            <span class="s3">// The prefetched tree has dynamic holes in it. We initiate a</span>
                            <span class="s3">// dynamic request to fill them in.</span>
                            <span class="s3">//</span>
                            <span class="s3">// Do not block on the result. We'll immediately render the Cache</span>
                            <span class="s3">// Node tree and suspend on the dynamic parts. When the request</span>
                            <span class="s3">// comes in, we'll fill in missing data and ping React to</span>
                            <span class="s3">// re-render. Unlike the lazy fetching model in the non-PPR</span>
                            <span class="s3">// implementation, this is modeled as a single React update +</span>
                            <span class="s3">// streaming, rather than multiple top-level updates. (However,</span>
                            <span class="s3">// even in the new model, we'll still need to sometimes update the</span>
                            <span class="s3">// root multiple times per navigation, like if the server sends us</span>
                            <span class="s3">// a different response than we expected. For now, we revert back</span>
                            <span class="s3">// to the lazy fetching mechanism in that case.)</span>
                            <span class="s1">const </span><span class="s0">dynamicRequest = (</span><span class="s4">0</span><span class="s0">, _fetchserverresponse.fetchServerResponse)(</span><span class="s1">new </span><span class="s0">URL(updatedCanonicalUrl, url.origin), {</span>
                                <span class="s0">flightRouterState: dynamicRequestTree,</span>
                                <span class="s0">nextUrl: state.nextUrl</span>
                            <span class="s0">});</span>
                            <span class="s0">(</span><span class="s4">0</span><span class="s0">, _pprnavigations.listenForDynamicRequest)(task, dynamicRequest);</span>
                        <span class="s3">// We store the dynamic request on the `lazyData` property of the CacheNode</span>
                        <span class="s3">// because we're not going to await the dynamic request here. Since we're not blocking</span>
                        <span class="s3">// on the dynamic request, `layout-router` will</span>
                        <span class="s3">// task.node.lazyData = dynamicRequest</span>
                        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                        <span class="s3">// The prefetched tree does not contain dynamic holes  it's</span>
                        <span class="s3">// fully static. We can skip the dynamic request.</span>
                        <span class="s0">}</span>
                    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                        <span class="s3">// Nothing changed, so reuse the old cache.</span>
                        <span class="s3">// TODO: What if the head changed but not any of the segment data?</span>
                        <span class="s3">// Is that possible? If so, we should clone the whole tree and</span>
                        <span class="s3">// update the head.</span>
                        <span class="s0">newTree = treePatch;</span>
                    <span class="s0">}</span>
                <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                    <span class="s3">// The static response does not include any dynamic holes, so</span>
                    <span class="s3">// there's no need to do a second request.</span>
                    <span class="s3">// TODO: As an incremental step this just reverts back to the</span>
                    <span class="s3">// non-PPR implementation. We can simplify this branch further,</span>
                    <span class="s3">// given that PPR prefetches are always static and return the whole</span>
                    <span class="s3">// tree. Or in the meantime we could factor it out into a</span>
                    <span class="s3">// separate function.</span>
                    <span class="s1">if </span><span class="s0">((</span><span class="s4">0</span><span class="s0">, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {</span>
                        <span class="s1">return </span><span class="s0">handleExternalUrl(state, mutable, href, pendingPush);</span>
                    <span class="s0">}</span>
                    <span class="s1">const </span><span class="s0">cache = (</span><span class="s4">0</span><span class="s0">, _approuter.createEmptyCacheNode)();</span>
                    <span class="s1">let </span><span class="s0">applied = </span><span class="s1">false</span><span class="s0">;</span>
                    <span class="s1">if </span><span class="s0">(prefetchValues.status === _routerreducertypes.PrefetchCacheEntryStatus.stale &amp;&amp; !isFirstRead) {</span>
                        <span class="s3">// When we have a stale prefetch entry, we only want to re-use the loading state of the route we're navigating to, to support instant loading navigations</span>
                        <span class="s3">// this will trigger a lazy fetch for the actual page data by nulling the `rsc` and `prefetchRsc` values for page data,</span>
                        <span class="s3">// while copying over the `loading` for the segment that contains the page data.</span>
                        <span class="s3">// We only do this on subsequent reads, as otherwise there'd be no loading data to re-use.</span>
                        <span class="s3">// We skip this branch if only the hash fragment has changed, as we don't want to trigger a lazy fetch in that case</span>
                        <span class="s0">applied = triggerLazyFetchForLeafSegments(cache, currentCache, flightSegmentPath, treePatch);</span>
                        <span class="s3">// since we re-used the stale cache's loading state &amp; refreshed the data,</span>
                        <span class="s3">// update the `lastUsedTime` so that it can continue to be re-used for the next 30s</span>
                        <span class="s0">prefetchValues.lastUsedTime = navigatedAt;</span>
                    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                        <span class="s0">applied = (</span><span class="s4">0</span><span class="s0">, _applyflightdata.applyFlightData)(navigatedAt, currentCache, cache, normalizedFlightData, prefetchValues);</span>
                    <span class="s0">}</span>
                    <span class="s1">const </span><span class="s0">hardNavigate = (</span><span class="s4">0</span><span class="s0">, _shouldhardnavigate.shouldHardNavigate)(flightSegmentPathWithLeadingEmpty, currentTree);</span>
                    <span class="s1">if </span><span class="s0">(hardNavigate) {</span>
                        <span class="s3">// Copy rsc for the root node of the cache.</span>
                        <span class="s0">cache.rsc = currentCache.rsc;</span>
                        <span class="s0">cache.prefetchRsc = currentCache.prefetchRsc;</span>
                        <span class="s0">(</span><span class="s4">0</span><span class="s0">, _invalidatecachebelowflightsegmentpath.invalidateCacheBelowFlightSegmentPath)(cache, currentCache, flightSegmentPath);</span>
                        <span class="s3">// Ensure the existing cache value is used when the cache was not invalidated.</span>
                        <span class="s0">mutable.cache = cache;</span>
                    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(applied) {</span>
                        <span class="s0">mutable.cache = cache;</span>
                        <span class="s3">// If we applied the cache, we update the &quot;current cache&quot; value so any other</span>
                        <span class="s3">// segments in the FlightDataPath will be able to reference the updated cache.</span>
                        <span class="s0">currentCache = cache;</span>
                    <span class="s0">}</span>
                    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">subSegment of generateSegmentsFromPatch(treePatch)){</span>
                        <span class="s1">const </span><span class="s0">scrollableSegmentPath = [</span>
                            <span class="s0">...flightSegmentPath,</span>
                            <span class="s0">...subSegment</span>
                        <span class="s0">];</span>
                        <span class="s3">// Filter out the __DEFAULT__ paths as they shouldn't be scrolled to in this case.</span>
                        <span class="s1">if </span><span class="s0">(scrollableSegmentPath[scrollableSegmentPath.length - </span><span class="s4">1</span><span class="s0">] !== _segment.DEFAULT_SEGMENT_KEY) {</span>
                            <span class="s0">scrollableSegments.push(scrollableSegmentPath);</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
                <span class="s0">currentTree = newTree;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
        <span class="s0">mutable.patchedTree = currentTree;</span>
        <span class="s0">mutable.canonicalUrl = updatedCanonicalUrl;</span>
        <span class="s0">mutable.scrollableSegments = scrollableSegments;</span>
        <span class="s0">mutable.hashFragment = hash;</span>
        <span class="s0">mutable.shouldScroll = shouldScroll;</span>
        <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _handlemutable.handleMutable)(state, mutable);</span>
    <span class="s0">}, ()=&gt;state);</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=navigate-reducer.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/reducers/server-patch-reducer.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;serverPatchReducer&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">serverPatchReducer;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_createhreffromurl = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_applyrouterstatepatchtotree = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_isnavigatingtonewrootlayout = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_navigatereducer = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_applyflightdata = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/apply-flight-data.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_handlemutable = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/handle-mutable.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_approuter = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/app-router.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">serverPatchReducer(state, action) {</span>
    <span class="s1">const </span><span class="s0">{ serverResponse: { flightData, canonicalUrl: canonicalUrlOverride }, navigatedAt } = action;</span>
    <span class="s1">const </span><span class="s0">mutable = {};</span>
    <span class="s0">mutable.preserveCustomHistoryState = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s3">// Handle case when navigating to page in `pages` from `app`</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">flightData === </span><span class="s2">'string'</span><span class="s0">) {</span>
        <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);</span>
    <span class="s0">}</span>
    <span class="s1">let </span><span class="s0">currentTree = state.tree;</span>
    <span class="s1">let </span><span class="s0">currentCache = state.cache;</span>
    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">normalizedFlightData of flightData){</span>
        <span class="s1">const </span><span class="s0">{ segmentPath: flightSegmentPath, tree: treePatch } = normalizedFlightData;</span>
        <span class="s1">const </span><span class="s0">newTree = (</span><span class="s4">0</span><span class="s0">, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([</span>
            <span class="s2">''</span><span class="s0">,</span>
            <span class="s0">...flightSegmentPath</span>
        <span class="s0">], currentTree, treePatch, state.canonicalUrl);</span>
        <span class="s3">// `applyRouterStatePatchToTree` returns `null` when it determined that the server response is not applicable to the current tree.</span>
        <span class="s3">// In other words, the server responded with a tree that doesn't match what the client is currently rendering.</span>
        <span class="s3">// This can happen if the server patch action took longer to resolve than a subsequent navigation which would have changed the tree.</span>
        <span class="s3">// Previously this case triggered an MPA navigation but it should be safe to simply discard the server response rather than forcing</span>
        <span class="s3">// the entire page to reload.</span>
        <span class="s1">if </span><span class="s0">(newTree === </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">state;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">((</span><span class="s4">0</span><span class="s0">, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {</span>
            <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _navigatereducer.handleExternalUrl)(state, mutable, state.canonicalUrl, state.pushRef.pendingPush);</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">canonicalUrlOverrideHref = canonicalUrlOverride ? (</span><span class="s4">0</span><span class="s0">, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : undefined;</span>
        <span class="s1">if </span><span class="s0">(canonicalUrlOverrideHref) {</span>
            <span class="s0">mutable.canonicalUrl = canonicalUrlOverrideHref;</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">cache = (</span><span class="s4">0</span><span class="s0">, _approuter.createEmptyCacheNode)();</span>
        <span class="s0">(</span><span class="s4">0</span><span class="s0">, _applyflightdata.applyFlightData)(navigatedAt, currentCache, cache, normalizedFlightData);</span>
        <span class="s0">mutable.patchedTree = newTree;</span>
        <span class="s0">mutable.cache = cache;</span>
        <span class="s0">currentCache = cache;</span>
        <span class="s0">currentTree = newTree;</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _handlemutable.handleMutable)(state, mutable);</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=server-patch-reducer.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/reducers/restore-reducer.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;restoreReducer&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">restoreReducer;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_createhreffromurl = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_computechangedpath = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/compute-changed-path.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_pprnavigations = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/ppr-navigations.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">restoreReducer(state, action) {</span>
    <span class="s1">const </span><span class="s0">{ url, tree } = action;</span>
    <span class="s1">const </span><span class="s0">href = (</span><span class="s4">0</span><span class="s0">, _createhreffromurl.createHrefFromUrl)(url);</span>
    <span class="s3">// This action is used to restore the router state from the history state.</span>
    <span class="s3">// However, it's possible that the history state no longer contains the `FlightRouterState`.</span>
    <span class="s3">// We will copy over the internal state on pushState/replaceState events, but if a history entry</span>
    <span class="s3">// occurred before hydration, or if the user navigated to a hash using a regular anchor link,</span>
    <span class="s3">// the history state will not contain the `FlightRouterState`.</span>
    <span class="s3">// In this case, we'll continue to use the existing tree so the router doesn't get into an invalid state.</span>
    <span class="s1">const </span><span class="s0">treeToRestore = tree || state.tree;</span>
    <span class="s1">const </span><span class="s0">oldCache = state.cache;</span>
    <span class="s1">const </span><span class="s0">newCache = (</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) ? </span><span class="s3">// prevents an unnecessary flash back to PPR state during a</span>
    <span class="s3">// back/forward navigation.</span>
    <span class="s2">&quot;TURBOPACK unreachable&quot; </span><span class="s0">: oldCache;</span>
    <span class="s1">var </span><span class="s0">_extractPathFromFlightRouterState;</span>
    <span class="s1">return </span><span class="s0">{</span>
        <span class="s3">// Set canonical url</span>
        <span class="s0">canonicalUrl: href,</span>
        <span class="s0">pushRef: {</span>
            <span class="s0">pendingPush: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">mpaNavigation: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s3">// Ensures that the custom history state that was set is preserved when applying this update.</span>
            <span class="s0">preserveCustomHistoryState: </span><span class="s1">true</span>
        <span class="s0">},</span>
        <span class="s0">focusAndScrollRef: state.focusAndScrollRef,</span>
        <span class="s0">cache: newCache,</span>
        <span class="s0">prefetchCache: state.prefetchCache,</span>
        <span class="s3">// Restore provided tree</span>
        <span class="s0">tree: treeToRestore,</span>
        <span class="s0">nextUrl: (_extractPathFromFlightRouterState = (</span><span class="s4">0</span><span class="s0">, _computechangedpath.extractPathFromFlightRouterState)(treeToRestore)) != </span><span class="s1">null </span><span class="s0">? _extractPathFromFlightRouterState : url.pathname</span>
    <span class="s0">};</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=restore-reducer.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;handleSegmentMismatch&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">handleSegmentMismatch;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_navigatereducer = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">handleSegmentMismatch(state, action, treePatch) {</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s0">) {</span>
        <span class="s0">console.warn(</span><span class="s2">'Performing hard navigation because your application experienced an unrecoverable error. If this keeps occurring, please file a Next.js issue.</span><span class="s6">\n\n</span><span class="s2">' </span><span class="s0">+ </span><span class="s2">'Reason: Segment mismatch</span><span class="s6">\n</span><span class="s2">' </span><span class="s0">+ (</span><span class="s2">&quot;Last Action: &quot; </span><span class="s0">+ action.type + </span><span class="s2">&quot;</span><span class="s6">\n\n</span><span class="s2">&quot;</span><span class="s0">) + (</span><span class="s2">&quot;Current Tree: &quot; </span><span class="s0">+ JSON.stringify(state.tree) + </span><span class="s2">&quot;</span><span class="s6">\n\n</span><span class="s2">&quot;</span><span class="s0">) + (</span><span class="s2">&quot;Tree Patch Payload: &quot; </span><span class="s0">+ JSON.stringify(treePatch)));</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _navigatereducer.handleExternalUrl)(state, {}, state.canonicalUrl, </span><span class="s1">true</span><span class="s0">);</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=handle-segment-mismatch.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;hasInterceptionRouteInCurrentTree&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">hasInterceptionRouteInCurrentTree;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_interceptionroutes = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/router/utils/interception-routes.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">hasInterceptionRouteInCurrentTree(param) {</span>
    <span class="s1">let </span><span class="s0">[segment, parallelRoutes] = param;</span>
    <span class="s3">// If we have a dynamic segment, it's marked as an interception route by the presence of the `i` suffix.</span>
    <span class="s1">if </span><span class="s0">(Array.isArray(segment) &amp;&amp; (segment[</span><span class="s4">2</span><span class="s0">] === </span><span class="s2">'di' </span><span class="s0">|| segment[</span><span class="s4">2</span><span class="s0">] === </span><span class="s2">'ci'</span><span class="s0">)) {</span>
        <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s3">// If segment is not an array, apply the existing string-based check</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">segment === </span><span class="s2">'string' </span><span class="s0">&amp;&amp; (</span><span class="s4">0</span><span class="s0">, _interceptionroutes.isInterceptionRouteAppPath)(segment)) {</span>
        <span class="s1">return true</span><span class="s0">;</span>
    <span class="s0">}</span>
    <span class="s3">// Iterate through parallelRoutes if they exist</span>
    <span class="s1">if </span><span class="s0">(parallelRoutes) {</span>
        <span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">key </span><span class="s1">in </span><span class="s0">parallelRoutes){</span>
            <span class="s1">if </span><span class="s0">(hasInterceptionRouteInCurrentTree(parallelRoutes[key])) {</span>
                <span class="s1">return true</span><span class="s0">;</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s1">return false</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=has-interception-route-in-current-tree.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/reducers/refresh-reducer.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;refreshReducer&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">refreshReducer;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_fetchserverresponse = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/fetch-server-response.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_createhreffromurl = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_applyrouterstatepatchtotree = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_isnavigatingtonewrootlayout = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_navigatereducer = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_handlemutable = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/handle-mutable.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_filllazyitemstillleafwithhead = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_approuter = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/app-router.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_handlesegmentmismatch = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_hasinterceptionrouteincurrenttree = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_refetchinactiveparallelsegments = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_segmentcache = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/segment-cache.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">refreshReducer(state, action) {</span>
    <span class="s1">const </span><span class="s0">{ origin } = action;</span>
    <span class="s1">const </span><span class="s0">mutable = {};</span>
    <span class="s1">const </span><span class="s0">href = state.canonicalUrl;</span>
    <span class="s1">let </span><span class="s0">currentTree = state.tree;</span>
    <span class="s0">mutable.preserveCustomHistoryState = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">cache = (</span><span class="s4">0</span><span class="s0">, _approuter.createEmptyCacheNode)();</span>
    <span class="s3">// If the current tree was intercepted, the nextUrl should be included in the request.</span>
    <span class="s3">// This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.</span>
    <span class="s1">const </span><span class="s0">includeNextUrl = (</span><span class="s4">0</span><span class="s0">, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree);</span>
    <span class="s3">// TODO-APP: verify that `href` is not an external url.</span>
    <span class="s3">// Fetch data from the root of the tree.</span>
    <span class="s0">cache.lazyData = (</span><span class="s4">0</span><span class="s0">, _fetchserverresponse.fetchServerResponse)(</span><span class="s1">new </span><span class="s0">URL(href, origin), {</span>
        <span class="s0">flightRouterState: [</span>
            <span class="s0">currentTree[</span><span class="s4">0</span><span class="s0">],</span>
            <span class="s0">currentTree[</span><span class="s4">1</span><span class="s0">],</span>
            <span class="s0">currentTree[</span><span class="s4">2</span><span class="s0">],</span>
            <span class="s2">'refetch'</span>
        <span class="s0">],</span>
        <span class="s0">nextUrl: includeNextUrl ? state.nextUrl : </span><span class="s1">null</span>
    <span class="s0">});</span>
    <span class="s1">const </span><span class="s0">navigatedAt = Date.now();</span>
    <span class="s1">return </span><span class="s0">cache.lazyData.then(async (param)=&gt;{</span>
        <span class="s1">let </span><span class="s0">{ flightData, canonicalUrl: canonicalUrlOverride } = param;</span>
        <span class="s3">// Handle case when navigating to page in `pages` from `app`</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">flightData === </span><span class="s2">'string'</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);</span>
        <span class="s0">}</span>
        <span class="s3">// Remove cache.lazyData as it has been resolved at this point.</span>
        <span class="s0">cache.lazyData = </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">normalizedFlightData of flightData){</span>
            <span class="s1">const </span><span class="s0">{ tree: treePatch, seedData: cacheNodeSeedData, head, isRootRender } = normalizedFlightData;</span>
            <span class="s1">if </span><span class="s0">(!isRootRender) {</span>
                <span class="s3">// TODO-APP: handle this case better</span>
                <span class="s0">console.log(</span><span class="s2">'REFRESH FAILED'</span><span class="s0">);</span>
                <span class="s1">return </span><span class="s0">state;</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">newTree = (</span><span class="s4">0</span><span class="s0">, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([</span>
                <span class="s2">''</span>
            <span class="s0">], currentTree, treePatch, state.canonicalUrl);</span>
            <span class="s1">if </span><span class="s0">(newTree === </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">((</span><span class="s4">0</span><span class="s0">, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {</span>
                <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _navigatereducer.handleExternalUrl)(state, mutable, href, state.pushRef.pendingPush);</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">canonicalUrlOverrideHref = canonicalUrlOverride ? (</span><span class="s4">0</span><span class="s0">, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : undefined;</span>
            <span class="s1">if </span><span class="s0">(canonicalUrlOverride) {</span>
                <span class="s0">mutable.canonicalUrl = canonicalUrlOverrideHref;</span>
            <span class="s0">}</span>
            <span class="s3">// Handles case where prefetch only returns the router tree patch without rendered components.</span>
            <span class="s1">if </span><span class="s0">(cacheNodeSeedData !== </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s1">const </span><span class="s0">rsc = cacheNodeSeedData[</span><span class="s4">1</span><span class="s0">];</span>
                <span class="s1">const </span><span class="s0">loading = cacheNodeSeedData[</span><span class="s4">3</span><span class="s0">];</span>
                <span class="s0">cache.rsc = rsc;</span>
                <span class="s0">cache.prefetchRsc = </span><span class="s1">null</span><span class="s0">;</span>
                <span class="s0">cache.loading = loading;</span>
                <span class="s0">(</span><span class="s4">0</span><span class="s0">, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(navigatedAt, cache, undefined, treePatch, cacheNodeSeedData, head, undefined);</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) </span><span class="s3">//TURBOPACK unreachable</span>
                <span class="s0">;</span>
                <span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">mutable.prefetchCache = </span><span class="s1">new </span><span class="s0">Map();</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s1">await </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _refetchinactiveparallelsegments.refreshInactiveParallelSegments)({</span>
                <span class="s0">navigatedAt,</span>
                <span class="s0">state,</span>
                <span class="s0">updatedTree: newTree,</span>
                <span class="s0">updatedCache: cache,</span>
                <span class="s0">includeNextUrl,</span>
                <span class="s0">canonicalUrl: mutable.canonicalUrl || state.canonicalUrl</span>
            <span class="s0">});</span>
            <span class="s0">mutable.cache = cache;</span>
            <span class="s0">mutable.patchedTree = newTree;</span>
            <span class="s0">currentTree = newTree;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _handlemutable.handleMutable)(state, mutable);</span>
    <span class="s0">}, ()=&gt;state);</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=refresh-reducer.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/reducers/hmr-refresh-reducer.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;hmrRefreshReducer&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">hmrRefreshReducer;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_fetchserverresponse = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/fetch-server-response.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_createhreffromurl = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_applyrouterstatepatchtotree = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_isnavigatingtonewrootlayout = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_navigatereducer = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_handlemutable = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/handle-mutable.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_applyflightdata = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/apply-flight-data.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_approuter = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/app-router.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_handlesegmentmismatch = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_hasinterceptionrouteincurrenttree = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s3">// A version of refresh reducer that keeps the cache around instead of wiping all of it.</span>
<span class="s1">function </span><span class="s0">hmrRefreshReducerImpl(state, action) {</span>
    <span class="s1">const </span><span class="s0">{ origin } = action;</span>
    <span class="s1">const </span><span class="s0">mutable = {};</span>
    <span class="s1">const </span><span class="s0">href = state.canonicalUrl;</span>
    <span class="s0">mutable.preserveCustomHistoryState = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">cache = (</span><span class="s4">0</span><span class="s0">, _approuter.createEmptyCacheNode)();</span>
    <span class="s3">// If the current tree was intercepted, the nextUrl should be included in the request.</span>
    <span class="s3">// This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.</span>
    <span class="s1">const </span><span class="s0">includeNextUrl = (</span><span class="s4">0</span><span class="s0">, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree);</span>
    <span class="s3">// TODO-APP: verify that `href` is not an external url.</span>
    <span class="s3">// Fetch data from the root of the tree.</span>
    <span class="s1">const </span><span class="s0">navigatedAt = Date.now();</span>
    <span class="s0">cache.lazyData = (</span><span class="s4">0</span><span class="s0">, _fetchserverresponse.fetchServerResponse)(</span><span class="s1">new </span><span class="s0">URL(href, origin), {</span>
        <span class="s0">flightRouterState: [</span>
            <span class="s0">state.tree[</span><span class="s4">0</span><span class="s0">],</span>
            <span class="s0">state.tree[</span><span class="s4">1</span><span class="s0">],</span>
            <span class="s0">state.tree[</span><span class="s4">2</span><span class="s0">],</span>
            <span class="s2">'refetch'</span>
        <span class="s0">],</span>
        <span class="s0">nextUrl: includeNextUrl ? state.nextUrl : </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">isHmrRefresh: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s1">return </span><span class="s0">cache.lazyData.then((param)=&gt;{</span>
        <span class="s1">let </span><span class="s0">{ flightData, canonicalUrl: canonicalUrlOverride } = param;</span>
        <span class="s3">// Handle case when navigating to page in `pages` from `app`</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">flightData === </span><span class="s2">'string'</span><span class="s0">) {</span>
            <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);</span>
        <span class="s0">}</span>
        <span class="s3">// Remove cache.lazyData as it has been resolved at this point.</span>
        <span class="s0">cache.lazyData = </span><span class="s1">null</span><span class="s0">;</span>
        <span class="s1">let </span><span class="s0">currentTree = state.tree;</span>
        <span class="s1">let </span><span class="s0">currentCache = state.cache;</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">normalizedFlightData of flightData){</span>
            <span class="s1">const </span><span class="s0">{ tree: treePatch, isRootRender } = normalizedFlightData;</span>
            <span class="s1">if </span><span class="s0">(!isRootRender) {</span>
                <span class="s3">// TODO-APP: handle this case better</span>
                <span class="s0">console.log(</span><span class="s2">'REFRESH FAILED'</span><span class="s0">);</span>
                <span class="s1">return </span><span class="s0">state;</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">newTree = (</span><span class="s4">0</span><span class="s0">, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([</span>
                <span class="s2">''</span>
            <span class="s0">], currentTree, treePatch, state.canonicalUrl);</span>
            <span class="s1">if </span><span class="s0">(newTree === </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">((</span><span class="s4">0</span><span class="s0">, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {</span>
                <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _navigatereducer.handleExternalUrl)(state, mutable, href, state.pushRef.pendingPush);</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">canonicalUrlOverrideHref = canonicalUrlOverride ? (</span><span class="s4">0</span><span class="s0">, _createhreffromurl.createHrefFromUrl)(canonicalUrlOverride) : undefined;</span>
            <span class="s1">if </span><span class="s0">(canonicalUrlOverride) {</span>
                <span class="s0">mutable.canonicalUrl = canonicalUrlOverrideHref;</span>
            <span class="s0">}</span>
            <span class="s1">const </span><span class="s0">applied = (</span><span class="s4">0</span><span class="s0">, _applyflightdata.applyFlightData)(navigatedAt, currentCache, cache, normalizedFlightData);</span>
            <span class="s1">if </span><span class="s0">(applied) {</span>
                <span class="s0">mutable.cache = cache;</span>
                <span class="s0">currentCache = cache;</span>
            <span class="s0">}</span>
            <span class="s0">mutable.patchedTree = newTree;</span>
            <span class="s0">mutable.canonicalUrl = href;</span>
            <span class="s0">currentTree = newTree;</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _handlemutable.handleMutable)(state, mutable);</span>
    <span class="s0">}, ()=&gt;state);</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">hmrRefreshReducerNoop(state, _action) {</span>
    <span class="s1">return </span><span class="s0">state;</span>
<span class="s0">}</span>
<span class="s1">const </span><span class="s0">hmrRefreshReducer = (</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) ? </span><span class="s2">&quot;TURBOPACK unreachable&quot; </span><span class="s0">: hmrRefreshReducerImpl;</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=hmr-refresh-reducer.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/assign-location.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;assignLocation&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">assignLocation;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_addbasepath = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/add-base-path.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">assignLocation(location, url) {</span>
    <span class="s1">if </span><span class="s0">(location.startsWith(</span><span class="s2">'.'</span><span class="s0">)) {</span>
        <span class="s1">const </span><span class="s0">urlBase = url.origin + url.pathname;</span>
        <span class="s1">return new </span><span class="s0">URL(</span><span class="s3">// new URL('./relative', 'https://example.com/subdir').href -&gt; 'https://example.com/relative'</span>
        <span class="s3">// new URL('./relative', 'https://example.com/subdir/').href -&gt; 'https://example.com/subdir/relative'</span>
        <span class="s0">(urlBase.endsWith(</span><span class="s2">'/'</span><span class="s0">) ? urlBase : urlBase + </span><span class="s2">'/'</span><span class="s0">) + location);</span>
    <span class="s0">}</span>
    <span class="s1">return new </span><span class="s0">URL((</span><span class="s4">0</span><span class="s0">, _addbasepath.addBasePath)(location), url.href);</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=assign-location.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/reducers/server-action-reducer.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;serverActionReducer&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">serverActionReducer;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_appcallserver = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/app-call-server.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_appfindsourcemapurl = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/app-find-source-map-url.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_approuterheaders = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/app-router-headers.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_unrecognizedactionerror = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/unrecognized-action-error.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_client = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react-server-dom-turbopack/client.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_routerreducertypes = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_assignlocation = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/assign-location.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_createhreffromurl = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_navigatereducer = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_applyrouterstatepatchtotree = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/apply-router-state-patch-to-tree.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_isnavigatingtonewrootlayout = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/is-navigating-to-new-root-layout.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_handlemutable = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/handle-mutable.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_filllazyitemstillleafwithhead = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_approuter = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/app-router.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_hasinterceptionrouteincurrenttree = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/reducers/has-interception-route-in-current-tree.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_handlesegmentmismatch = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/handle-segment-mismatch.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_refetchinactiveparallelsegments = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_flightdatahelpers = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/flight-data-helpers.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_redirect = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/redirect.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_redirecterror = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/redirect-error.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_prefetchcacheutils = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_removebasepath = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/remove-base-path.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_hasbasepath = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/has-base-path.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_serverreferenceinfo = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/server-reference-info.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_segmentcache = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/segment-cache.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">createFromFetch = _client.createFromFetch;</span>
<span class="s0">async </span><span class="s1">function </span><span class="s0">fetchServerAction(state, nextUrl, param) {</span>
    <span class="s1">let </span><span class="s0">{ actionId, actionArgs } = param;</span>
    <span class="s1">const </span><span class="s0">temporaryReferences = (</span><span class="s4">0</span><span class="s0">, _client.createTemporaryReferenceSet)();</span>
    <span class="s1">const </span><span class="s0">info = (</span><span class="s4">0</span><span class="s0">, _serverreferenceinfo.extractInfoFromServerReferenceId)(actionId);</span>
    <span class="s3">// TODO: Currently, we're only omitting unused args for the experimental &quot;use</span>
    <span class="s3">// cache&quot; functions. Once the server reference info byte feature is stable, we</span>
    <span class="s3">// should apply this to server actions as well.</span>
    <span class="s1">const </span><span class="s0">usedArgs = info.type === </span><span class="s2">'use-cache' </span><span class="s0">? (</span><span class="s4">0</span><span class="s0">, _serverreferenceinfo.omitUnusedArgs)(actionArgs, info) : actionArgs;</span>
    <span class="s1">const </span><span class="s0">body = </span><span class="s1">await </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _client.encodeReply)(usedArgs, {</span>
        <span class="s0">temporaryReferences</span>
    <span class="s0">});</span>
    <span class="s1">const </span><span class="s0">res = </span><span class="s1">await </span><span class="s0">fetch(state.canonicalUrl, {</span>
        <span class="s0">method: </span><span class="s2">'POST'</span><span class="s0">,</span>
        <span class="s0">headers: {</span>
            <span class="s0">Accept: _approuterheaders.RSC_CONTENT_TYPE_HEADER,</span>
            <span class="s0">[_approuterheaders.ACTION_HEADER]: actionId,</span>
            <span class="s0">[_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER]: (</span><span class="s4">0</span><span class="s0">, _flightdatahelpers.prepareFlightRouterStateForRequest)(state.tree),</span>
            <span class="s0">...(</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) ? </span><span class="s2">&quot;TURBOPACK unreachable&quot; </span><span class="s0">: {},</span>
            <span class="s0">...nextUrl ? {</span>
                <span class="s0">[_approuterheaders.NEXT_URL]: nextUrl</span>
            <span class="s0">} : {}</span>
        <span class="s0">},</span>
        <span class="s0">body</span>
    <span class="s0">});</span>
    <span class="s3">// Handle server actions that the server didn't recognize.</span>
    <span class="s1">const </span><span class="s0">unrecognizedActionHeader = res.headers.get(_approuterheaders.NEXT_ACTION_NOT_FOUND_HEADER);</span>
    <span class="s1">if </span><span class="s0">(unrecognizedActionHeader === </span><span class="s2">'1'</span><span class="s0">) {</span>
        <span class="s1">throw </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">_unrecognizedactionerror.UnrecognizedActionError(</span><span class="s2">'Server Action &quot;' </span><span class="s0">+ actionId + </span><span class="s2">'&quot; was not found on the server. </span><span class="s6">\n</span><span class="s2">Read more: https://nextjs.org/docs/messages/failed-to-find-server-action'</span><span class="s0">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
            <span class="s0">value: </span><span class="s2">&quot;E715&quot;</span><span class="s0">,</span>
            <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">configurable: </span><span class="s1">true</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">redirectHeader = res.headers.get(</span><span class="s2">'x-action-redirect'</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">[location, _redirectType] = (redirectHeader == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: redirectHeader.split(</span><span class="s2">';'</span><span class="s0">)) || [];</span>
    <span class="s1">let </span><span class="s0">redirectType;</span>
    <span class="s1">switch</span><span class="s0">(_redirectType){</span>
        <span class="s1">case </span><span class="s2">'push'</span><span class="s0">:</span>
            <span class="s0">redirectType = _redirecterror.RedirectType.push;</span>
            <span class="s1">break</span><span class="s0">;</span>
        <span class="s1">case </span><span class="s2">'replace'</span><span class="s0">:</span>
            <span class="s0">redirectType = _redirecterror.RedirectType.replace;</span>
            <span class="s1">break</span><span class="s0">;</span>
        <span class="s1">default</span><span class="s0">:</span>
            <span class="s0">redirectType = undefined;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">isPrerender = !!res.headers.get(_approuterheaders.NEXT_IS_PRERENDER_HEADER);</span>
    <span class="s1">let </span><span class="s0">revalidatedParts;</span>
    <span class="s1">try </span><span class="s0">{</span>
        <span class="s1">const </span><span class="s0">revalidatedHeader = JSON.parse(res.headers.get(</span><span class="s2">'x-action-revalidated'</span><span class="s0">) || </span><span class="s2">'[[],0,0]'</span><span class="s0">);</span>
        <span class="s0">revalidatedParts = {</span>
            <span class="s0">paths: revalidatedHeader[</span><span class="s4">0</span><span class="s0">] || [],</span>
            <span class="s0">tag: !!revalidatedHeader[</span><span class="s4">1</span><span class="s0">],</span>
            <span class="s0">cookie: revalidatedHeader[</span><span class="s4">2</span><span class="s0">]</span>
        <span class="s0">};</span>
    <span class="s0">} </span><span class="s1">catch </span><span class="s0">(e) {</span>
        <span class="s0">revalidatedParts = NO_REVALIDATED_PARTS;</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">redirectLocation = location ? (</span><span class="s4">0</span><span class="s0">, _assignlocation.assignLocation)(location, </span><span class="s1">new </span><span class="s0">URL(state.canonicalUrl, window.location.href)) : undefined;</span>
    <span class="s1">const </span><span class="s0">contentType = res.headers.get(</span><span class="s2">'content-type'</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">isRscResponse = !!(contentType &amp;&amp; contentType.startsWith(_approuterheaders.RSC_CONTENT_TYPE_HEADER));</span>
    <span class="s3">// Handle invalid server action responses.</span>
    <span class="s3">// A valid response must have `content-type: text/x-component`, unless it's an external redirect.</span>
    <span class="s3">// (external redirects have an 'x-action-redirect' header, but the body is an empty 'text/plain')</span>
    <span class="s1">if </span><span class="s0">(!isRscResponse &amp;&amp; !redirectLocation) {</span>
        <span class="s3">// The server can respond with a text/plain error message, but we'll fallback to something generic</span>
        <span class="s3">// if there isn't one.</span>
        <span class="s1">const </span><span class="s0">message = res.status &gt;= </span><span class="s4">400 </span><span class="s0">&amp;&amp; contentType === </span><span class="s2">'text/plain' </span><span class="s0">? </span><span class="s1">await </span><span class="s0">res.text() : </span><span class="s2">'An unexpected response was received from the server.'</span><span class="s0">;</span>
        <span class="s1">throw </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">Error(message), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
            <span class="s0">value: </span><span class="s2">&quot;E394&quot;</span><span class="s0">,</span>
            <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">configurable: </span><span class="s1">true</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">let </span><span class="s0">actionResult;</span>
    <span class="s1">let </span><span class="s0">actionFlightData;</span>
    <span class="s1">if </span><span class="s0">(isRscResponse) {</span>
        <span class="s1">const </span><span class="s0">response = </span><span class="s1">await </span><span class="s0">createFromFetch(Promise.resolve(res), {</span>
            <span class="s0">callServer: _appcallserver.callServer,</span>
            <span class="s0">findSourceMapURL: _appfindsourcemapurl.findSourceMapURL,</span>
            <span class="s0">temporaryReferences</span>
        <span class="s0">});</span>
        <span class="s3">// An internal redirect can send an RSC response, but does not have a useful `actionResult`.</span>
        <span class="s0">actionResult = redirectLocation ? undefined : response.a;</span>
        <span class="s0">actionFlightData = (</span><span class="s4">0</span><span class="s0">, _flightdatahelpers.normalizeFlightData)(response.f);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s3">// An external redirect doesn't contain RSC data.</span>
        <span class="s0">actionResult = undefined;</span>
        <span class="s0">actionFlightData = undefined;</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">{</span>
        <span class="s0">actionResult,</span>
        <span class="s0">actionFlightData,</span>
        <span class="s0">redirectLocation,</span>
        <span class="s0">redirectType,</span>
        <span class="s0">revalidatedParts,</span>
        <span class="s0">isPrerender</span>
    <span class="s0">};</span>
<span class="s0">}</span>
<span class="s1">const </span><span class="s0">NO_REVALIDATED_PARTS = {</span>
    <span class="s0">paths: [],</span>
    <span class="s0">tag: </span><span class="s1">false</span><span class="s0">,</span>
    <span class="s0">cookie: </span><span class="s1">false</span>
<span class="s0">};</span>
<span class="s1">function </span><span class="s0">serverActionReducer(state, action) {</span>
    <span class="s1">const </span><span class="s0">{ resolve, reject } = action;</span>
    <span class="s1">const </span><span class="s0">mutable = {};</span>
    <span class="s1">let </span><span class="s0">currentTree = state.tree;</span>
    <span class="s0">mutable.preserveCustomHistoryState = </span><span class="s1">false</span><span class="s0">;</span>
    <span class="s3">// only pass along the `nextUrl` param (used for interception routes) if the current route was intercepted.</span>
    <span class="s3">// If the route has been intercepted, the action should be as well.</span>
    <span class="s3">// Otherwise the server action might be intercepted with the wrong action id</span>
    <span class="s3">// (ie, one that corresponds with the intercepted route)</span>
    <span class="s1">const </span><span class="s0">nextUrl = state.nextUrl &amp;&amp; (</span><span class="s4">0</span><span class="s0">, _hasinterceptionrouteincurrenttree.hasInterceptionRouteInCurrentTree)(state.tree) ? state.nextUrl : </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">navigatedAt = Date.now();</span>
    <span class="s1">return </span><span class="s0">fetchServerAction(state, nextUrl, action).then(async (param)=&gt;{</span>
        <span class="s1">let </span><span class="s0">{ actionResult, actionFlightData: flightData, redirectLocation, redirectType, isPrerender, revalidatedParts } = param;</span>
        <span class="s1">let </span><span class="s0">redirectHref;</span>
        <span class="s3">// honor the redirect type instead of defaulting to push in case of server actions.</span>
        <span class="s1">if </span><span class="s0">(redirectLocation) {</span>
            <span class="s1">if </span><span class="s0">(redirectType === _redirecterror.RedirectType.replace) {</span>
                <span class="s0">state.pushRef.pendingPush = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s0">mutable.pendingPush = </span><span class="s1">false</span><span class="s0">;</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">state.pushRef.pendingPush = </span><span class="s1">true</span><span class="s0">;</span>
                <span class="s0">mutable.pendingPush = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">}</span>
            <span class="s0">redirectHref = (</span><span class="s4">0</span><span class="s0">, _createhreffromurl.createHrefFromUrl)(redirectLocation, </span><span class="s1">false</span><span class="s0">);</span>
            <span class="s0">mutable.canonicalUrl = redirectHref;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(!flightData) {</span>
            <span class="s0">resolve(actionResult);</span>
            <span class="s3">// If there is a redirect but no flight data we need to do a mpaNavigation.</span>
            <span class="s1">if </span><span class="s0">(redirectLocation) {</span>
                <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _navigatereducer.handleExternalUrl)(state, mutable, redirectLocation.href, state.pushRef.pendingPush);</span>
            <span class="s0">}</span>
            <span class="s1">return </span><span class="s0">state;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">flightData === </span><span class="s2">'string'</span><span class="s0">) {</span>
            <span class="s3">// Handle case when navigating to page in `pages` from `app`</span>
            <span class="s0">resolve(actionResult);</span>
            <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _navigatereducer.handleExternalUrl)(state, mutable, flightData, state.pushRef.pendingPush);</span>
        <span class="s0">}</span>
        <span class="s1">const </span><span class="s0">actionRevalidated = revalidatedParts.paths.length &gt; </span><span class="s4">0 </span><span class="s0">|| revalidatedParts.tag || revalidatedParts.cookie;</span>
        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">normalizedFlightData of flightData){</span>
            <span class="s1">const </span><span class="s0">{ tree: treePatch, seedData: cacheNodeSeedData, head, isRootRender } = normalizedFlightData;</span>
            <span class="s1">if </span><span class="s0">(!isRootRender) {</span>
                <span class="s3">// TODO-APP: handle this case better</span>
                <span class="s0">console.log(</span><span class="s2">'SERVER ACTION APPLY FAILED'</span><span class="s0">);</span>
                <span class="s0">resolve(actionResult);</span>
                <span class="s1">return </span><span class="s0">state;</span>
            <span class="s0">}</span>
            <span class="s3">// Given the path can only have two items the items are only the router state and rsc for the root.</span>
            <span class="s1">const </span><span class="s0">newTree = (</span><span class="s4">0</span><span class="s0">, _applyrouterstatepatchtotree.applyRouterStatePatchToTree)([</span>
                <span class="s2">''</span>
            <span class="s0">], currentTree, treePatch, redirectHref ? redirectHref : state.canonicalUrl);</span>
            <span class="s1">if </span><span class="s0">(newTree === </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s0">resolve(actionResult);</span>
                <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _handlesegmentmismatch.handleSegmentMismatch)(state, action, treePatch);</span>
            <span class="s0">}</span>
            <span class="s1">if </span><span class="s0">((</span><span class="s4">0</span><span class="s0">, _isnavigatingtonewrootlayout.isNavigatingToNewRootLayout)(currentTree, newTree)) {</span>
                <span class="s0">resolve(actionResult);</span>
                <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _navigatereducer.handleExternalUrl)(state, mutable, redirectHref || state.canonicalUrl, state.pushRef.pendingPush);</span>
            <span class="s0">}</span>
            <span class="s3">// The server sent back RSC data for the server action, so we need to apply it to the cache.</span>
            <span class="s1">if </span><span class="s0">(cacheNodeSeedData !== </span><span class="s1">null</span><span class="s0">) {</span>
                <span class="s1">const </span><span class="s0">rsc = cacheNodeSeedData[</span><span class="s4">1</span><span class="s0">];</span>
                <span class="s1">const </span><span class="s0">cache = (</span><span class="s4">0</span><span class="s0">, _approuter.createEmptyCacheNode)();</span>
                <span class="s0">cache.rsc = rsc;</span>
                <span class="s0">cache.prefetchRsc = </span><span class="s1">null</span><span class="s0">;</span>
                <span class="s0">cache.loading = cacheNodeSeedData[</span><span class="s4">3</span><span class="s0">];</span>
                <span class="s0">(</span><span class="s4">0</span><span class="s0">, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(navigatedAt, cache, undefined, treePatch, cacheNodeSeedData, head, undefined);</span>
                <span class="s0">mutable.cache = cache;</span>
                <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) </span><span class="s3">//TURBOPACK unreachable</span>
                <span class="s0">;</span>
                <span class="s1">else </span><span class="s0">{</span>
                    <span class="s0">mutable.prefetchCache = </span><span class="s1">new </span><span class="s0">Map();</span>
                <span class="s0">}</span>
                <span class="s1">if </span><span class="s0">(actionRevalidated) {</span>
                    <span class="s1">await </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _refetchinactiveparallelsegments.refreshInactiveParallelSegments)({</span>
                        <span class="s0">navigatedAt,</span>
                        <span class="s0">state,</span>
                        <span class="s0">updatedTree: newTree,</span>
                        <span class="s0">updatedCache: cache,</span>
                        <span class="s0">includeNextUrl: Boolean(nextUrl),</span>
                        <span class="s0">canonicalUrl: mutable.canonicalUrl || state.canonicalUrl</span>
                    <span class="s0">});</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
            <span class="s0">mutable.patchedTree = newTree;</span>
            <span class="s0">currentTree = newTree;</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(redirectLocation &amp;&amp; redirectHref) {</span>
            <span class="s1">if </span><span class="s0">(!(</span><span class="s2">&quot;TURBOPACK compile-time value&quot;</span><span class="s0">, </span><span class="s1">false</span><span class="s0">) &amp;&amp; !actionRevalidated) {</span>
                <span class="s3">// Because the RedirectBoundary will trigger a navigation, we need to seed the prefetch cache</span>
                <span class="s3">// with the FlightData that we got from the server action for the target page, so that it's</span>
                <span class="s3">// available when the page is navigated to and doesn't need to be re-fetched.</span>
                <span class="s3">// We only do this if the server action didn't revalidate any data, as in that case the</span>
                <span class="s3">// client cache will be cleared and the data will be re-fetched anyway.</span>
                <span class="s3">// NOTE: We don't do this in the Segment Cache implementation.</span>
                <span class="s3">// Dynamic data should never be placed into the cache, unless it's</span>
                <span class="s3">// &quot;converted&quot; to static data using &lt;Link prefetch={true}&gt;. What we</span>
                <span class="s3">// do instead is re-prefetch links and forms whenever the cache is</span>
                <span class="s3">// invalidated.</span>
                <span class="s0">(</span><span class="s4">0</span><span class="s0">, _prefetchcacheutils.createSeededPrefetchCacheEntry)({</span>
                    <span class="s0">url: redirectLocation,</span>
                    <span class="s0">data: {</span>
                        <span class="s0">flightData,</span>
                        <span class="s0">canonicalUrl: undefined,</span>
                        <span class="s0">couldBeIntercepted: </span><span class="s1">false</span><span class="s0">,</span>
                        <span class="s0">prerendered: </span><span class="s1">false</span><span class="s0">,</span>
                        <span class="s0">postponed: </span><span class="s1">false</span><span class="s0">,</span>
                        <span class="s3">// TODO: We should be able to set this if the server action</span>
                        <span class="s3">// returned a fully static response.</span>
                        <span class="s0">staleTime: -</span><span class="s4">1</span>
                    <span class="s0">},</span>
                    <span class="s0">tree: state.tree,</span>
                    <span class="s0">prefetchCache: state.prefetchCache,</span>
                    <span class="s0">nextUrl: state.nextUrl,</span>
                    <span class="s0">kind: isPrerender ? _routerreducertypes.PrefetchKind.FULL : _routerreducertypes.PrefetchKind.AUTO</span>
                <span class="s0">});</span>
                <span class="s0">mutable.prefetchCache = state.prefetchCache;</span>
            <span class="s0">}</span>
            <span class="s3">// If the action triggered a redirect, the action promise will be rejected with</span>
            <span class="s3">// a redirect so that it's handled by RedirectBoundary as we won't have a valid</span>
            <span class="s3">// action result to resolve the promise with. This will effectively reset the state of</span>
            <span class="s3">// the component that called the action as the error boundary will remount the tree.</span>
            <span class="s3">// The status code doesn't matter here as the action handler will have already sent</span>
            <span class="s3">// a response with the correct status code.</span>
            <span class="s0">reject((</span><span class="s4">0</span><span class="s0">, _redirect.getRedirectError)((</span><span class="s4">0</span><span class="s0">, _hasbasepath.hasBasePath)(redirectHref) ? (</span><span class="s4">0</span><span class="s0">, _removebasepath.removeBasePath)(redirectHref) : redirectHref, redirectType || _redirecterror.RedirectType.push));</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">resolve(actionResult);</span>
        <span class="s0">}</span>
        <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _handlemutable.handleMutable)(state, mutable);</span>
    <span class="s0">}, (e)=&gt;{</span>
        <span class="s3">// When the server action is rejected we don't update the state and instead call the reject handler of the promise.</span>
        <span class="s0">reject(e);</span>
        <span class="s1">return </span><span class="s0">state;</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=server-action-reducer.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/router-reducer.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;reducer&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">reducer;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_routerreducertypes = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_navigatereducer = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/reducers/navigate-reducer.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_serverpatchreducer = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/reducers/server-patch-reducer.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_restorereducer = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/reducers/restore-reducer.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_refreshreducer = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/reducers/refresh-reducer.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_prefetchreducer = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_hmrrefreshreducer = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/reducers/hmr-refresh-reducer.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_serveractionreducer = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/reducers/server-action-reducer.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s3">/**</span>
 <span class="s3">* Reducer that handles the app-router state updates.</span>
 <span class="s3">*/ </span><span class="s1">function </span><span class="s0">clientReducer(state, action) {</span>
    <span class="s1">switch</span><span class="s0">(action.type){</span>
        <span class="s1">case </span><span class="s0">_routerreducertypes.ACTION_NAVIGATE:</span>
            <span class="s0">{</span>
                <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _navigatereducer.navigateReducer)(state, action);</span>
            <span class="s0">}</span>
        <span class="s1">case </span><span class="s0">_routerreducertypes.ACTION_SERVER_PATCH:</span>
            <span class="s0">{</span>
                <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _serverpatchreducer.serverPatchReducer)(state, action);</span>
            <span class="s0">}</span>
        <span class="s1">case </span><span class="s0">_routerreducertypes.ACTION_RESTORE:</span>
            <span class="s0">{</span>
                <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _restorereducer.restoreReducer)(state, action);</span>
            <span class="s0">}</span>
        <span class="s1">case </span><span class="s0">_routerreducertypes.ACTION_REFRESH:</span>
            <span class="s0">{</span>
                <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _refreshreducer.refreshReducer)(state, action);</span>
            <span class="s0">}</span>
        <span class="s1">case </span><span class="s0">_routerreducertypes.ACTION_HMR_REFRESH:</span>
            <span class="s0">{</span>
                <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _hmrrefreshreducer.hmrRefreshReducer)(state, action);</span>
            <span class="s0">}</span>
        <span class="s1">case </span><span class="s0">_routerreducertypes.ACTION_PREFETCH:</span>
            <span class="s0">{</span>
                <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _prefetchreducer.prefetchReducer)(state, action);</span>
            <span class="s0">}</span>
        <span class="s1">case </span><span class="s0">_routerreducertypes.ACTION_SERVER_ACTION:</span>
            <span class="s0">{</span>
                <span class="s1">return </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _serveractionreducer.serverActionReducer)(state, action);</span>
            <span class="s0">}</span>
        <span class="s3">// This case should never be hit as dispatch is strongly typed.</span>
        <span class="s1">default</span><span class="s0">:</span>
            <span class="s1">throw </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">Error(</span><span class="s2">'Unknown action'</span><span class="s0">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
                <span class="s0">value: </span><span class="s2">&quot;E295&quot;</span><span class="s0">,</span>
                <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
                <span class="s0">configurable: </span><span class="s1">true</span>
            <span class="s0">});</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">serverReducer(state, _action) {</span>
    <span class="s1">return </span><span class="s0">state;</span>
<span class="s0">}</span>
<span class="s1">const </span><span class="s0">reducer = </span><span class="s1">typeof </span><span class="s0">window === </span><span class="s2">'undefined' </span><span class="s0">? serverReducer : clientReducer;</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=router-reducer.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/app-router-instance.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s4">0 </span><span class="s0">&amp;&amp; (module.exports = {</span>
    <span class="s0">createMutableActionQueue: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">dispatchNavigateAction: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">dispatchTraverseAction: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">getCurrentAppRouterState: </span><span class="s1">null</span><span class="s0">,</span>
    <span class="s0">publicAppRouterInstance: </span><span class="s1">null</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">_export(target, all) {</span>
    <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">name </span><span class="s1">in </span><span class="s0">all)Object.defineProperty(target, name, {</span>
        <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
        <span class="s0">get: all[name]</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s0">_export(exports, {</span>
    <span class="s0">createMutableActionQueue: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">createMutableActionQueue;</span>
    <span class="s0">},</span>
    <span class="s0">dispatchNavigateAction: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">dispatchNavigateAction;</span>
    <span class="s0">},</span>
    <span class="s0">dispatchTraverseAction: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">dispatchTraverseAction;</span>
    <span class="s0">},</span>
    <span class="s0">getCurrentAppRouterState: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">getCurrentAppRouterState;</span>
    <span class="s0">},</span>
    <span class="s0">publicAppRouterInstance: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">publicAppRouterInstance;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_routerreducertypes = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_routerreducer = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/router-reducer.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_react = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_isthenable = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/is-thenable.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_segmentcache = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/segment-cache.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_useactionqueue = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/use-action-queue.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_addbasepath = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/add-base-path.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_approuter = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/app-router.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_prefetchreducer = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/reducers/prefetch-reducer.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_links = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/links.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">runRemainingActions(actionQueue, setState) {</span>
    <span class="s1">if </span><span class="s0">(actionQueue.pending !== </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">actionQueue.pending = actionQueue.pending.next;</span>
        <span class="s1">if </span><span class="s0">(actionQueue.pending !== </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s3">// eslint-disable-next-line @typescript-eslint/no-use-before-define</span>
            <span class="s0">runAction({</span>
                <span class="s0">actionQueue,</span>
                <span class="s0">action: actionQueue.pending,</span>
                <span class="s0">setState</span>
            <span class="s0">});</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s3">// No more actions are pending, check if a refresh is needed</span>
            <span class="s1">if </span><span class="s0">(actionQueue.needsRefresh) {</span>
                <span class="s0">actionQueue.needsRefresh = </span><span class="s1">false</span><span class="s0">;</span>
                <span class="s0">actionQueue.dispatch({</span>
                    <span class="s0">type: _routerreducertypes.ACTION_REFRESH,</span>
                    <span class="s0">origin: window.location.origin</span>
                <span class="s0">}, setState);</span>
            <span class="s0">}</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s0">async </span><span class="s1">function </span><span class="s0">runAction(param) {</span>
    <span class="s1">let </span><span class="s0">{ actionQueue, action, setState } = param;</span>
    <span class="s1">const </span><span class="s0">prevState = actionQueue.state;</span>
    <span class="s0">actionQueue.pending = action;</span>
    <span class="s1">const </span><span class="s0">payload = action.payload;</span>
    <span class="s1">const </span><span class="s0">actionResult = actionQueue.action(prevState, payload);</span>
    <span class="s1">function </span><span class="s0">handleResult(nextState) {</span>
        <span class="s3">// if we discarded this action, the state should also be discarded</span>
        <span class="s1">if </span><span class="s0">(action.discarded) {</span>
            <span class="s1">return</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">actionQueue.state = nextState;</span>
        <span class="s0">runRemainingActions(actionQueue, setState);</span>
        <span class="s0">action.resolve(nextState);</span>
    <span class="s0">}</span>
    <span class="s3">// if the action is a promise, set up a callback to resolve it</span>
    <span class="s1">if </span><span class="s0">((</span><span class="s4">0</span><span class="s0">, _isthenable.isThenable)(actionResult)) {</span>
        <span class="s0">actionResult.then(handleResult, (err)=&gt;{</span>
            <span class="s0">runRemainingActions(actionQueue, setState);</span>
            <span class="s0">action.reject(err);</span>
        <span class="s0">});</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">handleResult(actionResult);</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">dispatchAction(actionQueue, payload, setState) {</span>
    <span class="s1">let </span><span class="s0">resolvers = {</span>
        <span class="s0">resolve: setState,</span>
        <span class="s0">reject: ()=&gt;{}</span>
    <span class="s0">};</span>
    <span class="s3">// most of the action types are async with the exception of restore</span>
    <span class="s3">// it's important that restore is handled quickly since it's fired on the popstate event</span>
    <span class="s3">// and we don't want to add any delay on a back/forward nav</span>
    <span class="s3">// this only creates a promise for the async actions</span>
    <span class="s1">if </span><span class="s0">(payload.type !== _routerreducertypes.ACTION_RESTORE) {</span>
        <span class="s3">// Create the promise and assign the resolvers to the object.</span>
        <span class="s1">const </span><span class="s0">deferredPromise = </span><span class="s1">new </span><span class="s0">Promise((resolve, reject)=&gt;{</span>
            <span class="s0">resolvers = {</span>
                <span class="s0">resolve,</span>
                <span class="s0">reject</span>
            <span class="s0">};</span>
        <span class="s0">});</span>
        <span class="s0">(</span><span class="s4">0</span><span class="s0">, _react.startTransition)(()=&gt;{</span>
            <span class="s3">// we immediately notify React of the pending promise -- the resolver is attached to the action node</span>
            <span class="s3">// and will be called when the associated action promise resolves</span>
            <span class="s0">setState(deferredPromise);</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">const </span><span class="s0">newAction = {</span>
        <span class="s0">payload,</span>
        <span class="s0">next: </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">resolve: resolvers.resolve,</span>
        <span class="s0">reject: resolvers.reject</span>
    <span class="s0">};</span>
    <span class="s3">// Check if the queue is empty</span>
    <span class="s1">if </span><span class="s0">(actionQueue.pending === </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s3">// The queue is empty, so add the action and start it immediately</span>
        <span class="s3">// Mark this action as the last in the queue</span>
        <span class="s0">actionQueue.last = newAction;</span>
        <span class="s0">runAction({</span>
            <span class="s0">actionQueue,</span>
            <span class="s0">action: newAction,</span>
            <span class="s0">setState</span>
        <span class="s0">});</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(payload.type === _routerreducertypes.ACTION_NAVIGATE || payload.type === _routerreducertypes.ACTION_RESTORE) {</span>
        <span class="s3">// Navigations (including back/forward) take priority over any pending actions.</span>
        <span class="s3">// Mark the pending action as discarded (so the state is never applied) and start the navigation action immediately.</span>
        <span class="s0">actionQueue.pending.discarded = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s3">// The rest of the current queue should still execute after this navigation.</span>
        <span class="s3">// (Note that it can't contain any earlier navigations, because we always put those into `actionQueue.pending` by calling `runAction`)</span>
        <span class="s0">newAction.next = actionQueue.pending.next;</span>
        <span class="s3">// if the pending action was a server action, mark the queue as needing a refresh once events are processed</span>
        <span class="s1">if </span><span class="s0">(actionQueue.pending.payload.type === _routerreducertypes.ACTION_SERVER_ACTION) {</span>
            <span class="s0">actionQueue.needsRefresh = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s0">}</span>
        <span class="s0">runAction({</span>
            <span class="s0">actionQueue,</span>
            <span class="s0">action: newAction,</span>
            <span class="s0">setState</span>
        <span class="s0">});</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s3">// The queue is not empty, so add the action to the end of the queue</span>
        <span class="s3">// It will be started by runRemainingActions after the previous action finishes</span>
        <span class="s1">if </span><span class="s0">(actionQueue.last !== </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s0">actionQueue.last.next = newAction;</span>
        <span class="s0">}</span>
        <span class="s0">actionQueue.last = newAction;</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">let </span><span class="s0">globalActionQueue = </span><span class="s1">null</span><span class="s0">;</span>
<span class="s1">function </span><span class="s0">createMutableActionQueue(initialState, instrumentationHooks) {</span>
    <span class="s1">const </span><span class="s0">actionQueue = {</span>
        <span class="s0">state: initialState,</span>
        <span class="s0">dispatch: (payload, setState)=&gt;dispatchAction(actionQueue, payload, setState),</span>
        <span class="s0">action: async (state, action)=&gt;{</span>
            <span class="s1">const </span><span class="s0">result = (</span><span class="s4">0</span><span class="s0">, _routerreducer.reducer)(state, action);</span>
            <span class="s1">return </span><span class="s0">result;</span>
        <span class="s0">},</span>
        <span class="s0">pending: </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">last: </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">onRouterTransitionStart: instrumentationHooks !== </span><span class="s1">null </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">instrumentationHooks.onRouterTransitionStart === </span><span class="s2">'function' </span><span class="s0">? instrumentationHooks.onRouterTransitionStart : </span><span class="s1">null</span>
    <span class="s0">};</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">window !== </span><span class="s2">'undefined'</span><span class="s0">) {</span>
        <span class="s3">// The action queue is lazily created on hydration, but after that point</span>
        <span class="s3">// it doesn't change. So we can store it in a global rather than pass</span>
        <span class="s3">// it around everywhere via props/context.</span>
        <span class="s1">if </span><span class="s0">(globalActionQueue !== </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s1">throw </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">Error(</span><span class="s2">'Internal Next.js Error: createMutableActionQueue was called more ' </span><span class="s0">+ </span><span class="s2">'than once'</span><span class="s0">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
                <span class="s0">value: </span><span class="s2">&quot;E624&quot;</span><span class="s0">,</span>
                <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
                <span class="s0">configurable: </span><span class="s1">true</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s0">globalActionQueue = actionQueue;</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">actionQueue;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">getCurrentAppRouterState() {</span>
    <span class="s1">return </span><span class="s0">globalActionQueue !== </span><span class="s1">null </span><span class="s0">? globalActionQueue.state : </span><span class="s1">null</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">getAppRouterActionQueue() {</span>
    <span class="s1">if </span><span class="s0">(globalActionQueue === </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s1">throw </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">Error(</span><span class="s2">'Internal Next.js error: Router action dispatched before initialization.'</span><span class="s0">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
            <span class="s0">value: </span><span class="s2">&quot;E668&quot;</span><span class="s0">,</span>
            <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">configurable: </span><span class="s1">true</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">globalActionQueue;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">getProfilingHookForOnNavigationStart() {</span>
    <span class="s1">if </span><span class="s0">(globalActionQueue !== </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s1">return </span><span class="s0">globalActionQueue.onRouterTransitionStart;</span>
    <span class="s0">}</span>
    <span class="s1">return null</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">dispatchNavigateAction(href, navigateType, shouldScroll, linkInstanceRef) {</span>
    <span class="s3">// TODO: This stuff could just go into the reducer. Leaving as-is for now</span>
    <span class="s3">// since we're about to rewrite all the router reducer stuff anyway.</span>
    <span class="s1">const </span><span class="s0">url = </span><span class="s1">new </span><span class="s0">URL((</span><span class="s4">0</span><span class="s0">, _addbasepath.addBasePath)(href), location.href);</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) </span><span class="s3">//TURBOPACK unreachable</span>
    <span class="s0">;</span>
    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _links.setLinkForCurrentNavigation)(linkInstanceRef);</span>
    <span class="s1">const </span><span class="s0">onRouterTransitionStart = getProfilingHookForOnNavigationStart();</span>
    <span class="s1">if </span><span class="s0">(onRouterTransitionStart !== </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">onRouterTransitionStart(href, navigateType);</span>
    <span class="s0">}</span>
    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _useactionqueue.dispatchAppRouterAction)({</span>
        <span class="s0">type: _routerreducertypes.ACTION_NAVIGATE,</span>
        <span class="s0">url,</span>
        <span class="s0">isExternalUrl: (</span><span class="s4">0</span><span class="s0">, _approuter.isExternalURL)(url),</span>
        <span class="s0">locationSearch: location.search,</span>
        <span class="s0">shouldScroll,</span>
        <span class="s0">navigateType,</span>
        <span class="s0">allowAliasing: </span><span class="s1">true</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">dispatchTraverseAction(href, tree) {</span>
    <span class="s1">const </span><span class="s0">onRouterTransitionStart = getProfilingHookForOnNavigationStart();</span>
    <span class="s1">if </span><span class="s0">(onRouterTransitionStart !== </span><span class="s1">null</span><span class="s0">) {</span>
        <span class="s0">onRouterTransitionStart(href, </span><span class="s2">'traverse'</span><span class="s0">);</span>
    <span class="s0">}</span>
    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _useactionqueue.dispatchAppRouterAction)({</span>
        <span class="s0">type: _routerreducertypes.ACTION_RESTORE,</span>
        <span class="s0">url: </span><span class="s1">new </span><span class="s0">URL(href),</span>
        <span class="s0">tree</span>
    <span class="s0">});</span>
<span class="s0">}</span>
<span class="s1">const </span><span class="s0">publicAppRouterInstance = {</span>
    <span class="s0">back: ()=&gt;window.history.back(),</span>
    <span class="s0">forward: ()=&gt;window.history.forward(),</span>
    <span class="s0">prefetch: (</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) ? </span><span class="s3">// cache. So we don't need to dispatch an action.</span>
    <span class="s2">&quot;TURBOPACK unreachable&quot; </span><span class="s0">: (href, options)=&gt;{</span>
        <span class="s3">// Use the old prefetch implementation.</span>
        <span class="s1">const </span><span class="s0">actionQueue = getAppRouterActionQueue();</span>
        <span class="s1">const </span><span class="s0">url = (</span><span class="s4">0</span><span class="s0">, _approuter.createPrefetchURL)(href);</span>
        <span class="s1">if </span><span class="s0">(url !== </span><span class="s1">null</span><span class="s0">) {</span>
            <span class="s1">var </span><span class="s0">_options_kind;</span>
            <span class="s3">// The prefetch reducer doesn't actually update any state or</span>
            <span class="s3">// trigger a rerender. It just writes to a mutable cache. So we</span>
            <span class="s3">// shouldn't bother calling setState/dispatch; we can just re-run</span>
            <span class="s3">// the reducer directly using the current state.</span>
            <span class="s3">// TODO: Refactor this away from a &quot;reducer&quot; so it's</span>
            <span class="s3">// less confusing.</span>
            <span class="s0">(</span><span class="s4">0</span><span class="s0">, _prefetchreducer.prefetchReducer)(actionQueue.state, {</span>
                <span class="s0">type: _routerreducertypes.ACTION_PREFETCH,</span>
                <span class="s0">url,</span>
                <span class="s0">kind: (_options_kind = options == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: options.kind) != </span><span class="s1">null </span><span class="s0">? _options_kind : _routerreducertypes.PrefetchKind.FULL</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
    <span class="s0">},</span>
    <span class="s0">replace: (href, options)=&gt;{</span>
        <span class="s0">(</span><span class="s4">0</span><span class="s0">, _react.startTransition)(()=&gt;{</span>
            <span class="s1">var </span><span class="s0">_options_scroll;</span>
            <span class="s0">dispatchNavigateAction(href, </span><span class="s2">'replace'</span><span class="s0">, (_options_scroll = options == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: options.scroll) != </span><span class="s1">null </span><span class="s0">? _options_scroll : </span><span class="s1">true</span><span class="s0">, </span><span class="s1">null</span><span class="s0">);</span>
        <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s0">push: (href, options)=&gt;{</span>
        <span class="s0">(</span><span class="s4">0</span><span class="s0">, _react.startTransition)(()=&gt;{</span>
            <span class="s1">var </span><span class="s0">_options_scroll;</span>
            <span class="s0">dispatchNavigateAction(href, </span><span class="s2">'push'</span><span class="s0">, (_options_scroll = options == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: options.scroll) != </span><span class="s1">null </span><span class="s0">? _options_scroll : </span><span class="s1">true</span><span class="s0">, </span><span class="s1">null</span><span class="s0">);</span>
        <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s0">refresh: ()=&gt;{</span>
        <span class="s0">(</span><span class="s4">0</span><span class="s0">, _react.startTransition)(()=&gt;{</span>
            <span class="s0">(</span><span class="s4">0</span><span class="s0">, _useactionqueue.dispatchAppRouterAction)({</span>
                <span class="s0">type: _routerreducertypes.ACTION_REFRESH,</span>
                <span class="s0">origin: window.location.origin</span>
            <span class="s0">});</span>
        <span class="s0">});</span>
    <span class="s0">},</span>
    <span class="s0">hmrRefresh: ()=&gt;{</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) </span><span class="s3">//TURBOPACK unreachable</span>
        <span class="s0">;</span>
        <span class="s1">else </span><span class="s0">{</span>
            <span class="s0">(</span><span class="s4">0</span><span class="s0">, _react.startTransition)(()=&gt;{</span>
                <span class="s0">(</span><span class="s4">0</span><span class="s0">, _useactionqueue.dispatchAppRouterAction)({</span>
                    <span class="s0">type: _routerreducertypes.ACTION_HMR_REFRESH,</span>
                    <span class="s0">origin: window.location.origin</span>
                <span class="s0">});</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">};</span>
<span class="s3">// Exists for debugging purposes. Don't use in application code.</span>
<span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">window !== </span><span class="s2">'undefined' </span><span class="s0">&amp;&amp; window.next) {</span>
    <span class="s0">window.next.router = publicAppRouterInstance;</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=app-router-instance.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/create-initial-router-state.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;createInitialRouterState&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">createInitialRouterState;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_createhreffromurl = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/create-href-from-url.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_filllazyitemstillleafwithhead = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_computechangedpath = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/compute-changed-path.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_prefetchcacheutils = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/prefetch-cache-utils.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_routerreducertypes = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/router-reducer-types.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_refetchinactiveparallelsegments = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/refetch-inactive-parallel-segments.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_flightdatahelpers = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/flight-data-helpers.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">function </span><span class="s0">createInitialRouterState(param) {</span>
    <span class="s1">let </span><span class="s0">{ navigatedAt, initialFlightData, initialCanonicalUrlParts, initialParallelRoutes, location, couldBeIntercepted, postponed, prerendered } = param;</span>
    <span class="s3">// When initialized on the server, the canonical URL is provided as an array of parts.</span>
    <span class="s3">// This is to ensure that when the RSC payload streamed to the client, crawlers don't interpret it</span>
    <span class="s3">// as a URL that should be crawled.</span>
    <span class="s1">const </span><span class="s0">initialCanonicalUrl = initialCanonicalUrlParts.join(</span><span class="s2">'/'</span><span class="s0">);</span>
    <span class="s1">const </span><span class="s0">normalizedFlightData = (</span><span class="s4">0</span><span class="s0">, _flightdatahelpers.getFlightDataPartsFromPath)(initialFlightData[</span><span class="s4">0</span><span class="s0">]);</span>
    <span class="s1">const </span><span class="s0">{ tree: initialTree, seedData: initialSeedData, head: initialHead } = normalizedFlightData;</span>
    <span class="s3">// For the SSR render, seed data should always be available (we only send back a `null` response</span>
    <span class="s3">// in the case of a `loading` segment, pre-PPR.)</span>
    <span class="s1">const </span><span class="s0">rsc = initialSeedData == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: initialSeedData[</span><span class="s4">1</span><span class="s0">];</span>
    <span class="s1">var </span><span class="s0">_initialSeedData_;</span>
    <span class="s1">const </span><span class="s0">loading = (_initialSeedData_ = initialSeedData == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: initialSeedData[</span><span class="s4">3</span><span class="s0">]) != </span><span class="s1">null </span><span class="s0">? _initialSeedData_ : </span><span class="s1">null</span><span class="s0">;</span>
    <span class="s1">const </span><span class="s0">cache = {</span>
        <span class="s0">lazyData: </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">rsc,</span>
        <span class="s0">prefetchRsc: </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">head: </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s0">prefetchHead: </span><span class="s1">null</span><span class="s0">,</span>
        <span class="s3">// The cache gets seeded during the first render. `initialParallelRoutes` ensures the cache from the first render is there during the second render.</span>
        <span class="s0">parallelRoutes: initialParallelRoutes,</span>
        <span class="s0">loading,</span>
        <span class="s0">navigatedAt</span>
    <span class="s0">};</span>
    <span class="s1">const </span><span class="s0">canonicalUrl = </span><span class="s3">// This is safe to do as canonicalUrl can't be rendered, it's only used to control the history updates in the useEffect further down in this file.</span>
    <span class="s0">location ? (</span><span class="s4">0</span><span class="s0">, _createhreffromurl.createHrefFromUrl)(location) : initialCanonicalUrl;</span>
    <span class="s0">(</span><span class="s4">0</span><span class="s0">, _refetchinactiveparallelsegments.addRefreshMarkerToActiveParallelSegments)(initialTree, canonicalUrl);</span>
    <span class="s1">const </span><span class="s0">prefetchCache = </span><span class="s1">new </span><span class="s0">Map();</span>
    <span class="s3">// When the cache hasn't been seeded yet we fill the cache with the head.</span>
    <span class="s1">if </span><span class="s0">(initialParallelRoutes === </span><span class="s1">null </span><span class="s0">|| initialParallelRoutes.size === </span><span class="s4">0</span><span class="s0">) {</span>
        <span class="s0">(</span><span class="s4">0</span><span class="s0">, _filllazyitemstillleafwithhead.fillLazyItemsTillLeafWithHead)(navigatedAt, cache, undefined, initialTree, initialSeedData, initialHead, undefined);</span>
    <span class="s0">}</span>
    <span class="s1">var </span><span class="s0">_ref;</span>
    <span class="s1">const </span><span class="s0">initialState = {</span>
        <span class="s0">tree: initialTree,</span>
        <span class="s0">cache,</span>
        <span class="s0">prefetchCache,</span>
        <span class="s0">pushRef: {</span>
            <span class="s0">pendingPush: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">mpaNavigation: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s3">// First render needs to preserve the previous window.history.state</span>
            <span class="s3">// to avoid it being overwritten on navigation back/forward with MPA Navigation.</span>
            <span class="s0">preserveCustomHistoryState: </span><span class="s1">true</span>
        <span class="s0">},</span>
        <span class="s0">focusAndScrollRef: {</span>
            <span class="s0">apply: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">onlyHashChange: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">hashFragment: </span><span class="s1">null</span><span class="s0">,</span>
            <span class="s0">segmentPaths: []</span>
        <span class="s0">},</span>
        <span class="s0">canonicalUrl,</span>
        <span class="s0">nextUrl: (_ref = (</span><span class="s4">0</span><span class="s0">, _computechangedpath.extractPathFromFlightRouterState)(initialTree) || (location == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: location.pathname)) != </span><span class="s1">null </span><span class="s0">? _ref : </span><span class="s1">null</span>
    <span class="s0">};</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) </span><span class="s3">//TURBOPACK unreachable</span>
    <span class="s0">;</span>
    <span class="s1">return </span><span class="s0">initialState;</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=create-initial-router-state.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/app-link-gc.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;linkGc&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">linkGc;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">linkGc() {</span>
    <span class="s3">// TODO-APP: Remove this logic when Float has GC built-in in development.</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s0">) {</span>
        <span class="s1">const </span><span class="s0">callback = (mutationList)=&gt;{</span>
            <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">mutation of mutationList){</span>
                <span class="s1">if </span><span class="s0">(mutation.type === </span><span class="s2">'childList'</span><span class="s0">) {</span>
                    <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">node of mutation.addedNodes){</span>
                        <span class="s1">if </span><span class="s0">(</span><span class="s2">'tagName' </span><span class="s1">in </span><span class="s0">node &amp;&amp; node.tagName === </span><span class="s2">'LINK'</span><span class="s0">) {</span>
                            <span class="s1">var </span><span class="s0">_link_dataset_precedence;</span>
                            <span class="s1">const </span><span class="s0">link = node;</span>
                            <span class="s1">if </span><span class="s0">((_link_dataset_precedence = link.dataset.precedence) == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: _link_dataset_precedence.startsWith(</span><span class="s2">'next'</span><span class="s0">)) {</span>
                                <span class="s1">const </span><span class="s0">href = link.getAttribute(</span><span class="s2">'href'</span><span class="s0">);</span>
                                <span class="s1">if </span><span class="s0">(href) {</span>
                                    <span class="s1">const </span><span class="s0">[resource, version] = href.split(</span><span class="s2">'?v='</span><span class="s0">, </span><span class="s4">2</span><span class="s0">);</span>
                                    <span class="s1">if </span><span class="s0">(version) {</span>
                                        <span class="s1">const </span><span class="s0">currentOrigin = window.location.origin;</span>
                                        <span class="s1">const </span><span class="s0">allLinks = [</span>
                                            <span class="s0">...document.querySelectorAll(</span><span class="s2">'link[href^=&quot;' </span><span class="s0">+ resource + </span><span class="s2">'&quot;]'</span><span class="s0">),</span>
                                            <span class="s3">// It's possible that the resource is a full URL or only pathname,</span>
                                            <span class="s3">// so we need to remove the alternative href as well.</span>
                                            <span class="s0">...document.querySelectorAll(</span><span class="s2">'link[href^=&quot;' </span><span class="s0">+ (resource.startsWith(currentOrigin) ? resource.slice(currentOrigin.length) : currentOrigin + resource) + </span><span class="s2">'&quot;]'</span><span class="s0">)</span>
                                        <span class="s0">];</span>
                                        <span class="s1">for </span><span class="s0">(</span><span class="s1">const </span><span class="s0">otherLink of allLinks){</span>
                                            <span class="s1">var </span><span class="s0">_otherLink_dataset_precedence;</span>
                                            <span class="s1">if </span><span class="s0">((_otherLink_dataset_precedence = otherLink.dataset.precedence) == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">void </span><span class="s4">0 </span><span class="s0">: _otherLink_dataset_precedence.startsWith(</span><span class="s2">'next'</span><span class="s0">)) {</span>
                                                <span class="s1">const </span><span class="s0">otherHref = otherLink.getAttribute(</span><span class="s2">'href'</span><span class="s0">);</span>
                                                <span class="s1">if </span><span class="s0">(otherHref) {</span>
                                                    <span class="s1">const </span><span class="s0">[, otherVersion] = otherHref.split(</span><span class="s2">'?v='</span><span class="s0">, </span><span class="s4">2</span><span class="s0">);</span>
                                                    <span class="s1">if </span><span class="s0">(!otherVersion || +otherVersion &lt; +version) {</span>
                                                        <span class="s3">// Delay the removal of the stylesheet to avoid FOUC</span>
                                                        <span class="s3">// caused by `@font-face` rules, as they seem to be</span>
                                                        <span class="s3">// a couple of ticks delayed between the old and new</span>
                                                        <span class="s3">// styles being swapped even if the font is cached.</span>
                                                        <span class="s0">setTimeout(()=&gt;{</span>
                                                            <span class="s0">otherLink.remove();</span>
                                                        <span class="s0">}, </span><span class="s4">5</span><span class="s0">);</span>
                                                        <span class="s1">const </span><span class="s0">preloadLink = document.querySelector(</span><span class="s2">'link[rel=&quot;preload&quot;][as=&quot;style&quot;][href=&quot;' </span><span class="s0">+ otherHref + </span><span class="s2">'&quot;]'</span><span class="s0">);</span>
                                                        <span class="s1">if </span><span class="s0">(preloadLink) {</span>
                                                            <span class="s0">preloadLink.remove();</span>
                                                        <span class="s0">}</span>
                                                    <span class="s0">}</span>
                                                <span class="s0">}</span>
                                            <span class="s0">}</span>
                                        <span class="s0">}</span>
                                    <span class="s0">}</span>
                                <span class="s0">}</span>
                            <span class="s0">}</span>
                        <span class="s0">}</span>
                    <span class="s0">}</span>
                <span class="s0">}</span>
            <span class="s0">}</span>
        <span class="s0">};</span>
        <span class="s3">// Create an observer instance linked to the callback function</span>
        <span class="s1">const </span><span class="s0">observer = </span><span class="s1">new </span><span class="s0">MutationObserver(callback);</span>
        <span class="s0">observer.observe(document.head, {</span>
            <span class="s0">childList: </span><span class="s1">true</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=app-link-gc.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/app-index.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;hydrate&quot;</span><span class="s0">, {</span>
    <span class="s0">enumerable: </span><span class="s1">true</span><span class="s0">,</span>
    <span class="s0">get: </span><span class="s1">function</span><span class="s0">() {</span>
        <span class="s1">return </span><span class="s0">hydrate;</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_interop_require_default = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/@swc/helpers/cjs/_interop_require_default.cjs [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_interop_require_wildcard = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/@swc/helpers/cjs/_interop_require_wildcard.cjs [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_jsxruntime = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react/jsx-runtime.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s0">__turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/app-globals.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_client = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">_interop_require_default._(__turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react-dom/client.js [app-client] (ecmascript)&quot;</span><span class="s0">));</span>
<span class="s1">const </span><span class="s0">_react = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">_interop_require_wildcard._(__turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)&quot;</span><span class="s0">));</span>
<span class="s1">const </span><span class="s0">_client1 = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/react-server-dom-turbopack/client.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_headmanagercontextsharedruntime = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_onrecoverableerror = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/react-client-callbacks/on-recoverable-error.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_errorboundarycallbacks = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/react-client-callbacks/error-boundary-callbacks.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_appcallserver = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/app-call-server.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_appfindsourcemapurl = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/app-find-source-map-url.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_approuterinstance = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/app-router-instance.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_approuter = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">_interop_require_default._(__turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/app-router.js [app-client] (ecmascript)&quot;</span><span class="s0">));</span>
<span class="s1">const </span><span class="s0">_createinitialrouterstate = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/components/router-reducer/create-initial-router-state.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_approutercontextsharedruntime = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_appbuildid = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/app-build-id.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s3">/// &lt;reference types=&quot;react-dom/experimental&quot; /&gt;</span>
<span class="s1">const </span><span class="s0">createFromReadableStream = _client1.createFromReadableStream;</span>
<span class="s1">const </span><span class="s0">appElement = document;</span>
<span class="s1">const </span><span class="s0">encoder = </span><span class="s1">new </span><span class="s0">TextEncoder();</span>
<span class="s1">let </span><span class="s0">initialServerDataBuffer = undefined;</span>
<span class="s1">let </span><span class="s0">initialServerDataWriter = undefined;</span>
<span class="s1">let </span><span class="s0">initialServerDataLoaded = </span><span class="s1">false</span><span class="s0">;</span>
<span class="s1">let </span><span class="s0">initialServerDataFlushed = </span><span class="s1">false</span><span class="s0">;</span>
<span class="s1">let </span><span class="s0">initialFormStateData = </span><span class="s1">null</span><span class="s0">;</span>
<span class="s1">function </span><span class="s0">nextServerDataCallback(seg) {</span>
    <span class="s1">if </span><span class="s0">(seg[</span><span class="s4">0</span><span class="s0">] === </span><span class="s4">0</span><span class="s0">) {</span>
        <span class="s0">initialServerDataBuffer = [];</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(seg[</span><span class="s4">0</span><span class="s0">] === </span><span class="s4">1</span><span class="s0">) {</span>
        <span class="s1">if </span><span class="s0">(!initialServerDataBuffer) </span><span class="s1">throw </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">Error(</span><span class="s2">'Unexpected server data: missing bootstrap script.'</span><span class="s0">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
            <span class="s0">value: </span><span class="s2">&quot;E18&quot;</span><span class="s0">,</span>
            <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">configurable: </span><span class="s1">true</span>
        <span class="s0">});</span>
        <span class="s1">if </span><span class="s0">(initialServerDataWriter) {</span>
            <span class="s0">initialServerDataWriter.enqueue(encoder.encode(seg[</span><span class="s4">1</span><span class="s0">]));</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">initialServerDataBuffer.push(seg[</span><span class="s4">1</span><span class="s0">]);</span>
        <span class="s0">}</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(seg[</span><span class="s4">0</span><span class="s0">] === </span><span class="s4">2</span><span class="s0">) {</span>
        <span class="s0">initialFormStateData = seg[</span><span class="s4">1</span><span class="s0">];</span>
    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(seg[</span><span class="s4">0</span><span class="s0">] === </span><span class="s4">3</span><span class="s0">) {</span>
        <span class="s1">if </span><span class="s0">(!initialServerDataBuffer) </span><span class="s1">throw </span><span class="s0">Object.defineProperty(</span><span class="s1">new </span><span class="s0">Error(</span><span class="s2">'Unexpected server data: missing bootstrap script.'</span><span class="s0">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
            <span class="s0">value: </span><span class="s2">&quot;E18&quot;</span><span class="s0">,</span>
            <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
            <span class="s0">configurable: </span><span class="s1">true</span>
        <span class="s0">});</span>
        <span class="s3">// Decode the base64 string back to binary data.</span>
        <span class="s1">const </span><span class="s0">binaryString = atob(seg[</span><span class="s4">1</span><span class="s0">]);</span>
        <span class="s1">const </span><span class="s0">decodedChunk = </span><span class="s1">new </span><span class="s0">Uint8Array(binaryString.length);</span>
        <span class="s1">for</span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s4">0</span><span class="s0">; i &lt; binaryString.length; i++){</span>
            <span class="s0">decodedChunk[i] = binaryString.charCodeAt(i);</span>
        <span class="s0">}</span>
        <span class="s1">if </span><span class="s0">(initialServerDataWriter) {</span>
            <span class="s0">initialServerDataWriter.enqueue(decodedChunk);</span>
        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
            <span class="s0">initialServerDataBuffer.push(decodedChunk);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">isStreamErrorOrUnfinished(ctr) {</span>
    <span class="s3">// If `desiredSize` is null, it means the stream is closed or errored. If it is lower than 0, the stream is still unfinished.</span>
    <span class="s1">return </span><span class="s0">ctr.desiredSize === </span><span class="s1">null </span><span class="s0">|| ctr.desiredSize &lt; </span><span class="s4">0</span><span class="s0">;</span>
<span class="s0">}</span>
<span class="s3">// There might be race conditions between `nextServerDataRegisterWriter` and</span>
<span class="s3">// `DOMContentLoaded`. The former will be called when React starts to hydrate</span>
<span class="s3">// the root, the latter will be called when the DOM is fully loaded.</span>
<span class="s3">// For streaming, the former is called first due to partial hydration.</span>
<span class="s3">// For non-streaming, the latter can be called first.</span>
<span class="s3">// Hence, we use two variables `initialServerDataLoaded` and</span>
<span class="s3">// `initialServerDataFlushed` to make sure the writer will be closed and</span>
<span class="s3">// `initialServerDataBuffer` will be cleared in the right time.</span>
<span class="s1">function </span><span class="s0">nextServerDataRegisterWriter(ctr) {</span>
    <span class="s1">if </span><span class="s0">(initialServerDataBuffer) {</span>
        <span class="s0">initialServerDataBuffer.forEach((val)=&gt;{</span>
            <span class="s0">ctr.enqueue(</span><span class="s1">typeof </span><span class="s0">val === </span><span class="s2">'string' </span><span class="s0">? encoder.encode(val) : val);</span>
        <span class="s0">});</span>
        <span class="s1">if </span><span class="s0">(initialServerDataLoaded &amp;&amp; !initialServerDataFlushed) {</span>
            <span class="s1">if </span><span class="s0">(isStreamErrorOrUnfinished(ctr)) {</span>
                <span class="s0">ctr.error(Object.defineProperty(</span><span class="s1">new </span><span class="s0">Error(</span><span class="s2">'The connection to the page was unexpectedly closed, possibly due to the stop button being clicked, loss of Wi-Fi, or an unstable internet connection.'</span><span class="s0">), </span><span class="s2">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s0">, {</span>
                    <span class="s0">value: </span><span class="s2">&quot;E117&quot;</span><span class="s0">,</span>
                    <span class="s0">enumerable: </span><span class="s1">false</span><span class="s0">,</span>
                    <span class="s0">configurable: </span><span class="s1">true</span>
                <span class="s0">}));</span>
            <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
                <span class="s0">ctr.close();</span>
            <span class="s0">}</span>
            <span class="s0">initialServerDataFlushed = </span><span class="s1">true</span><span class="s0">;</span>
            <span class="s0">initialServerDataBuffer = undefined;</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
    <span class="s0">initialServerDataWriter = ctr;</span>
<span class="s0">}</span>
<span class="s3">// When `DOMContentLoaded`, we can close all pending writers to finish hydration.</span>
<span class="s1">const </span><span class="s0">DOMContentLoaded = </span><span class="s1">function</span><span class="s0">() {</span>
    <span class="s1">if </span><span class="s0">(initialServerDataWriter &amp;&amp; !initialServerDataFlushed) {</span>
        <span class="s0">initialServerDataWriter.close();</span>
        <span class="s0">initialServerDataFlushed = </span><span class="s1">true</span><span class="s0">;</span>
        <span class="s0">initialServerDataBuffer = undefined;</span>
    <span class="s0">}</span>
    <span class="s0">initialServerDataLoaded = </span><span class="s1">true</span><span class="s0">;</span>
<span class="s0">};</span>
<span class="s3">// It's possible that the DOM is already loaded.</span>
<span class="s1">if </span><span class="s0">(document.readyState === </span><span class="s2">'loading'</span><span class="s0">) {</span>
    <span class="s0">document.addEventListener(</span><span class="s2">'DOMContentLoaded'</span><span class="s0">, DOMContentLoaded, </span><span class="s1">false</span><span class="s0">);</span>
<span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
    <span class="s3">// Delayed in marco task to ensure it's executed later than hydration</span>
    <span class="s0">setTimeout(DOMContentLoaded);</span>
<span class="s0">}</span>
<span class="s1">const </span><span class="s0">nextServerDataLoadingGlobal = self.__next_f = self.__next_f || [];</span>
<span class="s0">nextServerDataLoadingGlobal.forEach(nextServerDataCallback);</span>
<span class="s0">nextServerDataLoadingGlobal.push = nextServerDataCallback;</span>
<span class="s1">const </span><span class="s0">readable = </span><span class="s1">new </span><span class="s0">ReadableStream({</span>
    <span class="s0">start (controller) {</span>
        <span class="s0">nextServerDataRegisterWriter(controller);</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">initialServerResponse = createFromReadableStream(readable, {</span>
    <span class="s0">callServer: _appcallserver.callServer,</span>
    <span class="s0">findSourceMapURL: _appfindsourcemapurl.findSourceMapURL</span>
<span class="s0">});</span>
<span class="s1">function </span><span class="s0">ServerRoot(param) {</span>
    <span class="s1">let </span><span class="s0">{ pendingActionQueue } = param;</span>
    <span class="s1">const </span><span class="s0">initialRSCPayload = (</span><span class="s4">0</span><span class="s0">, _react.use)(initialServerResponse);</span>
    <span class="s1">const </span><span class="s0">actionQueue = (</span><span class="s4">0</span><span class="s0">, _react.use)(pendingActionQueue);</span>
    <span class="s1">const </span><span class="s0">router = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(_approuter.default, {</span>
        <span class="s0">actionQueue: actionQueue,</span>
        <span class="s0">globalErrorState: initialRSCPayload.G,</span>
        <span class="s0">assetPrefix: initialRSCPayload.p</span>
    <span class="s0">});</span>
    <span class="s1">if </span><span class="s0">((</span><span class="s2">&quot;TURBOPACK compile-time value&quot;</span><span class="s0">, </span><span class="s2">&quot;development&quot;</span><span class="s0">) === </span><span class="s2">'development' </span><span class="s0">&amp;&amp; initialRSCPayload.m) {</span>
        <span class="s3">// We provide missing slot information in a context provider only during development</span>
        <span class="s3">// as we log some additional information about the missing slots in the console.</span>
        <span class="s1">return </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(_approutercontextsharedruntime.MissingSlotContext, {</span>
            <span class="s0">value: initialRSCPayload.m,</span>
            <span class="s0">children: router</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s1">return </span><span class="s0">router;</span>
<span class="s0">}</span>
<span class="s1">const </span><span class="s0">StrictModeIfEnabled = (</span><span class="s2">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s0">) ? _react.default.StrictMode : </span><span class="s2">&quot;TURBOPACK unreachable&quot;</span><span class="s0">;</span>
<span class="s1">function </span><span class="s0">Root(param) {</span>
    <span class="s1">let </span><span class="s0">{ children } = param;</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time falsy&quot;</span><span class="s0">, </span><span class="s4">0</span><span class="s0">) </span><span class="s3">//TURBOPACK unreachable</span>
    <span class="s0">;</span>
    <span class="s1">return </span><span class="s0">children;</span>
<span class="s0">}</span>
<span class="s1">function </span><span class="s0">onDefaultTransitionIndicator() {</span>
    <span class="s3">// TODO: Compose default with user-configureable (e.g. nprogress)</span>
    <span class="s3">// TODO: Use React's default once we figure out hanging indicators: https://codesandbox.io/p/sandbox/charming-moon-hktkp6?file=%2Fsrc%2Findex.js%3A106%2C30</span>
    <span class="s1">return </span><span class="s0">()=&gt;{};</span>
<span class="s0">}</span>
<span class="s1">const </span><span class="s0">reactRootOptions = {</span>
    <span class="s0">onDefaultTransitionIndicator: onDefaultTransitionIndicator,</span>
    <span class="s0">onRecoverableError: _onrecoverableerror.onRecoverableError,</span>
    <span class="s0">onCaughtError: _errorboundarycallbacks.onCaughtError,</span>
    <span class="s0">onUncaughtError: _errorboundarycallbacks.onUncaughtError</span>
<span class="s0">};</span>
<span class="s1">function </span><span class="s0">hydrate(instrumentationHooks) {</span>
    <span class="s3">// React overrides `.then` and doesn't return a new promise chain,</span>
    <span class="s3">// so we wrap the action queue in a promise to ensure that its value</span>
    <span class="s3">// is defined when the promise resolves.</span>
    <span class="s3">// https://github.com/facebook/react/blob/163365a07872337e04826c4f501565d43dbd2fd4/packages/react-client/src/ReactFlightClient.js#L189-L190</span>
    <span class="s1">const </span><span class="s0">pendingActionQueue = </span><span class="s1">new </span><span class="s0">Promise((resolve, reject)=&gt;{</span>
        <span class="s0">initialServerResponse.then((initialRSCPayload)=&gt;{</span>
            <span class="s3">// setAppBuildId should be called only once, during JS initialization</span>
            <span class="s3">// and before any components have hydrated.</span>
            <span class="s0">(</span><span class="s4">0</span><span class="s0">, _appbuildid.setAppBuildId)(initialRSCPayload.b);</span>
            <span class="s1">const </span><span class="s0">initialTimestamp = Date.now();</span>
            <span class="s0">resolve((</span><span class="s4">0</span><span class="s0">, _approuterinstance.createMutableActionQueue)((</span><span class="s4">0</span><span class="s0">, _createinitialrouterstate.createInitialRouterState)({</span>
                <span class="s0">navigatedAt: initialTimestamp,</span>
                <span class="s0">initialFlightData: initialRSCPayload.f,</span>
                <span class="s0">initialCanonicalUrlParts: initialRSCPayload.c,</span>
                <span class="s0">initialParallelRoutes: </span><span class="s1">new </span><span class="s0">Map(),</span>
                <span class="s0">location: window.location,</span>
                <span class="s0">couldBeIntercepted: initialRSCPayload.i,</span>
                <span class="s0">postponed: initialRSCPayload.s,</span>
                <span class="s0">prerendered: initialRSCPayload.S</span>
            <span class="s0">}), instrumentationHooks));</span>
        <span class="s0">}, (err)=&gt;reject(err));</span>
    <span class="s0">});</span>
    <span class="s1">const </span><span class="s0">reactEl = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(StrictModeIfEnabled, {</span>
        <span class="s0">children: </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(_headmanagercontextsharedruntime.HeadManagerContext.Provider, {</span>
            <span class="s0">value: {</span>
                <span class="s0">appDir: </span><span class="s1">true</span>
            <span class="s0">},</span>
            <span class="s0">children: </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(Root, {</span>
                <span class="s0">children: </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(ServerRoot, {</span>
                    <span class="s0">pendingActionQueue: pendingActionQueue</span>
                <span class="s0">})</span>
            <span class="s0">})</span>
        <span class="s0">})</span>
    <span class="s0">});</span>
    <span class="s1">if </span><span class="s0">(document.documentElement.id === </span><span class="s2">'__next_error__'</span><span class="s0">) {</span>
        <span class="s1">let </span><span class="s0">element = reactEl;</span>
        <span class="s3">// Server rendering failed, fall back to client-side rendering</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s0">) {</span>
            <span class="s1">const </span><span class="s0">{ RootLevelDevOverlayElement } = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/next-devtools/userspace/app/client-entry.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
            <span class="s3">// Note this won't cause hydration mismatch because we are doing CSR w/o hydration</span>
            <span class="s0">element = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">(</span><span class="s4">0</span><span class="s0">, _jsxruntime.jsx)(RootLevelDevOverlayElement, {</span>
                <span class="s0">children: element</span>
            <span class="s0">});</span>
        <span class="s0">}</span>
        <span class="s0">_client.default.createRoot(appElement, reactRootOptions).render(element);</span>
    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
        <span class="s0">_react.default.startTransition(()=&gt;{</span>
            <span class="s0">_client.default.hydrateRoot(appElement, reactEl, {</span>
                <span class="s0">...reactRootOptions,</span>
                <span class="s0">formState: initialFormStateData</span>
            <span class="s0">});</span>
        <span class="s0">});</span>
    <span class="s0">}</span>
    <span class="s3">// TODO-APP: Remove this logic when Float has GC built-in in development.</span>
    <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s0">) {</span>
        <span class="s1">const </span><span class="s0">{ linkGc } = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/app-link-gc.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
        <span class="s0">linkGc();</span>
    <span class="s0">}</span>
<span class="s0">}</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=app-index.js.map</span>
<span class="s0">}),</span>
<span class="s2">&quot;[project]/node_modules/next/dist/client/app-next-turbopack.js [app-client] (ecmascript)&quot;</span><span class="s0">, ((__turbopack_context__, module, exports) =&gt; {</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>

<span class="s1">var </span><span class="s0">__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = </span><span class="s3">/*#__PURE__*/ </span><span class="s0">__turbopack_context__.i(</span><span class="s2">&quot;[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s2">&quot;use strict&quot;</span><span class="s0">;</span>
<span class="s0">Object.defineProperty(exports, </span><span class="s2">&quot;__esModule&quot;</span><span class="s0">, {</span>
    <span class="s0">value: </span><span class="s1">true</span>
<span class="s0">});</span>
<span class="s1">const </span><span class="s0">_appbootstrap = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/app-bootstrap.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s1">const </span><span class="s0">_onrecoverableerror = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/react-client-callbacks/on-recoverable-error.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s0">window.next.turbopack = </span><span class="s1">true</span><span class="s0">;</span>
<span class="s0">self.__webpack_hash__ = </span><span class="s2">''</span><span class="s0">;</span>
<span class="s3">// eslint-disable-next-line @next/internal/typechecked-require</span>
<span class="s1">const </span><span class="s0">instrumentationHooks = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/lib/require-instrumentation-client.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
<span class="s0">(</span><span class="s4">0</span><span class="s0">, _appbootstrap.appBootstrap)(()=&gt;{</span>
    <span class="s1">const </span><span class="s0">{ hydrate } = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/client/app-index.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
    <span class="s1">try </span><span class="s0">{</span>
        <span class="s0">hydrate(instrumentationHooks);</span>
    <span class="s0">} </span><span class="s1">finally</span><span class="s0">{</span>
        <span class="s1">if </span><span class="s0">(</span><span class="s2">&quot;TURBOPACK compile-time truthy&quot;</span><span class="s0">, </span><span class="s4">1</span><span class="s0">) {</span>
            <span class="s1">const </span><span class="s0">{ getOwnerStack } = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/next-devtools/userspace/app/errors/stitched-error.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
            <span class="s1">const </span><span class="s0">{ renderAppDevOverlay } = __turbopack_context__.r(</span><span class="s2">&quot;[project]/node_modules/next/dist/compiled/next-devtools/index.js [app-client] (ecmascript)&quot;</span><span class="s0">);</span>
            <span class="s0">renderAppDevOverlay(getOwnerStack, _onrecoverableerror.isRecoverableError);</span>
        <span class="s0">}</span>
    <span class="s0">}</span>
<span class="s0">});</span>
<span class="s1">if </span><span class="s0">((</span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'function' </span><span class="s0">|| </span><span class="s1">typeof </span><span class="s0">exports.default === </span><span class="s2">'object' </span><span class="s0">&amp;&amp; exports.default !== </span><span class="s1">null</span><span class="s0">) &amp;&amp; </span><span class="s1">typeof </span><span class="s0">exports.default.__esModule === </span><span class="s2">'undefined'</span><span class="s0">) {</span>
    <span class="s0">Object.defineProperty(exports.default, </span><span class="s2">'__esModule'</span><span class="s0">, {</span>
        <span class="s0">value: </span><span class="s1">true</span>
    <span class="s0">});</span>
    <span class="s0">Object.assign(exports.default, exports);</span>
    <span class="s0">module.exports = exports.default;</span>
<span class="s0">} </span><span class="s3">//# sourceMappingURL=app-next-turbopack.js.map</span>
<span class="s0">}),</span>
<span class="s0">]);</span>

<span class="s3">//# sourceMappingURL=node_modules_next_dist_client_cf1d9188._.js.map</span></pre>
</body>
</html>