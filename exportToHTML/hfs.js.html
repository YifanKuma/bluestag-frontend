<html>
<head>
<title>hfs.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #8c8c8c; font-style: italic;}
.s2 { color: #080808;}
.s3 { color: #0033b3;}
.s4 { color: #067d17;}
.s5 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
hfs.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@fileoverview </span><span class="s0">The main file for the humanfs package.</span>
 <span class="s0">* </span><span class="s1">@author </span><span class="s0">Nicholas C. Zakas</span>
 <span class="s0">*/</span>

<span class="s0">/* global URL, TextDecoder, TextEncoder */</span>

<span class="s0">//-----------------------------------------------------------------------------</span>
<span class="s0">// Types</span>
<span class="s0">//-----------------------------------------------------------------------------</span>

<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import(&quot;@humanfs/types&quot;).HfsImpl} HfsImpl */</span>
<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import(&quot;@humanfs/types&quot;).HfsDirectoryEntry} HfsDirectoryEntry */</span>
<span class="s0">/** </span><span class="s1">@typedef </span><span class="s0">{import(&quot;@humanfs/types&quot;).HfsWalkEntry} HfsWalkEntry */</span>

<span class="s0">//-----------------------------------------------------------------------------</span>
<span class="s0">// Helpers</span>
<span class="s0">//-----------------------------------------------------------------------------</span>

<span class="s3">const </span><span class="s2">decoder = </span><span class="s3">new </span><span class="s2">TextDecoder();</span>
<span class="s3">const </span><span class="s2">encoder = </span><span class="s3">new </span><span class="s2">TextEncoder();</span>

<span class="s0">/**</span>
 <span class="s0">* Error to represent when a method is missing on an impl.</span>
 <span class="s0">*/</span>
<span class="s3">export class </span><span class="s2">NoSuchMethodError </span><span class="s3">extends </span><span class="s2">Error {</span>
	<span class="s0">/**</span>
	 <span class="s0">* Creates a new instance.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} methodName The name of the method that was missing.</span>
	 <span class="s0">*/</span>
	<span class="s2">constructor(methodName) {</span>
		<span class="s3">super</span><span class="s2">(</span><span class="s4">`Method &quot;</span><span class="s2">${methodName}</span><span class="s4">&quot; does not exist on impl.`</span><span class="s2">);</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Error to represent when a method is not supported on an impl. This happens</span>
 <span class="s0">* when a method on `Hfs` is called with one name and the corresponding method</span>
 <span class="s0">* on the impl has a different name. (Example: `text()` and `bytes()`.)</span>
 <span class="s0">*/</span>
<span class="s3">export class </span><span class="s2">MethodNotSupportedError </span><span class="s3">extends </span><span class="s2">Error {</span>
	<span class="s0">/**</span>
	 <span class="s0">* Creates a new instance.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} methodName The name of the method that was missing.</span>
	 <span class="s0">*/</span>
	<span class="s2">constructor(methodName) {</span>
		<span class="s3">super</span><span class="s2">(</span><span class="s4">`Method &quot;</span><span class="s2">${methodName}</span><span class="s4">&quot; is not supported on this impl.`</span><span class="s2">);</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Error to represent when an impl is already set.</span>
 <span class="s0">*/</span>
<span class="s3">export class </span><span class="s2">ImplAlreadySetError </span><span class="s3">extends </span><span class="s2">Error {</span>
	<span class="s0">/**</span>
	 <span class="s0">* Creates a new instance.</span>
	 <span class="s0">*/</span>
	<span class="s2">constructor() {</span>
		<span class="s3">super</span><span class="s2">(</span><span class="s4">`Implementation already set.`</span><span class="s2">);</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Asserts that the given path is a valid file path.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{any} fileOrDirPath The path to check.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} When the path is not a non-empty string.</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">assertValidFileOrDirPath(fileOrDirPath) {</span>
	<span class="s3">if </span><span class="s2">(</span>
		<span class="s2">!fileOrDirPath ||</span>
		<span class="s2">(!(fileOrDirPath </span><span class="s3">instanceof </span><span class="s2">URL) &amp;&amp; </span><span class="s3">typeof </span><span class="s2">fileOrDirPath !== </span><span class="s4">&quot;string&quot;</span><span class="s2">)</span>
	<span class="s2">) {</span>
		<span class="s3">throw new </span><span class="s2">TypeError(</span><span class="s4">&quot;Path must be a non-empty string or URL.&quot;</span><span class="s2">);</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Asserts that the given file contents are valid.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{any} contents The contents to check.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} When the contents are not a string or ArrayBuffer.</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">assertValidFileContents(contents) {</span>
	<span class="s3">if </span><span class="s2">(</span>
		<span class="s3">typeof </span><span class="s2">contents !== </span><span class="s4">&quot;string&quot; </span><span class="s2">&amp;&amp;</span>
		<span class="s2">!(contents </span><span class="s3">instanceof </span><span class="s2">ArrayBuffer) &amp;&amp;</span>
		<span class="s2">!ArrayBuffer.isView(contents)</span>
	<span class="s2">) {</span>
		<span class="s3">throw new </span><span class="s2">TypeError(</span>
			<span class="s4">&quot;File contents must be a string, ArrayBuffer, or ArrayBuffer view.&quot;</span><span class="s2">,</span>
		<span class="s2">);</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Converts the given contents to Uint8Array.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{any} contents The data to convert.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Uint8Array} The converted Uint8Array.</span>
 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} When the contents are not a string or ArrayBuffer.</span>
 <span class="s0">*/</span>
<span class="s3">function </span><span class="s2">toUint8Array(contents) {</span>
	<span class="s3">if </span><span class="s2">(contents </span><span class="s3">instanceof </span><span class="s2">Uint8Array) {</span>
		<span class="s3">return </span><span class="s2">contents;</span>
	<span class="s2">}</span>

	<span class="s3">if </span><span class="s2">(</span><span class="s3">typeof </span><span class="s2">contents === </span><span class="s4">&quot;string&quot;</span><span class="s2">) {</span>
		<span class="s3">return </span><span class="s2">encoder.encode(contents);</span>
	<span class="s2">}</span>

	<span class="s3">if </span><span class="s2">(contents </span><span class="s3">instanceof </span><span class="s2">ArrayBuffer) {</span>
		<span class="s3">return new </span><span class="s2">Uint8Array(contents);</span>
	<span class="s2">}</span>

	<span class="s3">if </span><span class="s2">(ArrayBuffer.isView(contents)) {</span>
		<span class="s3">const </span><span class="s2">bytes = contents.buffer.slice(</span>
			<span class="s2">contents.byteOffset,</span>
			<span class="s2">contents.byteOffset + contents.byteLength,</span>
		<span class="s2">);</span>
		<span class="s3">return new </span><span class="s2">Uint8Array(bytes);</span>
	<span class="s2">}</span>
	<span class="s3">throw new </span><span class="s2">TypeError(</span>
		<span class="s4">&quot;Invalid contents type. Expected string or ArrayBuffer.&quot;</span><span class="s2">,</span>
	<span class="s2">);</span>
<span class="s2">}</span>

<span class="s0">//-----------------------------------------------------------------------------</span>
<span class="s0">// Exports</span>
<span class="s0">//-----------------------------------------------------------------------------</span>

<span class="s0">/**</span>
 <span class="s0">* A class representing a log entry.</span>
 <span class="s0">*/</span>
<span class="s3">export class </span><span class="s2">LogEntry {</span>
	<span class="s0">/**</span>
	 <span class="s0">* The type of log entry.</span>
	 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{string}</span>
	 <span class="s0">*/</span>
	<span class="s2">type;</span>

	<span class="s0">/**</span>
	 <span class="s0">* The data associated with the log entry.</span>
	 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{any}</span>
	 <span class="s0">*/</span>
	<span class="s2">data;</span>

	<span class="s0">/**</span>
	 <span class="s0">* The time at which the log entry was created.</span>
	 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{number}</span>
	 <span class="s0">*/</span>
	<span class="s2">timestamp = Date.now();</span>

	<span class="s0">/**</span>
	 <span class="s0">* Creates a new instance.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} type The type of log entry.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{any} [data] The data associated with the log entry.</span>
	 <span class="s0">*/</span>
	<span class="s2">constructor(type, data) {</span>
		<span class="s3">this</span><span class="s2">.type = type;</span>
		<span class="s3">this</span><span class="s2">.data = data;</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* A class representing a file system utility library.</span>
 <span class="s0">* </span><span class="s1">@implements </span><span class="s0">{HfsImpl}</span>
 <span class="s0">*/</span>
<span class="s3">export class </span><span class="s2">Hfs {</span>
	<span class="s0">/**</span>
	 <span class="s0">* The base implementation for this instance.</span>
	 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{HfsImpl}</span>
	 <span class="s0">*/</span>
	<span class="s2">#baseImpl;</span>

	<span class="s0">/**</span>
	 <span class="s0">* The current implementation for this instance.</span>
	 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{HfsImpl}</span>
	 <span class="s0">*/</span>
	<span class="s2">#impl;</span>

	<span class="s0">/**</span>
	 <span class="s0">* A map of log names to their corresponding entries.</span>
	 <span class="s0">* </span><span class="s1">@type </span><span class="s0">{Map&lt;string,Array&lt;LogEntry&gt;&gt;}</span>
	 <span class="s0">*/</span>
	<span class="s2">#logs = </span><span class="s3">new </span><span class="s2">Map();</span>

	<span class="s0">/**</span>
	 <span class="s0">* Creates a new instance.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{object} options The options for the instance.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{HfsImpl} options.impl The implementation to use.</span>
	 <span class="s0">*/</span>
	<span class="s2">constructor({ impl }) {</span>
		<span class="s3">this</span><span class="s2">.#baseImpl = impl;</span>
		<span class="s3">this</span><span class="s2">.#impl = impl;</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Logs an entry onto all currently open logs.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} methodName The name of the method being called.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{...*} args The arguments to the method.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s2">#log(methodName, ...args) {</span>
		<span class="s3">for </span><span class="s2">(</span><span class="s3">const </span><span class="s2">logs of </span><span class="s3">this</span><span class="s2">.#logs.values()) {</span>
			<span class="s2">logs.push(</span><span class="s3">new </span><span class="s2">LogEntry(</span><span class="s4">&quot;call&quot;</span><span class="s2">, { methodName, args }));</span>
		<span class="s2">}</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Starts a new log with the given name.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} name The name of the log to start;</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} When the log already exists.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} When the name is not a non-empty string.</span>
	 <span class="s0">*/</span>
	<span class="s2">logStart(name) {</span>
		<span class="s3">if </span><span class="s2">(!name || </span><span class="s3">typeof </span><span class="s2">name !== </span><span class="s4">&quot;string&quot;</span><span class="s2">) {</span>
			<span class="s3">throw new </span><span class="s2">TypeError(</span><span class="s4">&quot;Log name must be a non-empty string.&quot;</span><span class="s2">);</span>
		<span class="s2">}</span>

		<span class="s3">if </span><span class="s2">(</span><span class="s3">this</span><span class="s2">.#logs.has(name)) {</span>
			<span class="s3">throw new </span><span class="s2">Error(</span><span class="s4">`Log &quot;</span><span class="s2">${name}</span><span class="s4">&quot; already exists.`</span><span class="s2">);</span>
		<span class="s2">}</span>

		<span class="s3">this</span><span class="s2">.#logs.set(name, []);</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Ends a log with the given name and returns the entries.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} name The name of the log to end.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Array&lt;LogEntry&gt;} The entries in the log.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} When the log does not exist.</span>
	 <span class="s0">*/</span>
	<span class="s2">logEnd(name) {</span>
		<span class="s3">if </span><span class="s2">(</span><span class="s3">this</span><span class="s2">.#logs.has(name)) {</span>
			<span class="s3">const </span><span class="s2">logs = </span><span class="s3">this</span><span class="s2">.#logs.get(name);</span>
			<span class="s3">this</span><span class="s2">.#logs.delete(name);</span>
			<span class="s3">return </span><span class="s2">logs;</span>
		<span class="s2">}</span>

		<span class="s3">throw new </span><span class="s2">Error(</span><span class="s4">`Log &quot;</span><span class="s2">${name}</span><span class="s4">&quot; does not exist.`</span><span class="s2">);</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Determines if the current implementation is the base implementation.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} True if the current implementation is the base implementation.</span>
	 <span class="s0">*/</span>
	<span class="s2">isBaseImpl() {</span>
		<span class="s3">return this</span><span class="s2">.#impl === </span><span class="s3">this</span><span class="s2">.#baseImpl;</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Sets the implementation for this instance.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{object} impl The implementation to use.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s2">setImpl(impl) {</span>
		<span class="s3">this</span><span class="s2">.#log(</span><span class="s4">&quot;implSet&quot;</span><span class="s2">, impl);</span>

		<span class="s3">if </span><span class="s2">(</span><span class="s3">this</span><span class="s2">.#impl !== </span><span class="s3">this</span><span class="s2">.#baseImpl) {</span>
			<span class="s3">throw new </span><span class="s2">ImplAlreadySetError();</span>
		<span class="s2">}</span>

		<span class="s3">this</span><span class="s2">.#impl = impl;</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Resets the implementation for this instance back to its original.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">*/</span>
	<span class="s2">resetImpl() {</span>
		<span class="s3">this</span><span class="s2">.#log(</span><span class="s4">&quot;implReset&quot;</span><span class="s2">);</span>
		<span class="s3">this</span><span class="s2">.#impl = </span><span class="s3">this</span><span class="s2">.#baseImpl;</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Asserts that the given method exists on the current implementation.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} methodName The name of the method to check.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{NoSuchMethodError} When the method does not exist on the current implementation.</span>
	 <span class="s0">*/</span>
	<span class="s2">#assertImplMethod(methodName) {</span>
		<span class="s3">if </span><span class="s2">(</span><span class="s3">typeof this</span><span class="s2">.#impl[methodName] !== </span><span class="s4">&quot;function&quot;</span><span class="s2">) {</span>
			<span class="s3">throw new </span><span class="s2">NoSuchMethodError(methodName);</span>
		<span class="s2">}</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Asserts that the given method exists on the current implementation, and if not,</span>
	 <span class="s0">* throws an error with a different method name.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} methodName The name of the method to check.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} targetMethodName The name of the method that should be reported</span>
	 <span class="s0">*  as an error when methodName does not exist.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{NoSuchMethodError} When the method does not exist on the current implementation.</span>
	 <span class="s0">*/</span>
	<span class="s2">#assertImplMethodAlt(methodName, targetMethodName) {</span>
		<span class="s3">if </span><span class="s2">(</span><span class="s3">typeof this</span><span class="s2">.#impl[methodName] !== </span><span class="s4">&quot;function&quot;</span><span class="s2">) {</span>
			<span class="s3">throw new </span><span class="s2">MethodNotSupportedError(targetMethodName);</span>
		<span class="s2">}</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Calls the given method on the current implementation.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} methodName The name of the method to call.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{...any} args The arguments to the method.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{any} The return value from the method.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{NoSuchMethodError} When the method does not exist on the current implementation.</span>
	 <span class="s0">*/</span>
	<span class="s2">#callImplMethod(methodName, ...args) {</span>
		<span class="s3">this</span><span class="s2">.#log(methodName, ...args);</span>
		<span class="s3">this</span><span class="s2">.#assertImplMethod(methodName);</span>
		<span class="s3">return this</span><span class="s2">.#impl[methodName](...args);</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Calls the given method on the current implementation and doesn't log the call.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} methodName The name of the method to call.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{...any} args The arguments to the method.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{any} The return value from the method.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{NoSuchMethodError} When the method does not exist on the current implementation.</span>
	 <span class="s0">*/</span>
	<span class="s2">#callImplMethodWithoutLog(methodName, ...args) {</span>
		<span class="s3">this</span><span class="s2">.#assertImplMethod(methodName);</span>
		<span class="s3">return this</span><span class="s2">.#impl[methodName](...args);</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Calls the given method on the current implementation but logs a different method name.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} methodName The name of the method to call.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} targetMethodName The name of the method to log.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{...any} args The arguments to the method.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{any} The return value from the method.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{NoSuchMethodError} When the method does not exist on the current implementation.</span>
	 <span class="s0">*/</span>
	<span class="s2">#callImplMethodAlt(methodName, targetMethodName, ...args) {</span>
		<span class="s3">this</span><span class="s2">.#log(targetMethodName, ...args);</span>
		<span class="s3">this</span><span class="s2">.#assertImplMethodAlt(methodName, targetMethodName);</span>
		<span class="s3">return this</span><span class="s2">.#impl[methodName](...args);</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Reads the given file and returns the contents as text. Assumes UTF-8 encoding.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|URL} filePath The file to read.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise&lt;string|undefined&gt;} The contents of the file.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{NoSuchMethodError} When the method does not exist on the current implementation.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} When the file path is not a non-empty string.</span>
	 <span class="s0">*/</span>
	<span class="s2">async text(filePath) {</span>
		<span class="s2">assertValidFileOrDirPath(filePath);</span>

		<span class="s3">const </span><span class="s2">result = </span><span class="s3">await this</span><span class="s2">.#callImplMethodAlt(</span><span class="s4">&quot;bytes&quot;</span><span class="s2">, </span><span class="s4">&quot;text&quot;</span><span class="s2">, filePath);</span>
		<span class="s3">return </span><span class="s2">result ? decoder.decode(result) : undefined;</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Reads the given file and returns the contents as JSON. Assumes UTF-8 encoding.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|URL} filePath The file to read.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise&lt;any|undefined&gt;} The contents of the file as JSON.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{NoSuchMethodError} When the method does not exist on the current implementation.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{SyntaxError} When the file contents are not valid JSON.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} When the file path is not a non-empty string.</span>
	 <span class="s0">*/</span>
	<span class="s2">async json(filePath) {</span>
		<span class="s2">assertValidFileOrDirPath(filePath);</span>

		<span class="s3">const </span><span class="s2">result = </span><span class="s3">await this</span><span class="s2">.#callImplMethodAlt(</span><span class="s4">&quot;bytes&quot;</span><span class="s2">, </span><span class="s4">&quot;json&quot;</span><span class="s2">, filePath);</span>
		<span class="s3">return </span><span class="s2">result ? JSON.parse(decoder.decode(result)) : undefined;</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Reads the given file and returns the contents as an ArrayBuffer.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|URL} filePath The file to read.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise&lt;ArrayBuffer|undefined&gt;} The contents of the file as an ArrayBuffer.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{NoSuchMethodError} When the method does not exist on the current implementation.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} When the file path is not a non-empty string.</span>
	 <span class="s0">* </span><span class="s1">@deprecated </span><span class="s0">Use bytes() instead.</span>
	 <span class="s0">*/</span>
	<span class="s2">async arrayBuffer(filePath) {</span>
		<span class="s2">assertValidFileOrDirPath(filePath);</span>

		<span class="s3">const </span><span class="s2">result = </span><span class="s3">await this</span><span class="s2">.#callImplMethodAlt(</span>
			<span class="s4">&quot;bytes&quot;</span><span class="s2">,</span>
			<span class="s4">&quot;arrayBuffer&quot;</span><span class="s2">,</span>
			<span class="s2">filePath,</span>
		<span class="s2">);</span>
		<span class="s3">return </span><span class="s2">result?.buffer;</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Reads the given file and returns the contents as an Uint8Array.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|URL} filePath The file to read.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise&lt;Uint8Array|undefined&gt;} The contents of the file as an Uint8Array.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{NoSuchMethodError} When the method does not exist on the current implementation.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} When the file path is not a non-empty string.</span>
	 <span class="s0">*/</span>
	<span class="s2">async bytes(filePath) {</span>
		<span class="s2">assertValidFileOrDirPath(filePath);</span>
		<span class="s3">return this</span><span class="s2">.#callImplMethod(</span><span class="s4">&quot;bytes&quot;</span><span class="s2">, filePath);</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Writes the given data to the given file. Creates any necessary directories along the way.</span>
	 <span class="s0">* If the data is a string, UTF-8 encoding is used.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|URL} filePath The file to write.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|ArrayBuffer|ArrayBufferView} contents The data to write.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise&lt;void&gt;} A promise that resolves when the file is written.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{NoSuchMethodError} When the method does not exist on the current implementation.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} When the file path is not a non-empty string.</span>
	 <span class="s0">*/</span>
	<span class="s2">async write(filePath, contents) {</span>
		<span class="s2">assertValidFileOrDirPath(filePath);</span>
		<span class="s2">assertValidFileContents(contents);</span>
		<span class="s3">this</span><span class="s2">.#log(</span><span class="s4">&quot;write&quot;</span><span class="s2">, filePath, contents);</span>

		<span class="s3">let </span><span class="s2">value = toUint8Array(contents);</span>
		<span class="s3">return this</span><span class="s2">.#callImplMethodWithoutLog(</span><span class="s4">&quot;write&quot;</span><span class="s2">, filePath, value);</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Appends the given data to the given file. Creates any necessary directories along the way.</span>
	 <span class="s0">* If the data is a string, UTF-8 encoding is used.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|URL} filePath The file to append to.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|ArrayBuffer|ArrayBufferView} contents The data to append.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise&lt;void&gt;} A promise that resolves when the file is appended to.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{NoSuchMethodError} When the method does not exist on the current implementation.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} When the file path is not a non-empty string.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} When the file contents are not a string or ArrayBuffer.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} When the file cannot be appended to.</span>
	 <span class="s0">*/</span>
	<span class="s2">async append(filePath, contents) {</span>
		<span class="s2">assertValidFileOrDirPath(filePath);</span>
		<span class="s2">assertValidFileContents(contents);</span>
		<span class="s3">this</span><span class="s2">.#log(</span><span class="s4">&quot;append&quot;</span><span class="s2">, filePath, contents);</span>

		<span class="s3">let </span><span class="s2">value = toUint8Array(contents);</span>
		<span class="s3">return this</span><span class="s2">.#callImplMethodWithoutLog(</span><span class="s4">&quot;append&quot;</span><span class="s2">, filePath, value);</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Determines if the given file exists.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|URL} filePath The file to check.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise&lt;boolean&gt;} True if the file exists.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{NoSuchMethodError} When the method does not exist on the current implementation.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} When the file path is not a non-empty string.</span>
	 <span class="s0">*/</span>
	<span class="s2">async isFile(filePath) {</span>
		<span class="s2">assertValidFileOrDirPath(filePath);</span>
		<span class="s3">return this</span><span class="s2">.#callImplMethod(</span><span class="s4">&quot;isFile&quot;</span><span class="s2">, filePath);</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Determines if the given directory exists.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|URL} dirPath The directory to check.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise&lt;boolean&gt;} True if the directory exists.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{NoSuchMethodError} When the method does not exist on the current implementation.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} When the directory path is not a non-empty string.</span>
	 <span class="s0">*/</span>
	<span class="s2">async isDirectory(dirPath) {</span>
		<span class="s2">assertValidFileOrDirPath(dirPath);</span>
		<span class="s3">return this</span><span class="s2">.#callImplMethod(</span><span class="s4">&quot;isDirectory&quot;</span><span class="s2">, dirPath);</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Creates the given directory.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|URL} dirPath The directory to create.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise&lt;void&gt;} A promise that resolves when the directory is created.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{NoSuchMethodError} When the method does not exist on the current implementation.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} When the directory path is not a non-empty string.</span>
	 <span class="s0">*/</span>
	<span class="s2">async createDirectory(dirPath) {</span>
		<span class="s2">assertValidFileOrDirPath(dirPath);</span>
		<span class="s3">return this</span><span class="s2">.#callImplMethod(</span><span class="s4">&quot;createDirectory&quot;</span><span class="s2">, dirPath);</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Deletes the given file or empty directory.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|URL} filePath The file to delete.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise&lt;boolean&gt;} A promise that resolves when the file or</span>
	 <span class="s0">*   directory is deleted, true if the file or directory is deleted, false</span>
	 <span class="s0">*   if the file or directory does not exist.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{NoSuchMethodError} When the method does not exist on the current implementation.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} When the file path is not a non-empty string.</span>
	 <span class="s0">*/</span>
	<span class="s2">async </span><span class="s3">delete</span><span class="s2">(filePath) {</span>
		<span class="s2">assertValidFileOrDirPath(filePath);</span>
		<span class="s3">return this</span><span class="s2">.#callImplMethod(</span><span class="s4">&quot;delete&quot;</span><span class="s2">, filePath);</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Deletes the given file or directory recursively.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|URL} dirPath The directory to delete.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise&lt;boolean&gt;} A promise that resolves when the file or</span>
	 <span class="s0">*   directory is deleted, true if the file or directory is deleted, false</span>
	 <span class="s0">*   if the file or directory does not exist.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{NoSuchMethodError} When the method does not exist on the current implementation.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} When the directory path is not a non-empty string.</span>
	 <span class="s0">*/</span>
	<span class="s2">async deleteAll(dirPath) {</span>
		<span class="s2">assertValidFileOrDirPath(dirPath);</span>
		<span class="s3">return this</span><span class="s2">.#callImplMethod(</span><span class="s4">&quot;deleteAll&quot;</span><span class="s2">, dirPath);</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Returns a list of directory entries for the given path.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|URL} dirPath The path to the directory to read.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{AsyncIterable&lt;HfsDirectoryEntry&gt;} A promise that resolves with the</span>
	 <span class="s0">*   directory entries.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} If the directory path is not a string or URL.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} If the directory cannot be read.</span>
	 <span class="s0">*/</span>
	<span class="s2">async *list(dirPath) {</span>
		<span class="s2">assertValidFileOrDirPath(dirPath);</span>
		<span class="s3">yield</span><span class="s2">* </span><span class="s3">await this</span><span class="s2">.#callImplMethod(</span><span class="s4">&quot;list&quot;</span><span class="s2">, dirPath);</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Walks a directory using a depth-first traversal and returns the entries</span>
	 <span class="s0">* from the traversal.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|URL} dirPath The path to the directory to walk.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} [options] The options for the walk.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{(entry:HfsWalkEntry) =&gt; Promise&lt;boolean&gt;|boolean} [options.directoryFilter] A filter function to determine</span>
	 <span class="s0">* 	if a directory's entries should be included in the walk.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{(entry:HfsWalkEntry) =&gt; Promise&lt;boolean&gt;|boolean} [options.entryFilter] A filter function to determine if</span>
	 <span class="s0">* 	an entry should be included in the walk.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{AsyncIterable&lt;HfsWalkEntry&gt;} A promise that resolves with the</span>
	 <span class="s0">* 	directory entries.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} If the directory path is not a string or URL.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} If the directory cannot be read.</span>
	 <span class="s0">*/</span>
	<span class="s2">async *walk(</span>
		<span class="s2">dirPath,</span>
		<span class="s2">{ directoryFilter = () =&gt; </span><span class="s3">true</span><span class="s2">, entryFilter = () =&gt; </span><span class="s3">true </span><span class="s2">} = {},</span>
	<span class="s2">) {</span>
		<span class="s2">assertValidFileOrDirPath(dirPath);</span>
		<span class="s3">this</span><span class="s2">.#log(</span><span class="s4">&quot;walk&quot;</span><span class="s2">, dirPath, { directoryFilter, entryFilter });</span>

		<span class="s0">// inner function for recursion without additional logging</span>
		<span class="s3">const </span><span class="s2">walk = async </span><span class="s3">function</span><span class="s2">* (</span>
			<span class="s2">dirPath,</span>
			<span class="s2">{ directoryFilter, entryFilter, parentPath = </span><span class="s4">&quot;&quot;</span><span class="s2">, depth = </span><span class="s5">1 </span><span class="s2">},</span>
		<span class="s2">) {</span>
			<span class="s3">let </span><span class="s2">dirEntries;</span>

			<span class="s3">try </span><span class="s2">{</span>
				<span class="s2">dirEntries = </span><span class="s3">await this</span><span class="s2">.#callImplMethodWithoutLog(</span>
					<span class="s4">&quot;list&quot;</span><span class="s2">,</span>
					<span class="s2">dirPath,</span>
				<span class="s2">);</span>
			<span class="s2">} </span><span class="s3">catch </span><span class="s2">(error) {</span>
				<span class="s0">// if the directory does not exist then return an empty array</span>
				<span class="s3">if </span><span class="s2">(error.code === </span><span class="s4">&quot;ENOENT&quot;</span><span class="s2">) {</span>
					<span class="s3">return</span><span class="s2">;</span>
				<span class="s2">}</span>

				<span class="s0">// otherwise, rethrow the error</span>
				<span class="s3">throw </span><span class="s2">error;</span>
			<span class="s2">}</span>

			<span class="s3">for await </span><span class="s2">(</span><span class="s3">const </span><span class="s2">listEntry of dirEntries) {</span>
				<span class="s3">const </span><span class="s2">walkEntry = {</span>
					<span class="s2">path: listEntry.name,</span>
					<span class="s2">depth,</span>
					<span class="s2">...listEntry,</span>
				<span class="s2">};</span>

				<span class="s3">if </span><span class="s2">(parentPath) {</span>
					<span class="s2">walkEntry.path = </span><span class="s4">`</span><span class="s2">${parentPath}</span><span class="s4">/</span><span class="s2">${walkEntry.path}</span><span class="s4">`</span><span class="s2">;</span>
				<span class="s2">}</span>

				<span class="s0">// first emit the entry but only if the entry filter returns true</span>
				<span class="s3">let </span><span class="s2">shouldEmitEntry = entryFilter(walkEntry);</span>
				<span class="s3">if </span><span class="s2">(shouldEmitEntry.then) {</span>
					<span class="s2">shouldEmitEntry = </span><span class="s3">await </span><span class="s2">shouldEmitEntry;</span>
				<span class="s2">}</span>

				<span class="s3">if </span><span class="s2">(shouldEmitEntry) {</span>
					<span class="s3">yield </span><span class="s2">walkEntry;</span>
				<span class="s2">}</span>

				<span class="s0">// if it's a directory then yield the entry and walk the directory</span>
				<span class="s3">if </span><span class="s2">(listEntry.isDirectory) {</span>
					<span class="s0">// if the directory filter returns false, skip the directory</span>
					<span class="s3">let </span><span class="s2">shouldWalkDirectory = directoryFilter(walkEntry);</span>
					<span class="s3">if </span><span class="s2">(shouldWalkDirectory.then) {</span>
						<span class="s2">shouldWalkDirectory = </span><span class="s3">await </span><span class="s2">shouldWalkDirectory;</span>
					<span class="s2">}</span>

					<span class="s3">if </span><span class="s2">(!shouldWalkDirectory) {</span>
						<span class="s3">continue</span><span class="s2">;</span>
					<span class="s2">}</span>

					<span class="s0">// make sure there's a trailing slash on the directory path before appending</span>
					<span class="s3">const </span><span class="s2">directoryPath =</span>
						<span class="s2">dirPath </span><span class="s3">instanceof </span><span class="s2">URL</span>
							<span class="s2">? </span><span class="s3">new </span><span class="s2">URL(</span>
									<span class="s2">listEntry.name,</span>
									<span class="s2">dirPath.href.endsWith(</span><span class="s4">&quot;/&quot;</span><span class="s2">)</span>
										<span class="s2">? dirPath.href</span>
										<span class="s2">: </span><span class="s4">`</span><span class="s2">${dirPath.href}</span><span class="s4">/`</span><span class="s2">,</span>
								<span class="s2">)</span>
							<span class="s2">: </span><span class="s4">`</span><span class="s2">${dirPath.endsWith(</span><span class="s4">&quot;/&quot;</span><span class="s2">) ? dirPath : </span><span class="s4">`</span><span class="s2">${dirPath}</span><span class="s4">/`</span><span class="s2">}${listEntry.name}</span><span class="s4">`</span><span class="s2">;</span>

					<span class="s3">yield</span><span class="s2">* walk(directoryPath, {</span>
						<span class="s2">directoryFilter,</span>
						<span class="s2">entryFilter,</span>
						<span class="s2">parentPath: walkEntry.path,</span>
						<span class="s2">depth: depth + </span><span class="s5">1</span><span class="s2">,</span>
					<span class="s2">});</span>
				<span class="s2">}</span>
			<span class="s2">}</span>
		<span class="s2">}.bind(</span><span class="s3">this</span><span class="s2">);</span>

		<span class="s3">yield</span><span class="s2">* walk(dirPath, { directoryFilter, entryFilter });</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Returns the size of the given file.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|URL} filePath The path to the file to read.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise&lt;number&gt;} A promise that resolves with the size of the file.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} If the file path is not a string or URL.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} If the file cannot be read.</span>
	 <span class="s0">*/</span>
	<span class="s2">async size(filePath) {</span>
		<span class="s2">assertValidFileOrDirPath(filePath);</span>
		<span class="s3">return this</span><span class="s2">.#callImplMethod(</span><span class="s4">&quot;size&quot;</span><span class="s2">, filePath);</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Returns the last modified timestamp of the given file or directory.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|URL} fileOrDirPath The path to the file or directory.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise&lt;Date|undefined&gt;} A promise that resolves with the last modified date</span>
	 <span class="s0">*  or undefined if the file or directory does not exist.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} If the path is not a string or URL.</span>
	 <span class="s0">*/</span>
	<span class="s2">async lastModified(fileOrDirPath) {</span>
		<span class="s2">assertValidFileOrDirPath(fileOrDirPath);</span>
		<span class="s3">return this</span><span class="s2">.#callImplMethod(</span><span class="s4">&quot;lastModified&quot;</span><span class="s2">, fileOrDirPath);</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Copys a file from one location to another.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|URL} source The path to the file to copy.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|URL} destination The path to the new file.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise&lt;void&gt;} A promise that resolves when the file is copied.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} If the file path is not a string or URL.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} If the file cannot be copied.</span>
	 <span class="s0">*/</span>
	<span class="s2">async copy(source, destination) {</span>
		<span class="s2">assertValidFileOrDirPath(source);</span>
		<span class="s2">assertValidFileOrDirPath(destination);</span>
		<span class="s3">return this</span><span class="s2">.#callImplMethod(</span><span class="s4">&quot;copy&quot;</span><span class="s2">, source, destination);</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Copies a file or directory from one location to another.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|URL} source The path to the file or directory to copy.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|URL} destination The path to copy the file or directory to.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise&lt;void&gt;} A promise that resolves when the file or directory is</span>
	 <span class="s0">* copied.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} If the directory path is not a string or URL.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} If the directory cannot be copied.</span>
	 <span class="s0">*/</span>
	<span class="s2">async copyAll(source, destination) {</span>
		<span class="s2">assertValidFileOrDirPath(source);</span>
		<span class="s2">assertValidFileOrDirPath(destination);</span>
		<span class="s3">return this</span><span class="s2">.#callImplMethod(</span><span class="s4">&quot;copyAll&quot;</span><span class="s2">, source, destination);</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Moves a file from the source path to the destination path.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|URL} source The location of the file to move.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|URL} destination The destination of the file to move.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise&lt;void&gt;} A promise that resolves when the move is complete.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} If the file or directory paths are not strings.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} If the file or directory cannot be moved.</span>
	 <span class="s0">*/</span>
	<span class="s2">async move(source, destination) {</span>
		<span class="s2">assertValidFileOrDirPath(source);</span>
		<span class="s2">assertValidFileOrDirPath(destination);</span>
		<span class="s3">return this</span><span class="s2">.#callImplMethod(</span><span class="s4">&quot;move&quot;</span><span class="s2">, source, destination);</span>
	<span class="s2">}</span>

	<span class="s0">/**</span>
	 <span class="s0">* Moves a file or directory from one location to another.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|URL} source The path to the file or directory to move.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string|URL} destination The path to move the file or directory to.</span>
	 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Promise&lt;void&gt;} A promise that resolves when the file or directory is</span>
	 <span class="s0">* moved.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} If the source is not a string or URL.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} If the destination is not a string or URL.</span>
	 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{Error} If the file or directory cannot be moved.</span>
	 <span class="s0">*/</span>
	<span class="s2">async moveAll(source, destination) {</span>
		<span class="s2">assertValidFileOrDirPath(source);</span>
		<span class="s2">assertValidFileOrDirPath(destination);</span>
		<span class="s3">return this</span><span class="s2">.#callImplMethod(</span><span class="s4">&quot;moveAll&quot;</span><span class="s2">, source, destination);</span>
	<span class="s2">}</span>
<span class="s2">}</span>
</pre>
</body>
</html>