<html>
<head>
<title>trace-mapping.mjs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #067d17;}
.s4 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
trace-mapping.mjs</font>
</center></td></tr></table>
<pre><span class="s0">// src/trace-mapping.ts</span>
<span class="s2">import </span><span class="s1">{ encode, decode } from </span><span class="s3">&quot;@jridgewell/sourcemap-codec&quot;</span><span class="s1">;</span>

<span class="s0">// src/resolve.ts</span>
<span class="s2">import </span><span class="s1">resolveUri from </span><span class="s3">&quot;@jridgewell/resolve-uri&quot;</span><span class="s1">;</span>

<span class="s0">// src/strip-filename.ts</span>
<span class="s2">function </span><span class="s1">stripFilename(path) {</span>
  <span class="s2">if </span><span class="s1">(!path) </span><span class="s2">return </span><span class="s3">&quot;&quot;</span><span class="s1">;</span>
  <span class="s2">const </span><span class="s1">index = path.lastIndexOf(</span><span class="s3">&quot;/&quot;</span><span class="s1">);</span>
  <span class="s2">return </span><span class="s1">path.slice(</span><span class="s4">0</span><span class="s1">, index + </span><span class="s4">1</span><span class="s1">);</span>
<span class="s1">}</span>

<span class="s0">// src/resolve.ts</span>
<span class="s2">function </span><span class="s1">resolver(mapUrl, sourceRoot) {</span>
  <span class="s2">const </span><span class="s1">from = stripFilename(mapUrl);</span>
  <span class="s2">const </span><span class="s1">prefix = sourceRoot ? sourceRoot + </span><span class="s3">&quot;/&quot; </span><span class="s1">: </span><span class="s3">&quot;&quot;</span><span class="s1">;</span>
  <span class="s2">return </span><span class="s1">(source) =&gt; resolveUri(prefix + (source || </span><span class="s3">&quot;&quot;</span><span class="s1">), from);</span>
<span class="s1">}</span>

<span class="s0">// src/sourcemap-segment.ts</span>
<span class="s2">var </span><span class="s1">COLUMN = </span><span class="s4">0</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">SOURCES_INDEX = </span><span class="s4">1</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">SOURCE_LINE = </span><span class="s4">2</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">SOURCE_COLUMN = </span><span class="s4">3</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">NAMES_INDEX = </span><span class="s4">4</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">REV_GENERATED_LINE = </span><span class="s4">1</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">REV_GENERATED_COLUMN = </span><span class="s4">2</span><span class="s1">;</span>

<span class="s0">// src/sort.ts</span>
<span class="s2">function </span><span class="s1">maybeSort(mappings, owned) {</span>
  <span class="s2">const </span><span class="s1">unsortedIndex = nextUnsortedSegmentLine(mappings, </span><span class="s4">0</span><span class="s1">);</span>
  <span class="s2">if </span><span class="s1">(unsortedIndex === mappings.length) </span><span class="s2">return </span><span class="s1">mappings;</span>
  <span class="s2">if </span><span class="s1">(!owned) mappings = mappings.slice();</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = unsortedIndex; i &lt; mappings.length; i = nextUnsortedSegmentLine(mappings, i + </span><span class="s4">1</span><span class="s1">)) {</span>
    <span class="s1">mappings[i] = sortSegments(mappings[i], owned);</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">mappings;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">nextUnsortedSegmentLine(mappings, start) {</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = start; i &lt; mappings.length; i++) {</span>
    <span class="s2">if </span><span class="s1">(!isSorted(mappings[i])) </span><span class="s2">return </span><span class="s1">i;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">mappings.length;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isSorted(line) {</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">j = </span><span class="s4">1</span><span class="s1">; j &lt; line.length; j++) {</span>
    <span class="s2">if </span><span class="s1">(line[j][COLUMN] &lt; line[j - </span><span class="s4">1</span><span class="s1">][COLUMN]) {</span>
      <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">return true</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">sortSegments(line, owned) {</span>
  <span class="s2">if </span><span class="s1">(!owned) line = line.slice();</span>
  <span class="s2">return </span><span class="s1">line.sort(sortComparator);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">sortComparator(a, b) {</span>
  <span class="s2">return </span><span class="s1">a[COLUMN] - b[COLUMN];</span>
<span class="s1">}</span>

<span class="s0">// src/by-source.ts</span>
<span class="s2">function </span><span class="s1">buildBySources(decoded, memos) {</span>
  <span class="s2">const </span><span class="s1">sources = memos.map(() =&gt; []);</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; decoded.length; i++) {</span>
    <span class="s2">const </span><span class="s1">line = decoded[i];</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">j = </span><span class="s4">0</span><span class="s1">; j &lt; line.length; j++) {</span>
      <span class="s2">const </span><span class="s1">seg = line[j];</span>
      <span class="s2">if </span><span class="s1">(seg.length === </span><span class="s4">1</span><span class="s1">) </span><span class="s2">continue</span><span class="s1">;</span>
      <span class="s2">const </span><span class="s1">sourceIndex2 = seg[SOURCES_INDEX];</span>
      <span class="s2">const </span><span class="s1">sourceLine = seg[SOURCE_LINE];</span>
      <span class="s2">const </span><span class="s1">sourceColumn = seg[SOURCE_COLUMN];</span>
      <span class="s2">const </span><span class="s1">source = sources[sourceIndex2];</span>
      <span class="s2">const </span><span class="s1">segs = source[sourceLine] || (source[sourceLine] = []);</span>
      <span class="s1">segs.push([sourceColumn, i, seg[COLUMN]]);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; sources.length; i++) {</span>
    <span class="s2">const </span><span class="s1">source = sources[i];</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">j = </span><span class="s4">0</span><span class="s1">; j &lt; source.length; j++) {</span>
      <span class="s2">const </span><span class="s1">line = source[j];</span>
      <span class="s2">if </span><span class="s1">(line) line.sort(sortComparator);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">sources;</span>
<span class="s1">}</span>

<span class="s0">// src/binary-search.ts</span>
<span class="s2">var </span><span class="s1">found = </span><span class="s2">false</span><span class="s1">;</span>
<span class="s2">function </span><span class="s1">binarySearch(haystack, needle, low, high) {</span>
  <span class="s2">while </span><span class="s1">(low &lt;= high) {</span>
    <span class="s2">const </span><span class="s1">mid = low + (high - low &gt;&gt; </span><span class="s4">1</span><span class="s1">);</span>
    <span class="s2">const </span><span class="s1">cmp = haystack[mid][COLUMN] - needle;</span>
    <span class="s2">if </span><span class="s1">(cmp === </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">found = </span><span class="s2">true</span><span class="s1">;</span>
      <span class="s2">return </span><span class="s1">mid;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(cmp &lt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">low = mid + </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">high = mid - </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">found = </span><span class="s2">false</span><span class="s1">;</span>
  <span class="s2">return </span><span class="s1">low - </span><span class="s4">1</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">upperBound(haystack, needle, index) {</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = index + </span><span class="s4">1</span><span class="s1">; i &lt; haystack.length; index = i++) {</span>
    <span class="s2">if </span><span class="s1">(haystack[i][COLUMN] !== needle) </span><span class="s2">break</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">index;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">lowerBound(haystack, needle, index) {</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = index - </span><span class="s4">1</span><span class="s1">; i &gt;= </span><span class="s4">0</span><span class="s1">; index = i--) {</span>
    <span class="s2">if </span><span class="s1">(haystack[i][COLUMN] !== needle) </span><span class="s2">break</span><span class="s1">;</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">index;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">memoizedState() {</span>
  <span class="s2">return </span><span class="s1">{</span>
    <span class="s1">lastKey: -</span><span class="s4">1</span><span class="s1">,</span>
    <span class="s1">lastNeedle: -</span><span class="s4">1</span><span class="s1">,</span>
    <span class="s1">lastIndex: -</span><span class="s4">1</span>
  <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">memoizedBinarySearch(haystack, needle, state, key) {</span>
  <span class="s2">const </span><span class="s1">{ lastKey, lastNeedle, lastIndex } = state;</span>
  <span class="s2">let </span><span class="s1">low = </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s2">let </span><span class="s1">high = haystack.length - </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s2">if </span><span class="s1">(key === lastKey) {</span>
    <span class="s2">if </span><span class="s1">(needle === lastNeedle) {</span>
      <span class="s1">found = lastIndex !== -</span><span class="s4">1 </span><span class="s1">&amp;&amp; haystack[lastIndex][COLUMN] === needle;</span>
      <span class="s2">return </span><span class="s1">lastIndex;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(needle &gt;= lastNeedle) {</span>
      <span class="s1">low = lastIndex === -</span><span class="s4">1 </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: lastIndex;</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s1">high = lastIndex;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s1">state.lastKey = key;</span>
  <span class="s1">state.lastNeedle = needle;</span>
  <span class="s2">return </span><span class="s1">state.lastIndex = binarySearch(haystack, needle, low, high);</span>
<span class="s1">}</span>

<span class="s0">// src/types.ts</span>
<span class="s2">function </span><span class="s1">parse(map) {</span>
  <span class="s2">return typeof </span><span class="s1">map === </span><span class="s3">&quot;string&quot; </span><span class="s1">? JSON.parse(map) : map;</span>
<span class="s1">}</span>

<span class="s0">// src/flatten-map.ts</span>
<span class="s2">var </span><span class="s1">FlattenMap = </span><span class="s2">function</span><span class="s1">(map, mapUrl) {</span>
  <span class="s2">const </span><span class="s1">parsed = parse(map);</span>
  <span class="s2">if </span><span class="s1">(!(</span><span class="s3">&quot;sections&quot; </span><span class="s2">in </span><span class="s1">parsed)) {</span>
    <span class="s2">return new </span><span class="s1">TraceMap(parsed, mapUrl);</span>
  <span class="s1">}</span>
  <span class="s2">const </span><span class="s1">mappings = [];</span>
  <span class="s2">const </span><span class="s1">sources = [];</span>
  <span class="s2">const </span><span class="s1">sourcesContent = [];</span>
  <span class="s2">const </span><span class="s1">names = [];</span>
  <span class="s2">const </span><span class="s1">ignoreList = [];</span>
  <span class="s1">recurse(</span>
    <span class="s1">parsed,</span>
    <span class="s1">mapUrl,</span>
    <span class="s1">mappings,</span>
    <span class="s1">sources,</span>
    <span class="s1">sourcesContent,</span>
    <span class="s1">names,</span>
    <span class="s1">ignoreList,</span>
    <span class="s4">0</span><span class="s1">,</span>
    <span class="s4">0</span><span class="s1">,</span>
    <span class="s1">Infinity,</span>
    <span class="s1">Infinity</span>
  <span class="s1">);</span>
  <span class="s2">const </span><span class="s1">joined = {</span>
    <span class="s1">version: </span><span class="s4">3</span><span class="s1">,</span>
    <span class="s1">file: parsed.file,</span>
    <span class="s1">names,</span>
    <span class="s1">sources,</span>
    <span class="s1">sourcesContent,</span>
    <span class="s1">mappings,</span>
    <span class="s1">ignoreList</span>
  <span class="s1">};</span>
  <span class="s2">return </span><span class="s1">presortedDecodedMap(joined);</span>
<span class="s1">};</span>
<span class="s2">function </span><span class="s1">recurse(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {</span>
  <span class="s2">const </span><span class="s1">{ sections } = input;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; sections.length; i++) {</span>
    <span class="s2">const </span><span class="s1">{ map, offset } = sections[i];</span>
    <span class="s2">let </span><span class="s1">sl = stopLine;</span>
    <span class="s2">let </span><span class="s1">sc = stopColumn;</span>
    <span class="s2">if </span><span class="s1">(i + </span><span class="s4">1 </span><span class="s1">&lt; sections.length) {</span>
      <span class="s2">const </span><span class="s1">nextOffset = sections[i + </span><span class="s4">1</span><span class="s1">].offset;</span>
      <span class="s1">sl = Math.min(stopLine, lineOffset + nextOffset.line);</span>
      <span class="s2">if </span><span class="s1">(sl === stopLine) {</span>
        <span class="s1">sc = Math.min(stopColumn, columnOffset + nextOffset.column);</span>
      <span class="s1">} </span><span class="s2">else if </span><span class="s1">(sl &lt; stopLine) {</span>
        <span class="s1">sc = columnOffset + nextOffset.column;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">addSection(</span>
      <span class="s1">map,</span>
      <span class="s1">mapUrl,</span>
      <span class="s1">mappings,</span>
      <span class="s1">sources,</span>
      <span class="s1">sourcesContent,</span>
      <span class="s1">names,</span>
      <span class="s1">ignoreList,</span>
      <span class="s1">lineOffset + offset.line,</span>
      <span class="s1">columnOffset + offset.column,</span>
      <span class="s1">sl,</span>
      <span class="s1">sc</span>
    <span class="s1">);</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">addSection(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {</span>
  <span class="s2">const </span><span class="s1">parsed = parse(input);</span>
  <span class="s2">if </span><span class="s1">(</span><span class="s3">&quot;sections&quot; </span><span class="s2">in </span><span class="s1">parsed) </span><span class="s2">return </span><span class="s1">recurse(...arguments);</span>
  <span class="s2">const </span><span class="s1">map = </span><span class="s2">new </span><span class="s1">TraceMap(parsed, mapUrl);</span>
  <span class="s2">const </span><span class="s1">sourcesOffset = sources.length;</span>
  <span class="s2">const </span><span class="s1">namesOffset = names.length;</span>
  <span class="s2">const </span><span class="s1">decoded = decodedMappings(map);</span>
  <span class="s2">const </span><span class="s1">{ resolvedSources, sourcesContent: contents, ignoreList: ignores } = map;</span>
  <span class="s1">append(sources, resolvedSources);</span>
  <span class="s1">append(names, map.names);</span>
  <span class="s2">if </span><span class="s1">(contents) append(sourcesContent, contents);</span>
  <span class="s2">else for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; resolvedSources.length; i++) sourcesContent.push(</span><span class="s2">null</span><span class="s1">);</span>
  <span class="s2">if </span><span class="s1">(ignores) </span><span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; ignores.length; i++) ignoreList.push(ignores[i] + sourcesOffset);</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; decoded.length; i++) {</span>
    <span class="s2">const </span><span class="s1">lineI = lineOffset + i;</span>
    <span class="s2">if </span><span class="s1">(lineI &gt; stopLine) </span><span class="s2">return</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">out = getLine(mappings, lineI);</span>
    <span class="s2">const </span><span class="s1">cOffset = i === </span><span class="s4">0 </span><span class="s1">? columnOffset : </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">line = decoded[i];</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">j = </span><span class="s4">0</span><span class="s1">; j &lt; line.length; j++) {</span>
      <span class="s2">const </span><span class="s1">seg = line[j];</span>
      <span class="s2">const </span><span class="s1">column = cOffset + seg[COLUMN];</span>
      <span class="s2">if </span><span class="s1">(lineI === stopLine &amp;&amp; column &gt;= stopColumn) </span><span class="s2">return</span><span class="s1">;</span>
      <span class="s2">if </span><span class="s1">(seg.length === </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">out.push([column]);</span>
        <span class="s2">continue</span><span class="s1">;</span>
      <span class="s1">}</span>
      <span class="s2">const </span><span class="s1">sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];</span>
      <span class="s2">const </span><span class="s1">sourceLine = seg[SOURCE_LINE];</span>
      <span class="s2">const </span><span class="s1">sourceColumn = seg[SOURCE_COLUMN];</span>
      <span class="s1">out.push(</span>
        <span class="s1">seg.length === </span><span class="s4">4 </span><span class="s1">? [column, sourcesIndex, sourceLine, sourceColumn] : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]</span>
      <span class="s1">);</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">append(arr, other) {</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; other.length; i++) arr.push(other[i]);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">getLine(arr, index) {</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = arr.length; i &lt;= index; i++) arr[i] = [];</span>
  <span class="s2">return </span><span class="s1">arr[index];</span>
<span class="s1">}</span>

<span class="s0">// src/trace-mapping.ts</span>
<span class="s2">var </span><span class="s1">LINE_GTR_ZERO = </span><span class="s3">&quot;`line` must be greater than 0 (lines start at line 1)&quot;</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">COL_GTR_EQ_ZERO = </span><span class="s3">&quot;`column` must be greater than or equal to 0 (columns start at column 0)&quot;</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">LEAST_UPPER_BOUND = -</span><span class="s4">1</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">GREATEST_LOWER_BOUND = </span><span class="s4">1</span><span class="s1">;</span>
<span class="s2">var </span><span class="s1">TraceMap = </span><span class="s2">class </span><span class="s1">{</span>
  <span class="s1">constructor(map, mapUrl) {</span>
    <span class="s2">const </span><span class="s1">isString = </span><span class="s2">typeof </span><span class="s1">map === </span><span class="s3">&quot;string&quot;</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(!isString &amp;&amp; map._decodedMemo) </span><span class="s2">return </span><span class="s1">map;</span>
    <span class="s2">const </span><span class="s1">parsed = parse(map);</span>
    <span class="s2">const </span><span class="s1">{ version, file, names, sourceRoot, sources, sourcesContent } = parsed;</span>
    <span class="s2">this</span><span class="s1">.version = version;</span>
    <span class="s2">this</span><span class="s1">.file = file;</span>
    <span class="s2">this</span><span class="s1">.names = names || [];</span>
    <span class="s2">this</span><span class="s1">.sourceRoot = sourceRoot;</span>
    <span class="s2">this</span><span class="s1">.sources = sources;</span>
    <span class="s2">this</span><span class="s1">.sourcesContent = sourcesContent;</span>
    <span class="s2">this</span><span class="s1">.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || </span><span class="s2">void </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s2">const </span><span class="s1">resolve = resolver(mapUrl, sourceRoot);</span>
    <span class="s2">this</span><span class="s1">.resolvedSources = sources.map(resolve);</span>
    <span class="s2">const </span><span class="s1">{ mappings } = parsed;</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">mappings === </span><span class="s3">&quot;string&quot;</span><span class="s1">) {</span>
      <span class="s2">this</span><span class="s1">._encoded = mappings;</span>
      <span class="s2">this</span><span class="s1">._decoded = </span><span class="s2">void </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(Array.isArray(mappings)) {</span>
      <span class="s2">this</span><span class="s1">._encoded = </span><span class="s2">void </span><span class="s4">0</span><span class="s1">;</span>
      <span class="s2">this</span><span class="s1">._decoded = maybeSort(mappings, isString);</span>
    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(parsed.sections) {</span>
      <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">`TraceMap passed sectioned source map, please use FlattenMap export instead`</span><span class="s1">);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
      <span class="s2">throw new </span><span class="s1">Error(</span><span class="s3">`invalid source map: </span><span class="s1">${JSON.stringify(parsed)}</span><span class="s3">`</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s2">this</span><span class="s1">._decodedMemo = memoizedState();</span>
    <span class="s2">this</span><span class="s1">._bySources = </span><span class="s2">void </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s2">this</span><span class="s1">._bySourceMemos = </span><span class="s2">void </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s1">}</span>
<span class="s1">};</span>
<span class="s2">function </span><span class="s1">cast(map) {</span>
  <span class="s2">return </span><span class="s1">map;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">encodedMappings(map) {</span>
  <span class="s2">var </span><span class="s1">_a, _b;</span>
  <span class="s2">return </span><span class="s1">(_b = (_a = cast(map))._encoded) != </span><span class="s2">null </span><span class="s1">? _b : _a._encoded = encode(cast(map)._decoded);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">decodedMappings(map) {</span>
  <span class="s2">var </span><span class="s1">_a;</span>
  <span class="s2">return </span><span class="s1">(_a = cast(map))._decoded || (_a._decoded = decode(cast(map)._encoded));</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">traceSegment(map, line, column) {</span>
  <span class="s2">const </span><span class="s1">decoded = decodedMappings(map);</span>
  <span class="s2">if </span><span class="s1">(line &gt;= decoded.length) </span><span class="s2">return null</span><span class="s1">;</span>
  <span class="s2">const </span><span class="s1">segments = decoded[line];</span>
  <span class="s2">const </span><span class="s1">index = traceSegmentInternal(</span>
    <span class="s1">segments,</span>
    <span class="s1">cast(map)._decodedMemo,</span>
    <span class="s1">line,</span>
    <span class="s1">column,</span>
    <span class="s1">GREATEST_LOWER_BOUND</span>
  <span class="s1">);</span>
  <span class="s2">return </span><span class="s1">index === -</span><span class="s4">1 </span><span class="s1">? </span><span class="s2">null </span><span class="s1">: segments[index];</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">originalPositionFor(map, needle) {</span>
  <span class="s2">let </span><span class="s1">{ line, column, bias } = needle;</span>
  <span class="s1">line--;</span>
  <span class="s2">if </span><span class="s1">(line &lt; </span><span class="s4">0</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">Error(LINE_GTR_ZERO);</span>
  <span class="s2">if </span><span class="s1">(column &lt; </span><span class="s4">0</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">Error(COL_GTR_EQ_ZERO);</span>
  <span class="s2">const </span><span class="s1">decoded = decodedMappings(map);</span>
  <span class="s2">if </span><span class="s1">(line &gt;= decoded.length) </span><span class="s2">return </span><span class="s1">OMapping(</span><span class="s2">null</span><span class="s1">, </span><span class="s2">null</span><span class="s1">, </span><span class="s2">null</span><span class="s1">, </span><span class="s2">null</span><span class="s1">);</span>
  <span class="s2">const </span><span class="s1">segments = decoded[line];</span>
  <span class="s2">const </span><span class="s1">index = traceSegmentInternal(</span>
    <span class="s1">segments,</span>
    <span class="s1">cast(map)._decodedMemo,</span>
    <span class="s1">line,</span>
    <span class="s1">column,</span>
    <span class="s1">bias || GREATEST_LOWER_BOUND</span>
  <span class="s1">);</span>
  <span class="s2">if </span><span class="s1">(index === -</span><span class="s4">1</span><span class="s1">) </span><span class="s2">return </span><span class="s1">OMapping(</span><span class="s2">null</span><span class="s1">, </span><span class="s2">null</span><span class="s1">, </span><span class="s2">null</span><span class="s1">, </span><span class="s2">null</span><span class="s1">);</span>
  <span class="s2">const </span><span class="s1">segment = segments[index];</span>
  <span class="s2">if </span><span class="s1">(segment.length === </span><span class="s4">1</span><span class="s1">) </span><span class="s2">return </span><span class="s1">OMapping(</span><span class="s2">null</span><span class="s1">, </span><span class="s2">null</span><span class="s1">, </span><span class="s2">null</span><span class="s1">, </span><span class="s2">null</span><span class="s1">);</span>
  <span class="s2">const </span><span class="s1">{ names, resolvedSources } = map;</span>
  <span class="s2">return </span><span class="s1">OMapping(</span>
    <span class="s1">resolvedSources[segment[SOURCES_INDEX]],</span>
    <span class="s1">segment[SOURCE_LINE] + </span><span class="s4">1</span><span class="s1">,</span>
    <span class="s1">segment[SOURCE_COLUMN],</span>
    <span class="s1">segment.length === </span><span class="s4">5 </span><span class="s1">? names[segment[NAMES_INDEX]] : </span><span class="s2">null</span>
  <span class="s1">);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">generatedPositionFor(map, needle) {</span>
  <span class="s2">const </span><span class="s1">{ source, line, column, bias } = needle;</span>
  <span class="s2">return </span><span class="s1">generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, </span><span class="s2">false</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">allGeneratedPositionsFor(map, needle) {</span>
  <span class="s2">const </span><span class="s1">{ source, line, column, bias } = needle;</span>
  <span class="s2">return </span><span class="s1">generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, </span><span class="s2">true</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">eachMapping(map, cb) {</span>
  <span class="s2">const </span><span class="s1">decoded = decodedMappings(map);</span>
  <span class="s2">const </span><span class="s1">{ names, resolvedSources } = map;</span>
  <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; decoded.length; i++) {</span>
    <span class="s2">const </span><span class="s1">line = decoded[i];</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">let </span><span class="s1">j = </span><span class="s4">0</span><span class="s1">; j &lt; line.length; j++) {</span>
      <span class="s2">const </span><span class="s1">seg = line[j];</span>
      <span class="s2">const </span><span class="s1">generatedLine = i + </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s2">const </span><span class="s1">generatedColumn = seg[</span><span class="s4">0</span><span class="s1">];</span>
      <span class="s2">let </span><span class="s1">source = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s2">let </span><span class="s1">originalLine = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s2">let </span><span class="s1">originalColumn = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s2">let </span><span class="s1">name = </span><span class="s2">null</span><span class="s1">;</span>
      <span class="s2">if </span><span class="s1">(seg.length !== </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s1">source = resolvedSources[seg[</span><span class="s4">1</span><span class="s1">]];</span>
        <span class="s1">originalLine = seg[</span><span class="s4">2</span><span class="s1">] + </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s1">originalColumn = seg[</span><span class="s4">3</span><span class="s1">];</span>
      <span class="s1">}</span>
      <span class="s2">if </span><span class="s1">(seg.length === </span><span class="s4">5</span><span class="s1">) name = names[seg[</span><span class="s4">4</span><span class="s1">]];</span>
      <span class="s1">cb({</span>
        <span class="s1">generatedLine,</span>
        <span class="s1">generatedColumn,</span>
        <span class="s1">source,</span>
        <span class="s1">originalLine,</span>
        <span class="s1">originalColumn,</span>
        <span class="s1">name</span>
      <span class="s1">});</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">sourceIndex(map, source) {</span>
  <span class="s2">const </span><span class="s1">{ sources, resolvedSources } = map;</span>
  <span class="s2">let </span><span class="s1">index = sources.indexOf(source);</span>
  <span class="s2">if </span><span class="s1">(index === -</span><span class="s4">1</span><span class="s1">) index = resolvedSources.indexOf(source);</span>
  <span class="s2">return </span><span class="s1">index;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">sourceContentFor(map, source) {</span>
  <span class="s2">const </span><span class="s1">{ sourcesContent } = map;</span>
  <span class="s2">if </span><span class="s1">(sourcesContent == </span><span class="s2">null</span><span class="s1">) </span><span class="s2">return null</span><span class="s1">;</span>
  <span class="s2">const </span><span class="s1">index = sourceIndex(map, source);</span>
  <span class="s2">return </span><span class="s1">index === -</span><span class="s4">1 </span><span class="s1">? </span><span class="s2">null </span><span class="s1">: sourcesContent[index];</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">isIgnored(map, source) {</span>
  <span class="s2">const </span><span class="s1">{ ignoreList } = map;</span>
  <span class="s2">if </span><span class="s1">(ignoreList == </span><span class="s2">null</span><span class="s1">) </span><span class="s2">return false</span><span class="s1">;</span>
  <span class="s2">const </span><span class="s1">index = sourceIndex(map, source);</span>
  <span class="s2">return </span><span class="s1">index === -</span><span class="s4">1 </span><span class="s1">? </span><span class="s2">false </span><span class="s1">: ignoreList.includes(index);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">presortedDecodedMap(map, mapUrl) {</span>
  <span class="s2">const </span><span class="s1">tracer = </span><span class="s2">new </span><span class="s1">TraceMap(clone(map, []), mapUrl);</span>
  <span class="s1">cast(tracer)._decoded = map.mappings;</span>
  <span class="s2">return </span><span class="s1">tracer;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">decodedMap(map) {</span>
  <span class="s2">return </span><span class="s1">clone(map, decodedMappings(map));</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">encodedMap(map) {</span>
  <span class="s2">return </span><span class="s1">clone(map, encodedMappings(map));</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">clone(map, mappings) {</span>
  <span class="s2">return </span><span class="s1">{</span>
    <span class="s1">version: map.version,</span>
    <span class="s1">file: map.file,</span>
    <span class="s1">names: map.names,</span>
    <span class="s1">sourceRoot: map.sourceRoot,</span>
    <span class="s1">sources: map.sources,</span>
    <span class="s1">sourcesContent: map.sourcesContent,</span>
    <span class="s1">mappings,</span>
    <span class="s1">ignoreList: map.ignoreList || map.x_google_ignoreList</span>
  <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">OMapping(source, line, column, name) {</span>
  <span class="s2">return </span><span class="s1">{ source, line, column, name };</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">GMapping(line, column) {</span>
  <span class="s2">return </span><span class="s1">{ line, column };</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">traceSegmentInternal(segments, memo, line, column, bias) {</span>
  <span class="s2">let </span><span class="s1">index = memoizedBinarySearch(segments, column, memo, line);</span>
  <span class="s2">if </span><span class="s1">(found) {</span>
    <span class="s1">index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);</span>
  <span class="s1">} </span><span class="s2">else if </span><span class="s1">(bias === LEAST_UPPER_BOUND) index++;</span>
  <span class="s2">if </span><span class="s1">(index === -</span><span class="s4">1 </span><span class="s1">|| index === segments.length) </span><span class="s2">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s2">return </span><span class="s1">index;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">sliceGeneratedPositions(segments, memo, line, column, bias) {</span>
  <span class="s2">let </span><span class="s1">min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);</span>
  <span class="s2">if </span><span class="s1">(!found &amp;&amp; bias === LEAST_UPPER_BOUND) min++;</span>
  <span class="s2">if </span><span class="s1">(min === -</span><span class="s4">1 </span><span class="s1">|| min === segments.length) </span><span class="s2">return </span><span class="s1">[];</span>
  <span class="s2">const </span><span class="s1">matchedColumn = found ? column : segments[min][COLUMN];</span>
  <span class="s2">if </span><span class="s1">(!found) min = lowerBound(segments, matchedColumn, min);</span>
  <span class="s2">const </span><span class="s1">max = upperBound(segments, matchedColumn, min);</span>
  <span class="s2">const </span><span class="s1">result = [];</span>
  <span class="s2">for </span><span class="s1">(; min &lt;= max; min++) {</span>
    <span class="s2">const </span><span class="s1">segment = segments[min];</span>
    <span class="s1">result.push(GMapping(segment[REV_GENERATED_LINE] + </span><span class="s4">1</span><span class="s1">, segment[REV_GENERATED_COLUMN]));</span>
  <span class="s1">}</span>
  <span class="s2">return </span><span class="s1">result;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">generatedPosition(map, source, line, column, bias, all) {</span>
  <span class="s2">var </span><span class="s1">_a, _b;</span>
  <span class="s1">line--;</span>
  <span class="s2">if </span><span class="s1">(line &lt; </span><span class="s4">0</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">Error(LINE_GTR_ZERO);</span>
  <span class="s2">if </span><span class="s1">(column &lt; </span><span class="s4">0</span><span class="s1">) </span><span class="s2">throw new </span><span class="s1">Error(COL_GTR_EQ_ZERO);</span>
  <span class="s2">const </span><span class="s1">{ sources, resolvedSources } = map;</span>
  <span class="s2">let </span><span class="s1">sourceIndex2 = sources.indexOf(source);</span>
  <span class="s2">if </span><span class="s1">(sourceIndex2 === -</span><span class="s4">1</span><span class="s1">) sourceIndex2 = resolvedSources.indexOf(source);</span>
  <span class="s2">if </span><span class="s1">(sourceIndex2 === -</span><span class="s4">1</span><span class="s1">) </span><span class="s2">return </span><span class="s1">all ? [] : GMapping(</span><span class="s2">null</span><span class="s1">, </span><span class="s2">null</span><span class="s1">);</span>
  <span class="s2">const </span><span class="s1">bySourceMemos = (_a = cast(map))._bySourceMemos || (_a._bySourceMemos = sources.map(memoizedState));</span>
  <span class="s2">const </span><span class="s1">generated = (_b = cast(map))._bySources || (_b._bySources = buildBySources(decodedMappings(map), bySourceMemos));</span>
  <span class="s2">const </span><span class="s1">segments = generated[sourceIndex2][line];</span>
  <span class="s2">if </span><span class="s1">(segments == </span><span class="s2">null</span><span class="s1">) </span><span class="s2">return </span><span class="s1">all ? [] : GMapping(</span><span class="s2">null</span><span class="s1">, </span><span class="s2">null</span><span class="s1">);</span>
  <span class="s2">const </span><span class="s1">memo = bySourceMemos[sourceIndex2];</span>
  <span class="s2">if </span><span class="s1">(all) </span><span class="s2">return </span><span class="s1">sliceGeneratedPositions(segments, memo, line, column, bias);</span>
  <span class="s2">const </span><span class="s1">index = traceSegmentInternal(segments, memo, line, column, bias);</span>
  <span class="s2">if </span><span class="s1">(index === -</span><span class="s4">1</span><span class="s1">) </span><span class="s2">return </span><span class="s1">GMapping(</span><span class="s2">null</span><span class="s1">, </span><span class="s2">null</span><span class="s1">);</span>
  <span class="s2">const </span><span class="s1">segment = segments[index];</span>
  <span class="s2">return </span><span class="s1">GMapping(segment[REV_GENERATED_LINE] + </span><span class="s4">1</span><span class="s1">, segment[REV_GENERATED_COLUMN]);</span>
<span class="s1">}</span>
<span class="s2">export </span><span class="s1">{</span>
  <span class="s1">FlattenMap as AnyMap,</span>
  <span class="s1">FlattenMap,</span>
  <span class="s1">GREATEST_LOWER_BOUND,</span>
  <span class="s1">LEAST_UPPER_BOUND,</span>
  <span class="s1">TraceMap,</span>
  <span class="s1">allGeneratedPositionsFor,</span>
  <span class="s1">decodedMap,</span>
  <span class="s1">decodedMappings,</span>
  <span class="s1">eachMapping,</span>
  <span class="s1">encodedMap,</span>
  <span class="s1">encodedMappings,</span>
  <span class="s1">generatedPositionFor,</span>
  <span class="s1">isIgnored,</span>
  <span class="s1">originalPositionFor,</span>
  <span class="s1">presortedDecodedMap,</span>
  <span class="s1">sourceContentFor,</span>
  <span class="s1">traceSegment</span>
<span class="s1">};</span>
<span class="s0">//# sourceMappingURL=trace-mapping.mjs.map</span>
</pre>
</body>
</html>