<html>
<head>
<title>create-initial-router-state.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
create-initial-router-state.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../src/client/components/router-reducer/create-initial-router-state.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import type { FlightDataPath } from '../../../server/app-render/types'</span><span class="s3">\n\n</span><span class="s1">import { createHrefFromUrl } from './create-href-from-url'</span><span class="s3">\n</span><span class="s1">import { fillLazyItemsTillLeafWithHead } from './fill-lazy-items-till-leaf-with-head'</span><span class="s3">\n</span><span class="s1">import { extractPathFromFlightRouterState } from './compute-changed-path'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">createSeededPrefetchCacheEntry,</span><span class="s3">\n  </span><span class="s1">STATIC_STALETIME_MS,</span><span class="s3">\n</span><span class="s1">} from './prefetch-cache-utils'</span><span class="s3">\n</span><span class="s1">import { PrefetchKind, type PrefetchCacheEntry } from './router-reducer-types'</span><span class="s3">\n</span><span class="s1">import { addRefreshMarkerToActiveParallelSegments } from './refetch-inactive-parallel-segments'</span><span class="s3">\n</span><span class="s1">import { getFlightDataPartsFromPath } from '../../flight-data-helpers'</span><span class="s3">\n\n</span><span class="s1">export interface InitialRouterStateParameters {</span><span class="s3">\n  </span><span class="s1">navigatedAt: number</span><span class="s3">\n  </span><span class="s1">initialCanonicalUrlParts: string[]</span><span class="s3">\n  </span><span class="s1">initialParallelRoutes: CacheNode['parallelRoutes']</span><span class="s3">\n  </span><span class="s1">initialFlightData: FlightDataPath[]</span><span class="s3">\n  </span><span class="s1">location: Location | null</span><span class="s3">\n  </span><span class="s1">couldBeIntercepted: boolean</span><span class="s3">\n  </span><span class="s1">postponed: boolean</span><span class="s3">\n  </span><span class="s1">prerendered: boolean</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function createInitialRouterState({</span><span class="s3">\n  </span><span class="s1">navigatedAt,</span><span class="s3">\n  </span><span class="s1">initialFlightData,</span><span class="s3">\n  </span><span class="s1">initialCanonicalUrlParts,</span><span class="s3">\n  </span><span class="s1">initialParallelRoutes,</span><span class="s3">\n  </span><span class="s1">location,</span><span class="s3">\n  </span><span class="s1">couldBeIntercepted,</span><span class="s3">\n  </span><span class="s1">postponed,</span><span class="s3">\n  </span><span class="s1">prerendered,</span><span class="s3">\n</span><span class="s1">}: InitialRouterStateParameters) {</span><span class="s3">\n  </span><span class="s1">// When initialized on the server, the canonical URL is provided as an array of parts.</span><span class="s3">\n  </span><span class="s1">// This is to ensure that when the RSC payload streamed to the client, crawlers don't interpret it</span><span class="s3">\n  </span><span class="s1">// as a URL that should be crawled.</span><span class="s3">\n  </span><span class="s1">const initialCanonicalUrl = initialCanonicalUrlParts.join('/')</span><span class="s3">\n\n  </span><span class="s1">const normalizedFlightData = getFlightDataPartsFromPath(initialFlightData[0])</span><span class="s3">\n  </span><span class="s1">const {</span><span class="s3">\n    </span><span class="s1">tree: initialTree,</span><span class="s3">\n    </span><span class="s1">seedData: initialSeedData,</span><span class="s3">\n    </span><span class="s1">head: initialHead,</span><span class="s3">\n  </span><span class="s1">} = normalizedFlightData</span><span class="s3">\n  </span><span class="s1">// For the SSR render, seed data should always be available (we only send back a `null` response</span><span class="s3">\n  </span><span class="s1">// in the case of a `loading` segment, pre-PPR.)</span><span class="s3">\n  </span><span class="s1">const rsc = initialSeedData?.[1]</span><span class="s3">\n  </span><span class="s1">const loading = initialSeedData?.[3] ?? null</span><span class="s3">\n\n  </span><span class="s1">const cache: CacheNode = {</span><span class="s3">\n    </span><span class="s1">lazyData: null,</span><span class="s3">\n    </span><span class="s1">rsc,</span><span class="s3">\n    </span><span class="s1">prefetchRsc: null,</span><span class="s3">\n    </span><span class="s1">head: null,</span><span class="s3">\n    </span><span class="s1">prefetchHead: null,</span><span class="s3">\n    </span><span class="s1">// The cache gets seeded during the first render. `initialParallelRoutes` ensures the cache from the first render is there during the second render.</span><span class="s3">\n    </span><span class="s1">parallelRoutes: initialParallelRoutes,</span><span class="s3">\n    </span><span class="s1">loading,</span><span class="s3">\n    </span><span class="s1">navigatedAt,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const canonicalUrl =</span><span class="s3">\n    </span><span class="s1">// location.href is read as the initial value for canonicalUrl in the browser</span><span class="s3">\n    </span><span class="s1">// This is safe to do as canonicalUrl can't be rendered, it's only used to control the history updates in the useEffect further down in this file.</span><span class="s3">\n    </span><span class="s1">location</span><span class="s3">\n      </span><span class="s1">? // window.location does not have the same type as URL but has all the fields createHrefFromUrl needs.</span><span class="s3">\n        </span><span class="s1">createHrefFromUrl(location)</span><span class="s3">\n      </span><span class="s1">: initialCanonicalUrl</span><span class="s3">\n\n  </span><span class="s1">addRefreshMarkerToActiveParallelSegments(initialTree, canonicalUrl)</span><span class="s3">\n\n  </span><span class="s1">const prefetchCache = new Map&lt;string, PrefetchCacheEntry&gt;()</span><span class="s3">\n\n  </span><span class="s1">// When the cache hasn't been seeded yet we fill the cache with the head.</span><span class="s3">\n  </span><span class="s1">if (initialParallelRoutes === null || initialParallelRoutes.size === 0) {</span><span class="s3">\n    </span><span class="s1">fillLazyItemsTillLeafWithHead(</span><span class="s3">\n      </span><span class="s1">navigatedAt,</span><span class="s3">\n      </span><span class="s1">cache,</span><span class="s3">\n      </span><span class="s1">undefined,</span><span class="s3">\n      </span><span class="s1">initialTree,</span><span class="s3">\n      </span><span class="s1">initialSeedData,</span><span class="s3">\n      </span><span class="s1">initialHead,</span><span class="s3">\n      </span><span class="s1">undefined</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const initialState = {</span><span class="s3">\n    </span><span class="s1">tree: initialTree,</span><span class="s3">\n    </span><span class="s1">cache,</span><span class="s3">\n    </span><span class="s1">prefetchCache,</span><span class="s3">\n    </span><span class="s1">pushRef: {</span><span class="s3">\n      </span><span class="s1">pendingPush: false,</span><span class="s3">\n      </span><span class="s1">mpaNavigation: false,</span><span class="s3">\n      </span><span class="s1">// First render needs to preserve the previous window.history.state</span><span class="s3">\n      </span><span class="s1">// to avoid it being overwritten on navigation back/forward with MPA Navigation.</span><span class="s3">\n      </span><span class="s1">preserveCustomHistoryState: true,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">focusAndScrollRef: {</span><span class="s3">\n      </span><span class="s1">apply: false,</span><span class="s3">\n      </span><span class="s1">onlyHashChange: false,</span><span class="s3">\n      </span><span class="s1">hashFragment: null,</span><span class="s3">\n      </span><span class="s1">segmentPaths: [],</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">canonicalUrl,</span><span class="s3">\n    </span><span class="s1">nextUrl:</span><span class="s3">\n      </span><span class="s1">// the || operator is intentional, the pathname can be an empty string</span><span class="s3">\n      </span><span class="s1">(extractPathFromFlightRouterState(initialTree) || location?.pathname) ??</span><span class="s3">\n      </span><span class="s1">null,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (process.env.NODE_ENV !== 'development' &amp;&amp; location) {</span><span class="s3">\n    </span><span class="s1">// Seed the prefetch cache with this page's data.</span><span class="s3">\n    </span><span class="s1">// This is to prevent needlessly re-prefetching a page that is already reusable,</span><span class="s3">\n    </span><span class="s1">// and will avoid triggering a loading state/data fetch stall when navigating back to the page.</span><span class="s3">\n    </span><span class="s1">// We don't currently do this in development because links aren't prefetched in development</span><span class="s3">\n    </span><span class="s1">// so having a mismatch between prefetch/no prefetch provides inconsistent behavior based on which page</span><span class="s3">\n    </span><span class="s1">// was loaded first.</span><span class="s3">\n    </span><span class="s1">const url = new URL(</span><span class="s3">\n      </span><span class="s1">`${location.pathname}${location.search}`,</span><span class="s3">\n      </span><span class="s1">location.origin</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">createSeededPrefetchCacheEntry({</span><span class="s3">\n      </span><span class="s1">url,</span><span class="s3">\n      </span><span class="s1">data: {</span><span class="s3">\n        </span><span class="s1">flightData: [normalizedFlightData],</span><span class="s3">\n        </span><span class="s1">canonicalUrl: undefined,</span><span class="s3">\n        </span><span class="s1">couldBeIntercepted: !!couldBeIntercepted,</span><span class="s3">\n        </span><span class="s1">prerendered,</span><span class="s3">\n        </span><span class="s1">postponed,</span><span class="s3">\n        </span><span class="s1">// TODO: The initial RSC payload includes both static and dynamic data</span><span class="s3">\n        </span><span class="s1">// in the same response, even if PPR is enabled. So if there's any</span><span class="s3">\n        </span><span class="s1">// dynamic data at all, we can't set a stale time. In the future we may</span><span class="s3">\n        </span><span class="s1">// add a way to split a single Flight stream into static and dynamic</span><span class="s3">\n        </span><span class="s1">// parts. But in the meantime we should at least make this work for</span><span class="s3">\n        </span><span class="s1">// fully static pages.</span><span class="s3">\n        </span><span class="s1">staleTime:</span><span class="s3">\n          </span><span class="s1">// In the old router, there was only a single configurable staleTime (experimental.staleTimes)</span><span class="s3">\n          </span><span class="s1">// As an abundance of caution, this will only set the initial staleTime to the configured value</span><span class="s3">\n          </span><span class="s1">// if we're not leveraging the segment cache, which has its own prefetching semantics.</span><span class="s3">\n          </span><span class="s1">prerendered &amp;&amp; !process.env.__NEXT_CLIENT_SEGMENT_CACHE</span><span class="s3">\n            </span><span class="s1">? STATIC_STALETIME_MS</span><span class="s3">\n            </span><span class="s1">: -1,</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">tree: initialState.tree,</span><span class="s3">\n      </span><span class="s1">prefetchCache: initialState.prefetchCache,</span><span class="s3">\n      </span><span class="s1">nextUrl: initialState.nextUrl,</span><span class="s3">\n      </span><span class="s1">kind: prerendered ? PrefetchKind.FULL : PrefetchKind.AUTO,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return initialState</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;createInitialRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;navigatedAt&quot;</span><span class="s0">,</span><span class="s1">&quot;initialFlightData&quot;</span><span class="s0">,</span><span class="s1">&quot;initialCanonicalUrlParts&quot;</span><span class="s0">,</span><span class="s1">&quot;initialParallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;location&quot;</span><span class="s0">,</span><span class="s1">&quot;couldBeIntercepted&quot;</span><span class="s0">,</span><span class="s1">&quot;postponed&quot;</span><span class="s0">,</span><span class="s1">&quot;prerendered&quot;</span><span class="s0">,</span><span class="s1">&quot;initialCanonicalUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedFlightData&quot;</span><span class="s0">,</span><span class="s1">&quot;getFlightDataPartsFromPath&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;initialTree&quot;</span><span class="s0">,</span><span class="s1">&quot;seedData&quot;</span><span class="s0">,</span><span class="s1">&quot;initialSeedData&quot;</span><span class="s0">,</span><span class="s1">&quot;head&quot;</span><span class="s0">,</span><span class="s1">&quot;initialHead&quot;</span><span class="s0">,</span><span class="s1">&quot;rsc&quot;</span><span class="s0">,</span><span class="s1">&quot;loading&quot;</span><span class="s0">,</span><span class="s1">&quot;cache&quot;</span><span class="s0">,</span><span class="s1">&quot;lazyData&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchRsc&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchHead&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;canonicalUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;createHrefFromUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;addRefreshMarkerToActiveParallelSegments&quot;</span><span class="s0">,</span><span class="s1">&quot;prefetchCache&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">,</span><span class="s1">&quot;fillLazyItemsTillLeafWithHead&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;extractPathFromFlightRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;initialState&quot;</span><span class="s0">,</span><span class="s1">&quot;pushRef&quot;</span><span class="s0">,</span><span class="s1">&quot;pendingPush&quot;</span><span class="s0">,</span><span class="s1">&quot;mpaNavigation&quot;</span><span class="s0">,</span><span class="s1">&quot;preserveCustomHistoryState&quot;</span><span class="s0">,</span><span class="s1">&quot;focusAndScrollRef&quot;</span><span class="s0">,</span><span class="s1">&quot;apply&quot;</span><span class="s0">,</span><span class="s1">&quot;onlyHashChange&quot;</span><span class="s0">,</span><span class="s1">&quot;hashFragment&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentPaths&quot;</span><span class="s0">,</span><span class="s1">&quot;nextUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;URL&quot;</span><span class="s0">,</span><span class="s1">&quot;search&quot;</span><span class="s0">,</span><span class="s1">&quot;origin&quot;</span><span class="s0">,</span><span class="s1">&quot;createSeededPrefetchCacheEntry&quot;</span><span class="s0">,</span><span class="s1">&quot;data&quot;</span><span class="s0">,</span><span class="s1">&quot;flightData&quot;</span><span class="s0">,</span><span class="s1">&quot;staleTime&quot;</span><span class="s0">,</span><span class="s1">&quot;__NEXT_CLIENT_SEGMENT_CACHE&quot;</span><span class="s0">,</span><span class="s1">&quot;STATIC_STALETIME_MS&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;PrefetchKind&quot;</span><span class="s0">,</span><span class="s1">&quot;FULL&quot;</span><span class="s0">,</span><span class="s1">&quot;AUTO&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;+BAyBgBA;;;eAAAA;;;mCAtBkB;+CACY;oCACG;oCAI1C;oCAC+C;iDACG;mCACd;AAapC,SAASA,yBAAyB,KASV;IATU,IAAA,EACvCC,WAAW,EACXC,iBAAiB,EACjBC,wBAAwB,EACxBC,qBAAqB,EACrBC,QAAQ,EACRC,kBAAkB,EAClBC,SAAS,EACTC,WAAW,EACkB,GATU;IAUvC,sFAAsF;IACtF,kGAAkG;IAClG,mCAAmC;IACnC,MAAMC,sBAAsBN,yBAAyBO,IAAI,CAAC;IAE1D,MAAMC,uBAAuBC,IAAAA,6CAA0B,EAACV,iBAAiB,CAAC,EAAE;IAC5E,MAAM,EACJW,MAAMC,WAAW,EACjBC,UAAUC,eAAe,EACzBC,MAAMC,WAAW,EAClB,GAAGP;IACJ,gGAAgG;IAChG,gDAAgD;IAChD,MAAMQ,MAAMH,mCAAAA,eAAiB,CAAC,EAAE;QAChBA;IAAhB,MAAMI,UAAUJ,CAAAA,oBAAAA,mCAAAA,eAAiB,CAAC,EAAE,YAApBA,oBAAwB;IAExC,MAAMK,QAAmB;QACvBC,UAAU;QACVH;QACAI,aAAa;QACbN,MAAM;QACNO,cAAc;QACd,oJAAoJ;QACpJC,gBAAgBrB;QAChBgB;QACAnB;IACF;IAEA,MAAMyB,eACJ,6EAA6E;IAC7E,kJAAkJ;IAClJrB,WAEIsB,IAAAA,oCAAiB,EAACtB,YAClBI;IAENmB,IAAAA,yEAAwC,EAACd,aAAaY;IAEtD,MAAMG,gBAAgB,IAAIC;IAE1B,yEAAyE;IACzE,IAAI1B,0BAA0B,QAAQA,sBAAsB2B,IAAI,KAAK,GAAG;QACtEC,IAAAA,4DAA6B,EAC3B/B,aACAoB,OACAY,WACAnB,aACAE,iBACAE,aACAe;IAEJ;QAqBI,sEAAsE;IACrEC;IApBL,MAAMC,eAAe;QACnBtB,MAAMC;QACNO;QACAQ;QACAO,SAAS;YACPC,aAAa;YACbC,eAAe;YACf,mEAAmE;YACnE,gFAAgF;YAChFC,4BAA4B;QAC9B;QACAC,mBAAmB;YACjBC,OAAO;YACPC,gBAAgB;YAChBC,cAAc;YACdC,cAAc,EAAE;QAClB;QACAlB;QACAmB,SAEE,CAACX,OAAAA,IAAAA,oDAAgC,EAACpB,iBAAgBT,4BAAAA,SAAUyC,QAAQ,aAAnEZ,OACD;IACJ;IAEA,IAAIa,QAAQC,GAAG,CAACC,QAAQ,KAAK,iBAAiB5C,UAAU;QACtD,iDAAiD;QACjD,gFAAgF;QAChF,+FAA+F;QAC/F,2FAA2F;QAC3F,uGAAuG;QACvG,oBAAoB;QACpB,MAAM6C,MAAM,IAAIC,IACd,AAAC,KAAE9C,SAASyC,QAAQ,GAAGzC,SAAS+C,MAAM,EACtC/C,SAASgD,MAAM;QAGjBC,IAAAA,kDAA8B,EAAC;YAC7BJ;YACAK,MAAM;gBACJC,YAAY;oBAAC7C;iBAAqB;gBAClCe,cAAcO;gBACd3B,oBAAoB,CAAC,CAACA;gBACtBE;gBACAD;gBACA,sEAAsE;gBACtE,kEAAkE;gBAClE,uEAAuE;gBACvE,oEAAoE;gBACpE,mEAAmE;gBACnE,sBAAsB;gBACtBkD,WACE,8FAA8F;gBAC9F,+FAA+F;gBAC/F,sFAAsF;gBACtFjD,eAAe,CAACuC,QAAQC,GAAG,CAACU,2BAA2B,GACnDC,uCAAmB,GACnB,CAAC;YACT;YACA9C,MAAMsB,aAAatB,IAAI;YACvBgB,eAAeM,aAAaN,aAAa;YACzCgB,SAASV,aAAaU,OAAO;YAC7Be,MAAMpD,cAAcqD,gCAAY,CAACC,IAAI,GAAGD,gCAAY,CAACE,IAAI;QAC3D;IACF;IAEA,OAAO5B;AACT&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>