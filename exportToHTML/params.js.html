<html>
<head>
<title>params.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
params.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s3">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">createParamsFromClient: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">createPrerenderParamsForClientSegment: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">createServerParamsForMetadata: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">createServerParamsForRoute: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">createServerParamsForServerSegment: </span><span class="s2">null</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">_export(target, all) {</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">name </span><span class="s2">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">createParamsFromClient: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">createParamsFromClient;</span>
    <span class="s1">},</span>
    <span class="s1">createPrerenderParamsForClientSegment: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">createPrerenderParamsForClientSegment;</span>
    <span class="s1">},</span>
    <span class="s1">createServerParamsForMetadata: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">createServerParamsForMetadata;</span>
    <span class="s1">},</span>
    <span class="s1">createServerParamsForRoute: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">createServerParamsForRoute;</span>
    <span class="s1">},</span>
    <span class="s1">createServerParamsForServerSegment: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">createServerParamsForServerSegment;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_workasyncstorageexternal = require(</span><span class="s0">&quot;../app-render/work-async-storage.external&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_reflect = require(</span><span class="s0">&quot;../web/spec-extension/adapters/reflect&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_dynamicrendering = require(</span><span class="s0">&quot;../app-render/dynamic-rendering&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_workunitasyncstorageexternal = require(</span><span class="s0">&quot;../app-render/work-unit-async-storage.external&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_invarianterror = require(</span><span class="s0">&quot;../../shared/lib/invariant-error&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_reflectutils = require(</span><span class="s0">&quot;../../shared/lib/utils/reflect-utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_dynamicrenderingutils = require(</span><span class="s0">&quot;../dynamic-rendering-utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_creatededupedbycallsiteservererrorlogger = require(</span><span class="s0">&quot;../create-deduped-by-callsite-server-error-logger&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_dynamicaccessasyncstorageexternal = require(</span><span class="s0">&quot;../app-render/dynamic-access-async-storage.external&quot;</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">createParamsFromClient(underlyingParams, workStore) {</span>
    <span class="s2">const </span><span class="s1">workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();</span>
    <span class="s2">if </span><span class="s1">(workUnitStore) {</span>
        <span class="s2">switch</span><span class="s1">(workUnitStore.type){</span>
            <span class="s2">case </span><span class="s0">'prerender'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'prerender-client'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">createStaticPrerenderParams(underlyingParams, workStore, workUnitStore);</span>
            <span class="s2">case </span><span class="s0">'cache'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'private-cache'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'unstable-cache'</span><span class="s1">:</span>
                <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">_invarianterror.InvariantError(</span><span class="s0">'createParamsFromClient should not be called in cache contexts.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s0">&quot;E736&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s2">true</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s0">'prerender-runtime'</span><span class="s1">:</span>
                <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">_invarianterror.InvariantError(</span><span class="s0">'createParamsFromClient should not be called in a runtime prerender.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s0">&quot;E770&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s2">true</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s0">'request'</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">(process.env.NODE_ENV === </span><span class="s0">'development'</span><span class="s1">) {</span>
                    <span class="s4">// Semantically we only need the dev tracking when running in `next dev`</span>
                    <span class="s4">// but since you would never use next dev with production NODE_ENV we use this</span>
                    <span class="s4">// as a proxy so we can statically exclude this code from production builds.</span>
                    <span class="s2">const </span><span class="s1">devFallbackParams = workUnitStore.devFallbackParams;</span>
                    <span class="s2">return </span><span class="s1">createRenderParamsInDev(underlyingParams, devFallbackParams, workStore);</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">return </span><span class="s1">createRenderParamsInProd(underlyingParams);</span>
                <span class="s1">}</span>
            <span class="s2">default</span><span class="s1">:</span>
                <span class="s1">workUnitStore;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _workunitasyncstorageexternal.throwInvariantForMissingStore)();</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">createServerParamsForMetadata = createServerParamsForServerSegment;</span>
<span class="s2">function </span><span class="s1">createServerParamsForRoute(underlyingParams, workStore) {</span>
    <span class="s2">const </span><span class="s1">workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();</span>
    <span class="s2">if </span><span class="s1">(workUnitStore) {</span>
        <span class="s2">switch</span><span class="s1">(workUnitStore.type){</span>
            <span class="s2">case </span><span class="s0">'prerender'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'prerender-client'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">createStaticPrerenderParams(underlyingParams, workStore, workUnitStore);</span>
            <span class="s2">case </span><span class="s0">'cache'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'private-cache'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'unstable-cache'</span><span class="s1">:</span>
                <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">_invarianterror.InvariantError(</span><span class="s0">'createServerParamsForRoute should not be called in cache contexts.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s0">&quot;E738&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s2">true</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s0">'prerender-runtime'</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">createRuntimePrerenderParams(underlyingParams, workUnitStore);</span>
            <span class="s2">case </span><span class="s0">'request'</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">(process.env.NODE_ENV === </span><span class="s0">'development'</span><span class="s1">) {</span>
                    <span class="s4">// Semantically we only need the dev tracking when running in `next dev`</span>
                    <span class="s4">// but since you would never use next dev with production NODE_ENV we use this</span>
                    <span class="s4">// as a proxy so we can statically exclude this code from production builds.</span>
                    <span class="s2">const </span><span class="s1">devFallbackParams = workUnitStore.devFallbackParams;</span>
                    <span class="s2">return </span><span class="s1">createRenderParamsInDev(underlyingParams, devFallbackParams, workStore);</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">return </span><span class="s1">createRenderParamsInProd(underlyingParams);</span>
                <span class="s1">}</span>
            <span class="s2">default</span><span class="s1">:</span>
                <span class="s1">workUnitStore;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _workunitasyncstorageexternal.throwInvariantForMissingStore)();</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createServerParamsForServerSegment(underlyingParams, workStore) {</span>
    <span class="s2">const </span><span class="s1">workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();</span>
    <span class="s2">if </span><span class="s1">(workUnitStore) {</span>
        <span class="s2">switch</span><span class="s1">(workUnitStore.type){</span>
            <span class="s2">case </span><span class="s0">'prerender'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'prerender-client'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">createStaticPrerenderParams(underlyingParams, workStore, workUnitStore);</span>
            <span class="s2">case </span><span class="s0">'cache'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'private-cache'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'unstable-cache'</span><span class="s1">:</span>
                <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">_invarianterror.InvariantError(</span><span class="s0">'createServerParamsForServerSegment should not be called in cache contexts.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s0">&quot;E743&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s2">true</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s0">'prerender-runtime'</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">createRuntimePrerenderParams(underlyingParams, workUnitStore);</span>
            <span class="s2">case </span><span class="s0">'request'</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">(process.env.NODE_ENV === </span><span class="s0">'development'</span><span class="s1">) {</span>
                    <span class="s4">// Semantically we only need the dev tracking when running in `next dev`</span>
                    <span class="s4">// but since you would never use next dev with production NODE_ENV we use this</span>
                    <span class="s4">// as a proxy so we can statically exclude this code from production builds.</span>
                    <span class="s2">const </span><span class="s1">devFallbackParams = workUnitStore.devFallbackParams;</span>
                    <span class="s2">return </span><span class="s1">createRenderParamsInDev(underlyingParams, devFallbackParams, workStore);</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s2">return </span><span class="s1">createRenderParamsInProd(underlyingParams);</span>
                <span class="s1">}</span>
            <span class="s2">default</span><span class="s1">:</span>
                <span class="s1">workUnitStore;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _workunitasyncstorageexternal.throwInvariantForMissingStore)();</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createPrerenderParamsForClientSegment(underlyingParams) {</span>
    <span class="s2">const </span><span class="s1">workStore = _workasyncstorageexternal.workAsyncStorage.getStore();</span>
    <span class="s2">if </span><span class="s1">(!workStore) {</span>
        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">_invarianterror.InvariantError(</span><span class="s0">'Missing workStore in createPrerenderParamsForClientSegment'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
            <span class="s1">value: </span><span class="s0">&quot;E773&quot;</span><span class="s1">,</span>
            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">configurable: </span><span class="s2">true</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();</span>
    <span class="s2">if </span><span class="s1">(workUnitStore) {</span>
        <span class="s2">switch</span><span class="s1">(workUnitStore.type){</span>
            <span class="s2">case </span><span class="s0">'prerender'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'prerender-client'</span><span class="s1">:</span>
                <span class="s2">const </span><span class="s1">fallbackParams = workUnitStore.fallbackRouteParams;</span>
                <span class="s2">if </span><span class="s1">(fallbackParams) {</span>
                    <span class="s2">for</span><span class="s1">(</span><span class="s2">let </span><span class="s1">key </span><span class="s2">in </span><span class="s1">underlyingParams){</span>
                        <span class="s2">if </span><span class="s1">(fallbackParams.has(key)) {</span>
                            <span class="s4">// This params object has one or more fallback params, so we need</span>
                            <span class="s4">// to consider the awaiting of this params object &quot;dynamic&quot;. Since</span>
                            <span class="s4">// we are in cacheComponents mode we encode this as a promise that never</span>
                            <span class="s4">// resolves.</span>
                            <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _dynamicrenderingutils.makeHangingPromise)(workUnitStore.renderSignal, workStore.route, </span><span class="s0">'`params`'</span><span class="s1">);</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s2">case </span><span class="s0">'cache'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'private-cache'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'unstable-cache'</span><span class="s1">:</span>
                <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">_invarianterror.InvariantError(</span><span class="s0">'createPrerenderParamsForClientSegment should not be called in cache contexts.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s0">&quot;E734&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s2">true</span>
                <span class="s1">});</span>
            <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'prerender-runtime'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'request'</span><span class="s1">:</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s2">default</span><span class="s1">:</span>
                <span class="s1">workUnitStore;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s4">// We're prerendering in a mode that does not abort. We resolve the promise without</span>
    <span class="s4">// any tracking because we're just transporting a value from server to client where the tracking</span>
    <span class="s4">// will be applied.</span>
    <span class="s2">return </span><span class="s1">Promise.resolve(underlyingParams);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createStaticPrerenderParams(underlyingParams, workStore, prerenderStore) {</span>
    <span class="s2">switch</span><span class="s1">(prerenderStore.type){</span>
        <span class="s2">case </span><span class="s0">'prerender'</span><span class="s1">:</span>
        <span class="s2">case </span><span class="s0">'prerender-client'</span><span class="s1">:</span>
            <span class="s1">{</span>
                <span class="s2">const </span><span class="s1">fallbackParams = prerenderStore.fallbackRouteParams;</span>
                <span class="s2">if </span><span class="s1">(fallbackParams) {</span>
                    <span class="s2">for</span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">underlyingParams){</span>
                        <span class="s2">if </span><span class="s1">(fallbackParams.has(key)) {</span>
                            <span class="s4">// This params object has one or more fallback params, so we need</span>
                            <span class="s4">// to consider the awaiting of this params object &quot;dynamic&quot;. Since</span>
                            <span class="s4">// we are in cacheComponents mode we encode this as a promise that never</span>
                            <span class="s4">// resolves.</span>
                            <span class="s2">return </span><span class="s1">makeHangingParams(underlyingParams, workStore, prerenderStore);</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
            <span class="s1">{</span>
                <span class="s2">const </span><span class="s1">fallbackParams = prerenderStore.fallbackRouteParams;</span>
                <span class="s2">if </span><span class="s1">(fallbackParams) {</span>
                    <span class="s2">for</span><span class="s1">(</span><span class="s2">const </span><span class="s1">key </span><span class="s2">in </span><span class="s1">underlyingParams){</span>
                        <span class="s2">if </span><span class="s1">(fallbackParams.has(key)) {</span>
                            <span class="s2">return </span><span class="s1">makeErroringExoticParams(underlyingParams, fallbackParams, workStore, prerenderStore);</span>
                        <span class="s1">}</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
            <span class="s2">break</span><span class="s1">;</span>
        <span class="s2">default</span><span class="s1">:</span>
            <span class="s1">prerenderStore;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(process.env.__NEXT_CACHE_COMPONENTS) {</span>
        <span class="s2">return </span><span class="s1">makeUntrackedParams(underlyingParams);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s2">return </span><span class="s1">makeUntrackedExoticParams(underlyingParams);</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createRuntimePrerenderParams(underlyingParams, workUnitStore) {</span>
    <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _dynamicrendering.delayUntilRuntimeStage)(workUnitStore, process.env.__NEXT_CACHE_COMPONENTS ? makeUntrackedParams(underlyingParams) : makeUntrackedExoticParams(underlyingParams));</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createRenderParamsInProd(underlyingParams) {</span>
    <span class="s2">if </span><span class="s1">(process.env.__NEXT_CACHE_COMPONENTS) {</span>
        <span class="s2">return </span><span class="s1">makeUntrackedParams(underlyingParams);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">makeUntrackedExoticParams(underlyingParams);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createRenderParamsInDev(underlyingParams, devFallbackParams, workStore) {</span>
    <span class="s2">let </span><span class="s1">hasFallbackParams = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s2">if </span><span class="s1">(devFallbackParams) {</span>
        <span class="s2">for</span><span class="s1">(</span><span class="s2">let </span><span class="s1">key </span><span class="s2">in </span><span class="s1">underlyingParams){</span>
            <span class="s2">if </span><span class="s1">(devFallbackParams.has(key)) {</span>
                <span class="s1">hasFallbackParams = </span><span class="s2">true</span><span class="s1">;</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(process.env.__NEXT_CACHE_COMPONENTS) {</span>
        <span class="s2">return </span><span class="s1">makeDynamicallyTrackedParamsWithDevWarnings(underlyingParams, hasFallbackParams, workStore);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">makeDynamicallyTrackedExoticParamsWithDevWarnings(underlyingParams, hasFallbackParams, workStore);</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">CachedParams = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
<span class="s2">const </span><span class="s1">fallbackParamsProxyHandler = {</span>
    <span class="s1">get: </span><span class="s2">function </span><span class="s1">get(target, prop, receiver) {</span>
        <span class="s2">if </span><span class="s1">(prop === </span><span class="s0">'then' </span><span class="s1">|| prop === </span><span class="s0">'catch' </span><span class="s1">|| prop === </span><span class="s0">'finally'</span><span class="s1">) {</span>
            <span class="s2">const </span><span class="s1">originalMethod = _reflect.ReflectAdapter.get(target, prop, receiver);</span>
            <span class="s2">return </span><span class="s1">({</span>
                <span class="s1">[prop]: (...args)=&gt;{</span>
                    <span class="s2">const </span><span class="s1">store = _dynamicaccessasyncstorageexternal.dynamicAccessAsyncStorage.getStore();</span>
                    <span class="s2">if </span><span class="s1">(store) {</span>
                        <span class="s1">store.abortController.abort(Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`Accessed fallback </span><span class="s5">\`</span><span class="s0">params</span><span class="s5">\` </span><span class="s0">during prerendering.`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                            <span class="s1">value: </span><span class="s0">&quot;E691&quot;</span><span class="s1">,</span>
                            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                            <span class="s1">configurable: </span><span class="s2">true</span>
                        <span class="s1">}));</span>
                    <span class="s1">}</span>
                    <span class="s2">return new </span><span class="s1">Proxy(originalMethod.apply(target, args), fallbackParamsProxyHandler);</span>
                <span class="s1">}</span>
            <span class="s1">})[prop];</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">_reflect.ReflectAdapter.get(target, prop, receiver);</span>
    <span class="s1">}</span>
<span class="s1">};</span>
<span class="s2">function </span><span class="s1">makeHangingParams(underlyingParams, workStore, prerenderStore) {</span>
    <span class="s2">const </span><span class="s1">cachedParams = CachedParams.get(underlyingParams);</span>
    <span class="s2">if </span><span class="s1">(cachedParams) {</span>
        <span class="s2">return </span><span class="s1">cachedParams;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">promise = </span><span class="s2">new </span><span class="s1">Proxy((</span><span class="s3">0</span><span class="s1">, _dynamicrenderingutils.makeHangingPromise)(prerenderStore.renderSignal, workStore.route, </span><span class="s0">'`params`'</span><span class="s1">), fallbackParamsProxyHandler);</span>
    <span class="s1">CachedParams.set(underlyingParams, promise);</span>
    <span class="s2">return </span><span class="s1">promise;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">makeErroringExoticParams(underlyingParams, fallbackParams, workStore, prerenderStore) {</span>
    <span class="s2">const </span><span class="s1">cachedParams = CachedParams.get(underlyingParams);</span>
    <span class="s2">if </span><span class="s1">(cachedParams) {</span>
        <span class="s2">return </span><span class="s1">cachedParams;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">augmentedUnderlying = {</span>
        <span class="s1">...underlyingParams</span>
    <span class="s1">};</span>
    <span class="s4">// We don't use makeResolvedReactPromise here because params</span>
    <span class="s4">// supports copying with spread and we don't want to unnecessarily</span>
    <span class="s4">// instrument the promise with spreadable properties of ReactPromise.</span>
    <span class="s2">const </span><span class="s1">promise = Promise.resolve(augmentedUnderlying);</span>
    <span class="s1">CachedParams.set(underlyingParams, promise);</span>
    <span class="s1">Object.keys(underlyingParams).forEach((prop)=&gt;{</span>
        <span class="s2">if </span><span class="s1">(_reflectutils.wellKnownProperties.has(prop)) {</span>
        <span class="s4">// These properties cannot be shadowed because they need to be the</span>
        <span class="s4">// true underlying value for Promises to work correctly at runtime</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s2">if </span><span class="s1">(fallbackParams.has(prop)) {</span>
                <span class="s1">Object.defineProperty(augmentedUnderlying, prop, {</span>
                    <span class="s1">get () {</span>
                        <span class="s2">const </span><span class="s1">expression = (</span><span class="s3">0</span><span class="s1">, _reflectutils.describeStringPropertyAccess)(</span><span class="s0">'params'</span><span class="s1">, prop);</span>
                        <span class="s4">// In most dynamic APIs we also throw if `dynamic = &quot;error&quot;` however</span>
                        <span class="s4">// for params is only dynamic when we're generating a fallback shell</span>
                        <span class="s4">// and even when `dynamic = &quot;error&quot;` we still support generating dynamic</span>
                        <span class="s4">// fallback shells</span>
                        <span class="s4">// TODO remove this comment when cacheComponents is the default since there</span>
                        <span class="s4">// will be no `dynamic = &quot;error&quot;`</span>
                        <span class="s2">if </span><span class="s1">(prerenderStore.type === </span><span class="s0">'prerender-ppr'</span><span class="s1">) {</span>
                            <span class="s4">// PPR Prerender (no cacheComponents)</span>
                            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);</span>
                        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                            <span class="s4">// Legacy Prerender</span>
                            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);</span>
                        <span class="s1">}</span>
                    <span class="s1">},</span>
                    <span class="s1">enumerable: </span><span class="s2">true</span>
                <span class="s1">});</span>
                <span class="s1">Object.defineProperty(promise, prop, {</span>
                    <span class="s1">get () {</span>
                        <span class="s2">const </span><span class="s1">expression = (</span><span class="s3">0</span><span class="s1">, _reflectutils.describeStringPropertyAccess)(</span><span class="s0">'params'</span><span class="s1">, prop);</span>
                        <span class="s4">// In most dynamic APIs we also throw if `dynamic = &quot;error&quot;` however</span>
                        <span class="s4">// for params is only dynamic when we're generating a fallback shell</span>
                        <span class="s4">// and even when `dynamic = &quot;error&quot;` we still support generating dynamic</span>
                        <span class="s4">// fallback shells</span>
                        <span class="s4">// TODO remove this comment when cacheComponents is the default since there</span>
                        <span class="s4">// will be no `dynamic = &quot;error&quot;`</span>
                        <span class="s2">if </span><span class="s1">(prerenderStore.type === </span><span class="s0">'prerender-ppr'</span><span class="s1">) {</span>
                            <span class="s4">// PPR Prerender (no cacheComponents)</span>
                            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _dynamicrendering.postponeWithTracking)(workStore.route, expression, prerenderStore.dynamicTracking);</span>
                        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                            <span class="s4">// Legacy Prerender</span>
                            <span class="s1">(</span><span class="s3">0</span><span class="s1">, _dynamicrendering.throwToInterruptStaticGeneration)(expression, workStore, prerenderStore);</span>
                        <span class="s1">}</span>
                    <span class="s1">},</span>
                    <span class="s1">set (newValue) {</span>
                        <span class="s1">Object.defineProperty(promise, prop, {</span>
                            <span class="s1">value: newValue,</span>
                            <span class="s1">writable: </span><span class="s2">true</span><span class="s1">,</span>
                            <span class="s1">enumerable: </span><span class="s2">true</span>
                        <span class="s1">});</span>
                    <span class="s1">},</span>
                    <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s2">true</span>
                <span class="s1">});</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">;</span>
                <span class="s1">promise[prop] = underlyingParams[prop];</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s2">return </span><span class="s1">promise;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">makeUntrackedExoticParams(underlyingParams) {</span>
    <span class="s2">const </span><span class="s1">cachedParams = CachedParams.get(underlyingParams);</span>
    <span class="s2">if </span><span class="s1">(cachedParams) {</span>
        <span class="s2">return </span><span class="s1">cachedParams;</span>
    <span class="s1">}</span>
    <span class="s4">// We don't use makeResolvedReactPromise here because params</span>
    <span class="s4">// supports copying with spread and we don't want to unnecessarily</span>
    <span class="s4">// instrument the promise with spreadable properties of ReactPromise.</span>
    <span class="s2">const </span><span class="s1">promise = Promise.resolve(underlyingParams);</span>
    <span class="s1">CachedParams.set(underlyingParams, promise);</span>
    <span class="s1">Object.keys(underlyingParams).forEach((prop)=&gt;{</span>
        <span class="s2">if </span><span class="s1">(_reflectutils.wellKnownProperties.has(prop)) {</span>
        <span class="s4">// These properties cannot be shadowed because they need to be the</span>
        <span class="s4">// true underlying value for Promises to work correctly at runtime</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">;</span>
            <span class="s1">promise[prop] = underlyingParams[prop];</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s2">return </span><span class="s1">promise;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">makeUntrackedParams(underlyingParams) {</span>
    <span class="s2">const </span><span class="s1">cachedParams = CachedParams.get(underlyingParams);</span>
    <span class="s2">if </span><span class="s1">(cachedParams) {</span>
        <span class="s2">return </span><span class="s1">cachedParams;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">promise = Promise.resolve(underlyingParams);</span>
    <span class="s1">CachedParams.set(underlyingParams, promise);</span>
    <span class="s2">return </span><span class="s1">promise;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">makeDynamicallyTrackedExoticParamsWithDevWarnings(underlyingParams, hasFallbackParams, store) {</span>
    <span class="s2">const </span><span class="s1">cachedParams = CachedParams.get(underlyingParams);</span>
    <span class="s2">if </span><span class="s1">(cachedParams) {</span>
        <span class="s2">return </span><span class="s1">cachedParams;</span>
    <span class="s1">}</span>
    <span class="s4">// We don't use makeResolvedReactPromise here because params</span>
    <span class="s4">// supports copying with spread and we don't want to unnecessarily</span>
    <span class="s4">// instrument the promise with spreadable properties of ReactPromise.</span>
    <span class="s2">const </span><span class="s1">promise = hasFallbackParams ? (</span><span class="s3">0</span><span class="s1">, _dynamicrenderingutils.makeDevtoolsIOAwarePromise)(underlyingParams) : Promise.resolve(underlyingParams);</span>
    <span class="s2">const </span><span class="s1">proxiedProperties = </span><span class="s2">new </span><span class="s1">Set();</span>
    <span class="s2">const </span><span class="s1">unproxiedProperties = [];</span>
    <span class="s1">Object.keys(underlyingParams).forEach((prop)=&gt;{</span>
        <span class="s2">if </span><span class="s1">(_reflectutils.wellKnownProperties.has(prop)) {</span>
            <span class="s4">// These properties cannot be shadowed because they need to be the</span>
            <span class="s4">// true underlying value for Promises to work correctly at runtime</span>
            <span class="s1">unproxiedProperties.push(prop);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">proxiedProperties.add(prop);</span>
            <span class="s1">promise[prop] = underlyingParams[prop];</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s2">const </span><span class="s1">proxiedPromise = </span><span class="s2">new </span><span class="s1">Proxy(promise, {</span>
        <span class="s1">get (target, prop, receiver) {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">prop === </span><span class="s0">'string'</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s4">// We are accessing a property that was proxied to the promise instance</span>
                <span class="s1">proxiedProperties.has(prop)) {</span>
                    <span class="s2">const </span><span class="s1">expression = (</span><span class="s3">0</span><span class="s1">, _reflectutils.describeStringPropertyAccess)(</span><span class="s0">'params'</span><span class="s1">, prop);</span>
                    <span class="s1">syncIODev(store.route, expression);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">_reflect.ReflectAdapter.get(target, prop, receiver);</span>
        <span class="s1">},</span>
        <span class="s1">set (target, prop, value, receiver) {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">prop === </span><span class="s0">'string'</span><span class="s1">) {</span>
                <span class="s1">proxiedProperties.delete(prop);</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">_reflect.ReflectAdapter.set(target, prop, value, receiver);</span>
        <span class="s1">},</span>
        <span class="s1">ownKeys (target) {</span>
            <span class="s2">const </span><span class="s1">expression = </span><span class="s0">'`...params` or similar expression'</span><span class="s1">;</span>
            <span class="s1">syncIODev(store.route, expression, unproxiedProperties);</span>
            <span class="s2">return </span><span class="s1">Reflect.ownKeys(target);</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s1">CachedParams.set(underlyingParams, proxiedPromise);</span>
    <span class="s2">return </span><span class="s1">proxiedPromise;</span>
<span class="s1">}</span>
<span class="s4">// Similar to `makeDynamicallyTrackedExoticParamsWithDevWarnings`, but just</span>
<span class="s4">// logging the sync access without actually defining the params on the promise.</span>
<span class="s2">function </span><span class="s1">makeDynamicallyTrackedParamsWithDevWarnings(underlyingParams, hasFallbackParams, store) {</span>
    <span class="s2">const </span><span class="s1">cachedParams = CachedParams.get(underlyingParams);</span>
    <span class="s2">if </span><span class="s1">(cachedParams) {</span>
        <span class="s2">return </span><span class="s1">cachedParams;</span>
    <span class="s1">}</span>
    <span class="s4">// We don't use makeResolvedReactPromise here because params</span>
    <span class="s4">// supports copying with spread and we don't want to unnecessarily</span>
    <span class="s4">// instrument the promise with spreadable properties of ReactPromise.</span>
    <span class="s2">const </span><span class="s1">promise = hasFallbackParams ? (</span><span class="s3">0</span><span class="s1">, _dynamicrenderingutils.makeDevtoolsIOAwarePromise)(underlyingParams) : Promise.resolve(underlyingParams);</span>
    <span class="s2">const </span><span class="s1">proxiedProperties = </span><span class="s2">new </span><span class="s1">Set();</span>
    <span class="s2">const </span><span class="s1">unproxiedProperties = [];</span>
    <span class="s1">Object.keys(underlyingParams).forEach((prop)=&gt;{</span>
        <span class="s2">if </span><span class="s1">(_reflectutils.wellKnownProperties.has(prop)) {</span>
            <span class="s4">// These properties cannot be shadowed because they need to be the</span>
            <span class="s4">// true underlying value for Promises to work correctly at runtime</span>
            <span class="s1">unproxiedProperties.push(prop);</span>
        <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
            <span class="s1">proxiedProperties.add(prop);</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s2">const </span><span class="s1">proxiedPromise = </span><span class="s2">new </span><span class="s1">Proxy(promise, {</span>
        <span class="s1">get (target, prop, receiver) {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">prop === </span><span class="s0">'string'</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s4">// We are accessing a property that was proxied to the promise instance</span>
                <span class="s1">proxiedProperties.has(prop)) {</span>
                    <span class="s2">const </span><span class="s1">expression = (</span><span class="s3">0</span><span class="s1">, _reflectutils.describeStringPropertyAccess)(</span><span class="s0">'params'</span><span class="s1">, prop);</span>
                    <span class="s1">warnForSyncAccess(store.route, expression);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">_reflect.ReflectAdapter.get(target, prop, receiver);</span>
        <span class="s1">},</span>
        <span class="s1">set (target, prop, value, receiver) {</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">prop === </span><span class="s0">'string'</span><span class="s1">) {</span>
                <span class="s1">proxiedProperties.delete(prop);</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">_reflect.ReflectAdapter.set(target, prop, value, receiver);</span>
        <span class="s1">},</span>
        <span class="s1">ownKeys (target) {</span>
            <span class="s2">const </span><span class="s1">expression = </span><span class="s0">'`...params` or similar expression'</span><span class="s1">;</span>
            <span class="s1">warnForIncompleteEnumeration(store.route, expression, unproxiedProperties);</span>
            <span class="s2">return </span><span class="s1">Reflect.ownKeys(target);</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
    <span class="s1">CachedParams.set(underlyingParams, proxiedPromise);</span>
    <span class="s2">return </span><span class="s1">proxiedPromise;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">syncIODev(route, expression, missingProperties) {</span>
    <span class="s2">const </span><span class="s1">workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();</span>
    <span class="s2">if </span><span class="s1">(workUnitStore) {</span>
        <span class="s2">switch</span><span class="s1">(workUnitStore.type){</span>
            <span class="s2">case </span><span class="s0">'request'</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">(workUnitStore.prerenderPhase === </span><span class="s2">true</span><span class="s1">) {</span>
                    <span class="s4">// When we're rendering dynamically in dev, we need to advance out of</span>
                    <span class="s4">// the Prerender environment when we read Request data synchronously.</span>
                    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _dynamicrendering.trackSynchronousRequestDataAccessInDev)(workUnitStore);</span>
                <span class="s1">}</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s2">case </span><span class="s0">'prerender'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'prerender-client'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'prerender-runtime'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'prerender-ppr'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'prerender-legacy'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'cache'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'private-cache'</span><span class="s1">:</span>
            <span class="s2">case </span><span class="s0">'unstable-cache'</span><span class="s1">:</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s2">default</span><span class="s1">:</span>
                <span class="s1">workUnitStore;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s4">// In all cases we warn normally</span>
    <span class="s2">if </span><span class="s1">(missingProperties &amp;&amp; missingProperties.length &gt; </span><span class="s3">0</span><span class="s1">) {</span>
        <span class="s1">warnForIncompleteEnumeration(route, expression, missingProperties);</span>
    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
        <span class="s1">warnForSyncAccess(route, expression);</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s2">const </span><span class="s1">warnForSyncAccess = (</span><span class="s3">0</span><span class="s1">, _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(createParamsAccessError);</span>
<span class="s2">const </span><span class="s1">warnForIncompleteEnumeration = (</span><span class="s3">0</span><span class="s1">, _creatededupedbycallsiteservererrorlogger.createDedupedByCallsiteServerErrorLoggerDev)(createIncompleteEnumerationError);</span>
<span class="s2">function </span><span class="s1">createParamsAccessError(route, expression) {</span>
    <span class="s2">const </span><span class="s1">prefix = route ? </span><span class="s0">`Route &quot;</span><span class="s1">${route}</span><span class="s0">&quot; ` </span><span class="s1">: </span><span class="s0">'This route '</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`</span><span class="s1">${prefix}</span><span class="s0">used </span><span class="s1">${expression}</span><span class="s0">. ` </span><span class="s1">+ </span><span class="s0">`</span><span class="s5">\`</span><span class="s0">params</span><span class="s5">\` </span><span class="s0">should be awaited before using its properties. ` </span><span class="s1">+ </span><span class="s0">`Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
        <span class="s1">value: </span><span class="s0">&quot;E307&quot;</span><span class="s1">,</span>
        <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">configurable: </span><span class="s2">true</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">createIncompleteEnumerationError(route, expression, missingProperties) {</span>
    <span class="s2">const </span><span class="s1">prefix = route ? </span><span class="s0">`Route &quot;</span><span class="s1">${route}</span><span class="s0">&quot; ` </span><span class="s1">: </span><span class="s0">'This route '</span><span class="s1">;</span>
    <span class="s2">return </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`</span><span class="s1">${prefix}</span><span class="s0">used </span><span class="s1">${expression}</span><span class="s0">. ` </span><span class="s1">+ </span><span class="s0">`</span><span class="s5">\`</span><span class="s0">params</span><span class="s5">\` </span><span class="s0">should be awaited before using its properties. ` </span><span class="s1">+ </span><span class="s0">`The following properties were not available through enumeration ` </span><span class="s1">+ </span><span class="s0">`because they conflict with builtin property names: ` </span><span class="s1">+ </span><span class="s0">`</span><span class="s1">${describeListOfPropertyNames(missingProperties)}</span><span class="s0">. ` </span><span class="s1">+ </span><span class="s0">`Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
        <span class="s1">value: </span><span class="s0">&quot;E482&quot;</span><span class="s1">,</span>
        <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">configurable: </span><span class="s2">true</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">describeListOfPropertyNames(properties) {</span>
    <span class="s2">switch</span><span class="s1">(properties.length){</span>
        <span class="s2">case </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">_invarianterror.InvariantError(</span><span class="s0">'Expected describeListOfPropertyNames to be called with a non-empty list of strings.'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                <span class="s1">value: </span><span class="s0">&quot;E531&quot;</span><span class="s1">,</span>
                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s2">true</span>
            <span class="s1">});</span>
        <span class="s2">case </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s0">`</span><span class="s5">\`</span><span class="s1">${properties[</span><span class="s3">0</span><span class="s1">]}</span><span class="s5">\`</span><span class="s0">`</span><span class="s1">;</span>
        <span class="s2">case </span><span class="s3">2</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s0">`</span><span class="s5">\`</span><span class="s1">${properties[</span><span class="s3">0</span><span class="s1">]}</span><span class="s5">\` </span><span class="s0">and </span><span class="s5">\`</span><span class="s1">${properties[</span><span class="s3">1</span><span class="s1">]}</span><span class="s5">\`</span><span class="s0">`</span><span class="s1">;</span>
        <span class="s2">default</span><span class="s1">:</span>
            <span class="s1">{</span>
                <span class="s2">let </span><span class="s1">description = </span><span class="s0">''</span><span class="s1">;</span>
                <span class="s2">for</span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">; i &lt; properties.length - </span><span class="s3">1</span><span class="s1">; i++){</span>
                    <span class="s1">description += </span><span class="s0">`</span><span class="s5">\`</span><span class="s1">${properties[i]}</span><span class="s5">\`</span><span class="s0">, `</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s1">description += </span><span class="s0">`, and </span><span class="s5">\`</span><span class="s1">${properties[properties.length - </span><span class="s3">1</span><span class="s1">]}</span><span class="s5">\`</span><span class="s0">`</span><span class="s1">;</span>
                <span class="s2">return </span><span class="s1">description;</span>
            <span class="s1">}</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=params.js.map</span></pre>
</body>
</html>