<html>
<head>
<title>segment-value-encoding.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
segment-value-encoding.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../src/shared/lib/segment-cache/segment-value-encoding.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { PAGE_SEGMENT_KEY } from '../segment'</span><span class="s3">\n</span><span class="s1">import type { Segment as FlightRouterStateSegment } from '../../../server/app-render/types'</span><span class="s3">\n\n</span><span class="s1">// TypeScript trick to simulate opaque types, like in Flow.</span><span class="s3">\n</span><span class="s1">type Opaque&lt;K, T&gt; = T &amp; { __brand: K }</span><span class="s3">\n\n</span><span class="s1">export type SegmentRequestKeyPart = Opaque&lt;'SegmentRequestKeyPart', string&gt;</span><span class="s3">\n</span><span class="s1">export type SegmentRequestKey = Opaque&lt;'SegmentRequestKey', string&gt;</span><span class="s3">\n</span><span class="s1">export type SegmentCacheKeyPart = Opaque&lt;'SegmentCacheKeyPart', string&gt;</span><span class="s3">\n</span><span class="s1">export type SegmentCacheKey = Opaque&lt;'SegmentCacheKey', string&gt;</span><span class="s3">\n\n</span><span class="s1">export const ROOT_SEGMENT_REQUEST_KEY = '' as SegmentRequestKey</span><span class="s3">\n</span><span class="s1">export const ROOT_SEGMENT_CACHE_KEY = '' as SegmentCacheKey</span><span class="s3">\n\n</span><span class="s1">export function createSegmentRequestKeyPart(</span><span class="s3">\n  </span><span class="s1">segment: FlightRouterStateSegment</span><span class="s3">\n</span><span class="s1">): SegmentRequestKeyPart {</span><span class="s3">\n  </span><span class="s1">if (typeof segment === 'string') {</span><span class="s3">\n    </span><span class="s1">if (segment.startsWith(PAGE_SEGMENT_KEY)) {</span><span class="s3">\n      </span><span class="s1">// The Flight Router State type sometimes includes the search params in</span><span class="s3">\n      </span><span class="s1">// the page segment. However, the Segment Cache tracks this as a separate</span><span class="s3">\n      </span><span class="s1">// key. So, we strip the search params here, and then add them back when</span><span class="s3">\n      </span><span class="s1">// the cache entry is turned back into a FlightRouterState. This is an</span><span class="s3">\n      </span><span class="s1">// unfortunate consequence of the FlightRouteState being used both as a</span><span class="s3">\n      </span><span class="s1">// transport type and as a cache key; we'll address this once more of the</span><span class="s3">\n      </span><span class="s1">// Segment Cache implementation has settled.</span><span class="s3">\n      </span><span class="s1">// TODO: We should hoist the search params out of the FlightRouterState</span><span class="s3">\n      </span><span class="s1">// type entirely, This is our plan for dynamic route params, too.</span><span class="s3">\n      </span><span class="s1">return PAGE_SEGMENT_KEY as SegmentRequestKeyPart</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const safeName =</span><span class="s3">\n      </span><span class="s1">// TODO: FlightRouterState encodes Not Found routes as </span><span class="s3">\&quot;</span><span class="s1">/_not-found</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n      </span><span class="s1">// But params typically don't include the leading slash. We should use</span><span class="s3">\n      </span><span class="s1">// a different encoding to avoid this special case.</span><span class="s3">\n      </span><span class="s1">segment === '/_not-found'</span><span class="s3">\n        </span><span class="s1">? '_not-found'</span><span class="s3">\n        </span><span class="s1">: encodeToFilesystemAndURLSafeString(segment)</span><span class="s3">\n    </span><span class="s1">// Since this is not a dynamic segment, it's fully encoded. It does not</span><span class="s3">\n    </span><span class="s1">// need to be </span><span class="s3">\&quot;</span><span class="s1">hydrated</span><span class="s3">\&quot; </span><span class="s1">with a param value.</span><span class="s3">\n    </span><span class="s1">return safeName as SegmentRequestKeyPart</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const name = segment[0]</span><span class="s3">\n  </span><span class="s1">const paramType = segment[2]</span><span class="s3">\n  </span><span class="s1">const safeName = encodeToFilesystemAndURLSafeString(name)</span><span class="s3">\n\n  </span><span class="s1">const encodedName = '$' + paramType + '$' + safeName</span><span class="s3">\n  </span><span class="s1">return encodedName as SegmentRequestKeyPart</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function appendSegmentRequestKeyPart(</span><span class="s3">\n  </span><span class="s1">parentRequestKey: SegmentRequestKey,</span><span class="s3">\n  </span><span class="s1">parallelRouteKey: string,</span><span class="s3">\n  </span><span class="s1">childRequestKeyPart: SegmentRequestKeyPart</span><span class="s3">\n</span><span class="s1">): SegmentRequestKey {</span><span class="s3">\n  </span><span class="s1">// Aside from being filesystem safe, segment keys are also designed so that</span><span class="s3">\n  </span><span class="s1">// each segment and parallel route creates its own subdirectory. Roughly in</span><span class="s3">\n  </span><span class="s1">// the same shape as the source app directory. This is mostly just for easier</span><span class="s3">\n  </span><span class="s1">// debugging (you can open up the build folder and navigate the output); if</span><span class="s3">\n  </span><span class="s1">// we wanted to do we could just use a flat structure.</span><span class="s3">\n\n  </span><span class="s1">// Omit the parallel route key for children, since this is the most</span><span class="s3">\n  </span><span class="s1">// common case. Saves some bytes (and it's what the app directory does).</span><span class="s3">\n  </span><span class="s1">const slotKey =</span><span class="s3">\n    </span><span class="s1">parallelRouteKey === 'children'</span><span class="s3">\n      </span><span class="s1">? childRequestKeyPart</span><span class="s3">\n      </span><span class="s1">: `@${encodeToFilesystemAndURLSafeString(parallelRouteKey)}/${childRequestKeyPart}`</span><span class="s3">\n  </span><span class="s1">return (parentRequestKey + '/' + slotKey) as SegmentRequestKey</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function createSegmentCacheKeyPart(</span><span class="s3">\n  </span><span class="s1">requestKeyPart: SegmentRequestKeyPart,</span><span class="s3">\n  </span><span class="s1">segment: FlightRouterStateSegment</span><span class="s3">\n</span><span class="s1">): SegmentCacheKeyPart {</span><span class="s3">\n  </span><span class="s1">if (typeof segment === 'string') {</span><span class="s3">\n    </span><span class="s1">return requestKeyPart as any as SegmentCacheKeyPart</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const paramValue = segment[1]</span><span class="s3">\n  </span><span class="s1">const safeValue = encodeToFilesystemAndURLSafeString(paramValue)</span><span class="s3">\n  </span><span class="s1">return (requestKeyPart + '$' + safeValue) as SegmentCacheKeyPart</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function appendSegmentCacheKeyPart(</span><span class="s3">\n  </span><span class="s1">parentSegmentKey: SegmentCacheKey,</span><span class="s3">\n  </span><span class="s1">parallelRouteKey: string,</span><span class="s3">\n  </span><span class="s1">childCacheKeyPart: SegmentCacheKeyPart</span><span class="s3">\n</span><span class="s1">): SegmentCacheKey {</span><span class="s3">\n  </span><span class="s1">const slotKey =</span><span class="s3">\n    </span><span class="s1">parallelRouteKey === 'children'</span><span class="s3">\n      </span><span class="s1">? childCacheKeyPart</span><span class="s3">\n      </span><span class="s1">: `@${encodeToFilesystemAndURLSafeString(parallelRouteKey)}/${childCacheKeyPart}`</span><span class="s3">\n  </span><span class="s1">return (parentSegmentKey + '/' + slotKey) as SegmentCacheKey</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Define a regex pattern to match the most common characters found in a route</span><span class="s3">\n</span><span class="s1">// param. It excludes anything that might not be cross-platform filesystem</span><span class="s3">\n</span><span class="s1">// compatible, like |. It does not need to be precise because the fallback is to</span><span class="s3">\n</span><span class="s1">// just base64url-encode the whole parameter, which is fine; we just don't do it</span><span class="s3">\n</span><span class="s1">// by default for compactness, and for easier debugging.</span><span class="s3">\n</span><span class="s1">const simpleParamValueRegex = /^[a-zA-Z0-9</span><span class="s3">\\</span><span class="s1">-_@]+$/</span><span class="s3">\n\n</span><span class="s1">function encodeToFilesystemAndURLSafeString(value: string) {</span><span class="s3">\n  </span><span class="s1">if (simpleParamValueRegex.test(value)) {</span><span class="s3">\n    </span><span class="s1">return value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// If there are any unsafe characters, base64url-encode the entire value.</span><span class="s3">\n  </span><span class="s1">// We also add a ! prefix so it doesn't collide with the simple case.</span><span class="s3">\n  </span><span class="s1">const base64url = btoa(value)</span><span class="s3">\n    </span><span class="s1">.replace(/</span><span class="s3">\\</span><span class="s1">+/g, '-') // Replace '+' with '-'</span><span class="s3">\n    </span><span class="s1">.replace(/</span><span class="s3">\\</span><span class="s1">//g, '_') // Replace '/' with '_'</span><span class="s3">\n    </span><span class="s1">.replace(/=+$/, '') // Remove trailing '='</span><span class="s3">\n  </span><span class="s1">return '!' + base64url</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function convertSegmentPathToStaticExportFilename(</span><span class="s3">\n  </span><span class="s1">segmentPath: string</span><span class="s3">\n</span><span class="s1">): string {</span><span class="s3">\n  </span><span class="s1">return `__next${segmentPath.replace(/</span><span class="s3">\\</span><span class="s1">//g, '.')}.txt`</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;ROOT_SEGMENT_CACHE_KEY&quot;</span><span class="s0">,</span><span class="s1">&quot;ROOT_SEGMENT_REQUEST_KEY&quot;</span><span class="s0">,</span><span class="s1">&quot;appendSegmentCacheKeyPart&quot;</span><span class="s0">,</span><span class="s1">&quot;appendSegmentRequestKeyPart&quot;</span><span class="s0">,</span><span class="s1">&quot;convertSegmentPathToStaticExportFilename&quot;</span><span class="s0">,</span><span class="s1">&quot;createSegmentCacheKeyPart&quot;</span><span class="s0">,</span><span class="s1">&quot;createSegmentRequestKeyPart&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;PAGE_SEGMENT_KEY&quot;</span><span class="s0">,</span><span class="s1">&quot;safeName&quot;</span><span class="s0">,</span><span class="s1">&quot;encodeToFilesystemAndURLSafeString&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;paramType&quot;</span><span class="s0">,</span><span class="s1">&quot;encodedName&quot;</span><span class="s0">,</span><span class="s1">&quot;parentRequestKey&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRouteKey&quot;</span><span class="s0">,</span><span class="s1">&quot;childRequestKeyPart&quot;</span><span class="s0">,</span><span class="s1">&quot;slotKey&quot;</span><span class="s0">,</span><span class="s1">&quot;requestKeyPart&quot;</span><span class="s0">,</span><span class="s1">&quot;paramValue&quot;</span><span class="s0">,</span><span class="s1">&quot;safeValue&quot;</span><span class="s0">,</span><span class="s1">&quot;parentSegmentKey&quot;</span><span class="s0">,</span><span class="s1">&quot;childCacheKeyPart&quot;</span><span class="s0">,</span><span class="s1">&quot;simpleParamValueRegex&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;base64url&quot;</span><span class="s0">,</span><span class="s1">&quot;btoa&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;segmentPath&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;;;;;;IAYaA,sBAAsB;eAAtBA;;IADAC,wBAAwB;eAAxBA;;IAuEGC,yBAAyB;eAAzBA;;IAhCAC,2BAA2B;eAA3BA;;IAgEAC,wCAAwC;eAAxCA;;IA5CAC,yBAAyB;eAAzBA;;IAxDAC,2BAA2B;eAA3BA;;;yBAdiB;AAW1B,MAAML,2BAA2B;AACjC,MAAMD,yBAAyB;AAE/B,SAASM,4BACdC,OAAiC;IAEjC,IAAI,OAAOA,YAAY,UAAU;QAC/B,IAAIA,QAAQC,UAAU,CAACC,yBAAgB,GAAG;YACxC,uEAAuE;YACvE,yEAAyE;YACzE,wEAAwE;YACxE,sEAAsE;YACtE,uEAAuE;YACvE,yEAAyE;YACzE,4CAA4C;YAC5C,uEAAuE;YACvE,iEAAiE;YACjE,OAAOA,yBAAgB;QACzB;QACA,MAAMC,WACJ,qEAAqE;QACrE,sEAAsE;QACtE,mDAAmD;QACnDH,YAAY,gBACR,eACAI,mCAAmCJ;QACzC,uEAAuE;QACvE,4CAA4C;QAC5C,OAAOG;IACT;IAEA,MAAME,OAAOL,OAAO,CAAC,EAAE;IACvB,MAAMM,YAAYN,OAAO,CAAC,EAAE;IAC5B,MAAMG,WAAWC,mCAAmCC;IAEpD,MAAME,cAAc,MAAMD,YAAY,MAAMH;IAC5C,OAAOI;AACT;AAEO,SAASX,4BACdY,gBAAmC,EACnCC,gBAAwB,EACxBC,mBAA0C;IAE1C,2EAA2E;IAC3E,2EAA2E;IAC3E,6EAA6E;IAC7E,2EAA2E;IAC3E,sDAAsD;IAEtD,mEAAmE;IACnE,wEAAwE;IACxE,MAAMC,UACJF,qBAAqB,aACjBC,sBACA,AAAC,MAAGN,mCAAmCK,oBAAkB,MAAGC;IAClE,OAAQF,mBAAmB,MAAMG;AACnC;AAEO,SAASb,0BACdc,cAAqC,EACrCZ,OAAiC;IAEjC,IAAI,OAAOA,YAAY,UAAU;QAC/B,OAAOY;IACT;IACA,MAAMC,aAAab,OAAO,CAAC,EAAE;IAC7B,MAAMc,YAAYV,mCAAmCS;IACrD,OAAQD,iBAAiB,MAAME;AACjC;AAEO,SAASnB,0BACdoB,gBAAiC,EACjCN,gBAAwB,EACxBO,iBAAsC;IAEtC,MAAML,UACJF,qBAAqB,aACjBO,oBACA,AAAC,MAAGZ,mCAAmCK,oBAAkB,MAAGO;IAClE,OAAQD,mBAAmB,MAAMJ;AACnC;AAEA,8EAA8E;AAC9E,0EAA0E;AAC1E,gFAAgF;AAChF,gFAAgF;AAChF,wDAAwD;AACxD,MAAMM,wBAAwB;AAE9B,SAASb,mCAAmCc,KAAa;IACvD,IAAID,sBAAsBE,IAAI,CAACD,QAAQ;QACrC,OAAOA;IACT;IACA,yEAAyE;IACzE,qEAAqE;IACrE,MAAME,YAAYC,KAAKH,OACpBI,OAAO,CAAC,OAAO,KAAK,uBAAuB;KAC3CA,OAAO,CAAC,OAAO,KAAK,uBAAuB;KAC3CA,OAAO,CAAC,OAAO,IAAI,sBAAsB;;IAC5C,OAAO,MAAMF;AACf;AAEO,SAASvB,yCACd0B,WAAmB;IAEnB,OAAO,AAAC,WAAQA,YAAYD,OAAO,CAAC,OAAO,OAAK;AAClD&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>