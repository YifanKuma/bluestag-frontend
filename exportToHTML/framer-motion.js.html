<html>
<head>
<title>framer-motion.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #0033b3;}
.s2 { color: #067d17;}
.s3 { color: #1750eb;}
.s4 { color: #264eff;}
.s5 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
framer-motion.js</font>
</center></td></tr></table>
<pre><span class="s0">!</span><span class="s1">function</span><span class="s0">(t,e){</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">exports&amp;&amp;</span><span class="s2">&quot;undefined&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">module?e(exports,require(</span><span class="s2">&quot;react&quot;</span><span class="s0">)):</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">define&amp;&amp;define.amd?define([</span><span class="s2">&quot;exports&quot;</span><span class="s0">,</span><span class="s2">&quot;react&quot;</span><span class="s0">],e):e((t=</span><span class="s2">&quot;undefined&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">globalThis?globalThis:t||self).Motion={},t.React)}(</span><span class="s1">this</span><span class="s0">,</span><span class="s1">function</span><span class="s0">(t,e){</span><span class="s2">&quot;use strict&quot;</span><span class="s0">;</span><span class="s1">function </span><span class="s0">n(t){</span><span class="s1">var </span><span class="s0">e=Object.create(</span><span class="s1">null</span><span class="s0">);</span><span class="s1">return </span><span class="s0">t&amp;&amp;Object.keys(t).forEach(</span><span class="s1">function</span><span class="s0">(n){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;default&quot;</span><span class="s0">!==n){</span><span class="s1">var </span><span class="s0">i=Object.getOwnPropertyDescriptor(t,n);Object.defineProperty(e,n,i.get?i:{enumerable:!</span><span class="s3">0</span><span class="s0">,get:</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">t[n]}})}}),e.default=t,Object.freeze(e)}</span><span class="s1">var </span><span class="s0">i=n(e),s=React,o=Symbol.for(</span><span class="s2">&quot;react.element&quot;</span><span class="s0">),r=Symbol.for(</span><span class="s2">&quot;react.fragment&quot;</span><span class="s0">),a=Object.prototype.hasOwnProperty,l=s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,u={key:!</span><span class="s3">0</span><span class="s0">,ref:!</span><span class="s3">0</span><span class="s0">,__self:!</span><span class="s3">0</span><span class="s0">,__source:!</span><span class="s3">0</span><span class="s0">};</span><span class="s1">function </span><span class="s0">c(t,e,n){</span><span class="s1">var </span><span class="s0">i,s={},r=</span><span class="s1">null</span><span class="s0">,c=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(i </span><span class="s1">in void </span><span class="s3">0</span><span class="s0">!==n&amp;&amp;(r=</span><span class="s2">&quot;&quot;</span><span class="s0">+n),</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==e.key&amp;&amp;(r=</span><span class="s2">&quot;&quot;</span><span class="s0">+e.key),</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==e.ref&amp;&amp;(c=e.ref),e)a.call(e,i)&amp;&amp;!u.hasOwnProperty(i)&amp;&amp;(s[i]=e[i]);</span><span class="s1">if</span><span class="s0">(t&amp;&amp;t.defaultProps)</span><span class="s1">for</span><span class="s0">(i </span><span class="s1">in </span><span class="s0">e=t.defaultProps)</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===s[i]&amp;&amp;(s[i]=e[i]);</span><span class="s1">return</span><span class="s0">{$$typeof:o,type:t,key:r,ref:c,props:s,_owner:l.current}}</span><span class="s1">const </span><span class="s0">h=r,d=c,p=c,m=e.createContext({});</span><span class="s1">function </span><span class="s0">f(t){</span><span class="s1">const </span><span class="s0">n=e.useRef(</span><span class="s1">null</span><span class="s0">);</span><span class="s1">return null</span><span class="s0">===n.current&amp;&amp;(n.current=t()),n.current}</span><span class="s1">const </span><span class="s0">g=</span><span class="s2">&quot;undefined&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">window,y=g?e.useLayoutEffect:e.useEffect,v=e.createContext(</span><span class="s1">null</span><span class="s0">);</span><span class="s1">function </span><span class="s0">x(t,e){-</span><span class="s3">1</span><span class="s0">===t.indexOf(e)&amp;&amp;t.push(e)}</span><span class="s1">function </span><span class="s0">w(t,e){</span><span class="s1">const </span><span class="s0">n=t.indexOf(e);n&gt;-</span><span class="s3">1</span><span class="s0">&amp;&amp;t.splice(n,</span><span class="s3">1</span><span class="s0">)}</span><span class="s1">function </span><span class="s0">T([...t],e,n){</span><span class="s1">const </span><span class="s0">i=e&lt;</span><span class="s3">0</span><span class="s0">?t.length+e:e;</span><span class="s1">if</span><span class="s0">(i&gt;=</span><span class="s3">0</span><span class="s0">&amp;&amp;i&lt;t.length){</span><span class="s1">const </span><span class="s0">i=n&lt;</span><span class="s3">0</span><span class="s0">?t.length+n:n,[s]=t.splice(e,</span><span class="s3">1</span><span class="s0">);t.splice(i,</span><span class="s3">0</span><span class="s0">,s)}</span><span class="s1">return </span><span class="s0">t}</span><span class="s1">const </span><span class="s0">P=(t,e,n)=&gt;n&gt;e?e:n&lt;t?t:n;</span><span class="s1">let </span><span class="s0">b=()=&gt;{};</span><span class="s1">const </span><span class="s0">S={},E=t=&gt;</span><span class="s4">/^-?(?:\d+(?:\.\d+)?|\.\d+)$/u</span><span class="s0">.test(t);</span><span class="s1">function </span><span class="s0">A(t){</span><span class="s1">return</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t&amp;&amp;</span><span class="s1">null</span><span class="s0">!==t}</span><span class="s1">const </span><span class="s0">M=t=&gt;</span><span class="s4">/^0[^.\s]+$/u</span><span class="s0">.test(t);</span><span class="s1">function </span><span class="s0">C(t){</span><span class="s1">let </span><span class="s0">e;</span><span class="s1">return</span><span class="s0">()=&gt;(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===e&amp;&amp;(e=t()),e)}</span><span class="s1">const </span><span class="s0">V=t=&gt;t,D=(t,e)=&gt;n=&gt;e(t(n)),R=(...t)=&gt;t.reduce(D),k=(t,e,n)=&gt;{</span><span class="s1">const </span><span class="s0">i=e-t;</span><span class="s1">return </span><span class="s3">0</span><span class="s0">===i?</span><span class="s3">1</span><span class="s0">:(n-t)/i};</span><span class="s1">class </span><span class="s0">L{constructor(){</span><span class="s1">this</span><span class="s0">.subscriptions=[]}add(t){</span><span class="s1">return </span><span class="s0">x(</span><span class="s1">this</span><span class="s0">.subscriptions,t),()=&gt;w(</span><span class="s1">this</span><span class="s0">.subscriptions,t)}notify(t,e,n){</span><span class="s1">const </span><span class="s0">i=</span><span class="s1">this</span><span class="s0">.subscriptions.length;</span><span class="s1">if</span><span class="s0">(i)</span><span class="s1">if</span><span class="s0">(</span><span class="s3">1</span><span class="s0">===i)</span><span class="s1">this</span><span class="s0">.subscriptions[</span><span class="s3">0</span><span class="s0">](t,e,n);</span><span class="s1">else for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">s=</span><span class="s3">0</span><span class="s0">;s&lt;i;s++){</span><span class="s1">const </span><span class="s0">i=</span><span class="s1">this</span><span class="s0">.subscriptions[s];i&amp;&amp;i(t,e,n)}}getSize(){</span><span class="s1">return this</span><span class="s0">.subscriptions.length}clear(){</span><span class="s1">this</span><span class="s0">.subscriptions.length=</span><span class="s3">0</span><span class="s0">}}</span><span class="s1">const </span><span class="s0">O=t=&gt;</span><span class="s3">1e3</span><span class="s0">*t,j=t=&gt;t/</span><span class="s3">1e3</span><span class="s0">;</span><span class="s1">function </span><span class="s0">B(t,e){</span><span class="s1">return </span><span class="s0">e?t*(</span><span class="s3">1e3</span><span class="s0">/e):</span><span class="s3">0</span><span class="s0">}</span><span class="s1">const </span><span class="s0">I=</span><span class="s1">new </span><span class="s0">Set;</span><span class="s1">const </span><span class="s0">F=(t,e,n)=&gt;{</span><span class="s1">const </span><span class="s0">i=e-t;</span><span class="s1">return</span><span class="s0">((n-t)%i+i)%i+t},W=(t,e,n)=&gt;(((</span><span class="s3">1</span><span class="s0">-</span><span class="s3">3</span><span class="s0">*n+</span><span class="s3">3</span><span class="s0">*e)*t+(</span><span class="s3">3</span><span class="s0">*n-</span><span class="s3">6</span><span class="s0">*e))*t+</span><span class="s3">3</span><span class="s0">*e)*t;</span><span class="s1">function </span><span class="s0">U(t,e,n,i){</span><span class="s1">if</span><span class="s0">(t===e&amp;&amp;n===i)</span><span class="s1">return </span><span class="s0">V;</span><span class="s1">const </span><span class="s0">s=e=&gt;</span><span class="s1">function</span><span class="s0">(t,e,n,i,s){</span><span class="s1">let </span><span class="s0">o,r,a=</span><span class="s3">0</span><span class="s0">;</span><span class="s1">do</span><span class="s0">{r=e+(n-e)/</span><span class="s3">2</span><span class="s0">,o=W(r,i,s)-t,o&gt;</span><span class="s3">0</span><span class="s0">?n=r:e=r}</span><span class="s1">while</span><span class="s0">(Math.abs(o)&gt;</span><span class="s3">1e-7</span><span class="s0">&amp;&amp;++a&lt;</span><span class="s3">12</span><span class="s0">);</span><span class="s1">return </span><span class="s0">r}(e,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,t,n);</span><span class="s1">return </span><span class="s0">t=&gt;</span><span class="s3">0</span><span class="s0">===t||</span><span class="s3">1</span><span class="s0">===t?t:W(s(t),e,i)}</span><span class="s1">const </span><span class="s0">N=t=&gt;e=&gt;e&lt;=</span><span class="s3">.5</span><span class="s0">?t(</span><span class="s3">2</span><span class="s0">*e)/</span><span class="s3">2</span><span class="s0">:(</span><span class="s3">2</span><span class="s0">-t(</span><span class="s3">2</span><span class="s0">*(</span><span class="s3">1</span><span class="s0">-e)))/</span><span class="s3">2</span><span class="s0">,$=t=&gt;e=&gt;</span><span class="s3">1</span><span class="s0">-t(</span><span class="s3">1</span><span class="s0">-e),z=U(</span><span class="s3">.33</span><span class="s0">,</span><span class="s3">1.53</span><span class="s0">,</span><span class="s3">.69</span><span class="s0">,</span><span class="s3">.99</span><span class="s0">),X=$(z),H=N(X),Y=t=&gt;(t*=</span><span class="s3">2</span><span class="s0">)&lt;</span><span class="s3">1</span><span class="s0">?</span><span class="s3">.5</span><span class="s0">*X(t):</span><span class="s3">.5</span><span class="s0">*(</span><span class="s3">2</span><span class="s0">-Math.pow(</span><span class="s3">2</span><span class="s0">,-</span><span class="s3">10</span><span class="s0">*(t-</span><span class="s3">1</span><span class="s0">))),K=t=&gt;</span><span class="s3">1</span><span class="s0">-Math.sin(Math.acos(t)),G=$(K),_=N(K),Z=U(</span><span class="s3">.42</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">1</span><span class="s0">),q=U(</span><span class="s3">0</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">.58</span><span class="s0">,</span><span class="s3">1</span><span class="s0">),J=U(</span><span class="s3">.42</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">.58</span><span class="s0">,</span><span class="s3">1</span><span class="s0">);</span><span class="s1">const </span><span class="s0">Q=t=&gt;Array.isArray(t)&amp;&amp;</span><span class="s2">&quot;number&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">t[</span><span class="s3">0</span><span class="s0">];</span><span class="s1">function </span><span class="s0">tt(t,e){</span><span class="s1">return </span><span class="s0">Q(t)?t[F(</span><span class="s3">0</span><span class="s0">,t.length,e)]:t}</span><span class="s1">const </span><span class="s0">et=t=&gt;Array.isArray(t)&amp;&amp;</span><span class="s2">&quot;number&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t[</span><span class="s3">0</span><span class="s0">],nt={linear:V,easeIn:Z,easeInOut:J,easeOut:q,circIn:K,circInOut:_,circOut:G,backIn:X,backInOut:H,backOut:z,anticipate:Y},it=t=&gt;{</span><span class="s1">if</span><span class="s0">(et(t)){t.length;</span><span class="s1">const</span><span class="s0">[e,n,i,s]=t;</span><span class="s1">return </span><span class="s0">U(e,n,i,s)}</span><span class="s1">return</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t?nt[t]:t},st=[</span><span class="s2">&quot;setup&quot;</span><span class="s0">,</span><span class="s2">&quot;read&quot;</span><span class="s0">,</span><span class="s2">&quot;resolveKeyframes&quot;</span><span class="s0">,</span><span class="s2">&quot;preUpdate&quot;</span><span class="s0">,</span><span class="s2">&quot;update&quot;</span><span class="s0">,</span><span class="s2">&quot;preRender&quot;</span><span class="s0">,</span><span class="s2">&quot;render&quot;</span><span class="s0">,</span><span class="s2">&quot;postRender&quot;</span><span class="s0">],ot={value:</span><span class="s1">null</span><span class="s0">,addProjectionMetrics:</span><span class="s1">null</span><span class="s0">};</span><span class="s1">function </span><span class="s0">rt(t,e){</span><span class="s1">let </span><span class="s0">n=!</span><span class="s3">1</span><span class="s0">,i=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">const </span><span class="s0">s={delta:</span><span class="s3">0</span><span class="s0">,timestamp:</span><span class="s3">0</span><span class="s0">,isProcessing:!</span><span class="s3">1</span><span class="s0">},o=()=&gt;n=!</span><span class="s3">0</span><span class="s0">,r=st.reduce((t,n)=&gt;(t[n]=</span><span class="s1">function</span><span class="s0">(t,e){</span><span class="s1">let </span><span class="s0">n=</span><span class="s1">new </span><span class="s0">Set,i=</span><span class="s1">new </span><span class="s0">Set,s=!</span><span class="s3">1</span><span class="s0">,o=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">const </span><span class="s0">r=</span><span class="s1">new </span><span class="s0">WeakSet;</span><span class="s1">let </span><span class="s0">a={delta:</span><span class="s3">0</span><span class="s0">,timestamp:</span><span class="s3">0</span><span class="s0">,isProcessing:!</span><span class="s3">1</span><span class="s0">},l=</span><span class="s3">0</span><span class="s0">;</span><span class="s1">function </span><span class="s0">u(e){r.has(e)&amp;&amp;(c.schedule(e),t()),l++,e(a)}</span><span class="s1">const </span><span class="s0">c={schedule:(t,e=!</span><span class="s3">1</span><span class="s0">,o=!</span><span class="s3">1</span><span class="s0">)=&gt;{</span><span class="s1">const </span><span class="s0">a=o&amp;&amp;s?n:i;</span><span class="s1">return </span><span class="s0">e&amp;&amp;r.add(t),a.has(t)||a.add(t),t},cancel:t=&gt;{i.delete(t),r.delete(t)},process:t=&gt;{a=t,s?o=!</span><span class="s3">0</span><span class="s0">:(s=!</span><span class="s3">0</span><span class="s0">,[n,i]=[i,n],n.forEach(u),e&amp;&amp;ot.value&amp;&amp;ot.value.frameloop[e].push(l),l=</span><span class="s3">0</span><span class="s0">,n.clear(),s=!</span><span class="s3">1</span><span class="s0">,o&amp;&amp;(o=!</span><span class="s3">1</span><span class="s0">,c.process(t)))}};</span><span class="s1">return </span><span class="s0">c}(o,e?n:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">),t),{}),{setup:a,read:l,resolveKeyframes:u,preUpdate:c,update:h,preRender:d,render:p,postRender:m}=r,f=()=&gt;{</span><span class="s1">const </span><span class="s0">o=S.useManualTiming?s.timestamp:performance.now();n=!</span><span class="s3">1</span><span class="s0">,S.useManualTiming||(s.delta=i?</span><span class="s3">1e3</span><span class="s0">/</span><span class="s3">60</span><span class="s0">:Math.max(Math.min(o-s.timestamp,</span><span class="s3">40</span><span class="s0">),</span><span class="s3">1</span><span class="s0">)),s.timestamp=o,s.isProcessing=!</span><span class="s3">0</span><span class="s0">,a.process(s),l.process(s),u.process(s),c.process(s),h.process(s),d.process(s),p.process(s),m.process(s),s.isProcessing=!</span><span class="s3">1</span><span class="s0">,n&amp;&amp;e&amp;&amp;(i=!</span><span class="s3">1</span><span class="s0">,t(f))};</span><span class="s1">return</span><span class="s0">{schedule:st.reduce((e,o)=&gt;{</span><span class="s1">const </span><span class="s0">a=r[o];</span><span class="s1">return </span><span class="s0">e[o]=(e,o=!</span><span class="s3">1</span><span class="s0">,r=!</span><span class="s3">1</span><span class="s0">)=&gt;(n||(n=!</span><span class="s3">0</span><span class="s0">,i=!</span><span class="s3">0</span><span class="s0">,s.isProcessing||t(f)),a.schedule(e,o,r)),e},{}),cancel:t=&gt;{</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">e=</span><span class="s3">0</span><span class="s0">;e&lt;st.length;e++)r[st[e]].cancel(t)},state:s,steps:r}}</span><span class="s1">const</span><span class="s0">{schedule:at,cancel:lt,state:ut,steps:ct}=rt(</span><span class="s2">&quot;undefined&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">requestAnimationFrame?requestAnimationFrame:V,!</span><span class="s3">0</span><span class="s0">);</span><span class="s1">let </span><span class="s0">ht;</span><span class="s1">function </span><span class="s0">dt(){ht=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">}</span><span class="s1">const </span><span class="s0">pt={now:()=&gt;(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===ht&amp;&amp;pt.set(ut.isProcessing||S.useManualTiming?ut.timestamp:performance.now()),ht),set:t=&gt;{ht=t,queueMicrotask(dt)}},mt={layout:</span><span class="s3">0</span><span class="s0">,mainThread:</span><span class="s3">0</span><span class="s0">,waapi:</span><span class="s3">0</span><span class="s0">},ft=t=&gt;e=&gt;</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;e.startsWith(t),gt=ft(</span><span class="s2">&quot;--&quot;</span><span class="s0">),yt=ft(</span><span class="s2">&quot;var(--&quot;</span><span class="s0">),vt=t=&gt;!!yt(t)&amp;&amp;xt.test(t.split(</span><span class="s2">&quot;/*&quot;</span><span class="s0">)[</span><span class="s3">0</span><span class="s0">].trim()),xt=</span><span class="s4">/var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu</span><span class="s0">,wt={test:t=&gt;</span><span class="s2">&quot;number&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t,parse:parseFloat,transform:t=&gt;t},Tt={...wt,transform:t=&gt;P(</span><span class="s3">0</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,t)},Pt={...wt,</span><span class="s1">default</span><span class="s0">:</span><span class="s3">1</span><span class="s0">},bt=t=&gt;Math.round(</span><span class="s3">1e5</span><span class="s0">*t)/</span><span class="s3">1e5</span><span class="s0">,St=</span><span class="s4">/-?(?:\d+(?:\.\d+)?|\.\d+)/gu</span><span class="s0">;</span><span class="s1">const </span><span class="s0">Et=</span><span class="s4">/^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu</span><span class="s0">,At=(t,e)=&gt;n=&gt;Boolean(</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">n&amp;&amp;Et.test(n)&amp;&amp;n.startsWith(t)||e&amp;&amp;!</span><span class="s1">function</span><span class="s0">(t){</span><span class="s1">return null</span><span class="s0">==t}(n)&amp;&amp;Object.prototype.hasOwnProperty.call(n,e)),Mt=(t,e,n)=&gt;i=&gt;{</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;string&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">i)</span><span class="s1">return </span><span class="s0">i;</span><span class="s1">const</span><span class="s0">[s,o,r,a]=i.match(St);</span><span class="s1">return</span><span class="s0">{[t]:parseFloat(s),[e]:parseFloat(o),[n]:parseFloat(r),alpha:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==a?parseFloat(a):</span><span class="s3">1</span><span class="s0">}},Ct={...wt,transform:t=&gt;Math.round((t=&gt;P(</span><span class="s3">0</span><span class="s0">,</span><span class="s3">255</span><span class="s0">,t))(t))},Vt={test:At(</span><span class="s2">&quot;rgb&quot;</span><span class="s0">,</span><span class="s2">&quot;red&quot;</span><span class="s0">),parse:Mt(</span><span class="s2">&quot;red&quot;</span><span class="s0">,</span><span class="s2">&quot;green&quot;</span><span class="s0">,</span><span class="s2">&quot;blue&quot;</span><span class="s0">),transform:({red:t,green:e,blue:n,alpha:i=</span><span class="s3">1</span><span class="s0">})=&gt;</span><span class="s2">&quot;rgba(&quot;</span><span class="s0">+Ct.transform(t)+</span><span class="s2">&quot;, &quot;</span><span class="s0">+Ct.transform(e)+</span><span class="s2">&quot;, &quot;</span><span class="s0">+Ct.transform(n)+</span><span class="s2">&quot;, &quot;</span><span class="s0">+bt(Tt.transform(i))+</span><span class="s2">&quot;)&quot;</span><span class="s0">};</span><span class="s1">const </span><span class="s0">Dt={test:At(</span><span class="s2">&quot;#&quot;</span><span class="s0">),parse:</span><span class="s1">function</span><span class="s0">(t){</span><span class="s1">let </span><span class="s0">e=</span><span class="s2">&quot;&quot;</span><span class="s0">,n=</span><span class="s2">&quot;&quot;</span><span class="s0">,i=</span><span class="s2">&quot;&quot;</span><span class="s0">,s=</span><span class="s2">&quot;&quot;</span><span class="s0">;</span><span class="s1">return </span><span class="s0">t.length&gt;</span><span class="s3">5</span><span class="s0">?(e=t.substring(</span><span class="s3">1</span><span class="s0">,</span><span class="s3">3</span><span class="s0">),n=t.substring(</span><span class="s3">3</span><span class="s0">,</span><span class="s3">5</span><span class="s0">),i=t.substring(</span><span class="s3">5</span><span class="s0">,</span><span class="s3">7</span><span class="s0">),s=t.substring(</span><span class="s3">7</span><span class="s0">,</span><span class="s3">9</span><span class="s0">)):(e=t.substring(</span><span class="s3">1</span><span class="s0">,</span><span class="s3">2</span><span class="s0">),n=t.substring(</span><span class="s3">2</span><span class="s0">,</span><span class="s3">3</span><span class="s0">),i=t.substring(</span><span class="s3">3</span><span class="s0">,</span><span class="s3">4</span><span class="s0">),s=t.substring(</span><span class="s3">4</span><span class="s0">,</span><span class="s3">5</span><span class="s0">),e+=e,n+=n,i+=i,s+=s),{red:parseInt(e,</span><span class="s3">16</span><span class="s0">),green:parseInt(n,</span><span class="s3">16</span><span class="s0">),blue:parseInt(i,</span><span class="s3">16</span><span class="s0">),alpha:s?parseInt(s,</span><span class="s3">16</span><span class="s0">)/</span><span class="s3">255</span><span class="s0">:</span><span class="s3">1</span><span class="s0">}},transform:Vt.transform},Rt=t=&gt;({test:e=&gt;</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;e.endsWith(t)&amp;&amp;</span><span class="s3">1</span><span class="s0">===e.split(</span><span class="s2">&quot; &quot;</span><span class="s0">).length,parse:parseFloat,transform:e=&gt;</span><span class="s2">`</span><span class="s0">${e}${t}</span><span class="s2">`</span><span class="s0">}),kt=Rt(</span><span class="s2">&quot;deg&quot;</span><span class="s0">),Lt=Rt(</span><span class="s2">&quot;%&quot;</span><span class="s0">),Ot=Rt(</span><span class="s2">&quot;px&quot;</span><span class="s0">),jt=Rt(</span><span class="s2">&quot;vh&quot;</span><span class="s0">),Bt=Rt(</span><span class="s2">&quot;vw&quot;</span><span class="s0">),It=(()=&gt;({...Lt,parse:t=&gt;Lt.parse(t)/</span><span class="s3">100</span><span class="s0">,transform:t=&gt;Lt.transform(</span><span class="s3">100</span><span class="s0">*t)}))(),Ft={test:At(</span><span class="s2">&quot;hsl&quot;</span><span class="s0">,</span><span class="s2">&quot;hue&quot;</span><span class="s0">),parse:Mt(</span><span class="s2">&quot;hue&quot;</span><span class="s0">,</span><span class="s2">&quot;saturation&quot;</span><span class="s0">,</span><span class="s2">&quot;lightness&quot;</span><span class="s0">),transform:({hue:t,saturation:e,lightness:n,alpha:i=</span><span class="s3">1</span><span class="s0">})=&gt;</span><span class="s2">&quot;hsla(&quot;</span><span class="s0">+Math.round(t)+</span><span class="s2">&quot;, &quot;</span><span class="s0">+Lt.transform(bt(e))+</span><span class="s2">&quot;, &quot;</span><span class="s0">+Lt.transform(bt(n))+</span><span class="s2">&quot;, &quot;</span><span class="s0">+bt(Tt.transform(i))+</span><span class="s2">&quot;)&quot;</span><span class="s0">},Wt={test:t=&gt;Vt.test(t)||Dt.test(t)||Ft.test(t),parse:t=&gt;Vt.test(t)?Vt.parse(t):Ft.test(t)?Ft.parse(t):Dt.parse(t),transform:t=&gt;</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t?t:t.hasOwnProperty(</span><span class="s2">&quot;red&quot;</span><span class="s0">)?Vt.transform(t):Ft.transform(t),getAnimatableNone:t=&gt;{</span><span class="s1">const </span><span class="s0">e=Wt.parse(t);</span><span class="s1">return </span><span class="s0">e.alpha=</span><span class="s3">0</span><span class="s0">,Wt.transform(e)}},Ut=</span><span class="s4">/(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu</span><span class="s0">;</span><span class="s1">const </span><span class="s0">Nt=</span><span class="s2">&quot;number&quot;</span><span class="s0">,$t=</span><span class="s2">&quot;color&quot;</span><span class="s0">,zt=</span><span class="s4">/var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu</span><span class="s0">;</span><span class="s1">function </span><span class="s0">Xt(t){</span><span class="s1">const </span><span class="s0">e=t.toString(),n=[],i={color:[],number:[],</span><span class="s1">var</span><span class="s0">:[]},s=[];</span><span class="s1">let </span><span class="s0">o=</span><span class="s3">0</span><span class="s0">;</span><span class="s1">const </span><span class="s0">r=e.replace(zt,t=&gt;(Wt.test(t)?(i.color.push(o),s.push($t),n.push(Wt.parse(t))):t.startsWith(</span><span class="s2">&quot;var(&quot;</span><span class="s0">)?(i.var.push(o),s.push(</span><span class="s2">&quot;var&quot;</span><span class="s0">),n.push(t)):(i.number.push(o),s.push(Nt),n.push(parseFloat(t))),++o,</span><span class="s2">&quot;${}&quot;</span><span class="s0">)).split(</span><span class="s2">&quot;${}&quot;</span><span class="s0">);</span><span class="s1">return</span><span class="s0">{values:n,split:r,indexes:i,types:s}}</span><span class="s1">function </span><span class="s0">Ht(t){</span><span class="s1">return </span><span class="s0">Xt(t).values}</span><span class="s1">function </span><span class="s0">Yt(t){</span><span class="s1">const</span><span class="s0">{split:e,types:n}=Xt(t),i=e.length;</span><span class="s1">return </span><span class="s0">t=&gt;{</span><span class="s1">let </span><span class="s0">s=</span><span class="s2">&quot;&quot;</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">o=</span><span class="s3">0</span><span class="s0">;o&lt;i;o++)</span><span class="s1">if</span><span class="s0">(s+=e[o],</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==t[o]){</span><span class="s1">const </span><span class="s0">e=n[o];s+=e===Nt?bt(t[o]):e===$t?Wt.transform(t[o]):t[o]}</span><span class="s1">return </span><span class="s0">s}}</span><span class="s1">const </span><span class="s0">Kt=t=&gt;</span><span class="s2">&quot;number&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t?</span><span class="s3">0</span><span class="s0">:Wt.test(t)?Wt.getAnimatableNone(t):t;</span><span class="s1">const </span><span class="s0">Gt={test:</span><span class="s1">function</span><span class="s0">(t){</span><span class="s1">return </span><span class="s0">isNaN(t)&amp;&amp;</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t&amp;&amp;(t.match(St)?.length||</span><span class="s3">0</span><span class="s0">)+(t.match(Ut)?.length||</span><span class="s3">0</span><span class="s0">)&gt;</span><span class="s3">0</span><span class="s0">},parse:Ht,createTransformer:Yt,getAnimatableNone:</span><span class="s1">function</span><span class="s0">(t){</span><span class="s1">const </span><span class="s0">e=Ht(t);</span><span class="s1">return </span><span class="s0">Yt(t)(e.map(Kt))}};</span><span class="s1">function </span><span class="s0">_t(t,e,n){</span><span class="s1">return </span><span class="s0">n&lt;</span><span class="s3">0</span><span class="s0">&amp;&amp;(n+=</span><span class="s3">1</span><span class="s0">),n&gt;</span><span class="s3">1</span><span class="s0">&amp;&amp;(n-=</span><span class="s3">1</span><span class="s0">),n&lt;</span><span class="s3">1</span><span class="s0">/</span><span class="s3">6</span><span class="s0">?t+</span><span class="s3">6</span><span class="s0">*(e-t)*n:n&lt;</span><span class="s3">.5</span><span class="s0">?e:n&lt;</span><span class="s3">2</span><span class="s0">/</span><span class="s3">3</span><span class="s0">?t+(e-t)*(</span><span class="s3">2</span><span class="s0">/</span><span class="s3">3</span><span class="s0">-n)*</span><span class="s3">6</span><span class="s0">:t}</span><span class="s1">function </span><span class="s0">Zt({hue:t,saturation:e,lightness:n,alpha:i}){t/=</span><span class="s3">360</span><span class="s0">,n/=</span><span class="s3">100</span><span class="s0">;</span><span class="s1">let </span><span class="s0">s=</span><span class="s3">0</span><span class="s0">,o=</span><span class="s3">0</span><span class="s0">,r=</span><span class="s3">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(e/=</span><span class="s3">100</span><span class="s0">){</span><span class="s1">const </span><span class="s0">i=n&lt;</span><span class="s3">.5</span><span class="s0">?n*(</span><span class="s3">1</span><span class="s0">+e):n+e-n*e,a=</span><span class="s3">2</span><span class="s0">*n-i;s=_t(a,i,t+</span><span class="s3">1</span><span class="s0">/</span><span class="s3">3</span><span class="s0">),o=_t(a,i,t),r=_t(a,i,t-</span><span class="s3">1</span><span class="s0">/</span><span class="s3">3</span><span class="s0">)}</span><span class="s1">else </span><span class="s0">s=o=r=n;</span><span class="s1">return</span><span class="s0">{red:Math.round(</span><span class="s3">255</span><span class="s0">*s),green:Math.round(</span><span class="s3">255</span><span class="s0">*o),blue:Math.round(</span><span class="s3">255</span><span class="s0">*r),alpha:i}}</span><span class="s1">function </span><span class="s0">qt(t,e){</span><span class="s1">return </span><span class="s0">n=&gt;n&gt;</span><span class="s3">0</span><span class="s0">?e:t}</span><span class="s1">const </span><span class="s0">Jt=(t,e,n)=&gt;t+(e-t)*n,Qt=(t,e,n)=&gt;{</span><span class="s1">const </span><span class="s0">i=t*t,s=n*(e*e-i)+i;</span><span class="s1">return </span><span class="s0">s&lt;</span><span class="s3">0</span><span class="s0">?</span><span class="s3">0</span><span class="s0">:Math.sqrt(s)},te=[Dt,Vt,Ft];</span><span class="s1">function </span><span class="s0">ee(t){</span><span class="s1">const </span><span class="s0">e=(n=t,te.find(t=&gt;t.test(n)));</span><span class="s1">var </span><span class="s0">n;</span><span class="s1">if</span><span class="s0">(!Boolean(e))</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">let </span><span class="s0">i=e.parse(t);</span><span class="s1">return </span><span class="s0">e===Ft&amp;&amp;(i=Zt(i)),i}</span><span class="s1">const </span><span class="s0">ne=(t,e)=&gt;{</span><span class="s1">const </span><span class="s0">n=ee(t),i=ee(e);</span><span class="s1">if</span><span class="s0">(!n||!i)</span><span class="s1">return </span><span class="s0">qt(t,e);</span><span class="s1">const </span><span class="s0">s={...n};</span><span class="s1">return </span><span class="s0">t=&gt;(s.red=Qt(n.red,i.red,t),s.green=Qt(n.green,i.green,t),s.blue=Qt(n.blue,i.blue,t),s.alpha=Jt(n.alpha,i.alpha,t),Vt.transform(s))},ie=</span><span class="s1">new </span><span class="s0">Set([</span><span class="s2">&quot;none&quot;</span><span class="s0">,</span><span class="s2">&quot;hidden&quot;</span><span class="s0">]);</span><span class="s1">function </span><span class="s0">se(t,e){</span><span class="s1">return </span><span class="s0">ie.has(t)?n=&gt;n&lt;=</span><span class="s3">0</span><span class="s0">?t:e:n=&gt;n&gt;=</span><span class="s3">1</span><span class="s0">?e:t}</span><span class="s1">function </span><span class="s0">oe(t,e){</span><span class="s1">return </span><span class="s0">n=&gt;Jt(t,e,n)}</span><span class="s1">function </span><span class="s0">re(t){</span><span class="s1">return</span><span class="s2">&quot;number&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t?oe:</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t?vt(t)?qt:Wt.test(t)?ne:ue:Array.isArray(t)?ae:</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t?Wt.test(t)?ne:le:qt}</span><span class="s1">function </span><span class="s0">ae(t,e){</span><span class="s1">const </span><span class="s0">n=[...t],i=n.length,s=t.map((t,n)=&gt;re(t)(t,e[n]));</span><span class="s1">return </span><span class="s0">t=&gt;{</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">e=</span><span class="s3">0</span><span class="s0">;e&lt;i;e++)n[e]=s[e](t);</span><span class="s1">return </span><span class="s0">n}}</span><span class="s1">function </span><span class="s0">le(t,e){</span><span class="s1">const </span><span class="s0">n={...t,...e},i={};</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">s </span><span class="s1">in </span><span class="s0">n)</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==t[s]&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==e[s]&amp;&amp;(i[s]=re(t[s])(t[s],e[s]));</span><span class="s1">return </span><span class="s0">t=&gt;{</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">e </span><span class="s1">in </span><span class="s0">i)n[e]=i[e](t);</span><span class="s1">return </span><span class="s0">n}}</span><span class="s1">const </span><span class="s0">ue=(t,e)=&gt;{</span><span class="s1">const </span><span class="s0">n=Gt.createTransformer(e),i=Xt(t),s=Xt(e);</span><span class="s1">return </span><span class="s0">i.indexes.var.length===s.indexes.var.length&amp;&amp;i.indexes.color.length===s.indexes.color.length&amp;&amp;i.indexes.number.length&gt;=s.indexes.number.length?ie.has(t)&amp;&amp;!s.values.length||ie.has(e)&amp;&amp;!i.values.length?se(t,e):R(ae(</span><span class="s1">function</span><span class="s0">(t,e){</span><span class="s1">const </span><span class="s0">n=[],i={color:</span><span class="s3">0</span><span class="s0">,</span><span class="s1">var</span><span class="s0">:</span><span class="s3">0</span><span class="s0">,number:</span><span class="s3">0</span><span class="s0">};</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">s=</span><span class="s3">0</span><span class="s0">;s&lt;e.values.length;s++){</span><span class="s1">const </span><span class="s0">o=e.types[s],r=t.indexes[o][i[o]],a=t.values[r]??</span><span class="s3">0</span><span class="s0">;n[s]=a,i[o]++}</span><span class="s1">return </span><span class="s0">n}(i,s),s.values),n):qt(t,e)};</span><span class="s1">function </span><span class="s0">ce(t,e,n){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;number&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t&amp;&amp;</span><span class="s2">&quot;number&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;</span><span class="s2">&quot;number&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">n)</span><span class="s1">return </span><span class="s0">Jt(t,e,n);</span><span class="s1">return </span><span class="s0">re(t)(t,e)}</span><span class="s1">const </span><span class="s0">he=t=&gt;{</span><span class="s1">const </span><span class="s0">e=({timestamp:e})=&gt;t(e);</span><span class="s1">return</span><span class="s0">{start:(t=!</span><span class="s3">0</span><span class="s0">)=&gt;at.update(e,t),stop:()=&gt;lt(e),now:()=&gt;ut.isProcessing?ut.timestamp:pt.now()}},de=(t,e,n=</span><span class="s3">10</span><span class="s0">)=&gt;{</span><span class="s1">let </span><span class="s0">i=</span><span class="s2">&quot;&quot;</span><span class="s0">;</span><span class="s1">const </span><span class="s0">s=Math.max(Math.round(e/n),</span><span class="s3">2</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">e=</span><span class="s3">0</span><span class="s0">;e&lt;s;e++)i+=Math.round(</span><span class="s3">1e4</span><span class="s0">*t(e/(s-</span><span class="s3">1</span><span class="s0">)))/</span><span class="s3">1e4</span><span class="s0">+</span><span class="s2">&quot;, &quot;</span><span class="s0">;</span><span class="s1">return</span><span class="s2">`linear(</span><span class="s0">${i.substring(</span><span class="s3">0</span><span class="s0">,i.length-</span><span class="s3">2</span><span class="s0">)}</span><span class="s2">)`</span><span class="s0">},pe=</span><span class="s3">2e4</span><span class="s0">;</span><span class="s1">function </span><span class="s0">me(t){</span><span class="s1">let </span><span class="s0">e=</span><span class="s3">0</span><span class="s0">;</span><span class="s1">let </span><span class="s0">n=t.next(e);</span><span class="s1">for</span><span class="s0">(;!n.done&amp;&amp;e&lt;pe;)e+=</span><span class="s3">50</span><span class="s0">,n=t.next(e);</span><span class="s1">return </span><span class="s0">e&gt;=pe?</span><span class="s3">1</span><span class="s0">/</span><span class="s3">0</span><span class="s0">:e}</span><span class="s1">function </span><span class="s0">fe(t,e=</span><span class="s3">100</span><span class="s0">,n){</span><span class="s1">const </span><span class="s0">i=n({...t,keyframes:[</span><span class="s3">0</span><span class="s0">,e]}),s=Math.min(me(i),pe);</span><span class="s1">return</span><span class="s0">{type:</span><span class="s2">&quot;keyframes&quot;</span><span class="s0">,ease:t=&gt;i.next(s*t).value/e,duration:j(s)}}</span><span class="s1">function </span><span class="s0">ge(t,e,n){</span><span class="s1">const </span><span class="s0">i=Math.max(e-</span><span class="s3">5</span><span class="s0">,</span><span class="s3">0</span><span class="s0">);</span><span class="s1">return </span><span class="s0">B(n-t(i),e-i)}</span><span class="s1">const </span><span class="s0">ye=</span><span class="s3">100</span><span class="s0">,ve=</span><span class="s3">10</span><span class="s0">,xe=</span><span class="s3">1</span><span class="s0">,we=</span><span class="s3">0</span><span class="s0">,Te=</span><span class="s3">800</span><span class="s0">,Pe=</span><span class="s3">.3</span><span class="s0">,be=</span><span class="s3">.3</span><span class="s0">,Se={granular:</span><span class="s3">.01</span><span class="s0">,</span><span class="s1">default</span><span class="s0">:</span><span class="s3">2</span><span class="s0">},Ee={granular:</span><span class="s3">.005</span><span class="s0">,</span><span class="s1">default</span><span class="s0">:</span><span class="s3">.5</span><span class="s0">},Ae=</span><span class="s3">.01</span><span class="s0">,Me=</span><span class="s3">10</span><span class="s0">,Ce=</span><span class="s3">.05</span><span class="s0">,Ve=</span><span class="s3">1</span><span class="s0">,De=</span><span class="s3">.001</span><span class="s0">;</span><span class="s1">function </span><span class="s0">Re({duration:t=Te,bounce:e=Pe,velocity:n=we,mass:i=xe}){</span><span class="s1">let </span><span class="s0">s,o,r=</span><span class="s3">1</span><span class="s0">-e;r=P(Ce,Ve,r),t=P(Ae,Me,j(t)),r&lt;</span><span class="s3">1</span><span class="s0">?(s=e=&gt;{</span><span class="s1">const </span><span class="s0">i=e*r,s=i*t,o=i-n,a=Le(e,r),l=Math.exp(-s);</span><span class="s1">return </span><span class="s0">De-o/a*l},o=e=&gt;{</span><span class="s1">const </span><span class="s0">i=e*r*t,o=i*n+n,a=Math.pow(r,</span><span class="s3">2</span><span class="s0">)*Math.pow(e,</span><span class="s3">2</span><span class="s0">)*t,l=Math.exp(-i),u=Le(Math.pow(e,</span><span class="s3">2</span><span class="s0">),r);</span><span class="s1">return</span><span class="s0">(-s(e)+De&gt;</span><span class="s3">0</span><span class="s0">?-</span><span class="s3">1</span><span class="s0">:</span><span class="s3">1</span><span class="s0">)*((o-a)*l)/u}):(s=e=&gt;Math.exp(-e*t)*((e-n)*t+</span><span class="s3">1</span><span class="s0">)-</span><span class="s3">.001</span><span class="s0">,o=e=&gt;Math.exp(-e*t)*(t*t*(n-e)));</span><span class="s1">const </span><span class="s0">a=</span><span class="s1">function</span><span class="s0">(t,e,n){</span><span class="s1">let </span><span class="s0">i=n;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">n=</span><span class="s3">1</span><span class="s0">;n&lt;ke;n++)i-=t(i)/e(i);</span><span class="s1">return </span><span class="s0">i}(s,o,</span><span class="s3">5</span><span class="s0">/t);</span><span class="s1">if</span><span class="s0">(t=O(t),isNaN(a))</span><span class="s1">return</span><span class="s0">{stiffness:ye,damping:ve,duration:t};{</span><span class="s1">const </span><span class="s0">e=Math.pow(a,</span><span class="s3">2</span><span class="s0">)*i;</span><span class="s1">return</span><span class="s0">{stiffness:e,damping:</span><span class="s3">2</span><span class="s0">*r*Math.sqrt(i*e),duration:t}}}</span><span class="s1">const </span><span class="s0">ke=</span><span class="s3">12</span><span class="s0">;</span><span class="s1">function </span><span class="s0">Le(t,e){</span><span class="s1">return </span><span class="s0">t*Math.sqrt(</span><span class="s3">1</span><span class="s0">-e*e)}</span><span class="s1">const </span><span class="s0">Oe=[</span><span class="s2">&quot;duration&quot;</span><span class="s0">,</span><span class="s2">&quot;bounce&quot;</span><span class="s0">],je=[</span><span class="s2">&quot;stiffness&quot;</span><span class="s0">,</span><span class="s2">&quot;damping&quot;</span><span class="s0">,</span><span class="s2">&quot;mass&quot;</span><span class="s0">];</span><span class="s1">function </span><span class="s0">Be(t,e){</span><span class="s1">return </span><span class="s0">e.some(e=&gt;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==t[e])}</span><span class="s1">function </span><span class="s0">Ie(t=be,e=Pe){</span><span class="s1">const </span><span class="s0">n=</span><span class="s2">&quot;object&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">t?{visualDuration:t,keyframes:[</span><span class="s3">0</span><span class="s0">,</span><span class="s3">1</span><span class="s0">],bounce:e}:t;</span><span class="s1">let</span><span class="s0">{restSpeed:i,restDelta:s}=n;</span><span class="s1">const </span><span class="s0">o=n.keyframes[</span><span class="s3">0</span><span class="s0">],r=n.keyframes[n.keyframes.length-</span><span class="s3">1</span><span class="s0">],a={done:!</span><span class="s3">1</span><span class="s0">,value:o},{stiffness:l,damping:u,mass:c,duration:h,velocity:d,isResolvedFromDuration:p}=</span><span class="s1">function</span><span class="s0">(t){</span><span class="s1">let </span><span class="s0">e={velocity:we,stiffness:ye,damping:ve,mass:xe,isResolvedFromDuration:!</span><span class="s3">1</span><span class="s0">,...t};</span><span class="s1">if</span><span class="s0">(!Be(t,je)&amp;&amp;Be(t,Oe))</span><span class="s1">if</span><span class="s0">(t.visualDuration){</span><span class="s1">const </span><span class="s0">n=t.visualDuration,i=</span><span class="s3">2</span><span class="s0">*Math.PI/(</span><span class="s3">1.2</span><span class="s0">*n),s=i*i,o=</span><span class="s3">2</span><span class="s0">*P(</span><span class="s3">.05</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">1</span><span class="s0">-(t.bounce||</span><span class="s3">0</span><span class="s0">))*Math.sqrt(s);e={...e,mass:xe,stiffness:s,damping:o}}</span><span class="s1">else</span><span class="s0">{</span><span class="s1">const </span><span class="s0">n=Re(t);e={...e,...n,mass:xe},e.isResolvedFromDuration=!</span><span class="s3">0</span><span class="s0">}</span><span class="s1">return </span><span class="s0">e}({...n,velocity:-j(n.velocity||</span><span class="s3">0</span><span class="s0">)}),m=d||</span><span class="s3">0</span><span class="s0">,f=u/(</span><span class="s3">2</span><span class="s0">*Math.sqrt(l*c)),g=r-o,y=j(Math.sqrt(l/c)),v=Math.abs(g)&lt;</span><span class="s3">5</span><span class="s0">;</span><span class="s1">let </span><span class="s0">x;</span><span class="s1">if</span><span class="s0">(i||(i=v?Se.granular:Se.default),s||(s=v?Ee.granular:Ee.default),f&lt;</span><span class="s3">1</span><span class="s0">){</span><span class="s1">const </span><span class="s0">t=Le(y,f);x=e=&gt;{</span><span class="s1">const </span><span class="s0">n=Math.exp(-f*y*e);</span><span class="s1">return </span><span class="s0">r-n*((m+f*y*g)/t*Math.sin(t*e)+g*Math.cos(t*e))}}</span><span class="s1">else if</span><span class="s0">(</span><span class="s3">1</span><span class="s0">===f)x=t=&gt;r-Math.exp(-y*t)*(g+(m+y*g)*t);</span><span class="s1">else</span><span class="s0">{</span><span class="s1">const </span><span class="s0">t=y*Math.sqrt(f*f-</span><span class="s3">1</span><span class="s0">);x=e=&gt;{</span><span class="s1">const </span><span class="s0">n=Math.exp(-f*y*e),i=Math.min(t*e,</span><span class="s3">300</span><span class="s0">);</span><span class="s1">return </span><span class="s0">r-n*((m+f*y*g)*Math.sinh(i)+t*g*Math.cosh(i))/t}}</span><span class="s1">const </span><span class="s0">w={calculatedDuration:p&amp;&amp;h||</span><span class="s1">null</span><span class="s0">,next:t=&gt;{</span><span class="s1">const </span><span class="s0">e=x(t);</span><span class="s1">if</span><span class="s0">(p)a.done=t&gt;=h;</span><span class="s1">else</span><span class="s0">{</span><span class="s1">let </span><span class="s0">n=</span><span class="s3">0</span><span class="s0">===t?m:</span><span class="s3">0</span><span class="s0">;f&lt;</span><span class="s3">1</span><span class="s0">&amp;&amp;(n=</span><span class="s3">0</span><span class="s0">===t?O(m):ge(x,t,e));</span><span class="s1">const </span><span class="s0">o=Math.abs(n)&lt;=i,l=Math.abs(r-e)&lt;=s;a.done=o&amp;&amp;l}</span><span class="s1">return </span><span class="s0">a.value=a.done?r:e,a},toString:()=&gt;{</span><span class="s1">const </span><span class="s0">t=Math.min(me(w),pe),e=de(e=&gt;w.next(t*e).value,t,</span><span class="s3">30</span><span class="s0">);</span><span class="s1">return </span><span class="s0">t+</span><span class="s2">&quot;ms &quot;</span><span class="s0">+e},toTransition:()=&gt;{}};</span><span class="s1">return </span><span class="s0">w}</span><span class="s1">function </span><span class="s0">Fe({keyframes:t,velocity:e=</span><span class="s3">0</span><span class="s0">,power:n=</span><span class="s3">.8</span><span class="s0">,timeConstant:i=</span><span class="s3">325</span><span class="s0">,bounceDamping:s=</span><span class="s3">10</span><span class="s0">,bounceStiffness:o=</span><span class="s3">500</span><span class="s0">,modifyTarget:r,min:a,max:l,restDelta:u=</span><span class="s3">.5</span><span class="s0">,restSpeed:c}){</span><span class="s1">const </span><span class="s0">h=t[</span><span class="s3">0</span><span class="s0">],d={done:!</span><span class="s3">1</span><span class="s0">,value:h},p=t=&gt;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===a?l:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===l||Math.abs(a-t)&lt;Math.abs(l-t)?a:l;</span><span class="s1">let </span><span class="s0">m=n*e;</span><span class="s1">const </span><span class="s0">f=h+m,g=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===r?f:r(f);g!==f&amp;&amp;(m=g-h);</span><span class="s1">const </span><span class="s0">y=t=&gt;-m*Math.exp(-t/i),v=t=&gt;g+y(t),x=t=&gt;{</span><span class="s1">const </span><span class="s0">e=y(t),n=v(t);d.done=Math.abs(e)&lt;=u,d.value=d.done?g:n};</span><span class="s1">let </span><span class="s0">w,T;</span><span class="s1">const </span><span class="s0">P=t=&gt;{</span><span class="s1">var </span><span class="s0">e;(e=d.value,</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==a&amp;&amp;e&lt;a||</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==l&amp;&amp;e&gt;l)&amp;&amp;(w=t,T=Ie({keyframes:[d.value,p(d.value)],velocity:ge(v,t,d.value),damping:s,stiffness:o,restDelta:u,restSpeed:c}))};</span><span class="s1">return </span><span class="s0">P(</span><span class="s3">0</span><span class="s0">),{calculatedDuration:</span><span class="s1">null</span><span class="s0">,next:t=&gt;{</span><span class="s1">let </span><span class="s0">e=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">return </span><span class="s0">T||</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==w||(e=!</span><span class="s3">0</span><span class="s0">,x(t),P(t)),</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==w&amp;&amp;t&gt;=w?T.next(t-w):(!e&amp;&amp;x(t),d)}}}</span><span class="s1">function </span><span class="s0">We(t,e,{clamp:n=!</span><span class="s3">0</span><span class="s0">,ease:i,mixer:s}={}){</span><span class="s1">const </span><span class="s0">o=t.length;</span><span class="s1">if</span><span class="s0">(e.length,</span><span class="s3">1</span><span class="s0">===o)</span><span class="s1">return</span><span class="s0">()=&gt;e[</span><span class="s3">0</span><span class="s0">];</span><span class="s1">if</span><span class="s0">(</span><span class="s3">2</span><span class="s0">===o&amp;&amp;e[</span><span class="s3">0</span><span class="s0">]===e[</span><span class="s3">1</span><span class="s0">])</span><span class="s1">return</span><span class="s0">()=&gt;e[</span><span class="s3">1</span><span class="s0">];</span><span class="s1">const </span><span class="s0">r=t[</span><span class="s3">0</span><span class="s0">]===t[</span><span class="s3">1</span><span class="s0">];t[</span><span class="s3">0</span><span class="s0">]&gt;t[o-</span><span class="s3">1</span><span class="s0">]&amp;&amp;(t=[...t].reverse(),e=[...e].reverse());</span><span class="s1">const </span><span class="s0">a=</span><span class="s1">function</span><span class="s0">(t,e,n){</span><span class="s1">const </span><span class="s0">i=[],s=n||S.mix||ce,o=t.length-</span><span class="s3">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">n=</span><span class="s3">0</span><span class="s0">;n&lt;o;n++){</span><span class="s1">let </span><span class="s0">o=s(t[n],t[n+</span><span class="s3">1</span><span class="s0">]);</span><span class="s1">if</span><span class="s0">(e){</span><span class="s1">const </span><span class="s0">t=Array.isArray(e)?e[n]||V:e;o=R(t,o)}i.push(o)}</span><span class="s1">return </span><span class="s0">i}(e,i,s),l=a.length,u=n=&gt;{</span><span class="s1">if</span><span class="s0">(r&amp;&amp;n&lt;t[</span><span class="s3">0</span><span class="s0">])</span><span class="s1">return </span><span class="s0">e[</span><span class="s3">0</span><span class="s0">];</span><span class="s1">let </span><span class="s0">i=</span><span class="s3">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(l&gt;</span><span class="s3">1</span><span class="s0">)</span><span class="s1">for</span><span class="s0">(;i&lt;t.length-</span><span class="s3">2</span><span class="s0">&amp;&amp;!(n&lt;t[i+</span><span class="s3">1</span><span class="s0">]);i++);</span><span class="s1">const </span><span class="s0">s=k(t[i],t[i+</span><span class="s3">1</span><span class="s0">],n);</span><span class="s1">return </span><span class="s0">a[i](s)};</span><span class="s1">return </span><span class="s0">n?e=&gt;u(P(t[</span><span class="s3">0</span><span class="s0">],t[o-</span><span class="s3">1</span><span class="s0">],e)):u}</span><span class="s1">function </span><span class="s0">Ue(t,e){</span><span class="s1">const </span><span class="s0">n=t[t.length-</span><span class="s3">1</span><span class="s0">];</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">i=</span><span class="s3">1</span><span class="s0">;i&lt;=e;i++){</span><span class="s1">const </span><span class="s0">s=k(</span><span class="s3">0</span><span class="s0">,e,i);t.push(Jt(n,</span><span class="s3">1</span><span class="s0">,s))}}</span><span class="s1">function </span><span class="s0">Ne(t){</span><span class="s1">const </span><span class="s0">e=[</span><span class="s3">0</span><span class="s0">];</span><span class="s1">return </span><span class="s0">Ue(e,t.length-</span><span class="s3">1</span><span class="s0">),e}</span><span class="s1">function </span><span class="s0">$e(t,e){</span><span class="s1">return </span><span class="s0">t.map(t=&gt;t*e)}</span><span class="s1">function </span><span class="s0">ze(t,e){</span><span class="s1">return </span><span class="s0">t.map(()=&gt;e||J).splice(</span><span class="s3">0</span><span class="s0">,t.length-</span><span class="s3">1</span><span class="s0">)}</span><span class="s1">function </span><span class="s0">Xe({duration:t=</span><span class="s3">300</span><span class="s0">,keyframes:e,times:n,ease:i=</span><span class="s2">&quot;easeInOut&quot;</span><span class="s0">}){</span><span class="s1">const </span><span class="s0">s=Q(i)?i.map(it):it(i),o={done:!</span><span class="s3">1</span><span class="s0">,value:e[</span><span class="s3">0</span><span class="s0">]},r=We($e(n&amp;&amp;n.length===e.length?n:Ne(e),t),e,{ease:Array.isArray(s)?s:ze(e,s)});</span><span class="s1">return</span><span class="s0">{calculatedDuration:t,next:e=&gt;(o.value=r(e),o.done=e&gt;=t,o)}}Ie.applyToOptions=t=&gt;{</span><span class="s1">const </span><span class="s0">e=fe(t,</span><span class="s3">100</span><span class="s0">,Ie);</span><span class="s1">return </span><span class="s0">t.ease=e.ease,t.duration=O(e.duration),t.type=</span><span class="s2">&quot;keyframes&quot;</span><span class="s0">,t};</span><span class="s1">const </span><span class="s0">He=t=&gt;</span><span class="s1">null</span><span class="s0">!==t;</span><span class="s1">function </span><span class="s0">Ye(t,{repeat:e,repeatType:n=</span><span class="s2">&quot;loop&quot;</span><span class="s0">},i,s=</span><span class="s3">1</span><span class="s0">){</span><span class="s1">const </span><span class="s0">o=t.filter(He),r=s&lt;</span><span class="s3">0</span><span class="s0">||e&amp;&amp;</span><span class="s2">&quot;loop&quot;</span><span class="s0">!==n&amp;&amp;e%</span><span class="s3">2</span><span class="s0">==</span><span class="s3">1</span><span class="s0">?</span><span class="s3">0</span><span class="s0">:o.length-</span><span class="s3">1</span><span class="s0">;</span><span class="s1">return </span><span class="s0">r&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==i?i:o[r]}</span><span class="s1">const </span><span class="s0">Ke={decay:Fe,inertia:Fe,tween:Xe,keyframes:Xe,spring:Ie};</span><span class="s1">function </span><span class="s0">Ge(t){</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t.type&amp;&amp;(t.type=Ke[t.type])}</span><span class="s1">class </span><span class="s0">_e{constructor(){</span><span class="s1">this</span><span class="s0">.updateFinished()}get finished(){</span><span class="s1">return this</span><span class="s0">._finished}updateFinished(){</span><span class="s1">this</span><span class="s0">._finished=</span><span class="s1">new </span><span class="s0">Promise(t=&gt;{</span><span class="s1">this</span><span class="s0">.resolve=t})}notifyFinished(){</span><span class="s1">this</span><span class="s0">.resolve()}then(t,e){</span><span class="s1">return this</span><span class="s0">.finished.then(t,e)}}</span><span class="s1">const </span><span class="s0">Ze=t=&gt;t/</span><span class="s3">100</span><span class="s0">;</span><span class="s1">class </span><span class="s0">qe </span><span class="s1">extends </span><span class="s0">_e{constructor(t){</span><span class="s1">super</span><span class="s0">(),</span><span class="s1">this</span><span class="s0">.state=</span><span class="s2">&quot;idle&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.startTime=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.isStopped=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.currentTime=</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.holdTime=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.playbackSpeed=</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.stop=()=&gt;{</span><span class="s1">const</span><span class="s0">{motionValue:t}=</span><span class="s1">this</span><span class="s0">.options;t&amp;&amp;t.updatedAt!==pt.now()&amp;&amp;</span><span class="s1">this</span><span class="s0">.tick(pt.now()),</span><span class="s1">this</span><span class="s0">.isStopped=!</span><span class="s3">0</span><span class="s0">,</span><span class="s2">&quot;idle&quot;</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.state&amp;&amp;(</span><span class="s1">this</span><span class="s0">.teardown(),</span><span class="s1">this</span><span class="s0">.options.onStop?.())},mt.mainThread++,</span><span class="s1">this</span><span class="s0">.options=t,</span><span class="s1">this</span><span class="s0">.initAnimation(),</span><span class="s1">this</span><span class="s0">.play(),!</span><span class="s3">1</span><span class="s0">===t.autoplay&amp;&amp;</span><span class="s1">this</span><span class="s0">.pause()}initAnimation(){</span><span class="s1">const</span><span class="s0">{options:t}=</span><span class="s1">this</span><span class="s0">;Ge(t);</span><span class="s1">const</span><span class="s0">{type:e=Xe,repeat:n=</span><span class="s3">0</span><span class="s0">,repeatDelay:i=</span><span class="s3">0</span><span class="s0">,repeatType:s,velocity:o=</span><span class="s3">0</span><span class="s0">}=t;</span><span class="s1">let</span><span class="s0">{keyframes:r}=t;</span><span class="s1">const </span><span class="s0">a=e||Xe;a!==Xe&amp;&amp;</span><span class="s2">&quot;number&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">r[</span><span class="s3">0</span><span class="s0">]&amp;&amp;(</span><span class="s1">this</span><span class="s0">.mixKeyframes=R(Ze,ce(r[</span><span class="s3">0</span><span class="s0">],r[</span><span class="s3">1</span><span class="s0">])),r=[</span><span class="s3">0</span><span class="s0">,</span><span class="s3">100</span><span class="s0">]);</span><span class="s1">const </span><span class="s0">l=a({...t,keyframes:r});</span><span class="s2">&quot;mirror&quot;</span><span class="s0">===s&amp;&amp;(</span><span class="s1">this</span><span class="s0">.mirroredGenerator=a({...t,keyframes:[...r].reverse(),velocity:-o})),</span><span class="s1">null</span><span class="s0">===l.calculatedDuration&amp;&amp;(l.calculatedDuration=me(l));</span><span class="s1">const</span><span class="s0">{calculatedDuration:u}=l;</span><span class="s1">this</span><span class="s0">.calculatedDuration=u,</span><span class="s1">this</span><span class="s0">.resolvedDuration=u+i,</span><span class="s1">this</span><span class="s0">.totalDuration=</span><span class="s1">this</span><span class="s0">.resolvedDuration*(n+</span><span class="s3">1</span><span class="s0">)-i,</span><span class="s1">this</span><span class="s0">.generator=l}updateTime(t){</span><span class="s1">const </span><span class="s0">e=Math.round(t-</span><span class="s1">this</span><span class="s0">.startTime)*</span><span class="s1">this</span><span class="s0">.playbackSpeed;</span><span class="s1">null</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.holdTime?</span><span class="s1">this</span><span class="s0">.currentTime=</span><span class="s1">this</span><span class="s0">.holdTime:</span><span class="s1">this</span><span class="s0">.currentTime=e}tick(t,e=!</span><span class="s3">1</span><span class="s0">){</span><span class="s1">const</span><span class="s0">{generator:n,totalDuration:i,mixKeyframes:s,mirroredGenerator:o,resolvedDuration:r,calculatedDuration:a}=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.startTime)</span><span class="s1">return </span><span class="s0">n.next(</span><span class="s3">0</span><span class="s0">);</span><span class="s1">const</span><span class="s0">{delay:l=</span><span class="s3">0</span><span class="s0">,keyframes:u,repeat:c,repeatType:h,repeatDelay:d,type:p,onUpdate:m,finalKeyframe:f}=</span><span class="s1">this</span><span class="s0">.options;</span><span class="s1">this</span><span class="s0">.speed&gt;</span><span class="s3">0</span><span class="s0">?</span><span class="s1">this</span><span class="s0">.startTime=Math.min(</span><span class="s1">this</span><span class="s0">.startTime,t):</span><span class="s1">this</span><span class="s0">.speed&lt;</span><span class="s3">0</span><span class="s0">&amp;&amp;(</span><span class="s1">this</span><span class="s0">.startTime=Math.min(t-i/</span><span class="s1">this</span><span class="s0">.speed,</span><span class="s1">this</span><span class="s0">.startTime)),e?</span><span class="s1">this</span><span class="s0">.currentTime=t:</span><span class="s1">this</span><span class="s0">.updateTime(t);</span><span class="s1">const </span><span class="s0">g=</span><span class="s1">this</span><span class="s0">.currentTime-l*(</span><span class="s1">this</span><span class="s0">.playbackSpeed&gt;=</span><span class="s3">0</span><span class="s0">?</span><span class="s3">1</span><span class="s0">:-</span><span class="s3">1</span><span class="s0">),y=</span><span class="s1">this</span><span class="s0">.playbackSpeed&gt;=</span><span class="s3">0</span><span class="s0">?g&lt;</span><span class="s3">0</span><span class="s0">:g&gt;i;</span><span class="s1">this</span><span class="s0">.currentTime=Math.max(g,</span><span class="s3">0</span><span class="s0">),</span><span class="s2">&quot;finished&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state&amp;&amp;</span><span class="s1">null</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.holdTime&amp;&amp;(</span><span class="s1">this</span><span class="s0">.currentTime=i);</span><span class="s1">let </span><span class="s0">v=</span><span class="s1">this</span><span class="s0">.currentTime,x=n;</span><span class="s1">if</span><span class="s0">(c){</span><span class="s1">const </span><span class="s0">t=Math.min(</span><span class="s1">this</span><span class="s0">.currentTime,i)/r;</span><span class="s1">let </span><span class="s0">e=Math.floor(t),n=t%</span><span class="s3">1</span><span class="s0">;!n&amp;&amp;t&gt;=</span><span class="s3">1</span><span class="s0">&amp;&amp;(n=</span><span class="s3">1</span><span class="s0">),</span><span class="s3">1</span><span class="s0">===n&amp;&amp;e--,e=Math.min(e,c+</span><span class="s3">1</span><span class="s0">);Boolean(e%</span><span class="s3">2</span><span class="s0">)&amp;&amp;(</span><span class="s2">&quot;reverse&quot;</span><span class="s0">===h?(n=</span><span class="s3">1</span><span class="s0">-n,d&amp;&amp;(n-=d/r)):</span><span class="s2">&quot;mirror&quot;</span><span class="s0">===h&amp;&amp;(x=o)),v=P(</span><span class="s3">0</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,n)*r}</span><span class="s1">const </span><span class="s0">w=y?{done:!</span><span class="s3">1</span><span class="s0">,value:u[</span><span class="s3">0</span><span class="s0">]}:x.next(v);s&amp;&amp;(w.value=s(w.value));</span><span class="s1">let</span><span class="s0">{done:T}=w;y||</span><span class="s1">null</span><span class="s0">===a||(T=</span><span class="s1">this</span><span class="s0">.playbackSpeed&gt;=</span><span class="s3">0</span><span class="s0">?</span><span class="s1">this</span><span class="s0">.currentTime&gt;=i:</span><span class="s1">this</span><span class="s0">.currentTime&lt;=</span><span class="s3">0</span><span class="s0">);</span><span class="s1">const </span><span class="s0">b=</span><span class="s1">null</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.holdTime&amp;&amp;(</span><span class="s2">&quot;finished&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state||</span><span class="s2">&quot;running&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state&amp;&amp;T);</span><span class="s1">return </span><span class="s0">b&amp;&amp;p!==Fe&amp;&amp;(w.value=Ye(u,</span><span class="s1">this</span><span class="s0">.options,f,</span><span class="s1">this</span><span class="s0">.speed)),m&amp;&amp;m(w.value),b&amp;&amp;</span><span class="s1">this</span><span class="s0">.finish(),w}then(t,e){</span><span class="s1">return this</span><span class="s0">.finished.then(t,e)}get duration(){</span><span class="s1">return </span><span class="s0">j(</span><span class="s1">this</span><span class="s0">.calculatedDuration)}get iterationDuration(){</span><span class="s1">const</span><span class="s0">{delay:t=</span><span class="s3">0</span><span class="s0">}=</span><span class="s1">this</span><span class="s0">.options||{};</span><span class="s1">return this</span><span class="s0">.duration+j(t)}get time(){</span><span class="s1">return </span><span class="s0">j(</span><span class="s1">this</span><span class="s0">.currentTime)}set time(t){t=O(t),</span><span class="s1">this</span><span class="s0">.currentTime=t,</span><span class="s1">null</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.startTime||</span><span class="s1">null</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.holdTime||</span><span class="s3">0</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.playbackSpeed?</span><span class="s1">this</span><span class="s0">.holdTime=t:</span><span class="s1">this</span><span class="s0">.driver&amp;&amp;(</span><span class="s1">this</span><span class="s0">.startTime=</span><span class="s1">this</span><span class="s0">.driver.now()-t/</span><span class="s1">this</span><span class="s0">.playbackSpeed),</span><span class="s1">this</span><span class="s0">.driver?.start(!</span><span class="s3">1</span><span class="s0">)}get speed(){</span><span class="s1">return this</span><span class="s0">.playbackSpeed}set speed(t){</span><span class="s1">this</span><span class="s0">.updateTime(pt.now());</span><span class="s1">const </span><span class="s0">e=</span><span class="s1">this</span><span class="s0">.playbackSpeed!==t;</span><span class="s1">this</span><span class="s0">.playbackSpeed=t,e&amp;&amp;(</span><span class="s1">this</span><span class="s0">.time=j(</span><span class="s1">this</span><span class="s0">.currentTime))}play(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isStopped)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">const</span><span class="s0">{driver:t=he,startTime:e}=</span><span class="s1">this</span><span class="s0">.options;</span><span class="s1">this</span><span class="s0">.driver||(</span><span class="s1">this</span><span class="s0">.driver=t(t=&gt;</span><span class="s1">this</span><span class="s0">.tick(t))),</span><span class="s1">this</span><span class="s0">.options.onPlay?.();</span><span class="s1">const </span><span class="s0">n=</span><span class="s1">this</span><span class="s0">.driver.now();</span><span class="s2">&quot;finished&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state?(</span><span class="s1">this</span><span class="s0">.updateFinished(),</span><span class="s1">this</span><span class="s0">.startTime=n):</span><span class="s1">null</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.holdTime?</span><span class="s1">this</span><span class="s0">.startTime=n-</span><span class="s1">this</span><span class="s0">.holdTime:</span><span class="s1">this</span><span class="s0">.startTime||(</span><span class="s1">this</span><span class="s0">.startTime=e??n),</span><span class="s2">&quot;finished&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state&amp;&amp;</span><span class="s1">this</span><span class="s0">.speed&lt;</span><span class="s3">0</span><span class="s0">&amp;&amp;(</span><span class="s1">this</span><span class="s0">.startTime+=</span><span class="s1">this</span><span class="s0">.calculatedDuration),</span><span class="s1">this</span><span class="s0">.holdTime=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.state=</span><span class="s2">&quot;running&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.driver.start()}pause(){</span><span class="s1">this</span><span class="s0">.state=</span><span class="s2">&quot;paused&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.updateTime(pt.now()),</span><span class="s1">this</span><span class="s0">.holdTime=</span><span class="s1">this</span><span class="s0">.currentTime}complete(){</span><span class="s2">&quot;running&quot;</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.state&amp;&amp;</span><span class="s1">this</span><span class="s0">.play(),</span><span class="s1">this</span><span class="s0">.state=</span><span class="s2">&quot;finished&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.holdTime=</span><span class="s1">null</span><span class="s0">}finish(){</span><span class="s1">this</span><span class="s0">.notifyFinished(),</span><span class="s1">this</span><span class="s0">.teardown(),</span><span class="s1">this</span><span class="s0">.state=</span><span class="s2">&quot;finished&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.options.onComplete?.()}cancel(){</span><span class="s1">this</span><span class="s0">.holdTime=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.startTime=</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.tick(</span><span class="s3">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.teardown(),</span><span class="s1">this</span><span class="s0">.options.onCancel?.()}teardown(){</span><span class="s1">this</span><span class="s0">.state=</span><span class="s2">&quot;idle&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.stopDriver(),</span><span class="s1">this</span><span class="s0">.startTime=</span><span class="s1">this</span><span class="s0">.holdTime=</span><span class="s1">null</span><span class="s0">,mt.mainThread--}stopDriver(){</span><span class="s1">this</span><span class="s0">.driver&amp;&amp;(</span><span class="s1">this</span><span class="s0">.driver.stop(),</span><span class="s1">this</span><span class="s0">.driver=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">)}sample(t){</span><span class="s1">return this</span><span class="s0">.startTime=</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.tick(t,!</span><span class="s3">0</span><span class="s0">)}attachTimeline(t){</span><span class="s1">return this</span><span class="s0">.options.allowFlatten&amp;&amp;(</span><span class="s1">this</span><span class="s0">.options.type=</span><span class="s2">&quot;keyframes&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.options.ease=</span><span class="s2">&quot;linear&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.initAnimation()),</span><span class="s1">this</span><span class="s0">.driver?.stop(),t.observe(</span><span class="s1">this</span><span class="s0">)}}</span><span class="s1">function </span><span class="s0">Je(t){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">e=</span><span class="s3">1</span><span class="s0">;e&lt;t.length;e++)t[e]??(t[e]=t[e-</span><span class="s3">1</span><span class="s0">])}</span><span class="s1">const </span><span class="s0">Qe=t=&gt;</span><span class="s3">180</span><span class="s0">*t/Math.PI,tn=t=&gt;{</span><span class="s1">const </span><span class="s0">e=Qe(Math.atan2(t[</span><span class="s3">1</span><span class="s0">],t[</span><span class="s3">0</span><span class="s0">]));</span><span class="s1">return </span><span class="s0">nn(e)},en={x:</span><span class="s3">4</span><span class="s0">,y:</span><span class="s3">5</span><span class="s0">,translateX:</span><span class="s3">4</span><span class="s0">,translateY:</span><span class="s3">5</span><span class="s0">,scaleX:</span><span class="s3">0</span><span class="s0">,scaleY:</span><span class="s3">3</span><span class="s0">,scale:t=&gt;(Math.abs(t[</span><span class="s3">0</span><span class="s0">])+Math.abs(t[</span><span class="s3">3</span><span class="s0">]))/</span><span class="s3">2</span><span class="s0">,rotate:tn,rotateZ:tn,skewX:t=&gt;Qe(Math.atan(t[</span><span class="s3">1</span><span class="s0">])),skewY:t=&gt;Qe(Math.atan(t[</span><span class="s3">2</span><span class="s0">])),skew:t=&gt;(Math.abs(t[</span><span class="s3">1</span><span class="s0">])+Math.abs(t[</span><span class="s3">2</span><span class="s0">]))/</span><span class="s3">2</span><span class="s0">},nn=t=&gt;((t%=</span><span class="s3">360</span><span class="s0">)&lt;</span><span class="s3">0</span><span class="s0">&amp;&amp;(t+=</span><span class="s3">360</span><span class="s0">),t),sn=t=&gt;Math.sqrt(t[</span><span class="s3">0</span><span class="s0">]*t[</span><span class="s3">0</span><span class="s0">]+t[</span><span class="s3">1</span><span class="s0">]*t[</span><span class="s3">1</span><span class="s0">]),on=t=&gt;Math.sqrt(t[</span><span class="s3">4</span><span class="s0">]*t[</span><span class="s3">4</span><span class="s0">]+t[</span><span class="s3">5</span><span class="s0">]*t[</span><span class="s3">5</span><span class="s0">]),rn={x:</span><span class="s3">12</span><span class="s0">,y:</span><span class="s3">13</span><span class="s0">,z:</span><span class="s3">14</span><span class="s0">,translateX:</span><span class="s3">12</span><span class="s0">,translateY:</span><span class="s3">13</span><span class="s0">,translateZ:</span><span class="s3">14</span><span class="s0">,scaleX:sn,scaleY:on,scale:t=&gt;(sn(t)+on(t))/</span><span class="s3">2</span><span class="s0">,rotateX:t=&gt;nn(Qe(Math.atan2(t[</span><span class="s3">6</span><span class="s0">],t[</span><span class="s3">5</span><span class="s0">]))),rotateY:t=&gt;nn(Qe(Math.atan2(-t[</span><span class="s3">2</span><span class="s0">],t[</span><span class="s3">0</span><span class="s0">]))),rotateZ:tn,rotate:tn,skewX:t=&gt;Qe(Math.atan(t[</span><span class="s3">4</span><span class="s0">])),skewY:t=&gt;Qe(Math.atan(t[</span><span class="s3">1</span><span class="s0">])),skew:t=&gt;(Math.abs(t[</span><span class="s3">1</span><span class="s0">])+Math.abs(t[</span><span class="s3">4</span><span class="s0">]))/</span><span class="s3">2</span><span class="s0">};</span><span class="s1">function </span><span class="s0">an(t){</span><span class="s1">return </span><span class="s0">t.includes(</span><span class="s2">&quot;scale&quot;</span><span class="s0">)?</span><span class="s3">1</span><span class="s0">:</span><span class="s3">0</span><span class="s0">}</span><span class="s1">function </span><span class="s0">ln(t,e){</span><span class="s1">if</span><span class="s0">(!t||</span><span class="s2">&quot;none&quot;</span><span class="s0">===t)</span><span class="s1">return </span><span class="s0">an(e);</span><span class="s1">const </span><span class="s0">n=t.match(</span><span class="s4">/^matrix3d\(([-\d.e\s,]+)\)$/u</span><span class="s0">);</span><span class="s1">let </span><span class="s0">i,s;</span><span class="s1">if</span><span class="s0">(n)i=rn,s=n;</span><span class="s1">else</span><span class="s0">{</span><span class="s1">const </span><span class="s0">e=t.match(</span><span class="s4">/^matrix\(([-\d.e\s,]+)\)$/u</span><span class="s0">);i=en,s=e}</span><span class="s1">if</span><span class="s0">(!s)</span><span class="s1">return </span><span class="s0">an(e);</span><span class="s1">const </span><span class="s0">o=i[e],r=s[</span><span class="s3">1</span><span class="s0">].split(</span><span class="s2">&quot;,&quot;</span><span class="s0">).map(cn);</span><span class="s1">return</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">o?o(r):r[o]}</span><span class="s1">const </span><span class="s0">un=(t,e)=&gt;{</span><span class="s1">const</span><span class="s0">{transform:n=</span><span class="s2">&quot;none&quot;</span><span class="s0">}=getComputedStyle(t);</span><span class="s1">return </span><span class="s0">ln(n,e)};</span><span class="s1">function </span><span class="s0">cn(t){</span><span class="s1">return </span><span class="s0">parseFloat(t.trim())}</span><span class="s1">const </span><span class="s0">hn=[</span><span class="s2">&quot;transformPerspective&quot;</span><span class="s0">,</span><span class="s2">&quot;x&quot;</span><span class="s0">,</span><span class="s2">&quot;y&quot;</span><span class="s0">,</span><span class="s2">&quot;z&quot;</span><span class="s0">,</span><span class="s2">&quot;translateX&quot;</span><span class="s0">,</span><span class="s2">&quot;translateY&quot;</span><span class="s0">,</span><span class="s2">&quot;translateZ&quot;</span><span class="s0">,</span><span class="s2">&quot;scale&quot;</span><span class="s0">,</span><span class="s2">&quot;scaleX&quot;</span><span class="s0">,</span><span class="s2">&quot;scaleY&quot;</span><span class="s0">,</span><span class="s2">&quot;rotate&quot;</span><span class="s0">,</span><span class="s2">&quot;rotateX&quot;</span><span class="s0">,</span><span class="s2">&quot;rotateY&quot;</span><span class="s0">,</span><span class="s2">&quot;rotateZ&quot;</span><span class="s0">,</span><span class="s2">&quot;skew&quot;</span><span class="s0">,</span><span class="s2">&quot;skewX&quot;</span><span class="s0">,</span><span class="s2">&quot;skewY&quot;</span><span class="s0">],dn=(()=&gt;</span><span class="s1">new </span><span class="s0">Set(hn))(),pn=t=&gt;t===wt||t===Ot,mn=</span><span class="s1">new </span><span class="s0">Set([</span><span class="s2">&quot;x&quot;</span><span class="s0">,</span><span class="s2">&quot;y&quot;</span><span class="s0">,</span><span class="s2">&quot;z&quot;</span><span class="s0">]),fn=hn.filter(t=&gt;!mn.has(t));</span><span class="s1">const </span><span class="s0">gn={width:({x:t},{paddingLeft:e=</span><span class="s2">&quot;0&quot;</span><span class="s0">,paddingRight:n=</span><span class="s2">&quot;0&quot;</span><span class="s0">})=&gt;t.max-t.min-parseFloat(e)-parseFloat(n),height:({y:t},{paddingTop:e=</span><span class="s2">&quot;0&quot;</span><span class="s0">,paddingBottom:n=</span><span class="s2">&quot;0&quot;</span><span class="s0">})=&gt;t.max-t.min-parseFloat(e)-parseFloat(n),top:(t,{top:e})=&gt;parseFloat(e),left:(t,{left:e})=&gt;parseFloat(e),bottom:({y:t},{top:e})=&gt;parseFloat(e)+(t.max-t.min),right:({x:t},{left:e})=&gt;parseFloat(e)+(t.max-t.min),x:(t,{transform:e})=&gt;ln(e,</span><span class="s2">&quot;x&quot;</span><span class="s0">),y:(t,{transform:e})=&gt;ln(e,</span><span class="s2">&quot;y&quot;</span><span class="s0">)};gn.translateX=gn.x,gn.translateY=gn.y;</span><span class="s1">const </span><span class="s0">yn=</span><span class="s1">new </span><span class="s0">Set;</span><span class="s1">let </span><span class="s0">vn=!</span><span class="s3">1</span><span class="s0">,xn=!</span><span class="s3">1</span><span class="s0">,wn=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">function </span><span class="s0">Tn(){</span><span class="s1">if</span><span class="s0">(xn){</span><span class="s1">const </span><span class="s0">t=Array.from(yn).filter(t=&gt;t.needsMeasurement),e=</span><span class="s1">new </span><span class="s0">Set(t.map(t=&gt;t.element)),n=</span><span class="s1">new </span><span class="s0">Map;e.forEach(t=&gt;{</span><span class="s1">const </span><span class="s0">e=</span><span class="s1">function</span><span class="s0">(t){</span><span class="s1">const </span><span class="s0">e=[];</span><span class="s1">return </span><span class="s0">fn.forEach(n=&gt;{</span><span class="s1">const </span><span class="s0">i=t.getValue(n);</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==i&amp;&amp;(e.push([n,i.get()]),i.set(n.startsWith(</span><span class="s2">&quot;scale&quot;</span><span class="s0">)?</span><span class="s3">1</span><span class="s0">:</span><span class="s3">0</span><span class="s0">))}),e}(t);e.length&amp;&amp;(n.set(t,e),t.render())}),t.forEach(t=&gt;t.measureInitialState()),e.forEach(t=&gt;{t.render();</span><span class="s1">const </span><span class="s0">e=n.get(t);e&amp;&amp;e.forEach(([e,n])=&gt;{t.getValue(e)?.set(n)})}),t.forEach(t=&gt;t.measureEndState()),t.forEach(t=&gt;{</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==t.suspendedScrollY&amp;&amp;window.scrollTo(</span><span class="s3">0</span><span class="s0">,t.suspendedScrollY)})}xn=!</span><span class="s3">1</span><span class="s0">,vn=!</span><span class="s3">1</span><span class="s0">,yn.forEach(t=&gt;t.complete(wn)),yn.clear()}</span><span class="s1">function </span><span class="s0">Pn(){yn.forEach(t=&gt;{t.readKeyframes(),t.needsMeasurement&amp;&amp;(xn=!</span><span class="s3">0</span><span class="s0">)})}</span><span class="s1">function </span><span class="s0">bn(){wn=!</span><span class="s3">0</span><span class="s0">,Pn(),Tn(),wn=!</span><span class="s3">1</span><span class="s0">}</span><span class="s1">class </span><span class="s0">Sn{constructor(t,e,n,i,s,o=!</span><span class="s3">1</span><span class="s0">){</span><span class="s1">this</span><span class="s0">.state=</span><span class="s2">&quot;pending&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.isAsync=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.needsMeasurement=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.unresolvedKeyframes=[...t],</span><span class="s1">this</span><span class="s0">.onComplete=e,</span><span class="s1">this</span><span class="s0">.name=n,</span><span class="s1">this</span><span class="s0">.motionValue=i,</span><span class="s1">this</span><span class="s0">.element=s,</span><span class="s1">this</span><span class="s0">.isAsync=o}scheduleResolve(){</span><span class="s1">this</span><span class="s0">.state=</span><span class="s2">&quot;scheduled&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.isAsync?(yn.add(</span><span class="s1">this</span><span class="s0">),vn||(vn=!</span><span class="s3">0</span><span class="s0">,at.read(Pn),at.resolveKeyframes(Tn))):(</span><span class="s1">this</span><span class="s0">.readKeyframes(),</span><span class="s1">this</span><span class="s0">.complete())}readKeyframes(){</span><span class="s1">const</span><span class="s0">{unresolvedKeyframes:t,name:e,element:n,motionValue:i}=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">===t[</span><span class="s3">0</span><span class="s0">]){</span><span class="s1">const </span><span class="s0">s=i?.get(),o=t[t.length-</span><span class="s3">1</span><span class="s0">];</span><span class="s1">if</span><span class="s0">(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==s)t[</span><span class="s3">0</span><span class="s0">]=s;</span><span class="s1">else if</span><span class="s0">(n&amp;&amp;e){</span><span class="s1">const </span><span class="s0">i=n.readValue(e,o);</span><span class="s1">null</span><span class="s0">!=i&amp;&amp;(t[</span><span class="s3">0</span><span class="s0">]=i)}</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===t[</span><span class="s3">0</span><span class="s0">]&amp;&amp;(t[</span><span class="s3">0</span><span class="s0">]=o),i&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===s&amp;&amp;i.set(t[</span><span class="s3">0</span><span class="s0">])}Je(t)}setFinalKeyframe(){}measureInitialState(){}renderEndStyles(){}measureEndState(){}complete(t=!</span><span class="s3">1</span><span class="s0">){</span><span class="s1">this</span><span class="s0">.state=</span><span class="s2">&quot;complete&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.onComplete(</span><span class="s1">this</span><span class="s0">.unresolvedKeyframes,</span><span class="s1">this</span><span class="s0">.finalKeyframe,t),yn.delete(</span><span class="s1">this</span><span class="s0">)}cancel(){</span><span class="s2">&quot;scheduled&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state&amp;&amp;(yn.delete(</span><span class="s1">this</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.state=</span><span class="s2">&quot;pending&quot;</span><span class="s0">)}resume(){</span><span class="s2">&quot;pending&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state&amp;&amp;</span><span class="s1">this</span><span class="s0">.scheduleResolve()}}</span><span class="s1">const </span><span class="s0">En=t=&gt;t.startsWith(</span><span class="s2">&quot;--&quot;</span><span class="s0">);</span><span class="s1">function </span><span class="s0">An(t,e,n){En(e)?t.style.setProperty(e,n):t.style[e]=n}</span><span class="s1">const </span><span class="s0">Mn=C(()=&gt;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==window.ScrollTimeline),Cn={};</span><span class="s1">function </span><span class="s0">Vn(t,e){</span><span class="s1">const </span><span class="s0">n=C(t);</span><span class="s1">return</span><span class="s0">()=&gt;Cn[e]??n()}</span><span class="s1">const </span><span class="s0">Dn=Vn(()=&gt;{</span><span class="s1">try</span><span class="s0">{document.createElement(</span><span class="s2">&quot;div&quot;</span><span class="s0">).animate({opacity:</span><span class="s3">0</span><span class="s0">},{easing:</span><span class="s2">&quot;linear(0, 1)&quot;</span><span class="s0">})}</span><span class="s1">catch</span><span class="s0">(t){</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">},</span><span class="s2">&quot;linearEasing&quot;</span><span class="s0">),Rn=([t,e,n,i])=&gt;</span><span class="s2">`cubic-bezier(</span><span class="s0">${t}</span><span class="s2">, </span><span class="s0">${e}</span><span class="s2">, </span><span class="s0">${n}</span><span class="s2">, </span><span class="s0">${i}</span><span class="s2">)`</span><span class="s0">,kn={linear:</span><span class="s2">&quot;linear&quot;</span><span class="s0">,ease:</span><span class="s2">&quot;ease&quot;</span><span class="s0">,easeIn:</span><span class="s2">&quot;ease-in&quot;</span><span class="s0">,easeOut:</span><span class="s2">&quot;ease-out&quot;</span><span class="s0">,easeInOut:</span><span class="s2">&quot;ease-in-out&quot;</span><span class="s0">,circIn:Rn([</span><span class="s3">0</span><span class="s0">,</span><span class="s3">.65</span><span class="s0">,</span><span class="s3">.55</span><span class="s0">,</span><span class="s3">1</span><span class="s0">]),circOut:Rn([</span><span class="s3">.55</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">.45</span><span class="s0">]),backIn:Rn([</span><span class="s3">.31</span><span class="s0">,</span><span class="s3">.01</span><span class="s0">,</span><span class="s3">.66</span><span class="s0">,-</span><span class="s3">.59</span><span class="s0">]),backOut:Rn([</span><span class="s3">.33</span><span class="s0">,</span><span class="s3">1.53</span><span class="s0">,</span><span class="s3">.69</span><span class="s0">,</span><span class="s3">.99</span><span class="s0">])};</span><span class="s1">function </span><span class="s0">Ln(t,e){</span><span class="s1">return </span><span class="s0">t?</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t?Dn()?de(t,e):</span><span class="s2">&quot;ease-out&quot;</span><span class="s0">:et(t)?Rn(t):Array.isArray(t)?t.map(t=&gt;Ln(t,e)||kn.easeOut):kn[t]:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">}</span><span class="s1">function </span><span class="s0">On(t,e,n,{delay:i=</span><span class="s3">0</span><span class="s0">,duration:s=</span><span class="s3">300</span><span class="s0">,repeat:o=</span><span class="s3">0</span><span class="s0">,repeatType:r=</span><span class="s2">&quot;loop&quot;</span><span class="s0">,ease:a=</span><span class="s2">&quot;easeOut&quot;</span><span class="s0">,times:l}={},u=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">){</span><span class="s1">const </span><span class="s0">c={[e]:n};l&amp;&amp;(c.offset=l);</span><span class="s1">const </span><span class="s0">h=Ln(a,s);Array.isArray(h)&amp;&amp;(c.easing=h),ot.value&amp;&amp;mt.waapi++;</span><span class="s1">const </span><span class="s0">d={delay:i,duration:s,easing:Array.isArray(h)?</span><span class="s2">&quot;linear&quot;</span><span class="s0">:h,fill:</span><span class="s2">&quot;both&quot;</span><span class="s0">,iterations:o+</span><span class="s3">1</span><span class="s0">,direction:</span><span class="s2">&quot;reverse&quot;</span><span class="s0">===r?</span><span class="s2">&quot;alternate&quot;</span><span class="s0">:</span><span class="s2">&quot;normal&quot;</span><span class="s0">};u&amp;&amp;(d.pseudoElement=u);</span><span class="s1">const </span><span class="s0">p=t.animate(c,d);</span><span class="s1">return </span><span class="s0">ot.value&amp;&amp;p.finished.finally(()=&gt;{mt.waapi--}),p}</span><span class="s1">function </span><span class="s0">jn(t){</span><span class="s1">return</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t&amp;&amp;</span><span class="s2">&quot;applyToOptions&quot;</span><span class="s1">in </span><span class="s0">t}</span><span class="s1">function </span><span class="s0">Bn({type:t,...e}){</span><span class="s1">return </span><span class="s0">jn(t)&amp;&amp;Dn()?t.applyToOptions(e):(e.duration??(e.duration=</span><span class="s3">300</span><span class="s0">),e.ease??(e.ease=</span><span class="s2">&quot;easeOut&quot;</span><span class="s0">),e)}</span><span class="s1">class </span><span class="s0">In </span><span class="s1">extends </span><span class="s0">_e{constructor(t){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">super</span><span class="s0">(),</span><span class="s1">this</span><span class="s0">.finishedTime=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.isStopped=!</span><span class="s3">1</span><span class="s0">,!t)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">const</span><span class="s0">{element:e,name:n,keyframes:i,pseudoElement:s,allowFlatten:o=!</span><span class="s3">1</span><span class="s0">,finalKeyframe:r,onComplete:a}=t;</span><span class="s1">this</span><span class="s0">.isPseudoElement=Boolean(s),</span><span class="s1">this</span><span class="s0">.allowFlatten=o,</span><span class="s1">this</span><span class="s0">.options=t,t.type;</span><span class="s1">const </span><span class="s0">l=Bn(t);</span><span class="s1">this</span><span class="s0">.animation=On(e,n,i,l,s),!</span><span class="s3">1</span><span class="s0">===l.autoplay&amp;&amp;</span><span class="s1">this</span><span class="s0">.animation.pause(),</span><span class="s1">this</span><span class="s0">.animation.onfinish=()=&gt;{</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.finishedTime=</span><span class="s1">this</span><span class="s0">.time,!s){</span><span class="s1">const </span><span class="s0">t=Ye(i,</span><span class="s1">this</span><span class="s0">.options,r,</span><span class="s1">this</span><span class="s0">.speed);</span><span class="s1">this</span><span class="s0">.updateMotionValue?</span><span class="s1">this</span><span class="s0">.updateMotionValue(t):An(e,n,t),</span><span class="s1">this</span><span class="s0">.animation.cancel()}a?.(),</span><span class="s1">this</span><span class="s0">.notifyFinished()}}play(){</span><span class="s1">this</span><span class="s0">.isStopped||(</span><span class="s1">this</span><span class="s0">.animation.play(),</span><span class="s2">&quot;finished&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.state&amp;&amp;</span><span class="s1">this</span><span class="s0">.updateFinished())}pause(){</span><span class="s1">this</span><span class="s0">.animation.pause()}complete(){</span><span class="s1">this</span><span class="s0">.animation.finish?.()}cancel(){</span><span class="s1">try</span><span class="s0">{</span><span class="s1">this</span><span class="s0">.animation.cancel()}</span><span class="s1">catch</span><span class="s0">(t){}}stop(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isStopped)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.isStopped=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">const</span><span class="s0">{state:t}=</span><span class="s1">this</span><span class="s0">;</span><span class="s2">&quot;idle&quot;</span><span class="s0">!==t&amp;&amp;</span><span class="s2">&quot;finished&quot;</span><span class="s0">!==t&amp;&amp;(</span><span class="s1">this</span><span class="s0">.updateMotionValue?</span><span class="s1">this</span><span class="s0">.updateMotionValue():</span><span class="s1">this</span><span class="s0">.commitStyles(),</span><span class="s1">this</span><span class="s0">.isPseudoElement||</span><span class="s1">this</span><span class="s0">.cancel())}commitStyles(){</span><span class="s1">this</span><span class="s0">.isPseudoElement||</span><span class="s1">this</span><span class="s0">.animation.commitStyles?.()}get duration(){</span><span class="s1">const </span><span class="s0">t=</span><span class="s1">this</span><span class="s0">.animation.effect?.getComputedTiming?.().duration||</span><span class="s3">0</span><span class="s0">;</span><span class="s1">return </span><span class="s0">j(Number(t))}get iterationDuration(){</span><span class="s1">const</span><span class="s0">{delay:t=</span><span class="s3">0</span><span class="s0">}=</span><span class="s1">this</span><span class="s0">.options||{};</span><span class="s1">return this</span><span class="s0">.duration+j(t)}get time(){</span><span class="s1">return </span><span class="s0">j(Number(</span><span class="s1">this</span><span class="s0">.animation.currentTime)||</span><span class="s3">0</span><span class="s0">)}set time(t){</span><span class="s1">this</span><span class="s0">.finishedTime=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.animation.currentTime=O(t)}get speed(){</span><span class="s1">return this</span><span class="s0">.animation.playbackRate}set speed(t){t&lt;</span><span class="s3">0</span><span class="s0">&amp;&amp;(</span><span class="s1">this</span><span class="s0">.finishedTime=</span><span class="s1">null</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.animation.playbackRate=t}get state(){</span><span class="s1">return null</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.finishedTime?</span><span class="s2">&quot;finished&quot;</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.animation.playState}get startTime(){</span><span class="s1">return </span><span class="s0">Number(</span><span class="s1">this</span><span class="s0">.animation.startTime)}set startTime(t){</span><span class="s1">this</span><span class="s0">.animation.startTime=t}attachTimeline({timeline:t,observe:e}){</span><span class="s1">return this</span><span class="s0">.allowFlatten&amp;&amp;</span><span class="s1">this</span><span class="s0">.animation.effect?.updateTiming({easing:</span><span class="s2">&quot;linear&quot;</span><span class="s0">}),</span><span class="s1">this</span><span class="s0">.animation.onfinish=</span><span class="s1">null</span><span class="s0">,t&amp;&amp;Mn()?(</span><span class="s1">this</span><span class="s0">.animation.timeline=t,V):e(</span><span class="s1">this</span><span class="s0">)}}</span><span class="s1">const </span><span class="s0">Fn={anticipate:Y,backInOut:H,circInOut:_};</span><span class="s1">function </span><span class="s0">Wn(t){</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t.ease&amp;&amp;t.ease </span><span class="s1">in </span><span class="s0">Fn&amp;&amp;(t.ease=Fn[t.ease])}</span><span class="s1">class </span><span class="s0">Un </span><span class="s1">extends </span><span class="s0">In{constructor(t){Wn(t),Ge(t),</span><span class="s1">super</span><span class="s0">(t),t.startTime&amp;&amp;(</span><span class="s1">this</span><span class="s0">.startTime=t.startTime),</span><span class="s1">this</span><span class="s0">.options=t}updateMotionValue(t){</span><span class="s1">const</span><span class="s0">{motionValue:e,onUpdate:n,onComplete:i,element:s,...o}=</span><span class="s1">this</span><span class="s0">.options;</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==t)</span><span class="s1">return void </span><span class="s0">e.set(t);</span><span class="s1">const </span><span class="s0">r=</span><span class="s1">new </span><span class="s0">qe({...o,autoplay:!</span><span class="s3">1</span><span class="s0">}),a=O(</span><span class="s1">this</span><span class="s0">.finishedTime??</span><span class="s1">this</span><span class="s0">.time);e.setWithVelocity(r.sample(a-</span><span class="s3">10</span><span class="s0">).value,r.sample(a).value,</span><span class="s3">10</span><span class="s0">),r.stop()}}</span><span class="s1">const </span><span class="s0">Nn=(t,e)=&gt;</span><span class="s2">&quot;zIndex&quot;</span><span class="s0">!==e&amp;&amp;(!(</span><span class="s2">&quot;number&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">t&amp;&amp;!Array.isArray(t))||!(</span><span class="s2">&quot;string&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">t||!Gt.test(t)&amp;&amp;</span><span class="s2">&quot;0&quot;</span><span class="s0">!==t||t.startsWith(</span><span class="s2">&quot;url(&quot;</span><span class="s0">)));</span><span class="s1">function </span><span class="s0">$n(t){t.duration=</span><span class="s3">0</span><span class="s0">,t.type=</span><span class="s2">&quot;keyframes&quot;</span><span class="s0">}</span><span class="s1">const </span><span class="s0">zn=</span><span class="s1">new </span><span class="s0">Set([</span><span class="s2">&quot;opacity&quot;</span><span class="s0">,</span><span class="s2">&quot;clipPath&quot;</span><span class="s0">,</span><span class="s2">&quot;filter&quot;</span><span class="s0">,</span><span class="s2">&quot;transform&quot;</span><span class="s0">]),Xn=C(()=&gt;Object.hasOwnProperty.call(Element.prototype,</span><span class="s2">&quot;animate&quot;</span><span class="s0">));</span><span class="s1">function </span><span class="s0">Hn(t){</span><span class="s1">const</span><span class="s0">{motionValue:e,name:n,repeatDelay:i,repeatType:s,damping:o,type:r}=t,a=e?.owner?.current;</span><span class="s1">if</span><span class="s0">(!(a </span><span class="s1">instanceof </span><span class="s0">HTMLElement))</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">const</span><span class="s0">{onUpdate:l,transformTemplate:u}=e.owner.getProps();</span><span class="s1">return </span><span class="s0">Xn()&amp;&amp;n&amp;&amp;zn.has(n)&amp;&amp;(</span><span class="s2">&quot;transform&quot;</span><span class="s0">!==n||!u)&amp;&amp;!l&amp;&amp;!i&amp;&amp;</span><span class="s2">&quot;mirror&quot;</span><span class="s0">!==s&amp;&amp;</span><span class="s3">0</span><span class="s0">!==o&amp;&amp;</span><span class="s2">&quot;inertia&quot;</span><span class="s0">!==r}</span><span class="s1">class </span><span class="s0">Yn </span><span class="s1">extends </span><span class="s0">_e{constructor({autoplay:t=!</span><span class="s3">0</span><span class="s0">,delay:e=</span><span class="s3">0</span><span class="s0">,type:n=</span><span class="s2">&quot;keyframes&quot;</span><span class="s0">,repeat:i=</span><span class="s3">0</span><span class="s0">,repeatDelay:s=</span><span class="s3">0</span><span class="s0">,repeatType:o=</span><span class="s2">&quot;loop&quot;</span><span class="s0">,keyframes:r,name:a,motionValue:l,element:u,...c}){</span><span class="s1">super</span><span class="s0">(),</span><span class="s1">this</span><span class="s0">.stop=()=&gt;{</span><span class="s1">this</span><span class="s0">._animation&amp;&amp;(</span><span class="s1">this</span><span class="s0">._animation.stop(),</span><span class="s1">this</span><span class="s0">.stopTimeline?.()),</span><span class="s1">this</span><span class="s0">.keyframeResolver?.cancel()},</span><span class="s1">this</span><span class="s0">.createdAt=pt.now();</span><span class="s1">const </span><span class="s0">h={autoplay:t,delay:e,type:n,repeat:i,repeatDelay:s,repeatType:o,name:a,motionValue:l,element:u,...c},d=u?.KeyframeResolver||Sn;</span><span class="s1">this</span><span class="s0">.keyframeResolver=</span><span class="s1">new </span><span class="s0">d(r,(t,e,n)=&gt;</span><span class="s1">this</span><span class="s0">.onKeyframesResolved(t,e,h,!n),a,l,u),</span><span class="s1">this</span><span class="s0">.keyframeResolver?.scheduleResolve()}onKeyframesResolved(t,e,n,i){</span><span class="s1">this</span><span class="s0">.keyframeResolver=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">;</span><span class="s1">const</span><span class="s0">{name:s,type:o,velocity:r,delay:a,isHandoff:l,onUpdate:u}=n;</span><span class="s1">this</span><span class="s0">.resolvedAt=pt.now(),</span><span class="s1">function</span><span class="s0">(t,e,n,i){</span><span class="s1">const </span><span class="s0">s=t[</span><span class="s3">0</span><span class="s0">];</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">===s)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;display&quot;</span><span class="s0">===e||</span><span class="s2">&quot;visibility&quot;</span><span class="s0">===e)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">const </span><span class="s0">o=t[t.length-</span><span class="s3">1</span><span class="s0">],r=Nn(s,e),a=Nn(o,e);</span><span class="s1">return</span><span class="s0">!(!r||!a)&amp;&amp;(</span><span class="s1">function</span><span class="s0">(t){</span><span class="s1">const </span><span class="s0">e=t[</span><span class="s3">0</span><span class="s0">];</span><span class="s1">if</span><span class="s0">(</span><span class="s3">1</span><span class="s0">===t.length)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">n=</span><span class="s3">0</span><span class="s0">;n&lt;t.length;n++)</span><span class="s1">if</span><span class="s0">(t[n]!==e)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">}(t)||(</span><span class="s2">&quot;spring&quot;</span><span class="s0">===n||jn(n))&amp;&amp;i)}(t,s,o,r)||(!S.instantAnimations&amp;&amp;a||u?.(Ye(t,n,e)),t[</span><span class="s3">0</span><span class="s0">]=t[t.length-</span><span class="s3">1</span><span class="s0">],$n(n),n.repeat=</span><span class="s3">0</span><span class="s0">);</span><span class="s1">const </span><span class="s0">c={startTime:i?</span><span class="s1">this</span><span class="s0">.resolvedAt&amp;&amp;</span><span class="s1">this</span><span class="s0">.resolvedAt-</span><span class="s1">this</span><span class="s0">.createdAt&gt;</span><span class="s3">40</span><span class="s0">?</span><span class="s1">this</span><span class="s0">.resolvedAt:</span><span class="s1">this</span><span class="s0">.createdAt:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,finalKeyframe:e,...n,keyframes:t},h=!l&amp;&amp;Hn(c)?</span><span class="s1">new </span><span class="s0">Un({...c,element:c.motionValue.owner.current}):</span><span class="s1">new </span><span class="s0">qe(c);h.finished.then(()=&gt;</span><span class="s1">this</span><span class="s0">.notifyFinished()).catch(V),</span><span class="s1">this</span><span class="s0">.pendingTimeline&amp;&amp;(</span><span class="s1">this</span><span class="s0">.stopTimeline=h.attachTimeline(</span><span class="s1">this</span><span class="s0">.pendingTimeline),</span><span class="s1">this</span><span class="s0">.pendingTimeline=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">._animation=h}get finished(){</span><span class="s1">return this</span><span class="s0">._animation?</span><span class="s1">this</span><span class="s0">.animation.finished:</span><span class="s1">this</span><span class="s0">._finished}then(t,e){</span><span class="s1">return this</span><span class="s0">.finished.finally(t).then(()=&gt;{})}get animation(){</span><span class="s1">return this</span><span class="s0">._animation||(</span><span class="s1">this</span><span class="s0">.keyframeResolver?.resume(),bn()),</span><span class="s1">this</span><span class="s0">._animation}get duration(){</span><span class="s1">return this</span><span class="s0">.animation.duration}get iterationDuration(){</span><span class="s1">return this</span><span class="s0">.animation.iterationDuration}get time(){</span><span class="s1">return this</span><span class="s0">.animation.time}set time(t){</span><span class="s1">this</span><span class="s0">.animation.time=t}get speed(){</span><span class="s1">return this</span><span class="s0">.animation.speed}get state(){</span><span class="s1">return this</span><span class="s0">.animation.state}set speed(t){</span><span class="s1">this</span><span class="s0">.animation.speed=t}get startTime(){</span><span class="s1">return this</span><span class="s0">.animation.startTime}attachTimeline(t){</span><span class="s1">return this</span><span class="s0">._animation?</span><span class="s1">this</span><span class="s0">.stopTimeline=</span><span class="s1">this</span><span class="s0">.animation.attachTimeline(t):</span><span class="s1">this</span><span class="s0">.pendingTimeline=t,()=&gt;</span><span class="s1">this</span><span class="s0">.stop()}play(){</span><span class="s1">this</span><span class="s0">.animation.play()}pause(){</span><span class="s1">this</span><span class="s0">.animation.pause()}complete(){</span><span class="s1">this</span><span class="s0">.animation.complete()}cancel(){</span><span class="s1">this</span><span class="s0">._animation&amp;&amp;</span><span class="s1">this</span><span class="s0">.animation.cancel(),</span><span class="s1">this</span><span class="s0">.keyframeResolver?.cancel()}}</span><span class="s1">class </span><span class="s0">Kn{constructor(t){</span><span class="s1">this</span><span class="s0">.stop=()=&gt;</span><span class="s1">this</span><span class="s0">.runAll(</span><span class="s2">&quot;stop&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.animations=t.filter(Boolean)}get finished(){</span><span class="s1">return </span><span class="s0">Promise.all(</span><span class="s1">this</span><span class="s0">.animations.map(t=&gt;t.finished))}getAll(t){</span><span class="s1">return this</span><span class="s0">.animations[</span><span class="s3">0</span><span class="s0">][t]}setAll(t,e){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">n=</span><span class="s3">0</span><span class="s0">;n&lt;</span><span class="s1">this</span><span class="s0">.animations.length;n++)</span><span class="s1">this</span><span class="s0">.animations[n][t]=e}attachTimeline(t){</span><span class="s1">const </span><span class="s0">e=</span><span class="s1">this</span><span class="s0">.animations.map(e=&gt;e.attachTimeline(t));</span><span class="s1">return</span><span class="s0">()=&gt;{e.forEach((t,e)=&gt;{t&amp;&amp;t(),</span><span class="s1">this</span><span class="s0">.animations[e].stop()})}}get time(){</span><span class="s1">return this</span><span class="s0">.getAll(</span><span class="s2">&quot;time&quot;</span><span class="s0">)}set time(t){</span><span class="s1">this</span><span class="s0">.setAll(</span><span class="s2">&quot;time&quot;</span><span class="s0">,t)}get speed(){</span><span class="s1">return this</span><span class="s0">.getAll(</span><span class="s2">&quot;speed&quot;</span><span class="s0">)}set speed(t){</span><span class="s1">this</span><span class="s0">.setAll(</span><span class="s2">&quot;speed&quot;</span><span class="s0">,t)}get state(){</span><span class="s1">return this</span><span class="s0">.getAll(</span><span class="s2">&quot;state&quot;</span><span class="s0">)}get startTime(){</span><span class="s1">return this</span><span class="s0">.getAll(</span><span class="s2">&quot;startTime&quot;</span><span class="s0">)}get duration(){</span><span class="s1">return </span><span class="s0">Gn(</span><span class="s1">this</span><span class="s0">.animations,</span><span class="s2">&quot;duration&quot;</span><span class="s0">)}get iterationDuration(){</span><span class="s1">return </span><span class="s0">Gn(</span><span class="s1">this</span><span class="s0">.animations,</span><span class="s2">&quot;iterationDuration&quot;</span><span class="s0">)}runAll(t){</span><span class="s1">this</span><span class="s0">.animations.forEach(e=&gt;e[t]())}play(){</span><span class="s1">this</span><span class="s0">.runAll(</span><span class="s2">&quot;play&quot;</span><span class="s0">)}pause(){</span><span class="s1">this</span><span class="s0">.runAll(</span><span class="s2">&quot;pause&quot;</span><span class="s0">)}cancel(){</span><span class="s1">this</span><span class="s0">.runAll(</span><span class="s2">&quot;cancel&quot;</span><span class="s0">)}complete(){</span><span class="s1">this</span><span class="s0">.runAll(</span><span class="s2">&quot;complete&quot;</span><span class="s0">)}}</span><span class="s1">function </span><span class="s0">Gn(t,e){</span><span class="s1">let </span><span class="s0">n=</span><span class="s3">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">i=</span><span class="s3">0</span><span class="s0">;i&lt;t.length;i++){</span><span class="s1">const </span><span class="s0">s=t[i][e];</span><span class="s1">null</span><span class="s0">!==s&amp;&amp;s&gt;n&amp;&amp;(n=s)}</span><span class="s1">return </span><span class="s0">n}</span><span class="s1">class </span><span class="s0">_n </span><span class="s1">extends </span><span class="s0">Kn{then(t,e){</span><span class="s1">return this</span><span class="s0">.finished.finally(t).then(()=&gt;{})}}</span><span class="s1">class </span><span class="s0">Zn </span><span class="s1">extends </span><span class="s0">In{constructor(t){</span><span class="s1">super</span><span class="s0">(),</span><span class="s1">this</span><span class="s0">.animation=t,t.onfinish=()=&gt;{</span><span class="s1">this</span><span class="s0">.finishedTime=</span><span class="s1">this</span><span class="s0">.time,</span><span class="s1">this</span><span class="s0">.notifyFinished()}}}</span><span class="s1">const </span><span class="s0">qn=</span><span class="s1">new </span><span class="s0">WeakMap,Jn=(t,e=</span><span class="s2">&quot;&quot;</span><span class="s0">)=&gt;</span><span class="s2">`</span><span class="s0">${t}</span><span class="s2">:</span><span class="s0">${e}</span><span class="s2">`</span><span class="s0">;</span><span class="s1">function </span><span class="s0">Qn(t){</span><span class="s1">const </span><span class="s0">e=qn.get(t)||</span><span class="s1">new </span><span class="s0">Map;</span><span class="s1">return </span><span class="s0">qn.set(t,e),e}</span><span class="s1">const </span><span class="s0">ti=</span><span class="s4">/^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u</span><span class="s0">;</span><span class="s1">function </span><span class="s0">ei(t){</span><span class="s1">const </span><span class="s0">e=ti.exec(t);</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">[,];</span><span class="s1">const</span><span class="s0">[,n,i,s]=e;</span><span class="s1">return</span><span class="s0">[</span><span class="s2">`--</span><span class="s0">${n??i}</span><span class="s2">`</span><span class="s0">,s]}</span><span class="s1">function </span><span class="s0">ni(t,e,n=</span><span class="s3">1</span><span class="s0">){</span><span class="s1">const</span><span class="s0">[i,s]=ei(t);</span><span class="s1">if</span><span class="s0">(!i)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">const </span><span class="s0">o=window.getComputedStyle(e).getPropertyValue(i);</span><span class="s1">if</span><span class="s0">(o){</span><span class="s1">const </span><span class="s0">t=o.trim();</span><span class="s1">return </span><span class="s0">E(t)?parseFloat(t):t}</span><span class="s1">return </span><span class="s0">vt(s)?ni(s,e,n+</span><span class="s3">1</span><span class="s0">):s}</span><span class="s1">function </span><span class="s0">ii(t,e){</span><span class="s1">return </span><span class="s0">t?.[e]??t?.default??t}</span><span class="s1">const </span><span class="s0">si=</span><span class="s1">new </span><span class="s0">Set([</span><span class="s2">&quot;width&quot;</span><span class="s0">,</span><span class="s2">&quot;height&quot;</span><span class="s0">,</span><span class="s2">&quot;top&quot;</span><span class="s0">,</span><span class="s2">&quot;left&quot;</span><span class="s0">,</span><span class="s2">&quot;right&quot;</span><span class="s0">,</span><span class="s2">&quot;bottom&quot;</span><span class="s0">,...hn]),oi=t=&gt;e=&gt;e.test(t),ri=[wt,Ot,Lt,kt,Bt,jt,{test:t=&gt;</span><span class="s2">&quot;auto&quot;</span><span class="s0">===t,parse:t=&gt;t}],ai=t=&gt;ri.find(oi(t));</span><span class="s1">function </span><span class="s0">li(t){</span><span class="s1">return</span><span class="s2">&quot;number&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t?</span><span class="s3">0</span><span class="s0">===t:</span><span class="s1">null</span><span class="s0">===t||(</span><span class="s2">&quot;none&quot;</span><span class="s0">===t||</span><span class="s2">&quot;0&quot;</span><span class="s0">===t||M(t))}</span><span class="s1">const </span><span class="s0">ui=</span><span class="s1">new </span><span class="s0">Set([</span><span class="s2">&quot;brightness&quot;</span><span class="s0">,</span><span class="s2">&quot;contrast&quot;</span><span class="s0">,</span><span class="s2">&quot;saturate&quot;</span><span class="s0">,</span><span class="s2">&quot;opacity&quot;</span><span class="s0">]);</span><span class="s1">function </span><span class="s0">ci(t){</span><span class="s1">const</span><span class="s0">[e,n]=t.slice(</span><span class="s3">0</span><span class="s0">,-</span><span class="s3">1</span><span class="s0">).split(</span><span class="s2">&quot;(&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;drop-shadow&quot;</span><span class="s0">===e)</span><span class="s1">return </span><span class="s0">t;</span><span class="s1">const</span><span class="s0">[i]=n.match(St)||[];</span><span class="s1">if</span><span class="s0">(!i)</span><span class="s1">return </span><span class="s0">t;</span><span class="s1">const </span><span class="s0">s=n.replace(i,</span><span class="s2">&quot;&quot;</span><span class="s0">);</span><span class="s1">let </span><span class="s0">o=ui.has(e)?</span><span class="s3">1</span><span class="s0">:</span><span class="s3">0</span><span class="s0">;</span><span class="s1">return </span><span class="s0">i!==n&amp;&amp;(o*=</span><span class="s3">100</span><span class="s0">),e+</span><span class="s2">&quot;(&quot;</span><span class="s0">+o+s+</span><span class="s2">&quot;)&quot;</span><span class="s0">}</span><span class="s1">const </span><span class="s0">hi=</span><span class="s4">/\b([a-z-]*)\(.*?\)/gu</span><span class="s0">,di={...Gt,getAnimatableNone:t=&gt;{</span><span class="s1">const </span><span class="s0">e=t.match(hi);</span><span class="s1">return </span><span class="s0">e?e.map(ci).join(</span><span class="s2">&quot; &quot;</span><span class="s0">):t}},pi={...wt,transform:Math.round},mi={rotate:kt,rotateX:kt,rotateY:kt,rotateZ:kt,scale:Pt,scaleX:Pt,scaleY:Pt,scaleZ:Pt,skew:kt,skewX:kt,skewY:kt,distance:Ot,translateX:Ot,translateY:Ot,translateZ:Ot,x:Ot,y:Ot,z:Ot,perspective:Ot,transformPerspective:Ot,opacity:Tt,originX:It,originY:It,originZ:Ot},fi={borderWidth:Ot,borderTopWidth:Ot,borderRightWidth:Ot,borderBottomWidth:Ot,borderLeftWidth:Ot,borderRadius:Ot,radius:Ot,borderTopLeftRadius:Ot,borderTopRightRadius:Ot,borderBottomRightRadius:Ot,borderBottomLeftRadius:Ot,width:Ot,maxWidth:Ot,height:Ot,maxHeight:Ot,top:Ot,right:Ot,bottom:Ot,left:Ot,padding:Ot,paddingTop:Ot,paddingRight:Ot,paddingBottom:Ot,paddingLeft:Ot,margin:Ot,marginTop:Ot,marginRight:Ot,marginBottom:Ot,marginLeft:Ot,backgroundPositionX:Ot,backgroundPositionY:Ot,...mi,zIndex:pi,fillOpacity:Tt,strokeOpacity:Tt,numOctaves:pi},gi={...fi,color:Wt,backgroundColor:Wt,outlineColor:Wt,fill:Wt,stroke:Wt,borderColor:Wt,borderTopColor:Wt,borderRightColor:Wt,borderBottomColor:Wt,borderLeftColor:Wt,filter:di,WebkitFilter:di},yi=t=&gt;gi[t];</span><span class="s1">function </span><span class="s0">vi(t,e){</span><span class="s1">let </span><span class="s0">n=yi(t);</span><span class="s1">return </span><span class="s0">n!==di&amp;&amp;(n=Gt),n.getAnimatableNone?n.getAnimatableNone(e):</span><span class="s1">void </span><span class="s3">0</span><span class="s0">}</span><span class="s1">const </span><span class="s0">xi=</span><span class="s1">new </span><span class="s0">Set([</span><span class="s2">&quot;auto&quot;</span><span class="s0">,</span><span class="s2">&quot;none&quot;</span><span class="s0">,</span><span class="s2">&quot;0&quot;</span><span class="s0">]);</span><span class="s1">class </span><span class="s0">wi </span><span class="s1">extends </span><span class="s0">Sn{constructor(t,e,n,i,s){</span><span class="s1">super</span><span class="s0">(t,e,n,i,s,!</span><span class="s3">0</span><span class="s0">)}readKeyframes(){</span><span class="s1">const</span><span class="s0">{unresolvedKeyframes:t,element:e,name:n}=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(!e||!e.current)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">super</span><span class="s0">.readKeyframes();</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">n=</span><span class="s3">0</span><span class="s0">;n&lt;t.length;n++){</span><span class="s1">let </span><span class="s0">i=t[n];</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">i&amp;&amp;(i=i.trim(),vt(i))){</span><span class="s1">const </span><span class="s0">s=ni(i,e.current);</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==s&amp;&amp;(t[n]=s),n===t.length-</span><span class="s3">1</span><span class="s0">&amp;&amp;(</span><span class="s1">this</span><span class="s0">.finalKeyframe=i)}}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.resolveNoneKeyframes(),!si.has(n)||</span><span class="s3">2</span><span class="s0">!==t.length)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">const</span><span class="s0">[i,s]=t,o=ai(i),r=ai(s);</span><span class="s1">if</span><span class="s0">(o!==r)</span><span class="s1">if</span><span class="s0">(pn(o)&amp;&amp;pn(r))</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">e=</span><span class="s3">0</span><span class="s0">;e&lt;t.length;e++){</span><span class="s1">const </span><span class="s0">n=t[e];</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">n&amp;&amp;(t[e]=parseFloat(n))}</span><span class="s1">else </span><span class="s0">gn[n]&amp;&amp;(</span><span class="s1">this</span><span class="s0">.needsMeasurement=!</span><span class="s3">0</span><span class="s0">)}resolveNoneKeyframes(){</span><span class="s1">const</span><span class="s0">{unresolvedKeyframes:t,name:e}=</span><span class="s1">this</span><span class="s0">,n=[];</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">e=</span><span class="s3">0</span><span class="s0">;e&lt;t.length;e++)(</span><span class="s1">null</span><span class="s0">===t[e]||li(t[e]))&amp;&amp;n.push(e);n.length&amp;&amp;</span><span class="s1">function</span><span class="s0">(t,e,n){</span><span class="s1">let </span><span class="s0">i,s=</span><span class="s3">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(;s&lt;t.length&amp;&amp;!i;){</span><span class="s1">const </span><span class="s0">e=t[s];</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;!xi.has(e)&amp;&amp;Xt(e).values.length&amp;&amp;(i=t[s]),s++}</span><span class="s1">if</span><span class="s0">(i&amp;&amp;n)</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">s of e)t[s]=vi(n,i)}(t,n,e)}measureInitialState(){</span><span class="s1">const</span><span class="s0">{element:t,unresolvedKeyframes:e,name:n}=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(!t||!t.current)</span><span class="s1">return</span><span class="s0">;</span><span class="s2">&quot;height&quot;</span><span class="s0">===n&amp;&amp;(</span><span class="s1">this</span><span class="s0">.suspendedScrollY=window.pageYOffset),</span><span class="s1">this</span><span class="s0">.measuredOrigin=gn[n](t.measureViewportBox(),window.getComputedStyle(t.current)),e[</span><span class="s3">0</span><span class="s0">]=</span><span class="s1">this</span><span class="s0">.measuredOrigin;</span><span class="s1">const </span><span class="s0">i=e[e.length-</span><span class="s3">1</span><span class="s0">];</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==i&amp;&amp;t.getValue(n,i).jump(i,!</span><span class="s3">1</span><span class="s0">)}measureEndState(){</span><span class="s1">const</span><span class="s0">{element:t,name:e,unresolvedKeyframes:n}=</span><span class="s1">this</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(!t||!t.current)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">const </span><span class="s0">i=t.getValue(e);i&amp;&amp;i.jump(</span><span class="s1">this</span><span class="s0">.measuredOrigin,!</span><span class="s3">1</span><span class="s0">);</span><span class="s1">const </span><span class="s0">s=n.length-</span><span class="s3">1</span><span class="s0">,o=n[s];n[s]=gn[e](t.measureViewportBox(),window.getComputedStyle(t.current)),</span><span class="s1">null</span><span class="s0">!==o&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.finalKeyframe&amp;&amp;(</span><span class="s1">this</span><span class="s0">.finalKeyframe=o),</span><span class="s1">this</span><span class="s0">.removedTransforms?.length&amp;&amp;</span><span class="s1">this</span><span class="s0">.removedTransforms.forEach(([e,n])=&gt;{t.getValue(e).set(n)}),</span><span class="s1">this</span><span class="s0">.resolveNoneKeyframes()}}</span><span class="s1">const </span><span class="s0">Ti=</span><span class="s1">new </span><span class="s0">Set([</span><span class="s2">&quot;borderWidth&quot;</span><span class="s0">,</span><span class="s2">&quot;borderTopWidth&quot;</span><span class="s0">,</span><span class="s2">&quot;borderRightWidth&quot;</span><span class="s0">,</span><span class="s2">&quot;borderBottomWidth&quot;</span><span class="s0">,</span><span class="s2">&quot;borderLeftWidth&quot;</span><span class="s0">,</span><span class="s2">&quot;borderRadius&quot;</span><span class="s0">,</span><span class="s2">&quot;radius&quot;</span><span class="s0">,</span><span class="s2">&quot;borderTopLeftRadius&quot;</span><span class="s0">,</span><span class="s2">&quot;borderTopRightRadius&quot;</span><span class="s0">,</span><span class="s2">&quot;borderBottomRightRadius&quot;</span><span class="s0">,</span><span class="s2">&quot;borderBottomLeftRadius&quot;</span><span class="s0">,</span><span class="s2">&quot;width&quot;</span><span class="s0">,</span><span class="s2">&quot;maxWidth&quot;</span><span class="s0">,</span><span class="s2">&quot;height&quot;</span><span class="s0">,</span><span class="s2">&quot;maxHeight&quot;</span><span class="s0">,</span><span class="s2">&quot;top&quot;</span><span class="s0">,</span><span class="s2">&quot;right&quot;</span><span class="s0">,</span><span class="s2">&quot;bottom&quot;</span><span class="s0">,</span><span class="s2">&quot;left&quot;</span><span class="s0">,</span><span class="s2">&quot;padding&quot;</span><span class="s0">,</span><span class="s2">&quot;paddingTop&quot;</span><span class="s0">,</span><span class="s2">&quot;paddingRight&quot;</span><span class="s0">,</span><span class="s2">&quot;paddingBottom&quot;</span><span class="s0">,</span><span class="s2">&quot;paddingLeft&quot;</span><span class="s0">,</span><span class="s2">&quot;margin&quot;</span><span class="s0">,</span><span class="s2">&quot;marginTop&quot;</span><span class="s0">,</span><span class="s2">&quot;marginRight&quot;</span><span class="s0">,</span><span class="s2">&quot;marginBottom&quot;</span><span class="s0">,</span><span class="s2">&quot;marginLeft&quot;</span><span class="s0">,</span><span class="s2">&quot;backgroundPositionX&quot;</span><span class="s0">,</span><span class="s2">&quot;backgroundPositionY&quot;</span><span class="s0">]);</span><span class="s1">function </span><span class="s0">Pi(t,e){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">n=</span><span class="s3">0</span><span class="s0">;n&lt;t.length;n++)</span><span class="s2">&quot;number&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t[n]&amp;&amp;Ti.has(e)&amp;&amp;(t[n]=t[n]+</span><span class="s2">&quot;px&quot;</span><span class="s0">)}</span><span class="s1">const </span><span class="s0">bi=C(()=&gt;{</span><span class="s1">try</span><span class="s0">{document.createElement(</span><span class="s2">&quot;div&quot;</span><span class="s0">).animate({opacity:[</span><span class="s3">1</span><span class="s0">]})}</span><span class="s1">catch</span><span class="s0">(t){</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">}</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">}),Si=</span><span class="s1">new </span><span class="s0">Set([</span><span class="s2">&quot;opacity&quot;</span><span class="s0">,</span><span class="s2">&quot;clipPath&quot;</span><span class="s0">,</span><span class="s2">&quot;filter&quot;</span><span class="s0">,</span><span class="s2">&quot;transform&quot;</span><span class="s0">]);</span><span class="s1">function </span><span class="s0">Ei(t,e,n){</span><span class="s1">if</span><span class="s0">(t </span><span class="s1">instanceof </span><span class="s0">EventTarget)</span><span class="s1">return</span><span class="s0">[t];</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t){</span><span class="s1">let </span><span class="s0">i=document;e&amp;&amp;(i=e.current);</span><span class="s1">const </span><span class="s0">s=n?.[t]??i.querySelectorAll(t);</span><span class="s1">return </span><span class="s0">s?Array.from(s):[]}</span><span class="s1">return </span><span class="s0">Array.from(t)}</span><span class="s1">function </span><span class="s0">Ai(t){</span><span class="s1">return</span><span class="s0">(e,n)=&gt;{</span><span class="s1">const </span><span class="s0">i=Ei(e),s=[];</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">e of i){</span><span class="s1">const </span><span class="s0">i=t(e,n);s.push(i)}</span><span class="s1">return</span><span class="s0">()=&gt;{</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">t of s)t()}}}</span><span class="s1">const </span><span class="s0">Mi=(t,e)=&gt;e&amp;&amp;</span><span class="s2">&quot;number&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t?e.transform(t):t;</span><span class="s1">class </span><span class="s0">Ci{constructor(){</span><span class="s1">this</span><span class="s0">.latest={},</span><span class="s1">this</span><span class="s0">.values=</span><span class="s1">new </span><span class="s0">Map}set(t,e,n,i,s=!</span><span class="s3">0</span><span class="s0">){</span><span class="s1">const </span><span class="s0">o=</span><span class="s1">this</span><span class="s0">.values.get(t);o&amp;&amp;o.onRemove();</span><span class="s1">const </span><span class="s0">r=()=&gt;{</span><span class="s1">const </span><span class="s0">i=e.get();</span><span class="s1">this</span><span class="s0">.latest[t]=s?Mi(i,fi[t]):i,n&amp;&amp;at.render(n)};r();</span><span class="s1">const </span><span class="s0">a=e.on(</span><span class="s2">&quot;change&quot;</span><span class="s0">,r);i&amp;&amp;e.addDependent(i);</span><span class="s1">const </span><span class="s0">l=()=&gt;{a(),n&amp;&amp;lt(n),</span><span class="s1">this</span><span class="s0">.values.delete(t),i&amp;&amp;e.removeDependent(i)};</span><span class="s1">return this</span><span class="s0">.values.set(t,{value:e,onRemove:l}),l}get(t){</span><span class="s1">return this</span><span class="s0">.values.get(t)?.value}destroy(){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">t of </span><span class="s1">this</span><span class="s0">.values.values())t.onRemove()}}</span><span class="s1">function </span><span class="s0">Vi(t){</span><span class="s1">const </span><span class="s0">e=</span><span class="s1">new </span><span class="s0">WeakMap,n=[];</span><span class="s1">return</span><span class="s0">(i,s)=&gt;{</span><span class="s1">const </span><span class="s0">o=e.get(i)??</span><span class="s1">new </span><span class="s0">Ci;e.set(i,o);</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">e </span><span class="s1">in </span><span class="s0">s){</span><span class="s1">const </span><span class="s0">r=s[e],a=t(i,o,e,r);n.push(a)}</span><span class="s1">return</span><span class="s0">()=&gt;{</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">t of n)t()}}}</span><span class="s1">const </span><span class="s0">Di=(t,e,n,i)=&gt;{</span><span class="s1">const </span><span class="s0">s=</span><span class="s1">function</span><span class="s0">(t,e){</span><span class="s1">if</span><span class="s0">(!(e </span><span class="s1">in </span><span class="s0">t))</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">const </span><span class="s0">n=Object.getOwnPropertyDescriptor(Object.getPrototypeOf(t),e)||Object.getOwnPropertyDescriptor(t,e);</span><span class="s1">return </span><span class="s0">n&amp;&amp;</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">n.set}(t,n),o=s?n:n.startsWith(</span><span class="s2">&quot;data&quot;</span><span class="s0">)||n.startsWith(</span><span class="s2">&quot;aria&quot;</span><span class="s0">)?n.replace(</span><span class="s4">/([A-Z])/g</span><span class="s0">,t=&gt;</span><span class="s2">`-</span><span class="s0">${t.toLowerCase()}</span><span class="s2">`</span><span class="s0">):n;</span><span class="s1">const </span><span class="s0">r=s?()=&gt;{t[o]=e.latest[n]}:()=&gt;{</span><span class="s1">const </span><span class="s0">i=e.latest[n];</span><span class="s1">null</span><span class="s0">==i?t.removeAttribute(o):t.setAttribute(o,String(i))};</span><span class="s1">return </span><span class="s0">e.set(n,i,r)},Ri=Ai(Vi(Di)),ki=Vi((t,e,n,i)=&gt;e.set(n,i,()=&gt;{t[n]=e.latest[n]},</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">));</span><span class="s1">function </span><span class="s0">Li(t){</span><span class="s1">return </span><span class="s0">A(t)&amp;&amp;</span><span class="s2">&quot;offsetHeight&quot;</span><span class="s1">in </span><span class="s0">t}</span><span class="s1">const </span><span class="s0">Oi={current:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">};</span><span class="s1">class </span><span class="s0">ji{constructor(t,e={}){</span><span class="s1">this</span><span class="s0">.canTrackVelocity=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.events={},</span><span class="s1">this</span><span class="s0">.updateAndNotify=t=&gt;{</span><span class="s1">const </span><span class="s0">e=pt.now();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.updatedAt!==e&amp;&amp;</span><span class="s1">this</span><span class="s0">.setPrevFrameValue(),</span><span class="s1">this</span><span class="s0">.prev=</span><span class="s1">this</span><span class="s0">.current,</span><span class="s1">this</span><span class="s0">.setCurrent(t),</span><span class="s1">this</span><span class="s0">.current!==</span><span class="s1">this</span><span class="s0">.prev&amp;&amp;(</span><span class="s1">this</span><span class="s0">.events.change?.notify(</span><span class="s1">this</span><span class="s0">.current),</span><span class="s1">this</span><span class="s0">.dependents))</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">t of </span><span class="s1">this</span><span class="s0">.dependents)t.dirty()},</span><span class="s1">this</span><span class="s0">.hasAnimated=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.setCurrent(t),</span><span class="s1">this</span><span class="s0">.owner=e.owner}setCurrent(t){</span><span class="s1">var </span><span class="s0">e;</span><span class="s1">this</span><span class="s0">.current=t,</span><span class="s1">this</span><span class="s0">.updatedAt=pt.now(),</span><span class="s1">null</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.canTrackVelocity&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==t&amp;&amp;(</span><span class="s1">this</span><span class="s0">.canTrackVelocity=(e=</span><span class="s1">this</span><span class="s0">.current,!isNaN(parseFloat(e))))}setPrevFrameValue(t=</span><span class="s1">this</span><span class="s0">.current){</span><span class="s1">this</span><span class="s0">.prevFrameValue=t,</span><span class="s1">this</span><span class="s0">.prevUpdatedAt=</span><span class="s1">this</span><span class="s0">.updatedAt}onChange(t){</span><span class="s1">return this</span><span class="s0">.on(</span><span class="s2">&quot;change&quot;</span><span class="s0">,t)}on(t,e){</span><span class="s1">this</span><span class="s0">.events[t]||(</span><span class="s1">this</span><span class="s0">.events[t]=</span><span class="s1">new </span><span class="s0">L);</span><span class="s1">const </span><span class="s0">n=</span><span class="s1">this</span><span class="s0">.events[t].add(e);</span><span class="s1">return</span><span class="s2">&quot;change&quot;</span><span class="s0">===t?()=&gt;{n(),at.read(()=&gt;{</span><span class="s1">this</span><span class="s0">.events.change.getSize()||</span><span class="s1">this</span><span class="s0">.stop()})}:n}clearListeners(){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">t </span><span class="s1">in this</span><span class="s0">.events)</span><span class="s1">this</span><span class="s0">.events[t].clear()}attach(t,e){</span><span class="s1">this</span><span class="s0">.passiveEffect=t,</span><span class="s1">this</span><span class="s0">.stopPassiveEffect=e}set(t){</span><span class="s1">this</span><span class="s0">.passiveEffect?</span><span class="s1">this</span><span class="s0">.passiveEffect(t,</span><span class="s1">this</span><span class="s0">.updateAndNotify):</span><span class="s1">this</span><span class="s0">.updateAndNotify(t)}setWithVelocity(t,e,n){</span><span class="s1">this</span><span class="s0">.set(e),</span><span class="s1">this</span><span class="s0">.prev=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.prevFrameValue=t,</span><span class="s1">this</span><span class="s0">.prevUpdatedAt=</span><span class="s1">this</span><span class="s0">.updatedAt-n}jump(t,e=!</span><span class="s3">0</span><span class="s0">){</span><span class="s1">this</span><span class="s0">.updateAndNotify(t),</span><span class="s1">this</span><span class="s0">.prev=t,</span><span class="s1">this</span><span class="s0">.prevUpdatedAt=</span><span class="s1">this</span><span class="s0">.prevFrameValue=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,e&amp;&amp;</span><span class="s1">this</span><span class="s0">.stop(),</span><span class="s1">this</span><span class="s0">.stopPassiveEffect&amp;&amp;</span><span class="s1">this</span><span class="s0">.stopPassiveEffect()}dirty(){</span><span class="s1">this</span><span class="s0">.events.change?.notify(</span><span class="s1">this</span><span class="s0">.current)}addDependent(t){</span><span class="s1">this</span><span class="s0">.dependents||(</span><span class="s1">this</span><span class="s0">.dependents=</span><span class="s1">new </span><span class="s0">Set),</span><span class="s1">this</span><span class="s0">.dependents.add(t)}removeDependent(t){</span><span class="s1">this</span><span class="s0">.dependents&amp;&amp;</span><span class="s1">this</span><span class="s0">.dependents.delete(t)}get(){</span><span class="s1">return </span><span class="s0">Oi.current&amp;&amp;Oi.current.push(</span><span class="s1">this</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.current}getPrevious(){</span><span class="s1">return this</span><span class="s0">.prev}getVelocity(){</span><span class="s1">const </span><span class="s0">t=pt.now();</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.canTrackVelocity||</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.prevFrameValue||t-</span><span class="s1">this</span><span class="s0">.updatedAt&gt;</span><span class="s3">30</span><span class="s0">)</span><span class="s1">return </span><span class="s3">0</span><span class="s0">;</span><span class="s1">const </span><span class="s0">e=Math.min(</span><span class="s1">this</span><span class="s0">.updatedAt-</span><span class="s1">this</span><span class="s0">.prevUpdatedAt,</span><span class="s3">30</span><span class="s0">);</span><span class="s1">return </span><span class="s0">B(parseFloat(</span><span class="s1">this</span><span class="s0">.current)-parseFloat(</span><span class="s1">this</span><span class="s0">.prevFrameValue),e)}start(t){</span><span class="s1">return this</span><span class="s0">.stop(),</span><span class="s1">new </span><span class="s0">Promise(e=&gt;{</span><span class="s1">this</span><span class="s0">.hasAnimated=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.animation=t(e),</span><span class="s1">this</span><span class="s0">.events.animationStart&amp;&amp;</span><span class="s1">this</span><span class="s0">.events.animationStart.notify()}).then(()=&gt;{</span><span class="s1">this</span><span class="s0">.events.animationComplete&amp;&amp;</span><span class="s1">this</span><span class="s0">.events.animationComplete.notify(),</span><span class="s1">this</span><span class="s0">.clearAnimation()})}stop(){</span><span class="s1">this</span><span class="s0">.animation&amp;&amp;(</span><span class="s1">this</span><span class="s0">.animation.stop(),</span><span class="s1">this</span><span class="s0">.events.animationCancel&amp;&amp;</span><span class="s1">this</span><span class="s0">.events.animationCancel.notify()),</span><span class="s1">this</span><span class="s0">.clearAnimation()}isAnimating(){</span><span class="s1">return</span><span class="s0">!!</span><span class="s1">this</span><span class="s0">.animation}clearAnimation(){</span><span class="s1">delete this</span><span class="s0">.animation}destroy(){</span><span class="s1">this</span><span class="s0">.dependents?.clear(),</span><span class="s1">this</span><span class="s0">.events.destroy?.notify(),</span><span class="s1">this</span><span class="s0">.clearListeners(),</span><span class="s1">this</span><span class="s0">.stop(),</span><span class="s1">this</span><span class="s0">.stopPassiveEffect&amp;&amp;</span><span class="s1">this</span><span class="s0">.stopPassiveEffect()}}</span><span class="s1">function </span><span class="s0">Bi(t,e){</span><span class="s1">return new </span><span class="s0">ji(t,e)}</span><span class="s1">const </span><span class="s0">Ii={x:</span><span class="s2">&quot;translateX&quot;</span><span class="s0">,y:</span><span class="s2">&quot;translateY&quot;</span><span class="s0">,z:</span><span class="s2">&quot;translateZ&quot;</span><span class="s0">,transformPerspective:</span><span class="s2">&quot;perspective&quot;</span><span class="s0">};</span><span class="s1">const </span><span class="s0">Fi=</span><span class="s1">new </span><span class="s0">Set([</span><span class="s2">&quot;originX&quot;</span><span class="s0">,</span><span class="s2">&quot;originY&quot;</span><span class="s0">,</span><span class="s2">&quot;originZ&quot;</span><span class="s0">]),Wi=(t,e,n,i)=&gt;{</span><span class="s1">let </span><span class="s0">s,o;</span><span class="s1">return </span><span class="s0">dn.has(n)?(e.get(</span><span class="s2">&quot;transform&quot;</span><span class="s0">)||(Li(t)||e.get(</span><span class="s2">&quot;transformBox&quot;</span><span class="s0">)||Wi(t,e,</span><span class="s2">&quot;transformBox&quot;</span><span class="s0">,</span><span class="s1">new </span><span class="s0">ji(</span><span class="s2">&quot;fill-box&quot;</span><span class="s0">)),e.set(</span><span class="s2">&quot;transform&quot;</span><span class="s0">,</span><span class="s1">new </span><span class="s0">ji(</span><span class="s2">&quot;none&quot;</span><span class="s0">),()=&gt;{t.style.transform=</span><span class="s1">function</span><span class="s0">(t){</span><span class="s1">let </span><span class="s0">e=</span><span class="s2">&quot;&quot;</span><span class="s0">,n=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">i=</span><span class="s3">0</span><span class="s0">;i&lt;hn.length;i++){</span><span class="s1">const </span><span class="s0">s=hn[i],o=t.latest[s];</span><span class="s1">if</span><span class="s0">(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===o)</span><span class="s1">continue</span><span class="s0">;</span><span class="s1">let </span><span class="s0">r=!</span><span class="s3">0</span><span class="s0">;r=</span><span class="s2">&quot;number&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">o?o===(s.startsWith(</span><span class="s2">&quot;scale&quot;</span><span class="s0">)?</span><span class="s3">1</span><span class="s0">:</span><span class="s3">0</span><span class="s0">):</span><span class="s3">0</span><span class="s0">===parseFloat(o),r||(n=!</span><span class="s3">1</span><span class="s0">,e+=</span><span class="s2">`</span><span class="s0">${Ii[s]||s}</span><span class="s2">(</span><span class="s0">${t.latest[s]}</span><span class="s2">) `</span><span class="s0">)}</span><span class="s1">return </span><span class="s0">n?</span><span class="s2">&quot;none&quot;</span><span class="s0">:e.trim()}(e)})),o=e.get(</span><span class="s2">&quot;transform&quot;</span><span class="s0">)):Fi.has(n)?(e.get(</span><span class="s2">&quot;transformOrigin&quot;</span><span class="s0">)||e.set(</span><span class="s2">&quot;transformOrigin&quot;</span><span class="s0">,</span><span class="s1">new </span><span class="s0">ji(</span><span class="s2">&quot;&quot;</span><span class="s0">),()=&gt;{</span><span class="s1">const </span><span class="s0">n=e.latest.originX??</span><span class="s2">&quot;50%&quot;</span><span class="s0">,i=e.latest.originY??</span><span class="s2">&quot;50%&quot;</span><span class="s0">,s=e.latest.originZ??</span><span class="s3">0</span><span class="s0">;t.style.transformOrigin=</span><span class="s2">`</span><span class="s0">${n} ${i} ${s}</span><span class="s2">`</span><span class="s0">}),o=e.get(</span><span class="s2">&quot;transformOrigin&quot;</span><span class="s0">)):s=En(n)?()=&gt;{t.style.setProperty(n,e.latest[n])}:()=&gt;{t.style[n]=e.latest[n]},e.set(n,i,s,o)},Ui=Ai(Vi(Wi)),Ni=Ot.transform;</span><span class="s1">const </span><span class="s0">$i=Ai(Vi((t,e,n,i)=&gt;{</span><span class="s1">if</span><span class="s0">(n.startsWith(</span><span class="s2">&quot;path&quot;</span><span class="s0">))</span><span class="s1">return function</span><span class="s0">(t,e,n,i){</span><span class="s1">return </span><span class="s0">at.render(()=&gt;t.setAttribute(</span><span class="s2">&quot;pathLength&quot;</span><span class="s0">,</span><span class="s2">&quot;1&quot;</span><span class="s0">)),</span><span class="s2">&quot;pathOffset&quot;</span><span class="s0">===n?e.set(n,i,()=&gt;t.setAttribute(</span><span class="s2">&quot;stroke-dashoffset&quot;</span><span class="s0">,Ni(-e.latest[n]))):(e.get(</span><span class="s2">&quot;stroke-dasharray&quot;</span><span class="s0">)||e.set(</span><span class="s2">&quot;stroke-dasharray&quot;</span><span class="s0">,</span><span class="s1">new </span><span class="s0">ji(</span><span class="s2">&quot;1 1&quot;</span><span class="s0">),()=&gt;{</span><span class="s1">const</span><span class="s0">{pathLength:n=</span><span class="s3">1</span><span class="s0">,pathSpacing:i}=e.latest;t.setAttribute(</span><span class="s2">&quot;stroke-dasharray&quot;</span><span class="s0">,</span><span class="s2">`</span><span class="s0">${Ni(n)} ${Ni(i??</span><span class="s3">1</span><span class="s0">-Number(n))}</span><span class="s2">`</span><span class="s0">)}),e.set(n,i,</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,e.get(</span><span class="s2">&quot;stroke-dasharray&quot;</span><span class="s0">)))}(t,e,n,i);</span><span class="s1">if</span><span class="s0">(n.startsWith(</span><span class="s2">&quot;attr&quot;</span><span class="s0">))</span><span class="s1">return </span><span class="s0">Di(t,e,</span><span class="s1">function</span><span class="s0">(t){</span><span class="s1">return </span><span class="s0">t.replace(</span><span class="s4">/^attr([A-Z])/</span><span class="s0">,(t,e)=&gt;e.toLowerCase())}(n),i);</span><span class="s1">return</span><span class="s0">(n </span><span class="s1">in </span><span class="s0">t.style?Wi:Di)(t,e,n,i)}));</span><span class="s1">const</span><span class="s0">{schedule:zi,cancel:Xi}=rt(queueMicrotask,!</span><span class="s3">1</span><span class="s0">),Hi={x:!</span><span class="s3">1</span><span class="s0">,y:!</span><span class="s3">1</span><span class="s0">};</span><span class="s1">function </span><span class="s0">Yi(){</span><span class="s1">return </span><span class="s0">Hi.x||Hi.y}</span><span class="s1">function </span><span class="s0">Ki(t){</span><span class="s1">return</span><span class="s2">&quot;x&quot;</span><span class="s0">===t||</span><span class="s2">&quot;y&quot;</span><span class="s0">===t?Hi[t]?</span><span class="s1">null</span><span class="s0">:(Hi[t]=!</span><span class="s3">0</span><span class="s0">,()=&gt;{Hi[t]=!</span><span class="s3">1</span><span class="s0">}):Hi.x||Hi.y?</span><span class="s1">null</span><span class="s0">:(Hi.x=Hi.y=!</span><span class="s3">0</span><span class="s0">,()=&gt;{Hi.x=Hi.y=!</span><span class="s3">1</span><span class="s0">})}</span><span class="s1">function </span><span class="s0">Gi(t,e){</span><span class="s1">const </span><span class="s0">n=Ei(t),i=</span><span class="s1">new </span><span class="s0">AbortController;</span><span class="s1">return</span><span class="s0">[n,{passive:!</span><span class="s3">0</span><span class="s0">,...e,signal:i.signal},()=&gt;i.abort()]}</span><span class="s1">function </span><span class="s0">_i(t){</span><span class="s1">return</span><span class="s0">!(</span><span class="s2">&quot;touch&quot;</span><span class="s0">===t.pointerType||Yi())}</span><span class="s1">function </span><span class="s0">Zi(t,e,n={}){</span><span class="s1">const</span><span class="s0">[i,s,o]=Gi(t,n),r=t=&gt;{</span><span class="s1">if</span><span class="s0">(!_i(t))</span><span class="s1">return</span><span class="s0">;</span><span class="s1">const</span><span class="s0">{target:n}=t,i=e(n,t);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">i||!n)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">const </span><span class="s0">o=t=&gt;{_i(t)&amp;&amp;(i(t),n.removeEventListener(</span><span class="s2">&quot;pointerleave&quot;</span><span class="s0">,o))};n.addEventListener(</span><span class="s2">&quot;pointerleave&quot;</span><span class="s0">,o,s)};</span><span class="s1">return </span><span class="s0">i.forEach(t=&gt;{t.addEventListener(</span><span class="s2">&quot;pointerenter&quot;</span><span class="s0">,r,s)}),o}</span><span class="s1">const </span><span class="s0">qi=(t,e)=&gt;!!e&amp;&amp;(t===e||qi(t,e.parentElement)),Ji=t=&gt;</span><span class="s2">&quot;mouse&quot;</span><span class="s0">===t.pointerType?</span><span class="s2">&quot;number&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">t.button||t.button&lt;=</span><span class="s3">0</span><span class="s0">:!</span><span class="s3">1</span><span class="s0">!==t.isPrimary,Qi=</span><span class="s1">new </span><span class="s0">Set([</span><span class="s2">&quot;BUTTON&quot;</span><span class="s0">,</span><span class="s2">&quot;INPUT&quot;</span><span class="s0">,</span><span class="s2">&quot;SELECT&quot;</span><span class="s0">,</span><span class="s2">&quot;TEXTAREA&quot;</span><span class="s0">,</span><span class="s2">&quot;A&quot;</span><span class="s0">]);</span><span class="s1">const </span><span class="s0">ts=</span><span class="s1">new </span><span class="s0">WeakSet;</span><span class="s1">function </span><span class="s0">es(t){</span><span class="s1">return </span><span class="s0">e=&gt;{</span><span class="s2">&quot;Enter&quot;</span><span class="s0">===e.key&amp;&amp;t(e)}}</span><span class="s1">function </span><span class="s0">ns(t,e){t.dispatchEvent(</span><span class="s1">new </span><span class="s0">PointerEvent(</span><span class="s2">&quot;pointer&quot;</span><span class="s0">+e,{isPrimary:!</span><span class="s3">0</span><span class="s0">,bubbles:!</span><span class="s3">0</span><span class="s0">}))}</span><span class="s1">function </span><span class="s0">is(t){</span><span class="s1">return </span><span class="s0">Ji(t)&amp;&amp;!Yi()}</span><span class="s1">function </span><span class="s0">ss(t,e,n={}){</span><span class="s1">const</span><span class="s0">[i,s,o]=Gi(t,n),r=t=&gt;{</span><span class="s1">const </span><span class="s0">i=t.currentTarget;</span><span class="s1">if</span><span class="s0">(!is(t))</span><span class="s1">return</span><span class="s0">;ts.add(i);</span><span class="s1">const </span><span class="s0">o=e(i,t),r=(t,e)=&gt;{window.removeEventListener(</span><span class="s2">&quot;pointerup&quot;</span><span class="s0">,a),window.removeEventListener(</span><span class="s2">&quot;pointercancel&quot;</span><span class="s0">,l),ts.has(i)&amp;&amp;ts.delete(i),is(t)&amp;&amp;</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">o&amp;&amp;o(t,{success:e})},a=t=&gt;{r(t,i===window||i===document||n.useGlobalTarget||qi(i,t.target))},l=t=&gt;{r(t,!</span><span class="s3">1</span><span class="s0">)};window.addEventListener(</span><span class="s2">&quot;pointerup&quot;</span><span class="s0">,a,s),window.addEventListener(</span><span class="s2">&quot;pointercancel&quot;</span><span class="s0">,l,s)};</span><span class="s1">return </span><span class="s0">i.forEach(t=&gt;{</span><span class="s1">var </span><span class="s0">e;(n.useGlobalTarget?window:t).addEventListener(</span><span class="s2">&quot;pointerdown&quot;</span><span class="s0">,r,s),Li(t)&amp;&amp;(t.addEventListener(</span><span class="s2">&quot;focus&quot;</span><span class="s0">,t=&gt;((t,e)=&gt;{</span><span class="s1">const </span><span class="s0">n=t.currentTarget;</span><span class="s1">if</span><span class="s0">(!n)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">const </span><span class="s0">i=es(()=&gt;{</span><span class="s1">if</span><span class="s0">(ts.has(n))</span><span class="s1">return</span><span class="s0">;ns(n,</span><span class="s2">&quot;down&quot;</span><span class="s0">);</span><span class="s1">const </span><span class="s0">t=es(()=&gt;{ns(n,</span><span class="s2">&quot;up&quot;</span><span class="s0">)});n.addEventListener(</span><span class="s2">&quot;keyup&quot;</span><span class="s0">,t,e),n.addEventListener(</span><span class="s2">&quot;blur&quot;</span><span class="s0">,()=&gt;ns(n,</span><span class="s2">&quot;cancel&quot;</span><span class="s0">),e)});n.addEventListener(</span><span class="s2">&quot;keydown&quot;</span><span class="s0">,i,e),n.addEventListener(</span><span class="s2">&quot;blur&quot;</span><span class="s0">,()=&gt;n.removeEventListener(</span><span class="s2">&quot;keydown&quot;</span><span class="s0">,i),e)})(t,s)),e=t,Qi.has(e.tagName)||-</span><span class="s3">1</span><span class="s0">!==e.tabIndex||t.hasAttribute(</span><span class="s2">&quot;tabindex&quot;</span><span class="s0">)||(t.tabIndex=</span><span class="s3">0</span><span class="s0">))}),o}</span><span class="s1">function </span><span class="s0">os(t,e){</span><span class="s1">const </span><span class="s0">n=window.getComputedStyle(t);</span><span class="s1">return </span><span class="s0">En(e)?n.getPropertyValue(e):n[e]}</span><span class="s1">function </span><span class="s0">rs(t){</span><span class="s1">return </span><span class="s0">A(t)&amp;&amp;</span><span class="s2">&quot;ownerSVGElement&quot;</span><span class="s1">in </span><span class="s0">t}</span><span class="s1">const </span><span class="s0">as=</span><span class="s1">new </span><span class="s0">WeakMap;</span><span class="s1">let </span><span class="s0">ls;</span><span class="s1">const </span><span class="s0">us=(t,e,n)=&gt;(i,s)=&gt;s&amp;&amp;s[</span><span class="s3">0</span><span class="s0">]?s[</span><span class="s3">0</span><span class="s0">][t+</span><span class="s2">&quot;Size&quot;</span><span class="s0">]:rs(i)&amp;&amp;</span><span class="s2">&quot;getBBox&quot;</span><span class="s1">in </span><span class="s0">i?i.getBBox()[e]:i[n],cs=us(</span><span class="s2">&quot;inline&quot;</span><span class="s0">,</span><span class="s2">&quot;width&quot;</span><span class="s0">,</span><span class="s2">&quot;offsetWidth&quot;</span><span class="s0">),hs=us(</span><span class="s2">&quot;block&quot;</span><span class="s0">,</span><span class="s2">&quot;height&quot;</span><span class="s0">,</span><span class="s2">&quot;offsetHeight&quot;</span><span class="s0">);</span><span class="s1">function </span><span class="s0">ds({target:t,borderBoxSize:e}){as.get(t)?.forEach(n=&gt;{n(t,{get width(){</span><span class="s1">return </span><span class="s0">cs(t,e)},get height(){</span><span class="s1">return </span><span class="s0">hs(t,e)}})})}</span><span class="s1">function </span><span class="s0">ps(t){t.forEach(ds)}</span><span class="s1">function </span><span class="s0">ms(t,e){ls||</span><span class="s2">&quot;undefined&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">ResizeObserver&amp;&amp;(ls=</span><span class="s1">new </span><span class="s0">ResizeObserver(ps));</span><span class="s1">const </span><span class="s0">n=Ei(t);</span><span class="s1">return </span><span class="s0">n.forEach(t=&gt;{</span><span class="s1">let </span><span class="s0">n=as.get(t);n||(n=</span><span class="s1">new </span><span class="s0">Set,as.set(t,n)),n.add(e),ls?.observe(t)}),()=&gt;{n.forEach(t=&gt;{</span><span class="s1">const </span><span class="s0">n=as.get(t);n?.delete(e),n?.size||ls?.unobserve(t)})}}</span><span class="s1">const </span><span class="s0">fs=</span><span class="s1">new </span><span class="s0">Set;</span><span class="s1">let </span><span class="s0">gs;</span><span class="s1">function </span><span class="s0">ys(t){</span><span class="s1">return </span><span class="s0">fs.add(t),gs||(gs=()=&gt;{</span><span class="s1">const </span><span class="s0">t={get width(){</span><span class="s1">return </span><span class="s0">window.innerWidth},get height(){</span><span class="s1">return </span><span class="s0">window.innerHeight}};fs.forEach(e=&gt;e(t))},window.addEventListener(</span><span class="s2">&quot;resize&quot;</span><span class="s0">,gs)),()=&gt;{fs.delete(t),fs.size||</span><span class="s2">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">gs||(window.removeEventListener(</span><span class="s2">&quot;resize&quot;</span><span class="s0">,gs),gs=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">)}}</span><span class="s1">function </span><span class="s0">vs(t,e){</span><span class="s1">return</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t?ys(t):ms(t,e)}</span><span class="s1">function </span><span class="s0">xs(t,e){</span><span class="s1">let </span><span class="s0">n;</span><span class="s1">const </span><span class="s0">i=()=&gt;{</span><span class="s1">const</span><span class="s0">{currentTime:i}=e,s=(</span><span class="s1">null</span><span class="s0">===i?</span><span class="s3">0</span><span class="s0">:i.value)/</span><span class="s3">100</span><span class="s0">;n!==s&amp;&amp;t(s),n=s};</span><span class="s1">return </span><span class="s0">at.preUpdate(i,!</span><span class="s3">0</span><span class="s0">),()=&gt;lt(i)}</span><span class="s1">function </span><span class="s0">ws(){</span><span class="s1">const</span><span class="s0">{value:t}=ot;</span><span class="s1">null</span><span class="s0">!==t?(t.frameloop.rate.push(ut.delta),t.animations.mainThread.push(mt.mainThread),t.animations.waapi.push(mt.waapi),t.animations.layout.push(mt.layout)):lt(ws)}</span><span class="s1">function </span><span class="s0">Ts(t){</span><span class="s1">return </span><span class="s0">t.reduce((t,e)=&gt;t+e,</span><span class="s3">0</span><span class="s0">)/t.length}</span><span class="s1">function </span><span class="s0">Ps(t,e=Ts){</span><span class="s1">return </span><span class="s3">0</span><span class="s0">===t.length?{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">,avg:</span><span class="s3">0</span><span class="s0">}:{min:Math.min(...t),max:Math.max(...t),avg:e(t)}}</span><span class="s1">const </span><span class="s0">bs=t=&gt;Math.round(</span><span class="s3">1e3</span><span class="s0">/t);</span><span class="s1">function </span><span class="s0">Ss(){ot.value=</span><span class="s1">null</span><span class="s0">,ot.addProjectionMetrics=</span><span class="s1">null</span><span class="s0">}</span><span class="s1">function </span><span class="s0">Es(){</span><span class="s1">const</span><span class="s0">{value:t}=ot;</span><span class="s1">if</span><span class="s0">(!t)</span><span class="s1">throw new </span><span class="s0">Error(</span><span class="s2">&quot;Stats are not being measured&quot;</span><span class="s0">);Ss(),lt(ws);</span><span class="s1">const </span><span class="s0">e={frameloop:{setup:Ps(t.frameloop.setup),rate:Ps(t.frameloop.rate),read:Ps(t.frameloop.read),resolveKeyframes:Ps(t.frameloop.resolveKeyframes),preUpdate:Ps(t.frameloop.preUpdate),update:Ps(t.frameloop.update),preRender:Ps(t.frameloop.preRender),render:Ps(t.frameloop.render),postRender:Ps(t.frameloop.postRender)},animations:{mainThread:Ps(t.animations.mainThread),waapi:Ps(t.animations.waapi),layout:Ps(t.animations.layout)},layoutProjection:{nodes:Ps(t.layoutProjection.nodes),calculatedTargetDeltas:Ps(t.layoutProjection.calculatedTargetDeltas),calculatedProjections:Ps(t.layoutProjection.calculatedProjections)}},{rate:n}=e.frameloop;</span><span class="s1">return </span><span class="s0">n.min=bs(n.min),n.max=bs(n.max),n.avg=bs(n.avg),[n.min,n.max]=[n.max,n.min],e}</span><span class="s1">function </span><span class="s0">As(t){</span><span class="s1">return </span><span class="s0">rs(t)&amp;&amp;</span><span class="s2">&quot;svg&quot;</span><span class="s0">===t.tagName}</span><span class="s1">function </span><span class="s0">Ms(t,e){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;first&quot;</span><span class="s0">===t)</span><span class="s1">return </span><span class="s3">0</span><span class="s0">;{</span><span class="s1">const </span><span class="s0">n=e-</span><span class="s3">1</span><span class="s0">;</span><span class="s1">return</span><span class="s2">&quot;last&quot;</span><span class="s0">===t?n:n/</span><span class="s3">2</span><span class="s0">}}</span><span class="s1">function </span><span class="s0">Cs(...t){</span><span class="s1">const </span><span class="s0">e=!Array.isArray(t[</span><span class="s3">0</span><span class="s0">]),n=e?</span><span class="s3">0</span><span class="s0">:-</span><span class="s3">1</span><span class="s0">,i=t[</span><span class="s3">0</span><span class="s0">+n],s=We(t[</span><span class="s3">1</span><span class="s0">+n],t[</span><span class="s3">2</span><span class="s0">+n],t[</span><span class="s3">3</span><span class="s0">+n]);</span><span class="s1">return </span><span class="s0">e?s(i):s}</span><span class="s1">function </span><span class="s0">Vs(t){</span><span class="s1">const </span><span class="s0">e=[];Oi.current=e;</span><span class="s1">const </span><span class="s0">n=t();Oi.current=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">;</span><span class="s1">const </span><span class="s0">i=Bi(n);</span><span class="s1">return function</span><span class="s0">(t,e,n){</span><span class="s1">const </span><span class="s0">i=()=&gt;e.set(n()),s=()=&gt;at.preRender(i,!</span><span class="s3">1</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">),o=t.map(t=&gt;t.on(</span><span class="s2">&quot;change&quot;</span><span class="s0">,s));e.on(</span><span class="s2">&quot;destroy&quot;</span><span class="s0">,()=&gt;{o.forEach(t=&gt;t()),lt(i)})}(e,i,t),i}</span><span class="s1">const </span><span class="s0">Ds=t=&gt;Boolean(t&amp;&amp;t.getVelocity);</span><span class="s1">function </span><span class="s0">Rs(t,e,n){</span><span class="s1">const </span><span class="s0">i=t.get();</span><span class="s1">let </span><span class="s0">s,o=</span><span class="s1">null</span><span class="s0">,r=i;</span><span class="s1">const </span><span class="s0">a=</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">i?i.replace(</span><span class="s4">/[\d.-]/g</span><span class="s0">,</span><span class="s2">&quot;&quot;</span><span class="s0">):</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,l=()=&gt;{o&amp;&amp;(o.stop(),o=</span><span class="s1">null</span><span class="s0">)},u=()=&gt;{l(),o=</span><span class="s1">new </span><span class="s0">qe({keyframes:[Ls(t.get()),Ls(r)],velocity:t.getVelocity(),type:</span><span class="s2">&quot;spring&quot;</span><span class="s0">,restDelta:</span><span class="s3">.001</span><span class="s0">,restSpeed:</span><span class="s3">.01</span><span class="s0">,...n,onUpdate:s})};</span><span class="s1">if</span><span class="s0">(t.attach((e,n)=&gt;(r=e,s=t=&gt;n(ks(t,a)),at.postRender(u),t.get()),l),Ds(e)){</span><span class="s1">const </span><span class="s0">n=e.on(</span><span class="s2">&quot;change&quot;</span><span class="s0">,e=&gt;t.set(ks(e,a))),i=t.on(</span><span class="s2">&quot;destroy&quot;</span><span class="s0">,n);</span><span class="s1">return</span><span class="s0">()=&gt;{n(),i()}}</span><span class="s1">return </span><span class="s0">l}</span><span class="s1">function </span><span class="s0">ks(t,e){</span><span class="s1">return </span><span class="s0">e?t+e:t}</span><span class="s1">function </span><span class="s0">Ls(t){</span><span class="s1">return</span><span class="s2">&quot;number&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t?t:parseFloat(t)}</span><span class="s1">const </span><span class="s0">Os=[...ri,Wt,Gt],js=t=&gt;Os.find(oi(t));</span><span class="s1">function </span><span class="s0">Bs(t){</span><span class="s1">return</span><span class="s2">&quot;layout&quot;</span><span class="s0">===t?</span><span class="s2">&quot;group&quot;</span><span class="s0">:</span><span class="s2">&quot;enter&quot;</span><span class="s0">===t||</span><span class="s2">&quot;new&quot;</span><span class="s0">===t?</span><span class="s2">&quot;new&quot;</span><span class="s0">:</span><span class="s2">&quot;exit&quot;</span><span class="s0">===t||</span><span class="s2">&quot;old&quot;</span><span class="s0">===t?</span><span class="s2">&quot;old&quot;</span><span class="s0">:</span><span class="s2">&quot;group&quot;</span><span class="s0">}</span><span class="s1">let </span><span class="s0">Is={},Fs=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">const </span><span class="s0">Ws=(t,e)=&gt;{Is[t]=e},Us=()=&gt;{Fs||(Fs=document.createElement(</span><span class="s2">&quot;style&quot;</span><span class="s0">),Fs.id=</span><span class="s2">&quot;motion-view&quot;</span><span class="s0">);</span><span class="s1">let </span><span class="s0">t=</span><span class="s2">&quot;&quot;</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">e </span><span class="s1">in </span><span class="s0">Is){</span><span class="s1">const </span><span class="s0">n=Is[e];t+=</span><span class="s2">`</span><span class="s0">${e} </span><span class="s2">{</span><span class="s5">\n</span><span class="s2">`</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const</span><span class="s0">[e,i]of Object.entries(n))t+=</span><span class="s2">`  </span><span class="s0">${e}</span><span class="s2">: </span><span class="s0">${i}</span><span class="s2">;</span><span class="s5">\n</span><span class="s2">`</span><span class="s0">;t+=</span><span class="s2">&quot;}</span><span class="s5">\n</span><span class="s2">&quot;</span><span class="s0">}Fs.textContent=t,document.head.appendChild(Fs),Is={}},Ns=()=&gt;{Fs&amp;&amp;Fs.parentElement&amp;&amp;Fs.parentElement.removeChild(Fs)};</span><span class="s1">function </span><span class="s0">$s(t){</span><span class="s1">const </span><span class="s0">e=t.match(</span><span class="s4">/::view-transition-(old|new|group|image-pair)\((.*?)\)/</span><span class="s0">);</span><span class="s1">return </span><span class="s0">e?{layer:e[</span><span class="s3">2</span><span class="s0">],type:e[</span><span class="s3">1</span><span class="s0">]}:</span><span class="s1">null</span><span class="s0">}</span><span class="s1">function </span><span class="s0">zs(t){</span><span class="s1">const</span><span class="s0">{effect:e}=t;</span><span class="s1">return</span><span class="s0">!!e&amp;&amp;(e.target===document.documentElement&amp;&amp;e.pseudoElement?.startsWith(</span><span class="s2">&quot;::view-transition&quot;</span><span class="s0">))}</span><span class="s1">function </span><span class="s0">Xs(){</span><span class="s1">return </span><span class="s0">document.getAnimations().filter(zs)}</span><span class="s1">const </span><span class="s0">Hs=[</span><span class="s2">&quot;layout&quot;</span><span class="s0">,</span><span class="s2">&quot;enter&quot;</span><span class="s0">,</span><span class="s2">&quot;exit&quot;</span><span class="s0">,</span><span class="s2">&quot;new&quot;</span><span class="s0">,</span><span class="s2">&quot;old&quot;</span><span class="s0">];</span><span class="s1">function </span><span class="s0">Ys(t){</span><span class="s1">const</span><span class="s0">{update:e,targets:n,options:i}=t;</span><span class="s1">if</span><span class="s0">(!document.startViewTransition)</span><span class="s1">return new </span><span class="s0">Promise(async t=&gt;{</span><span class="s1">await </span><span class="s0">e(),t(</span><span class="s1">new </span><span class="s0">Kn([]))});(</span><span class="s1">function</span><span class="s0">(t,e){</span><span class="s1">return </span><span class="s0">e.has(t)&amp;&amp;Object.keys(e.get(t)).length&gt;</span><span class="s3">0</span><span class="s0">})(</span><span class="s2">&quot;root&quot;</span><span class="s0">,n)||Ws(</span><span class="s2">&quot;:root&quot;</span><span class="s0">,{</span><span class="s2">&quot;view-transition-name&quot;</span><span class="s0">:</span><span class="s2">&quot;none&quot;</span><span class="s0">}),Ws(</span><span class="s2">&quot;::view-transition-group(*), ::view-transition-old(*), ::view-transition-new(*)&quot;</span><span class="s0">,{</span><span class="s2">&quot;animation-timing-function&quot;</span><span class="s0">:</span><span class="s2">&quot;linear !important&quot;</span><span class="s0">}),Us();</span><span class="s1">const </span><span class="s0">s=document.startViewTransition(async()=&gt;{</span><span class="s1">await </span><span class="s0">e()});</span><span class="s1">return </span><span class="s0">s.finished.finally(()=&gt;{Ns()}),</span><span class="s1">new </span><span class="s0">Promise(t=&gt;{s.ready.then(()=&gt;{</span><span class="s1">const </span><span class="s0">e=Xs(),s=[];n.forEach((t,e)=&gt;{</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">n of Hs){</span><span class="s1">if</span><span class="s0">(!t[n])</span><span class="s1">continue</span><span class="s0">;</span><span class="s1">const</span><span class="s0">{keyframes:o,options:r}=t[n];</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let</span><span class="s0">[t,a]of Object.entries(o)){</span><span class="s1">if</span><span class="s0">(!a)</span><span class="s1">continue</span><span class="s0">;</span><span class="s1">const </span><span class="s0">o={...ii(i,t),...ii(r,t)},l=Bs(n);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;opacity&quot;</span><span class="s0">===t&amp;&amp;!Array.isArray(a)){a=[</span><span class="s2">&quot;new&quot;</span><span class="s0">===l?</span><span class="s3">0</span><span class="s0">:</span><span class="s3">1</span><span class="s0">,a]}</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">o.delay&amp;&amp;(o.delay=o.delay(</span><span class="s3">0</span><span class="s0">,</span><span class="s3">1</span><span class="s0">)),o.duration&amp;&amp;(o.duration=O(o.duration)),o.delay&amp;&amp;(o.delay=O(o.delay));</span><span class="s1">const </span><span class="s0">u=</span><span class="s1">new </span><span class="s0">In({...o,element:document.documentElement,name:t,pseudoElement:</span><span class="s2">`::view-transition-</span><span class="s0">${l}</span><span class="s2">(</span><span class="s0">${e}</span><span class="s2">)`</span><span class="s0">,keyframes:a});s.push(u)}}});</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">t of e){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;finished&quot;</span><span class="s0">===t.playState)</span><span class="s1">continue</span><span class="s0">;</span><span class="s1">const</span><span class="s0">{effect:e}=t;</span><span class="s1">if</span><span class="s0">(!(e&amp;&amp;e </span><span class="s1">instanceof </span><span class="s0">KeyframeEffect))</span><span class="s1">continue</span><span class="s0">;</span><span class="s1">const</span><span class="s0">{pseudoElement:o}=e;</span><span class="s1">if</span><span class="s0">(!o)</span><span class="s1">continue</span><span class="s0">;</span><span class="s1">const </span><span class="s0">r=$s(o);</span><span class="s1">if</span><span class="s0">(!r)</span><span class="s1">continue</span><span class="s0">;</span><span class="s1">const </span><span class="s0">a=n.get(r.layer);</span><span class="s1">if</span><span class="s0">(a)Ks(a,</span><span class="s2">&quot;enter&quot;</span><span class="s0">)&amp;&amp;Ks(a,</span><span class="s2">&quot;exit&quot;</span><span class="s0">)&amp;&amp;e.getKeyframes().some(t=&gt;t.mixBlendMode)?s.push(</span><span class="s1">new </span><span class="s0">Zn(t)):t.cancel();</span><span class="s1">else</span><span class="s0">{</span><span class="s1">const </span><span class="s0">n=</span><span class="s2">&quot;group&quot;</span><span class="s0">===r.type?</span><span class="s2">&quot;layout&quot;</span><span class="s0">:</span><span class="s2">&quot;&quot;</span><span class="s0">;</span><span class="s1">let </span><span class="s0">o={...ii(i,n)};o.duration&amp;&amp;(o.duration=O(o.duration)),o=Bn(o);</span><span class="s1">const </span><span class="s0">a=Ln(o.ease,o.duration);e.updateTiming({delay:O(o.delay??</span><span class="s3">0</span><span class="s0">),duration:o.duration,easing:a}),s.push(</span><span class="s1">new </span><span class="s0">Zn(t))}}t(</span><span class="s1">new </span><span class="s0">Kn(s))})})}</span><span class="s1">function </span><span class="s0">Ks(t,e){</span><span class="s1">return </span><span class="s0">t?.[e]?.keyframes.opacity}</span><span class="s1">let </span><span class="s0">Gs=[],_s=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">function </span><span class="s0">Zs(){_s=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">const</span><span class="s0">[t]=Gs;</span><span class="s1">var </span><span class="s0">e;t&amp;&amp;(w(Gs,e=t),_s=e,Ys(e).then(t=&gt;{e.notifyReady(t),t.finished.finally(Zs)}))}</span><span class="s1">function </span><span class="s0">qs(){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">t=Gs.length-</span><span class="s3">1</span><span class="s0">;t&gt;=</span><span class="s3">0</span><span class="s0">;t--){</span><span class="s1">const </span><span class="s0">e=Gs[t],{interrupt:n}=e.options;</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;immediate&quot;</span><span class="s0">===n){</span><span class="s1">const </span><span class="s0">n=Gs.slice(</span><span class="s3">0</span><span class="s0">,t+</span><span class="s3">1</span><span class="s0">).map(t=&gt;t.update),i=Gs.slice(t+</span><span class="s3">1</span><span class="s0">);e.update=()=&gt;{n.forEach(t=&gt;t())},Gs=[e,...i];</span><span class="s1">break</span><span class="s0">}}_s&amp;&amp;</span><span class="s2">&quot;immediate&quot;</span><span class="s0">!==Gs[</span><span class="s3">0</span><span class="s0">]?.options.interrupt||Zs()}</span><span class="s1">class </span><span class="s0">Js{constructor(t,e={}){</span><span class="s1">var </span><span class="s0">n;</span><span class="s1">this</span><span class="s0">.currentSubject=</span><span class="s2">&quot;root&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.targets=</span><span class="s1">new </span><span class="s0">Map,</span><span class="s1">this</span><span class="s0">.notifyReady=V,</span><span class="s1">this</span><span class="s0">.readyPromise=</span><span class="s1">new </span><span class="s0">Promise(t=&gt;{</span><span class="s1">this</span><span class="s0">.notifyReady=t}),</span><span class="s1">this</span><span class="s0">.update=t,</span><span class="s1">this</span><span class="s0">.options={interrupt:</span><span class="s2">&quot;wait&quot;</span><span class="s0">,...e},n=</span><span class="s1">this</span><span class="s0">,Gs.push(n),zi.render(qs)}get(t){</span><span class="s1">return this</span><span class="s0">.currentSubject=t,</span><span class="s1">this</span><span class="s0">}layout(t,e){</span><span class="s1">return this</span><span class="s0">.updateTarget(</span><span class="s2">&quot;layout&quot;</span><span class="s0">,t,e),</span><span class="s1">this</span><span class="s0">}</span><span class="s1">new</span><span class="s0">(t,e){</span><span class="s1">return this</span><span class="s0">.updateTarget(</span><span class="s2">&quot;new&quot;</span><span class="s0">,t,e),</span><span class="s1">this</span><span class="s0">}old(t,e){</span><span class="s1">return this</span><span class="s0">.updateTarget(</span><span class="s2">&quot;old&quot;</span><span class="s0">,t,e),</span><span class="s1">this</span><span class="s0">}enter(t,e){</span><span class="s1">return this</span><span class="s0">.updateTarget(</span><span class="s2">&quot;enter&quot;</span><span class="s0">,t,e),</span><span class="s1">this</span><span class="s0">}exit(t,e){</span><span class="s1">return this</span><span class="s0">.updateTarget(</span><span class="s2">&quot;exit&quot;</span><span class="s0">,t,e),</span><span class="s1">this</span><span class="s0">}crossfade(t){</span><span class="s1">return this</span><span class="s0">.updateTarget(</span><span class="s2">&quot;enter&quot;</span><span class="s0">,{opacity:</span><span class="s3">1</span><span class="s0">},t),</span><span class="s1">this</span><span class="s0">.updateTarget(</span><span class="s2">&quot;exit&quot;</span><span class="s0">,{opacity:</span><span class="s3">0</span><span class="s0">},t),</span><span class="s1">this</span><span class="s0">}updateTarget(t,e,n={}){</span><span class="s1">const</span><span class="s0">{currentSubject:i,targets:s}=</span><span class="s1">this</span><span class="s0">;s.has(i)||s.set(i,{});s.get(i)[t]={keyframes:e,options:n}}then(t,e){</span><span class="s1">return this</span><span class="s0">.readyPromise.then(t,e)}}</span><span class="s1">const </span><span class="s0">Qs=at,to=st.reduce((t,e)=&gt;(t[e]=t=&gt;lt(t),t),{}),eo=e.createContext({transformPagePoint:t=&gt;t,isStatic:!</span><span class="s3">1</span><span class="s0">,reducedMotion:</span><span class="s2">&quot;never&quot;</span><span class="s0">});</span><span class="s1">function </span><span class="s0">no(t,e){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t)</span><span class="s1">return </span><span class="s0">t(e);</span><span class="s1">null</span><span class="s0">!=t&amp;&amp;(t.current=e)}</span><span class="s1">function </span><span class="s0">io(...t){</span><span class="s1">return </span><span class="s0">i.useCallback(</span><span class="s1">function</span><span class="s0">(...t){</span><span class="s1">return </span><span class="s0">e=&gt;{</span><span class="s1">let </span><span class="s0">n=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">const </span><span class="s0">i=t.map(t=&gt;{</span><span class="s1">const </span><span class="s0">i=no(t,e);</span><span class="s1">return </span><span class="s0">n||</span><span class="s2">&quot;function&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">i||(n=!</span><span class="s3">0</span><span class="s0">),i});</span><span class="s1">if</span><span class="s0">(n)</span><span class="s1">return</span><span class="s0">()=&gt;{</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">e=</span><span class="s3">0</span><span class="s0">;e&lt;i.length;e++){</span><span class="s1">const </span><span class="s0">n=i[e];</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">n?n():no(t[e],</span><span class="s1">null</span><span class="s0">)}}}}(...t),t)}</span><span class="s1">class </span><span class="s0">so </span><span class="s1">extends </span><span class="s0">i.Component{getSnapshotBeforeUpdate(t){</span><span class="s1">const </span><span class="s0">e=</span><span class="s1">this</span><span class="s0">.props.childRef.current;</span><span class="s1">if</span><span class="s0">(e&amp;&amp;t.isPresent&amp;&amp;!</span><span class="s1">this</span><span class="s0">.props.isPresent){</span><span class="s1">const </span><span class="s0">t=e.offsetParent,n=Li(t)&amp;&amp;t.offsetWidth||</span><span class="s3">0</span><span class="s0">,i=</span><span class="s1">this</span><span class="s0">.props.sizeRef.current;i.height=e.offsetHeight||</span><span class="s3">0</span><span class="s0">,i.width=e.offsetWidth||</span><span class="s3">0</span><span class="s0">,i.top=e.offsetTop,i.left=e.offsetLeft,i.right=n-i.width-i.left}</span><span class="s1">return null</span><span class="s0">}componentDidUpdate(){}render(){</span><span class="s1">return this</span><span class="s0">.props.children}}</span><span class="s1">function </span><span class="s0">oo({children:t,isPresent:n,anchorX:s,root:o}){</span><span class="s1">const </span><span class="s0">r=e.useId(),a=e.useRef(</span><span class="s1">null</span><span class="s0">),l=e.useRef({width:</span><span class="s3">0</span><span class="s0">,height:</span><span class="s3">0</span><span class="s0">,top:</span><span class="s3">0</span><span class="s0">,left:</span><span class="s3">0</span><span class="s0">,right:</span><span class="s3">0</span><span class="s0">}),{nonce:u}=e.useContext(eo),c=io(a,t?.ref);</span><span class="s1">return </span><span class="s0">e.useInsertionEffect(()=&gt;{</span><span class="s1">const</span><span class="s0">{width:t,height:e,top:i,left:c,right:h}=l.current;</span><span class="s1">if</span><span class="s0">(n||!a.current||!t||!e)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">const </span><span class="s0">d=</span><span class="s2">&quot;left&quot;</span><span class="s0">===s?</span><span class="s2">`left: </span><span class="s0">${c}</span><span class="s2">`</span><span class="s0">:</span><span class="s2">`right: </span><span class="s0">${h}</span><span class="s2">`</span><span class="s0">;a.current.dataset.motionPopId=r;</span><span class="s1">const </span><span class="s0">p=document.createElement(</span><span class="s2">&quot;style&quot;</span><span class="s0">);u&amp;&amp;(p.nonce=u);</span><span class="s1">const </span><span class="s0">m=o??document.head;</span><span class="s1">return </span><span class="s0">m.appendChild(p),p.sheet&amp;&amp;p.sheet.insertRule(</span><span class="s2">`</span><span class="s5">\n          </span><span class="s2">[data-motion-pop-id=&quot;</span><span class="s0">${r}</span><span class="s2">&quot;] {</span><span class="s5">\n            </span><span class="s2">position: absolute !important;</span><span class="s5">\n            </span><span class="s2">width: </span><span class="s0">${t}</span><span class="s2">px !important;</span><span class="s5">\n            </span><span class="s2">height: </span><span class="s0">${e}</span><span class="s2">px !important;</span><span class="s5">\n            </span><span class="s0">${d}</span><span class="s2">px !important;</span><span class="s5">\n            </span><span class="s2">top: </span><span class="s0">${i}</span><span class="s2">px !important;</span><span class="s5">\n          </span><span class="s2">}</span><span class="s5">\n        </span><span class="s2">`</span><span class="s0">),()=&gt;{m.contains(p)&amp;&amp;m.removeChild(p)}},[n]),d(so,{isPresent:n,childRef:a,sizeRef:l,children:i.cloneElement(t,{ref:c})})}</span><span class="s1">const </span><span class="s0">ro=({children:t,initial:n,isPresent:s,onExitComplete:o,custom:r,presenceAffectsLayout:a,mode:l,anchorX:u,root:c})=&gt;{</span><span class="s1">const </span><span class="s0">h=f(ao),p=e.useId();</span><span class="s1">let </span><span class="s0">m=!</span><span class="s3">0</span><span class="s0">,g=e.useMemo(()=&gt;(m=!</span><span class="s3">1</span><span class="s0">,{id:p,initial:n,isPresent:s,custom:r,onExitComplete:t=&gt;{h.set(t,!</span><span class="s3">0</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">t of h.values())</span><span class="s1">if</span><span class="s0">(!t)</span><span class="s1">return</span><span class="s0">;o&amp;&amp;o()},register:t=&gt;(h.set(t,!</span><span class="s3">1</span><span class="s0">),()=&gt;h.delete(t))}),[s,h,o]);</span><span class="s1">return </span><span class="s0">a&amp;&amp;m&amp;&amp;(g={...g}),e.useMemo(()=&gt;{h.forEach((t,e)=&gt;h.set(e,!</span><span class="s3">1</span><span class="s0">))},[s]),i.useEffect(()=&gt;{!s&amp;&amp;!h.size&amp;&amp;o&amp;&amp;o()},[s]),</span><span class="s2">&quot;popLayout&quot;</span><span class="s0">===l&amp;&amp;(t=d(oo,{isPresent:s,anchorX:u,root:c,children:t})),d(v.Provider,{value:g,children:t})};</span><span class="s1">function </span><span class="s0">ao(){</span><span class="s1">return new </span><span class="s0">Map}</span><span class="s1">function </span><span class="s0">lo(t=!</span><span class="s3">0</span><span class="s0">){</span><span class="s1">const </span><span class="s0">n=e.useContext(v);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">null</span><span class="s0">===n)</span><span class="s1">return</span><span class="s0">[!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">null</span><span class="s0">];</span><span class="s1">const</span><span class="s0">{isPresent:i,onExitComplete:s,register:o}=n,r=e.useId();e.useEffect(()=&gt;{</span><span class="s1">if</span><span class="s0">(t)</span><span class="s1">return </span><span class="s0">o(r)},[t]);</span><span class="s1">const </span><span class="s0">a=e.useCallback(()=&gt;t&amp;&amp;s&amp;&amp;s(r),[r,s,t]);</span><span class="s1">return</span><span class="s0">!i&amp;&amp;s?[!</span><span class="s3">1</span><span class="s0">,a]:[!</span><span class="s3">0</span><span class="s0">]}</span><span class="s1">const </span><span class="s0">uo=t=&gt;t.key||</span><span class="s2">&quot;&quot;</span><span class="s0">;</span><span class="s1">function </span><span class="s0">co(t){</span><span class="s1">const </span><span class="s0">n=[];</span><span class="s1">return </span><span class="s0">e.Children.forEach(t,t=&gt;{e.isValidElement(t)&amp;&amp;n.push(t)}),n}</span><span class="s1">const </span><span class="s0">ho=e.createContext(</span><span class="s1">null</span><span class="s0">);</span><span class="s1">function </span><span class="s0">po(t){</span><span class="s1">return </span><span class="s0">t.max-t.min}</span><span class="s1">function </span><span class="s0">mo(t,e,n,i=</span><span class="s3">.5</span><span class="s0">){t.origin=i,t.originPoint=Jt(e.min,e.max,t.origin),t.scale=po(n)/po(e),t.translate=Jt(n.min,n.max,t.origin)-t.originPoint,(t.scale&gt;=</span><span class="s3">.9999</span><span class="s0">&amp;&amp;t.scale&lt;=</span><span class="s3">1.0001</span><span class="s0">||isNaN(t.scale))&amp;&amp;(t.scale=</span><span class="s3">1</span><span class="s0">),(t.translate&gt;=-</span><span class="s3">.01</span><span class="s0">&amp;&amp;t.translate&lt;=</span><span class="s3">.01</span><span class="s0">||isNaN(t.translate))&amp;&amp;(t.translate=</span><span class="s3">0</span><span class="s0">)}</span><span class="s1">function </span><span class="s0">fo(t,e,n,i){mo(t.x,e.x,n.x,i?i.originX:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">),mo(t.y,e.y,n.y,i?i.originY:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">)}</span><span class="s1">function </span><span class="s0">go(t,e,n){t.min=n.min+e.min,t.max=t.min+po(e)}</span><span class="s1">function </span><span class="s0">yo(t,e,n){t.min=e.min-n.min,t.max=t.min+po(e)}</span><span class="s1">function </span><span class="s0">vo(t,e,n){yo(t.x,e.x,n.x),yo(t.y,e.y,n.y)}</span><span class="s1">const </span><span class="s0">xo=t=&gt;!t.isLayoutDirty&amp;&amp;t.willUpdate(!</span><span class="s3">1</span><span class="s0">);</span><span class="s1">function </span><span class="s0">wo(){</span><span class="s1">const </span><span class="s0">t=</span><span class="s1">new </span><span class="s0">Set,e=</span><span class="s1">new </span><span class="s0">WeakMap,n=()=&gt;t.forEach(xo);</span><span class="s1">return</span><span class="s0">{add:i=&gt;{t.add(i),e.set(i,i.addEventListener(</span><span class="s2">&quot;willUpdate&quot;</span><span class="s0">,n))},remove:i=&gt;{t.delete(i);</span><span class="s1">const </span><span class="s0">s=e.get(i);s&amp;&amp;(s(),e.delete(i)),n()},dirty:n}}</span><span class="s1">const </span><span class="s0">To=t=&gt;</span><span class="s1">null</span><span class="s0">!==t;</span><span class="s1">const </span><span class="s0">Po={type:</span><span class="s2">&quot;spring&quot;</span><span class="s0">,stiffness:</span><span class="s3">500</span><span class="s0">,damping:</span><span class="s3">25</span><span class="s0">,restSpeed:</span><span class="s3">10</span><span class="s0">},bo={type:</span><span class="s2">&quot;keyframes&quot;</span><span class="s0">,duration:</span><span class="s3">.8</span><span class="s0">},So={type:</span><span class="s2">&quot;keyframes&quot;</span><span class="s0">,ease:[</span><span class="s3">.25</span><span class="s0">,</span><span class="s3">.1</span><span class="s0">,</span><span class="s3">.35</span><span class="s0">,</span><span class="s3">1</span><span class="s0">],duration:</span><span class="s3">.3</span><span class="s0">},Eo=(t,{keyframes:e})=&gt;e.length&gt;</span><span class="s3">2</span><span class="s0">?bo:dn.has(t)?t.startsWith(</span><span class="s2">&quot;scale&quot;</span><span class="s0">)?{type:</span><span class="s2">&quot;spring&quot;</span><span class="s0">,stiffness:</span><span class="s3">550</span><span class="s0">,damping:</span><span class="s3">0</span><span class="s0">===e[</span><span class="s3">1</span><span class="s0">]?</span><span class="s3">2</span><span class="s0">*Math.sqrt(</span><span class="s3">550</span><span class="s0">):</span><span class="s3">30</span><span class="s0">,restSpeed:</span><span class="s3">10</span><span class="s0">}:Po:So;</span><span class="s1">const </span><span class="s0">Ao=(t,e,n,i={},s,o)=&gt;r=&gt;{</span><span class="s1">const </span><span class="s0">a=ii(i,t)||{},l=a.delay||i.delay||</span><span class="s3">0</span><span class="s0">;</span><span class="s1">let</span><span class="s0">{elapsed:u=</span><span class="s3">0</span><span class="s0">}=i;u-=O(l);</span><span class="s1">const </span><span class="s0">c={keyframes:Array.isArray(n)?n:[</span><span class="s1">null</span><span class="s0">,n],ease:</span><span class="s2">&quot;easeOut&quot;</span><span class="s0">,velocity:e.getVelocity(),...a,delay:-u,onUpdate:t=&gt;{e.set(t),a.onUpdate&amp;&amp;a.onUpdate(t)},onComplete:()=&gt;{r(),a.onComplete&amp;&amp;a.onComplete()},name:t,motionValue:e,element:o?</span><span class="s1">void </span><span class="s3">0</span><span class="s0">:s};(</span><span class="s1">function</span><span class="s0">({when:t,delay:e,delayChildren:n,staggerChildren:i,staggerDirection:s,repeat:o,repeatType:r,repeatDelay:a,from:l,elapsed:u,...c}){</span><span class="s1">return</span><span class="s0">!!Object.keys(c).length})(a)||Object.assign(c,Eo(t,c)),c.duration&amp;&amp;(c.duration=O(c.duration)),c.repeatDelay&amp;&amp;(c.repeatDelay=O(c.repeatDelay)),</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==c.from&amp;&amp;(c.keyframes[</span><span class="s3">0</span><span class="s0">]=c.from);</span><span class="s1">let </span><span class="s0">h=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">((!</span><span class="s3">1</span><span class="s0">===c.type||</span><span class="s3">0</span><span class="s0">===c.duration&amp;&amp;!c.repeatDelay)&amp;&amp;($n(c),</span><span class="s3">0</span><span class="s0">===c.delay&amp;&amp;(h=!</span><span class="s3">0</span><span class="s0">)),(S.instantAnimations||S.skipAnimations)&amp;&amp;(h=!</span><span class="s3">0</span><span class="s0">,$n(c),c.delay=</span><span class="s3">0</span><span class="s0">),c.allowFlatten=!a.type&amp;&amp;!a.ease,h&amp;&amp;!o&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==e.get()){</span><span class="s1">const </span><span class="s0">t=</span><span class="s1">function</span><span class="s0">(t,{repeat:e,repeatType:n=</span><span class="s2">&quot;loop&quot;</span><span class="s0">},i){</span><span class="s1">const </span><span class="s0">s=t.filter(To),o=e&amp;&amp;</span><span class="s2">&quot;loop&quot;</span><span class="s0">!==n&amp;&amp;e%</span><span class="s3">2</span><span class="s0">==</span><span class="s3">1</span><span class="s0">?</span><span class="s3">0</span><span class="s0">:s.length-</span><span class="s3">1</span><span class="s0">;</span><span class="s1">return </span><span class="s0">o&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==i?i:s[o]}(c.keyframes,a);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==t)</span><span class="s1">return void </span><span class="s0">at.update(()=&gt;{c.onUpdate(t),c.onComplete()})}</span><span class="s1">return </span><span class="s0">a.isSync?</span><span class="s1">new </span><span class="s0">qe(c):</span><span class="s1">new </span><span class="s0">Yn(c)};</span><span class="s1">function </span><span class="s0">Mo(t,e,n){</span><span class="s1">const </span><span class="s0">i=Ds(t)?t:Bi(t);</span><span class="s1">return </span><span class="s0">i.start(Ao(</span><span class="s2">&quot;&quot;</span><span class="s0">,i,e,n)),i.animation}</span><span class="s1">const </span><span class="s0">Co=t=&gt;t.replace(</span><span class="s4">/([a-z])([A-Z])/gu</span><span class="s0">,</span><span class="s2">&quot;$1-$2&quot;</span><span class="s0">).toLowerCase(),Vo=</span><span class="s2">&quot;framerAppearId&quot;</span><span class="s0">,Do=</span><span class="s2">&quot;data-&quot;</span><span class="s0">+Co(Vo);</span><span class="s1">function </span><span class="s0">Ro(t){</span><span class="s1">return </span><span class="s0">t.props[Do]}</span><span class="s1">const </span><span class="s0">ko=(t,e)=&gt;t.depth-e.depth;</span><span class="s1">class </span><span class="s0">Lo{constructor(){</span><span class="s1">this</span><span class="s0">.children=[],</span><span class="s1">this</span><span class="s0">.isDirty=!</span><span class="s3">1</span><span class="s0">}add(t){x(</span><span class="s1">this</span><span class="s0">.children,t),</span><span class="s1">this</span><span class="s0">.isDirty=!</span><span class="s3">0</span><span class="s0">}remove(t){w(</span><span class="s1">this</span><span class="s0">.children,t),</span><span class="s1">this</span><span class="s0">.isDirty=!</span><span class="s3">0</span><span class="s0">}forEach(t){</span><span class="s1">this</span><span class="s0">.isDirty&amp;&amp;</span><span class="s1">this</span><span class="s0">.children.sort(ko),</span><span class="s1">this</span><span class="s0">.isDirty=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.children.forEach(t)}}</span><span class="s1">function </span><span class="s0">Oo(t,e){</span><span class="s1">const </span><span class="s0">n=pt.now(),i=({timestamp:s})=&gt;{</span><span class="s1">const </span><span class="s0">o=s-n;o&gt;=e&amp;&amp;(lt(i),t(o-e))};</span><span class="s1">return </span><span class="s0">at.setup(i,!</span><span class="s3">0</span><span class="s0">),()=&gt;lt(i)}</span><span class="s1">function </span><span class="s0">jo(t){</span><span class="s1">return </span><span class="s0">Ds(t)?t.get():t}</span><span class="s1">const </span><span class="s0">Bo=[</span><span class="s2">&quot;TopLeft&quot;</span><span class="s0">,</span><span class="s2">&quot;TopRight&quot;</span><span class="s0">,</span><span class="s2">&quot;BottomLeft&quot;</span><span class="s0">,</span><span class="s2">&quot;BottomRight&quot;</span><span class="s0">],Io=Bo.length,Fo=t=&gt;</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t?parseFloat(t):t,Wo=t=&gt;</span><span class="s2">&quot;number&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t||Ot.test(t);</span><span class="s1">function </span><span class="s0">Uo(t,e){</span><span class="s1">return void </span><span class="s3">0</span><span class="s0">!==t[e]?t[e]:t.borderRadius}</span><span class="s1">const </span><span class="s0">No=zo(</span><span class="s3">0</span><span class="s0">,</span><span class="s3">.5</span><span class="s0">,G),$o=zo(</span><span class="s3">.5</span><span class="s0">,</span><span class="s3">.95</span><span class="s0">,V);</span><span class="s1">function </span><span class="s0">zo(t,e,n){</span><span class="s1">return </span><span class="s0">i=&gt;i&lt;t?</span><span class="s3">0</span><span class="s0">:i&gt;e?</span><span class="s3">1</span><span class="s0">:n(k(t,e,i))}</span><span class="s1">function </span><span class="s0">Xo(t,e){t.min=e.min,t.max=e.max}</span><span class="s1">function </span><span class="s0">Ho(t,e){Xo(t.x,e.x),Xo(t.y,e.y)}</span><span class="s1">function </span><span class="s0">Yo(t,e){t.translate=e.translate,t.scale=e.scale,t.originPoint=e.originPoint,t.origin=e.origin}</span><span class="s1">function </span><span class="s0">Ko(t){</span><span class="s1">return void </span><span class="s3">0</span><span class="s0">===t||</span><span class="s3">1</span><span class="s0">===t}</span><span class="s1">function </span><span class="s0">Go({scale:t,scaleX:e,scaleY:n}){</span><span class="s1">return</span><span class="s0">!Ko(t)||!Ko(e)||!Ko(n)}</span><span class="s1">function </span><span class="s0">_o(t){</span><span class="s1">return </span><span class="s0">Go(t)||Zo(t)||t.z||t.rotate||t.rotateX||t.rotateY||t.skewX||t.skewY}</span><span class="s1">function </span><span class="s0">Zo(t){</span><span class="s1">return </span><span class="s0">qo(t.x)||qo(t.y)}</span><span class="s1">function </span><span class="s0">qo(t){</span><span class="s1">return </span><span class="s0">t&amp;&amp;</span><span class="s2">&quot;0%&quot;</span><span class="s0">!==t}</span><span class="s1">function </span><span class="s0">Jo(t,e,n){</span><span class="s1">return </span><span class="s0">n+e*(t-n)}</span><span class="s1">function </span><span class="s0">Qo(t,e,n,i,s){</span><span class="s1">return void </span><span class="s3">0</span><span class="s0">!==s&amp;&amp;(t=Jo(t,s,i)),Jo(t,n,i)+e}</span><span class="s1">function </span><span class="s0">tr(t,e=</span><span class="s3">0</span><span class="s0">,n=</span><span class="s3">1</span><span class="s0">,i,s){t.min=Qo(t.min,e,n,i,s),t.max=Qo(t.max,e,n,i,s)}</span><span class="s1">function </span><span class="s0">er(t,{x:e,y:n}){tr(t.x,e.translate,e.scale,e.originPoint),tr(t.y,n.translate,n.scale,n.originPoint)}</span><span class="s1">const </span><span class="s0">nr=</span><span class="s3">.999999999999</span><span class="s0">,ir=</span><span class="s3">1.0000000000001</span><span class="s0">;</span><span class="s1">function </span><span class="s0">sr(t,e){t.min=t.min+e,t.max=t.max+e}</span><span class="s1">function </span><span class="s0">or(t,e,n,i,s=</span><span class="s3">.5</span><span class="s0">){tr(t,e,n,Jt(t.min,t.max,s),i)}</span><span class="s1">function </span><span class="s0">rr(t,e){or(t.x,e.x,e.scaleX,e.scale,e.originX),or(t.y,e.y,e.scaleY,e.scale,e.originY)}</span><span class="s1">function </span><span class="s0">ar(t,e,n,i,s){</span><span class="s1">return </span><span class="s0">t=Jo(t-=e,</span><span class="s3">1</span><span class="s0">/n,i),</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==s&amp;&amp;(t=Jo(t,</span><span class="s3">1</span><span class="s0">/s,i)),t}</span><span class="s1">function </span><span class="s0">lr(t,e,[n,i,s],o,r){!</span><span class="s1">function</span><span class="s0">(t,e=</span><span class="s3">0</span><span class="s0">,n=</span><span class="s3">1</span><span class="s0">,i=</span><span class="s3">.5</span><span class="s0">,s,o=t,r=t){Lt.test(e)&amp;&amp;(e=parseFloat(e),e=Jt(r.min,r.max,e/</span><span class="s3">100</span><span class="s0">)-r.min);</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;number&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">let </span><span class="s0">a=Jt(o.min,o.max,i);t===o&amp;&amp;(a-=e),t.min=ar(t.min,e,n,a,s),t.max=ar(t.max,e,n,a,s)}(t,e[n],e[i],e[s],e.scale,o,r)}</span><span class="s1">const </span><span class="s0">ur=[</span><span class="s2">&quot;x&quot;</span><span class="s0">,</span><span class="s2">&quot;scaleX&quot;</span><span class="s0">,</span><span class="s2">&quot;originX&quot;</span><span class="s0">],cr=[</span><span class="s2">&quot;y&quot;</span><span class="s0">,</span><span class="s2">&quot;scaleY&quot;</span><span class="s0">,</span><span class="s2">&quot;originY&quot;</span><span class="s0">];</span><span class="s1">function </span><span class="s0">hr(t,e,n,i){lr(t.x,e,ur,n?n.x:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,i?i.x:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">),lr(t.y,e,cr,n?n.y:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,i?i.y:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">)}</span><span class="s1">const </span><span class="s0">dr=()=&gt;({x:{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">},y:{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">}});</span><span class="s1">function </span><span class="s0">pr(t){</span><span class="s1">return </span><span class="s3">0</span><span class="s0">===t.translate&amp;&amp;</span><span class="s3">1</span><span class="s0">===t.scale}</span><span class="s1">function </span><span class="s0">mr(t){</span><span class="s1">return </span><span class="s0">pr(t.x)&amp;&amp;pr(t.y)}</span><span class="s1">function </span><span class="s0">fr(t,e){</span><span class="s1">return </span><span class="s0">t.min===e.min&amp;&amp;t.max===e.max}</span><span class="s1">function </span><span class="s0">gr(t,e){</span><span class="s1">return </span><span class="s0">Math.round(t.min)===Math.round(e.min)&amp;&amp;Math.round(t.max)===Math.round(e.max)}</span><span class="s1">function </span><span class="s0">yr(t,e){</span><span class="s1">return </span><span class="s0">gr(t.x,e.x)&amp;&amp;gr(t.y,e.y)}</span><span class="s1">function </span><span class="s0">vr(t){</span><span class="s1">return </span><span class="s0">po(t.x)/po(t.y)}</span><span class="s1">function </span><span class="s0">xr(t,e){</span><span class="s1">return </span><span class="s0">t.translate===e.translate&amp;&amp;t.scale===e.scale&amp;&amp;t.originPoint===e.originPoint}</span><span class="s1">class </span><span class="s0">wr{constructor(){</span><span class="s1">this</span><span class="s0">.members=[]}add(t){x(</span><span class="s1">this</span><span class="s0">.members,t),t.scheduleRender()}remove(t){</span><span class="s1">if</span><span class="s0">(w(</span><span class="s1">this</span><span class="s0">.members,t),t===</span><span class="s1">this</span><span class="s0">.prevLead&amp;&amp;(</span><span class="s1">this</span><span class="s0">.prevLead=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">),t===</span><span class="s1">this</span><span class="s0">.lead){</span><span class="s1">const </span><span class="s0">t=</span><span class="s1">this</span><span class="s0">.members[</span><span class="s1">this</span><span class="s0">.members.length-</span><span class="s3">1</span><span class="s0">];t&amp;&amp;</span><span class="s1">this</span><span class="s0">.promote(t)}}relegate(t){</span><span class="s1">const </span><span class="s0">e=</span><span class="s1">this</span><span class="s0">.members.findIndex(e=&gt;t===e);</span><span class="s1">if</span><span class="s0">(</span><span class="s3">0</span><span class="s0">===e)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">let </span><span class="s0">n;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">t=e;t&gt;=</span><span class="s3">0</span><span class="s0">;t--){</span><span class="s1">const </span><span class="s0">e=</span><span class="s1">this</span><span class="s0">.members[t];</span><span class="s1">if</span><span class="s0">(!</span><span class="s3">1</span><span class="s0">!==e.isPresent){n=e;</span><span class="s1">break</span><span class="s0">}}</span><span class="s1">return</span><span class="s0">!!n&amp;&amp;(</span><span class="s1">this</span><span class="s0">.promote(n),!</span><span class="s3">0</span><span class="s0">)}promote(t,e){</span><span class="s1">const </span><span class="s0">n=</span><span class="s1">this</span><span class="s0">.lead;</span><span class="s1">if</span><span class="s0">(t!==n&amp;&amp;(</span><span class="s1">this</span><span class="s0">.prevLead=n,</span><span class="s1">this</span><span class="s0">.lead=t,t.show(),n)){n.instance&amp;&amp;n.scheduleRender(),t.scheduleRender(),t.resumeFrom=n,e&amp;&amp;(t.resumeFrom.preserveOpacity=!</span><span class="s3">0</span><span class="s0">),n.snapshot&amp;&amp;(t.snapshot=n.snapshot,t.snapshot.latestValues=n.animationValues||n.latestValues),t.root&amp;&amp;t.root.isUpdating&amp;&amp;(t.isLayoutDirty=!</span><span class="s3">0</span><span class="s0">);</span><span class="s1">const</span><span class="s0">{crossfade:i}=t.options;!</span><span class="s3">1</span><span class="s0">===i&amp;&amp;n.hide()}}exitAnimationComplete(){</span><span class="s1">this</span><span class="s0">.members.forEach(t=&gt;{</span><span class="s1">const</span><span class="s0">{options:e,resumingFrom:n}=t;e.onExitComplete&amp;&amp;e.onExitComplete(),n&amp;&amp;n.options.onExitComplete&amp;&amp;n.options.onExitComplete()})}scheduleRender(){</span><span class="s1">this</span><span class="s0">.members.forEach(t=&gt;{t.instance&amp;&amp;t.scheduleRender(!</span><span class="s3">1</span><span class="s0">)})}removeLeadSnapshot(){</span><span class="s1">this</span><span class="s0">.lead&amp;&amp;</span><span class="s1">this</span><span class="s0">.lead.snapshot&amp;&amp;(</span><span class="s1">this</span><span class="s0">.lead.snapshot=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">)}}</span><span class="s1">const </span><span class="s0">Tr={};</span><span class="s1">function </span><span class="s0">Pr(t){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">e </span><span class="s1">in </span><span class="s0">t)Tr[e]=t[e],gt(e)&amp;&amp;(Tr[e].isCSSVariable=!</span><span class="s3">0</span><span class="s0">)}</span><span class="s1">function </span><span class="s0">br(t){</span><span class="s1">return</span><span class="s0">[t(</span><span class="s2">&quot;x&quot;</span><span class="s0">),t(</span><span class="s2">&quot;y&quot;</span><span class="s0">)]}</span><span class="s1">const </span><span class="s0">Sr={hasAnimatedSinceResize:!</span><span class="s3">0</span><span class="s0">,hasEverUpdated:!</span><span class="s3">1</span><span class="s0">},Er={nodes:</span><span class="s3">0</span><span class="s0">,calculatedTargetDeltas:</span><span class="s3">0</span><span class="s0">,calculatedProjections:</span><span class="s3">0</span><span class="s0">},Ar=[</span><span class="s2">&quot;&quot;</span><span class="s0">,</span><span class="s2">&quot;X&quot;</span><span class="s0">,</span><span class="s2">&quot;Y&quot;</span><span class="s0">,</span><span class="s2">&quot;Z&quot;</span><span class="s0">];</span><span class="s1">let </span><span class="s0">Mr=</span><span class="s3">0</span><span class="s0">;</span><span class="s1">function </span><span class="s0">Cr(t,e,n,i){</span><span class="s1">const</span><span class="s0">{latestValues:s}=e;s[t]&amp;&amp;(n[t]=s[t],e.setStaticValue(t,</span><span class="s3">0</span><span class="s0">),i&amp;&amp;(i[t]=</span><span class="s3">0</span><span class="s0">))}</span><span class="s1">function </span><span class="s0">Vr(t){</span><span class="s1">if</span><span class="s0">(t.hasCheckedOptimisedAppear=!</span><span class="s3">0</span><span class="s0">,t.root===t)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">const</span><span class="s0">{visualElement:e}=t.options;</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">const </span><span class="s0">n=Ro(e);</span><span class="s1">if</span><span class="s0">(window.MotionHasOptimisedAnimation(n,</span><span class="s2">&quot;transform&quot;</span><span class="s0">)){</span><span class="s1">const</span><span class="s0">{layout:e,layoutId:i}=t.options;window.MotionCancelOptimisedAnimation(n,</span><span class="s2">&quot;transform&quot;</span><span class="s0">,at,!(e||i))}</span><span class="s1">const</span><span class="s0">{parent:i}=t;i&amp;&amp;!i.hasCheckedOptimisedAppear&amp;&amp;Vr(i)}</span><span class="s1">function </span><span class="s0">Dr({attachResizeListener:t,defaultParent:e,measureScroll:n,checkIsScrollRoot:i,resetTransform:s}){</span><span class="s1">return class</span><span class="s0">{constructor(t={},n=e?.()){</span><span class="s1">this</span><span class="s0">.id=Mr++,</span><span class="s1">this</span><span class="s0">.animationId=</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.animationCommitId=</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.children=</span><span class="s1">new </span><span class="s0">Set,</span><span class="s1">this</span><span class="s0">.options={},</span><span class="s1">this</span><span class="s0">.isTreeAnimating=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.isAnimationBlocked=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.isLayoutDirty=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.isProjectionDirty=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.isSharedProjectionDirty=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.isTransformDirty=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.updateManuallyBlocked=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.updateBlockedByResize=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.isUpdating=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.isSVG=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.needsReset=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.shouldResetTransform=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.hasCheckedOptimisedAppear=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.treeScale={x:</span><span class="s3">1</span><span class="s0">,y:</span><span class="s3">1</span><span class="s0">},</span><span class="s1">this</span><span class="s0">.eventHandlers=</span><span class="s1">new </span><span class="s0">Map,</span><span class="s1">this</span><span class="s0">.hasTreeAnimated=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.updateScheduled=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.scheduleUpdate=()=&gt;</span><span class="s1">this</span><span class="s0">.update(),</span><span class="s1">this</span><span class="s0">.projectionUpdateScheduled=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.checkUpdateFailed=()=&gt;{</span><span class="s1">this</span><span class="s0">.isUpdating&amp;&amp;(</span><span class="s1">this</span><span class="s0">.isUpdating=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.clearAllSnapshots())},</span><span class="s1">this</span><span class="s0">.updateProjection=()=&gt;{</span><span class="s1">this</span><span class="s0">.projectionUpdateScheduled=!</span><span class="s3">1</span><span class="s0">,ot.value&amp;&amp;(Er.nodes=Er.calculatedTargetDeltas=Er.calculatedProjections=</span><span class="s3">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.nodes.forEach(Lr),</span><span class="s1">this</span><span class="s0">.nodes.forEach(Ur),</span><span class="s1">this</span><span class="s0">.nodes.forEach(Nr),</span><span class="s1">this</span><span class="s0">.nodes.forEach(Or),ot.addProjectionMetrics&amp;&amp;ot.addProjectionMetrics(Er)},</span><span class="s1">this</span><span class="s0">.resolvedRelativeTargetAt=</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.hasProjected=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.isVisible=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.animationProgress=</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.sharedNodes=</span><span class="s1">new </span><span class="s0">Map,</span><span class="s1">this</span><span class="s0">.latestValues=t,</span><span class="s1">this</span><span class="s0">.root=n?n.root||n:</span><span class="s1">this</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.path=n?[...n.path,n]:[],</span><span class="s1">this</span><span class="s0">.parent=n,</span><span class="s1">this</span><span class="s0">.depth=n?n.depth+</span><span class="s3">1</span><span class="s0">:</span><span class="s3">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">t=</span><span class="s3">0</span><span class="s0">;t&lt;</span><span class="s1">this</span><span class="s0">.path.length;t++)</span><span class="s1">this</span><span class="s0">.path[t].shouldResetTransform=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.root===</span><span class="s1">this</span><span class="s0">&amp;&amp;(</span><span class="s1">this</span><span class="s0">.nodes=</span><span class="s1">new </span><span class="s0">Lo)}addEventListener(t,e){</span><span class="s1">return this</span><span class="s0">.eventHandlers.has(t)||</span><span class="s1">this</span><span class="s0">.eventHandlers.set(t,</span><span class="s1">new </span><span class="s0">L),</span><span class="s1">this</span><span class="s0">.eventHandlers.get(t).add(e)}notifyListeners(t,...e){</span><span class="s1">const </span><span class="s0">n=</span><span class="s1">this</span><span class="s0">.eventHandlers.get(t);n&amp;&amp;n.notify(...e)}hasListeners(t){</span><span class="s1">return this</span><span class="s0">.eventHandlers.has(t)}mount(e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.instance)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.isSVG=rs(e)&amp;&amp;!As(e),</span><span class="s1">this</span><span class="s0">.instance=e;</span><span class="s1">const</span><span class="s0">{layoutId:n,layout:i,visualElement:s}=</span><span class="s1">this</span><span class="s0">.options;</span><span class="s1">if</span><span class="s0">(s&amp;&amp;!s.current&amp;&amp;s.mount(e),</span><span class="s1">this</span><span class="s0">.root.nodes.add(</span><span class="s1">this</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.parent&amp;&amp;</span><span class="s1">this</span><span class="s0">.parent.children.add(</span><span class="s1">this</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.root.hasTreeAnimated&amp;&amp;(i||n)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.isLayoutDirty=!</span><span class="s3">0</span><span class="s0">),t){</span><span class="s1">let </span><span class="s0">n,i=</span><span class="s3">0</span><span class="s0">;</span><span class="s1">const </span><span class="s0">s=()=&gt;</span><span class="s1">this</span><span class="s0">.root.updateBlockedByResize=!</span><span class="s3">1</span><span class="s0">;at.read(()=&gt;{i=window.innerWidth}),t(e,()=&gt;{</span><span class="s1">const </span><span class="s0">t=window.innerWidth;t!==i&amp;&amp;(i=t,</span><span class="s1">this</span><span class="s0">.root.updateBlockedByResize=!</span><span class="s3">0</span><span class="s0">,n&amp;&amp;n(),n=Oo(s,</span><span class="s3">250</span><span class="s0">),Sr.hasAnimatedSinceResize&amp;&amp;(Sr.hasAnimatedSinceResize=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.nodes.forEach(Wr)))})}n&amp;&amp;</span><span class="s1">this</span><span class="s0">.root.registerSharedNode(n,</span><span class="s1">this</span><span class="s0">),!</span><span class="s3">1</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.options.animate&amp;&amp;s&amp;&amp;(n||i)&amp;&amp;</span><span class="s1">this</span><span class="s0">.addEventListener(</span><span class="s2">&quot;didUpdate&quot;</span><span class="s0">,({delta:t,hasLayoutChanged:e,hasRelativeLayoutChanged:n,layout:i})=&gt;{</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isTreeAnimationBlocked())</span><span class="s1">return this</span><span class="s0">.target=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">void</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.relativeTarget=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">);</span><span class="s1">const </span><span class="s0">o=</span><span class="s1">this</span><span class="s0">.options.transition||s.getDefaultTransition()||Kr,{onLayoutAnimationStart:r,onLayoutAnimationComplete:a}=s.getProps(),l=!</span><span class="s1">this</span><span class="s0">.targetLayout||!yr(</span><span class="s1">this</span><span class="s0">.targetLayout,i),u=!e&amp;&amp;n;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.options.layoutRoot||</span><span class="s1">this</span><span class="s0">.resumeFrom||u||e&amp;&amp;(l||!</span><span class="s1">this</span><span class="s0">.currentAnimation)){</span><span class="s1">this</span><span class="s0">.resumeFrom&amp;&amp;(</span><span class="s1">this</span><span class="s0">.resumingFrom=</span><span class="s1">this</span><span class="s0">.resumeFrom,</span><span class="s1">this</span><span class="s0">.resumingFrom.resumingFrom=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">);</span><span class="s1">const </span><span class="s0">e={...ii(o,</span><span class="s2">&quot;layout&quot;</span><span class="s0">),onPlay:r,onComplete:a};(s.shouldReduceMotion||</span><span class="s1">this</span><span class="s0">.options.layoutRoot)&amp;&amp;(e.delay=</span><span class="s3">0</span><span class="s0">,e.type=!</span><span class="s3">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.startAnimation(e),</span><span class="s1">this</span><span class="s0">.setAnimationOrigin(t,u)}</span><span class="s1">else </span><span class="s0">e||Wr(</span><span class="s1">this</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.isLead()&amp;&amp;</span><span class="s1">this</span><span class="s0">.options.onExitComplete&amp;&amp;</span><span class="s1">this</span><span class="s0">.options.onExitComplete();</span><span class="s1">this</span><span class="s0">.targetLayout=i})}unmount(){</span><span class="s1">this</span><span class="s0">.options.layoutId&amp;&amp;</span><span class="s1">this</span><span class="s0">.willUpdate(),</span><span class="s1">this</span><span class="s0">.root.nodes.remove(</span><span class="s1">this</span><span class="s0">);</span><span class="s1">const </span><span class="s0">t=</span><span class="s1">this</span><span class="s0">.getStack();t&amp;&amp;t.remove(</span><span class="s1">this</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.parent&amp;&amp;</span><span class="s1">this</span><span class="s0">.parent.children.delete(</span><span class="s1">this</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.instance=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.eventHandlers.clear(),lt(</span><span class="s1">this</span><span class="s0">.updateProjection)}blockUpdate(){</span><span class="s1">this</span><span class="s0">.updateManuallyBlocked=!</span><span class="s3">0</span><span class="s0">}unblockUpdate(){</span><span class="s1">this</span><span class="s0">.updateManuallyBlocked=!</span><span class="s3">1</span><span class="s0">}isUpdateBlocked(){</span><span class="s1">return this</span><span class="s0">.updateManuallyBlocked||</span><span class="s1">this</span><span class="s0">.updateBlockedByResize}isTreeAnimationBlocked(){</span><span class="s1">return this</span><span class="s0">.isAnimationBlocked||</span><span class="s1">this</span><span class="s0">.parent&amp;&amp;</span><span class="s1">this</span><span class="s0">.parent.isTreeAnimationBlocked()||!</span><span class="s3">1</span><span class="s0">}startUpdate(){</span><span class="s1">this</span><span class="s0">.isUpdateBlocked()||(</span><span class="s1">this</span><span class="s0">.isUpdating=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.nodes&amp;&amp;</span><span class="s1">this</span><span class="s0">.nodes.forEach($r),</span><span class="s1">this</span><span class="s0">.animationId++)}getTransformTemplate(){</span><span class="s1">const</span><span class="s0">{visualElement:t}=</span><span class="s1">this</span><span class="s0">.options;</span><span class="s1">return </span><span class="s0">t&amp;&amp;t.getProps().transformTemplate}willUpdate(t=!</span><span class="s3">0</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.root.hasTreeAnimated=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.root.isUpdateBlocked())</span><span class="s1">return void</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.options.onExitComplete&amp;&amp;</span><span class="s1">this</span><span class="s0">.options.onExitComplete());</span><span class="s1">if</span><span class="s0">(window.MotionCancelOptimisedAnimation&amp;&amp;!</span><span class="s1">this</span><span class="s0">.hasCheckedOptimisedAppear&amp;&amp;Vr(</span><span class="s1">this</span><span class="s0">),!</span><span class="s1">this</span><span class="s0">.root.isUpdating&amp;&amp;</span><span class="s1">this</span><span class="s0">.root.startUpdate(),</span><span class="s1">this</span><span class="s0">.isLayoutDirty)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.isLayoutDirty=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">t=</span><span class="s3">0</span><span class="s0">;t&lt;</span><span class="s1">this</span><span class="s0">.path.length;t++){</span><span class="s1">const </span><span class="s0">e=</span><span class="s1">this</span><span class="s0">.path[t];e.shouldResetTransform=!</span><span class="s3">0</span><span class="s0">,e.updateScroll(</span><span class="s2">&quot;snapshot&quot;</span><span class="s0">),e.options.layoutRoot&amp;&amp;e.willUpdate(!</span><span class="s3">1</span><span class="s0">)}</span><span class="s1">const</span><span class="s0">{layoutId:e,layout:n}=</span><span class="s1">this</span><span class="s0">.options;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===e&amp;&amp;!n)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">const </span><span class="s0">i=</span><span class="s1">this</span><span class="s0">.getTransformTemplate();</span><span class="s1">this</span><span class="s0">.prevTransformTemplateValue=i?i(</span><span class="s1">this</span><span class="s0">.latestValues,</span><span class="s2">&quot;&quot;</span><span class="s0">):</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.updateSnapshot(),t&amp;&amp;</span><span class="s1">this</span><span class="s0">.notifyListeners(</span><span class="s2">&quot;willUpdate&quot;</span><span class="s0">)}update(){</span><span class="s1">this</span><span class="s0">.updateScheduled=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isUpdateBlocked())</span><span class="s1">return this</span><span class="s0">.unblockUpdate(),</span><span class="s1">this</span><span class="s0">.clearAllSnapshots(),</span><span class="s1">void this</span><span class="s0">.nodes.forEach(Br);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.animationId&lt;=</span><span class="s1">this</span><span class="s0">.animationCommitId)</span><span class="s1">return void this</span><span class="s0">.nodes.forEach(Ir);</span><span class="s1">this</span><span class="s0">.animationCommitId=</span><span class="s1">this</span><span class="s0">.animationId,</span><span class="s1">this</span><span class="s0">.isUpdating?(</span><span class="s1">this</span><span class="s0">.isUpdating=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.nodes.forEach(Fr),</span><span class="s1">this</span><span class="s0">.nodes.forEach(Rr),</span><span class="s1">this</span><span class="s0">.nodes.forEach(kr)):</span><span class="s1">this</span><span class="s0">.nodes.forEach(Ir),</span><span class="s1">this</span><span class="s0">.clearAllSnapshots();</span><span class="s1">const </span><span class="s0">t=pt.now();ut.delta=P(</span><span class="s3">0</span><span class="s0">,</span><span class="s3">1e3</span><span class="s0">/</span><span class="s3">60</span><span class="s0">,t-ut.timestamp),ut.timestamp=t,ut.isProcessing=!</span><span class="s3">0</span><span class="s0">,ct.update.process(ut),ct.preRender.process(ut),ct.render.process(ut),ut.isProcessing=!</span><span class="s3">1</span><span class="s0">}didUpdate(){</span><span class="s1">this</span><span class="s0">.updateScheduled||(</span><span class="s1">this</span><span class="s0">.updateScheduled=!</span><span class="s3">0</span><span class="s0">,zi.read(</span><span class="s1">this</span><span class="s0">.scheduleUpdate))}clearAllSnapshots(){</span><span class="s1">this</span><span class="s0">.nodes.forEach(jr),</span><span class="s1">this</span><span class="s0">.sharedNodes.forEach(zr)}scheduleUpdateProjection(){</span><span class="s1">this</span><span class="s0">.projectionUpdateScheduled||(</span><span class="s1">this</span><span class="s0">.projectionUpdateScheduled=!</span><span class="s3">0</span><span class="s0">,at.preRender(</span><span class="s1">this</span><span class="s0">.updateProjection,!</span><span class="s3">1</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">))}scheduleCheckAfterUnmount(){at.postRender(()=&gt;{</span><span class="s1">this</span><span class="s0">.isLayoutDirty?</span><span class="s1">this</span><span class="s0">.root.didUpdate():</span><span class="s1">this</span><span class="s0">.root.checkUpdateFailed()})}updateSnapshot(){!</span><span class="s1">this</span><span class="s0">.snapshot&amp;&amp;</span><span class="s1">this</span><span class="s0">.instance&amp;&amp;(</span><span class="s1">this</span><span class="s0">.snapshot=</span><span class="s1">this</span><span class="s0">.measure(),!</span><span class="s1">this</span><span class="s0">.snapshot||po(</span><span class="s1">this</span><span class="s0">.snapshot.measuredBox.x)||po(</span><span class="s1">this</span><span class="s0">.snapshot.measuredBox.y)||(</span><span class="s1">this</span><span class="s0">.snapshot=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">))}updateLayout(){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.instance)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.updateScroll(),!(</span><span class="s1">this</span><span class="s0">.options.alwaysMeasureLayout&amp;&amp;</span><span class="s1">this</span><span class="s0">.isLead()||</span><span class="s1">this</span><span class="s0">.isLayoutDirty))</span><span class="s1">return</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.resumeFrom&amp;&amp;!</span><span class="s1">this</span><span class="s0">.resumeFrom.instance)</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">t=</span><span class="s3">0</span><span class="s0">;t&lt;</span><span class="s1">this</span><span class="s0">.path.length;t++){</span><span class="s1">this</span><span class="s0">.path[t].updateScroll()}</span><span class="s1">const </span><span class="s0">t=</span><span class="s1">this</span><span class="s0">.layout;</span><span class="s1">this</span><span class="s0">.layout=</span><span class="s1">this</span><span class="s0">.measure(!</span><span class="s3">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.layoutCorrected={x:{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">},y:{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">}},</span><span class="s1">this</span><span class="s0">.isLayoutDirty=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.projectionDelta=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.notifyListeners(</span><span class="s2">&quot;measure&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.layout.layoutBox);</span><span class="s1">const</span><span class="s0">{visualElement:e}=</span><span class="s1">this</span><span class="s0">.options;e&amp;&amp;e.notify(</span><span class="s2">&quot;LayoutMeasure&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.layout.layoutBox,t?t.layoutBox:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">)}updateScroll(t=</span><span class="s2">&quot;measure&quot;</span><span class="s0">){</span><span class="s1">let </span><span class="s0">e=Boolean(</span><span class="s1">this</span><span class="s0">.options.layoutScroll&amp;&amp;</span><span class="s1">this</span><span class="s0">.instance);</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.scroll&amp;&amp;</span><span class="s1">this</span><span class="s0">.scroll.animationId===</span><span class="s1">this</span><span class="s0">.root.animationId&amp;&amp;</span><span class="s1">this</span><span class="s0">.scroll.phase===t&amp;&amp;(e=!</span><span class="s3">1</span><span class="s0">),e&amp;&amp;</span><span class="s1">this</span><span class="s0">.instance){</span><span class="s1">const </span><span class="s0">e=i(</span><span class="s1">this</span><span class="s0">.instance);</span><span class="s1">this</span><span class="s0">.scroll={animationId:</span><span class="s1">this</span><span class="s0">.root.animationId,phase:t,isRoot:e,offset:n(</span><span class="s1">this</span><span class="s0">.instance),wasRoot:</span><span class="s1">this</span><span class="s0">.scroll?</span><span class="s1">this</span><span class="s0">.scroll.isRoot:e}}}resetTransform(){</span><span class="s1">if</span><span class="s0">(!s)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">const </span><span class="s0">t=</span><span class="s1">this</span><span class="s0">.isLayoutDirty||</span><span class="s1">this</span><span class="s0">.shouldResetTransform||</span><span class="s1">this</span><span class="s0">.options.alwaysMeasureLayout,e=</span><span class="s1">this</span><span class="s0">.projectionDelta&amp;&amp;!mr(</span><span class="s1">this</span><span class="s0">.projectionDelta),n=</span><span class="s1">this</span><span class="s0">.getTransformTemplate(),i=n?n(</span><span class="s1">this</span><span class="s0">.latestValues,</span><span class="s2">&quot;&quot;</span><span class="s0">):</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,o=i!==</span><span class="s1">this</span><span class="s0">.prevTransformTemplateValue;t&amp;&amp;</span><span class="s1">this</span><span class="s0">.instance&amp;&amp;(e||_o(</span><span class="s1">this</span><span class="s0">.latestValues)||o)&amp;&amp;(s(</span><span class="s1">this</span><span class="s0">.instance,i),</span><span class="s1">this</span><span class="s0">.shouldResetTransform=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.scheduleRender())}measure(t=!</span><span class="s3">0</span><span class="s0">){</span><span class="s1">const </span><span class="s0">e=</span><span class="s1">this</span><span class="s0">.measurePageBox();</span><span class="s1">let </span><span class="s0">n=</span><span class="s1">this</span><span class="s0">.removeElementScroll(e);</span><span class="s1">var </span><span class="s0">i;</span><span class="s1">return </span><span class="s0">t&amp;&amp;(n=</span><span class="s1">this</span><span class="s0">.removeTransform(n)),Zr((i=n).x),Zr(i.y),{animationId:</span><span class="s1">this</span><span class="s0">.root.animationId,measuredBox:e,layoutBox:n,latestValues:{},source:</span><span class="s1">this</span><span class="s0">.id}}measurePageBox(){</span><span class="s1">const</span><span class="s0">{visualElement:t}=</span><span class="s1">this</span><span class="s0">.options;</span><span class="s1">if</span><span class="s0">(!t)</span><span class="s1">return</span><span class="s0">{x:{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">},y:{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">}};</span><span class="s1">const </span><span class="s0">e=t.measureViewportBox();</span><span class="s1">if</span><span class="s0">(!(</span><span class="s1">this</span><span class="s0">.scroll?.wasRoot||</span><span class="s1">this</span><span class="s0">.path.some(Jr))){</span><span class="s1">const</span><span class="s0">{scroll:t}=</span><span class="s1">this</span><span class="s0">.root;t&amp;&amp;(sr(e.x,t.offset.x),sr(e.y,t.offset.y))}</span><span class="s1">return </span><span class="s0">e}removeElementScroll(t){</span><span class="s1">const </span><span class="s0">e={x:{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">},y:{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">}};</span><span class="s1">if</span><span class="s0">(Ho(e,t),</span><span class="s1">this</span><span class="s0">.scroll?.wasRoot)</span><span class="s1">return </span><span class="s0">e;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">n=</span><span class="s3">0</span><span class="s0">;n&lt;</span><span class="s1">this</span><span class="s0">.path.length;n++){</span><span class="s1">const </span><span class="s0">i=</span><span class="s1">this</span><span class="s0">.path[n],{scroll:s,options:o}=i;i!==</span><span class="s1">this</span><span class="s0">.root&amp;&amp;s&amp;&amp;o.layoutScroll&amp;&amp;(s.wasRoot&amp;&amp;Ho(e,t),sr(e.x,s.offset.x),sr(e.y,s.offset.y))}</span><span class="s1">return </span><span class="s0">e}applyTransform(t,e=!</span><span class="s3">1</span><span class="s0">){</span><span class="s1">const </span><span class="s0">n={x:{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">},y:{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">}};Ho(n,t);</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">t=</span><span class="s3">0</span><span class="s0">;t&lt;</span><span class="s1">this</span><span class="s0">.path.length;t++){</span><span class="s1">const </span><span class="s0">i=</span><span class="s1">this</span><span class="s0">.path[t];!e&amp;&amp;i.options.layoutScroll&amp;&amp;i.scroll&amp;&amp;i!==i.root&amp;&amp;rr(n,{x:-i.scroll.offset.x,y:-i.scroll.offset.y}),_o(i.latestValues)&amp;&amp;rr(n,i.latestValues)}</span><span class="s1">return </span><span class="s0">_o(</span><span class="s1">this</span><span class="s0">.latestValues)&amp;&amp;rr(n,</span><span class="s1">this</span><span class="s0">.latestValues),n}removeTransform(t){</span><span class="s1">const </span><span class="s0">e={x:{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">},y:{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">}};Ho(e,t);</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">t=</span><span class="s3">0</span><span class="s0">;t&lt;</span><span class="s1">this</span><span class="s0">.path.length;t++){</span><span class="s1">const </span><span class="s0">n=</span><span class="s1">this</span><span class="s0">.path[t];</span><span class="s1">if</span><span class="s0">(!n.instance)</span><span class="s1">continue</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(!_o(n.latestValues))</span><span class="s1">continue</span><span class="s0">;Go(n.latestValues)&amp;&amp;n.updateSnapshot();</span><span class="s1">const </span><span class="s0">i=dr();Ho(i,n.measurePageBox()),hr(e,n.latestValues,n.snapshot?n.snapshot.layoutBox:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,i)}</span><span class="s1">return </span><span class="s0">_o(</span><span class="s1">this</span><span class="s0">.latestValues)&amp;&amp;hr(e,</span><span class="s1">this</span><span class="s0">.latestValues),e}setTargetDelta(t){</span><span class="s1">this</span><span class="s0">.targetDelta=t,</span><span class="s1">this</span><span class="s0">.root.scheduleUpdateProjection(),</span><span class="s1">this</span><span class="s0">.isProjectionDirty=!</span><span class="s3">0</span><span class="s0">}setOptions(t){</span><span class="s1">this</span><span class="s0">.options={...</span><span class="s1">this</span><span class="s0">.options,...t,crossfade:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===t.crossfade||t.crossfade}}clearMeasurements(){</span><span class="s1">this</span><span class="s0">.scroll=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.layout=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.snapshot=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.prevTransformTemplateValue=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.targetDelta=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.target=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.isLayoutDirty=!</span><span class="s3">1</span><span class="s0">}forceRelativeParentToResolveTarget(){</span><span class="s1">this</span><span class="s0">.relativeParent&amp;&amp;</span><span class="s1">this</span><span class="s0">.relativeParent.resolvedRelativeTargetAt!==ut.timestamp&amp;&amp;</span><span class="s1">this</span><span class="s0">.relativeParent.resolveTargetDelta(!</span><span class="s3">0</span><span class="s0">)}resolveTargetDelta(t=!</span><span class="s3">1</span><span class="s0">){</span><span class="s1">const </span><span class="s0">e=</span><span class="s1">this</span><span class="s0">.getLead();</span><span class="s1">this</span><span class="s0">.isProjectionDirty||(</span><span class="s1">this</span><span class="s0">.isProjectionDirty=e.isProjectionDirty),</span><span class="s1">this</span><span class="s0">.isTransformDirty||(</span><span class="s1">this</span><span class="s0">.isTransformDirty=e.isTransformDirty),</span><span class="s1">this</span><span class="s0">.isSharedProjectionDirty||(</span><span class="s1">this</span><span class="s0">.isSharedProjectionDirty=e.isSharedProjectionDirty);</span><span class="s1">const </span><span class="s0">n=Boolean(</span><span class="s1">this</span><span class="s0">.resumingFrom)||</span><span class="s1">this</span><span class="s0">!==e;</span><span class="s1">if</span><span class="s0">(!(t||n&amp;&amp;</span><span class="s1">this</span><span class="s0">.isSharedProjectionDirty||</span><span class="s1">this</span><span class="s0">.isProjectionDirty||</span><span class="s1">this</span><span class="s0">.parent?.isProjectionDirty||</span><span class="s1">this</span><span class="s0">.attemptToResolveRelativeTarget||</span><span class="s1">this</span><span class="s0">.root.updateBlockedByResize))</span><span class="s1">return</span><span class="s0">;</span><span class="s1">const</span><span class="s0">{layout:i,layoutId:s}=</span><span class="s1">this</span><span class="s0">.options;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.layout&amp;&amp;(i||s)){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.resolvedRelativeTargetAt=ut.timestamp,!</span><span class="s1">this</span><span class="s0">.targetDelta&amp;&amp;!</span><span class="s1">this</span><span class="s0">.relativeTarget){</span><span class="s1">const </span><span class="s0">t=</span><span class="s1">this</span><span class="s0">.getClosestProjectingParent();t&amp;&amp;t.layout&amp;&amp;</span><span class="s3">1</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.animationProgress?(</span><span class="s1">this</span><span class="s0">.relativeParent=t,</span><span class="s1">this</span><span class="s0">.forceRelativeParentToResolveTarget(),</span><span class="s1">this</span><span class="s0">.relativeTarget={x:{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">},y:{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">}},</span><span class="s1">this</span><span class="s0">.relativeTargetOrigin={x:{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">},y:{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">}},vo(</span><span class="s1">this</span><span class="s0">.relativeTargetOrigin,</span><span class="s1">this</span><span class="s0">.layout.layoutBox,t.layout.layoutBox),Ho(</span><span class="s1">this</span><span class="s0">.relativeTarget,</span><span class="s1">this</span><span class="s0">.relativeTargetOrigin)):</span><span class="s1">this</span><span class="s0">.relativeParent=</span><span class="s1">this</span><span class="s0">.relativeTarget=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.relativeTarget||</span><span class="s1">this</span><span class="s0">.targetDelta){</span><span class="s1">var </span><span class="s0">o,r,a;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.target||(</span><span class="s1">this</span><span class="s0">.target={x:{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">},y:{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">}},</span><span class="s1">this</span><span class="s0">.targetWithTransforms={x:{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">},y:{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">}}),</span><span class="s1">this</span><span class="s0">.relativeTarget&amp;&amp;</span><span class="s1">this</span><span class="s0">.relativeTargetOrigin&amp;&amp;</span><span class="s1">this</span><span class="s0">.relativeParent&amp;&amp;</span><span class="s1">this</span><span class="s0">.relativeParent.target?(</span><span class="s1">this</span><span class="s0">.forceRelativeParentToResolveTarget(),o=</span><span class="s1">this</span><span class="s0">.target,r=</span><span class="s1">this</span><span class="s0">.relativeTarget,a=</span><span class="s1">this</span><span class="s0">.relativeParent.target,go(o.x,r.x,a.x),go(o.y,r.y,a.y)):</span><span class="s1">this</span><span class="s0">.targetDelta?(Boolean(</span><span class="s1">this</span><span class="s0">.resumingFrom)?</span><span class="s1">this</span><span class="s0">.target=</span><span class="s1">this</span><span class="s0">.applyTransform(</span><span class="s1">this</span><span class="s0">.layout.layoutBox):Ho(</span><span class="s1">this</span><span class="s0">.target,</span><span class="s1">this</span><span class="s0">.layout.layoutBox),er(</span><span class="s1">this</span><span class="s0">.target,</span><span class="s1">this</span><span class="s0">.targetDelta)):Ho(</span><span class="s1">this</span><span class="s0">.target,</span><span class="s1">this</span><span class="s0">.layout.layoutBox),</span><span class="s1">this</span><span class="s0">.attemptToResolveRelativeTarget){</span><span class="s1">this</span><span class="s0">.attemptToResolveRelativeTarget=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">const </span><span class="s0">t=</span><span class="s1">this</span><span class="s0">.getClosestProjectingParent();t&amp;&amp;Boolean(t.resumingFrom)===Boolean(</span><span class="s1">this</span><span class="s0">.resumingFrom)&amp;&amp;!t.options.layoutScroll&amp;&amp;t.target&amp;&amp;</span><span class="s3">1</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.animationProgress?(</span><span class="s1">this</span><span class="s0">.relativeParent=t,</span><span class="s1">this</span><span class="s0">.forceRelativeParentToResolveTarget(),</span><span class="s1">this</span><span class="s0">.relativeTarget={x:{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">},y:{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">}},</span><span class="s1">this</span><span class="s0">.relativeTargetOrigin={x:{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">},y:{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">}},vo(</span><span class="s1">this</span><span class="s0">.relativeTargetOrigin,</span><span class="s1">this</span><span class="s0">.target,t.target),Ho(</span><span class="s1">this</span><span class="s0">.relativeTarget,</span><span class="s1">this</span><span class="s0">.relativeTargetOrigin)):</span><span class="s1">this</span><span class="s0">.relativeParent=</span><span class="s1">this</span><span class="s0">.relativeTarget=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">}ot.value&amp;&amp;Er.calculatedTargetDeltas++}}}getClosestProjectingParent(){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.parent&amp;&amp;!Go(</span><span class="s1">this</span><span class="s0">.parent.latestValues)&amp;&amp;!Zo(</span><span class="s1">this</span><span class="s0">.parent.latestValues))</span><span class="s1">return this</span><span class="s0">.parent.isProjecting()?</span><span class="s1">this</span><span class="s0">.parent:</span><span class="s1">this</span><span class="s0">.parent.getClosestProjectingParent()}isProjecting(){</span><span class="s1">return </span><span class="s0">Boolean((</span><span class="s1">this</span><span class="s0">.relativeTarget||</span><span class="s1">this</span><span class="s0">.targetDelta||</span><span class="s1">this</span><span class="s0">.options.layoutRoot)&amp;&amp;</span><span class="s1">this</span><span class="s0">.layout)}calcProjection(){</span><span class="s1">const </span><span class="s0">t=</span><span class="s1">this</span><span class="s0">.getLead(),e=Boolean(</span><span class="s1">this</span><span class="s0">.resumingFrom)||</span><span class="s1">this</span><span class="s0">!==t;</span><span class="s1">let </span><span class="s0">n=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">((</span><span class="s1">this</span><span class="s0">.isProjectionDirty||</span><span class="s1">this</span><span class="s0">.parent?.isProjectionDirty)&amp;&amp;(n=!</span><span class="s3">1</span><span class="s0">),e&amp;&amp;(</span><span class="s1">this</span><span class="s0">.isSharedProjectionDirty||</span><span class="s1">this</span><span class="s0">.isTransformDirty)&amp;&amp;(n=!</span><span class="s3">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.resolvedRelativeTargetAt===ut.timestamp&amp;&amp;(n=!</span><span class="s3">1</span><span class="s0">),n)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">const</span><span class="s0">{layout:i,layoutId:s}=</span><span class="s1">this</span><span class="s0">.options;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isTreeAnimating=Boolean(</span><span class="s1">this</span><span class="s0">.parent&amp;&amp;</span><span class="s1">this</span><span class="s0">.parent.isTreeAnimating||</span><span class="s1">this</span><span class="s0">.currentAnimation||</span><span class="s1">this</span><span class="s0">.pendingAnimation),</span><span class="s1">this</span><span class="s0">.isTreeAnimating||(</span><span class="s1">this</span><span class="s0">.targetDelta=</span><span class="s1">this</span><span class="s0">.relativeTarget=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">),!</span><span class="s1">this</span><span class="s0">.layout||!i&amp;&amp;!s)</span><span class="s1">return</span><span class="s0">;Ho(</span><span class="s1">this</span><span class="s0">.layoutCorrected,</span><span class="s1">this</span><span class="s0">.layout.layoutBox);</span><span class="s1">const </span><span class="s0">o=</span><span class="s1">this</span><span class="s0">.treeScale.x,r=</span><span class="s1">this</span><span class="s0">.treeScale.y;!</span><span class="s1">function</span><span class="s0">(t,e,n,i=!</span><span class="s3">1</span><span class="s0">){</span><span class="s1">const </span><span class="s0">s=n.length;</span><span class="s1">if</span><span class="s0">(!s)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">let </span><span class="s0">o,r;e.x=e.y=</span><span class="s3">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">a=</span><span class="s3">0</span><span class="s0">;a&lt;s;a++){o=n[a],r=o.projectionDelta;</span><span class="s1">const</span><span class="s0">{visualElement:s}=o.options;s&amp;&amp;s.props.style&amp;&amp;</span><span class="s2">&quot;contents&quot;</span><span class="s0">===s.props.style.display||(i&amp;&amp;o.options.layoutScroll&amp;&amp;o.scroll&amp;&amp;o!==o.root&amp;&amp;rr(t,{x:-o.scroll.offset.x,y:-o.scroll.offset.y}),r&amp;&amp;(e.x*=r.x.scale,e.y*=r.y.scale,er(t,r)),i&amp;&amp;_o(o.latestValues)&amp;&amp;rr(t,o.latestValues))}e.x&lt;ir&amp;&amp;e.x&gt;nr&amp;&amp;(e.x=</span><span class="s3">1</span><span class="s0">),e.y&lt;ir&amp;&amp;e.y&gt;nr&amp;&amp;(e.y=</span><span class="s3">1</span><span class="s0">)}(</span><span class="s1">this</span><span class="s0">.layoutCorrected,</span><span class="s1">this</span><span class="s0">.treeScale,</span><span class="s1">this</span><span class="s0">.path,e),!t.layout||t.target||</span><span class="s3">1</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.treeScale.x&amp;&amp;</span><span class="s3">1</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.treeScale.y||(t.target=t.layout.layoutBox,t.targetWithTransforms={x:{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">},y:{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">}});</span><span class="s1">const</span><span class="s0">{target:a}=t;a?(</span><span class="s1">this</span><span class="s0">.projectionDelta&amp;&amp;</span><span class="s1">this</span><span class="s0">.prevProjectionDelta?(Yo(</span><span class="s1">this</span><span class="s0">.prevProjectionDelta.x,</span><span class="s1">this</span><span class="s0">.projectionDelta.x),Yo(</span><span class="s1">this</span><span class="s0">.prevProjectionDelta.y,</span><span class="s1">this</span><span class="s0">.projectionDelta.y)):</span><span class="s1">this</span><span class="s0">.createProjectionDeltas(),fo(</span><span class="s1">this</span><span class="s0">.projectionDelta,</span><span class="s1">this</span><span class="s0">.layoutCorrected,a,</span><span class="s1">this</span><span class="s0">.latestValues),</span><span class="s1">this</span><span class="s0">.treeScale.x===o&amp;&amp;</span><span class="s1">this</span><span class="s0">.treeScale.y===r&amp;&amp;xr(</span><span class="s1">this</span><span class="s0">.projectionDelta.x,</span><span class="s1">this</span><span class="s0">.prevProjectionDelta.x)&amp;&amp;xr(</span><span class="s1">this</span><span class="s0">.projectionDelta.y,</span><span class="s1">this</span><span class="s0">.prevProjectionDelta.y)||(</span><span class="s1">this</span><span class="s0">.hasProjected=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.scheduleRender(),</span><span class="s1">this</span><span class="s0">.notifyListeners(</span><span class="s2">&quot;projectionUpdate&quot;</span><span class="s0">,a)),ot.value&amp;&amp;Er.calculatedProjections++):</span><span class="s1">this</span><span class="s0">.prevProjectionDelta&amp;&amp;(</span><span class="s1">this</span><span class="s0">.createProjectionDeltas(),</span><span class="s1">this</span><span class="s0">.scheduleRender())}hide(){</span><span class="s1">this</span><span class="s0">.isVisible=!</span><span class="s3">1</span><span class="s0">}show(){</span><span class="s1">this</span><span class="s0">.isVisible=!</span><span class="s3">0</span><span class="s0">}scheduleRender(t=!</span><span class="s3">0</span><span class="s0">){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.options.visualElement?.scheduleRender(),t){</span><span class="s1">const </span><span class="s0">t=</span><span class="s1">this</span><span class="s0">.getStack();t&amp;&amp;t.scheduleRender()}</span><span class="s1">this</span><span class="s0">.resumingFrom&amp;&amp;!</span><span class="s1">this</span><span class="s0">.resumingFrom.instance&amp;&amp;(</span><span class="s1">this</span><span class="s0">.resumingFrom=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">)}createProjectionDeltas(){</span><span class="s1">this</span><span class="s0">.prevProjectionDelta={x:{translate:</span><span class="s3">0</span><span class="s0">,scale:</span><span class="s3">1</span><span class="s0">,origin:</span><span class="s3">0</span><span class="s0">,originPoint:</span><span class="s3">0</span><span class="s0">},y:{translate:</span><span class="s3">0</span><span class="s0">,scale:</span><span class="s3">1</span><span class="s0">,origin:</span><span class="s3">0</span><span class="s0">,originPoint:</span><span class="s3">0</span><span class="s0">}},</span><span class="s1">this</span><span class="s0">.projectionDelta={x:{translate:</span><span class="s3">0</span><span class="s0">,scale:</span><span class="s3">1</span><span class="s0">,origin:</span><span class="s3">0</span><span class="s0">,originPoint:</span><span class="s3">0</span><span class="s0">},y:{translate:</span><span class="s3">0</span><span class="s0">,scale:</span><span class="s3">1</span><span class="s0">,origin:</span><span class="s3">0</span><span class="s0">,originPoint:</span><span class="s3">0</span><span class="s0">}},</span><span class="s1">this</span><span class="s0">.projectionDeltaWithTransform={x:{translate:</span><span class="s3">0</span><span class="s0">,scale:</span><span class="s3">1</span><span class="s0">,origin:</span><span class="s3">0</span><span class="s0">,originPoint:</span><span class="s3">0</span><span class="s0">},y:{translate:</span><span class="s3">0</span><span class="s0">,scale:</span><span class="s3">1</span><span class="s0">,origin:</span><span class="s3">0</span><span class="s0">,originPoint:</span><span class="s3">0</span><span class="s0">}}}setAnimationOrigin(t,e=!</span><span class="s3">1</span><span class="s0">){</span><span class="s1">const </span><span class="s0">n=</span><span class="s1">this</span><span class="s0">.snapshot,i=n?n.latestValues:{},s={...</span><span class="s1">this</span><span class="s0">.latestValues},o={x:{translate:</span><span class="s3">0</span><span class="s0">,scale:</span><span class="s3">1</span><span class="s0">,origin:</span><span class="s3">0</span><span class="s0">,originPoint:</span><span class="s3">0</span><span class="s0">},y:{translate:</span><span class="s3">0</span><span class="s0">,scale:</span><span class="s3">1</span><span class="s0">,origin:</span><span class="s3">0</span><span class="s0">,originPoint:</span><span class="s3">0</span><span class="s0">}};</span><span class="s1">this</span><span class="s0">.relativeParent&amp;&amp;</span><span class="s1">this</span><span class="s0">.relativeParent.options.layoutRoot||(</span><span class="s1">this</span><span class="s0">.relativeTarget=</span><span class="s1">this</span><span class="s0">.relativeTargetOrigin=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.attemptToResolveRelativeTarget=!e;</span><span class="s1">const </span><span class="s0">r={x:{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">},y:{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">}},a=(n?n.source:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">)!==(</span><span class="s1">this</span><span class="s0">.layout?</span><span class="s1">this</span><span class="s0">.layout.source:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">),l=</span><span class="s1">this</span><span class="s0">.getStack(),u=!l||l.members.length&lt;=</span><span class="s3">1</span><span class="s0">,c=Boolean(a&amp;&amp;!u&amp;&amp;!</span><span class="s3">0</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.options.crossfade&amp;&amp;!</span><span class="s1">this</span><span class="s0">.path.some(Yr));</span><span class="s1">let </span><span class="s0">h;</span><span class="s1">this</span><span class="s0">.animationProgress=</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.mixTargetDelta=e=&gt;{</span><span class="s1">const </span><span class="s0">n=e/</span><span class="s3">1e3</span><span class="s0">;</span><span class="s1">var </span><span class="s0">l,d;Xr(o.x,t.x,n),Xr(o.y,t.y,n),</span><span class="s1">this</span><span class="s0">.setTargetDelta(o),</span><span class="s1">this</span><span class="s0">.relativeTarget&amp;&amp;</span><span class="s1">this</span><span class="s0">.relativeTargetOrigin&amp;&amp;</span><span class="s1">this</span><span class="s0">.layout&amp;&amp;</span><span class="s1">this</span><span class="s0">.relativeParent&amp;&amp;</span><span class="s1">this</span><span class="s0">.relativeParent.layout&amp;&amp;(vo(r,</span><span class="s1">this</span><span class="s0">.layout.layoutBox,</span><span class="s1">this</span><span class="s0">.relativeParent.layout.layoutBox),</span><span class="s1">function</span><span class="s0">(t,e,n,i){Hr(t.x,e.x,n.x,i),Hr(t.y,e.y,n.y,i)}(</span><span class="s1">this</span><span class="s0">.relativeTarget,</span><span class="s1">this</span><span class="s0">.relativeTargetOrigin,r,n),h&amp;&amp;(l=</span><span class="s1">this</span><span class="s0">.relativeTarget,d=h,fr(l.x,d.x)&amp;&amp;fr(l.y,d.y))&amp;&amp;(</span><span class="s1">this</span><span class="s0">.isProjectionDirty=!</span><span class="s3">1</span><span class="s0">),h||(h={x:{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">},y:{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">}}),Ho(h,</span><span class="s1">this</span><span class="s0">.relativeTarget)),a&amp;&amp;(</span><span class="s1">this</span><span class="s0">.animationValues=s,</span><span class="s1">function</span><span class="s0">(t,e,n,i,s,o){s?(t.opacity=Jt(</span><span class="s3">0</span><span class="s0">,n.opacity??</span><span class="s3">1</span><span class="s0">,No(i)),t.opacityExit=Jt(e.opacity??</span><span class="s3">1</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,$o(i))):o&amp;&amp;(t.opacity=Jt(e.opacity??</span><span class="s3">1</span><span class="s0">,n.opacity??</span><span class="s3">1</span><span class="s0">,i));</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">s=</span><span class="s3">0</span><span class="s0">;s&lt;Io;s++){</span><span class="s1">const </span><span class="s0">o=</span><span class="s2">`border</span><span class="s0">${Bo[s]}</span><span class="s2">Radius`</span><span class="s0">;</span><span class="s1">let </span><span class="s0">r=Uo(e,o),a=Uo(n,o);</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===r&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===a||(r||(r=</span><span class="s3">0</span><span class="s0">),a||(a=</span><span class="s3">0</span><span class="s0">),</span><span class="s3">0</span><span class="s0">===r||</span><span class="s3">0</span><span class="s0">===a||Wo(r)===Wo(a)?(t[o]=Math.max(Jt(Fo(r),Fo(a),i),</span><span class="s3">0</span><span class="s0">),(Lt.test(a)||Lt.test(r))&amp;&amp;(t[o]+=</span><span class="s2">&quot;%&quot;</span><span class="s0">)):t[o]=a)}(e.rotate||n.rotate)&amp;&amp;(t.rotate=Jt(e.rotate||</span><span class="s3">0</span><span class="s0">,n.rotate||</span><span class="s3">0</span><span class="s0">,i))}(s,i,</span><span class="s1">this</span><span class="s0">.latestValues,n,c,u)),</span><span class="s1">this</span><span class="s0">.root.scheduleUpdateProjection(),</span><span class="s1">this</span><span class="s0">.scheduleRender(),</span><span class="s1">this</span><span class="s0">.animationProgress=n},</span><span class="s1">this</span><span class="s0">.mixTargetDelta(</span><span class="s1">this</span><span class="s0">.options.layoutRoot?</span><span class="s3">1e3</span><span class="s0">:</span><span class="s3">0</span><span class="s0">)}startAnimation(t){</span><span class="s1">this</span><span class="s0">.notifyListeners(</span><span class="s2">&quot;animationStart&quot;</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.currentAnimation?.stop(),</span><span class="s1">this</span><span class="s0">.resumingFrom?.currentAnimation?.stop(),</span><span class="s1">this</span><span class="s0">.pendingAnimation&amp;&amp;(lt(</span><span class="s1">this</span><span class="s0">.pendingAnimation),</span><span class="s1">this</span><span class="s0">.pendingAnimation=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.pendingAnimation=at.update(()=&gt;{Sr.hasAnimatedSinceResize=!</span><span class="s3">0</span><span class="s0">,mt.layout++,</span><span class="s1">this</span><span class="s0">.motionValue||(</span><span class="s1">this</span><span class="s0">.motionValue=Bi(</span><span class="s3">0</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.currentAnimation=Mo(</span><span class="s1">this</span><span class="s0">.motionValue,[</span><span class="s3">0</span><span class="s0">,</span><span class="s3">1e3</span><span class="s0">],{...t,velocity:</span><span class="s3">0</span><span class="s0">,isSync:!</span><span class="s3">0</span><span class="s0">,onUpdate:e=&gt;{</span><span class="s1">this</span><span class="s0">.mixTargetDelta(e),t.onUpdate&amp;&amp;t.onUpdate(e)},onStop:()=&gt;{mt.layout--},onComplete:()=&gt;{mt.layout--,t.onComplete&amp;&amp;t.onComplete(),</span><span class="s1">this</span><span class="s0">.completeAnimation()}}),</span><span class="s1">this</span><span class="s0">.resumingFrom&amp;&amp;(</span><span class="s1">this</span><span class="s0">.resumingFrom.currentAnimation=</span><span class="s1">this</span><span class="s0">.currentAnimation),</span><span class="s1">this</span><span class="s0">.pendingAnimation=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">})}completeAnimation(){</span><span class="s1">this</span><span class="s0">.resumingFrom&amp;&amp;(</span><span class="s1">this</span><span class="s0">.resumingFrom.currentAnimation=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.resumingFrom.preserveOpacity=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">);</span><span class="s1">const </span><span class="s0">t=</span><span class="s1">this</span><span class="s0">.getStack();t&amp;&amp;t.exitAnimationComplete(),</span><span class="s1">this</span><span class="s0">.resumingFrom=</span><span class="s1">this</span><span class="s0">.currentAnimation=</span><span class="s1">this</span><span class="s0">.animationValues=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.notifyListeners(</span><span class="s2">&quot;animationComplete&quot;</span><span class="s0">)}finishAnimation(){</span><span class="s1">this</span><span class="s0">.currentAnimation&amp;&amp;(</span><span class="s1">this</span><span class="s0">.mixTargetDelta&amp;&amp;</span><span class="s1">this</span><span class="s0">.mixTargetDelta(</span><span class="s3">1e3</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.currentAnimation.stop()),</span><span class="s1">this</span><span class="s0">.completeAnimation()}applyTransformsToTarget(){</span><span class="s1">const </span><span class="s0">t=</span><span class="s1">this</span><span class="s0">.getLead();</span><span class="s1">let</span><span class="s0">{targetWithTransforms:e,target:n,layout:i,latestValues:s}=t;</span><span class="s1">if</span><span class="s0">(e&amp;&amp;n&amp;&amp;i){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">!==t&amp;&amp;</span><span class="s1">this</span><span class="s0">.layout&amp;&amp;i&amp;&amp;qr(</span><span class="s1">this</span><span class="s0">.options.animationType,</span><span class="s1">this</span><span class="s0">.layout.layoutBox,i.layoutBox)){n=</span><span class="s1">this</span><span class="s0">.target||{x:{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">},y:{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">}};</span><span class="s1">const </span><span class="s0">e=po(</span><span class="s1">this</span><span class="s0">.layout.layoutBox.x);n.x.min=t.target.x.min,n.x.max=n.x.min+e;</span><span class="s1">const </span><span class="s0">i=po(</span><span class="s1">this</span><span class="s0">.layout.layoutBox.y);n.y.min=t.target.y.min,n.y.max=n.y.min+i}Ho(e,n),rr(e,s),fo(</span><span class="s1">this</span><span class="s0">.projectionDeltaWithTransform,</span><span class="s1">this</span><span class="s0">.layoutCorrected,e,s)}}registerSharedNode(t,e){</span><span class="s1">this</span><span class="s0">.sharedNodes.has(t)||</span><span class="s1">this</span><span class="s0">.sharedNodes.set(t,</span><span class="s1">new </span><span class="s0">wr);</span><span class="s1">this</span><span class="s0">.sharedNodes.get(t).add(e);</span><span class="s1">const </span><span class="s0">n=e.options.initialPromotionConfig;e.promote({transition:n?n.transition:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,preserveFollowOpacity:n&amp;&amp;n.shouldPreserveFollowOpacity?n.shouldPreserveFollowOpacity(e):</span><span class="s1">void </span><span class="s3">0</span><span class="s0">})}isLead(){</span><span class="s1">const </span><span class="s0">t=</span><span class="s1">this</span><span class="s0">.getStack();</span><span class="s1">return</span><span class="s0">!t||t.lead===</span><span class="s1">this</span><span class="s0">}getLead(){</span><span class="s1">const</span><span class="s0">{layoutId:t}=</span><span class="s1">this</span><span class="s0">.options;</span><span class="s1">return </span><span class="s0">t&amp;&amp;</span><span class="s1">this</span><span class="s0">.getStack()?.lead||</span><span class="s1">this</span><span class="s0">}getPrevLead(){</span><span class="s1">const</span><span class="s0">{layoutId:t}=</span><span class="s1">this</span><span class="s0">.options;</span><span class="s1">return </span><span class="s0">t?</span><span class="s1">this</span><span class="s0">.getStack()?.prevLead:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">}getStack(){</span><span class="s1">const</span><span class="s0">{layoutId:t}=</span><span class="s1">this</span><span class="s0">.options;</span><span class="s1">if</span><span class="s0">(t)</span><span class="s1">return this</span><span class="s0">.root.sharedNodes.get(t)}promote({needsReset:t,transition:e,preserveFollowOpacity:n}={}){</span><span class="s1">const </span><span class="s0">i=</span><span class="s1">this</span><span class="s0">.getStack();i&amp;&amp;i.promote(</span><span class="s1">this</span><span class="s0">,n),t&amp;&amp;(</span><span class="s1">this</span><span class="s0">.projectionDelta=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.needsReset=!</span><span class="s3">0</span><span class="s0">),e&amp;&amp;</span><span class="s1">this</span><span class="s0">.setOptions({transition:e})}relegate(){</span><span class="s1">const </span><span class="s0">t=</span><span class="s1">this</span><span class="s0">.getStack();</span><span class="s1">return</span><span class="s0">!!t&amp;&amp;t.relegate(</span><span class="s1">this</span><span class="s0">)}resetSkewAndRotation(){</span><span class="s1">const</span><span class="s0">{visualElement:t}=</span><span class="s1">this</span><span class="s0">.options;</span><span class="s1">if</span><span class="s0">(!t)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">let </span><span class="s0">e=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">const</span><span class="s0">{latestValues:n}=t;</span><span class="s1">if</span><span class="s0">((n.z||n.rotate||n.rotateX||n.rotateY||n.rotateZ||n.skewX||n.skewY)&amp;&amp;(e=!</span><span class="s3">0</span><span class="s0">),!e)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">const </span><span class="s0">i={};n.z&amp;&amp;Cr(</span><span class="s2">&quot;z&quot;</span><span class="s0">,t,i,</span><span class="s1">this</span><span class="s0">.animationValues);</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">e=</span><span class="s3">0</span><span class="s0">;e&lt;Ar.length;e++)Cr(</span><span class="s2">`rotate</span><span class="s0">${Ar[e]}</span><span class="s2">`</span><span class="s0">,t,i,</span><span class="s1">this</span><span class="s0">.animationValues),Cr(</span><span class="s2">`skew</span><span class="s0">${Ar[e]}</span><span class="s2">`</span><span class="s0">,t,i,</span><span class="s1">this</span><span class="s0">.animationValues);t.render();</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">e </span><span class="s1">in </span><span class="s0">i)t.setStaticValue(e,i[e]),</span><span class="s1">this</span><span class="s0">.animationValues&amp;&amp;(</span><span class="s1">this</span><span class="s0">.animationValues[e]=i[e]);t.scheduleRender()}applyProjectionStyles(t,e){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.instance||</span><span class="s1">this</span><span class="s0">.isSVG)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.isVisible)</span><span class="s1">return void</span><span class="s0">(t.visibility=</span><span class="s2">&quot;hidden&quot;</span><span class="s0">);</span><span class="s1">const </span><span class="s0">n=</span><span class="s1">this</span><span class="s0">.getTransformTemplate();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.needsReset)</span><span class="s1">return this</span><span class="s0">.needsReset=!</span><span class="s3">1</span><span class="s0">,t.visibility=</span><span class="s2">&quot;&quot;</span><span class="s0">,t.opacity=</span><span class="s2">&quot;&quot;</span><span class="s0">,t.pointerEvents=jo(e?.pointerEvents)||</span><span class="s2">&quot;&quot;</span><span class="s0">,</span><span class="s1">void</span><span class="s0">(t.transform=n?n(</span><span class="s1">this</span><span class="s0">.latestValues,</span><span class="s2">&quot;&quot;</span><span class="s0">):</span><span class="s2">&quot;none&quot;</span><span class="s0">);</span><span class="s1">const </span><span class="s0">i=</span><span class="s1">this</span><span class="s0">.getLead();</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.projectionDelta||!</span><span class="s1">this</span><span class="s0">.layout||!i.target)</span><span class="s1">return this</span><span class="s0">.options.layoutId&amp;&amp;(t.opacity=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.latestValues.opacity?</span><span class="s1">this</span><span class="s0">.latestValues.opacity:</span><span class="s3">1</span><span class="s0">,t.pointerEvents=jo(e?.pointerEvents)||</span><span class="s2">&quot;&quot;</span><span class="s0">),</span><span class="s1">void</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.hasProjected&amp;&amp;!_o(</span><span class="s1">this</span><span class="s0">.latestValues)&amp;&amp;(t.transform=n?n({},</span><span class="s2">&quot;&quot;</span><span class="s0">):</span><span class="s2">&quot;none&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.hasProjected=!</span><span class="s3">1</span><span class="s0">));t.visibility=</span><span class="s2">&quot;&quot;</span><span class="s0">;</span><span class="s1">const </span><span class="s0">s=i.animationValues||i.latestValues;</span><span class="s1">this</span><span class="s0">.applyTransformsToTarget();</span><span class="s1">let </span><span class="s0">o=</span><span class="s1">function</span><span class="s0">(t,e,n){</span><span class="s1">let </span><span class="s0">i=</span><span class="s2">&quot;&quot;</span><span class="s0">;</span><span class="s1">const </span><span class="s0">s=t.x.translate/e.x,o=t.y.translate/e.y,r=n?.z||</span><span class="s3">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">((s||o||r)&amp;&amp;(i=</span><span class="s2">`translate3d(</span><span class="s0">${s}</span><span class="s2">px, </span><span class="s0">${o}</span><span class="s2">px, </span><span class="s0">${r}</span><span class="s2">px) `</span><span class="s0">),</span><span class="s3">1</span><span class="s0">===e.x&amp;&amp;</span><span class="s3">1</span><span class="s0">===e.y||(i+=</span><span class="s2">`scale(</span><span class="s0">${</span><span class="s3">1</span><span class="s0">/e.x}</span><span class="s2">, </span><span class="s0">${</span><span class="s3">1</span><span class="s0">/e.y}</span><span class="s2">) `</span><span class="s0">),n){</span><span class="s1">const</span><span class="s0">{transformPerspective:t,rotate:e,rotateX:s,rotateY:o,skewX:r,skewY:a}=n;t&amp;&amp;(i=</span><span class="s2">`perspective(</span><span class="s0">${t}</span><span class="s2">px) </span><span class="s0">${i}</span><span class="s2">`</span><span class="s0">),e&amp;&amp;(i+=</span><span class="s2">`rotate(</span><span class="s0">${e}</span><span class="s2">deg) `</span><span class="s0">),s&amp;&amp;(i+=</span><span class="s2">`rotateX(</span><span class="s0">${s}</span><span class="s2">deg) `</span><span class="s0">),o&amp;&amp;(i+=</span><span class="s2">`rotateY(</span><span class="s0">${o}</span><span class="s2">deg) `</span><span class="s0">),r&amp;&amp;(i+=</span><span class="s2">`skewX(</span><span class="s0">${r}</span><span class="s2">deg) `</span><span class="s0">),a&amp;&amp;(i+=</span><span class="s2">`skewY(</span><span class="s0">${a}</span><span class="s2">deg) `</span><span class="s0">)}</span><span class="s1">const </span><span class="s0">a=t.x.scale*e.x,l=t.y.scale*e.y;</span><span class="s1">return </span><span class="s3">1</span><span class="s0">===a&amp;&amp;</span><span class="s3">1</span><span class="s0">===l||(i+=</span><span class="s2">`scale(</span><span class="s0">${a}</span><span class="s2">, </span><span class="s0">${l}</span><span class="s2">)`</span><span class="s0">),i||</span><span class="s2">&quot;none&quot;</span><span class="s0">}(</span><span class="s1">this</span><span class="s0">.projectionDeltaWithTransform,</span><span class="s1">this</span><span class="s0">.treeScale,s);n&amp;&amp;(o=n(s,o)),t.transform=o;</span><span class="s1">const</span><span class="s0">{x:r,y:a}=</span><span class="s1">this</span><span class="s0">.projectionDelta;t.transformOrigin=</span><span class="s2">`</span><span class="s0">${</span><span class="s3">100</span><span class="s0">*r.origin}</span><span class="s2">% </span><span class="s0">${</span><span class="s3">100</span><span class="s0">*a.origin}</span><span class="s2">% 0`</span><span class="s0">,i.animationValues?t.opacity=i===</span><span class="s1">this</span><span class="s0">?s.opacity??</span><span class="s1">this</span><span class="s0">.latestValues.opacity??</span><span class="s3">1</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.preserveOpacity?</span><span class="s1">this</span><span class="s0">.latestValues.opacity:s.opacityExit:t.opacity=i===</span><span class="s1">this</span><span class="s0">?</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==s.opacity?s.opacity:</span><span class="s2">&quot;&quot;</span><span class="s0">:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==s.opacityExit?s.opacityExit:</span><span class="s3">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">e </span><span class="s1">in </span><span class="s0">Tr){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===s[e])</span><span class="s1">continue</span><span class="s0">;</span><span class="s1">const</span><span class="s0">{correct:n,applyTo:r,isCSSVariable:a}=Tr[e],l=</span><span class="s2">&quot;none&quot;</span><span class="s0">===o?s[e]:n(s[e],i);</span><span class="s1">if</span><span class="s0">(r){</span><span class="s1">const </span><span class="s0">e=r.length;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">n=</span><span class="s3">0</span><span class="s0">;n&lt;e;n++)t[r[n]]=l}</span><span class="s1">else </span><span class="s0">a?</span><span class="s1">this</span><span class="s0">.options.visualElement.renderState.vars[e]=l:t[e]=l}</span><span class="s1">this</span><span class="s0">.options.layoutId&amp;&amp;(t.pointerEvents=i===</span><span class="s1">this</span><span class="s0">?jo(e?.pointerEvents)||</span><span class="s2">&quot;&quot;</span><span class="s0">:</span><span class="s2">&quot;none&quot;</span><span class="s0">)}clearSnapshot(){</span><span class="s1">this</span><span class="s0">.resumeFrom=</span><span class="s1">this</span><span class="s0">.snapshot=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">}resetTree(){</span><span class="s1">this</span><span class="s0">.root.nodes.forEach(t=&gt;t.currentAnimation?.stop()),</span><span class="s1">this</span><span class="s0">.root.nodes.forEach(Br),</span><span class="s1">this</span><span class="s0">.root.sharedNodes.clear()}}}</span><span class="s1">function </span><span class="s0">Rr(t){t.updateLayout()}</span><span class="s1">function </span><span class="s0">kr(t){</span><span class="s1">const </span><span class="s0">e=t.resumeFrom?.snapshot||t.snapshot;</span><span class="s1">if</span><span class="s0">(t.isLead()&amp;&amp;t.layout&amp;&amp;e&amp;&amp;t.hasListeners(</span><span class="s2">&quot;didUpdate&quot;</span><span class="s0">)){</span><span class="s1">const</span><span class="s0">{layoutBox:n,measuredBox:i}=t.layout,{animationType:s}=t.options,o=e.source!==t.layout.source;</span><span class="s2">&quot;size&quot;</span><span class="s0">===s?br(t=&gt;{</span><span class="s1">const </span><span class="s0">i=o?e.measuredBox[t]:e.layoutBox[t],s=po(i);i.min=n[t].min,i.max=i.min+s}):qr(s,e.layoutBox,n)&amp;&amp;br(i=&gt;{</span><span class="s1">const </span><span class="s0">s=o?e.measuredBox[i]:e.layoutBox[i],r=po(n[i]);s.max=s.min+r,t.relativeTarget&amp;&amp;!t.currentAnimation&amp;&amp;(t.isProjectionDirty=!</span><span class="s3">0</span><span class="s0">,t.relativeTarget[i].max=t.relativeTarget[i].min+r)});</span><span class="s1">const </span><span class="s0">r={x:{translate:</span><span class="s3">0</span><span class="s0">,scale:</span><span class="s3">1</span><span class="s0">,origin:</span><span class="s3">0</span><span class="s0">,originPoint:</span><span class="s3">0</span><span class="s0">},y:{translate:</span><span class="s3">0</span><span class="s0">,scale:</span><span class="s3">1</span><span class="s0">,origin:</span><span class="s3">0</span><span class="s0">,originPoint:</span><span class="s3">0</span><span class="s0">}};fo(r,n,e.layoutBox);</span><span class="s1">const </span><span class="s0">a={x:{translate:</span><span class="s3">0</span><span class="s0">,scale:</span><span class="s3">1</span><span class="s0">,origin:</span><span class="s3">0</span><span class="s0">,originPoint:</span><span class="s3">0</span><span class="s0">},y:{translate:</span><span class="s3">0</span><span class="s0">,scale:</span><span class="s3">1</span><span class="s0">,origin:</span><span class="s3">0</span><span class="s0">,originPoint:</span><span class="s3">0</span><span class="s0">}};o?fo(a,t.applyTransform(i,!</span><span class="s3">0</span><span class="s0">),e.measuredBox):fo(a,n,e.layoutBox);</span><span class="s1">const </span><span class="s0">l=!mr(r);</span><span class="s1">let </span><span class="s0">u=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(!t.resumeFrom){</span><span class="s1">const </span><span class="s0">i=t.getClosestProjectingParent();</span><span class="s1">if</span><span class="s0">(i&amp;&amp;!i.resumeFrom){</span><span class="s1">const</span><span class="s0">{snapshot:s,layout:o}=i;</span><span class="s1">if</span><span class="s0">(s&amp;&amp;o){</span><span class="s1">const </span><span class="s0">r={x:{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">},y:{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">}};vo(r,e.layoutBox,s.layoutBox);</span><span class="s1">const </span><span class="s0">a={x:{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">},y:{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">}};vo(a,n,o.layoutBox),yr(r,a)||(u=!</span><span class="s3">0</span><span class="s0">),i.options.layoutRoot&amp;&amp;(t.relativeTarget=a,t.relativeTargetOrigin=r,t.relativeParent=i)}}}t.notifyListeners(</span><span class="s2">&quot;didUpdate&quot;</span><span class="s0">,{layout:n,snapshot:e,delta:a,layoutDelta:r,hasLayoutChanged:l,hasRelativeLayoutChanged:u})}</span><span class="s1">else if</span><span class="s0">(t.isLead()){</span><span class="s1">const</span><span class="s0">{onExitComplete:e}=t.options;e&amp;&amp;e()}t.options.transition=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">}</span><span class="s1">function </span><span class="s0">Lr(t){ot.value&amp;&amp;Er.nodes++,t.parent&amp;&amp;(t.isProjecting()||(t.isProjectionDirty=t.parent.isProjectionDirty),t.isSharedProjectionDirty||(t.isSharedProjectionDirty=Boolean(t.isProjectionDirty||t.parent.isProjectionDirty||t.parent.isSharedProjectionDirty)),t.isTransformDirty||(t.isTransformDirty=t.parent.isTransformDirty))}</span><span class="s1">function </span><span class="s0">Or(t){t.isProjectionDirty=t.isSharedProjectionDirty=t.isTransformDirty=!</span><span class="s3">1</span><span class="s0">}</span><span class="s1">function </span><span class="s0">jr(t){t.clearSnapshot()}</span><span class="s1">function </span><span class="s0">Br(t){t.clearMeasurements()}</span><span class="s1">function </span><span class="s0">Ir(t){t.isLayoutDirty=!</span><span class="s3">1</span><span class="s0">}</span><span class="s1">function </span><span class="s0">Fr(t){</span><span class="s1">const</span><span class="s0">{visualElement:e}=t.options;e&amp;&amp;e.getProps().onBeforeLayoutMeasure&amp;&amp;e.notify(</span><span class="s2">&quot;BeforeLayoutMeasure&quot;</span><span class="s0">),t.resetTransform()}</span><span class="s1">function </span><span class="s0">Wr(t){t.finishAnimation(),t.targetDelta=t.relativeTarget=t.target=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,t.isProjectionDirty=!</span><span class="s3">0</span><span class="s0">}</span><span class="s1">function </span><span class="s0">Ur(t){t.resolveTargetDelta()}</span><span class="s1">function </span><span class="s0">Nr(t){t.calcProjection()}</span><span class="s1">function </span><span class="s0">$r(t){t.resetSkewAndRotation()}</span><span class="s1">function </span><span class="s0">zr(t){t.removeLeadSnapshot()}</span><span class="s1">function </span><span class="s0">Xr(t,e,n){t.translate=Jt(e.translate,</span><span class="s3">0</span><span class="s0">,n),t.scale=Jt(e.scale,</span><span class="s3">1</span><span class="s0">,n),t.origin=e.origin,t.originPoint=e.originPoint}</span><span class="s1">function </span><span class="s0">Hr(t,e,n,i){t.min=Jt(e.min,n.min,i),t.max=Jt(e.max,n.max,i)}</span><span class="s1">function </span><span class="s0">Yr(t){</span><span class="s1">return </span><span class="s0">t.animationValues&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==t.animationValues.opacityExit}</span><span class="s1">const </span><span class="s0">Kr={duration:</span><span class="s3">.45</span><span class="s0">,ease:[</span><span class="s3">.4</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">.1</span><span class="s0">,</span><span class="s3">1</span><span class="s0">]},Gr=t=&gt;</span><span class="s2">&quot;undefined&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">navigator&amp;&amp;navigator.userAgent&amp;&amp;navigator.userAgent.toLowerCase().includes(t),_r=Gr(</span><span class="s2">&quot;applewebkit/&quot;</span><span class="s0">)&amp;&amp;!Gr(</span><span class="s2">&quot;chrome/&quot;</span><span class="s0">)?Math.round:V;</span><span class="s1">function </span><span class="s0">Zr(t){t.min=_r(t.min),t.max=_r(t.max)}</span><span class="s1">function </span><span class="s0">qr(t,e,n){</span><span class="s1">return</span><span class="s2">&quot;position&quot;</span><span class="s0">===t||</span><span class="s2">&quot;preserve-aspect&quot;</span><span class="s0">===t&amp;&amp;(i=vr(e),s=vr(n),o=</span><span class="s3">.2</span><span class="s0">,!(Math.abs(i-s)&lt;=o));</span><span class="s1">var </span><span class="s0">i,s,o}</span><span class="s1">function </span><span class="s0">Jr(t){</span><span class="s1">return </span><span class="s0">t!==t.root&amp;&amp;t.scroll?.wasRoot}</span><span class="s1">function </span><span class="s0">Qr(t,e,n,i={passive:!</span><span class="s3">0</span><span class="s0">}){</span><span class="s1">return </span><span class="s0">t.addEventListener(e,n,i),()=&gt;t.removeEventListener(e,n)}</span><span class="s1">const </span><span class="s0">ta=Dr({attachResizeListener:(t,e)=&gt;Qr(t,</span><span class="s2">&quot;resize&quot;</span><span class="s0">,e),measureScroll:()=&gt;({x:document.documentElement.scrollLeft||document.body.scrollLeft,y:document.documentElement.scrollTop||document.body.scrollTop}),checkIsScrollRoot:()=&gt;!</span><span class="s3">0</span><span class="s0">}),ea={current:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">},na=Dr({measureScroll:t=&gt;({x:t.scrollLeft,y:t.scrollTop}),defaultParent:()=&gt;{</span><span class="s1">if</span><span class="s0">(!ea.current){</span><span class="s1">const </span><span class="s0">t=</span><span class="s1">new </span><span class="s0">ta({});t.mount(window),t.setOptions({layoutScroll:!</span><span class="s3">0</span><span class="s0">}),ea.current=t}</span><span class="s1">return </span><span class="s0">ea.current},resetTransform:(t,e)=&gt;{t.style.transform=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==e?e:</span><span class="s2">&quot;none&quot;</span><span class="s0">},checkIsScrollRoot:t=&gt;Boolean(</span><span class="s2">&quot;fixed&quot;</span><span class="s0">===window.getComputedStyle(t).position)});</span><span class="s1">function </span><span class="s0">ia(t,e){</span><span class="s1">return </span><span class="s0">e.max===e.min?</span><span class="s3">0</span><span class="s0">:t/(e.max-e.min)*</span><span class="s3">100</span><span class="s0">}</span><span class="s1">const </span><span class="s0">sa={correct:(t,e)=&gt;{</span><span class="s1">if</span><span class="s0">(!e.target)</span><span class="s1">return </span><span class="s0">t;</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t){</span><span class="s1">if</span><span class="s0">(!Ot.test(t))</span><span class="s1">return </span><span class="s0">t;t=parseFloat(t)}</span><span class="s1">return</span><span class="s2">`</span><span class="s0">${ia(t,e.target.x)}</span><span class="s2">% </span><span class="s0">${ia(t,e.target.y)}</span><span class="s2">%`</span><span class="s0">}},oa={correct:(t,{treeScale:e,projectionDelta:n})=&gt;{</span><span class="s1">const </span><span class="s0">i=t,s=Gt.parse(t);</span><span class="s1">if</span><span class="s0">(s.length&gt;</span><span class="s3">5</span><span class="s0">)</span><span class="s1">return </span><span class="s0">i;</span><span class="s1">const </span><span class="s0">o=Gt.createTransformer(t),r=</span><span class="s2">&quot;number&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">s[</span><span class="s3">0</span><span class="s0">]?</span><span class="s3">1</span><span class="s0">:</span><span class="s3">0</span><span class="s0">,a=n.x.scale*e.x,l=n.y.scale*e.y;s[</span><span class="s3">0</span><span class="s0">+r]/=a,s[</span><span class="s3">1</span><span class="s0">+r]/=l;</span><span class="s1">const </span><span class="s0">u=Jt(a,l,</span><span class="s3">.5</span><span class="s0">);</span><span class="s1">return</span><span class="s2">&quot;number&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">s[</span><span class="s3">2</span><span class="s0">+r]&amp;&amp;(s[</span><span class="s3">2</span><span class="s0">+r]/=u),</span><span class="s2">&quot;number&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">s[</span><span class="s3">3</span><span class="s0">+r]&amp;&amp;(s[</span><span class="s3">3</span><span class="s0">+r]/=u),o(s)}};</span><span class="s1">function </span><span class="s0">ra({top:t,left:e,right:n,bottom:i}){</span><span class="s1">return</span><span class="s0">{x:{min:e,max:n},y:{min:t,max:i}}}</span><span class="s1">function </span><span class="s0">aa(t,e){</span><span class="s1">return </span><span class="s0">ra(</span><span class="s1">function</span><span class="s0">(t,e){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return </span><span class="s0">t;</span><span class="s1">const </span><span class="s0">n=e({x:t.left,y:t.top}),i=e({x:t.right,y:t.bottom});</span><span class="s1">return</span><span class="s0">{top:n.y,left:n.x,bottom:i.y,right:i.x}}(t.getBoundingClientRect(),e))}</span><span class="s1">const </span><span class="s0">la={animation:[</span><span class="s2">&quot;animate&quot;</span><span class="s0">,</span><span class="s2">&quot;variants&quot;</span><span class="s0">,</span><span class="s2">&quot;whileHover&quot;</span><span class="s0">,</span><span class="s2">&quot;whileTap&quot;</span><span class="s0">,</span><span class="s2">&quot;exit&quot;</span><span class="s0">,</span><span class="s2">&quot;whileInView&quot;</span><span class="s0">,</span><span class="s2">&quot;whileFocus&quot;</span><span class="s0">,</span><span class="s2">&quot;whileDrag&quot;</span><span class="s0">],exit:[</span><span class="s2">&quot;exit&quot;</span><span class="s0">],drag:[</span><span class="s2">&quot;drag&quot;</span><span class="s0">,</span><span class="s2">&quot;dragControls&quot;</span><span class="s0">],focus:[</span><span class="s2">&quot;whileFocus&quot;</span><span class="s0">],hover:[</span><span class="s2">&quot;whileHover&quot;</span><span class="s0">,</span><span class="s2">&quot;onHoverStart&quot;</span><span class="s0">,</span><span class="s2">&quot;onHoverEnd&quot;</span><span class="s0">],tap:[</span><span class="s2">&quot;whileTap&quot;</span><span class="s0">,</span><span class="s2">&quot;onTap&quot;</span><span class="s0">,</span><span class="s2">&quot;onTapStart&quot;</span><span class="s0">,</span><span class="s2">&quot;onTapCancel&quot;</span><span class="s0">],pan:[</span><span class="s2">&quot;onPan&quot;</span><span class="s0">,</span><span class="s2">&quot;onPanStart&quot;</span><span class="s0">,</span><span class="s2">&quot;onPanSessionStart&quot;</span><span class="s0">,</span><span class="s2">&quot;onPanEnd&quot;</span><span class="s0">],inView:[</span><span class="s2">&quot;whileInView&quot;</span><span class="s0">,</span><span class="s2">&quot;onViewportEnter&quot;</span><span class="s0">,</span><span class="s2">&quot;onViewportLeave&quot;</span><span class="s0">],layout:[</span><span class="s2">&quot;layout&quot;</span><span class="s0">,</span><span class="s2">&quot;layoutId&quot;</span><span class="s0">]},ua={};</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">t </span><span class="s1">in </span><span class="s0">la)ua[t]={isEnabled:e=&gt;la[t].some(t=&gt;!!e[t])};</span><span class="s1">const </span><span class="s0">ca={current:</span><span class="s1">null</span><span class="s0">},ha={current:!</span><span class="s3">1</span><span class="s0">};</span><span class="s1">function </span><span class="s0">da(){</span><span class="s1">if</span><span class="s0">(ha.current=!</span><span class="s3">0</span><span class="s0">,g)</span><span class="s1">if</span><span class="s0">(window.matchMedia){</span><span class="s1">const </span><span class="s0">t=window.matchMedia(</span><span class="s2">&quot;(prefers-reduced-motion)&quot;</span><span class="s0">),e=()=&gt;ca.current=t.matches;t.addEventListener(</span><span class="s2">&quot;change&quot;</span><span class="s0">,e),e()}</span><span class="s1">else </span><span class="s0">ca.current=!</span><span class="s3">1</span><span class="s0">}</span><span class="s1">const </span><span class="s0">pa=</span><span class="s1">new </span><span class="s0">WeakMap;</span><span class="s1">function </span><span class="s0">ma(t){</span><span class="s1">return null</span><span class="s0">!==t&amp;&amp;</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t&amp;&amp;</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t.start}</span><span class="s1">function </span><span class="s0">fa(t){</span><span class="s1">return</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t||Array.isArray(t)}</span><span class="s1">const </span><span class="s0">ga=[</span><span class="s2">&quot;animate&quot;</span><span class="s0">,</span><span class="s2">&quot;whileInView&quot;</span><span class="s0">,</span><span class="s2">&quot;whileFocus&quot;</span><span class="s0">,</span><span class="s2">&quot;whileHover&quot;</span><span class="s0">,</span><span class="s2">&quot;whileTap&quot;</span><span class="s0">,</span><span class="s2">&quot;whileDrag&quot;</span><span class="s0">,</span><span class="s2">&quot;exit&quot;</span><span class="s0">],ya=[</span><span class="s2">&quot;initial&quot;</span><span class="s0">,...ga];</span><span class="s1">function </span><span class="s0">va(t){</span><span class="s1">return </span><span class="s0">ma(t.animate)||ya.some(e=&gt;fa(t[e]))}</span><span class="s1">function </span><span class="s0">xa(t){</span><span class="s1">return </span><span class="s0">Boolean(va(t)||t.variants)}</span><span class="s1">function </span><span class="s0">wa(t){</span><span class="s1">const </span><span class="s0">e=[{},{}];</span><span class="s1">return </span><span class="s0">t?.values.forEach((t,n)=&gt;{e[</span><span class="s3">0</span><span class="s0">][n]=t.get(),e[</span><span class="s3">1</span><span class="s0">][n]=t.getVelocity()}),e}</span><span class="s1">function </span><span class="s0">Ta(t,e,n,i){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e){</span><span class="s1">const</span><span class="s0">[s,o]=wa(i);e=e(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==n?n:t.custom,s,o)}</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;(e=t.variants&amp;&amp;t.variants[e]),</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e){</span><span class="s1">const</span><span class="s0">[s,o]=wa(i);e=e(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==n?n:t.custom,s,o)}</span><span class="s1">return </span><span class="s0">e}</span><span class="s1">const </span><span class="s0">Pa=[</span><span class="s2">&quot;AnimationStart&quot;</span><span class="s0">,</span><span class="s2">&quot;AnimationComplete&quot;</span><span class="s0">,</span><span class="s2">&quot;Update&quot;</span><span class="s0">,</span><span class="s2">&quot;BeforeLayoutMeasure&quot;</span><span class="s0">,</span><span class="s2">&quot;LayoutMeasure&quot;</span><span class="s0">,</span><span class="s2">&quot;LayoutAnimationStart&quot;</span><span class="s0">,</span><span class="s2">&quot;LayoutAnimationComplete&quot;</span><span class="s0">];</span><span class="s1">class </span><span class="s0">ba{scrapeMotionValuesFromProps(t,e,n){</span><span class="s1">return</span><span class="s0">{}}constructor({parent:t,props:e,presenceContext:n,reducedMotionConfig:i,blockInitialAnimation:s,visualState:o},r={}){</span><span class="s1">this</span><span class="s0">.current=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.children=</span><span class="s1">new </span><span class="s0">Set,</span><span class="s1">this</span><span class="s0">.isVariantNode=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.isControllingVariants=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.shouldReduceMotion=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.values=</span><span class="s1">new </span><span class="s0">Map,</span><span class="s1">this</span><span class="s0">.KeyframeResolver=Sn,</span><span class="s1">this</span><span class="s0">.features={},</span><span class="s1">this</span><span class="s0">.valueSubscriptions=</span><span class="s1">new </span><span class="s0">Map,</span><span class="s1">this</span><span class="s0">.prevMotionValues={},</span><span class="s1">this</span><span class="s0">.events={},</span><span class="s1">this</span><span class="s0">.propEventSubscriptions={},</span><span class="s1">this</span><span class="s0">.notifyUpdate=()=&gt;</span><span class="s1">this</span><span class="s0">.notify(</span><span class="s2">&quot;Update&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.latestValues),</span><span class="s1">this</span><span class="s0">.render=()=&gt;{</span><span class="s1">this</span><span class="s0">.current&amp;&amp;(</span><span class="s1">this</span><span class="s0">.triggerBuild(),</span><span class="s1">this</span><span class="s0">.renderInstance(</span><span class="s1">this</span><span class="s0">.current,</span><span class="s1">this</span><span class="s0">.renderState,</span><span class="s1">this</span><span class="s0">.props.style,</span><span class="s1">this</span><span class="s0">.projection))},</span><span class="s1">this</span><span class="s0">.renderScheduledAt=</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.scheduleRender=()=&gt;{</span><span class="s1">const </span><span class="s0">t=pt.now();</span><span class="s1">this</span><span class="s0">.renderScheduledAt&lt;t&amp;&amp;(</span><span class="s1">this</span><span class="s0">.renderScheduledAt=t,at.render(</span><span class="s1">this</span><span class="s0">.render,!</span><span class="s3">1</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">))};</span><span class="s1">const</span><span class="s0">{latestValues:a,renderState:l}=o;</span><span class="s1">this</span><span class="s0">.latestValues=a,</span><span class="s1">this</span><span class="s0">.baseTarget={...a},</span><span class="s1">this</span><span class="s0">.initialValues=e.initial?{...a}:{},</span><span class="s1">this</span><span class="s0">.renderState=l,</span><span class="s1">this</span><span class="s0">.parent=t,</span><span class="s1">this</span><span class="s0">.props=e,</span><span class="s1">this</span><span class="s0">.presenceContext=n,</span><span class="s1">this</span><span class="s0">.depth=t?t.depth+</span><span class="s3">1</span><span class="s0">:</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.reducedMotionConfig=i,</span><span class="s1">this</span><span class="s0">.options=r,</span><span class="s1">this</span><span class="s0">.blockInitialAnimation=Boolean(s),</span><span class="s1">this</span><span class="s0">.isControllingVariants=va(e),</span><span class="s1">this</span><span class="s0">.isVariantNode=xa(e),</span><span class="s1">this</span><span class="s0">.isVariantNode&amp;&amp;(</span><span class="s1">this</span><span class="s0">.variantChildren=</span><span class="s1">new </span><span class="s0">Set),</span><span class="s1">this</span><span class="s0">.manuallyAnimateOnMount=Boolean(t&amp;&amp;t.current);</span><span class="s1">const</span><span class="s0">{willChange:u,...c}=</span><span class="s1">this</span><span class="s0">.scrapeMotionValuesFromProps(e,{},</span><span class="s1">this</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">t </span><span class="s1">in </span><span class="s0">c){</span><span class="s1">const </span><span class="s0">e=c[t];</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==a[t]&amp;&amp;Ds(e)&amp;&amp;e.set(a[t])}}mount(t){</span><span class="s1">this</span><span class="s0">.current=t,pa.set(t,</span><span class="s1">this</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.projection&amp;&amp;!</span><span class="s1">this</span><span class="s0">.projection.instance&amp;&amp;</span><span class="s1">this</span><span class="s0">.projection.mount(t),</span><span class="s1">this</span><span class="s0">.parent&amp;&amp;</span><span class="s1">this</span><span class="s0">.isVariantNode&amp;&amp;!</span><span class="s1">this</span><span class="s0">.isControllingVariants&amp;&amp;(</span><span class="s1">this</span><span class="s0">.removeFromVariantTree=</span><span class="s1">this</span><span class="s0">.parent.addVariantChild(</span><span class="s1">this</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.values.forEach((t,e)=&gt;</span><span class="s1">this</span><span class="s0">.bindToMotionValue(e,t)),ha.current||da(),</span><span class="s1">this</span><span class="s0">.shouldReduceMotion=</span><span class="s2">&quot;never&quot;</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.reducedMotionConfig&amp;&amp;(</span><span class="s2">&quot;always&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.reducedMotionConfig||ca.current),</span><span class="s1">this</span><span class="s0">.parent?.addChild(</span><span class="s1">this</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.update(</span><span class="s1">this</span><span class="s0">.props,</span><span class="s1">this</span><span class="s0">.presenceContext)}unmount(){</span><span class="s1">this</span><span class="s0">.projection&amp;&amp;</span><span class="s1">this</span><span class="s0">.projection.unmount(),lt(</span><span class="s1">this</span><span class="s0">.notifyUpdate),lt(</span><span class="s1">this</span><span class="s0">.render),</span><span class="s1">this</span><span class="s0">.valueSubscriptions.forEach(t=&gt;t()),</span><span class="s1">this</span><span class="s0">.valueSubscriptions.clear(),</span><span class="s1">this</span><span class="s0">.removeFromVariantTree&amp;&amp;</span><span class="s1">this</span><span class="s0">.removeFromVariantTree(),</span><span class="s1">this</span><span class="s0">.parent?.removeChild(</span><span class="s1">this</span><span class="s0">);</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">t </span><span class="s1">in this</span><span class="s0">.events)</span><span class="s1">this</span><span class="s0">.events[t].clear();</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">t </span><span class="s1">in this</span><span class="s0">.features){</span><span class="s1">const </span><span class="s0">e=</span><span class="s1">this</span><span class="s0">.features[t];e&amp;&amp;(e.unmount(),e.isMounted=!</span><span class="s3">1</span><span class="s0">)}</span><span class="s1">this</span><span class="s0">.current=</span><span class="s1">null</span><span class="s0">}addChild(t){</span><span class="s1">this</span><span class="s0">.children.add(t),</span><span class="s1">this</span><span class="s0">.enteringChildren??(</span><span class="s1">this</span><span class="s0">.enteringChildren=</span><span class="s1">new </span><span class="s0">Set),</span><span class="s1">this</span><span class="s0">.enteringChildren.add(t)}removeChild(t){</span><span class="s1">this</span><span class="s0">.children.delete(t),</span><span class="s1">this</span><span class="s0">.enteringChildren&amp;&amp;</span><span class="s1">this</span><span class="s0">.enteringChildren.delete(t)}bindToMotionValue(t,e){</span><span class="s1">this</span><span class="s0">.valueSubscriptions.has(t)&amp;&amp;</span><span class="s1">this</span><span class="s0">.valueSubscriptions.get(t)();</span><span class="s1">const </span><span class="s0">n=dn.has(t);n&amp;&amp;</span><span class="s1">this</span><span class="s0">.onBindTransform&amp;&amp;</span><span class="s1">this</span><span class="s0">.onBindTransform();</span><span class="s1">const </span><span class="s0">i=e.on(</span><span class="s2">&quot;change&quot;</span><span class="s0">,e=&gt;{</span><span class="s1">this</span><span class="s0">.latestValues[t]=e,</span><span class="s1">this</span><span class="s0">.props.onUpdate&amp;&amp;at.preRender(</span><span class="s1">this</span><span class="s0">.notifyUpdate),n&amp;&amp;</span><span class="s1">this</span><span class="s0">.projection&amp;&amp;(</span><span class="s1">this</span><span class="s0">.projection.isTransformDirty=!</span><span class="s3">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.scheduleRender()});</span><span class="s1">let </span><span class="s0">s;window.MotionCheckAppearSync&amp;&amp;(s=window.MotionCheckAppearSync(</span><span class="s1">this</span><span class="s0">,t,e)),</span><span class="s1">this</span><span class="s0">.valueSubscriptions.set(t,()=&gt;{i(),s&amp;&amp;s(),e.owner&amp;&amp;e.stop()})}sortNodePosition(t){</span><span class="s1">return this</span><span class="s0">.current&amp;&amp;</span><span class="s1">this</span><span class="s0">.sortInstanceNodePosition&amp;&amp;</span><span class="s1">this</span><span class="s0">.type===t.type?</span><span class="s1">this</span><span class="s0">.sortInstanceNodePosition(</span><span class="s1">this</span><span class="s0">.current,t.current):</span><span class="s3">0</span><span class="s0">}updateFeatures(){</span><span class="s1">let </span><span class="s0">t=</span><span class="s2">&quot;animation&quot;</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(t </span><span class="s1">in </span><span class="s0">ua){</span><span class="s1">const </span><span class="s0">e=ua[t];</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">continue</span><span class="s0">;</span><span class="s1">const</span><span class="s0">{isEnabled:n,Feature:i}=e;</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.features[t]&amp;&amp;i&amp;&amp;n(</span><span class="s1">this</span><span class="s0">.props)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.features[t]=</span><span class="s1">new </span><span class="s0">i(</span><span class="s1">this</span><span class="s0">)),</span><span class="s1">this</span><span class="s0">.features[t]){</span><span class="s1">const </span><span class="s0">e=</span><span class="s1">this</span><span class="s0">.features[t];e.isMounted?e.update():(e.mount(),e.isMounted=!</span><span class="s3">0</span><span class="s0">)}}}triggerBuild(){</span><span class="s1">this</span><span class="s0">.build(</span><span class="s1">this</span><span class="s0">.renderState,</span><span class="s1">this</span><span class="s0">.latestValues,</span><span class="s1">this</span><span class="s0">.props)}measureViewportBox(){</span><span class="s1">return this</span><span class="s0">.current?</span><span class="s1">this</span><span class="s0">.measureInstanceViewportBox(</span><span class="s1">this</span><span class="s0">.current,</span><span class="s1">this</span><span class="s0">.props):{x:{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">},y:{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">}}}getStaticValue(t){</span><span class="s1">return this</span><span class="s0">.latestValues[t]}setStaticValue(t,e){</span><span class="s1">this</span><span class="s0">.latestValues[t]=e}update(t,e){(t.transformTemplate||</span><span class="s1">this</span><span class="s0">.props.transformTemplate)&amp;&amp;</span><span class="s1">this</span><span class="s0">.scheduleRender(),</span><span class="s1">this</span><span class="s0">.prevProps=</span><span class="s1">this</span><span class="s0">.props,</span><span class="s1">this</span><span class="s0">.props=t,</span><span class="s1">this</span><span class="s0">.prevPresenceContext=</span><span class="s1">this</span><span class="s0">.presenceContext,</span><span class="s1">this</span><span class="s0">.presenceContext=e;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">e=</span><span class="s3">0</span><span class="s0">;e&lt;Pa.length;e++){</span><span class="s1">const </span><span class="s0">n=Pa[e];</span><span class="s1">this</span><span class="s0">.propEventSubscriptions[n]&amp;&amp;(</span><span class="s1">this</span><span class="s0">.propEventSubscriptions[n](),</span><span class="s1">delete this</span><span class="s0">.propEventSubscriptions[n]);</span><span class="s1">const </span><span class="s0">i=t[</span><span class="s2">&quot;on&quot;</span><span class="s0">+n];i&amp;&amp;(</span><span class="s1">this</span><span class="s0">.propEventSubscriptions[n]=</span><span class="s1">this</span><span class="s0">.on(n,i))}</span><span class="s1">this</span><span class="s0">.prevMotionValues=</span><span class="s1">function</span><span class="s0">(t,e,n){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">i </span><span class="s1">in </span><span class="s0">e){</span><span class="s1">const </span><span class="s0">s=e[i],o=n[i];</span><span class="s1">if</span><span class="s0">(Ds(s))t.addValue(i,s);</span><span class="s1">else if</span><span class="s0">(Ds(o))t.addValue(i,Bi(s,{owner:t}));</span><span class="s1">else if</span><span class="s0">(o!==s)</span><span class="s1">if</span><span class="s0">(t.hasValue(i)){</span><span class="s1">const </span><span class="s0">e=t.getValue(i);!</span><span class="s3">0</span><span class="s0">===e.liveStyle?e.jump(s):e.hasAnimated||e.set(s)}</span><span class="s1">else</span><span class="s0">{</span><span class="s1">const </span><span class="s0">e=t.getStaticValue(i);t.addValue(i,Bi(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==e?e:s,{owner:t}))}}</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">i </span><span class="s1">in </span><span class="s0">n)</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===e[i]&amp;&amp;t.removeValue(i);</span><span class="s1">return </span><span class="s0">e}(</span><span class="s1">this</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.scrapeMotionValuesFromProps(t,</span><span class="s1">this</span><span class="s0">.prevProps,</span><span class="s1">this</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.prevMotionValues),</span><span class="s1">this</span><span class="s0">.handleChildMotionValue&amp;&amp;</span><span class="s1">this</span><span class="s0">.handleChildMotionValue()}getProps(){</span><span class="s1">return this</span><span class="s0">.props}getVariant(t){</span><span class="s1">return this</span><span class="s0">.props.variants?</span><span class="s1">this</span><span class="s0">.props.variants[t]:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">}getDefaultTransition(){</span><span class="s1">return this</span><span class="s0">.props.transition}getTransformPagePoint(){</span><span class="s1">return this</span><span class="s0">.props.transformPagePoint}getClosestVariantNode(){</span><span class="s1">return this</span><span class="s0">.isVariantNode?</span><span class="s1">this</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.parent?</span><span class="s1">this</span><span class="s0">.parent.getClosestVariantNode():</span><span class="s1">void </span><span class="s3">0</span><span class="s0">}addVariantChild(t){</span><span class="s1">const </span><span class="s0">e=</span><span class="s1">this</span><span class="s0">.getClosestVariantNode();</span><span class="s1">if</span><span class="s0">(e)</span><span class="s1">return </span><span class="s0">e.variantChildren&amp;&amp;e.variantChildren.add(t),()=&gt;e.variantChildren.delete(t)}addValue(t,e){</span><span class="s1">const </span><span class="s0">n=</span><span class="s1">this</span><span class="s0">.values.get(t);e!==n&amp;&amp;(n&amp;&amp;</span><span class="s1">this</span><span class="s0">.removeValue(t),</span><span class="s1">this</span><span class="s0">.bindToMotionValue(t,e),</span><span class="s1">this</span><span class="s0">.values.set(t,e),</span><span class="s1">this</span><span class="s0">.latestValues[t]=e.get())}removeValue(t){</span><span class="s1">this</span><span class="s0">.values.delete(t);</span><span class="s1">const </span><span class="s0">e=</span><span class="s1">this</span><span class="s0">.valueSubscriptions.get(t);e&amp;&amp;(e(),</span><span class="s1">this</span><span class="s0">.valueSubscriptions.delete(t)),</span><span class="s1">delete this</span><span class="s0">.latestValues[t],</span><span class="s1">this</span><span class="s0">.removeValueFromRenderState(t,</span><span class="s1">this</span><span class="s0">.renderState)}hasValue(t){</span><span class="s1">return this</span><span class="s0">.values.has(t)}getValue(t,e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.props.values&amp;&amp;</span><span class="s1">this</span><span class="s0">.props.values[t])</span><span class="s1">return this</span><span class="s0">.props.values[t];</span><span class="s1">let </span><span class="s0">n=</span><span class="s1">this</span><span class="s0">.values.get(t);</span><span class="s1">return void </span><span class="s3">0</span><span class="s0">===n&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==e&amp;&amp;(n=Bi(</span><span class="s1">null</span><span class="s0">===e?</span><span class="s1">void </span><span class="s3">0</span><span class="s0">:e,{owner:</span><span class="s1">this</span><span class="s0">}),</span><span class="s1">this</span><span class="s0">.addValue(t,n)),n}readValue(t,e){</span><span class="s1">let </span><span class="s0">n=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.latestValues[t]&amp;&amp;</span><span class="s1">this</span><span class="s0">.current?</span><span class="s1">this</span><span class="s0">.getBaseTargetFromProps(</span><span class="s1">this</span><span class="s0">.props,t)??</span><span class="s1">this</span><span class="s0">.readValueFromInstance(</span><span class="s1">this</span><span class="s0">.current,t,</span><span class="s1">this</span><span class="s0">.options):</span><span class="s1">this</span><span class="s0">.latestValues[t];</span><span class="s1">return null</span><span class="s0">!=n&amp;&amp;(</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">n&amp;&amp;(E(n)||M(n))?n=parseFloat(n):!js(n)&amp;&amp;Gt.test(e)&amp;&amp;(n=vi(t,e)),</span><span class="s1">this</span><span class="s0">.setBaseTarget(t,Ds(n)?n.get():n)),Ds(n)?n.get():n}setBaseTarget(t,e){</span><span class="s1">this</span><span class="s0">.baseTarget[t]=e}getBaseTarget(t){</span><span class="s1">const</span><span class="s0">{initial:e}=</span><span class="s1">this</span><span class="s0">.props;</span><span class="s1">let </span><span class="s0">n;</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e||</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e){</span><span class="s1">const </span><span class="s0">i=Ta(</span><span class="s1">this</span><span class="s0">.props,e,</span><span class="s1">this</span><span class="s0">.presenceContext?.custom);i&amp;&amp;(n=i[t])}</span><span class="s1">if</span><span class="s0">(e&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==n)</span><span class="s1">return </span><span class="s0">n;</span><span class="s1">const </span><span class="s0">i=</span><span class="s1">this</span><span class="s0">.getBaseTargetFromProps(</span><span class="s1">this</span><span class="s0">.props,t);</span><span class="s1">return void </span><span class="s3">0</span><span class="s0">===i||Ds(i)?</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.initialValues[t]&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===n?</span><span class="s1">void </span><span class="s3">0</span><span class="s0">:</span><span class="s1">this</span><span class="s0">.baseTarget[t]:i}on(t,e){</span><span class="s1">return this</span><span class="s0">.events[t]||(</span><span class="s1">this</span><span class="s0">.events[t]=</span><span class="s1">new </span><span class="s0">L),</span><span class="s1">this</span><span class="s0">.events[t].add(e)}notify(t,...e){</span><span class="s1">this</span><span class="s0">.events[t]&amp;&amp;</span><span class="s1">this</span><span class="s0">.events[t].notify(...e)}scheduleRenderMicrotask(){zi.render(</span><span class="s1">this</span><span class="s0">.render)}}</span><span class="s1">class </span><span class="s0">Sa </span><span class="s1">extends </span><span class="s0">ba{constructor(){</span><span class="s1">super</span><span class="s0">(...arguments),</span><span class="s1">this</span><span class="s0">.KeyframeResolver=wi}sortInstanceNodePosition(t,e){</span><span class="s1">return </span><span class="s3">2</span><span class="s0">&amp;t.compareDocumentPosition(e)?</span><span class="s3">1</span><span class="s0">:-</span><span class="s3">1</span><span class="s0">}getBaseTargetFromProps(t,e){</span><span class="s1">return </span><span class="s0">t.style?t.style[e]:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">}removeValueFromRenderState(t,{vars:e,style:n}){</span><span class="s1">delete </span><span class="s0">e[t],</span><span class="s1">delete </span><span class="s0">n[t]}handleChildMotionValue(){</span><span class="s1">this</span><span class="s0">.childSubscription&amp;&amp;(</span><span class="s1">this</span><span class="s0">.childSubscription(),</span><span class="s1">delete this</span><span class="s0">.childSubscription);</span><span class="s1">const</span><span class="s0">{children:t}=</span><span class="s1">this</span><span class="s0">.props;Ds(t)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.childSubscription=t.on(</span><span class="s2">&quot;change&quot;</span><span class="s0">,t=&gt;{</span><span class="s1">this</span><span class="s0">.current&amp;&amp;(</span><span class="s1">this</span><span class="s0">.current.textContent=</span><span class="s2">`</span><span class="s0">${t}</span><span class="s2">`</span><span class="s0">)}))}}</span><span class="s1">const </span><span class="s0">Ea={x:</span><span class="s2">&quot;translateX&quot;</span><span class="s0">,y:</span><span class="s2">&quot;translateY&quot;</span><span class="s0">,z:</span><span class="s2">&quot;translateZ&quot;</span><span class="s0">,transformPerspective:</span><span class="s2">&quot;perspective&quot;</span><span class="s0">},Aa=hn.length;</span><span class="s1">function </span><span class="s0">Ma(t,e,n){</span><span class="s1">let </span><span class="s0">i=</span><span class="s2">&quot;&quot;</span><span class="s0">,s=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">o=</span><span class="s3">0</span><span class="s0">;o&lt;Aa;o++){</span><span class="s1">const </span><span class="s0">r=hn[o],a=t[r];</span><span class="s1">if</span><span class="s0">(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===a)</span><span class="s1">continue</span><span class="s0">;</span><span class="s1">let </span><span class="s0">l=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(l=</span><span class="s2">&quot;number&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">a?a===(r.startsWith(</span><span class="s2">&quot;scale&quot;</span><span class="s0">)?</span><span class="s3">1</span><span class="s0">:</span><span class="s3">0</span><span class="s0">):</span><span class="s3">0</span><span class="s0">===parseFloat(a),!l||n){</span><span class="s1">const </span><span class="s0">t=Mi(a,fi[r]);</span><span class="s1">if</span><span class="s0">(!l){s=!</span><span class="s3">1</span><span class="s0">;i+=</span><span class="s2">`</span><span class="s0">${Ea[r]||r}</span><span class="s2">(</span><span class="s0">${t}</span><span class="s2">) `</span><span class="s0">}n&amp;&amp;(e[r]=t)}}</span><span class="s1">return </span><span class="s0">i=i.trim(),n?i=n(e,s?</span><span class="s2">&quot;&quot;</span><span class="s0">:i):s&amp;&amp;(i=</span><span class="s2">&quot;none&quot;</span><span class="s0">),i}</span><span class="s1">function </span><span class="s0">Ca(t,e,n){</span><span class="s1">const</span><span class="s0">{style:i,vars:s,transformOrigin:o}=t;</span><span class="s1">let </span><span class="s0">r=!</span><span class="s3">1</span><span class="s0">,a=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">t </span><span class="s1">in </span><span class="s0">e){</span><span class="s1">const </span><span class="s0">n=e[t];</span><span class="s1">if</span><span class="s0">(dn.has(t))r=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">else if</span><span class="s0">(gt(t))s[t]=n;</span><span class="s1">else</span><span class="s0">{</span><span class="s1">const </span><span class="s0">e=Mi(n,fi[t]);t.startsWith(</span><span class="s2">&quot;origin&quot;</span><span class="s0">)?(a=!</span><span class="s3">0</span><span class="s0">,o[t]=e):i[t]=e}}</span><span class="s1">if</span><span class="s0">(e.transform||(r||n?i.transform=Ma(e,t.transform,n):i.transform&amp;&amp;(i.transform=</span><span class="s2">&quot;none&quot;</span><span class="s0">)),a){</span><span class="s1">const</span><span class="s0">{originX:t=</span><span class="s2">&quot;50%&quot;</span><span class="s0">,originY:e=</span><span class="s2">&quot;50%&quot;</span><span class="s0">,originZ:n=</span><span class="s3">0</span><span class="s0">}=o;i.transformOrigin=</span><span class="s2">`</span><span class="s0">${t} ${e} ${n}</span><span class="s2">`</span><span class="s0">}}</span><span class="s1">function </span><span class="s0">Va(t,{style:e,vars:n},i,s){</span><span class="s1">const </span><span class="s0">o=t.style;</span><span class="s1">let </span><span class="s0">r;</span><span class="s1">for</span><span class="s0">(r </span><span class="s1">in </span><span class="s0">e)o[r]=e[r];</span><span class="s1">for</span><span class="s0">(r </span><span class="s1">in </span><span class="s0">s?.applyProjectionStyles(o,i),n)o.setProperty(r,n[r])}</span><span class="s1">function </span><span class="s0">Da(t,{layout:e,layoutId:n}){</span><span class="s1">return </span><span class="s0">dn.has(t)||t.startsWith(</span><span class="s2">&quot;origin&quot;</span><span class="s0">)||(e||</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==n)&amp;&amp;(!!Tr[t]||</span><span class="s2">&quot;opacity&quot;</span><span class="s0">===t)}</span><span class="s1">function </span><span class="s0">Ra(t,e,n){</span><span class="s1">const</span><span class="s0">{style:i}=t,s={};</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">o </span><span class="s1">in </span><span class="s0">i)(Ds(i[o])||e.style&amp;&amp;Ds(e.style[o])||Da(o,t)||</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==n?.getValue(o)?.liveStyle)&amp;&amp;(s[o]=i[o]);</span><span class="s1">return </span><span class="s0">s}</span><span class="s1">class </span><span class="s0">ka </span><span class="s1">extends </span><span class="s0">Sa{constructor(){</span><span class="s1">super</span><span class="s0">(...arguments),</span><span class="s1">this</span><span class="s0">.type=</span><span class="s2">&quot;html&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.renderInstance=Va}readValueFromInstance(t,e){</span><span class="s1">if</span><span class="s0">(dn.has(e))</span><span class="s1">return this</span><span class="s0">.projection?.isProjecting?an(e):un(t,e);{</span><span class="s1">const </span><span class="s0">i=(n=t,window.getComputedStyle(n)),s=(gt(e)?i.getPropertyValue(e):i[e])||</span><span class="s3">0</span><span class="s0">;</span><span class="s1">return</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">s?s.trim():s}</span><span class="s1">var </span><span class="s0">n}measureInstanceViewportBox(t,{transformPagePoint:e}){</span><span class="s1">return </span><span class="s0">aa(t,e)}build(t,e,n){Ca(t,e,n.transformTemplate)}scrapeMotionValuesFromProps(t,e,n){</span><span class="s1">return </span><span class="s0">Ra(t,e,n)}}</span><span class="s1">function </span><span class="s0">La(){</span><span class="s1">const </span><span class="s0">t=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">const </span><span class="s0">t=e.useRef(!</span><span class="s3">1</span><span class="s0">);</span><span class="s1">return </span><span class="s0">y(()=&gt;(t.current=!</span><span class="s3">0</span><span class="s0">,()=&gt;{t.current=!</span><span class="s3">1</span><span class="s0">}),[]),t}(),[n,i]=e.useState(</span><span class="s3">0</span><span class="s0">),s=e.useCallback(()=&gt;{t.current&amp;&amp;i(n+</span><span class="s3">1</span><span class="s0">)},[n]);</span><span class="s1">return</span><span class="s0">[e.useCallback(()=&gt;at.postRender(s),[s]),n]}</span><span class="s1">const </span><span class="s0">Oa=t=&gt;!</span><span class="s3">0</span><span class="s0">===t,ja=({children:t,id:n,inherit:i=!</span><span class="s3">0</span><span class="s0">})=&gt;{</span><span class="s1">const </span><span class="s0">s=e.useContext(m),o=e.useContext(ho),[r,a]=La(),l=e.useRef(</span><span class="s1">null</span><span class="s0">),u=s.id||o;</span><span class="s1">null</span><span class="s0">===l.current&amp;&amp;((t=&gt;Oa(!</span><span class="s3">0</span><span class="s0">===t)||</span><span class="s2">&quot;id&quot;</span><span class="s0">===t)(i)&amp;&amp;u&amp;&amp;(n=n?u+</span><span class="s2">&quot;-&quot;</span><span class="s0">+n:u),l.current={id:n,group:Oa(i)&amp;&amp;s.group||wo()});</span><span class="s1">const </span><span class="s0">c=e.useMemo(()=&gt;({...l.current,forceRender:r}),[a]);</span><span class="s1">return </span><span class="s0">d(m.Provider,{value:c,children:t})},Ba=e.createContext({strict:!</span><span class="s3">1</span><span class="s0">});</span><span class="s1">function </span><span class="s0">Ia(t){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">e </span><span class="s1">in </span><span class="s0">t)ua[e]={...ua[e],...t[e]}}</span><span class="s1">function </span><span class="s0">Fa(t){</span><span class="s1">return</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t}</span><span class="s1">const </span><span class="s0">Wa=</span><span class="s1">new </span><span class="s0">Set([</span><span class="s2">&quot;animate&quot;</span><span class="s0">,</span><span class="s2">&quot;exit&quot;</span><span class="s0">,</span><span class="s2">&quot;variants&quot;</span><span class="s0">,</span><span class="s2">&quot;initial&quot;</span><span class="s0">,</span><span class="s2">&quot;style&quot;</span><span class="s0">,</span><span class="s2">&quot;values&quot;</span><span class="s0">,</span><span class="s2">&quot;variants&quot;</span><span class="s0">,</span><span class="s2">&quot;transition&quot;</span><span class="s0">,</span><span class="s2">&quot;transformTemplate&quot;</span><span class="s0">,</span><span class="s2">&quot;custom&quot;</span><span class="s0">,</span><span class="s2">&quot;inherit&quot;</span><span class="s0">,</span><span class="s2">&quot;onBeforeLayoutMeasure&quot;</span><span class="s0">,</span><span class="s2">&quot;onAnimationStart&quot;</span><span class="s0">,</span><span class="s2">&quot;onAnimationComplete&quot;</span><span class="s0">,</span><span class="s2">&quot;onUpdate&quot;</span><span class="s0">,</span><span class="s2">&quot;onDragStart&quot;</span><span class="s0">,</span><span class="s2">&quot;onDrag&quot;</span><span class="s0">,</span><span class="s2">&quot;onDragEnd&quot;</span><span class="s0">,</span><span class="s2">&quot;onMeasureDragConstraints&quot;</span><span class="s0">,</span><span class="s2">&quot;onDirectionLock&quot;</span><span class="s0">,</span><span class="s2">&quot;onDragTransitionEnd&quot;</span><span class="s0">,</span><span class="s2">&quot;_dragX&quot;</span><span class="s0">,</span><span class="s2">&quot;_dragY&quot;</span><span class="s0">,</span><span class="s2">&quot;onHoverStart&quot;</span><span class="s0">,</span><span class="s2">&quot;onHoverEnd&quot;</span><span class="s0">,</span><span class="s2">&quot;onViewportEnter&quot;</span><span class="s0">,</span><span class="s2">&quot;onViewportLeave&quot;</span><span class="s0">,</span><span class="s2">&quot;globalTapTarget&quot;</span><span class="s0">,</span><span class="s2">&quot;ignoreStrict&quot;</span><span class="s0">,</span><span class="s2">&quot;viewport&quot;</span><span class="s0">]);</span><span class="s1">function </span><span class="s0">Ua(t){</span><span class="s1">return </span><span class="s0">t.startsWith(</span><span class="s2">&quot;while&quot;</span><span class="s0">)||t.startsWith(</span><span class="s2">&quot;drag&quot;</span><span class="s0">)&amp;&amp;</span><span class="s2">&quot;draggable&quot;</span><span class="s0">!==t||t.startsWith(</span><span class="s2">&quot;layout&quot;</span><span class="s0">)||t.startsWith(</span><span class="s2">&quot;onTap&quot;</span><span class="s0">)||t.startsWith(</span><span class="s2">&quot;onPan&quot;</span><span class="s0">)||t.startsWith(</span><span class="s2">&quot;onLayout&quot;</span><span class="s0">)||Wa.has(t)}</span><span class="s1">let </span><span class="s0">Na=t=&gt;!Ua(t);</span><span class="s1">function </span><span class="s0">$a(t){</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t&amp;&amp;(Na=e=&gt;e.startsWith(</span><span class="s2">&quot;on&quot;</span><span class="s0">)?!Ua(e):t(e))}</span><span class="s1">try</span><span class="s0">{$a(require(</span><span class="s2">&quot;@emotion/is-prop-valid&quot;</span><span class="s0">).default)}</span><span class="s1">catch</span><span class="s0">{}</span><span class="s1">function </span><span class="s0">za(t,e,n){</span><span class="s1">const </span><span class="s0">i={};</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">s </span><span class="s1">in </span><span class="s0">t)</span><span class="s2">&quot;values&quot;</span><span class="s0">===s&amp;&amp;</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t.values||(Na(s)||!</span><span class="s3">0</span><span class="s0">===n&amp;&amp;Ua(s)||!e&amp;&amp;!Ua(s)||t.draggable&amp;&amp;s.startsWith(</span><span class="s2">&quot;onDrag&quot;</span><span class="s0">))&amp;&amp;(i[s]=t[s]);</span><span class="s1">return </span><span class="s0">i}</span><span class="s1">const </span><span class="s0">Xa=e.createContext(</span><span class="s1">null</span><span class="s0">),Ha={offset:</span><span class="s2">&quot;stroke-dashoffset&quot;</span><span class="s0">,array:</span><span class="s2">&quot;stroke-dasharray&quot;</span><span class="s0">},Ya={offset:</span><span class="s2">&quot;strokeDashoffset&quot;</span><span class="s0">,array:</span><span class="s2">&quot;strokeDasharray&quot;</span><span class="s0">};</span><span class="s1">function </span><span class="s0">Ka(t,{attrX:e,attrY:n,attrScale:i,pathLength:s,pathSpacing:o=</span><span class="s3">1</span><span class="s0">,pathOffset:r=</span><span class="s3">0</span><span class="s0">,...a},l,u,c){</span><span class="s1">if</span><span class="s0">(Ca(t,a,u),l)</span><span class="s1">return void</span><span class="s0">(t.style.viewBox&amp;&amp;(t.attrs.viewBox=t.style.viewBox));t.attrs=t.style,t.style={};</span><span class="s1">const</span><span class="s0">{attrs:h,style:d}=t;h.transform&amp;&amp;(d.transform=h.transform,</span><span class="s1">delete </span><span class="s0">h.transform),(d.transform||h.transformOrigin)&amp;&amp;(d.transformOrigin=h.transformOrigin??</span><span class="s2">&quot;50% 50%&quot;</span><span class="s0">,</span><span class="s1">delete </span><span class="s0">h.transformOrigin),d.transform&amp;&amp;(d.transformBox=c?.transformBox??</span><span class="s2">&quot;fill-box&quot;</span><span class="s0">,</span><span class="s1">delete </span><span class="s0">h.transformBox),</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==e&amp;&amp;(h.x=e),</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==n&amp;&amp;(h.y=n),</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==i&amp;&amp;(h.scale=i),</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==s&amp;&amp;</span><span class="s1">function</span><span class="s0">(t,e,n=</span><span class="s3">1</span><span class="s0">,i=</span><span class="s3">0</span><span class="s0">,s=!</span><span class="s3">0</span><span class="s0">){t.pathLength=</span><span class="s3">1</span><span class="s0">;</span><span class="s1">const </span><span class="s0">o=s?Ha:Ya;t[o.offset]=Ot.transform(-i);</span><span class="s1">const </span><span class="s0">r=Ot.transform(e),a=Ot.transform(n);t[o.array]=</span><span class="s2">`</span><span class="s0">${r} ${a}</span><span class="s2">`</span><span class="s0">}(h,s,o,r,!</span><span class="s3">1</span><span class="s0">)}</span><span class="s1">const </span><span class="s0">Ga=</span><span class="s1">new </span><span class="s0">Set([</span><span class="s2">&quot;baseFrequency&quot;</span><span class="s0">,</span><span class="s2">&quot;diffuseConstant&quot;</span><span class="s0">,</span><span class="s2">&quot;kernelMatrix&quot;</span><span class="s0">,</span><span class="s2">&quot;kernelUnitLength&quot;</span><span class="s0">,</span><span class="s2">&quot;keySplines&quot;</span><span class="s0">,</span><span class="s2">&quot;keyTimes&quot;</span><span class="s0">,</span><span class="s2">&quot;limitingConeAngle&quot;</span><span class="s0">,</span><span class="s2">&quot;markerHeight&quot;</span><span class="s0">,</span><span class="s2">&quot;markerWidth&quot;</span><span class="s0">,</span><span class="s2">&quot;numOctaves&quot;</span><span class="s0">,</span><span class="s2">&quot;targetX&quot;</span><span class="s0">,</span><span class="s2">&quot;targetY&quot;</span><span class="s0">,</span><span class="s2">&quot;surfaceScale&quot;</span><span class="s0">,</span><span class="s2">&quot;specularConstant&quot;</span><span class="s0">,</span><span class="s2">&quot;specularExponent&quot;</span><span class="s0">,</span><span class="s2">&quot;stdDeviation&quot;</span><span class="s0">,</span><span class="s2">&quot;tableValues&quot;</span><span class="s0">,</span><span class="s2">&quot;viewBox&quot;</span><span class="s0">,</span><span class="s2">&quot;gradientTransform&quot;</span><span class="s0">,</span><span class="s2">&quot;pathLength&quot;</span><span class="s0">,</span><span class="s2">&quot;startOffset&quot;</span><span class="s0">,</span><span class="s2">&quot;textLength&quot;</span><span class="s0">,</span><span class="s2">&quot;lengthAdjust&quot;</span><span class="s0">]),_a=t=&gt;</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t&amp;&amp;</span><span class="s2">&quot;svg&quot;</span><span class="s0">===t.toLowerCase();</span><span class="s1">function </span><span class="s0">Za(t,e,n){</span><span class="s1">const </span><span class="s0">i=Ra(t,e,n);</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">n </span><span class="s1">in </span><span class="s0">t)</span><span class="s1">if</span><span class="s0">(Ds(t[n])||Ds(e[n])){i[-</span><span class="s3">1</span><span class="s0">!==hn.indexOf(n)?</span><span class="s2">&quot;attr&quot;</span><span class="s0">+n.charAt(</span><span class="s3">0</span><span class="s0">).toUpperCase()+n.substring(</span><span class="s3">1</span><span class="s0">):n]=t[n]}</span><span class="s1">return </span><span class="s0">i}</span><span class="s1">class </span><span class="s0">qa </span><span class="s1">extends </span><span class="s0">Sa{constructor(){</span><span class="s1">super</span><span class="s0">(...arguments),</span><span class="s1">this</span><span class="s0">.type=</span><span class="s2">&quot;svg&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.isSVGTag=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.measureInstanceViewportBox=dr}getBaseTargetFromProps(t,e){</span><span class="s1">return </span><span class="s0">t[e]}readValueFromInstance(t,e){</span><span class="s1">if</span><span class="s0">(dn.has(e)){</span><span class="s1">const </span><span class="s0">t=yi(e);</span><span class="s1">return </span><span class="s0">t&amp;&amp;t.default||</span><span class="s3">0</span><span class="s0">}</span><span class="s1">return </span><span class="s0">e=Ga.has(e)?e:Co(e),t.getAttribute(e)}scrapeMotionValuesFromProps(t,e,n){</span><span class="s1">return </span><span class="s0">Za(t,e,n)}build(t,e,n){Ka(t,e,</span><span class="s1">this</span><span class="s0">.isSVGTag,n.transformTemplate,n.style)}renderInstance(t,e,n,i){!</span><span class="s1">function</span><span class="s0">(t,e,n,i){Va(t,e,</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,i);</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">n </span><span class="s1">in </span><span class="s0">e.attrs)t.setAttribute(Ga.has(n)?n:Co(n),e.attrs[n])}(t,e,</span><span class="s3">0</span><span class="s0">,i)}mount(t){</span><span class="s1">this</span><span class="s0">.isSVGTag=_a(t.tagName),</span><span class="s1">super</span><span class="s0">.mount(t)}}</span><span class="s1">const </span><span class="s0">Ja=[</span><span class="s2">&quot;animate&quot;</span><span class="s0">,</span><span class="s2">&quot;circle&quot;</span><span class="s0">,</span><span class="s2">&quot;defs&quot;</span><span class="s0">,</span><span class="s2">&quot;desc&quot;</span><span class="s0">,</span><span class="s2">&quot;ellipse&quot;</span><span class="s0">,</span><span class="s2">&quot;g&quot;</span><span class="s0">,</span><span class="s2">&quot;image&quot;</span><span class="s0">,</span><span class="s2">&quot;line&quot;</span><span class="s0">,</span><span class="s2">&quot;filter&quot;</span><span class="s0">,</span><span class="s2">&quot;marker&quot;</span><span class="s0">,</span><span class="s2">&quot;mask&quot;</span><span class="s0">,</span><span class="s2">&quot;metadata&quot;</span><span class="s0">,</span><span class="s2">&quot;path&quot;</span><span class="s0">,</span><span class="s2">&quot;pattern&quot;</span><span class="s0">,</span><span class="s2">&quot;polygon&quot;</span><span class="s0">,</span><span class="s2">&quot;polyline&quot;</span><span class="s0">,</span><span class="s2">&quot;rect&quot;</span><span class="s0">,</span><span class="s2">&quot;stop&quot;</span><span class="s0">,</span><span class="s2">&quot;switch&quot;</span><span class="s0">,</span><span class="s2">&quot;symbol&quot;</span><span class="s0">,</span><span class="s2">&quot;svg&quot;</span><span class="s0">,</span><span class="s2">&quot;text&quot;</span><span class="s0">,</span><span class="s2">&quot;tspan&quot;</span><span class="s0">,</span><span class="s2">&quot;use&quot;</span><span class="s0">,</span><span class="s2">&quot;view&quot;</span><span class="s0">];</span><span class="s1">function </span><span class="s0">Qa(t){</span><span class="s1">return</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t&amp;&amp;!t.includes(</span><span class="s2">&quot;-&quot;</span><span class="s0">)&amp;&amp;!!(Ja.indexOf(t)&gt;-</span><span class="s3">1</span><span class="s0">||</span><span class="s4">/[A-Z]/u</span><span class="s0">.test(t))}</span><span class="s1">const </span><span class="s0">tl=(t,n)=&gt;Qa(t)?</span><span class="s1">new </span><span class="s0">qa(n):</span><span class="s1">new </span><span class="s0">ka(n,{allowProjection:t!==e.Fragment}),el=e.createContext({});</span><span class="s1">function </span><span class="s0">nl(t){</span><span class="s1">const</span><span class="s0">{initial:n,animate:i}=</span><span class="s1">function</span><span class="s0">(t,e){</span><span class="s1">if</span><span class="s0">(va(t)){</span><span class="s1">const</span><span class="s0">{initial:e,animate:n}=t;</span><span class="s1">return</span><span class="s0">{initial:!</span><span class="s3">1</span><span class="s0">===e||fa(e)?e:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,animate:fa(n)?n:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">}}</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">!==t.inherit?e:{}}(t,e.useContext(el));</span><span class="s1">return </span><span class="s0">e.useMemo(()=&gt;({initial:n,animate:i}),[il(n),il(i)])}</span><span class="s1">function </span><span class="s0">il(t){</span><span class="s1">return </span><span class="s0">Array.isArray(t)?t.join(</span><span class="s2">&quot; &quot;</span><span class="s0">):t}</span><span class="s1">const </span><span class="s0">sl=()=&gt;({style:{},transform:{},transformOrigin:{},vars:{}});</span><span class="s1">function </span><span class="s0">ol(t,e,n){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">i </span><span class="s1">in </span><span class="s0">e)Ds(e[i])||Da(i,n)||(t[i]=e[i])}</span><span class="s1">function </span><span class="s0">rl(t,n){</span><span class="s1">const </span><span class="s0">i={};</span><span class="s1">return </span><span class="s0">ol(i,t.style||{},t),Object.assign(i,</span><span class="s1">function</span><span class="s0">({transformTemplate:t},n){</span><span class="s1">return </span><span class="s0">e.useMemo(()=&gt;{</span><span class="s1">const </span><span class="s0">e={style:{},transform:{},transformOrigin:{},vars:{}};</span><span class="s1">return </span><span class="s0">Ca(e,n,t),Object.assign({},e.vars,e.style)},[n])}(t,n)),i}</span><span class="s1">function </span><span class="s0">al(t,e){</span><span class="s1">const </span><span class="s0">n={},i=rl(t,e);</span><span class="s1">return </span><span class="s0">t.drag&amp;&amp;!</span><span class="s3">1</span><span class="s0">!==t.dragListener&amp;&amp;(n.draggable=!</span><span class="s3">1</span><span class="s0">,i.userSelect=i.WebkitUserSelect=i.WebkitTouchCallout=</span><span class="s2">&quot;none&quot;</span><span class="s0">,i.touchAction=!</span><span class="s3">0</span><span class="s0">===t.drag?</span><span class="s2">&quot;none&quot;</span><span class="s0">:</span><span class="s2">&quot;pan-&quot;</span><span class="s0">+(</span><span class="s2">&quot;x&quot;</span><span class="s0">===t.drag?</span><span class="s2">&quot;y&quot;</span><span class="s0">:</span><span class="s2">&quot;x&quot;</span><span class="s0">)),</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===t.tabIndex&amp;&amp;(t.onTap||t.onTapStart||t.whileTap)&amp;&amp;(n.tabIndex=</span><span class="s3">0</span><span class="s0">),n.style=i,n}</span><span class="s1">const </span><span class="s0">ll=()=&gt;({style:{},transform:{},transformOrigin:{},vars:{},attrs:{}});</span><span class="s1">function </span><span class="s0">ul(t,n,i,s){</span><span class="s1">const </span><span class="s0">o=e.useMemo(()=&gt;{</span><span class="s1">const </span><span class="s0">e={style:{},transform:{},transformOrigin:{},vars:{},attrs:{}};</span><span class="s1">return </span><span class="s0">Ka(e,n,_a(s),t.transformTemplate,t.style),{...e.attrs,style:{...e.style}}},[n]);</span><span class="s1">if</span><span class="s0">(t.style){</span><span class="s1">const </span><span class="s0">e={};ol(e,t.style,t),o.style={...e,...o.style}}</span><span class="s1">return </span><span class="s0">o}</span><span class="s1">function </span><span class="s0">cl(t,n,i,{latestValues:s},o,r=!</span><span class="s3">1</span><span class="s0">){</span><span class="s1">const </span><span class="s0">a=(Qa(t)?ul:al)(n,s,o,t),l=za(n,</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t,r),u=t!==e.Fragment?{...l,...a,ref:i}:{},{children:c}=n,h=e.useMemo(()=&gt;Ds(c)?c.get():c,[c]);</span><span class="s1">return </span><span class="s0">e.createElement(t,{...u,children:h})}</span><span class="s1">function </span><span class="s0">hl(t,e,n,i){</span><span class="s1">const </span><span class="s0">s={},o=i(t,{});</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">t </span><span class="s1">in </span><span class="s0">o)s[t]=jo(o[t]);</span><span class="s1">let</span><span class="s0">{initial:r,animate:a}=t;</span><span class="s1">const </span><span class="s0">l=va(t),u=xa(t);e&amp;&amp;u&amp;&amp;!l&amp;&amp;!</span><span class="s3">1</span><span class="s0">!==t.inherit&amp;&amp;(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===r&amp;&amp;(r=e.initial),</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===a&amp;&amp;(a=e.animate));</span><span class="s1">let </span><span class="s0">c=!!n&amp;&amp;!</span><span class="s3">1</span><span class="s0">===n.initial;c=c||!</span><span class="s3">1</span><span class="s0">===r;</span><span class="s1">const </span><span class="s0">h=c?a:r;</span><span class="s1">if</span><span class="s0">(h&amp;&amp;</span><span class="s2">&quot;boolean&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">h&amp;&amp;!ma(h)){</span><span class="s1">const </span><span class="s0">e=Array.isArray(h)?h:[h];</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">n=</span><span class="s3">0</span><span class="s0">;n&lt;e.length;n++){</span><span class="s1">const </span><span class="s0">i=Ta(t,e[n]);</span><span class="s1">if</span><span class="s0">(i){</span><span class="s1">const</span><span class="s0">{transitionEnd:t,transition:e,...n}=i;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">t </span><span class="s1">in </span><span class="s0">n){</span><span class="s1">let </span><span class="s0">e=n[t];</span><span class="s1">if</span><span class="s0">(Array.isArray(e)){e=e[c?e.length-</span><span class="s3">1</span><span class="s0">:</span><span class="s3">0</span><span class="s0">]}</span><span class="s1">null</span><span class="s0">!==e&amp;&amp;(s[t]=e)}</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">e </span><span class="s1">in </span><span class="s0">t)s[e]=t[e]}}}</span><span class="s1">return </span><span class="s0">s}</span><span class="s1">const </span><span class="s0">dl=t=&gt;(n,i)=&gt;{</span><span class="s1">const </span><span class="s0">s=e.useContext(el),o=e.useContext(v),r=()=&gt;</span><span class="s1">function</span><span class="s0">({scrapeMotionValuesFromProps:t,createRenderState:e},n,i,s){</span><span class="s1">return</span><span class="s0">{latestValues:hl(n,i,s,t),renderState:e()}}(t,n,s,o);</span><span class="s1">return </span><span class="s0">i?r():f(r)},pl=dl({scrapeMotionValuesFromProps:Ra,createRenderState:sl}),ml=dl({scrapeMotionValuesFromProps:Za,createRenderState:ll}),fl=Symbol.for(</span><span class="s2">&quot;motionComponentSymbol&quot;</span><span class="s0">);</span><span class="s1">function </span><span class="s0">gl(t){</span><span class="s1">return </span><span class="s0">t&amp;&amp;</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t&amp;&amp;Object.prototype.hasOwnProperty.call(t,</span><span class="s2">&quot;current&quot;</span><span class="s0">)}</span><span class="s1">function </span><span class="s0">yl(t,n,i){</span><span class="s1">return </span><span class="s0">e.useCallback(e=&gt;{e&amp;&amp;t.onMount&amp;&amp;t.onMount(e),n&amp;&amp;(e?n.mount(e):n.unmount()),i&amp;&amp;(</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">i?i(e):gl(i)&amp;&amp;(i.current=e))},[n])}</span><span class="s1">const </span><span class="s0">vl=e.createContext({});</span><span class="s1">function </span><span class="s0">xl(t,n,i,s,o){</span><span class="s1">const</span><span class="s0">{visualElement:r}=e.useContext(el),a=e.useContext(Ba),l=e.useContext(v),u=e.useContext(eo).reducedMotion,c=e.useRef(</span><span class="s1">null</span><span class="s0">);s=s||a.renderer,!c.current&amp;&amp;s&amp;&amp;(c.current=s(t,{visualState:n,parent:r,props:i,presenceContext:l,blockInitialAnimation:!!l&amp;&amp;!</span><span class="s3">1</span><span class="s0">===l.initial,reducedMotionConfig:u}));</span><span class="s1">const </span><span class="s0">h=c.current,d=e.useContext(vl);!h||h.projection||!o||</span><span class="s2">&quot;html&quot;</span><span class="s0">!==h.type&amp;&amp;</span><span class="s2">&quot;svg&quot;</span><span class="s0">!==h.type||</span><span class="s1">function</span><span class="s0">(t,e,n,i){</span><span class="s1">const</span><span class="s0">{layoutId:s,layout:o,drag:r,dragConstraints:a,layoutScroll:l,layoutRoot:u,layoutCrossfade:c}=e;t.projection=</span><span class="s1">new </span><span class="s0">n(t.latestValues,e[</span><span class="s2">&quot;data-framer-portal-id&quot;</span><span class="s0">]?</span><span class="s1">void </span><span class="s3">0</span><span class="s0">:wl(t.parent)),t.projection.setOptions({layoutId:s,layout:o,alwaysMeasureLayout:Boolean(r)||a&amp;&amp;gl(a),visualElement:t,animationType:</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">o?o:</span><span class="s2">&quot;both&quot;</span><span class="s0">,initialPromotionConfig:i,crossfade:c,layoutScroll:l,layoutRoot:u})}(c.current,i,o,d);</span><span class="s1">const </span><span class="s0">p=e.useRef(!</span><span class="s3">1</span><span class="s0">);e.useInsertionEffect(()=&gt;{h&amp;&amp;p.current&amp;&amp;h.update(i,l)});</span><span class="s1">const </span><span class="s0">m=i[Do],f=e.useRef(Boolean(m)&amp;&amp;!window.MotionHandoffIsComplete?.(m)&amp;&amp;window.MotionHasOptimisedAnimation?.(m));</span><span class="s1">return </span><span class="s0">y(()=&gt;{h&amp;&amp;(p.current=!</span><span class="s3">0</span><span class="s0">,window.MotionIsMounted=!</span><span class="s3">0</span><span class="s0">,h.updateFeatures(),h.scheduleRenderMicrotask(),f.current&amp;&amp;h.animationState&amp;&amp;h.animationState.animateChanges())}),e.useEffect(()=&gt;{h&amp;&amp;(!f.current&amp;&amp;h.animationState&amp;&amp;h.animationState.animateChanges(),f.current&amp;&amp;(queueMicrotask(()=&gt;{window.MotionHandoffMarkAsComplete?.(m)}),f.current=!</span><span class="s3">1</span><span class="s0">),h.enteringChildren=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">)}),h}</span><span class="s1">function </span><span class="s0">wl(t){</span><span class="s1">if</span><span class="s0">(t)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">!==t.options.allowProjection?t.projection:wl(t.parent)}</span><span class="s1">function </span><span class="s0">Tl(t,{forwardMotionProps:n=!</span><span class="s3">1</span><span class="s0">}={},i,s){i&amp;&amp;Ia(i);</span><span class="s1">const </span><span class="s0">o=Qa(t)?ml:pl;</span><span class="s1">function </span><span class="s0">r(i,r){</span><span class="s1">let </span><span class="s0">a;</span><span class="s1">const </span><span class="s0">l={...e.useContext(eo),...i,layoutId:Pl(i)},{isStatic:u}=l,c=nl(i),h=o(i,u);</span><span class="s1">if</span><span class="s0">(!u&amp;&amp;g){e.useContext(Ba).strict;</span><span class="s1">const </span><span class="s0">n=</span><span class="s1">function</span><span class="s0">(t){</span><span class="s1">const</span><span class="s0">{drag:e,layout:n}=ua;</span><span class="s1">if</span><span class="s0">(!e&amp;&amp;!n)</span><span class="s1">return</span><span class="s0">{};</span><span class="s1">const </span><span class="s0">i={...e,...n};</span><span class="s1">return</span><span class="s0">{MeasureLayout:e?.isEnabled(t)||n?.isEnabled(t)?i.MeasureLayout:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,ProjectionNode:i.ProjectionNode}}(l);a=n.MeasureLayout,c.visualElement=xl(t,h,l,s,n.ProjectionNode)}</span><span class="s1">return </span><span class="s0">p(el.Provider,{value:c,children:[a&amp;&amp;c.visualElement?d(a,{visualElement:c.visualElement,...l}):</span><span class="s1">null</span><span class="s0">,cl(t,i,yl(h,c.visualElement,r),h,u,n)]})}r.displayName=</span><span class="s2">`motion.</span><span class="s0">${</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t?t:</span><span class="s2">`create(</span><span class="s0">${t.displayName??t.name??</span><span class="s2">&quot;&quot;</span><span class="s0">}</span><span class="s2">)`</span><span class="s0">}</span><span class="s2">`</span><span class="s0">;</span><span class="s1">const </span><span class="s0">a=e.forwardRef(r);</span><span class="s1">return </span><span class="s0">a[fl]=t,a}</span><span class="s1">function </span><span class="s0">Pl({layoutId:t}){</span><span class="s1">const </span><span class="s0">n=e.useContext(m).id;</span><span class="s1">return </span><span class="s0">n&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==t?n+</span><span class="s2">&quot;-&quot;</span><span class="s0">+t:t}</span><span class="s1">function </span><span class="s0">bl(t,e){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;undefined&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">Proxy)</span><span class="s1">return </span><span class="s0">Tl;</span><span class="s1">const </span><span class="s0">n=</span><span class="s1">new </span><span class="s0">Map,i=(n,i)=&gt;Tl(n,i,t,e);</span><span class="s1">return new </span><span class="s0">Proxy((t,e)=&gt;i(t,e),{get:(s,o)=&gt;</span><span class="s2">&quot;create&quot;</span><span class="s0">===o?i:(n.has(o)||n.set(o,Tl(o,</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,t,e)),n.get(o))})}</span><span class="s1">function </span><span class="s0">Sl(t,e,n){</span><span class="s1">const </span><span class="s0">i=t.getProps();</span><span class="s1">return </span><span class="s0">Ta(i,e,</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==n?n:i.custom,t)}</span><span class="s1">const </span><span class="s0">El=t=&gt;Array.isArray(t);</span><span class="s1">function </span><span class="s0">Al(t,e,n){t.hasValue(e)?t.getValue(e).set(n):t.addValue(e,Bi(n))}</span><span class="s1">function </span><span class="s0">Ml(t){</span><span class="s1">return </span><span class="s0">El(t)?t[t.length-</span><span class="s3">1</span><span class="s0">]||</span><span class="s3">0</span><span class="s0">:t}</span><span class="s1">function </span><span class="s0">Cl(t,e){</span><span class="s1">const </span><span class="s0">n=Sl(t,e);</span><span class="s1">let</span><span class="s0">{transitionEnd:i={},transition:s={},...o}=n||{};o={...o,...i};</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">e </span><span class="s1">in </span><span class="s0">o){Al(t,e,Ml(o[e]))}}</span><span class="s1">function </span><span class="s0">Vl(t,e){</span><span class="s1">const </span><span class="s0">n=t.getValue(</span><span class="s2">&quot;willChange&quot;</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(i=n,Boolean(Ds(i)&amp;&amp;i.add))</span><span class="s1">return </span><span class="s0">n.add(e);</span><span class="s1">if</span><span class="s0">(!n&amp;&amp;S.WillChange){</span><span class="s1">const </span><span class="s0">n=</span><span class="s1">new </span><span class="s0">S.WillChange(</span><span class="s2">&quot;auto&quot;</span><span class="s0">);t.addValue(</span><span class="s2">&quot;willChange&quot;</span><span class="s0">,n),n.add(e)}</span><span class="s1">var </span><span class="s0">i}</span><span class="s1">function </span><span class="s0">Dl({protectedKeys:t,needsAnimating:e},n){</span><span class="s1">const </span><span class="s0">i=t.hasOwnProperty(n)&amp;&amp;!</span><span class="s3">0</span><span class="s0">!==e[n];</span><span class="s1">return </span><span class="s0">e[n]=!</span><span class="s3">1</span><span class="s0">,i}</span><span class="s1">function </span><span class="s0">Rl(t,e,{delay:n=</span><span class="s3">0</span><span class="s0">,transitionOverride:i,type:s}={}){</span><span class="s1">let</span><span class="s0">{transition:o=t.getDefaultTransition(),transitionEnd:r,...a}=e;i&amp;&amp;(o=i);</span><span class="s1">const </span><span class="s0">l=[],u=s&amp;&amp;t.animationState&amp;&amp;t.animationState.getState()[s];</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">e </span><span class="s1">in </span><span class="s0">a){</span><span class="s1">const </span><span class="s0">i=t.getValue(e,t.latestValues[e]??</span><span class="s1">null</span><span class="s0">),s=a[e];</span><span class="s1">if</span><span class="s0">(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===s||u&amp;&amp;Dl(u,e))</span><span class="s1">continue</span><span class="s0">;</span><span class="s1">const </span><span class="s0">r={delay:n,...ii(o||{},e)},c=i.get();</span><span class="s1">if</span><span class="s0">(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==c&amp;&amp;!i.isAnimating&amp;&amp;!Array.isArray(s)&amp;&amp;s===c&amp;&amp;!r.velocity)</span><span class="s1">continue</span><span class="s0">;</span><span class="s1">let </span><span class="s0">h=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(window.MotionHandoffAnimation){</span><span class="s1">const </span><span class="s0">n=Ro(t);</span><span class="s1">if</span><span class="s0">(n){</span><span class="s1">const </span><span class="s0">t=window.MotionHandoffAnimation(n,e,at);</span><span class="s1">null</span><span class="s0">!==t&amp;&amp;(r.startTime=t,h=!</span><span class="s3">0</span><span class="s0">)}}Vl(t,e),i.start(Ao(e,i,s,t.shouldReduceMotion&amp;&amp;si.has(e)?{type:!</span><span class="s3">1</span><span class="s0">}:r,t,h));</span><span class="s1">const </span><span class="s0">d=i.animation;d&amp;&amp;l.push(d)}</span><span class="s1">return </span><span class="s0">r&amp;&amp;Promise.all(l).then(()=&gt;{at.update(()=&gt;{r&amp;&amp;Cl(t,r)})}),l}</span><span class="s1">function </span><span class="s0">kl(t,e,n,i=</span><span class="s3">0</span><span class="s0">,s=</span><span class="s3">1</span><span class="s0">){</span><span class="s1">const </span><span class="s0">o=Array.from(t).sort((t,e)=&gt;t.sortNodePosition(e)).indexOf(e),r=t.size,a=(r-</span><span class="s3">1</span><span class="s0">)*i;</span><span class="s1">return</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">n?n(o,r):</span><span class="s3">1</span><span class="s0">===s?o*i:a-o*i}</span><span class="s1">function </span><span class="s0">Ll(t,e,n={}){</span><span class="s1">const </span><span class="s0">i=Sl(t,e,</span><span class="s2">&quot;exit&quot;</span><span class="s0">===n.type?t.presenceContext?.custom:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">);</span><span class="s1">let</span><span class="s0">{transition:s=t.getDefaultTransition()||{}}=i||{};n.transitionOverride&amp;&amp;(s=n.transitionOverride);</span><span class="s1">const </span><span class="s0">o=i?()=&gt;Promise.all(Rl(t,i,n)):()=&gt;Promise.resolve(),r=t.variantChildren&amp;&amp;t.variantChildren.size?(i=</span><span class="s3">0</span><span class="s0">)=&gt;{</span><span class="s1">const</span><span class="s0">{delayChildren:o=</span><span class="s3">0</span><span class="s0">,staggerChildren:r,staggerDirection:a}=s;</span><span class="s1">return function</span><span class="s0">(t,e,n=</span><span class="s3">0</span><span class="s0">,i=</span><span class="s3">0</span><span class="s0">,s=</span><span class="s3">0</span><span class="s0">,o=</span><span class="s3">1</span><span class="s0">,r){</span><span class="s1">const </span><span class="s0">a=[];</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">l of t.variantChildren)l.notify(</span><span class="s2">&quot;AnimationStart&quot;</span><span class="s0">,e),a.push(Ll(l,e,{...r,delay:n+(</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">i?</span><span class="s3">0</span><span class="s0">:i)+kl(t.variantChildren,l,i,s,o)}).then(()=&gt;l.notify(</span><span class="s2">&quot;AnimationComplete&quot;</span><span class="s0">,e)));</span><span class="s1">return </span><span class="s0">Promise.all(a)}(t,e,i,o,r,a,n)}:()=&gt;Promise.resolve(),{when:a}=s;</span><span class="s1">if</span><span class="s0">(a){</span><span class="s1">const</span><span class="s0">[t,e]=</span><span class="s2">&quot;beforeChildren&quot;</span><span class="s0">===a?[o,r]:[r,o];</span><span class="s1">return </span><span class="s0">t().then(()=&gt;e())}</span><span class="s1">return </span><span class="s0">Promise.all([o(),r(n.delay)])}</span><span class="s1">function </span><span class="s0">Ol(t,e,n={}){</span><span class="s1">let </span><span class="s0">i;</span><span class="s1">if</span><span class="s0">(t.notify(</span><span class="s2">&quot;AnimationStart&quot;</span><span class="s0">,e),Array.isArray(e)){</span><span class="s1">const </span><span class="s0">s=e.map(e=&gt;Ll(t,e,n));i=Promise.all(s)}</span><span class="s1">else if</span><span class="s0">(</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e)i=Ll(t,e,n);</span><span class="s1">else</span><span class="s0">{</span><span class="s1">const </span><span class="s0">s=</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e?Sl(t,e,n.custom):e;i=Promise.all(Rl(t,s,n))}</span><span class="s1">return </span><span class="s0">i.then(()=&gt;{t.notify(</span><span class="s2">&quot;AnimationComplete&quot;</span><span class="s0">,e)})}</span><span class="s1">function </span><span class="s0">jl(t,e){</span><span class="s1">if</span><span class="s0">(!Array.isArray(e))</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">const </span><span class="s0">n=e.length;</span><span class="s1">if</span><span class="s0">(n!==t.length)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">i=</span><span class="s3">0</span><span class="s0">;i&lt;n;i++)</span><span class="s1">if</span><span class="s0">(e[i]!==t[i])</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">return</span><span class="s0">!</span><span class="s3">0</span><span class="s0">}</span><span class="s1">const </span><span class="s0">Bl=ya.length;</span><span class="s1">function </span><span class="s0">Il(t){</span><span class="s1">if</span><span class="s0">(!t)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(!t.isControllingVariants){</span><span class="s1">const </span><span class="s0">e=t.parent&amp;&amp;Il(t.parent)||{};</span><span class="s1">return void </span><span class="s3">0</span><span class="s0">!==t.props.initial&amp;&amp;(e.initial=t.props.initial),e}</span><span class="s1">const </span><span class="s0">e={};</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">n=</span><span class="s3">0</span><span class="s0">;n&lt;Bl;n++){</span><span class="s1">const </span><span class="s0">i=ya[n],s=t.props[i];(fa(s)||!</span><span class="s3">1</span><span class="s0">===s)&amp;&amp;(e[i]=s)}</span><span class="s1">return </span><span class="s0">e}</span><span class="s1">const </span><span class="s0">Fl=[...ga].reverse(),Wl=ga.length;</span><span class="s1">function </span><span class="s0">Ul(t){</span><span class="s1">let </span><span class="s0">e=</span><span class="s1">function</span><span class="s0">(t){</span><span class="s1">return </span><span class="s0">e=&gt;Promise.all(e.map(({animation:e,options:n})=&gt;Ol(t,e,n)))}(t),n=zl(),i=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">const </span><span class="s0">s=e=&gt;(n,i)=&gt;{</span><span class="s1">const </span><span class="s0">s=Sl(t,i,</span><span class="s2">&quot;exit&quot;</span><span class="s0">===e?t.presenceContext?.custom:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(s){</span><span class="s1">const</span><span class="s0">{transition:t,transitionEnd:e,...i}=s;n={...n,...i,...e}}</span><span class="s1">return </span><span class="s0">n};</span><span class="s1">function </span><span class="s0">o(o){</span><span class="s1">const</span><span class="s0">{props:r}=t,a=Il(t.parent)||{},l=[],u=</span><span class="s1">new </span><span class="s0">Set;</span><span class="s1">let </span><span class="s0">c={},h=</span><span class="s3">1</span><span class="s0">/</span><span class="s3">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">e=</span><span class="s3">0</span><span class="s0">;e&lt;Wl;e++){</span><span class="s1">const </span><span class="s0">d=Fl[e],p=n[d],m=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==r[d]?r[d]:a[d],f=fa(m),g=d===o?p.isActive:</span><span class="s1">null</span><span class="s0">;!</span><span class="s3">1</span><span class="s0">===g&amp;&amp;(h=e);</span><span class="s1">let </span><span class="s0">y=m===a[d]&amp;&amp;m!==r[d]&amp;&amp;f;</span><span class="s1">if</span><span class="s0">(y&amp;&amp;i&amp;&amp;t.manuallyAnimateOnMount&amp;&amp;(y=!</span><span class="s3">1</span><span class="s0">),p.protectedKeys={...c},!p.isActive&amp;&amp;</span><span class="s1">null</span><span class="s0">===g||!m&amp;&amp;!p.prevProp||ma(m)||</span><span class="s2">&quot;boolean&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">m)</span><span class="s1">continue</span><span class="s0">;</span><span class="s1">const </span><span class="s0">v=Nl(p.prevProp,m);</span><span class="s1">let </span><span class="s0">x=v||d===o&amp;&amp;p.isActive&amp;&amp;!y&amp;&amp;f||e&gt;h&amp;&amp;f,w=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">const </span><span class="s0">T=Array.isArray(m)?m:[m];</span><span class="s1">let </span><span class="s0">P=T.reduce(s(d),{});!</span><span class="s3">1</span><span class="s0">===g&amp;&amp;(P={});</span><span class="s1">const</span><span class="s0">{prevResolvedValues:b={}}=p,S={...b,...P},E=e=&gt;{x=!</span><span class="s3">0</span><span class="s0">,u.has(e)&amp;&amp;(w=!</span><span class="s3">0</span><span class="s0">,u.delete(e)),p.needsAnimating[e]=!</span><span class="s3">0</span><span class="s0">;</span><span class="s1">const </span><span class="s0">n=t.getValue(e);n&amp;&amp;(n.liveStyle=!</span><span class="s3">1</span><span class="s0">)};</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">t </span><span class="s1">in </span><span class="s0">S){</span><span class="s1">const </span><span class="s0">e=P[t],n=b[t];</span><span class="s1">if</span><span class="s0">(c.hasOwnProperty(t))</span><span class="s1">continue</span><span class="s0">;</span><span class="s1">let </span><span class="s0">i=!</span><span class="s3">1</span><span class="s0">;i=El(e)&amp;&amp;El(n)?!jl(e,n):e!==n,i?</span><span class="s1">null</span><span class="s0">!=e?E(t):u.add(t):</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==e&amp;&amp;u.has(t)?E(t):p.protectedKeys[t]=!</span><span class="s3">0</span><span class="s0">}p.prevProp=m,p.prevResolvedValues=P,p.isActive&amp;&amp;(c={...c,...P}),i&amp;&amp;t.blockInitialAnimation&amp;&amp;(x=!</span><span class="s3">1</span><span class="s0">);</span><span class="s1">const </span><span class="s0">A=y&amp;&amp;v;x&amp;&amp;(!A||w)&amp;&amp;l.push(...T.map(e=&gt;{</span><span class="s1">const </span><span class="s0">n={type:d};</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;i&amp;&amp;!A&amp;&amp;t.manuallyAnimateOnMount&amp;&amp;t.parent){</span><span class="s1">const</span><span class="s0">{parent:i}=t,s=Sl(i,e);</span><span class="s1">if</span><span class="s0">(i.enteringChildren&amp;&amp;s){</span><span class="s1">const</span><span class="s0">{delayChildren:e}=s.transition||{};n.delay=kl(i.enteringChildren,t,e)}}</span><span class="s1">return</span><span class="s0">{animation:e,options:n}}))}</span><span class="s1">if</span><span class="s0">(u.size){</span><span class="s1">const </span><span class="s0">e={};</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;boolean&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">r.initial){</span><span class="s1">const </span><span class="s0">n=Sl(t,Array.isArray(r.initial)?r.initial[</span><span class="s3">0</span><span class="s0">]:r.initial);n&amp;&amp;n.transition&amp;&amp;(e.transition=n.transition)}u.forEach(n=&gt;{</span><span class="s1">const </span><span class="s0">i=t.getBaseTarget(n),s=t.getValue(n);s&amp;&amp;(s.liveStyle=!</span><span class="s3">0</span><span class="s0">),e[n]=i??</span><span class="s1">null</span><span class="s0">}),l.push({animation:e})}</span><span class="s1">let </span><span class="s0">d=Boolean(l.length);</span><span class="s1">return</span><span class="s0">!i||!</span><span class="s3">1</span><span class="s0">!==r.initial&amp;&amp;r.initial!==r.animate||t.manuallyAnimateOnMount||(d=!</span><span class="s3">1</span><span class="s0">),i=!</span><span class="s3">1</span><span class="s0">,d?e(l):Promise.resolve()}</span><span class="s1">return</span><span class="s0">{animateChanges:o,setActive:</span><span class="s1">function</span><span class="s0">(e,i){</span><span class="s1">if</span><span class="s0">(n[e].isActive===i)</span><span class="s1">return </span><span class="s0">Promise.resolve();t.variantChildren?.forEach(t=&gt;t.animationState?.setActive(e,i)),n[e].isActive=i;</span><span class="s1">const </span><span class="s0">s=o(e);</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">t </span><span class="s1">in </span><span class="s0">n)n[t].protectedKeys={};</span><span class="s1">return </span><span class="s0">s},setAnimateFunction:</span><span class="s1">function</span><span class="s0">(n){e=n(t)},getState:()=&gt;n,reset:()=&gt;{n=zl(),i=!</span><span class="s3">0</span><span class="s0">}}}</span><span class="s1">function </span><span class="s0">Nl(t,e){</span><span class="s1">return</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e?e!==t:!!Array.isArray(e)&amp;&amp;!jl(e,t)}</span><span class="s1">function </span><span class="s0">$l(t=!</span><span class="s3">1</span><span class="s0">){</span><span class="s1">return</span><span class="s0">{isActive:t,protectedKeys:{},needsAnimating:{},prevResolvedValues:{}}}</span><span class="s1">function </span><span class="s0">zl(){</span><span class="s1">return</span><span class="s0">{animate:$l(!</span><span class="s3">0</span><span class="s0">),whileInView:$l(),whileHover:$l(),whileTap:$l(),whileDrag:$l(),whileFocus:$l(),exit:$l()}}</span><span class="s1">class </span><span class="s0">Xl{constructor(t){</span><span class="s1">this</span><span class="s0">.isMounted=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.node=t}update(){}}</span><span class="s1">let </span><span class="s0">Hl=</span><span class="s3">0</span><span class="s0">;</span><span class="s1">const </span><span class="s0">Yl={animation:{Feature:</span><span class="s1">class extends </span><span class="s0">Xl{constructor(t){</span><span class="s1">super</span><span class="s0">(t),t.animationState||(t.animationState=Ul(t))}updateAnimationControlsSubscription(){</span><span class="s1">const</span><span class="s0">{animate:t}=</span><span class="s1">this</span><span class="s0">.node.getProps();ma(t)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.unmountControls=t.subscribe(</span><span class="s1">this</span><span class="s0">.node))}mount(){</span><span class="s1">this</span><span class="s0">.updateAnimationControlsSubscription()}update(){</span><span class="s1">const</span><span class="s0">{animate:t}=</span><span class="s1">this</span><span class="s0">.node.getProps(),{animate:e}=</span><span class="s1">this</span><span class="s0">.node.prevProps||{};t!==e&amp;&amp;</span><span class="s1">this</span><span class="s0">.updateAnimationControlsSubscription()}unmount(){</span><span class="s1">this</span><span class="s0">.node.animationState.reset(),</span><span class="s1">this</span><span class="s0">.unmountControls?.()}}},exit:{Feature:</span><span class="s1">class extends </span><span class="s0">Xl{constructor(){</span><span class="s1">super</span><span class="s0">(...arguments),</span><span class="s1">this</span><span class="s0">.id=Hl++}update(){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.node.presenceContext)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">const</span><span class="s0">{isPresent:t,onExitComplete:e}=</span><span class="s1">this</span><span class="s0">.node.presenceContext,{isPresent:n}=</span><span class="s1">this</span><span class="s0">.node.prevPresenceContext||{};</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.node.animationState||t===n)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">const </span><span class="s0">i=</span><span class="s1">this</span><span class="s0">.node.animationState.setActive(</span><span class="s2">&quot;exit&quot;</span><span class="s0">,!t);e&amp;&amp;!t&amp;&amp;i.then(()=&gt;{e(</span><span class="s1">this</span><span class="s0">.id)})}mount(){</span><span class="s1">const</span><span class="s0">{register:t,onExitComplete:e}=</span><span class="s1">this</span><span class="s0">.node.presenceContext||{};e&amp;&amp;e(</span><span class="s1">this</span><span class="s0">.id),t&amp;&amp;(</span><span class="s1">this</span><span class="s0">.unmount=t(</span><span class="s1">this</span><span class="s0">.id))}unmount(){}}}};</span><span class="s1">function </span><span class="s0">Kl(t){</span><span class="s1">return</span><span class="s0">{point:{x:t.pageX,y:t.pageY}}}</span><span class="s1">const </span><span class="s0">Gl=t=&gt;e=&gt;Ji(e)&amp;&amp;t(e,Kl(e));</span><span class="s1">function </span><span class="s0">_l(t,e,n,i){</span><span class="s1">return </span><span class="s0">Qr(t,e,Gl(n),i)}</span><span class="s1">const </span><span class="s0">Zl=({current:t})=&gt;t?t.ownerDocument.defaultView:</span><span class="s1">null</span><span class="s0">,ql=(t,e)=&gt;Math.abs(t-e);</span><span class="s1">function </span><span class="s0">Jl(t,e){</span><span class="s1">const </span><span class="s0">n=ql(t.x,e.x),i=ql(t.y,e.y);</span><span class="s1">return </span><span class="s0">Math.sqrt(n**</span><span class="s3">2</span><span class="s0">+i**</span><span class="s3">2</span><span class="s0">)}</span><span class="s1">class </span><span class="s0">Ql{constructor(t,e,{transformPagePoint:n,contextWindow:i=window,dragSnapToOrigin:s=!</span><span class="s3">1</span><span class="s0">,distanceThreshold:o=</span><span class="s3">3</span><span class="s0">}={}){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.startEvent=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.lastMoveEvent=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.lastMoveEventInfo=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.handlers={},</span><span class="s1">this</span><span class="s0">.contextWindow=window,</span><span class="s1">this</span><span class="s0">.updatePoint=()=&gt;{</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.lastMoveEvent||!</span><span class="s1">this</span><span class="s0">.lastMoveEventInfo)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">const </span><span class="s0">t=nu(</span><span class="s1">this</span><span class="s0">.lastMoveEventInfo,</span><span class="s1">this</span><span class="s0">.history),e=</span><span class="s1">null</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.startEvent,n=Jl(t.offset,{x:</span><span class="s3">0</span><span class="s0">,y:</span><span class="s3">0</span><span class="s0">})&gt;=</span><span class="s1">this</span><span class="s0">.distanceThreshold;</span><span class="s1">if</span><span class="s0">(!e&amp;&amp;!n)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">const</span><span class="s0">{point:i}=t,{timestamp:s}=ut;</span><span class="s1">this</span><span class="s0">.history.push({...i,timestamp:s});</span><span class="s1">const</span><span class="s0">{onStart:o,onMove:r}=</span><span class="s1">this</span><span class="s0">.handlers;e||(o&amp;&amp;o(</span><span class="s1">this</span><span class="s0">.lastMoveEvent,t),</span><span class="s1">this</span><span class="s0">.startEvent=</span><span class="s1">this</span><span class="s0">.lastMoveEvent),r&amp;&amp;r(</span><span class="s1">this</span><span class="s0">.lastMoveEvent,t)},</span><span class="s1">this</span><span class="s0">.handlePointerMove=(t,e)=&gt;{</span><span class="s1">this</span><span class="s0">.lastMoveEvent=t,</span><span class="s1">this</span><span class="s0">.lastMoveEventInfo=tu(e,</span><span class="s1">this</span><span class="s0">.transformPagePoint),at.update(</span><span class="s1">this</span><span class="s0">.updatePoint,!</span><span class="s3">0</span><span class="s0">)},</span><span class="s1">this</span><span class="s0">.handlePointerUp=(t,e)=&gt;{</span><span class="s1">this</span><span class="s0">.end();</span><span class="s1">const</span><span class="s0">{onEnd:n,onSessionEnd:i,resumeAnimation:s}=</span><span class="s1">this</span><span class="s0">.handlers;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.dragSnapToOrigin&amp;&amp;s&amp;&amp;s(),!</span><span class="s1">this</span><span class="s0">.lastMoveEvent||!</span><span class="s1">this</span><span class="s0">.lastMoveEventInfo)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">const </span><span class="s0">o=nu(</span><span class="s2">&quot;pointercancel&quot;</span><span class="s0">===t.type?</span><span class="s1">this</span><span class="s0">.lastMoveEventInfo:tu(e,</span><span class="s1">this</span><span class="s0">.transformPagePoint),</span><span class="s1">this</span><span class="s0">.history);</span><span class="s1">this</span><span class="s0">.startEvent&amp;&amp;n&amp;&amp;n(t,o),i&amp;&amp;i(t,o)},!Ji(t))</span><span class="s1">return</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.dragSnapToOrigin=s,</span><span class="s1">this</span><span class="s0">.handlers=e,</span><span class="s1">this</span><span class="s0">.transformPagePoint=n,</span><span class="s1">this</span><span class="s0">.distanceThreshold=o,</span><span class="s1">this</span><span class="s0">.contextWindow=i||window;</span><span class="s1">const </span><span class="s0">r=tu(Kl(t),</span><span class="s1">this</span><span class="s0">.transformPagePoint),{point:a}=r,{timestamp:l}=ut;</span><span class="s1">this</span><span class="s0">.history=[{...a,timestamp:l}];</span><span class="s1">const</span><span class="s0">{onSessionStart:u}=e;u&amp;&amp;u(t,nu(r,</span><span class="s1">this</span><span class="s0">.history)),</span><span class="s1">this</span><span class="s0">.removeListeners=R(_l(</span><span class="s1">this</span><span class="s0">.contextWindow,</span><span class="s2">&quot;pointermove&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.handlePointerMove),_l(</span><span class="s1">this</span><span class="s0">.contextWindow,</span><span class="s2">&quot;pointerup&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.handlePointerUp),_l(</span><span class="s1">this</span><span class="s0">.contextWindow,</span><span class="s2">&quot;pointercancel&quot;</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.handlePointerUp))}updateHandlers(t){</span><span class="s1">this</span><span class="s0">.handlers=t}end(){</span><span class="s1">this</span><span class="s0">.removeListeners&amp;&amp;</span><span class="s1">this</span><span class="s0">.removeListeners(),lt(</span><span class="s1">this</span><span class="s0">.updatePoint)}}</span><span class="s1">function </span><span class="s0">tu(t,e){</span><span class="s1">return </span><span class="s0">e?{point:e(t.point)}:t}</span><span class="s1">function </span><span class="s0">eu(t,e){</span><span class="s1">return</span><span class="s0">{x:t.x-e.x,y:t.y-e.y}}</span><span class="s1">function </span><span class="s0">nu({point:t},e){</span><span class="s1">return</span><span class="s0">{point:t,delta:eu(t,su(e)),offset:eu(t,iu(e)),velocity:ou(e,</span><span class="s3">.1</span><span class="s0">)}}</span><span class="s1">function </span><span class="s0">iu(t){</span><span class="s1">return </span><span class="s0">t[</span><span class="s3">0</span><span class="s0">]}</span><span class="s1">function </span><span class="s0">su(t){</span><span class="s1">return </span><span class="s0">t[t.length-</span><span class="s3">1</span><span class="s0">]}</span><span class="s1">function </span><span class="s0">ou(t,e){</span><span class="s1">if</span><span class="s0">(t.length&lt;</span><span class="s3">2</span><span class="s0">)</span><span class="s1">return</span><span class="s0">{x:</span><span class="s3">0</span><span class="s0">,y:</span><span class="s3">0</span><span class="s0">};</span><span class="s1">let </span><span class="s0">n=t.length-</span><span class="s3">1</span><span class="s0">,i=</span><span class="s1">null</span><span class="s0">;</span><span class="s1">const </span><span class="s0">s=su(t);</span><span class="s1">for</span><span class="s0">(;n&gt;=</span><span class="s3">0</span><span class="s0">&amp;&amp;(i=t[n],!(s.timestamp-i.timestamp&gt;O(e)));)n--;</span><span class="s1">if</span><span class="s0">(!i)</span><span class="s1">return</span><span class="s0">{x:</span><span class="s3">0</span><span class="s0">,y:</span><span class="s3">0</span><span class="s0">};</span><span class="s1">const </span><span class="s0">o=j(s.timestamp-i.timestamp);</span><span class="s1">if</span><span class="s0">(</span><span class="s3">0</span><span class="s0">===o)</span><span class="s1">return</span><span class="s0">{x:</span><span class="s3">0</span><span class="s0">,y:</span><span class="s3">0</span><span class="s0">};</span><span class="s1">const </span><span class="s0">r={x:(s.x-i.x)/o,y:(s.y-i.y)/o};</span><span class="s1">return </span><span class="s0">r.x===</span><span class="s3">1</span><span class="s0">/</span><span class="s3">0</span><span class="s0">&amp;&amp;(r.x=</span><span class="s3">0</span><span class="s0">),r.y===</span><span class="s3">1</span><span class="s0">/</span><span class="s3">0</span><span class="s0">&amp;&amp;(r.y=</span><span class="s3">0</span><span class="s0">),r}</span><span class="s1">function </span><span class="s0">ru(t,e,n){</span><span class="s1">return</span><span class="s0">{min:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==e?t.min+e:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,max:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==n?t.max+n-(t.max-t.min):</span><span class="s1">void </span><span class="s3">0</span><span class="s0">}}</span><span class="s1">function </span><span class="s0">au(t,e){</span><span class="s1">let </span><span class="s0">n=e.min-t.min,i=e.max-t.max;</span><span class="s1">return </span><span class="s0">e.max-e.min&lt;t.max-t.min&amp;&amp;([n,i]=[i,n]),{min:n,max:i}}</span><span class="s1">const </span><span class="s0">lu=</span><span class="s3">.35</span><span class="s0">;</span><span class="s1">function </span><span class="s0">uu(t,e,n){</span><span class="s1">return</span><span class="s0">{min:cu(t,e),max:cu(t,n)}}</span><span class="s1">function </span><span class="s0">cu(t,e){</span><span class="s1">return</span><span class="s2">&quot;number&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t?t:t[e]||</span><span class="s3">0</span><span class="s0">}</span><span class="s1">const </span><span class="s0">hu=</span><span class="s1">new </span><span class="s0">WeakMap;</span><span class="s1">class </span><span class="s0">du{constructor(t){</span><span class="s1">this</span><span class="s0">.openDragLock=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.isDragging=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.currentDirection=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.originPoint={x:</span><span class="s3">0</span><span class="s0">,y:</span><span class="s3">0</span><span class="s0">},</span><span class="s1">this</span><span class="s0">.constraints=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.hasMutatedConstraints=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.elastic={x:{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">},y:{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">}},</span><span class="s1">this</span><span class="s0">.latestPointerEvent=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.latestPanInfo=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.visualElement=t}start(t,{snapToCursor:e=!</span><span class="s3">1</span><span class="s0">,distanceThreshold:n}={}){</span><span class="s1">const</span><span class="s0">{presenceContext:i}=</span><span class="s1">this</span><span class="s0">.visualElement;</span><span class="s1">if</span><span class="s0">(i&amp;&amp;!</span><span class="s3">1</span><span class="s0">===i.isPresent)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">const</span><span class="s0">{dragSnapToOrigin:s}=</span><span class="s1">this</span><span class="s0">.getProps();</span><span class="s1">this</span><span class="s0">.panSession=</span><span class="s1">new </span><span class="s0">Ql(t,{onSessionStart:t=&gt;{</span><span class="s1">const</span><span class="s0">{dragSnapToOrigin:n}=</span><span class="s1">this</span><span class="s0">.getProps();n?</span><span class="s1">this</span><span class="s0">.pauseAnimation():</span><span class="s1">this</span><span class="s0">.stopAnimation(),e&amp;&amp;</span><span class="s1">this</span><span class="s0">.snapToCursor(Kl(t).point)},onStart:(t,e)=&gt;{</span><span class="s1">const</span><span class="s0">{drag:n,dragPropagation:i,onDragStart:s}=</span><span class="s1">this</span><span class="s0">.getProps();</span><span class="s1">if</span><span class="s0">(n&amp;&amp;!i&amp;&amp;(</span><span class="s1">this</span><span class="s0">.openDragLock&amp;&amp;</span><span class="s1">this</span><span class="s0">.openDragLock(),</span><span class="s1">this</span><span class="s0">.openDragLock=Ki(n),!</span><span class="s1">this</span><span class="s0">.openDragLock))</span><span class="s1">return</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.latestPointerEvent=t,</span><span class="s1">this</span><span class="s0">.latestPanInfo=e,</span><span class="s1">this</span><span class="s0">.isDragging=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.currentDirection=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.resolveConstraints(),</span><span class="s1">this</span><span class="s0">.visualElement.projection&amp;&amp;(</span><span class="s1">this</span><span class="s0">.visualElement.projection.isAnimationBlocked=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.visualElement.projection.target=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">),br(t=&gt;{</span><span class="s1">let </span><span class="s0">e=</span><span class="s1">this</span><span class="s0">.getAxisMotionValue(t).get()||</span><span class="s3">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(Lt.test(e)){</span><span class="s1">const</span><span class="s0">{projection:n}=</span><span class="s1">this</span><span class="s0">.visualElement;</span><span class="s1">if</span><span class="s0">(n&amp;&amp;n.layout){</span><span class="s1">const </span><span class="s0">i=n.layout.layoutBox[t];</span><span class="s1">if</span><span class="s0">(i){e=po(i)*(parseFloat(e)/</span><span class="s3">100</span><span class="s0">)}}}</span><span class="s1">this</span><span class="s0">.originPoint[t]=e}),s&amp;&amp;at.postRender(()=&gt;s(t,e)),Vl(</span><span class="s1">this</span><span class="s0">.visualElement,</span><span class="s2">&quot;transform&quot;</span><span class="s0">);</span><span class="s1">const</span><span class="s0">{animationState:o}=</span><span class="s1">this</span><span class="s0">.visualElement;o&amp;&amp;o.setActive(</span><span class="s2">&quot;whileDrag&quot;</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">)},onMove:(t,e)=&gt;{</span><span class="s1">this</span><span class="s0">.latestPointerEvent=t,</span><span class="s1">this</span><span class="s0">.latestPanInfo=e;</span><span class="s1">const</span><span class="s0">{dragPropagation:n,dragDirectionLock:i,onDirectionLock:s,onDrag:o}=</span><span class="s1">this</span><span class="s0">.getProps();</span><span class="s1">if</span><span class="s0">(!n&amp;&amp;!</span><span class="s1">this</span><span class="s0">.openDragLock)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">const</span><span class="s0">{offset:r}=e;</span><span class="s1">if</span><span class="s0">(i&amp;&amp;</span><span class="s1">null</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.currentDirection)</span><span class="s1">return this</span><span class="s0">.currentDirection=</span><span class="s1">function</span><span class="s0">(t,e=</span><span class="s3">10</span><span class="s0">){</span><span class="s1">let </span><span class="s0">n=</span><span class="s1">null</span><span class="s0">;Math.abs(t.y)&gt;e?n=</span><span class="s2">&quot;y&quot;</span><span class="s0">:Math.abs(t.x)&gt;e&amp;&amp;(n=</span><span class="s2">&quot;x&quot;</span><span class="s0">);</span><span class="s1">return </span><span class="s0">n}(r),</span><span class="s1">void</span><span class="s0">(</span><span class="s1">null</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.currentDirection&amp;&amp;s&amp;&amp;s(</span><span class="s1">this</span><span class="s0">.currentDirection));</span><span class="s1">this</span><span class="s0">.updateAxis(</span><span class="s2">&quot;x&quot;</span><span class="s0">,e.point,r),</span><span class="s1">this</span><span class="s0">.updateAxis(</span><span class="s2">&quot;y&quot;</span><span class="s0">,e.point,r),</span><span class="s1">this</span><span class="s0">.visualElement.render(),o&amp;&amp;o(t,e)},onSessionEnd:(t,e)=&gt;{</span><span class="s1">this</span><span class="s0">.latestPointerEvent=t,</span><span class="s1">this</span><span class="s0">.latestPanInfo=e,</span><span class="s1">this</span><span class="s0">.stop(t,e),</span><span class="s1">this</span><span class="s0">.latestPointerEvent=</span><span class="s1">null</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.latestPanInfo=</span><span class="s1">null</span><span class="s0">},resumeAnimation:()=&gt;br(t=&gt;</span><span class="s2">&quot;paused&quot;</span><span class="s0">===</span><span class="s1">this</span><span class="s0">.getAnimationState(t)&amp;&amp;</span><span class="s1">this</span><span class="s0">.getAxisMotionValue(t).animation?.play())},{transformPagePoint:</span><span class="s1">this</span><span class="s0">.visualElement.getTransformPagePoint(),dragSnapToOrigin:s,distanceThreshold:n,contextWindow:Zl(</span><span class="s1">this</span><span class="s0">.visualElement)})}stop(t,e){</span><span class="s1">const </span><span class="s0">n=t||</span><span class="s1">this</span><span class="s0">.latestPointerEvent,i=e||</span><span class="s1">this</span><span class="s0">.latestPanInfo,s=</span><span class="s1">this</span><span class="s0">.isDragging;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.cancel(),!s||!i||!n)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">const</span><span class="s0">{velocity:o}=i;</span><span class="s1">this</span><span class="s0">.startAnimation(o);</span><span class="s1">const</span><span class="s0">{onDragEnd:r}=</span><span class="s1">this</span><span class="s0">.getProps();r&amp;&amp;at.postRender(()=&gt;r(n,i))}cancel(){</span><span class="s1">this</span><span class="s0">.isDragging=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">const</span><span class="s0">{projection:t,animationState:e}=</span><span class="s1">this</span><span class="s0">.visualElement;t&amp;&amp;(t.isAnimationBlocked=!</span><span class="s3">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.panSession&amp;&amp;</span><span class="s1">this</span><span class="s0">.panSession.end(),</span><span class="s1">this</span><span class="s0">.panSession=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">;</span><span class="s1">const</span><span class="s0">{dragPropagation:n}=</span><span class="s1">this</span><span class="s0">.getProps();!n&amp;&amp;</span><span class="s1">this</span><span class="s0">.openDragLock&amp;&amp;(</span><span class="s1">this</span><span class="s0">.openDragLock(),</span><span class="s1">this</span><span class="s0">.openDragLock=</span><span class="s1">null</span><span class="s0">),e&amp;&amp;e.setActive(</span><span class="s2">&quot;whileDrag&quot;</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">)}updateAxis(t,e,n){</span><span class="s1">const</span><span class="s0">{drag:i}=</span><span class="s1">this</span><span class="s0">.getProps();</span><span class="s1">if</span><span class="s0">(!n||!pu(t,i,</span><span class="s1">this</span><span class="s0">.currentDirection))</span><span class="s1">return</span><span class="s0">;</span><span class="s1">const </span><span class="s0">s=</span><span class="s1">this</span><span class="s0">.getAxisMotionValue(t);</span><span class="s1">let </span><span class="s0">o=</span><span class="s1">this</span><span class="s0">.originPoint[t]+n[t];</span><span class="s1">this</span><span class="s0">.constraints&amp;&amp;</span><span class="s1">this</span><span class="s0">.constraints[t]&amp;&amp;(o=</span><span class="s1">function</span><span class="s0">(t,{min:e,max:n},i){</span><span class="s1">return void </span><span class="s3">0</span><span class="s0">!==e&amp;&amp;t&lt;e?t=i?Jt(e,t,i.min):Math.max(t,e):</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==n&amp;&amp;t&gt;n&amp;&amp;(t=i?Jt(n,t,i.max):Math.min(t,n)),t}(o,</span><span class="s1">this</span><span class="s0">.constraints[t],</span><span class="s1">this</span><span class="s0">.elastic[t])),s.set(o)}resolveConstraints(){</span><span class="s1">const</span><span class="s0">{dragConstraints:t,dragElastic:e}=</span><span class="s1">this</span><span class="s0">.getProps(),n=</span><span class="s1">this</span><span class="s0">.visualElement.projection&amp;&amp;!</span><span class="s1">this</span><span class="s0">.visualElement.projection.layout?</span><span class="s1">this</span><span class="s0">.visualElement.projection.measure(!</span><span class="s3">1</span><span class="s0">):</span><span class="s1">this</span><span class="s0">.visualElement.projection?.layout,i=</span><span class="s1">this</span><span class="s0">.constraints;t&amp;&amp;gl(t)?</span><span class="s1">this</span><span class="s0">.constraints||(</span><span class="s1">this</span><span class="s0">.constraints=</span><span class="s1">this</span><span class="s0">.resolveRefConstraints()):</span><span class="s1">this</span><span class="s0">.constraints=!(!t||!n)&amp;&amp;</span><span class="s1">function</span><span class="s0">(t,{top:e,left:n,bottom:i,right:s}){</span><span class="s1">return</span><span class="s0">{x:ru(t.x,n,s),y:ru(t.y,e,i)}}(n.layoutBox,t),</span><span class="s1">this</span><span class="s0">.elastic=</span><span class="s1">function</span><span class="s0">(t=lu){</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">===t?t=</span><span class="s3">0</span><span class="s0">:!</span><span class="s3">0</span><span class="s0">===t&amp;&amp;(t=lu),{x:uu(t,</span><span class="s2">&quot;left&quot;</span><span class="s0">,</span><span class="s2">&quot;right&quot;</span><span class="s0">),y:uu(t,</span><span class="s2">&quot;top&quot;</span><span class="s0">,</span><span class="s2">&quot;bottom&quot;</span><span class="s0">)}}(e),i!==</span><span class="s1">this</span><span class="s0">.constraints&amp;&amp;n&amp;&amp;</span><span class="s1">this</span><span class="s0">.constraints&amp;&amp;!</span><span class="s1">this</span><span class="s0">.hasMutatedConstraints&amp;&amp;br(t=&gt;{!</span><span class="s3">1</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.constraints&amp;&amp;</span><span class="s1">this</span><span class="s0">.getAxisMotionValue(t)&amp;&amp;(</span><span class="s1">this</span><span class="s0">.constraints[t]=</span><span class="s1">function</span><span class="s0">(t,e){</span><span class="s1">const </span><span class="s0">n={};</span><span class="s1">return void </span><span class="s3">0</span><span class="s0">!==e.min&amp;&amp;(n.min=e.min-t.min),</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==e.max&amp;&amp;(n.max=e.max-t.min),n}(n.layoutBox[t],</span><span class="s1">this</span><span class="s0">.constraints[t]))})}resolveRefConstraints(){</span><span class="s1">const</span><span class="s0">{dragConstraints:t,onMeasureDragConstraints:e}=</span><span class="s1">this</span><span class="s0">.getProps();</span><span class="s1">if</span><span class="s0">(!t||!gl(t))</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">const </span><span class="s0">n=t.current,{projection:i}=</span><span class="s1">this</span><span class="s0">.visualElement;</span><span class="s1">if</span><span class="s0">(!i||!i.layout)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">const </span><span class="s0">s=</span><span class="s1">function</span><span class="s0">(t,e,n){</span><span class="s1">const </span><span class="s0">i=aa(t,n),{scroll:s}=e;</span><span class="s1">return </span><span class="s0">s&amp;&amp;(sr(i.x,s.offset.x),sr(i.y,s.offset.y)),i}(n,i.root,</span><span class="s1">this</span><span class="s0">.visualElement.getTransformPagePoint());</span><span class="s1">let </span><span class="s0">o=</span><span class="s1">function</span><span class="s0">(t,e){</span><span class="s1">return</span><span class="s0">{x:au(t.x,e.x),y:au(t.y,e.y)}}(i.layout.layoutBox,s);</span><span class="s1">if</span><span class="s0">(e){</span><span class="s1">const </span><span class="s0">t=e(</span><span class="s1">function</span><span class="s0">({x:t,y:e}){</span><span class="s1">return</span><span class="s0">{top:e.min,right:t.max,bottom:e.max,left:t.min}}(o));</span><span class="s1">this</span><span class="s0">.hasMutatedConstraints=!!t,t&amp;&amp;(o=ra(t))}</span><span class="s1">return </span><span class="s0">o}startAnimation(t){</span><span class="s1">const</span><span class="s0">{drag:e,dragMomentum:n,dragElastic:i,dragTransition:s,dragSnapToOrigin:o,onDragTransitionEnd:r}=</span><span class="s1">this</span><span class="s0">.getProps(),a=</span><span class="s1">this</span><span class="s0">.constraints||{},l=br(r=&gt;{</span><span class="s1">if</span><span class="s0">(!pu(r,e,</span><span class="s1">this</span><span class="s0">.currentDirection))</span><span class="s1">return</span><span class="s0">;</span><span class="s1">let </span><span class="s0">l=a&amp;&amp;a[r]||{};o&amp;&amp;(l={min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">});</span><span class="s1">const </span><span class="s0">u=i?</span><span class="s3">200</span><span class="s0">:</span><span class="s3">1e6</span><span class="s0">,c=i?</span><span class="s3">40</span><span class="s0">:</span><span class="s3">1e7</span><span class="s0">,h={type:</span><span class="s2">&quot;inertia&quot;</span><span class="s0">,velocity:n?t[r]:</span><span class="s3">0</span><span class="s0">,bounceStiffness:u,bounceDamping:c,timeConstant:</span><span class="s3">750</span><span class="s0">,restDelta:</span><span class="s3">1</span><span class="s0">,restSpeed:</span><span class="s3">10</span><span class="s0">,...s,...l};</span><span class="s1">return this</span><span class="s0">.startAxisValueAnimation(r,h)});</span><span class="s1">return </span><span class="s0">Promise.all(l).then(r)}startAxisValueAnimation(t,e){</span><span class="s1">const </span><span class="s0">n=</span><span class="s1">this</span><span class="s0">.getAxisMotionValue(t);</span><span class="s1">return </span><span class="s0">Vl(</span><span class="s1">this</span><span class="s0">.visualElement,t),n.start(Ao(t,n,</span><span class="s3">0</span><span class="s0">,e,</span><span class="s1">this</span><span class="s0">.visualElement,!</span><span class="s3">1</span><span class="s0">))}stopAnimation(){br(t=&gt;</span><span class="s1">this</span><span class="s0">.getAxisMotionValue(t).stop())}pauseAnimation(){br(t=&gt;</span><span class="s1">this</span><span class="s0">.getAxisMotionValue(t).animation?.pause())}getAnimationState(t){</span><span class="s1">return this</span><span class="s0">.getAxisMotionValue(t).animation?.state}getAxisMotionValue(t){</span><span class="s1">const </span><span class="s0">e=</span><span class="s2">`_drag</span><span class="s0">${t.toUpperCase()}</span><span class="s2">`</span><span class="s0">,n=</span><span class="s1">this</span><span class="s0">.visualElement.getProps(),i=n[e];</span><span class="s1">return </span><span class="s0">i||</span><span class="s1">this</span><span class="s0">.visualElement.getValue(t,(n.initial?n.initial[t]:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">)||</span><span class="s3">0</span><span class="s0">)}snapToCursor(t){br(e=&gt;{</span><span class="s1">const</span><span class="s0">{drag:n}=</span><span class="s1">this</span><span class="s0">.getProps();</span><span class="s1">if</span><span class="s0">(!pu(e,n,</span><span class="s1">this</span><span class="s0">.currentDirection))</span><span class="s1">return</span><span class="s0">;</span><span class="s1">const</span><span class="s0">{projection:i}=</span><span class="s1">this</span><span class="s0">.visualElement,s=</span><span class="s1">this</span><span class="s0">.getAxisMotionValue(e);</span><span class="s1">if</span><span class="s0">(i&amp;&amp;i.layout){</span><span class="s1">const</span><span class="s0">{min:n,max:o}=i.layout.layoutBox[e];s.set(t[e]-Jt(n,o,</span><span class="s3">.5</span><span class="s0">))}})}scalePositionWithinConstraints(){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.visualElement.current)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">const</span><span class="s0">{drag:t,dragConstraints:e}=</span><span class="s1">this</span><span class="s0">.getProps(),{projection:n}=</span><span class="s1">this</span><span class="s0">.visualElement;</span><span class="s1">if</span><span class="s0">(!gl(e)||!n||!</span><span class="s1">this</span><span class="s0">.constraints)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">this</span><span class="s0">.stopAnimation();</span><span class="s1">const </span><span class="s0">i={x:</span><span class="s3">0</span><span class="s0">,y:</span><span class="s3">0</span><span class="s0">};br(t=&gt;{</span><span class="s1">const </span><span class="s0">e=</span><span class="s1">this</span><span class="s0">.getAxisMotionValue(t);</span><span class="s1">if</span><span class="s0">(e&amp;&amp;!</span><span class="s3">1</span><span class="s0">!==</span><span class="s1">this</span><span class="s0">.constraints){</span><span class="s1">const </span><span class="s0">n=e.get();i[t]=</span><span class="s1">function</span><span class="s0">(t,e){</span><span class="s1">let </span><span class="s0">n=</span><span class="s3">.5</span><span class="s0">;</span><span class="s1">const </span><span class="s0">i=po(t),s=po(e);</span><span class="s1">return </span><span class="s0">s&gt;i?n=k(e.min,e.max-i,t.min):i&gt;s&amp;&amp;(n=k(t.min,t.max-s,e.min)),P(</span><span class="s3">0</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,n)}({min:n,max:n},</span><span class="s1">this</span><span class="s0">.constraints[t])}});</span><span class="s1">const</span><span class="s0">{transformTemplate:s}=</span><span class="s1">this</span><span class="s0">.visualElement.getProps();</span><span class="s1">this</span><span class="s0">.visualElement.current.style.transform=s?s({},</span><span class="s2">&quot;&quot;</span><span class="s0">):</span><span class="s2">&quot;none&quot;</span><span class="s0">,n.root&amp;&amp;n.root.updateScroll(),n.updateLayout(),</span><span class="s1">this</span><span class="s0">.resolveConstraints(),br(e=&gt;{</span><span class="s1">if</span><span class="s0">(!pu(e,t,</span><span class="s1">null</span><span class="s0">))</span><span class="s1">return</span><span class="s0">;</span><span class="s1">const </span><span class="s0">n=</span><span class="s1">this</span><span class="s0">.getAxisMotionValue(e),{min:s,max:o}=</span><span class="s1">this</span><span class="s0">.constraints[e];n.set(Jt(s,o,i[e]))})}addListeners(){</span><span class="s1">if</span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.visualElement.current)</span><span class="s1">return</span><span class="s0">;hu.set(</span><span class="s1">this</span><span class="s0">.visualElement,</span><span class="s1">this</span><span class="s0">);</span><span class="s1">const </span><span class="s0">t=_l(</span><span class="s1">this</span><span class="s0">.visualElement.current,</span><span class="s2">&quot;pointerdown&quot;</span><span class="s0">,t=&gt;{</span><span class="s1">const</span><span class="s0">{drag:e,dragListener:n=!</span><span class="s3">0</span><span class="s0">}=</span><span class="s1">this</span><span class="s0">.getProps();e&amp;&amp;n&amp;&amp;</span><span class="s1">this</span><span class="s0">.start(t)}),e=()=&gt;{</span><span class="s1">const</span><span class="s0">{dragConstraints:t}=</span><span class="s1">this</span><span class="s0">.getProps();gl(t)&amp;&amp;t.current&amp;&amp;(</span><span class="s1">this</span><span class="s0">.constraints=</span><span class="s1">this</span><span class="s0">.resolveRefConstraints())},{projection:n}=</span><span class="s1">this</span><span class="s0">.visualElement,i=n.addEventListener(</span><span class="s2">&quot;measure&quot;</span><span class="s0">,e);n&amp;&amp;!n.layout&amp;&amp;(n.root&amp;&amp;n.root.updateScroll(),n.updateLayout()),at.read(e);</span><span class="s1">const </span><span class="s0">s=Qr(window,</span><span class="s2">&quot;resize&quot;</span><span class="s0">,()=&gt;</span><span class="s1">this</span><span class="s0">.scalePositionWithinConstraints()),o=n.addEventListener(</span><span class="s2">&quot;didUpdate&quot;</span><span class="s0">,({delta:t,hasLayoutChanged:e})=&gt;{</span><span class="s1">this</span><span class="s0">.isDragging&amp;&amp;e&amp;&amp;(br(e=&gt;{</span><span class="s1">const </span><span class="s0">n=</span><span class="s1">this</span><span class="s0">.getAxisMotionValue(e);n&amp;&amp;(</span><span class="s1">this</span><span class="s0">.originPoint[e]+=t[e].translate,n.set(n.get()+t[e].translate))}),</span><span class="s1">this</span><span class="s0">.visualElement.render())});</span><span class="s1">return</span><span class="s0">()=&gt;{s(),t(),i(),o&amp;&amp;o()}}getProps(){</span><span class="s1">const </span><span class="s0">t=</span><span class="s1">this</span><span class="s0">.visualElement.getProps(),{drag:e=!</span><span class="s3">1</span><span class="s0">,dragDirectionLock:n=!</span><span class="s3">1</span><span class="s0">,dragPropagation:i=!</span><span class="s3">1</span><span class="s0">,dragConstraints:s=!</span><span class="s3">1</span><span class="s0">,dragElastic:o=lu,dragMomentum:r=!</span><span class="s3">0</span><span class="s0">}=t;</span><span class="s1">return</span><span class="s0">{...t,drag:e,dragDirectionLock:n,dragPropagation:i,dragConstraints:s,dragElastic:o,dragMomentum:r}}}</span><span class="s1">function </span><span class="s0">pu(t,e,n){</span><span class="s1">return</span><span class="s0">!(!</span><span class="s3">0</span><span class="s0">!==e&amp;&amp;e!==t||</span><span class="s1">null</span><span class="s0">!==n&amp;&amp;n!==t)}</span><span class="s1">const </span><span class="s0">mu=t=&gt;(e,n)=&gt;{t&amp;&amp;at.postRender(()=&gt;t(e,n))};</span><span class="s1">let </span><span class="s0">fu=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">class </span><span class="s0">gu </span><span class="s1">extends </span><span class="s0">e.Component{componentDidMount(){</span><span class="s1">const</span><span class="s0">{visualElement:t,layoutGroup:e,switchLayoutGroup:n,layoutId:i}=</span><span class="s1">this</span><span class="s0">.props,{projection:s}=t;Pr(vu),s&amp;&amp;(e.group&amp;&amp;e.group.add(s),n&amp;&amp;n.register&amp;&amp;i&amp;&amp;n.register(s),fu&amp;&amp;s.root.didUpdate(),s.addEventListener(</span><span class="s2">&quot;animationComplete&quot;</span><span class="s0">,()=&gt;{</span><span class="s1">this</span><span class="s0">.safeToRemove()}),s.setOptions({...s.options,onExitComplete:()=&gt;</span><span class="s1">this</span><span class="s0">.safeToRemove()})),Sr.hasEverUpdated=!</span><span class="s3">0</span><span class="s0">}getSnapshotBeforeUpdate(t){</span><span class="s1">const</span><span class="s0">{layoutDependency:e,visualElement:n,drag:i,isPresent:s}=</span><span class="s1">this</span><span class="s0">.props,{projection:o}=n;</span><span class="s1">return </span><span class="s0">o?(o.isPresent=s,fu=!</span><span class="s3">0</span><span class="s0">,i||t.layoutDependency!==e||</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===e||t.isPresent!==s?o.willUpdate():</span><span class="s1">this</span><span class="s0">.safeToRemove(),t.isPresent!==s&amp;&amp;(s?o.promote():o.relegate()||at.postRender(()=&gt;{</span><span class="s1">const </span><span class="s0">t=o.getStack();t&amp;&amp;t.members.length||</span><span class="s1">this</span><span class="s0">.safeToRemove()})),</span><span class="s1">null</span><span class="s0">):</span><span class="s1">null</span><span class="s0">}componentDidUpdate(){</span><span class="s1">const</span><span class="s0">{projection:t}=</span><span class="s1">this</span><span class="s0">.props.visualElement;t&amp;&amp;(t.root.didUpdate(),zi.postRender(()=&gt;{!t.currentAnimation&amp;&amp;t.isLead()&amp;&amp;</span><span class="s1">this</span><span class="s0">.safeToRemove()}))}componentWillUnmount(){</span><span class="s1">const</span><span class="s0">{visualElement:t,layoutGroup:e,switchLayoutGroup:n}=</span><span class="s1">this</span><span class="s0">.props,{projection:i}=t;fu=!</span><span class="s3">0</span><span class="s0">,i&amp;&amp;(i.scheduleCheckAfterUnmount(),e&amp;&amp;e.group&amp;&amp;e.group.remove(i),n&amp;&amp;n.deregister&amp;&amp;n.deregister(i))}safeToRemove(){</span><span class="s1">const</span><span class="s0">{safeToRemove:t}=</span><span class="s1">this</span><span class="s0">.props;t&amp;&amp;t()}render(){</span><span class="s1">return null</span><span class="s0">}}</span><span class="s1">function </span><span class="s0">yu(t){</span><span class="s1">const</span><span class="s0">[n,i]=lo(),s=e.useContext(m);</span><span class="s1">return </span><span class="s0">d(gu,{...t,layoutGroup:s,switchLayoutGroup:e.useContext(vl),isPresent:n,safeToRemove:i})}</span><span class="s1">const </span><span class="s0">vu={borderRadius:{...sa,applyTo:[</span><span class="s2">&quot;borderTopLeftRadius&quot;</span><span class="s0">,</span><span class="s2">&quot;borderTopRightRadius&quot;</span><span class="s0">,</span><span class="s2">&quot;borderBottomLeftRadius&quot;</span><span class="s0">,</span><span class="s2">&quot;borderBottomRightRadius&quot;</span><span class="s0">]},borderTopLeftRadius:sa,borderTopRightRadius:sa,borderBottomLeftRadius:sa,borderBottomRightRadius:sa,boxShadow:oa},xu={pan:{Feature:</span><span class="s1">class extends </span><span class="s0">Xl{constructor(){</span><span class="s1">super</span><span class="s0">(...arguments),</span><span class="s1">this</span><span class="s0">.removePointerDownListener=V}onPointerDown(t){</span><span class="s1">this</span><span class="s0">.session=</span><span class="s1">new </span><span class="s0">Ql(t,</span><span class="s1">this</span><span class="s0">.createPanHandlers(),{transformPagePoint:</span><span class="s1">this</span><span class="s0">.node.getTransformPagePoint(),contextWindow:Zl(</span><span class="s1">this</span><span class="s0">.node)})}createPanHandlers(){</span><span class="s1">const</span><span class="s0">{onPanSessionStart:t,onPanStart:e,onPan:n,onPanEnd:i}=</span><span class="s1">this</span><span class="s0">.node.getProps();</span><span class="s1">return</span><span class="s0">{onSessionStart:mu(t),onStart:mu(e),onMove:n,onEnd:(t,e)=&gt;{</span><span class="s1">delete this</span><span class="s0">.session,i&amp;&amp;at.postRender(()=&gt;i(t,e))}}}mount(){</span><span class="s1">this</span><span class="s0">.removePointerDownListener=_l(</span><span class="s1">this</span><span class="s0">.node.current,</span><span class="s2">&quot;pointerdown&quot;</span><span class="s0">,t=&gt;</span><span class="s1">this</span><span class="s0">.onPointerDown(t))}update(){</span><span class="s1">this</span><span class="s0">.session&amp;&amp;</span><span class="s1">this</span><span class="s0">.session.updateHandlers(</span><span class="s1">this</span><span class="s0">.createPanHandlers())}unmount(){</span><span class="s1">this</span><span class="s0">.removePointerDownListener(),</span><span class="s1">this</span><span class="s0">.session&amp;&amp;</span><span class="s1">this</span><span class="s0">.session.end()}}},drag:{Feature:</span><span class="s1">class extends </span><span class="s0">Xl{constructor(t){</span><span class="s1">super</span><span class="s0">(t),</span><span class="s1">this</span><span class="s0">.removeGroupControls=V,</span><span class="s1">this</span><span class="s0">.removeListeners=V,</span><span class="s1">this</span><span class="s0">.controls=</span><span class="s1">new </span><span class="s0">du(t)}mount(){</span><span class="s1">const</span><span class="s0">{dragControls:t}=</span><span class="s1">this</span><span class="s0">.node.getProps();t&amp;&amp;(</span><span class="s1">this</span><span class="s0">.removeGroupControls=t.subscribe(</span><span class="s1">this</span><span class="s0">.controls)),</span><span class="s1">this</span><span class="s0">.removeListeners=</span><span class="s1">this</span><span class="s0">.controls.addListeners()||V}unmount(){</span><span class="s1">this</span><span class="s0">.removeGroupControls(),</span><span class="s1">this</span><span class="s0">.removeListeners()}},ProjectionNode:na,MeasureLayout:yu}};</span><span class="s1">function </span><span class="s0">wu(t,e,n){</span><span class="s1">const</span><span class="s0">{props:i}=t;t.animationState&amp;&amp;i.whileHover&amp;&amp;t.animationState.setActive(</span><span class="s2">&quot;whileHover&quot;</span><span class="s0">,</span><span class="s2">&quot;Start&quot;</span><span class="s0">===n);</span><span class="s1">const </span><span class="s0">s=i[</span><span class="s2">&quot;onHover&quot;</span><span class="s0">+n];s&amp;&amp;at.postRender(()=&gt;s(e,Kl(e)))}</span><span class="s1">function </span><span class="s0">Tu(t,e,n){</span><span class="s1">const</span><span class="s0">{props:i}=t;</span><span class="s1">if</span><span class="s0">(t.current </span><span class="s1">instanceof </span><span class="s0">HTMLButtonElement&amp;&amp;t.current.disabled)</span><span class="s1">return</span><span class="s0">;t.animationState&amp;&amp;i.whileTap&amp;&amp;t.animationState.setActive(</span><span class="s2">&quot;whileTap&quot;</span><span class="s0">,</span><span class="s2">&quot;Start&quot;</span><span class="s0">===n);</span><span class="s1">const </span><span class="s0">s=i[</span><span class="s2">&quot;onTap&quot;</span><span class="s0">+(</span><span class="s2">&quot;End&quot;</span><span class="s0">===n?</span><span class="s2">&quot;&quot;</span><span class="s0">:n)];s&amp;&amp;at.postRender(()=&gt;s(e,Kl(e)))}</span><span class="s1">const </span><span class="s0">Pu=</span><span class="s1">new </span><span class="s0">WeakMap,bu=</span><span class="s1">new </span><span class="s0">WeakMap,Su=t=&gt;{</span><span class="s1">const </span><span class="s0">e=Pu.get(t.target);e&amp;&amp;e(t)},Eu=t=&gt;{t.forEach(Su)};</span><span class="s1">function </span><span class="s0">Au(t,e,n){</span><span class="s1">const </span><span class="s0">i=</span><span class="s1">function</span><span class="s0">({root:t,...e}){</span><span class="s1">const </span><span class="s0">n=t||document;bu.has(n)||bu.set(n,{});</span><span class="s1">const </span><span class="s0">i=bu.get(n),s=JSON.stringify(e);</span><span class="s1">return </span><span class="s0">i[s]||(i[s]=</span><span class="s1">new </span><span class="s0">IntersectionObserver(Eu,{root:t,...e})),i[s]}(e);</span><span class="s1">return </span><span class="s0">Pu.set(t,n),i.observe(t),()=&gt;{Pu.delete(t),i.unobserve(t)}}</span><span class="s1">const </span><span class="s0">Mu={some:</span><span class="s3">0</span><span class="s0">,all:</span><span class="s3">1</span><span class="s0">};</span><span class="s1">const </span><span class="s0">Cu={inView:{Feature:</span><span class="s1">class extends </span><span class="s0">Xl{constructor(){</span><span class="s1">super</span><span class="s0">(...arguments),</span><span class="s1">this</span><span class="s0">.hasEnteredView=!</span><span class="s3">1</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.isInView=!</span><span class="s3">1</span><span class="s0">}startObserver(){</span><span class="s1">this</span><span class="s0">.unmount();</span><span class="s1">const</span><span class="s0">{viewport:t={}}=</span><span class="s1">this</span><span class="s0">.node.getProps(),{root:e,margin:n,amount:i=</span><span class="s2">&quot;some&quot;</span><span class="s0">,once:s}=t,o={root:e?e.current:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,rootMargin:n,threshold:</span><span class="s2">&quot;number&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">i?i:Mu[i]};</span><span class="s1">return </span><span class="s0">Au(</span><span class="s1">this</span><span class="s0">.node.current,o,t=&gt;{</span><span class="s1">const</span><span class="s0">{isIntersecting:e}=t;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isInView===e)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s1">this</span><span class="s0">.isInView=e,s&amp;&amp;!e&amp;&amp;</span><span class="s1">this</span><span class="s0">.hasEnteredView)</span><span class="s1">return</span><span class="s0">;e&amp;&amp;(</span><span class="s1">this</span><span class="s0">.hasEnteredView=!</span><span class="s3">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.node.animationState&amp;&amp;</span><span class="s1">this</span><span class="s0">.node.animationState.setActive(</span><span class="s2">&quot;whileInView&quot;</span><span class="s0">,e);</span><span class="s1">const</span><span class="s0">{onViewportEnter:n,onViewportLeave:i}=</span><span class="s1">this</span><span class="s0">.node.getProps(),o=e?n:i;o&amp;&amp;o(t)})}mount(){</span><span class="s1">this</span><span class="s0">.startObserver()}update(){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;undefined&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">IntersectionObserver)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">const</span><span class="s0">{props:t,prevProps:e}=</span><span class="s1">this</span><span class="s0">.node;[</span><span class="s2">&quot;amount&quot;</span><span class="s0">,</span><span class="s2">&quot;margin&quot;</span><span class="s0">,</span><span class="s2">&quot;root&quot;</span><span class="s0">].some(</span><span class="s1">function</span><span class="s0">({viewport:t={}},{viewport:e={}}={}){</span><span class="s1">return </span><span class="s0">n=&gt;t[n]!==e[n]}(t,e))&amp;&amp;</span><span class="s1">this</span><span class="s0">.startObserver()}unmount(){}}},tap:{Feature:</span><span class="s1">class extends </span><span class="s0">Xl{mount(){</span><span class="s1">const</span><span class="s0">{current:t}=</span><span class="s1">this</span><span class="s0">.node;t&amp;&amp;(</span><span class="s1">this</span><span class="s0">.unmount=ss(t,(t,e)=&gt;(Tu(</span><span class="s1">this</span><span class="s0">.node,e,</span><span class="s2">&quot;Start&quot;</span><span class="s0">),(t,{success:e})=&gt;Tu(</span><span class="s1">this</span><span class="s0">.node,t,e?</span><span class="s2">&quot;End&quot;</span><span class="s0">:</span><span class="s2">&quot;Cancel&quot;</span><span class="s0">)),{useGlobalTarget:</span><span class="s1">this</span><span class="s0">.node.props.globalTapTarget}))}unmount(){}}},focus:{Feature:</span><span class="s1">class extends </span><span class="s0">Xl{constructor(){</span><span class="s1">super</span><span class="s0">(...arguments),</span><span class="s1">this</span><span class="s0">.isActive=!</span><span class="s3">1</span><span class="s0">}onFocus(){</span><span class="s1">let </span><span class="s0">t=!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">try</span><span class="s0">{t=</span><span class="s1">this</span><span class="s0">.node.current.matches(</span><span class="s2">&quot;:focus-visible&quot;</span><span class="s0">)}</span><span class="s1">catch</span><span class="s0">(e){t=!</span><span class="s3">0</span><span class="s0">}t&amp;&amp;</span><span class="s1">this</span><span class="s0">.node.animationState&amp;&amp;(</span><span class="s1">this</span><span class="s0">.node.animationState.setActive(</span><span class="s2">&quot;whileFocus&quot;</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.isActive=!</span><span class="s3">0</span><span class="s0">)}onBlur(){</span><span class="s1">this</span><span class="s0">.isActive&amp;&amp;</span><span class="s1">this</span><span class="s0">.node.animationState&amp;&amp;(</span><span class="s1">this</span><span class="s0">.node.animationState.setActive(</span><span class="s2">&quot;whileFocus&quot;</span><span class="s0">,!</span><span class="s3">1</span><span class="s0">),</span><span class="s1">this</span><span class="s0">.isActive=!</span><span class="s3">1</span><span class="s0">)}mount(){</span><span class="s1">this</span><span class="s0">.unmount=R(Qr(</span><span class="s1">this</span><span class="s0">.node.current,</span><span class="s2">&quot;focus&quot;</span><span class="s0">,()=&gt;</span><span class="s1">this</span><span class="s0">.onFocus()),Qr(</span><span class="s1">this</span><span class="s0">.node.current,</span><span class="s2">&quot;blur&quot;</span><span class="s0">,()=&gt;</span><span class="s1">this</span><span class="s0">.onBlur()))}unmount(){}}},hover:{Feature:</span><span class="s1">class extends </span><span class="s0">Xl{mount(){</span><span class="s1">const</span><span class="s0">{current:t}=</span><span class="s1">this</span><span class="s0">.node;t&amp;&amp;(</span><span class="s1">this</span><span class="s0">.unmount=Zi(t,(t,e)=&gt;(wu(</span><span class="s1">this</span><span class="s0">.node,e,</span><span class="s2">&quot;Start&quot;</span><span class="s0">),t=&gt;wu(</span><span class="s1">this</span><span class="s0">.node,t,</span><span class="s2">&quot;End&quot;</span><span class="s0">))))}unmount(){}}}},Vu={layout:{ProjectionNode:na,MeasureLayout:yu}},Du=bl({...Yl,...Cu,...xu,...Vu},tl);</span><span class="s1">function </span><span class="s0">Ru({children:t,as:n=</span><span class="s2">&quot;ul&quot;</span><span class="s0">,axis:i=</span><span class="s2">&quot;y&quot;</span><span class="s0">,onReorder:s,values:o,...r},a){</span><span class="s1">const </span><span class="s0">l=f(()=&gt;Du[n]),u=[],c=e.useRef(!</span><span class="s3">1</span><span class="s0">),h={axis:i,registerItem:(t,e)=&gt;{</span><span class="s1">const </span><span class="s0">n=u.findIndex(e=&gt;t===e.value);-</span><span class="s3">1</span><span class="s0">!==n?u[n].layout=e[i]:u.push({value:t,layout:e[i]}),u.sort(Ou)},updateOrder:(t,e,n)=&gt;{</span><span class="s1">if</span><span class="s0">(c.current)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">const </span><span class="s0">i=</span><span class="s1">function</span><span class="s0">(t,e,n,i){</span><span class="s1">if</span><span class="s0">(!i)</span><span class="s1">return </span><span class="s0">t;</span><span class="s1">const </span><span class="s0">s=t.findIndex(t=&gt;t.value===e);</span><span class="s1">if</span><span class="s0">(-</span><span class="s3">1</span><span class="s0">===s)</span><span class="s1">return </span><span class="s0">t;</span><span class="s1">const </span><span class="s0">o=i&gt;</span><span class="s3">0</span><span class="s0">?</span><span class="s3">1</span><span class="s0">:-</span><span class="s3">1</span><span class="s0">,r=t[s+o];</span><span class="s1">if</span><span class="s0">(!r)</span><span class="s1">return </span><span class="s0">t;</span><span class="s1">const </span><span class="s0">a=t[s],l=r.layout,u=Jt(l.min,l.max,</span><span class="s3">.5</span><span class="s0">);</span><span class="s1">return </span><span class="s3">1</span><span class="s0">===o&amp;&amp;a.layout.max+n&gt;u||-</span><span class="s3">1</span><span class="s0">===o&amp;&amp;a.layout.min+n&lt;u?T(t,s,s+o):t}(u,t,e,n);u!==i&amp;&amp;(c.current=!</span><span class="s3">0</span><span class="s0">,s(i.map(Lu).filter(t=&gt;-</span><span class="s3">1</span><span class="s0">!==o.indexOf(t))))}};</span><span class="s1">return </span><span class="s0">e.useEffect(()=&gt;{c.current=!</span><span class="s3">1</span><span class="s0">}),d(l,{...r,ref:a,ignoreStrict:!</span><span class="s3">0</span><span class="s0">,children:d(Xa.Provider,{value:h,children:t})})}</span><span class="s1">const </span><span class="s0">ku=e.forwardRef(Ru);</span><span class="s1">function </span><span class="s0">Lu(t){</span><span class="s1">return </span><span class="s0">t.value}</span><span class="s1">function </span><span class="s0">Ou(t,e){</span><span class="s1">return </span><span class="s0">t.layout.min-e.layout.min}</span><span class="s1">function </span><span class="s0">ju(t){</span><span class="s1">const </span><span class="s0">n=f(()=&gt;Bi(t)),{isStatic:i}=e.useContext(eo);</span><span class="s1">if</span><span class="s0">(i){</span><span class="s1">const</span><span class="s0">[,i]=e.useState(t);e.useEffect(()=&gt;n.on(</span><span class="s2">&quot;change&quot;</span><span class="s0">,i),[])}</span><span class="s1">return </span><span class="s0">n}</span><span class="s1">function </span><span class="s0">Bu(t,e){</span><span class="s1">const </span><span class="s0">n=ju(e()),i=()=&gt;n.set(e());</span><span class="s1">return </span><span class="s0">i(),y(()=&gt;{</span><span class="s1">const </span><span class="s0">e=()=&gt;at.preRender(i,!</span><span class="s3">1</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">),n=t.map(t=&gt;t.on(</span><span class="s2">&quot;change&quot;</span><span class="s0">,e));</span><span class="s1">return</span><span class="s0">()=&gt;{n.forEach(t=&gt;t()),lt(i)}}),n}</span><span class="s1">function </span><span class="s0">Iu(t,e,n,i){</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t)</span><span class="s1">return function</span><span class="s0">(t){Oi.current=[],t();</span><span class="s1">const </span><span class="s0">e=Bu(Oi.current,t);</span><span class="s1">return </span><span class="s0">Oi.current=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,e}(t);</span><span class="s1">const </span><span class="s0">s=</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e?e:Cs(e,n,i);</span><span class="s1">return </span><span class="s0">Array.isArray(t)?Fu(t,s):Fu([t],([t])=&gt;s(t))}</span><span class="s1">function </span><span class="s0">Fu(t,e){</span><span class="s1">const </span><span class="s0">n=f(()=&gt;[]);</span><span class="s1">return </span><span class="s0">Bu(t,()=&gt;{n.length=</span><span class="s3">0</span><span class="s0">;</span><span class="s1">const </span><span class="s0">i=t.length;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">e=</span><span class="s3">0</span><span class="s0">;e&lt;i;e++)n[e]=t[e].get();</span><span class="s1">return </span><span class="s0">e(n)})}</span><span class="s1">function </span><span class="s0">Wu(t,e=</span><span class="s3">0</span><span class="s0">){</span><span class="s1">return </span><span class="s0">Ds(t)?t:ju(e)}</span><span class="s1">function </span><span class="s0">Uu({children:t,style:n={},value:i,as:s=</span><span class="s2">&quot;li&quot;</span><span class="s0">,onDrag:o,layout:r=!</span><span class="s3">0</span><span class="s0">,...a},l){</span><span class="s1">const </span><span class="s0">u=f(()=&gt;Du[s]),c=e.useContext(Xa),h={x:Wu(n.x),y:Wu(n.y)},p=Iu([h.x,h.y],([t,e])=&gt;t||e?</span><span class="s3">1</span><span class="s0">:</span><span class="s2">&quot;unset&quot;</span><span class="s0">),{axis:m,registerItem:g,updateOrder:y}=c;</span><span class="s1">return </span><span class="s0">d(u,{drag:m,...a,dragSnapToOrigin:!</span><span class="s3">0</span><span class="s0">,style:{...n,x:h.x,y:h.y,zIndex:p},layout:r,onDrag:(t,e)=&gt;{</span><span class="s1">const</span><span class="s0">{velocity:n}=e;n[m]&amp;&amp;y(i,h[m].get(),n[m]),o&amp;&amp;o(t,e)},onLayoutMeasure:t=&gt;g(i,t),ref:l,ignoreStrict:!</span><span class="s3">0</span><span class="s0">,children:t})}</span><span class="s1">const </span><span class="s0">Nu=e.forwardRef(Uu);</span><span class="s1">var </span><span class="s0">$u=Object.freeze({__proto__:</span><span class="s1">null</span><span class="s0">,Group:ku,Item:Nu});</span><span class="s1">function </span><span class="s0">zu(t){</span><span class="s1">return</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t&amp;&amp;!Array.isArray(t)}</span><span class="s1">function </span><span class="s0">Xu(t,e,n,i){</span><span class="s1">return</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t&amp;&amp;zu(e)?Ei(t,n,i):t </span><span class="s1">instanceof </span><span class="s0">NodeList?Array.from(t):Array.isArray(t)?t:[t]}</span><span class="s1">function </span><span class="s0">Hu(t,e,n){</span><span class="s1">return </span><span class="s0">t*(e+</span><span class="s3">1</span><span class="s0">)}</span><span class="s1">function </span><span class="s0">Yu(t,e,n,i){</span><span class="s1">return</span><span class="s2">&quot;number&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e?e:e.startsWith(</span><span class="s2">&quot;-&quot;</span><span class="s0">)||e.startsWith(</span><span class="s2">&quot;+&quot;</span><span class="s0">)?Math.max(</span><span class="s3">0</span><span class="s0">,t+parseFloat(e)):</span><span class="s2">&quot;&lt;&quot;</span><span class="s0">===e?n:e.startsWith(</span><span class="s2">&quot;&lt;&quot;</span><span class="s0">)?Math.max(</span><span class="s3">0</span><span class="s0">,n+parseFloat(e.slice(</span><span class="s3">1</span><span class="s0">))):i.get(e)??t}</span><span class="s1">function </span><span class="s0">Ku(t,e,n,i,s,o){!</span><span class="s1">function</span><span class="s0">(t,e,n){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">i=</span><span class="s3">0</span><span class="s0">;i&lt;t.length;i++){</span><span class="s1">const </span><span class="s0">s=t[i];s.at&gt;e&amp;&amp;s.at&lt;n&amp;&amp;(w(t,s),i--)}}(t,s,o);</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">r=</span><span class="s3">0</span><span class="s0">;r&lt;e.length;r++)t.push({value:e[r],at:Jt(s,o,i[r]),easing:tt(n,r)})}</span><span class="s1">function </span><span class="s0">Gu(t,e){</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">n=</span><span class="s3">0</span><span class="s0">;n&lt;t.length;n++)t[n]=t[n]/(e+</span><span class="s3">1</span><span class="s0">)}</span><span class="s1">function </span><span class="s0">_u(t,e){</span><span class="s1">return </span><span class="s0">t.at===e.at?</span><span class="s1">null</span><span class="s0">===t.value?</span><span class="s3">1</span><span class="s0">:</span><span class="s1">null</span><span class="s0">===e.value?-</span><span class="s3">1</span><span class="s0">:</span><span class="s3">0</span><span class="s0">:t.at-e.at}</span><span class="s1">function </span><span class="s0">Zu(t,e){</span><span class="s1">return</span><span class="s0">!e.has(t)&amp;&amp;e.set(t,{}),e.get(t)}</span><span class="s1">function </span><span class="s0">qu(t,e){</span><span class="s1">return </span><span class="s0">e[t]||(e[t]=[]),e[t]}</span><span class="s1">function </span><span class="s0">Ju(t){</span><span class="s1">return </span><span class="s0">Array.isArray(t)?t:[t]}</span><span class="s1">function </span><span class="s0">Qu(t,e){</span><span class="s1">return </span><span class="s0">t&amp;&amp;t[e]?{...t,...t[e]}:{...t}}</span><span class="s1">const </span><span class="s0">tc=t=&gt;</span><span class="s2">&quot;number&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t,ec=t=&gt;t.every(tc);</span><span class="s1">class </span><span class="s0">nc </span><span class="s1">extends </span><span class="s0">ba{constructor(){</span><span class="s1">super</span><span class="s0">(...arguments),</span><span class="s1">this</span><span class="s0">.type=</span><span class="s2">&quot;object&quot;</span><span class="s0">}readValueFromInstance(t,e){</span><span class="s1">if</span><span class="s0">(</span><span class="s1">function</span><span class="s0">(t,e){</span><span class="s1">return </span><span class="s0">t </span><span class="s1">in </span><span class="s0">e}(e,t)){</span><span class="s1">const </span><span class="s0">n=t[e];</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">n||</span><span class="s2">&quot;number&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">n)</span><span class="s1">return </span><span class="s0">n}}getBaseTargetFromProps(){}removeValueFromRenderState(t,e){</span><span class="s1">delete </span><span class="s0">e.output[t]}measureInstanceViewportBox(){</span><span class="s1">return</span><span class="s0">{x:{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">},y:{min:</span><span class="s3">0</span><span class="s0">,max:</span><span class="s3">0</span><span class="s0">}}}build(t,e){Object.assign(t.output,e)}renderInstance(t,{output:e}){Object.assign(t,e)}sortInstanceNodePosition(){</span><span class="s1">return </span><span class="s3">0</span><span class="s0">}}</span><span class="s1">function </span><span class="s0">ic(t){</span><span class="s1">const </span><span class="s0">e={presenceContext:</span><span class="s1">null</span><span class="s0">,props:{},visualState:{renderState:{transform:{},transformOrigin:{},style:{},vars:{},attrs:{}},latestValues:{}}},n=rs(t)&amp;&amp;!As(t)?</span><span class="s1">new </span><span class="s0">qa(e):</span><span class="s1">new </span><span class="s0">ka(e);n.mount(t),pa.set(t,n)}</span><span class="s1">function </span><span class="s0">sc(t){</span><span class="s1">const </span><span class="s0">e=</span><span class="s1">new </span><span class="s0">nc({presenceContext:</span><span class="s1">null</span><span class="s0">,props:{},visualState:{renderState:{output:{}},latestValues:{}}});e.mount(t),pa.set(t,e)}</span><span class="s1">function </span><span class="s0">oc(t,e,n,i){</span><span class="s1">const </span><span class="s0">s=[];</span><span class="s1">if</span><span class="s0">(</span><span class="s1">function</span><span class="s0">(t,e){</span><span class="s1">return </span><span class="s0">Ds(t)||</span><span class="s2">&quot;number&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t||</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t&amp;&amp;!zu(e)}(t,e))s.push(Mo(t,zu(e)&amp;&amp;e.default||e,n&amp;&amp;n.default||n));</span><span class="s1">else</span><span class="s0">{</span><span class="s1">const </span><span class="s0">o=Xu(t,e,i),r=o.length;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">t=</span><span class="s3">0</span><span class="s0">;t&lt;r;t++){</span><span class="s1">const </span><span class="s0">i=o[t],a=i </span><span class="s1">instanceof </span><span class="s0">Element?ic:sc;pa.has(i)||a(i);</span><span class="s1">const </span><span class="s0">l=pa.get(i),u={...n};</span><span class="s2">&quot;delay&quot;</span><span class="s1">in </span><span class="s0">u&amp;&amp;</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">u.delay&amp;&amp;(u.delay=u.delay(t,r)),s.push(...Rl(l,{...e,transition:u},{}))}}</span><span class="s1">return </span><span class="s0">s}</span><span class="s1">function </span><span class="s0">rc(t,e,n){</span><span class="s1">const </span><span class="s0">i=[],s=</span><span class="s1">function</span><span class="s0">(t,{defaultTransition:e={},...n}={},i,s){</span><span class="s1">const </span><span class="s0">o=e.duration||</span><span class="s3">.3</span><span class="s0">,r=</span><span class="s1">new </span><span class="s0">Map,a=</span><span class="s1">new </span><span class="s0">Map,l={},u=</span><span class="s1">new </span><span class="s0">Map;</span><span class="s1">let </span><span class="s0">c=</span><span class="s3">0</span><span class="s0">,h=</span><span class="s3">0</span><span class="s0">,d=</span><span class="s3">0</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">n=</span><span class="s3">0</span><span class="s0">;n&lt;t.length;n++){</span><span class="s1">const </span><span class="s0">r=t[n];</span><span class="s1">if</span><span class="s0">(</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">r){u.set(r,h);</span><span class="s1">continue</span><span class="s0">}</span><span class="s1">if</span><span class="s0">(!Array.isArray(r)){u.set(r.name,Yu(h,r.at,c,u));</span><span class="s1">continue</span><span class="s0">}</span><span class="s1">let</span><span class="s0">[p,m,f={}]=r;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==f.at&amp;&amp;(h=Yu(h,f.at,c,u));</span><span class="s1">let </span><span class="s0">g=</span><span class="s3">0</span><span class="s0">;</span><span class="s1">const </span><span class="s0">y=(t,n,i,r=</span><span class="s3">0</span><span class="s0">,a=</span><span class="s3">0</span><span class="s0">)=&gt;{</span><span class="s1">const </span><span class="s0">l=Ju(t),{delay:u=</span><span class="s3">0</span><span class="s0">,times:c=Ne(l),type:p=</span><span class="s2">&quot;keyframes&quot;</span><span class="s0">,repeat:m,repeatType:f,repeatDelay:y=</span><span class="s3">0</span><span class="s0">,...v}=n;</span><span class="s1">let</span><span class="s0">{ease:x=e.ease||</span><span class="s2">&quot;easeOut&quot;</span><span class="s0">,duration:w}=n;</span><span class="s1">const </span><span class="s0">T=</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">u?u(r,a):u,P=l.length,b=jn(p)?p:s?.[p||</span><span class="s2">&quot;keyframes&quot;</span><span class="s0">];</span><span class="s1">if</span><span class="s0">(P&lt;=</span><span class="s3">2</span><span class="s0">&amp;&amp;b){</span><span class="s1">let </span><span class="s0">t=</span><span class="s3">100</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(</span><span class="s3">2</span><span class="s0">===P&amp;&amp;ec(l)){</span><span class="s1">const </span><span class="s0">e=l[</span><span class="s3">1</span><span class="s0">]-l[</span><span class="s3">0</span><span class="s0">];t=Math.abs(e)}</span><span class="s1">const </span><span class="s0">e={...v};</span><span class="s1">void </span><span class="s3">0</span><span class="s0">!==w&amp;&amp;(e.duration=O(w));</span><span class="s1">const </span><span class="s0">n=fe(e,t,b);x=n.ease,w=n.duration}w??(w=o);</span><span class="s1">const </span><span class="s0">S=h+T;</span><span class="s3">1</span><span class="s0">===c.length&amp;&amp;</span><span class="s3">0</span><span class="s0">===c[</span><span class="s3">0</span><span class="s0">]&amp;&amp;(c[</span><span class="s3">1</span><span class="s0">]=</span><span class="s3">1</span><span class="s0">);</span><span class="s1">const </span><span class="s0">E=c.length-l.length;</span><span class="s1">if</span><span class="s0">(E&gt;</span><span class="s3">0</span><span class="s0">&amp;&amp;Ue(c,E),</span><span class="s3">1</span><span class="s0">===l.length&amp;&amp;l.unshift(</span><span class="s1">null</span><span class="s0">),m){w=Hu(w,m);</span><span class="s1">const </span><span class="s0">t=[...l],e=[...c];x=Array.isArray(x)?[...x]:[x];</span><span class="s1">const </span><span class="s0">n=[...x];</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">i=</span><span class="s3">0</span><span class="s0">;i&lt;m;i++){l.push(...t);</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">s=</span><span class="s3">0</span><span class="s0">;s&lt;t.length;s++)c.push(e[s]+(i+</span><span class="s3">1</span><span class="s0">)),x.push(</span><span class="s3">0</span><span class="s0">===s?</span><span class="s2">&quot;linear&quot;</span><span class="s0">:tt(n,s-</span><span class="s3">1</span><span class="s0">))}Gu(c,m)}</span><span class="s1">const </span><span class="s0">A=S+w;Ku(i,l,x,c,S,A),g=Math.max(T+w,g),d=Math.max(A,d)};</span><span class="s1">if</span><span class="s0">(Ds(p))y(m,f,qu(</span><span class="s2">&quot;default&quot;</span><span class="s0">,Zu(p,a)));</span><span class="s1">else</span><span class="s0">{</span><span class="s1">const </span><span class="s0">t=Xu(p,m,i,l),e=t.length;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">n=</span><span class="s3">0</span><span class="s0">;n&lt;e;n++){</span><span class="s1">const </span><span class="s0">i=Zu(t[n],a);</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">t </span><span class="s1">in </span><span class="s0">m)y(m[t],Qu(f,t),qu(t,i),n,e)}}c=h,h+=g}</span><span class="s1">return </span><span class="s0">a.forEach((t,i)=&gt;{</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">s </span><span class="s1">in </span><span class="s0">t){</span><span class="s1">const </span><span class="s0">o=t[s];o.sort(_u);</span><span class="s1">const </span><span class="s0">a=[],l=[],u=[];</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">t=</span><span class="s3">0</span><span class="s0">;t&lt;o.length;t++){</span><span class="s1">const</span><span class="s0">{at:e,value:n,easing:i}=o[t];a.push(n),l.push(k(</span><span class="s3">0</span><span class="s0">,d,e)),u.push(i||</span><span class="s2">&quot;easeOut&quot;</span><span class="s0">)}</span><span class="s3">0</span><span class="s0">!==l[</span><span class="s3">0</span><span class="s0">]&amp;&amp;(l.unshift(</span><span class="s3">0</span><span class="s0">),a.unshift(a[</span><span class="s3">0</span><span class="s0">]),u.unshift(</span><span class="s2">&quot;easeInOut&quot;</span><span class="s0">)),</span><span class="s3">1</span><span class="s0">!==l[l.length-</span><span class="s3">1</span><span class="s0">]&amp;&amp;(l.push(</span><span class="s3">1</span><span class="s0">),a.push(</span><span class="s1">null</span><span class="s0">)),r.has(i)||r.set(i,{keyframes:{},transition:{}});</span><span class="s1">const </span><span class="s0">c=r.get(i);c.keyframes[s]=a,c.transition[s]={...e,duration:d,ease:u,times:l,...n}}}),r}(t,e,n,{spring:Ie});</span><span class="s1">return </span><span class="s0">s.forEach(({keyframes:t,transition:e},n)=&gt;{i.push(...oc(n,t,e))}),i}</span><span class="s1">function </span><span class="s0">ac(t){</span><span class="s1">return function</span><span class="s0">(e,n,i){</span><span class="s1">let </span><span class="s0">s,o=[];</span><span class="s1">if</span><span class="s0">(r=e,Array.isArray(r)&amp;&amp;r.some(Array.isArray))o=rc(e,n,t);</span><span class="s1">else</span><span class="s0">{</span><span class="s1">const</span><span class="s0">{onComplete:r,...a}=i||{};</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">r&amp;&amp;(s=r),o=oc(e,n,a,t)}</span><span class="s1">var </span><span class="s0">r;</span><span class="s1">const </span><span class="s0">a=</span><span class="s1">new </span><span class="s0">_n(o);</span><span class="s1">return </span><span class="s0">s&amp;&amp;a.finished.then(s),t&amp;&amp;(t.animations.push(a),a.finished.then(()=&gt;{w(t.animations,a)})),a}}</span><span class="s1">const </span><span class="s0">lc=ac();</span><span class="s1">const </span><span class="s0">uc=t=&gt;</span><span class="s1">function</span><span class="s0">(e,n,i){</span><span class="s1">return new </span><span class="s0">_n(</span><span class="s1">function</span><span class="s0">(t,e,n,i){</span><span class="s1">const </span><span class="s0">s=Ei(t,i),o=s.length,r=[];</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">t=</span><span class="s3">0</span><span class="s0">;t&lt;o;t++){</span><span class="s1">const </span><span class="s0">i=s[t],a={...n};</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">a.delay&amp;&amp;(a.delay=a.delay(t,o));</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">t </span><span class="s1">in </span><span class="s0">e){</span><span class="s1">let </span><span class="s0">n=e[t];Array.isArray(n)||(n=[n]);</span><span class="s1">const </span><span class="s0">s={...ii(a,t)};s.duration&amp;&amp;(s.duration=O(s.duration)),s.delay&amp;&amp;(s.delay=O(s.delay));</span><span class="s1">const </span><span class="s0">o=Qn(i),l=Jn(t,s.pseudoElement||</span><span class="s2">&quot;&quot;</span><span class="s0">),u=o.get(l);u&amp;&amp;u.stop(),r.push({map:o,key:l,unresolvedKeyframes:n,options:{...s,element:i,name:t,allowFlatten:!a.type&amp;&amp;!a.ease}})}}</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">t=</span><span class="s3">0</span><span class="s0">;t&lt;r.length;t++){</span><span class="s1">const</span><span class="s0">{unresolvedKeyframes:e,options:n}=r[t],{element:i,name:s,pseudoElement:o}=n;o||</span><span class="s1">null</span><span class="s0">!==e[</span><span class="s3">0</span><span class="s0">]||(e[</span><span class="s3">0</span><span class="s0">]=os(i,s)),Je(e),Pi(e,s),!o&amp;&amp;e.length&lt;</span><span class="s3">2</span><span class="s0">&amp;&amp;e.unshift(os(i,s)),n.keyframes=e}</span><span class="s1">const </span><span class="s0">a=[];</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">t=</span><span class="s3">0</span><span class="s0">;t&lt;r.length;t++){</span><span class="s1">const</span><span class="s0">{map:e,key:n,options:i}=r[t],s=</span><span class="s1">new </span><span class="s0">In(i);e.set(n,s),s.finished.finally(()=&gt;e.delete(n)),a.push(s)}</span><span class="s1">return </span><span class="s0">a}(e,n,i,t))},cc=uc(),hc={x:{length:</span><span class="s2">&quot;Width&quot;</span><span class="s0">,position:</span><span class="s2">&quot;Left&quot;</span><span class="s0">},y:{length:</span><span class="s2">&quot;Height&quot;</span><span class="s0">,position:</span><span class="s2">&quot;Top&quot;</span><span class="s0">}};</span><span class="s1">function </span><span class="s0">dc(t,e,n,i){</span><span class="s1">const </span><span class="s0">s=n[e],{length:o,position:r}=hc[e],a=s.current,l=n.time;s.current=t[</span><span class="s2">`scroll</span><span class="s0">${r}</span><span class="s2">`</span><span class="s0">],s.scrollLength=t[</span><span class="s2">`scroll</span><span class="s0">${o}</span><span class="s2">`</span><span class="s0">]-t[</span><span class="s2">`client</span><span class="s0">${o}</span><span class="s2">`</span><span class="s0">],s.offset.length=</span><span class="s3">0</span><span class="s0">,s.offset[</span><span class="s3">0</span><span class="s0">]=</span><span class="s3">0</span><span class="s0">,s.offset[</span><span class="s3">1</span><span class="s0">]=s.scrollLength,s.progress=k(</span><span class="s3">0</span><span class="s0">,s.scrollLength,s.current);</span><span class="s1">const </span><span class="s0">u=i-l;s.velocity=u&gt;</span><span class="s3">50</span><span class="s0">?</span><span class="s3">0</span><span class="s0">:B(s.current-a,u)}</span><span class="s1">const </span><span class="s0">pc={start:</span><span class="s3">0</span><span class="s0">,center:</span><span class="s3">.5</span><span class="s0">,end:</span><span class="s3">1</span><span class="s0">};</span><span class="s1">function </span><span class="s0">mc(t,e,n=</span><span class="s3">0</span><span class="s0">){</span><span class="s1">let </span><span class="s0">i=</span><span class="s3">0</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(t </span><span class="s1">in </span><span class="s0">pc&amp;&amp;(t=pc[t]),</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t){</span><span class="s1">const </span><span class="s0">e=parseFloat(t);t.endsWith(</span><span class="s2">&quot;px&quot;</span><span class="s0">)?i=e:t.endsWith(</span><span class="s2">&quot;%&quot;</span><span class="s0">)?t=e/</span><span class="s3">100</span><span class="s0">:t.endsWith(</span><span class="s2">&quot;vw&quot;</span><span class="s0">)?i=e/</span><span class="s3">100</span><span class="s0">*document.documentElement.clientWidth:t.endsWith(</span><span class="s2">&quot;vh&quot;</span><span class="s0">)?i=e/</span><span class="s3">100</span><span class="s0">*document.documentElement.clientHeight:t=e}</span><span class="s1">return</span><span class="s2">&quot;number&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t&amp;&amp;(i=e*t),n+i}</span><span class="s1">const </span><span class="s0">fc=[</span><span class="s3">0</span><span class="s0">,</span><span class="s3">0</span><span class="s0">];</span><span class="s1">function </span><span class="s0">gc(t,e,n,i){</span><span class="s1">let </span><span class="s0">s=Array.isArray(t)?t:fc,o=</span><span class="s3">0</span><span class="s0">,r=</span><span class="s3">0</span><span class="s0">;</span><span class="s1">return</span><span class="s2">&quot;number&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t?s=[t,t]:</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t&amp;&amp;(s=(t=t.trim()).includes(</span><span class="s2">&quot; &quot;</span><span class="s0">)?t.split(</span><span class="s2">&quot; &quot;</span><span class="s0">):[t,pc[t]?t:</span><span class="s2">&quot;0&quot;</span><span class="s0">]),o=mc(s[</span><span class="s3">0</span><span class="s0">],n,i),r=mc(s[</span><span class="s3">1</span><span class="s0">],e),o-r}</span><span class="s1">const </span><span class="s0">yc={Enter:[[</span><span class="s3">0</span><span class="s0">,</span><span class="s3">1</span><span class="s0">],[</span><span class="s3">1</span><span class="s0">,</span><span class="s3">1</span><span class="s0">]],Exit:[[</span><span class="s3">0</span><span class="s0">,</span><span class="s3">0</span><span class="s0">],[</span><span class="s3">1</span><span class="s0">,</span><span class="s3">0</span><span class="s0">]],Any:[[</span><span class="s3">1</span><span class="s0">,</span><span class="s3">0</span><span class="s0">],[</span><span class="s3">0</span><span class="s0">,</span><span class="s3">1</span><span class="s0">]],All:[[</span><span class="s3">0</span><span class="s0">,</span><span class="s3">0</span><span class="s0">],[</span><span class="s3">1</span><span class="s0">,</span><span class="s3">1</span><span class="s0">]]},vc={x:</span><span class="s3">0</span><span class="s0">,y:</span><span class="s3">0</span><span class="s0">};</span><span class="s1">function </span><span class="s0">xc(t,e,n){</span><span class="s1">const</span><span class="s0">{offset:i=yc.All}=n,{target:s=t,axis:o=</span><span class="s2">&quot;y&quot;</span><span class="s0">}=n,r=</span><span class="s2">&quot;y&quot;</span><span class="s0">===o?</span><span class="s2">&quot;height&quot;</span><span class="s0">:</span><span class="s2">&quot;width&quot;</span><span class="s0">,a=s!==t?</span><span class="s1">function</span><span class="s0">(t,e){</span><span class="s1">const </span><span class="s0">n={x:</span><span class="s3">0</span><span class="s0">,y:</span><span class="s3">0</span><span class="s0">};</span><span class="s1">let </span><span class="s0">i=t;</span><span class="s1">for</span><span class="s0">(;i&amp;&amp;i!==e;)</span><span class="s1">if</span><span class="s0">(Li(i))n.x+=i.offsetLeft,n.y+=i.offsetTop,i=i.offsetParent;</span><span class="s1">else if</span><span class="s0">(</span><span class="s2">&quot;svg&quot;</span><span class="s0">===i.tagName){</span><span class="s1">const </span><span class="s0">t=i.getBoundingClientRect();i=i.parentElement;</span><span class="s1">const </span><span class="s0">e=i.getBoundingClientRect();n.x+=t.left-e.left,n.y+=t.top-e.top}</span><span class="s1">else</span><span class="s0">{</span><span class="s1">if</span><span class="s0">(!(i </span><span class="s1">instanceof </span><span class="s0">SVGGraphicsElement))</span><span class="s1">break</span><span class="s0">;{</span><span class="s1">const</span><span class="s0">{x:t,y:e}=i.getBBox();n.x+=t,n.y+=e;</span><span class="s1">let </span><span class="s0">s=</span><span class="s1">null</span><span class="s0">,o=i.parentNode;</span><span class="s1">for</span><span class="s0">(;!s;)</span><span class="s2">&quot;svg&quot;</span><span class="s0">===o.tagName&amp;&amp;(s=o),o=i.parentNode;i=s}}</span><span class="s1">return </span><span class="s0">n}(s,t):vc,l=s===t?{width:t.scrollWidth,height:t.scrollHeight}:</span><span class="s1">function</span><span class="s0">(t){</span><span class="s1">return</span><span class="s2">&quot;getBBox&quot;</span><span class="s1">in </span><span class="s0">t&amp;&amp;</span><span class="s2">&quot;svg&quot;</span><span class="s0">!==t.tagName?t.getBBox():{width:t.clientWidth,height:t.clientHeight}}(s),u={width:t.clientWidth,height:t.clientHeight};e[o].offset.length=</span><span class="s3">0</span><span class="s0">;</span><span class="s1">let </span><span class="s0">c=!e[o].interpolate;</span><span class="s1">const </span><span class="s0">h=i.length;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">t=</span><span class="s3">0</span><span class="s0">;t&lt;h;t++){</span><span class="s1">const </span><span class="s0">n=gc(i[t],u[r],l[r],a[o]);c||n===e[o].interpolatorOffsets[t]||(c=!</span><span class="s3">0</span><span class="s0">),e[o].offset[t]=n}c&amp;&amp;(e[o].interpolate=We(e[o].offset,Ne(i),{clamp:!</span><span class="s3">1</span><span class="s0">}),e[o].interpolatorOffsets=[...e[o].offset]),e[o].progress=P(</span><span class="s3">0</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,e[o].interpolate(e[o].current))}</span><span class="s1">function </span><span class="s0">wc(t,e,n,i={}){</span><span class="s1">return</span><span class="s0">{measure:e=&gt;{!</span><span class="s1">function</span><span class="s0">(t,e=t,n){</span><span class="s1">if</span><span class="s0">(n.x.targetOffset=</span><span class="s3">0</span><span class="s0">,n.y.targetOffset=</span><span class="s3">0</span><span class="s0">,e!==t){</span><span class="s1">let </span><span class="s0">i=e;</span><span class="s1">for</span><span class="s0">(;i&amp;&amp;i!==t;)n.x.targetOffset+=i.offsetLeft,n.y.targetOffset+=i.offsetTop,i=i.offsetParent}n.x.targetLength=e===t?e.scrollWidth:e.clientWidth,n.y.targetLength=e===t?e.scrollHeight:e.clientHeight,n.x.containerLength=t.clientWidth,n.y.containerLength=t.clientHeight}(t,i.target,n),</span><span class="s1">function</span><span class="s0">(t,e,n){dc(t,</span><span class="s2">&quot;x&quot;</span><span class="s0">,e,n),dc(t,</span><span class="s2">&quot;y&quot;</span><span class="s0">,e,n),e.time=n}(t,n,e),(i.offset||i.target)&amp;&amp;xc(t,n,i)},notify:()=&gt;e(n)}}</span><span class="s1">const </span><span class="s0">Tc=</span><span class="s1">new </span><span class="s0">WeakMap,Pc=</span><span class="s1">new </span><span class="s0">WeakMap,bc=</span><span class="s1">new </span><span class="s0">WeakMap,Sc=t=&gt;t===document.scrollingElement?window:t;</span><span class="s1">function </span><span class="s0">Ec(t,{container:e=document.scrollingElement,...n}={}){</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return </span><span class="s0">V;</span><span class="s1">let </span><span class="s0">i=bc.get(e);i||(i=</span><span class="s1">new </span><span class="s0">Set,bc.set(e,i));</span><span class="s1">const </span><span class="s0">s=wc(e,t,{time:</span><span class="s3">0</span><span class="s0">,x:{current:</span><span class="s3">0</span><span class="s0">,offset:[],progress:</span><span class="s3">0</span><span class="s0">,scrollLength:</span><span class="s3">0</span><span class="s0">,targetOffset:</span><span class="s3">0</span><span class="s0">,targetLength:</span><span class="s3">0</span><span class="s0">,containerLength:</span><span class="s3">0</span><span class="s0">,velocity:</span><span class="s3">0</span><span class="s0">},y:{current:</span><span class="s3">0</span><span class="s0">,offset:[],progress:</span><span class="s3">0</span><span class="s0">,scrollLength:</span><span class="s3">0</span><span class="s0">,targetOffset:</span><span class="s3">0</span><span class="s0">,targetLength:</span><span class="s3">0</span><span class="s0">,containerLength:</span><span class="s3">0</span><span class="s0">,velocity:</span><span class="s3">0</span><span class="s0">}},n);</span><span class="s1">if</span><span class="s0">(i.add(s),!Tc.has(e)){</span><span class="s1">const </span><span class="s0">t=()=&gt;{</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">t of i)t.measure(ut.timestamp);at.preUpdate(n)},n=()=&gt;{</span><span class="s1">for</span><span class="s0">(</span><span class="s1">const </span><span class="s0">t of i)t.notify()},s=()=&gt;at.read(t);Tc.set(e,s);</span><span class="s1">const </span><span class="s0">o=Sc(e);window.addEventListener(</span><span class="s2">&quot;resize&quot;</span><span class="s0">,s,{passive:!</span><span class="s3">0</span><span class="s0">}),e!==document.documentElement&amp;&amp;Pc.set(e,vs(e,s)),o.addEventListener(</span><span class="s2">&quot;scroll&quot;</span><span class="s0">,s,{passive:!</span><span class="s3">0</span><span class="s0">}),s()}</span><span class="s1">const </span><span class="s0">o=Tc.get(e);</span><span class="s1">return </span><span class="s0">at.read(o,!</span><span class="s3">1</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">),()=&gt;{lt(o);</span><span class="s1">const </span><span class="s0">t=bc.get(e);</span><span class="s1">if</span><span class="s0">(!t)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(t.delete(s),t.size)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">const </span><span class="s0">n=Tc.get(e);Tc.delete(e),n&amp;&amp;(Sc(e).removeEventListener(</span><span class="s2">&quot;scroll&quot;</span><span class="s0">,n),Pc.get(e)?.(),window.removeEventListener(</span><span class="s2">&quot;resize&quot;</span><span class="s0">,n))}}</span><span class="s1">const </span><span class="s0">Ac=</span><span class="s1">new </span><span class="s0">Map;</span><span class="s1">function </span><span class="s0">Mc({source:t,container:e,...n}){</span><span class="s1">const</span><span class="s0">{axis:i}=n;t&amp;&amp;(e=t);</span><span class="s1">const </span><span class="s0">s=Ac.get(e)??</span><span class="s1">new </span><span class="s0">Map;Ac.set(e,s);</span><span class="s1">const </span><span class="s0">o=n.target??</span><span class="s2">&quot;self&quot;</span><span class="s0">,r=s.get(o)??{},a=i+(n.offset??[]).join(</span><span class="s2">&quot;,&quot;</span><span class="s0">);</span><span class="s1">return </span><span class="s0">r[a]||(r[a]=!n.target&amp;&amp;Mn()?</span><span class="s1">new </span><span class="s0">ScrollTimeline({source:e,axis:i}):</span><span class="s1">function</span><span class="s0">(t){</span><span class="s1">const </span><span class="s0">e={value:</span><span class="s3">0</span><span class="s0">},n=Ec(n=&gt;{e.value=</span><span class="s3">100</span><span class="s0">*n[t.axis].progress},t);</span><span class="s1">return</span><span class="s0">{currentTime:e,cancel:n}}({container:e,...n})),r[a]}</span><span class="s1">function </span><span class="s0">Cc(t,{axis:e=</span><span class="s2">&quot;y&quot;</span><span class="s0">,container:n=document.scrollingElement,...i}={}){</span><span class="s1">if</span><span class="s0">(!n)</span><span class="s1">return </span><span class="s0">V;</span><span class="s1">const </span><span class="s0">s={axis:e,container:n,...i};</span><span class="s1">return</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t?</span><span class="s1">function</span><span class="s0">(t,e){</span><span class="s1">return function</span><span class="s0">(t){</span><span class="s1">return </span><span class="s3">2</span><span class="s0">===t.length}(t)?Ec(n=&gt;{t(n[e.axis].progress,n)},e):xs(t,Mc(e))}(t,s):</span><span class="s1">function</span><span class="s0">(t,e){</span><span class="s1">const </span><span class="s0">n=Mc(e);</span><span class="s1">return </span><span class="s0">t.attachTimeline({timeline:e.target?</span><span class="s1">void </span><span class="s3">0</span><span class="s0">:n,observe:t=&gt;(t.pause(),xs(e=&gt;{t.time=t.iterationDuration*e},n))})}(t,s)}</span><span class="s1">const </span><span class="s0">Vc={some:</span><span class="s3">0</span><span class="s0">,all:</span><span class="s3">1</span><span class="s0">};</span><span class="s1">function </span><span class="s0">Dc(t,e,{root:n,margin:i,amount:s=</span><span class="s2">&quot;some&quot;</span><span class="s0">}={}){</span><span class="s1">const </span><span class="s0">o=Ei(t),r=</span><span class="s1">new </span><span class="s0">WeakMap,a=</span><span class="s1">new </span><span class="s0">IntersectionObserver(t=&gt;{t.forEach(t=&gt;{</span><span class="s1">const </span><span class="s0">n=r.get(t.target);</span><span class="s1">if</span><span class="s0">(t.isIntersecting!==Boolean(n))</span><span class="s1">if</span><span class="s0">(t.isIntersecting){</span><span class="s1">const </span><span class="s0">n=e(t.target,t);</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">n?r.set(t.target,n):a.unobserve(t.target)}</span><span class="s1">else</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">n&amp;&amp;(n(t),r.delete(t.target))})},{root:n,rootMargin:i,threshold:</span><span class="s2">&quot;number&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">s?s:Vc[s]});</span><span class="s1">return </span><span class="s0">o.forEach(t=&gt;a.observe(t)),()=&gt;a.disconnect()}</span><span class="s1">const </span><span class="s0">Rc=bl();</span><span class="s1">function </span><span class="s0">kc(t){</span><span class="s1">return </span><span class="s0">e.useEffect(()=&gt;()=&gt;t(),[])}</span><span class="s1">const </span><span class="s0">Lc={renderer:tl,...Yl,...Cu},Oc={...Lc,...xu,...Vu},jc={renderer:tl,...Yl};</span><span class="s1">function </span><span class="s0">Bc(t,n,i){e.useInsertionEffect(()=&gt;t.on(n,i),[t,n,i])}</span><span class="s1">const </span><span class="s0">Ic=()=&gt;({scrollX:Bi(</span><span class="s3">0</span><span class="s0">),scrollY:Bi(</span><span class="s3">0</span><span class="s0">),scrollXProgress:Bi(</span><span class="s3">0</span><span class="s0">),scrollYProgress:Bi(</span><span class="s3">0</span><span class="s0">)}),Fc=t=&gt;!!t&amp;&amp;!t.current;</span><span class="s1">function </span><span class="s0">Wc({container:t,target:n,...i}={}){</span><span class="s1">const </span><span class="s0">s=f(Ic),o=e.useRef(</span><span class="s1">null</span><span class="s0">),r=e.useRef(!</span><span class="s3">1</span><span class="s0">),a=e.useCallback(()=&gt;(o.current=Cc((t,{x:e,y:n})=&gt;{s.scrollX.set(e.current),s.scrollXProgress.set(e.progress),s.scrollY.set(n.current),s.scrollYProgress.set(n.progress)},{...i,container:t?.current||</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,target:n?.current||</span><span class="s1">void </span><span class="s3">0</span><span class="s0">}),()=&gt;{o.current?.()}),[t,n,JSON.stringify(i.offset)]);</span><span class="s1">return </span><span class="s0">y(()=&gt;(r.current=!</span><span class="s3">1</span><span class="s0">,Fc(t)||Fc(n)?</span><span class="s1">void</span><span class="s0">(r.current=!</span><span class="s3">0</span><span class="s0">):a()),[a]),e.useEffect(()=&gt;r.current?(Fc(t),Fc(n),a()):</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,[a]),s}</span><span class="s1">function </span><span class="s0">Uc(t){</span><span class="s1">const </span><span class="s0">n=e.useRef(</span><span class="s3">0</span><span class="s0">),{isStatic:i}=e.useContext(eo);e.useEffect(()=&gt;{</span><span class="s1">if</span><span class="s0">(i)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">const </span><span class="s0">e=({timestamp:e,delta:i})=&gt;{n.current||(n.current=e),t(e-n.current,i)};</span><span class="s1">return </span><span class="s0">at.update(e,!</span><span class="s3">0</span><span class="s0">),()=&gt;lt(e)},[t])}</span><span class="s1">class </span><span class="s0">Nc </span><span class="s1">extends </span><span class="s0">ji{constructor(){</span><span class="s1">super</span><span class="s0">(...arguments),</span><span class="s1">this</span><span class="s0">.isEnabled=!</span><span class="s3">1</span><span class="s0">}add(t){(dn.has(t)||Si.has(t))&amp;&amp;(</span><span class="s1">this</span><span class="s0">.isEnabled=!</span><span class="s3">0</span><span class="s0">,</span><span class="s1">this</span><span class="s0">.update())}update(){</span><span class="s1">this</span><span class="s0">.set(</span><span class="s1">this</span><span class="s0">.isEnabled?</span><span class="s2">&quot;transform&quot;</span><span class="s0">:</span><span class="s2">&quot;auto&quot;</span><span class="s0">)}}</span><span class="s1">function </span><span class="s0">$c(){!ha.current&amp;&amp;da();</span><span class="s1">const</span><span class="s0">[t]=e.useState(ca.current);</span><span class="s1">return </span><span class="s0">t}</span><span class="s1">function </span><span class="s0">zc(t,e){[...e].reverse().forEach(n=&gt;{</span><span class="s1">const </span><span class="s0">i=t.getVariant(n);i&amp;&amp;Cl(t,i),t.variantChildren&amp;&amp;t.variantChildren.forEach(t=&gt;{zc(t,e)})})}</span><span class="s1">function </span><span class="s0">Xc(){</span><span class="s1">const </span><span class="s0">t=</span><span class="s1">new </span><span class="s0">Set,e={subscribe:e=&gt;(t.add(e),()=&gt;{t.delete(e)}),start(e,n){</span><span class="s1">const </span><span class="s0">i=[];</span><span class="s1">return </span><span class="s0">t.forEach(t=&gt;{i.push(Ol(t,e,{transitionOverride:n}))}),Promise.all(i)},set:e=&gt;t.forEach(t=&gt;{!</span><span class="s1">function</span><span class="s0">(t,e){Array.isArray(e)?zc(t,e):</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e?zc(t,[e]):Cl(t,e)}(t,e)}),stop(){t.forEach(t=&gt;{!</span><span class="s1">function</span><span class="s0">(t){t.values.forEach(t=&gt;t.stop())}(t)})},mount:()=&gt;()=&gt;{e.stop()}};</span><span class="s1">return </span><span class="s0">e}</span><span class="s1">function </span><span class="s0">Hc(){</span><span class="s1">const </span><span class="s0">t=f(Xc);</span><span class="s1">return </span><span class="s0">y(t.mount,[]),t}</span><span class="s1">const </span><span class="s0">Yc=Hc;</span><span class="s1">class </span><span class="s0">Kc{constructor(){</span><span class="s1">this</span><span class="s0">.componentControls=</span><span class="s1">new </span><span class="s0">Set}subscribe(t){</span><span class="s1">return this</span><span class="s0">.componentControls.add(t),()=&gt;</span><span class="s1">this</span><span class="s0">.componentControls.delete(t)}start(t,e){</span><span class="s1">this</span><span class="s0">.componentControls.forEach(n=&gt;{n.start(t.nativeEvent||t,e)})}cancel(){</span><span class="s1">this</span><span class="s0">.componentControls.forEach(t=&gt;{t.cancel()})}stop(){</span><span class="s1">this</span><span class="s0">.componentControls.forEach(t=&gt;{t.stop()})}}</span><span class="s1">const </span><span class="s0">Gc=()=&gt;</span><span class="s1">new </span><span class="s0">Kc;</span><span class="s1">function </span><span class="s0">_c(t){</span><span class="s1">return null</span><span class="s0">!==t&amp;&amp;</span><span class="s2">&quot;object&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">t&amp;&amp;fl </span><span class="s1">in </span><span class="s0">t}</span><span class="s1">function </span><span class="s0">Zc(){</span><span class="s1">return </span><span class="s0">qc}</span><span class="s1">function </span><span class="s0">qc(t){ea.current&amp;&amp;(ea.current.isUpdating=!</span><span class="s3">1</span><span class="s0">,ea.current.blockUpdate(),t&amp;&amp;t())}</span><span class="s1">const </span><span class="s0">Jc=</span><span class="s1">new </span><span class="s0">Map,Qc=</span><span class="s1">new </span><span class="s0">Map,th=(t,e)=&gt;</span><span class="s2">`</span><span class="s0">${t}</span><span class="s2">: </span><span class="s0">${dn.has(e)?</span><span class="s2">&quot;transform&quot;</span><span class="s0">:e}</span><span class="s2">`</span><span class="s0">;</span><span class="s1">function </span><span class="s0">eh(t,e,n){</span><span class="s1">const </span><span class="s0">i=th(t,e),s=Jc.get(i);</span><span class="s1">if</span><span class="s0">(!s)</span><span class="s1">return null</span><span class="s0">;</span><span class="s1">const</span><span class="s0">{animation:o,startTime:r}=s;</span><span class="s1">function </span><span class="s0">a(){window.MotionCancelOptimisedAnimation?.(t,e,n)}</span><span class="s1">return </span><span class="s0">o.onfinish=a,</span><span class="s1">null</span><span class="s0">===r||window.MotionHandoffIsComplete?.(t)?(a(),</span><span class="s1">null</span><span class="s0">):r}</span><span class="s1">let </span><span class="s0">nh,ih;</span><span class="s1">const </span><span class="s0">sh=</span><span class="s1">new </span><span class="s0">Set;</span><span class="s1">function </span><span class="s0">oh(){sh.forEach(t=&gt;{t.animation.play(),t.animation.startTime=t.startTime}),sh.clear()}</span><span class="s1">const </span><span class="s0">rh=()=&gt;({});</span><span class="s1">class </span><span class="s0">ah </span><span class="s1">extends </span><span class="s0">ba{constructor(){</span><span class="s1">super</span><span class="s0">(...arguments),</span><span class="s1">this</span><span class="s0">.measureInstanceViewportBox=dr}build(){}resetTransform(){}restoreTransform(){}removeValueFromRenderState(){}renderInstance(){}scrapeMotionValuesFromProps(){</span><span class="s1">return</span><span class="s0">{}}getBaseTargetFromProps(){}readValueFromInstance(t,e,n){</span><span class="s1">return </span><span class="s0">n.initialState[e]||</span><span class="s3">0</span><span class="s0">}sortInstanceNodePosition(){</span><span class="s1">return </span><span class="s3">0</span><span class="s0">}}</span><span class="s1">const </span><span class="s0">lh=dl({scrapeMotionValuesFromProps:rh,createRenderState:rh});</span><span class="s1">let </span><span class="s0">uh=</span><span class="s3">0</span><span class="s0">;</span><span class="s1">const </span><span class="s0">ch=t=&gt;t&gt;</span><span class="s3">.001</span><span class="s0">?</span><span class="s3">1</span><span class="s0">/t:</span><span class="s3">1e5</span><span class="s0">;t.AnimatePresence=({children:t,custom:n,initial:i=!</span><span class="s3">0</span><span class="s0">,onExitComplete:s,presenceAffectsLayout:o=!</span><span class="s3">0</span><span class="s0">,mode:r=</span><span class="s2">&quot;sync&quot;</span><span class="s0">,propagate:a=!</span><span class="s3">1</span><span class="s0">,anchorX:l=</span><span class="s2">&quot;left&quot;</span><span class="s0">,root:u})=&gt;{</span><span class="s1">const</span><span class="s0">[c,p]=lo(a),g=e.useMemo(()=&gt;co(t),[t]),v=a&amp;&amp;!c?[]:g.map(uo),x=e.useRef(!</span><span class="s3">0</span><span class="s0">),w=e.useRef(g),T=f(()=&gt;</span><span class="s1">new </span><span class="s0">Map),[P,b]=e.useState(g),[S,E]=e.useState(g);y(()=&gt;{x.current=!</span><span class="s3">1</span><span class="s0">,w.current=g;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">t=</span><span class="s3">0</span><span class="s0">;t&lt;S.length;t++){</span><span class="s1">const </span><span class="s0">e=uo(S[t]);v.includes(e)?T.delete(e):!</span><span class="s3">0</span><span class="s0">!==T.get(e)&amp;&amp;T.set(e,!</span><span class="s3">1</span><span class="s0">)}},[S,v.length,v.join(</span><span class="s2">&quot;-&quot;</span><span class="s0">)]);</span><span class="s1">const </span><span class="s0">A=[];</span><span class="s1">if</span><span class="s0">(g!==P){</span><span class="s1">let </span><span class="s0">t=[...g];</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">e=</span><span class="s3">0</span><span class="s0">;e&lt;S.length;e++){</span><span class="s1">const </span><span class="s0">n=S[e],i=uo(n);v.includes(i)||(t.splice(e,</span><span class="s3">0</span><span class="s0">,n),A.push(n))}</span><span class="s1">return</span><span class="s2">&quot;wait&quot;</span><span class="s0">===r&amp;&amp;A.length&amp;&amp;(t=A),E(co(t)),b(g),</span><span class="s1">null</span><span class="s0">}</span><span class="s1">const</span><span class="s0">{forceRender:M}=e.useContext(m);</span><span class="s1">return </span><span class="s0">d(h,{children:S.map(t=&gt;{</span><span class="s1">const </span><span class="s0">e=uo(t),h=!(a&amp;&amp;!c)&amp;&amp;(g===S||v.includes(e));</span><span class="s1">return </span><span class="s0">d(ro,{isPresent:h,initial:!(x.current&amp;&amp;!i)&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,custom:n,presenceAffectsLayout:o,mode:r,root:u,onExitComplete:h?</span><span class="s1">void </span><span class="s3">0</span><span class="s0">:()=&gt;{</span><span class="s1">if</span><span class="s0">(!T.has(e))</span><span class="s1">return</span><span class="s0">;T.set(e,!</span><span class="s3">0</span><span class="s0">);</span><span class="s1">let </span><span class="s0">t=!</span><span class="s3">0</span><span class="s0">;T.forEach(e=&gt;{e||(t=!</span><span class="s3">1</span><span class="s0">)}),t&amp;&amp;(M?.(),E(w.current),a&amp;&amp;p?.(),s&amp;&amp;s())},anchorX:l,children:t},e)})})},t.AnimateSharedLayout=({children:t})=&gt;(i.useEffect(()=&gt;{},[]),d(ja,{id:f(()=&gt;</span><span class="s2">&quot;asl-&quot;</span><span class="s0">+uh++),children:t})),t.AsyncMotionValueAnimation=Yn,t.DOMKeyframesResolver=wi,t.DeprecatedLayoutGroupContext=ho,t.DragControls=Kc,t.GroupAnimation=Kn,t.GroupAnimationWithThen=_n,t.JSAnimation=qe,t.KeyframeResolver=Sn,t.LayoutGroup=ja,t.LayoutGroupContext=m,t.LazyMotion=</span><span class="s1">function</span><span class="s0">({children:t,features:n,strict:i=!</span><span class="s3">1</span><span class="s0">}){</span><span class="s1">const</span><span class="s0">[,s]=e.useState(!Fa(n)),o=e.useRef(</span><span class="s1">void </span><span class="s3">0</span><span class="s0">);</span><span class="s1">if</span><span class="s0">(!Fa(n)){</span><span class="s1">const</span><span class="s0">{renderer:t,...e}=n;o.current=t,Ia(e)}</span><span class="s1">return </span><span class="s0">e.useEffect(()=&gt;{Fa(n)&amp;&amp;n().then(({renderer:t,...e})=&gt;{Ia(e),o.current=t,s(!</span><span class="s3">0</span><span class="s0">)})},[]),d(Ba.Provider,{value:{renderer:o.current,strict:i},children:t})},t.MotionConfig=</span><span class="s1">function</span><span class="s0">({children:t,isValidProp:n,...i}){n&amp;&amp;$a(n),(i={...e.useContext(eo),...i}).isStatic=f(()=&gt;i.isStatic);</span><span class="s1">const </span><span class="s0">s=e.useMemo(()=&gt;i,[JSON.stringify(i.transition),i.transformPagePoint,i.reducedMotion]);</span><span class="s1">return </span><span class="s0">d(eo.Provider,{value:s,children:t})},t.MotionConfigContext=eo,t.MotionContext=el,t.MotionGlobalConfig=S,t.MotionValue=ji,t.NativeAnimation=In,t.NativeAnimationExtended=Un,t.NativeAnimationWrapper=Zn,t.PresenceContext=v,t.Reorder=$u,t.SubscriptionManager=L,t.SwitchLayoutGroupContext=vl,t.ViewTransitionBuilder=Js,t.VisualElement=ba,t.WillChangeMotionValue=Nc,t.acceleratedValues=Si,t.activeAnimations=mt,t.addAttrValue=Di,t.addPointerEvent=_l,t.addPointerInfo=Gl,t.addScaleCorrector=Pr,t.addStyleValue=Wi,t.addUniqueItem=x,t.alpha=Tt,t.analyseComplexValue=Xt,t.animate=lc,t.animateMini=cc,t.animateValue=</span><span class="s1">function</span><span class="s0">(t){</span><span class="s1">return new </span><span class="s0">qe(t)},t.animateView=</span><span class="s1">function</span><span class="s0">(t,e={}){</span><span class="s1">return new </span><span class="s0">Js(t,e)},t.animateVisualElement=Ol,t.animationControls=Xc,t.animationMapKey=Jn,t.animations=Yl,t.anticipate=Y,t.applyGeneratorOptions=Bn,t.applyPxDefaults=Pi,t.attachSpring=Rs,t.attrEffect=Ri,t.backIn=X,t.backInOut=H,t.backOut=z,t.buildTransform=Ma,t.calcGeneratorDuration=me,t.calcLength=po,t.cancelFrame=lt,t.cancelMicrotask=Xi,t.cancelSync=to,t.circIn=K,t.circInOut=_,t.circOut=G,t.clamp=P,t.collectMotionValues=Oi,t.color=Wt,t.complex=Gt,t.convertOffsetToTimes=$e,t.createBox=dr,t.createGeneratorEasing=fe,t.createRenderBatcher=rt,t.createScopedAnimate=ac,t.cubicBezier=U,t.cubicBezierAsString=Rn,t.defaultEasing=ze,t.defaultOffset=Ne,t.defaultTransformValue=an,t.defaultValueTypes=gi,t.degrees=kt,t.delay=Oo,t.dimensionValueTypes=ri,t.disableInstantTransitions=</span><span class="s1">function</span><span class="s0">(){S.instantAnimations=!</span><span class="s3">1</span><span class="s0">},t.distance=ql,t.distance2D=Jl,t.domAnimation=Lc,t.domMax=Oc,t.domMin=jc,t.easeIn=Z,t.easeInOut=J,t.easeOut=q,t.easingDefinitionToFunction=it,t.fillOffset=Ue,t.fillWildcards=Je,t.filterProps=za,t.findDimensionValueType=ai,t.findValueType=js,t.flushKeyframeResolvers=bn,t.frame=at,t.frameData=ut,t.frameSteps=ct,t.generateLinearEasing=de,t.getAnimatableNone=vi,t.getAnimationMap=Qn,t.getComputedStyle=os,t.getDefaultValueType=yi,t.getEasingForSegment=tt,t.getMixer=re,t.getOriginIndex=Ms,t.getValueAsType=Mi,t.getValueTransition=ii,t.getVariableValue=ni,t.getViewAnimationLayerInfo=$s,t.getViewAnimations=Xs,t.hasWarned=</span><span class="s1">function</span><span class="s0">(t){</span><span class="s1">return </span><span class="s0">I.has(t)},t.hex=Dt,t.hover=Zi,t.hsla=Ft,t.hslaToRgba=Zt,t.inView=Dc,t.inertia=Fe,t.interpolate=We,t.invariant=b,t.invisibleValues=ie,t.isBezierDefinition=et,t.isBrowser=g,t.isCSSVariableName=gt,t.isCSSVariableToken=vt,t.isDragActive=Yi,t.isDragging=Hi,t.isEasingArray=Q,t.isGenerator=jn,t.isHTMLElement=Li,t.isMotionComponent=_c,t.isMotionValue=Ds,t.isNodeOrChild=qi,t.isNumericalString=E,t.isObject=A,t.isPrimaryPointer=Ji,t.isSVGElement=rs,t.isSVGSVGElement=As,t.isValidMotionProp=Ua,t.isWaapiSupportedEasing=</span><span class="s1">function </span><span class="s0">t(e){</span><span class="s1">return </span><span class="s0">Boolean(</span><span class="s2">&quot;function&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;Dn()||!e||</span><span class="s2">&quot;string&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">e&amp;&amp;(e </span><span class="s1">in </span><span class="s0">kn||Dn())||et(e)||Array.isArray(e)&amp;&amp;e.every(t))},t.isZeroValueString=M,t.keyframes=Xe,t.m=Rc,t.makeAnimationInstant=$n,t.makeUseVisualState=dl,t.mapEasingToNativeEasing=Ln,t.mapValue=</span><span class="s1">function</span><span class="s0">(t,e,n,i){</span><span class="s1">const </span><span class="s0">s=Cs(e,n,i);</span><span class="s1">return </span><span class="s0">Vs(()=&gt;s(t.get()))},t.maxGeneratorDuration=pe,t.memo=C,t.microtask=zi,t.millisecondsToSeconds=j,t.mirrorEasing=N,t.mix=ce,t.mixArray=ae,t.mixColor=ne,t.mixComplex=ue,t.mixImmediate=qt,t.mixLinearColor=Qt,t.mixNumber=Jt,t.mixObject=le,t.mixVisibility=se,t.motion=Du,t.motionValue=Bi,t.moveItem=T,t.noop=V,t.number=wt,t.numberValueTypes=fi,t.observeTimeline=xs,t.optimizedAppearDataAttribute=Do,t.parseCSSVariable=ei,t.parseValueFromTransform=ln,t.percent=Lt,t.pipe=R,t.positionalKeys=si,t.press=ss,t.progress=k,t.progressPercentage=It,t.propEffect=ki,t.px=Ot,t.readTransformValue=un,t.recordStats=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">if</span><span class="s0">(ot.value)</span><span class="s1">throw </span><span class="s0">Ss(),</span><span class="s1">new </span><span class="s0">Error(</span><span class="s2">&quot;Stats are already being measured&quot;</span><span class="s0">);</span><span class="s1">const </span><span class="s0">t=ot;</span><span class="s1">return </span><span class="s0">t.value={frameloop:{setup:[],rate:[],read:[],resolveKeyframes:[],preUpdate:[],update:[],preRender:[],render:[],postRender:[]},animations:{mainThread:[],waapi:[],layout:[]},layoutProjection:{nodes:[],calculatedTargetDeltas:[],calculatedProjections:[]}},t.addProjectionMetrics=e=&gt;{</span><span class="s1">const</span><span class="s0">{layoutProjection:n}=t.value;n.nodes.push(e.nodes),n.calculatedTargetDeltas.push(e.calculatedTargetDeltas),n.calculatedProjections.push(e.calculatedProjections)},at.postRender(ws,!</span><span class="s3">0</span><span class="s0">),Es},t.removeItem=w,t.resize=vs,t.resolveElements=Ei,t.resolveMotionValue=jo,t.reverseEasing=$,t.rgbUnit=Ct,t.rgba=Vt,t.scale=Pt,t.scroll=Cc,t.scrollInfo=Ec,t.secondsToMilliseconds=O,t.setDragLock=Ki,t.setStyle=An,t.spring=Ie,t.springValue=</span><span class="s1">function</span><span class="s0">(t,e){</span><span class="s1">const </span><span class="s0">n=Bi(Ds(t)?t.get():t);</span><span class="s1">return </span><span class="s0">Rs(n,t,e),n},t.stagger=</span><span class="s1">function</span><span class="s0">(t=</span><span class="s3">.1</span><span class="s0">,{startDelay:e=</span><span class="s3">0</span><span class="s0">,from:n=</span><span class="s3">0</span><span class="s0">,ease:i}={}){</span><span class="s1">return</span><span class="s0">(s,o)=&gt;{</span><span class="s1">const </span><span class="s0">r=</span><span class="s2">&quot;number&quot;</span><span class="s0">==</span><span class="s1">typeof </span><span class="s0">n?n:Ms(n,o),a=Math.abs(r-s);</span><span class="s1">let </span><span class="s0">l=t*a;</span><span class="s1">if</span><span class="s0">(i){</span><span class="s1">const </span><span class="s0">e=o*t;l=it(i)(l/e)*e}</span><span class="s1">return </span><span class="s0">e+l}},t.startOptimizedAppearAnimation=</span><span class="s1">function</span><span class="s0">(t,e,n,i,s){</span><span class="s1">if</span><span class="s0">(window.MotionIsMounted)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">const </span><span class="s0">o=t.dataset[Vo];</span><span class="s1">if</span><span class="s0">(!o)</span><span class="s1">return</span><span class="s0">;window.MotionHandoffAnimation=eh;</span><span class="s1">const </span><span class="s0">r=th(o,e);ih||(ih=On(t,e,[n[</span><span class="s3">0</span><span class="s0">],n[</span><span class="s3">0</span><span class="s0">]],{duration:</span><span class="s3">1e4</span><span class="s0">,ease:</span><span class="s2">&quot;linear&quot;</span><span class="s0">}),Jc.set(r,{animation:ih,startTime:</span><span class="s1">null</span><span class="s0">}),window.MotionHandoffAnimation=eh,window.MotionHasOptimisedAnimation=(t,e)=&gt;{</span><span class="s1">if</span><span class="s0">(!t)</span><span class="s1">return</span><span class="s0">!</span><span class="s3">1</span><span class="s0">;</span><span class="s1">if</span><span class="s0">(!e)</span><span class="s1">return </span><span class="s0">Qc.has(t);</span><span class="s1">const </span><span class="s0">n=th(t,e);</span><span class="s1">return </span><span class="s0">Boolean(Jc.get(n))},window.MotionHandoffMarkAsComplete=t=&gt;{Qc.has(t)&amp;&amp;Qc.set(t,!</span><span class="s3">0</span><span class="s0">)},window.MotionHandoffIsComplete=t=&gt;!</span><span class="s3">0</span><span class="s0">===Qc.get(t),window.MotionCancelOptimisedAnimation=(t,e,n,i)=&gt;{</span><span class="s1">const </span><span class="s0">s=th(t,e),o=Jc.get(s);o&amp;&amp;(n&amp;&amp;</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===i?n.postRender(()=&gt;{n.postRender(()=&gt;{o.animation.cancel()})}):o.animation.cancel(),n&amp;&amp;i?(sh.add(o),n.render(oh)):(Jc.delete(s),Jc.size||(window.MotionCancelOptimisedAnimation=</span><span class="s1">void </span><span class="s3">0</span><span class="s0">)))},window.MotionCheckAppearSync=(t,e,n)=&gt;{</span><span class="s1">const </span><span class="s0">i=Ro(t);</span><span class="s1">if</span><span class="s0">(!i)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">const </span><span class="s0">s=window.MotionHasOptimisedAnimation?.(i,e),o=t.props.values?.[e];</span><span class="s1">if</span><span class="s0">(!s||!o)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">const </span><span class="s0">r=n.on(</span><span class="s2">&quot;change&quot;</span><span class="s0">,t=&gt;{o.get()!==t&amp;&amp;(window.MotionCancelOptimisedAnimation?.(i,e),r())});</span><span class="s1">return </span><span class="s0">r});</span><span class="s1">const </span><span class="s0">a=()=&gt;{ih.cancel();</span><span class="s1">const </span><span class="s0">o=On(t,e,n,i);</span><span class="s1">void </span><span class="s3">0</span><span class="s0">===nh&amp;&amp;(nh=performance.now()),o.startTime=nh,Jc.set(r,{animation:o,startTime:nh}),s&amp;&amp;s(o)};Qc.set(o,!</span><span class="s3">1</span><span class="s0">),ih.ready?ih.ready.then(a).catch(V):a()},t.startWaapiAnimation=On,t.statsBuffer=ot,t.steps=</span><span class="s1">function</span><span class="s0">(t,e=</span><span class="s2">&quot;end&quot;</span><span class="s0">){</span><span class="s1">return </span><span class="s0">n=&gt;{</span><span class="s1">const </span><span class="s0">i=(n=</span><span class="s2">&quot;end&quot;</span><span class="s0">===e?Math.min(n,</span><span class="s3">.999</span><span class="s0">):Math.max(n,</span><span class="s3">.001</span><span class="s0">))*t,s=</span><span class="s2">&quot;end&quot;</span><span class="s0">===e?Math.floor(i):Math.ceil(i);</span><span class="s1">return </span><span class="s0">P(</span><span class="s3">0</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,s/t)}},t.styleEffect=Ui,t.supportedWaapiEasing=kn,t.supportsBrowserAnimation=Hn,t.supportsFlags=Cn,t.supportsLinearEasing=Dn,t.supportsPartialKeyframes=bi,t.supportsScrollTimeline=Mn,t.svgEffect=$i,t.sync=Qs,t.testValueType=oi,t.time=pt,t.transform=Cs,t.transformPropOrder=hn,t.transformProps=dn,t.transformValue=Vs,t.transformValueTypes=mi,t.unwrapMotionComponent=</span><span class="s1">function</span><span class="s0">(t){</span><span class="s1">if</span><span class="s0">(_c(t))</span><span class="s1">return </span><span class="s0">t[fl]},t.useAnimate=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">const </span><span class="s0">t=f(()=&gt;({current:</span><span class="s1">null</span><span class="s0">,animations:[]})),e=f(()=&gt;ac(t));</span><span class="s1">return </span><span class="s0">kc(()=&gt;{t.animations.forEach(t=&gt;t.stop()),t.animations.length=</span><span class="s3">0</span><span class="s0">}),[t,e]},t.useAnimateMini=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">const </span><span class="s0">t=f(()=&gt;({current:</span><span class="s1">null</span><span class="s0">,animations:[]})),e=f(()=&gt;uc(t));</span><span class="s1">return </span><span class="s0">kc(()=&gt;{t.animations.forEach(t=&gt;t.stop())}),[t,e]},t.useAnimation=Yc,t.useAnimationControls=Hc,t.useAnimationFrame=Uc,t.useComposedRefs=io,t.useCycle=</span><span class="s1">function</span><span class="s0">(...t){</span><span class="s1">const </span><span class="s0">n=e.useRef(</span><span class="s3">0</span><span class="s0">),[i,s]=e.useState(t[n.current]),o=e.useCallback(e=&gt;{n.current=</span><span class="s2">&quot;number&quot;</span><span class="s0">!=</span><span class="s1">typeof </span><span class="s0">e?F(</span><span class="s3">0</span><span class="s0">,t.length,n.current+</span><span class="s3">1</span><span class="s0">):e,s(t[n.current])},[t.length,...t]);</span><span class="s1">return</span><span class="s0">[i,o]},t.useDeprecatedAnimatedState=</span><span class="s1">function</span><span class="s0">(t){</span><span class="s1">const</span><span class="s0">[n,i]=e.useState(t),s=lh({},!</span><span class="s3">1</span><span class="s0">),o=f(()=&gt;</span><span class="s1">new </span><span class="s0">ah({props:{onUpdate:t=&gt;{i({...t})}},visualState:s,presenceContext:</span><span class="s1">null</span><span class="s0">},{initialState:t}));</span><span class="s1">return </span><span class="s0">e.useLayoutEffect(()=&gt;(o.mount({}),()=&gt;o.unmount()),[o]),[n,f(()=&gt;t=&gt;Ol(o,t))]},t.useDeprecatedInvertedScale=</span><span class="s1">function</span><span class="s0">(t){</span><span class="s1">let </span><span class="s0">n=ju(</span><span class="s3">1</span><span class="s0">),i=ju(</span><span class="s3">1</span><span class="s0">);</span><span class="s1">const</span><span class="s0">{visualElement:s}=e.useContext(el);</span><span class="s1">return </span><span class="s0">t?(n=t.scaleX||n,i=t.scaleY||i):s&amp;&amp;(n=s.getValue(</span><span class="s2">&quot;scaleX&quot;</span><span class="s0">,</span><span class="s3">1</span><span class="s0">),i=s.getValue(</span><span class="s2">&quot;scaleY&quot;</span><span class="s0">,</span><span class="s3">1</span><span class="s0">)),{scaleX:Iu(n,ch),scaleY:Iu(i,ch)}},t.useDomEvent=</span><span class="s1">function</span><span class="s0">(t,n,i,s){e.useEffect(()=&gt;{</span><span class="s1">const </span><span class="s0">e=t.current;</span><span class="s1">if</span><span class="s0">(i&amp;&amp;e)</span><span class="s1">return </span><span class="s0">Qr(e,n,i,s)},[t,n,i,s])},t.useDragControls=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">f(Gc)},t.useElementScroll=</span><span class="s1">function</span><span class="s0">(t){</span><span class="s1">return </span><span class="s0">Wc({container:t})},t.useForceUpdate=La,t.useInView=</span><span class="s1">function</span><span class="s0">(t,{root:n,margin:i,amount:s,once:o=!</span><span class="s3">1</span><span class="s0">,initial:r=!</span><span class="s3">1</span><span class="s0">}={}){</span><span class="s1">const</span><span class="s0">[a,l]=e.useState(r);</span><span class="s1">return </span><span class="s0">e.useEffect(()=&gt;{</span><span class="s1">if</span><span class="s0">(!t.current||o&amp;&amp;a)</span><span class="s1">return</span><span class="s0">;</span><span class="s1">const </span><span class="s0">e={root:n&amp;&amp;n.current||</span><span class="s1">void </span><span class="s3">0</span><span class="s0">,margin:i,amount:s};</span><span class="s1">return </span><span class="s0">Dc(t.current,()=&gt;(l(!</span><span class="s3">0</span><span class="s0">),o?</span><span class="s1">void </span><span class="s3">0</span><span class="s0">:()=&gt;l(!</span><span class="s3">1</span><span class="s0">)),e)},[n,t,i,o,s]),a},t.useInstantLayoutTransition=Zc,t.useInstantTransition=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">const</span><span class="s0">[t,n]=La(),i=Zc(),s=e.useRef(-</span><span class="s3">1</span><span class="s0">);</span><span class="s1">return </span><span class="s0">e.useEffect(()=&gt;{at.postRender(()=&gt;at.postRender(()=&gt;{n===s.current&amp;&amp;(S.instantAnimations=!</span><span class="s3">1</span><span class="s0">)}))},[n]),e=&gt;{i(()=&gt;{S.instantAnimations=!</span><span class="s3">0</span><span class="s0">,t(),e(),s.current=n+</span><span class="s3">1</span><span class="s0">})}},t.useIsPresent=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return null</span><span class="s0">===(t=e.useContext(v))||t.isPresent;</span><span class="s1">var </span><span class="s0">t},t.useIsomorphicLayoutEffect=y,t.useMotionTemplate=</span><span class="s1">function</span><span class="s0">(t,...e){</span><span class="s1">const </span><span class="s0">n=t.length;</span><span class="s1">return </span><span class="s0">Bu(e.filter(Ds),</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">let </span><span class="s0">i=</span><span class="s2">&quot;&quot;</span><span class="s0">;</span><span class="s1">for</span><span class="s0">(</span><span class="s1">let </span><span class="s0">s=</span><span class="s3">0</span><span class="s0">;s&lt;n;s++){i+=t[s];</span><span class="s1">const </span><span class="s0">n=e[s];n&amp;&amp;(i+=Ds(n)?n.get():n)}</span><span class="s1">return </span><span class="s0">i})},t.useMotionValue=ju,t.useMotionValueEvent=Bc,t.usePageInView=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">const</span><span class="s0">[t,n]=e.useState(!</span><span class="s3">0</span><span class="s0">);</span><span class="s1">return </span><span class="s0">e.useEffect(()=&gt;{</span><span class="s1">const </span><span class="s0">t=()=&gt;n(!document.hidden);</span><span class="s1">return </span><span class="s0">document.hidden&amp;&amp;t(),document.addEventListener(</span><span class="s2">&quot;visibilitychange&quot;</span><span class="s0">,t),()=&gt;{document.removeEventListener(</span><span class="s2">&quot;visibilitychange&quot;</span><span class="s0">,t)}},[]),t},t.usePresence=lo,t.usePresenceData=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">const </span><span class="s0">t=e.useContext(v);</span><span class="s1">return </span><span class="s0">t?t.custom:</span><span class="s1">void </span><span class="s3">0</span><span class="s0">},t.useReducedMotion=$c,t.useReducedMotionConfig=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">const </span><span class="s0">t=$c(),{reducedMotion:n}=e.useContext(eo);</span><span class="s1">return</span><span class="s2">&quot;never&quot;</span><span class="s0">!==n&amp;&amp;(</span><span class="s2">&quot;always&quot;</span><span class="s0">===n||t)},t.useResetProjection=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">e.useCallback(()=&gt;{</span><span class="s1">const </span><span class="s0">t=ea.current;t&amp;&amp;t.resetTree()},[])},t.useScroll=Wc,t.useSpring=</span><span class="s1">function</span><span class="s0">(t,n={}){</span><span class="s1">const</span><span class="s0">{isStatic:i}=e.useContext(eo),s=()=&gt;Ds(t)?t.get():t;</span><span class="s1">if</span><span class="s0">(i)</span><span class="s1">return </span><span class="s0">Iu(s);</span><span class="s1">const </span><span class="s0">o=ju(s());</span><span class="s1">return </span><span class="s0">e.useInsertionEffect(()=&gt;Rs(o,t,n),[o,JSON.stringify(n)]),o},t.useTime=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">const </span><span class="s0">t=ju(</span><span class="s3">0</span><span class="s0">);</span><span class="s1">return </span><span class="s0">Uc(e=&gt;t.set(e)),t},t.useTransform=Iu,t.useUnmountEffect=kc,t.useVelocity=</span><span class="s1">function</span><span class="s0">(t){</span><span class="s1">const </span><span class="s0">e=ju(t.getVelocity()),n=()=&gt;{</span><span class="s1">const </span><span class="s0">i=t.getVelocity();e.set(i),i&amp;&amp;at.update(n)};</span><span class="s1">return </span><span class="s0">Bc(t,</span><span class="s2">&quot;change&quot;</span><span class="s0">,()=&gt;{at.update(n,!</span><span class="s3">1</span><span class="s0">,!</span><span class="s3">0</span><span class="s0">)}),e},t.useViewportScroll=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">Wc()},t.useWillChange=</span><span class="s1">function</span><span class="s0">(){</span><span class="s1">return </span><span class="s0">f(()=&gt;</span><span class="s1">new </span><span class="s0">Nc(</span><span class="s2">&quot;auto&quot;</span><span class="s0">))},t.velocityPerSecond=B,t.vh=jt,t.visualElementStore=pa,t.vw=Bt,t.warnOnce=</span><span class="s1">function</span><span class="s0">(t,e,n){t||I.has(e)||(console.warn(</span><span class="s1">function</span><span class="s0">(t,e){</span><span class="s1">return </span><span class="s0">e?</span><span class="s2">`</span><span class="s0">${t}</span><span class="s2">. For more information and steps for solving, visit https://motion.dev/troubleshooting/</span><span class="s0">${e}</span><span class="s2">`</span><span class="s0">:t}(e,n)),I.add(e))},t.warning=()=&gt;{},t.wrap=F});</span>
</pre>
</body>
</html>