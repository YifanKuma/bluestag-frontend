<html>
<head>
<title>jsx-pragma.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
jsx-pragma.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../src/build/babel/plugins/jsx-pragma.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type {</span><span class="s3">\n  </span><span class="s1">NodePath,</span><span class="s3">\n  </span><span class="s1">types as BabelTypes,</span><span class="s3">\n</span><span class="s1">} from 'next/dist/compiled/babel/core'</span><span class="s3">\n</span><span class="s1">import type { PluginObj } from 'next/dist/compiled/babel/core'</span><span class="s3">\n</span><span class="s1">import jsx from 'next/dist/compiled/babel/plugin-syntax-jsx'</span><span class="s3">\n\n</span><span class="s1">export default function ({</span><span class="s3">\n  </span><span class="s1">types: t,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">types: typeof BabelTypes</span><span class="s3">\n</span><span class="s1">}): PluginObj&lt;any&gt; {</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">inherits: jsx,</span><span class="s3">\n    </span><span class="s1">visitor: {</span><span class="s3">\n      </span><span class="s1">JSXElement(_path, state) {</span><span class="s3">\n        </span><span class="s1">state.set('jsx', true)</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n\n      </span><span class="s1">// Fragment syntax is still JSX since it compiles to createElement(),</span><span class="s3">\n      </span><span class="s1">// but JSXFragment is not a JSXElement</span><span class="s3">\n      </span><span class="s1">JSXFragment(_path, state) {</span><span class="s3">\n        </span><span class="s1">state.set('jsx', true)</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n\n      </span><span class="s1">Program: {</span><span class="s3">\n        </span><span class="s1">exit(path: NodePath&lt;BabelTypes.Program&gt;, state) {</span><span class="s3">\n          </span><span class="s1">if (state.get('jsx')) {</span><span class="s3">\n            </span><span class="s1">const pragma = t.identifier(state.opts.pragma)</span><span class="s3">\n            </span><span class="s1">let importAs = pragma</span><span class="s3">\n\n            </span><span class="s1">// if there's already a React in scope, use that instead of adding an import</span><span class="s3">\n            </span><span class="s1">const existingBinding =</span><span class="s3">\n              </span><span class="s1">state.opts.reuseImport !== false &amp;&amp;</span><span class="s3">\n              </span><span class="s1">state.opts.importAs &amp;&amp;</span><span class="s3">\n              </span><span class="s1">path.scope.getBinding(state.opts.importAs)</span><span class="s3">\n\n            </span><span class="s1">// var _jsx = _pragma.createElement;</span><span class="s3">\n            </span><span class="s1">if (state.opts.property) {</span><span class="s3">\n              </span><span class="s1">if (state.opts.importAs) {</span><span class="s3">\n                </span><span class="s1">importAs = t.identifier(state.opts.importAs)</span><span class="s3">\n              </span><span class="s1">} else {</span><span class="s3">\n                </span><span class="s1">importAs = path.scope.generateUidIdentifier('pragma')</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n\n              </span><span class="s1">const mapping = t.variableDeclaration('var', [</span><span class="s3">\n                </span><span class="s1">t.variableDeclarator(</span><span class="s3">\n                  </span><span class="s1">pragma,</span><span class="s3">\n                  </span><span class="s1">t.memberExpression(</span><span class="s3">\n                    </span><span class="s1">importAs,</span><span class="s3">\n                    </span><span class="s1">t.identifier(state.opts.property)</span><span class="s3">\n                  </span><span class="s1">)</span><span class="s3">\n                </span><span class="s1">),</span><span class="s3">\n              </span><span class="s1">])</span><span class="s3">\n\n              </span><span class="s1">// if the React binding came from a require('react'),</span><span class="s3">\n              </span><span class="s1">// make sure that our usage comes after it.</span><span class="s3">\n              </span><span class="s1">let newPath: NodePath&lt;BabelTypes.VariableDeclaration&gt;</span><span class="s3">\n\n              </span><span class="s1">if (</span><span class="s3">\n                </span><span class="s1">existingBinding &amp;&amp;</span><span class="s3">\n                </span><span class="s1">t.isVariableDeclarator(existingBinding.path.node) &amp;&amp;</span><span class="s3">\n                </span><span class="s1">t.isCallExpression(existingBinding.path.node.init) &amp;&amp;</span><span class="s3">\n                </span><span class="s1">t.isIdentifier(existingBinding.path.node.init.callee) &amp;&amp;</span><span class="s3">\n                </span><span class="s1">existingBinding.path.node.init.callee.name === 'require'</span><span class="s3">\n              </span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">;[newPath] =</span><span class="s3">\n                  </span><span class="s1">existingBinding.path.parentPath.insertAfter(mapping)</span><span class="s3">\n              </span><span class="s1">} else {</span><span class="s3">\n                </span><span class="s1">;[newPath] = path.unshiftContainer('body', mapping)</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n\n              </span><span class="s1">path.scope.registerDeclaration(newPath)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">if (!existingBinding) {</span><span class="s3">\n              </span><span class="s1">const importSpecifier = t.importDeclaration(</span><span class="s3">\n                </span><span class="s1">[</span><span class="s3">\n                  </span><span class="s1">state.opts.import</span><span class="s3">\n                    </span><span class="s1">? // import { $import as _pragma } from '$module'</span><span class="s3">\n                      </span><span class="s1">t.importSpecifier(</span><span class="s3">\n                        </span><span class="s1">importAs,</span><span class="s3">\n                        </span><span class="s1">t.identifier(state.opts.import)</span><span class="s3">\n                      </span><span class="s1">)</span><span class="s3">\n                    </span><span class="s1">: state.opts.importNamespace</span><span class="s3">\n                      </span><span class="s1">? t.importNamespaceSpecifier(importAs)</span><span class="s3">\n                      </span><span class="s1">: // import _pragma from '$module'</span><span class="s3">\n                        </span><span class="s1">t.importDefaultSpecifier(importAs),</span><span class="s3">\n                </span><span class="s1">],</span><span class="s3">\n                </span><span class="s1">t.stringLiteral(state.opts.module || 'react')</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n\n              </span><span class="s1">const [newPath] = path.unshiftContainer('body', importSpecifier)</span><span class="s3">\n              </span><span class="s1">for (const specifier of newPath.get('specifiers')) {</span><span class="s3">\n                </span><span class="s1">path.scope.registerBinding(</span><span class="s3">\n                  </span><span class="s1">'module',</span><span class="s3">\n                  </span><span class="s1">specifier as NodePath&lt;BabelTypes.Node&gt;</span><span class="s3">\n                </span><span class="s1">)</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;types&quot;</span><span class="s0">,</span><span class="s1">&quot;t&quot;</span><span class="s0">,</span><span class="s1">&quot;inherits&quot;</span><span class="s0">,</span><span class="s1">&quot;jsx&quot;</span><span class="s0">,</span><span class="s1">&quot;visitor&quot;</span><span class="s0">,</span><span class="s1">&quot;JSXElement&quot;</span><span class="s0">,</span><span class="s1">&quot;_path&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;JSXFragment&quot;</span><span class="s0">,</span><span class="s1">&quot;Program&quot;</span><span class="s0">,</span><span class="s1">&quot;exit&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;pragma&quot;</span><span class="s0">,</span><span class="s1">&quot;identifier&quot;</span><span class="s0">,</span><span class="s1">&quot;opts&quot;</span><span class="s0">,</span><span class="s1">&quot;importAs&quot;</span><span class="s0">,</span><span class="s1">&quot;existingBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;reuseImport&quot;</span><span class="s0">,</span><span class="s1">&quot;scope&quot;</span><span class="s0">,</span><span class="s1">&quot;getBinding&quot;</span><span class="s0">,</span><span class="s1">&quot;property&quot;</span><span class="s0">,</span><span class="s1">&quot;generateUidIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;mapping&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;variableDeclarator&quot;</span><span class="s0">,</span><span class="s1">&quot;memberExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;newPath&quot;</span><span class="s0">,</span><span class="s1">&quot;isVariableDeclarator&quot;</span><span class="s0">,</span><span class="s1">&quot;node&quot;</span><span class="s0">,</span><span class="s1">&quot;isCallExpression&quot;</span><span class="s0">,</span><span class="s1">&quot;init&quot;</span><span class="s0">,</span><span class="s1">&quot;isIdentifier&quot;</span><span class="s0">,</span><span class="s1">&quot;callee&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;parentPath&quot;</span><span class="s0">,</span><span class="s1">&quot;insertAfter&quot;</span><span class="s0">,</span><span class="s1">&quot;unshiftContainer&quot;</span><span class="s0">,</span><span class="s1">&quot;registerDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;importSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;importDeclaration&quot;</span><span class="s0">,</span><span class="s1">&quot;import&quot;</span><span class="s0">,</span><span class="s1">&quot;importNamespace&quot;</span><span class="s0">,</span><span class="s1">&quot;importNamespaceSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;importDefaultSpecifier&quot;</span><span class="s0">,</span><span class="s1">&quot;stringLiteral&quot;</span><span class="s0">,</span><span class="s1">&quot;module&quot;</span><span class="s0">,</span><span class="s1">&quot;specifier&quot;</span><span class="s0">,</span><span class="s1">&quot;registerBinding&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;+BAOA;;;eAAA;;;wEAFgB;;;;;;AAED,SAAf,SAAyB,EACvBA,OAAOC,CAAC,EAGT;IACC,OAAO;QACLC,UAAUC,wBAAG;QACbC,SAAS;YACPC,YAAWC,KAAK,EAAEC,KAAK;gBACrBA,MAAMC,GAAG,CAAC,OAAO;YACnB;YAEA,qEAAqE;YACrE,sCAAsC;YACtCC,aAAYH,KAAK,EAAEC,KAAK;gBACtBA,MAAMC,GAAG,CAAC,OAAO;YACnB;YAEAE,SAAS;gBACPC,MAAKC,IAAkC,EAAEL,KAAK;oBAC5C,IAAIA,MAAMM,GAAG,CAAC,QAAQ;wBACpB,MAAMC,SAASb,EAAEc,UAAU,CAACR,MAAMS,IAAI,CAACF,MAAM;wBAC7C,IAAIG,WAAWH;wBAEf,4EAA4E;wBAC5E,MAAMI,kBACJX,MAAMS,IAAI,CAACG,WAAW,KAAK,SAC3BZ,MAAMS,IAAI,CAACC,QAAQ,IACnBL,KAAKQ,KAAK,CAACC,UAAU,CAACd,MAAMS,IAAI,CAACC,QAAQ;wBAE3C,oCAAoC;wBACpC,IAAIV,MAAMS,IAAI,CAACM,QAAQ,EAAE;4BACvB,IAAIf,MAAMS,IAAI,CAACC,QAAQ,EAAE;gCACvBA,WAAWhB,EAAEc,UAAU,CAACR,MAAMS,IAAI,CAACC,QAAQ;4BAC7C,OAAO;gCACLA,WAAWL,KAAKQ,KAAK,CAACG,qBAAqB,CAAC;4BAC9C;4BAEA,MAAMC,UAAUvB,EAAEwB,mBAAmB,CAAC,OAAO;gCAC3CxB,EAAEyB,kBAAkB,CAClBZ,QACAb,EAAE0B,gBAAgB,CAChBV,UACAhB,EAAEc,UAAU,CAACR,MAAMS,IAAI,CAACM,QAAQ;6BAGrC;4BAED,qDAAqD;4BACrD,2CAA2C;4BAC3C,IAAIM;4BAEJ,IACEV,mBACAjB,EAAE4B,oBAAoB,CAACX,gBAAgBN,IAAI,CAACkB,IAAI,KAChD7B,EAAE8B,gBAAgB,CAACb,gBAAgBN,IAAI,CAACkB,IAAI,CAACE,IAAI,KACjD/B,EAAEgC,YAAY,CAACf,gBAAgBN,IAAI,CAACkB,IAAI,CAACE,IAAI,CAACE,MAAM,KACpDhB,gBAAgBN,IAAI,CAACkB,IAAI,CAACE,IAAI,CAACE,MAAM,CAACC,IAAI,KAAK,WAC/C;;gCACC,CAACP,QAAQ,GACRV,gBAAgBN,IAAI,CAACwB,UAAU,CAACC,WAAW,CAACb;4BAChD,OAAO;;gCACJ,CAACI,QAAQ,GAAGhB,KAAK0B,gBAAgB,CAAC,QAAQd;4BAC7C;4BAEAZ,KAAKQ,KAAK,CAACmB,mBAAmB,CAACX;wBACjC;wBAEA,IAAI,CAACV,iBAAiB;4BACpB,MAAMsB,kBAAkBvC,EAAEwC,iBAAiB,CACzC;gCACElC,MAAMS,IAAI,CAAC0B,MAAM,GAEbzC,EAAEuC,eAAe,CACfvB,UACAhB,EAAEc,UAAU,CAACR,MAAMS,IAAI,CAAC0B,MAAM,KAEhCnC,MAAMS,IAAI,CAAC2B,eAAe,GACxB1C,EAAE2C,wBAAwB,CAAC3B,YAE3BhB,EAAE4C,sBAAsB,CAAC5B;6BAChC,EACDhB,EAAE6C,aAAa,CAACvC,MAAMS,IAAI,CAAC+B,MAAM,IAAI;4BAGvC,MAAM,CAACnB,QAAQ,GAAGhB,KAAK0B,gBAAgB,CAAC,QAAQE;4BAChD,KAAK,MAAMQ,aAAapB,QAAQf,GAAG,CAAC,cAAe;gCACjDD,KAAKQ,KAAK,CAAC6B,eAAe,CACxB,UACAD;4BAEJ;wBACF;oBACF;gBACF;YACF;QACF;IACF;AACF&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>