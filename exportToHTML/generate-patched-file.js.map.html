<html>
<head>
<title>generate-patched-file.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
generate-patched-file.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;generate-patched-file.js&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/eslint-bulk-suppressions/generate-patched-file.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.</span><span class="s3">\n</span><span class="s1">// See LICENSE in the project root for license information.</span><span class="s3">\n\n</span><span class="s1">import fs from 'fs';</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">ESLINT_BULK_FORCE_REGENERATE_PATCH_ENV_VAR_NAME,</span><span class="s3">\n  </span><span class="s1">ESLINT_BULK_PATCH_PATH_ENV_VAR_NAME</span><span class="s3">\n</span><span class="s1">} from './constants';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Dynamically generate file to properly patch many versions of ESLint</span><span class="s3">\n </span><span class="s1">* @param inputFilePath - Must be an iteration of https://github.com/eslint/eslint/blob/main/lib/linter/linter.js</span><span class="s3">\n </span><span class="s1">* @param outputFilePath - Some small changes to linter.js</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function generatePatchedLinterJsFileIfDoesNotExist(</span><span class="s3">\n  </span><span class="s1">inputFilePath: string,</span><span class="s3">\n  </span><span class="s1">outputFilePath: string,</span><span class="s3">\n  </span><span class="s1">eslintPackageVersion: string</span><span class="s3">\n</span><span class="s1">): void {</span><span class="s3">\n  </span><span class="s1">const generateEnvVarValue: string | undefined =</span><span class="s3">\n    </span><span class="s1">process.env[ESLINT_BULK_FORCE_REGENERATE_PATCH_ENV_VAR_NAME];</span><span class="s3">\n  </span><span class="s1">if (generateEnvVarValue !== 'true' &amp;&amp; generateEnvVarValue !== '1' &amp;&amp; fs.existsSync(outputFilePath)) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const majorVersion: number = parseInt(eslintPackageVersion, 10);</span><span class="s3">\n\n  </span><span class="s1">const inputFile: string = fs.readFileSync(inputFilePath).toString();</span><span class="s3">\n\n  </span><span class="s1">let inputIndex: number = 0;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Extract from the stream until marker is reached.  When matching marker,</span><span class="s3">\n   </span><span class="s1">* ignore whitespace in the stream and in the marker.  Return the extracted text.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">function scanUntilMarker(marker: string): string {</span><span class="s3">\n    </span><span class="s1">const trimmedMarker: string = marker.replace(/</span><span class="s3">\\</span><span class="s1">s/g, '');</span><span class="s3">\n\n    </span><span class="s1">let output: string = '';</span><span class="s3">\n    </span><span class="s1">let trimmed: string = '';</span><span class="s3">\n\n    </span><span class="s1">while (inputIndex &lt; inputFile.length) {</span><span class="s3">\n      </span><span class="s1">const char: string = inputFile[inputIndex++];</span><span class="s3">\n      </span><span class="s1">output += char;</span><span class="s3">\n      </span><span class="s1">if (!/^</span><span class="s3">\\</span><span class="s1">s$/.test(char)) {</span><span class="s3">\n        </span><span class="s1">trimmed += char;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (trimmed.endsWith(trimmedMarker)) {</span><span class="s3">\n        </span><span class="s1">return output;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">throw new Error('Unexpected end of input while looking for ' + JSON.stringify(marker));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function scanUntilNewline(): string {</span><span class="s3">\n    </span><span class="s1">let output: string = '';</span><span class="s3">\n\n    </span><span class="s1">while (inputIndex &lt; inputFile.length) {</span><span class="s3">\n      </span><span class="s1">const char: string = inputFile[inputIndex++];</span><span class="s3">\n      </span><span class="s1">output += char;</span><span class="s3">\n      </span><span class="s1">if (char === '</span><span class="s3">\\</span><span class="s1">n') {</span><span class="s3">\n        </span><span class="s1">return output;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">throw new Error('Unexpected end of input while looking for new line');</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function scanUntilEnd(): string {</span><span class="s3">\n    </span><span class="s1">const output: string = inputFile.substring(inputIndex);</span><span class="s3">\n    </span><span class="s1">inputIndex = inputFile.length;</span><span class="s3">\n    </span><span class="s1">return output;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const markerForStartOfClassMethodSpaces: string = '</span><span class="s3">\\</span><span class="s1">n     */</span><span class="s3">\\</span><span class="s1">n    ';</span><span class="s3">\n  </span><span class="s1">const markerForStartOfClassMethodTabs: string = '</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">t */</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">t';</span><span class="s3">\n  </span><span class="s1">function indexOfStartOfClassMethod(input: string, position?: number): { index: number; marker?: string } {</span><span class="s3">\n    </span><span class="s1">let startOfClassMethodIndex: number = input.indexOf(markerForStartOfClassMethodSpaces, position);</span><span class="s3">\n    </span><span class="s1">if (startOfClassMethodIndex === -1) {</span><span class="s3">\n      </span><span class="s1">startOfClassMethodIndex = input.indexOf(markerForStartOfClassMethodTabs, position);</span><span class="s3">\n      </span><span class="s1">if (startOfClassMethodIndex === -1) {</span><span class="s3">\n        </span><span class="s1">return { index: startOfClassMethodIndex };</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return { index: startOfClassMethodIndex, marker: markerForStartOfClassMethodTabs };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return { index: startOfClassMethodIndex, marker: markerForStartOfClassMethodSpaces };</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns index of next public method</span><span class="s3">\n   </span><span class="s1">* @param fromIndex - index of inputFile to search if public method still exists</span><span class="s3">\n   </span><span class="s1">* @returns -1 if public method does not exist or index of next public method</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">function getIndexOfNextMethod(fromIndex: number): { index: number; isPublic?: boolean } {</span><span class="s3">\n    </span><span class="s1">const rest: string = inputFile.substring(fromIndex);</span><span class="s3">\n\n    </span><span class="s1">const endOfClassIndex: number = rest.indexOf('</span><span class="s3">\\</span><span class="s1">n}');</span><span class="s3">\n\n    </span><span class="s1">const { index: startOfClassMethodIndex, marker: startOfClassMethodMarker } =</span><span class="s3">\n      </span><span class="s1">indexOfStartOfClassMethod(rest);</span><span class="s3">\n\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">startOfClassMethodIndex === -1 ||</span><span class="s3">\n      </span><span class="s1">!startOfClassMethodMarker ||</span><span class="s3">\n      </span><span class="s1">startOfClassMethodIndex &gt; endOfClassIndex</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return { index: -1 };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const afterMarkerIndex: number = startOfClassMethodIndex + startOfClassMethodMarker.length;</span><span class="s3">\n\n    </span><span class="s1">const isPublicMethod: boolean =</span><span class="s3">\n      </span><span class="s1">rest[afterMarkerIndex] !== '_' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">rest[afterMarkerIndex] !== '#' &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!rest.substring(afterMarkerIndex, rest.indexOf('</span><span class="s3">\\</span><span class="s1">n', afterMarkerIndex)).includes('static') &amp;&amp;</span><span class="s3">\n      </span><span class="s1">!rest.substring(afterMarkerIndex, rest.indexOf('</span><span class="s3">\\</span><span class="s1">n', afterMarkerIndex)).includes('constructor');</span><span class="s3">\n\n    </span><span class="s1">return { index: fromIndex + afterMarkerIndex, isPublic: isPublicMethod };</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function scanUntilIndex(indexToScanTo: number): string {</span><span class="s3">\n    </span><span class="s1">const output: string = inputFile.substring(inputIndex, indexToScanTo);</span><span class="s3">\n    </span><span class="s1">inputIndex = indexToScanTo;</span><span class="s3">\n    </span><span class="s1">return output;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let outputFile: string = '';</span><span class="s3">\n\n  </span><span class="s1">// Match this:</span><span class="s3">\n  </span><span class="s1">//    //------------------------------------------------------------------------------</span><span class="s3">\n  </span><span class="s1">//    // Requirements</span><span class="s3">\n  </span><span class="s1">//    //------------------------------------------------------------------------------</span><span class="s3">\n  </span><span class="s1">outputFile += scanUntilMarker('// Requirements');</span><span class="s3">\n  </span><span class="s1">outputFile += scanUntilMarker('//--');</span><span class="s3">\n  </span><span class="s1">outputFile += scanUntilNewline();</span><span class="s3">\n\n  </span><span class="s1">outputFile += `</span><span class="s3">\n</span><span class="s1">// --- BEGIN MONKEY PATCH ---</span><span class="s3">\n</span><span class="s1">const bulkSuppressionsPatch = require(process.env.${ESLINT_BULK_PATCH_PATH_ENV_VAR_NAME});</span><span class="s3">\n</span><span class="s1">const requireFromPathToLinterJS = bulkSuppressionsPatch.requireFromPathToLinterJS;</span><span class="s3">\n</span><span class="s1">`;</span><span class="s3">\n\n  </span><span class="s1">// Match this:</span><span class="s3">\n  </span><span class="s1">//    //------------------------------------------------------------------------------</span><span class="s3">\n  </span><span class="s1">//    // Typedefs</span><span class="s3">\n  </span><span class="s1">//    //------------------------------------------------------------------------------</span><span class="s3">\n  </span><span class="s1">const requireSection: string = scanUntilMarker('// Typedefs');</span><span class="s3">\n\n  </span><span class="s1">// Match something like this:</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">//    const path = require('path'),</span><span class="s3">\n  </span><span class="s1">//    eslintScope = require('eslint-scope'),</span><span class="s3">\n  </span><span class="s1">//    evk = require('eslint-visitor-keys'),</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// Convert to something like this:</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">//    const path = require('path'),</span><span class="s3">\n  </span><span class="s1">//    eslintScope = requireFromPathToLinterJS('eslint-scope'),</span><span class="s3">\n  </span><span class="s1">//    evk = requireFromPathToLinterJS('eslint-visitor-keys'),</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">outputFile += requireSection.replace(/require</span><span class="s3">\\</span><span class="s1">s*</span><span class="s3">\\</span><span class="s1">((?:'([^']+)'|</span><span class="s3">\&quot;</span><span class="s1">([^</span><span class="s3">\&quot;</span><span class="s1">]+)</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\\</span><span class="s1">)/g, (match, p1, p2) =&gt; {</span><span class="s3">\n    </span><span class="s1">const importPath: string = p1 ?? p2 ?? '';</span><span class="s3">\n\n    </span><span class="s1">if (importPath !== 'path') {</span><span class="s3">\n      </span><span class="s1">if (p1) {</span><span class="s3">\n        </span><span class="s1">return `requireFromPathToLinterJS('${p1}')`;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (p2) {</span><span class="s3">\n        </span><span class="s1">return `requireFromPathToLinterJS(</span><span class="s3">\&quot;</span><span class="s1">${p2}</span><span class="s3">\&quot;</span><span class="s1">)`;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Keep as-is</span><span class="s3">\n    </span><span class="s1">return match;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">outputFile += `--- END MONKEY PATCH ---</span><span class="s3">\n</span><span class="s1">`;</span><span class="s3">\n\n  </span><span class="s1">if (majorVersion &gt;= 9) {</span><span class="s3">\n    </span><span class="s1">outputFile += scanUntilMarker('const emitter = createEmitter();');</span><span class="s3">\n    </span><span class="s1">outputFile += `</span><span class="s3">\n      </span><span class="s1">// --- BEGIN MONKEY PATCH ---</span><span class="s3">\n      </span><span class="s1">let currentNode = undefined;</span><span class="s3">\n      </span><span class="s1">// --- END MONKEY PATCH ---`;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Match this:</span><span class="s3">\n  </span><span class="s1">// ```</span><span class="s3">\n  </span><span class="s1">//      if (reportTranslator === null) {</span><span class="s3">\n  </span><span class="s1">//        reportTranslator = createReportTranslator({</span><span class="s3">\n  </span><span class="s1">//            ruleId,</span><span class="s3">\n  </span><span class="s1">//            severity,</span><span class="s3">\n  </span><span class="s1">//            sourceCode,</span><span class="s3">\n  </span><span class="s1">//            messageIds,</span><span class="s3">\n  </span><span class="s1">//            disableFixes</span><span class="s3">\n  </span><span class="s1">//        });</span><span class="s3">\n  </span><span class="s1">//    }</span><span class="s3">\n  </span><span class="s1">//    const problem = reportTranslator(...args);</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">//    if (problem.fix &amp;&amp; !(rule.meta &amp;&amp; rule.meta.fixable)) {</span><span class="s3">\n  </span><span class="s1">//        throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Fixable rules must set the `meta.fixable` property to </span><span class="s3">\\\&quot;</span><span class="s1">code</span><span class="s3">\\\&quot; </span><span class="s1">or </span><span class="s3">\\\&quot;</span><span class="s1">whitespace</span><span class="s3">\\\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">//    }</span><span class="s3">\n  </span><span class="s1">// ```</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// Convert to something like this:</span><span class="s3">\n  </span><span class="s1">// ```</span><span class="s3">\n  </span><span class="s1">//      if (reportTranslator === null) {</span><span class="s3">\n  </span><span class="s1">//        reportTranslator = createReportTranslator({</span><span class="s3">\n  </span><span class="s1">//            ruleId,</span><span class="s3">\n  </span><span class="s1">//            severity,</span><span class="s3">\n  </span><span class="s1">//            sourceCode,</span><span class="s3">\n  </span><span class="s1">//            messageIds,</span><span class="s3">\n  </span><span class="s1">//            disableFixes</span><span class="s3">\n  </span><span class="s1">//        });</span><span class="s3">\n  </span><span class="s1">//    }</span><span class="s3">\n  </span><span class="s1">//    const problem = reportTranslator(...args);</span><span class="s3">\n  </span><span class="s1">//    // --- BEGIN MONKEY PATCH ---</span><span class="s3">\n  </span><span class="s1">//    if (bulkSuppressionsPatch.shouldBulkSuppress({ filename, currentNode: args[0]?.node ?? currentNode, ruleId, problem })) return;</span><span class="s3">\n  </span><span class="s1">//    // --- END MONKEY PATCH ---</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">//    if (problem.fix &amp;&amp; !(rule.meta &amp;&amp; rule.meta.fixable)) {</span><span class="s3">\n  </span><span class="s1">//        throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Fixable rules must set the `meta.fixable` property to </span><span class="s3">\\\&quot;</span><span class="s1">code</span><span class="s3">\\\&quot; </span><span class="s1">or </span><span class="s3">\\\&quot;</span><span class="s1">whitespace</span><span class="s3">\\\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">//    }</span><span class="s3">\n  </span><span class="s1">// ```</span><span class="s3">\n  </span><span class="s1">outputFile += scanUntilMarker('const problem = reportTranslator(...args);');</span><span class="s3">\n  </span><span class="s1">outputFile += `</span><span class="s3">\n    </span><span class="s1">// --- BEGIN MONKEY PATCH ---</span><span class="s3">\n    </span><span class="s1">if (bulkSuppressionsPatch.shouldBulkSuppress({ filename, currentNode: args[0]?.node ?? currentNode, ruleId, problem })) return;</span><span class="s3">\n    </span><span class="s1">// --- END MONKEY PATCH ---`;</span><span class="s3">\n\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// Match this:</span><span class="s3">\n  </span><span class="s1">// ```</span><span class="s3">\n  </span><span class="s1">//    Object.keys(ruleListeners).forEach(selector =&gt; {</span><span class="s3">\n  </span><span class="s1">//      ...</span><span class="s3">\n  </span><span class="s1">//    });</span><span class="s3">\n  </span><span class="s1">// ```</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// Convert to something like this:</span><span class="s3">\n  </span><span class="s1">// ```</span><span class="s3">\n  </span><span class="s1">//    Object.keys(ruleListeners).forEach(selector =&gt; {</span><span class="s3">\n  </span><span class="s1">//      // --- BEGIN MONKEY PATCH ---</span><span class="s3">\n  </span><span class="s1">//      emitter.on(selector, (...args) =&gt; { currentNode = args[args.length - 1]; });</span><span class="s3">\n  </span><span class="s1">//      // --- END MONKEY PATCH ---</span><span class="s3">\n  </span><span class="s1">//      ...</span><span class="s3">\n  </span><span class="s1">//    });</span><span class="s3">\n  </span><span class="s1">// ```</span><span class="s3">\n  </span><span class="s1">if (majorVersion &gt;= 9) {</span><span class="s3">\n    </span><span class="s1">outputFile += scanUntilMarker('Object.keys(ruleListeners).forEach(selector =&gt; {');</span><span class="s3">\n    </span><span class="s1">outputFile += `</span><span class="s3">\n      </span><span class="s1">// --- BEGIN MONKEY PATCH ---</span><span class="s3">\n      </span><span class="s1">emitter.on(selector, (...args) =&gt; { currentNode = args[args.length - 1]; });</span><span class="s3">\n      </span><span class="s1">// --- END MONKEY PATCH ---`;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">outputFile += scanUntilMarker('class Linter {');</span><span class="s3">\n  </span><span class="s1">outputFile += scanUntilNewline();</span><span class="s3">\n  </span><span class="s1">outputFile += `</span><span class="s3">\n    </span><span class="s1">// --- BEGIN MONKEY PATCH ---</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* We intercept ESLint execution at the .eslintrc.js file, but unfortunately the Linter class is</span><span class="s3">\n     </span><span class="s1">* initialized before the .eslintrc.js file is executed. This means the internalSlotsMap that all</span><span class="s3">\n     </span><span class="s1">* the patched methods refer to is not initialized. This method checks if the internalSlotsMap is</span><span class="s3">\n     </span><span class="s1">* initialized, and if not, initializes it.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_conditionallyReinitialize({ cwd, configType } = {}) {</span><span class="s3">\n        </span><span class="s1">if (internalSlotsMap.get(this) === undefined) {</span><span class="s3">\n            </span><span class="s1">internalSlotsMap.set(this, {</span><span class="s3">\n              </span><span class="s1">cwd: normalizeCwd(cwd),</span><span class="s3">\n              </span><span class="s1">lastConfigArray: null,</span><span class="s3">\n              </span><span class="s1">lastSourceCode: null,</span><span class="s3">\n              </span><span class="s1">lastSuppressedMessages: [],</span><span class="s3">\n              </span><span class="s1">configType, // TODO: Remove after flat config conversion</span><span class="s3">\n              </span><span class="s1">parserMap: new Map([['espree', espree]]),</span><span class="s3">\n              </span><span class="s1">ruleMap: new Rules()</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n\n            </span><span class="s1">this.version = pkg.version;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// --- END MONKEY PATCH ---</span><span class="s3">\n</span><span class="s1">`;</span><span class="s3">\n\n  </span><span class="s1">const privateMethodNames: string[] = [];</span><span class="s3">\n  </span><span class="s1">let { index: indexOfNextMethod, isPublic } = getIndexOfNextMethod(inputIndex);</span><span class="s3">\n\n  </span><span class="s1">while (indexOfNextMethod !== -1) {</span><span class="s3">\n    </span><span class="s1">outputFile += scanUntilIndex(indexOfNextMethod);</span><span class="s3">\n    </span><span class="s1">if (isPublic) {</span><span class="s3">\n      </span><span class="s1">// Inject the monkey patch at the start of the public method</span><span class="s3">\n      </span><span class="s1">outputFile += scanUntilNewline();</span><span class="s3">\n      </span><span class="s1">outputFile += `        // --- BEGIN MONKEY PATCH ---</span><span class="s3">\n        </span><span class="s1">this._conditionallyReinitialize();</span><span class="s3">\n        </span><span class="s1">// --- END MONKEY PATCH ---</span><span class="s3">\n</span><span class="s1">`;</span><span class="s3">\n    </span><span class="s1">} else if (inputFile[inputIndex] === '#') {</span><span class="s3">\n      </span><span class="s1">// Replace the '#' private method with a '_' private method, so that our monkey patch</span><span class="s3">\n      </span><span class="s1">// can still call it. Otherwise, we get the following error during execution:</span><span class="s3">\n      </span><span class="s1">// TypeError: Receiver must be an instance of class Linter</span><span class="s3">\n      </span><span class="s1">const privateMethodName: string = scanUntilMarker('(');</span><span class="s3">\n      </span><span class="s1">// Remove the '(' at the end and stash it, since we need to escape it for the regex later</span><span class="s3">\n      </span><span class="s1">privateMethodNames.push(privateMethodName.slice(0, -1));</span><span class="s3">\n      </span><span class="s1">outputFile += `_${privateMethodName.slice(1)}`;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const indexResult: { index: number; isPublic?: boolean } = getIndexOfNextMethod(inputIndex);</span><span class="s3">\n    </span><span class="s1">indexOfNextMethod = indexResult.index;</span><span class="s3">\n    </span><span class="s1">isPublic = indexResult.isPublic;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">outputFile += scanUntilEnd();</span><span class="s3">\n\n  </span><span class="s1">// Do a second pass to find and replace all calls to private methods with the patched versions.</span><span class="s3">\n  </span><span class="s1">if (privateMethodNames.length) {</span><span class="s3">\n    </span><span class="s1">// eslint-disable-next-line @rushstack/security/no-unsafe-regexp</span><span class="s3">\n    </span><span class="s1">const privateMethodCallRegex: RegExp = new RegExp(`</span><span class="s3">\\</span><span class="s1">.(${privateMethodNames.join('|')})</span><span class="s3">\\\\</span><span class="s1">(`, 'g');</span><span class="s3">\n    </span><span class="s1">outputFile = outputFile.replace(privateMethodCallRegex, (match, privateMethodName) =&gt; {</span><span class="s3">\n      </span><span class="s1">// Replace the leading '#' with a leading '_'</span><span class="s3">\n      </span><span class="s1">return `._${privateMethodName.slice(1)}(`;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">fs.writeFileSync(outputFilePath, outputFile);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">]}</span></pre>
</body>
</html>