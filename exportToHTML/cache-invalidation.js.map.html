<html>
<head>
<title>cache-invalidation.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
cache-invalidation.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/build/webpack/cache-invalidation.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import fs from 'node:fs/promises'</span><span class="s3">\n</span><span class="s1">import path from 'node:path'</span><span class="s3">\n\n</span><span class="s1">const INVALIDATION_MARKER = '__nextjs_invalidated_cache'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Atomically write an invalidation marker.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Because attempting to delete currently open cache files could cause issues,</span><span class="s3">\n </span><span class="s1">* actual deletion of files is deferred until the next start-up (in</span><span class="s3">\n </span><span class="s1">* `checkPersistentCacheInvalidationAndCleanup`).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* In the case that no database is currently open (e.g. via a separate CLI</span><span class="s3">\n </span><span class="s1">* subcommand), you should call `cleanupPersistentCache` *after* this to eagerly</span><span class="s3">\n </span><span class="s1">* remove the cache files.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export async function invalidatePersistentCache(cacheDirectory: string) {</span><span class="s3">\n  </span><span class="s1">let file</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">// We're just opening it so that `open()` creates the file.</span><span class="s3">\n    </span><span class="s1">file = await fs.open(path.join(cacheDirectory, INVALIDATION_MARKER), 'w')</span><span class="s3">\n    </span><span class="s1">// We don't currently write anything to the file, but we could choose to</span><span class="s3">\n    </span><span class="s1">// later, e.g. a reason for the invalidation.</span><span class="s3">\n  </span><span class="s1">} catch (err: any) {</span><span class="s3">\n    </span><span class="s1">// it's valid for the cache to not exist at all</span><span class="s3">\n    </span><span class="s1">if (err.code !== 'ENOENT') {</span><span class="s3">\n      </span><span class="s1">throw err</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} finally {</span><span class="s3">\n    </span><span class="s1">file?.close()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Called during startup. See if the cache is in a partially-completed</span><span class="s3">\n </span><span class="s1">* invalidation state. Finds and delete any invalidated cache files.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export async function checkPersistentCacheInvalidationAndCleanup(</span><span class="s3">\n  </span><span class="s1">cacheDirectory: string</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const invalidated = await fs</span><span class="s3">\n    </span><span class="s1">.access(path.join(cacheDirectory, INVALIDATION_MARKER))</span><span class="s3">\n    </span><span class="s1">.then(</span><span class="s3">\n      </span><span class="s1">() =&gt; true,</span><span class="s3">\n      </span><span class="s1">() =&gt; false</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">if (invalidated) {</span><span class="s3">\n    </span><span class="s1">await cleanupPersistentCache(cacheDirectory)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Helper for `checkPersistentCacheInvalidationAndCleanup`. You can call this to</span><span class="s3">\n </span><span class="s1">* explicitly clean up a database after running `invalidatePersistentCache` when</span><span class="s3">\n </span><span class="s1">* webpack is not running.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* You should not run this if the cache has not yet been invalidated, as this</span><span class="s3">\n </span><span class="s1">* operation is not atomic and could result in a partially-deleted and corrupted</span><span class="s3">\n </span><span class="s1">* database.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">async function cleanupPersistentCache(cacheDirectory: string) {</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">await cleanupPersistentCacheInner(cacheDirectory)</span><span class="s3">\n  </span><span class="s1">} catch (e) {</span><span class="s3">\n    </span><span class="s1">// generate a user-friendly error message</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`Unable to remove an invalidated webpack cache. If this issue persists ` +</span><span class="s3">\n        </span><span class="s1">`you can work around it by deleting ${cacheDirectory}`,</span><span class="s3">\n      </span><span class="s1">{ cause: e }</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">async function cleanupPersistentCacheInner(cacheDirectory: string) {</span><span class="s3">\n  </span><span class="s1">const files = await fs.readdir(cacheDirectory)</span><span class="s3">\n\n  </span><span class="s1">// delete everything except the invalidation marker</span><span class="s3">\n  </span><span class="s1">await Promise.all(</span><span class="s3">\n    </span><span class="s1">files.map((name) =&gt;</span><span class="s3">\n      </span><span class="s1">name !== INVALIDATION_MARKER</span><span class="s3">\n        </span><span class="s1">? fs.rm(path.join(cacheDirectory, name), {</span><span class="s3">\n            </span><span class="s1">force: true, // ignore errors if path does not exist</span><span class="s3">\n            </span><span class="s1">recursive: true,</span><span class="s3">\n            </span><span class="s1">maxRetries: 2, // windows prevents deletion of open files</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">: null</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">// delete the invalidation marker last, once we're sure everything is cleaned</span><span class="s3">\n  </span><span class="s1">// up</span><span class="s3">\n  </span><span class="s1">await fs.rm(path.join(cacheDirectory, INVALIDATION_MARKER), {</span><span class="s3">\n    </span><span class="s1">force: true,</span><span class="s3">\n    </span><span class="s1">maxRetries: 2,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;checkPersistentCacheInvalidationAndCleanup&quot;</span><span class="s0">,</span><span class="s1">&quot;invalidatePersistentCache&quot;</span><span class="s0">,</span><span class="s1">&quot;INVALIDATION_MARKER&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheDirectory&quot;</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">,</span><span class="s1">&quot;fs&quot;</span><span class="s0">,</span><span class="s1">&quot;open&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;code&quot;</span><span class="s0">,</span><span class="s1">&quot;close&quot;</span><span class="s0">,</span><span class="s1">&quot;invalidated&quot;</span><span class="s0">,</span><span class="s1">&quot;access&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;cleanupPersistentCache&quot;</span><span class="s0">,</span><span class="s1">&quot;cleanupPersistentCacheInner&quot;</span><span class="s0">,</span><span class="s1">&quot;e&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;cause&quot;</span><span class="s0">,</span><span class="s1">&quot;files&quot;</span><span class="s0">,</span><span class="s1">&quot;readdir&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;all&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;rm&quot;</span><span class="s0">,</span><span class="s1">&quot;force&quot;</span><span class="s0">,</span><span class="s1">&quot;recursive&quot;</span><span class="s0">,</span><span class="s1">&quot;maxRetries&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;IAqCsBA,0CAA0C;eAA1CA;;IArBAC,yBAAyB;eAAzBA;;;iEAhBP;iEACE;;;;;;AAEjB,MAAMC,sBAAsB;AAarB,eAAeD,0BAA0BE,cAAsB;IACpE,IAAIC;IACJ,IAAI;QACF,2DAA2D;QAC3DA,OAAO,MAAMC,iBAAE,CAACC,IAAI,CAACC,iBAAI,CAACC,IAAI,CAACL,gBAAgBD,sBAAsB;IACrE,wEAAwE;IACxE,6CAA6C;IAC/C,EAAE,OAAOO,KAAU;QACjB,+CAA+C;QAC/C,IAAIA,IAAIC,IAAI,KAAK,UAAU;YACzB,MAAMD;QACR;IACF,SAAU;QACRL,wBAAAA,KAAMO,KAAK;IACb;AACF;AAMO,eAAeX,2CACpBG,cAAsB;IAEtB,MAAMS,cAAc,MAAMP,iBAAE,CACzBQ,MAAM,CAACN,iBAAI,CAACC,IAAI,CAACL,gBAAgBD,sBACjCY,IAAI,CACH,IAAM,MACN,IAAM;IAEV,IAAIF,aAAa;QACf,MAAMG,uBAAuBZ;IAC/B;AACF;AAEA;;;;;;;;CAQC,GACD,eAAeY,uBAAuBZ,cAAsB;IAC1D,IAAI;QACF,MAAMa,4BAA4Bb;IACpC,EAAE,OAAOc,GAAG;QACV,yCAAyC;QACzC,MAAM,qBAIL,CAJK,IAAIC,MACR,CAAC,sEAAsE,CAAC,GACtE,CAAC,mCAAmC,EAAEf,gBAAgB,EACxD;YAAEgB,OAAOF;QAAE,IAHP,qBAAA;mBAAA;wBAAA;0BAAA;QAIN;IACF;AACF;AAEA,eAAeD,4BAA4Bb,cAAsB;IAC/D,MAAMiB,QAAQ,MAAMf,iBAAE,CAACgB,OAAO,CAAClB;IAE/B,mDAAmD;IACnD,MAAMmB,QAAQC,GAAG,CACfH,MAAMI,GAAG,CAAC,CAACC,OACTA,SAASvB,sBACLG,iBAAE,CAACqB,EAAE,CAACnB,iBAAI,CAACC,IAAI,CAACL,gBAAgBsB,OAAO;YACrCE,OAAO;YACPC,WAAW;YACXC,YAAY;QACd,KACA;IAIR,6EAA6E;IAC7E,KAAK;IACL,MAAMxB,iBAAE,CAACqB,EAAE,CAACnB,iBAAI,CAACC,IAAI,CAACL,gBAAgBD,sBAAsB;QAC1DyB,OAAO;QACPE,YAAY;IACd;AACF&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>