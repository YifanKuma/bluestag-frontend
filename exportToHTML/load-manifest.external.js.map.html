<html>
<head>
<title>load-manifest.external.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
load-manifest.external.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../src/server/load-manifest.external.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { DeepReadonly } from '../shared/lib/deep-readonly'</span><span class="s3">\n\n</span><span class="s1">import { join } from 'path'</span><span class="s3">\n</span><span class="s1">import { readFileSync } from 'fs'</span><span class="s3">\n</span><span class="s1">import { runInNewContext } from 'vm'</span><span class="s3">\n</span><span class="s1">import { deepFreeze } from '../shared/lib/deep-freeze'</span><span class="s3">\n\n</span><span class="s1">const sharedCache = new Map&lt;string, unknown&gt;()</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Load a manifest file from the file system. Optionally cache the manifest in</span><span class="s3">\n </span><span class="s1">* memory to avoid reading the file multiple times using the provided cache or</span><span class="s3">\n </span><span class="s1">* defaulting to a shared module cache. The manifest is frozen to prevent</span><span class="s3">\n </span><span class="s1">* modifications if it is cached.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param path the path to the manifest file</span><span class="s3">\n </span><span class="s1">* @param shouldCache whether to cache the manifest in memory</span><span class="s3">\n </span><span class="s1">* @param cache the cache to use for storing the manifest</span><span class="s3">\n </span><span class="s1">* @returns the manifest object</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function loadManifest&lt;T extends object&gt;(</span><span class="s3">\n  </span><span class="s1">path: string,</span><span class="s3">\n  </span><span class="s1">shouldCache: false</span><span class="s3">\n</span><span class="s1">): T</span><span class="s3">\n</span><span class="s1">export function loadManifest&lt;T extends object&gt;(</span><span class="s3">\n  </span><span class="s1">path: string,</span><span class="s3">\n  </span><span class="s1">shouldCache?: boolean,</span><span class="s3">\n  </span><span class="s1">cache?: Map&lt;string, unknown&gt;,</span><span class="s3">\n  </span><span class="s1">skipParse?: boolean</span><span class="s3">\n</span><span class="s1">): DeepReadonly&lt;T&gt;</span><span class="s3">\n</span><span class="s1">export function loadManifest&lt;T extends object&gt;(</span><span class="s3">\n  </span><span class="s1">path: string,</span><span class="s3">\n  </span><span class="s1">shouldCache?: true,</span><span class="s3">\n  </span><span class="s1">cache?: Map&lt;string, unknown&gt;,</span><span class="s3">\n  </span><span class="s1">skipParse?: boolean</span><span class="s3">\n</span><span class="s1">): DeepReadonly&lt;T&gt;</span><span class="s3">\n</span><span class="s1">export function loadManifest&lt;T extends object&gt;(</span><span class="s3">\n  </span><span class="s1">path: string,</span><span class="s3">\n  </span><span class="s1">shouldCache: boolean = true,</span><span class="s3">\n  </span><span class="s1">cache = sharedCache,</span><span class="s3">\n  </span><span class="s1">skipParse = false</span><span class="s3">\n</span><span class="s1">): T {</span><span class="s3">\n  </span><span class="s1">const cached = shouldCache &amp;&amp; cache.get(path)</span><span class="s3">\n  </span><span class="s1">if (cached) {</span><span class="s3">\n    </span><span class="s1">return cached as T</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let manifest: any = readFileSync(/* turbopackIgnore: true */ path, 'utf8')</span><span class="s3">\n\n  </span><span class="s1">if (!skipParse) {</span><span class="s3">\n    </span><span class="s1">manifest = JSON.parse(manifest)</span><span class="s3">\n\n    </span><span class="s1">// Freeze the manifest so it cannot be modified if we're caching it.</span><span class="s3">\n    </span><span class="s1">if (shouldCache) {</span><span class="s3">\n      </span><span class="s1">manifest = deepFreeze(manifest)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (shouldCache) {</span><span class="s3">\n    </span><span class="s1">cache.set(path, manifest)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return manifest</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function evalManifest&lt;T extends object&gt;(</span><span class="s3">\n  </span><span class="s1">path: string,</span><span class="s3">\n  </span><span class="s1">shouldCache: false</span><span class="s3">\n</span><span class="s1">): T</span><span class="s3">\n</span><span class="s1">export function evalManifest&lt;T extends object&gt;(</span><span class="s3">\n  </span><span class="s1">path: string,</span><span class="s3">\n  </span><span class="s1">shouldCache?: boolean,</span><span class="s3">\n  </span><span class="s1">cache?: Map&lt;string, unknown&gt;</span><span class="s3">\n</span><span class="s1">): DeepReadonly&lt;T&gt;</span><span class="s3">\n</span><span class="s1">export function evalManifest&lt;T extends object&gt;(</span><span class="s3">\n  </span><span class="s1">path: string,</span><span class="s3">\n  </span><span class="s1">shouldCache?: true,</span><span class="s3">\n  </span><span class="s1">cache?: Map&lt;string, unknown&gt;</span><span class="s3">\n</span><span class="s1">): DeepReadonly&lt;T&gt;</span><span class="s3">\n</span><span class="s1">export function evalManifest&lt;T extends object&gt;(</span><span class="s3">\n  </span><span class="s1">path: string,</span><span class="s3">\n  </span><span class="s1">shouldCache: boolean = true,</span><span class="s3">\n  </span><span class="s1">cache = sharedCache</span><span class="s3">\n</span><span class="s1">): T {</span><span class="s3">\n  </span><span class="s1">const cached = shouldCache &amp;&amp; cache.get(path)</span><span class="s3">\n  </span><span class="s1">if (cached) {</span><span class="s3">\n    </span><span class="s1">return cached as T</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const content = readFileSync(/* turbopackIgnore: true */ path, 'utf8')</span><span class="s3">\n  </span><span class="s1">if (content.length === 0) {</span><span class="s3">\n    </span><span class="s1">throw new Error('Manifest file is empty')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let contextObject = {}</span><span class="s3">\n  </span><span class="s1">runInNewContext(content, contextObject)</span><span class="s3">\n\n  </span><span class="s1">// Freeze the context object so it cannot be modified if we're caching it.</span><span class="s3">\n  </span><span class="s1">if (shouldCache) {</span><span class="s3">\n    </span><span class="s1">contextObject = deepFreeze(contextObject)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (shouldCache) {</span><span class="s3">\n    </span><span class="s1">cache.set(path, contextObject)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return contextObject as T</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function loadManifestFromRelativePath&lt;T extends object&gt;({</span><span class="s3">\n  </span><span class="s1">projectDir,</span><span class="s3">\n  </span><span class="s1">distDir,</span><span class="s3">\n  </span><span class="s1">manifest,</span><span class="s3">\n  </span><span class="s1">shouldCache,</span><span class="s3">\n  </span><span class="s1">cache,</span><span class="s3">\n  </span><span class="s1">skipParse,</span><span class="s3">\n  </span><span class="s1">handleMissing,</span><span class="s3">\n  </span><span class="s1">useEval,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">projectDir: string</span><span class="s3">\n  </span><span class="s1">distDir: string</span><span class="s3">\n  </span><span class="s1">manifest: string</span><span class="s3">\n  </span><span class="s1">shouldCache?: boolean</span><span class="s3">\n  </span><span class="s1">cache?: Map&lt;string, unknown&gt;</span><span class="s3">\n  </span><span class="s1">skipParse?: boolean</span><span class="s3">\n  </span><span class="s1">handleMissing?: boolean</span><span class="s3">\n  </span><span class="s1">useEval?: boolean</span><span class="s3">\n</span><span class="s1">}): DeepReadonly&lt;T&gt; {</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">const manifestPath = join(</span><span class="s3">\n      </span><span class="s1">/* turbopackIgnore: true */ projectDir,</span><span class="s3">\n      </span><span class="s1">distDir,</span><span class="s3">\n      </span><span class="s1">manifest</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">if (useEval) {</span><span class="s3">\n      </span><span class="s1">return evalManifest&lt;T&gt;(manifestPath, shouldCache, cache)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return loadManifest&lt;T&gt;(manifestPath, shouldCache, cache, skipParse)</span><span class="s3">\n  </span><span class="s1">} catch (err) {</span><span class="s3">\n    </span><span class="s1">if (handleMissing) {</span><span class="s3">\n      </span><span class="s1">// TODO: should this be undefined</span><span class="s3">\n      </span><span class="s1">return {} as DeepReadonly&lt;T&gt;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">throw err</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function clearManifestCache(path: string, cache = sharedCache): boolean {</span><span class="s3">\n  </span><span class="s1">return cache.delete(path)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;clearManifestCache&quot;</span><span class="s0">,</span><span class="s1">&quot;evalManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;loadManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;loadManifestFromRelativePath&quot;</span><span class="s0">,</span><span class="s1">&quot;sharedCache&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldCache&quot;</span><span class="s0">,</span><span class="s1">&quot;cache&quot;</span><span class="s0">,</span><span class="s1">&quot;skipParse&quot;</span><span class="s0">,</span><span class="s1">&quot;cached&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;manifest&quot;</span><span class="s0">,</span><span class="s1">&quot;readFileSync&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON&quot;</span><span class="s0">,</span><span class="s1">&quot;parse&quot;</span><span class="s0">,</span><span class="s1">&quot;deepFreeze&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;content&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;contextObject&quot;</span><span class="s0">,</span><span class="s1">&quot;runInNewContext&quot;</span><span class="s0">,</span><span class="s1">&quot;projectDir&quot;</span><span class="s0">,</span><span class="s1">&quot;distDir&quot;</span><span class="s0">,</span><span class="s1">&quot;handleMissing&quot;</span><span class="s0">,</span><span class="s1">&quot;useEval&quot;</span><span class="s0">,</span><span class="s1">&quot;manifestPath&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;;;IAoJgBA,kBAAkB;eAAlBA;;IArEAC,YAAY;eAAZA;;IA3CAC,YAAY;eAAZA;;IAyEAC,4BAA4B;eAA5BA;;;sBA3GK;oBACQ;oBACG;4BACL;AAE3B,MAAMC,cAAc,IAAIC;AA6BjB,SAASH,aACdI,IAAY,EACZC,cAAuB,IAAI,EAC3BC,QAAQJ,WAAW,EACnBK,YAAY,KAAK;IAEjB,MAAMC,SAASH,eAAeC,MAAMG,GAAG,CAACL;IACxC,IAAII,QAAQ;QACV,OAAOA;IACT;IAEA,IAAIE,WAAgBC,IAAAA,gBAAY,EAAC,yBAAyB,GAAGP,MAAM;IAEnE,IAAI,CAACG,WAAW;QACdG,WAAWE,KAAKC,KAAK,CAACH;QAEtB,oEAAoE;QACpE,IAAIL,aAAa;YACfK,WAAWI,IAAAA,sBAAU,EAACJ;QACxB;IACF;IAEA,IAAIL,aAAa;QACfC,MAAMS,GAAG,CAACX,MAAMM;IAClB;IAEA,OAAOA;AACT;AAgBO,SAASX,aACdK,IAAY,EACZC,cAAuB,IAAI,EAC3BC,QAAQJ,WAAW;IAEnB,MAAMM,SAASH,eAAeC,MAAMG,GAAG,CAACL;IACxC,IAAII,QAAQ;QACV,OAAOA;IACT;IAEA,MAAMQ,UAAUL,IAAAA,gBAAY,EAAC,yBAAyB,GAAGP,MAAM;IAC/D,IAAIY,QAAQC,MAAM,KAAK,GAAG;QACxB,MAAM,qBAAmC,CAAnC,IAAIC,MAAM,2BAAV,qBAAA;mBAAA;wBAAA;0BAAA;QAAkC;IAC1C;IAEA,IAAIC,gBAAgB,CAAC;IACrBC,IAAAA,mBAAe,EAACJ,SAASG;IAEzB,0EAA0E;IAC1E,IAAId,aAAa;QACfc,gBAAgBL,IAAAA,sBAAU,EAACK;IAC7B;IAEA,IAAId,aAAa;QACfC,MAAMS,GAAG,CAACX,MAAMe;IAClB;IAEA,OAAOA;AACT;AAEO,SAASlB,6BAA+C,EAC7DoB,UAAU,EACVC,OAAO,EACPZ,QAAQ,EACRL,WAAW,EACXC,KAAK,EACLC,SAAS,EACTgB,aAAa,EACbC,OAAO,EAUR;IACC,IAAI;QACF,MAAMC,eAAeC,IAAAA,UAAI,EACvB,yBAAyB,GAAGL,YAC5BC,SACAZ;QAGF,IAAIc,SAAS;YACX,OAAOzB,aAAgB0B,cAAcpB,aAAaC;QACpD;QACA,OAAON,aAAgByB,cAAcpB,aAAaC,OAAOC;IAC3D,EAAE,OAAOoB,KAAK;QACZ,IAAIJ,eAAe;YACjB,iCAAiC;YACjC,OAAO,CAAC;QACV;QACA,MAAMI;IACR;AACF;AAEO,SAAS7B,mBAAmBM,IAAY,EAAEE,QAAQJ,WAAW;IAClE,OAAOI,MAAMsB,MAAM,CAACxB;AACtB&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>