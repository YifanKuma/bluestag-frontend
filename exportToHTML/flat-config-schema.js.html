<html>
<head>
<title>flat-config-schema.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #8c8c8c; font-style: italic;}
.s2 { color: #080808;}
.s3 { color: #067d17;}
.s4 { color: #0033b3;}
.s5 { color: #1750eb;}
.s6 { color: #264eff;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
flat-config-schema.js</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@fileoverview </span><span class="s0">Flat config schema</span>
 <span class="s0">* </span><span class="s1">@author </span><span class="s0">Nicholas C. Zakas</span>
 <span class="s0">*/</span>

<span class="s3">&quot;use strict&quot;</span><span class="s2">;</span>

<span class="s0">//-----------------------------------------------------------------------------</span>
<span class="s0">// Requirements</span>
<span class="s0">//-----------------------------------------------------------------------------</span>

<span class="s4">const </span><span class="s2">{ normalizeSeverityToNumber } = require(</span><span class="s3">&quot;../shared/severity&quot;</span><span class="s2">);</span>

<span class="s0">//-----------------------------------------------------------------------------</span>
<span class="s0">// Type Definitions</span>
<span class="s0">//-----------------------------------------------------------------------------</span>

<span class="s0">/**</span>
 <span class="s0">* </span><span class="s1">@typedef </span><span class="s0">ObjectPropertySchema</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{Function|string} merge The function or name of the function to call</span>
 <span class="s0">*      to merge multiple objects with this property.</span>
 <span class="s0">* </span><span class="s1">@property </span><span class="s0">{Function|string} validate The function or name of the function to call</span>
 <span class="s0">*      to validate the value of this property.</span>
 <span class="s0">*/</span>

<span class="s0">//-----------------------------------------------------------------------------</span>
<span class="s0">// Helpers</span>
<span class="s0">//-----------------------------------------------------------------------------</span>

<span class="s4">const </span><span class="s2">ruleSeverities = </span><span class="s4">new </span><span class="s2">Map([</span>
	<span class="s2">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">],</span>
	<span class="s2">[</span><span class="s3">&quot;off&quot;</span><span class="s2">, </span><span class="s5">0</span><span class="s2">],</span>
	<span class="s2">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">],</span>
	<span class="s2">[</span><span class="s3">&quot;warn&quot;</span><span class="s2">, </span><span class="s5">1</span><span class="s2">],</span>
	<span class="s2">[</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">],</span>
	<span class="s2">[</span><span class="s3">&quot;error&quot;</span><span class="s2">, </span><span class="s5">2</span><span class="s2">],</span>
<span class="s2">]);</span>

<span class="s0">/**</span>
 <span class="s0">* Check if a value is a non-null object.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{any} value The value to check.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} `true` if the value is a non-null object.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">isNonNullObject(value) {</span>
	<span class="s4">return typeof </span><span class="s2">value === </span><span class="s3">&quot;object&quot; </span><span class="s2">&amp;&amp; value !== </span><span class="s4">null</span><span class="s2">;</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Check if a value is a non-null non-array object.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{any} value The value to check.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} `true` if the value is a non-null non-array object.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">isNonArrayObject(value) {</span>
	<span class="s4">return </span><span class="s2">isNonNullObject(value) &amp;&amp; !Array.isArray(value);</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Check if a value is undefined.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{any} value The value to check.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} `true` if the value is undefined.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">isUndefined(value) {</span>
	<span class="s4">return typeof </span><span class="s2">value === </span><span class="s3">&quot;undefined&quot;</span><span class="s2">;</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Deeply merges two non-array objects.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} first The base object.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} second The overrides object.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Map&lt;string, Map&lt;string, Object&gt;&gt;} [mergeMap] Maps the combination of first and second arguments to a merged result.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Object} An object with properties from both first and second.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">deepMerge(first, second, mergeMap = </span><span class="s4">new </span><span class="s2">Map()) {</span>
	<span class="s4">let </span><span class="s2">secondMergeMap = mergeMap.get(first);</span>

	<span class="s4">if </span><span class="s2">(secondMergeMap) {</span>
		<span class="s4">const </span><span class="s2">result = secondMergeMap.get(second);</span>

		<span class="s4">if </span><span class="s2">(result) {</span>
			<span class="s0">// If this combination of first and second arguments has been already visited, return the previously created result.</span>
			<span class="s4">return </span><span class="s2">result;</span>
		<span class="s2">}</span>
	<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
		<span class="s2">secondMergeMap = </span><span class="s4">new </span><span class="s2">Map();</span>
		<span class="s2">mergeMap.set(first, secondMergeMap);</span>
	<span class="s2">}</span>

	<span class="s0">/* 
     * First create a result object where properties from the second object 
     * overwrite properties from the first. This sets up a baseline to use 
     * later rather than needing to inspect and change every property 
     * individually. 
     */</span>
	<span class="s4">const </span><span class="s2">result = {</span>
		<span class="s2">...first,</span>
		<span class="s2">...second,</span>
	<span class="s2">};</span>

	<span class="s4">delete </span><span class="s2">result.__proto__; </span><span class="s0">// eslint-disable-line no-proto -- don't merge own property &quot;__proto__&quot;</span>

	<span class="s0">// Store the pending result for this combination of first and second arguments.</span>
	<span class="s2">secondMergeMap.set(second, result);</span>

	<span class="s4">for </span><span class="s2">(</span><span class="s4">const </span><span class="s2">key of Object.keys(second)) {</span>
		<span class="s0">// avoid hairy edge case</span>
		<span class="s4">if </span><span class="s2">(</span>
			<span class="s2">key === </span><span class="s3">&quot;__proto__&quot; </span><span class="s2">||</span>
			<span class="s2">!Object.prototype.propertyIsEnumerable.call(first, key)</span>
		<span class="s2">) {</span>
			<span class="s4">continue</span><span class="s2">;</span>
		<span class="s2">}</span>

		<span class="s4">const </span><span class="s2">firstValue = first[key];</span>
		<span class="s4">const </span><span class="s2">secondValue = second[key];</span>

		<span class="s4">if </span><span class="s2">(isNonArrayObject(firstValue) &amp;&amp; isNonArrayObject(secondValue)) {</span>
			<span class="s2">result[key] = deepMerge(firstValue, secondValue, mergeMap);</span>
		<span class="s2">} </span><span class="s4">else if </span><span class="s2">(isUndefined(secondValue)) {</span>
			<span class="s2">result[key] = firstValue;</span>
		<span class="s2">}</span>
	<span class="s2">}</span>

	<span class="s4">return </span><span class="s2">result;</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Normalizes the rule options config for a given rule by ensuring that</span>
 <span class="s0">* it is an array and that the first item is 0, 1, or 2.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array|string|number} ruleOptions The rule options config.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{Array} An array of rule options.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">normalizeRuleOptions(ruleOptions) {</span>
	<span class="s4">const </span><span class="s2">finalOptions = Array.isArray(ruleOptions)</span>
		<span class="s2">? ruleOptions.slice(</span><span class="s5">0</span><span class="s2">)</span>
		<span class="s2">: [ruleOptions];</span>

	<span class="s2">finalOptions[</span><span class="s5">0</span><span class="s2">] = ruleSeverities.get(finalOptions[</span><span class="s5">0</span><span class="s2">]);</span>
	<span class="s4">return </span><span class="s2">structuredClone(finalOptions);</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Determines if an object has any methods.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Object} object The object to check.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{boolean} `true` if the object has any methods.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">hasMethod(object) {</span>
	<span class="s4">for </span><span class="s2">(</span><span class="s4">const </span><span class="s2">key of Object.keys(object)) {</span>
		<span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">object[key] === </span><span class="s3">&quot;function&quot;</span><span class="s2">) {</span>
			<span class="s4">return true</span><span class="s2">;</span>
		<span class="s2">}</span>
	<span class="s2">}</span>

	<span class="s4">return false</span><span class="s2">;</span>
<span class="s2">}</span>

<span class="s0">//-----------------------------------------------------------------------------</span>
<span class="s0">// Assertions</span>
<span class="s0">//-----------------------------------------------------------------------------</span>

<span class="s0">/**</span>
 <span class="s0">* The error type when a rule's options are configured with an invalid type.</span>
 <span class="s0">*/</span>
<span class="s4">class </span><span class="s2">InvalidRuleOptionsError </span><span class="s4">extends </span><span class="s2">Error {</span>
	<span class="s0">/**</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} ruleId Rule name being configured.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{any} value The invalid value.</span>
	 <span class="s0">*/</span>
	<span class="s2">constructor(ruleId, value) {</span>
		<span class="s4">super</span><span class="s2">(</span>
			<span class="s3">`Key &quot;</span><span class="s2">${ruleId}</span><span class="s3">&quot;: Expected severity of &quot;off&quot;, 0, &quot;warn&quot;, 1, &quot;error&quot;, or 2.`</span><span class="s2">,</span>
		<span class="s2">);</span>
		<span class="s4">this</span><span class="s2">.messageTemplate = </span><span class="s3">&quot;invalid-rule-options&quot;</span><span class="s2">;</span>
		<span class="s4">this</span><span class="s2">.messageData = { ruleId, value };</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Validates that a value is a valid rule options entry.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} ruleId Rule name being configured.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{any} value The value to check.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{InvalidRuleOptionsError} If the value isn't a valid rule options.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">assertIsRuleOptions(ruleId, value) {</span>
	<span class="s4">if </span><span class="s2">(</span>
		<span class="s4">typeof </span><span class="s2">value !== </span><span class="s3">&quot;string&quot; </span><span class="s2">&amp;&amp;</span>
		<span class="s4">typeof </span><span class="s2">value !== </span><span class="s3">&quot;number&quot; </span><span class="s2">&amp;&amp;</span>
		<span class="s2">!Array.isArray(value)</span>
	<span class="s2">) {</span>
		<span class="s4">throw new </span><span class="s2">InvalidRuleOptionsError(ruleId, value);</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* The error type when a rule's severity is invalid.</span>
 <span class="s0">*/</span>
<span class="s4">class </span><span class="s2">InvalidRuleSeverityError </span><span class="s4">extends </span><span class="s2">Error {</span>
	<span class="s0">/**</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} ruleId Rule name being configured.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{any} value The invalid value.</span>
	 <span class="s0">*/</span>
	<span class="s2">constructor(ruleId, value) {</span>
		<span class="s4">super</span><span class="s2">(</span>
			<span class="s3">`Key &quot;</span><span class="s2">${ruleId}</span><span class="s3">&quot;: Expected severity of &quot;off&quot;, 0, &quot;warn&quot;, 1, &quot;error&quot;, or 2.`</span><span class="s2">,</span>
		<span class="s2">);</span>
		<span class="s4">this</span><span class="s2">.messageTemplate = </span><span class="s3">&quot;invalid-rule-severity&quot;</span><span class="s2">;</span>
		<span class="s4">this</span><span class="s2">.messageData = { ruleId, value };</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Validates that a value is valid rule severity.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} ruleId Rule name being configured.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{any} value The value to check.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{InvalidRuleSeverityError} If the value isn't a valid rule severity.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">assertIsRuleSeverity(ruleId, value) {</span>
	<span class="s4">const </span><span class="s2">severity = ruleSeverities.get(value);</span>

	<span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">severity === </span><span class="s3">&quot;undefined&quot;</span><span class="s2">) {</span>
		<span class="s4">throw new </span><span class="s2">InvalidRuleSeverityError(ruleId, value);</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Validates that a given string is the form pluginName/objectName.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} value The string to check.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} If the string isn't in the correct format.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">assertIsPluginMemberName(value) {</span>
	<span class="s4">if </span><span class="s2">(!</span><span class="s6">/[\w\-@$]+(?:\/[\w\-$]+)+$/iu</span><span class="s2">.test(value)) {</span>
		<span class="s4">throw new </span><span class="s2">TypeError(</span>
			<span class="s3">`Expected string in the form &quot;pluginName/objectName&quot; but found &quot;</span><span class="s2">${value}</span><span class="s3">&quot;.`</span><span class="s2">,</span>
		<span class="s2">);</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* Validates that a value is an object.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{any} value The value to check.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{void}</span>
 <span class="s0">* </span><span class="s1">@throws </span><span class="s0">{TypeError} If the value isn't an object.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">assertIsObject(value) {</span>
	<span class="s4">if </span><span class="s2">(!isNonNullObject(value)) {</span>
		<span class="s4">throw new </span><span class="s2">TypeError(</span><span class="s3">&quot;Expected an object.&quot;</span><span class="s2">);</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* The error type when there's an eslintrc-style options in a flat config.</span>
 <span class="s0">*/</span>
<span class="s4">class </span><span class="s2">IncompatibleKeyError </span><span class="s4">extends </span><span class="s2">Error {</span>
	<span class="s0">/**</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} key The invalid key.</span>
	 <span class="s0">*/</span>
	<span class="s2">constructor(key) {</span>
		<span class="s4">super</span><span class="s2">(</span>
			<span class="s3">&quot;This appears to be in eslintrc format rather than flat config format.&quot;</span><span class="s2">,</span>
		<span class="s2">);</span>
		<span class="s4">this</span><span class="s2">.messageTemplate = </span><span class="s3">&quot;eslintrc-incompat&quot;</span><span class="s2">;</span>
		<span class="s4">this</span><span class="s2">.messageData = { key };</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">/**</span>
 <span class="s0">* The error type when there's an eslintrc-style plugins array found.</span>
 <span class="s0">*/</span>
<span class="s4">class </span><span class="s2">IncompatiblePluginsError </span><span class="s4">extends </span><span class="s2">Error {</span>
	<span class="s0">/**</span>
	 <span class="s0">* Creates a new instance.</span>
	 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{Array&lt;string&gt;} plugins The plugins array.</span>
	 <span class="s0">*/</span>
	<span class="s2">constructor(plugins) {</span>
		<span class="s4">super</span><span class="s2">(</span>
			<span class="s3">&quot;This appears to be in eslintrc format (array of strings) rather than flat config format (object).&quot;</span><span class="s2">,</span>
		<span class="s2">);</span>
		<span class="s4">this</span><span class="s2">.messageTemplate = </span><span class="s3">&quot;eslintrc-plugins&quot;</span><span class="s2">;</span>
		<span class="s4">this</span><span class="s2">.messageData = { plugins };</span>
	<span class="s2">}</span>
<span class="s2">}</span>

<span class="s0">//-----------------------------------------------------------------------------</span>
<span class="s0">// Low-Level Schemas</span>
<span class="s0">//-----------------------------------------------------------------------------</span>

<span class="s0">/** </span><span class="s1">@type </span><span class="s0">{ObjectPropertySchema} */</span>
<span class="s4">const </span><span class="s2">booleanSchema = {</span>
	<span class="s2">merge: </span><span class="s3">&quot;replace&quot;</span><span class="s2">,</span>
	<span class="s2">validate: </span><span class="s3">&quot;boolean&quot;</span><span class="s2">,</span>
<span class="s2">};</span>

<span class="s4">const </span><span class="s2">ALLOWED_SEVERITIES = </span><span class="s4">new </span><span class="s2">Set([</span><span class="s3">&quot;error&quot;</span><span class="s2">, </span><span class="s3">&quot;warn&quot;</span><span class="s2">, </span><span class="s3">&quot;off&quot;</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">]);</span>

<span class="s0">/** </span><span class="s1">@type </span><span class="s0">{ObjectPropertySchema} */</span>
<span class="s4">const </span><span class="s2">disableDirectiveSeveritySchema = {</span>
	<span class="s2">merge(first, second) {</span>
		<span class="s4">const </span><span class="s2">value = second === </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">? first : second;</span>

		<span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">value === </span><span class="s3">&quot;boolean&quot;</span><span class="s2">) {</span>
			<span class="s4">return </span><span class="s2">value ? </span><span class="s3">&quot;warn&quot; </span><span class="s2">: </span><span class="s3">&quot;off&quot;</span><span class="s2">;</span>
		<span class="s2">}</span>

		<span class="s4">return </span><span class="s2">normalizeSeverityToNumber(value);</span>
	<span class="s2">},</span>
	<span class="s2">validate(value) {</span>
		<span class="s4">if </span><span class="s2">(!(ALLOWED_SEVERITIES.has(value) || </span><span class="s4">typeof </span><span class="s2">value === </span><span class="s3">&quot;boolean&quot;</span><span class="s2">)) {</span>
			<span class="s4">throw new </span><span class="s2">TypeError(</span>
				<span class="s3">'Expected one of: &quot;error&quot;, &quot;warn&quot;, &quot;off&quot;, 0, 1, 2, or a boolean.'</span><span class="s2">,</span>
			<span class="s2">);</span>
		<span class="s2">}</span>
	<span class="s2">},</span>
<span class="s2">};</span>

<span class="s0">/** </span><span class="s1">@type </span><span class="s0">{ObjectPropertySchema} */</span>
<span class="s4">const </span><span class="s2">unusedInlineConfigsSeveritySchema = {</span>
	<span class="s2">merge(first, second) {</span>
		<span class="s4">const </span><span class="s2">value = second === </span><span class="s4">void </span><span class="s5">0 </span><span class="s2">? first : second;</span>

		<span class="s4">return </span><span class="s2">normalizeSeverityToNumber(value);</span>
	<span class="s2">},</span>
	<span class="s2">validate(value) {</span>
		<span class="s4">if </span><span class="s2">(!ALLOWED_SEVERITIES.has(value)) {</span>
			<span class="s4">throw new </span><span class="s2">TypeError(</span>
				<span class="s3">'Expected one of: &quot;error&quot;, &quot;warn&quot;, &quot;off&quot;, 0, 1, or 2.'</span><span class="s2">,</span>
			<span class="s2">);</span>
		<span class="s2">}</span>
	<span class="s2">},</span>
<span class="s2">};</span>

<span class="s0">/** </span><span class="s1">@type </span><span class="s0">{ObjectPropertySchema} */</span>
<span class="s4">const </span><span class="s2">deepObjectAssignSchema = {</span>
	<span class="s2">merge(first = {}, second = {}) {</span>
		<span class="s4">return </span><span class="s2">deepMerge(first, second);</span>
	<span class="s2">},</span>
	<span class="s2">validate: </span><span class="s3">&quot;object&quot;</span><span class="s2">,</span>
<span class="s2">};</span>

<span class="s0">//-----------------------------------------------------------------------------</span>
<span class="s0">// High-Level Schemas</span>
<span class="s0">//-----------------------------------------------------------------------------</span>

<span class="s0">/** </span><span class="s1">@type </span><span class="s0">{ObjectPropertySchema} */</span>
<span class="s4">const </span><span class="s2">languageOptionsSchema = {</span>
	<span class="s2">merge(first = {}, second = {}) {</span>
		<span class="s4">const </span><span class="s2">result = deepMerge(first, second);</span>

		<span class="s4">for </span><span class="s2">(</span><span class="s4">const </span><span class="s2">[key, value] of Object.entries(result)) {</span>
			<span class="s0">/* 
             * Special case: Because the `parser` property is an object, it should 
             * not be deep merged. Instead, it should be replaced if it exists in 
             * the second object. To make this more generic, we just check for 
             * objects with methods and replace them if they exist in the second 
             * object. 
             */</span>
			<span class="s4">if </span><span class="s2">(isNonArrayObject(value)) {</span>
				<span class="s4">if </span><span class="s2">(hasMethod(value)) {</span>
					<span class="s2">result[key] = second[key] ?? first[key];</span>
					<span class="s4">continue</span><span class="s2">;</span>
				<span class="s2">}</span>

				<span class="s0">// for other objects, make sure we aren't reusing the same object</span>
				<span class="s2">result[key] = { ...result[key] };</span>
				<span class="s4">continue</span><span class="s2">;</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s4">return </span><span class="s2">result;</span>
	<span class="s2">},</span>
	<span class="s2">validate: </span><span class="s3">&quot;object&quot;</span><span class="s2">,</span>
<span class="s2">};</span>

<span class="s0">/** </span><span class="s1">@type </span><span class="s0">{ObjectPropertySchema} */</span>
<span class="s4">const </span><span class="s2">languageSchema = {</span>
	<span class="s2">merge: </span><span class="s3">&quot;replace&quot;</span><span class="s2">,</span>
	<span class="s2">validate: assertIsPluginMemberName,</span>
<span class="s2">};</span>

<span class="s0">/** </span><span class="s1">@type </span><span class="s0">{ObjectPropertySchema} */</span>
<span class="s4">const </span><span class="s2">pluginsSchema = {</span>
	<span class="s2">merge(first = {}, second = {}) {</span>
		<span class="s4">const </span><span class="s2">keys = </span><span class="s4">new </span><span class="s2">Set([...Object.keys(first), ...Object.keys(second)]);</span>
		<span class="s4">const </span><span class="s2">result = {};</span>

		<span class="s0">// manually validate that plugins are not redefined</span>
		<span class="s4">for </span><span class="s2">(</span><span class="s4">const </span><span class="s2">key of keys) {</span>
			<span class="s0">// avoid hairy edge case</span>
			<span class="s4">if </span><span class="s2">(key === </span><span class="s3">&quot;__proto__&quot;</span><span class="s2">) {</span>
				<span class="s4">continue</span><span class="s2">;</span>
			<span class="s2">}</span>

			<span class="s4">if </span><span class="s2">(key </span><span class="s4">in </span><span class="s2">first &amp;&amp; key </span><span class="s4">in </span><span class="s2">second &amp;&amp; first[key] !== second[key]) {</span>
				<span class="s4">throw new </span><span class="s2">TypeError(</span><span class="s3">`Cannot redefine plugin &quot;</span><span class="s2">${key}</span><span class="s3">&quot;.`</span><span class="s2">);</span>
			<span class="s2">}</span>

			<span class="s2">result[key] = second[key] || first[key];</span>
		<span class="s2">}</span>

		<span class="s4">return </span><span class="s2">result;</span>
	<span class="s2">},</span>
	<span class="s2">validate(value) {</span>
		<span class="s0">// first check the value to be sure it's an object</span>
		<span class="s4">if </span><span class="s2">(value === </span><span class="s4">null </span><span class="s2">|| </span><span class="s4">typeof </span><span class="s2">value !== </span><span class="s3">&quot;object&quot;</span><span class="s2">) {</span>
			<span class="s4">throw new </span><span class="s2">TypeError(</span><span class="s3">&quot;Expected an object.&quot;</span><span class="s2">);</span>
		<span class="s2">}</span>

		<span class="s0">// make sure it's not an array, which would mean eslintrc-style is used</span>
		<span class="s4">if </span><span class="s2">(Array.isArray(value)) {</span>
			<span class="s4">throw new </span><span class="s2">IncompatiblePluginsError(value);</span>
		<span class="s2">}</span>

		<span class="s0">// second check the keys to make sure they are objects</span>
		<span class="s4">for </span><span class="s2">(</span><span class="s4">const </span><span class="s2">key of Object.keys(value)) {</span>
			<span class="s0">// avoid hairy edge case</span>
			<span class="s4">if </span><span class="s2">(key === </span><span class="s3">&quot;__proto__&quot;</span><span class="s2">) {</span>
				<span class="s4">continue</span><span class="s2">;</span>
			<span class="s2">}</span>

			<span class="s4">if </span><span class="s2">(value[key] === </span><span class="s4">null </span><span class="s2">|| </span><span class="s4">typeof </span><span class="s2">value[key] !== </span><span class="s3">&quot;object&quot;</span><span class="s2">) {</span>
				<span class="s4">throw new </span><span class="s2">TypeError(</span><span class="s3">`Key &quot;</span><span class="s2">${key}</span><span class="s3">&quot;: Expected an object.`</span><span class="s2">);</span>
			<span class="s2">}</span>
		<span class="s2">}</span>
	<span class="s2">},</span>
<span class="s2">};</span>

<span class="s0">/** </span><span class="s1">@type </span><span class="s0">{ObjectPropertySchema} */</span>
<span class="s4">const </span><span class="s2">processorSchema = {</span>
	<span class="s2">merge: </span><span class="s3">&quot;replace&quot;</span><span class="s2">,</span>
	<span class="s2">validate(value) {</span>
		<span class="s4">if </span><span class="s2">(</span><span class="s4">typeof </span><span class="s2">value === </span><span class="s3">&quot;string&quot;</span><span class="s2">) {</span>
			<span class="s2">assertIsPluginMemberName(value);</span>
		<span class="s2">} </span><span class="s4">else if </span><span class="s2">(value &amp;&amp; </span><span class="s4">typeof </span><span class="s2">value === </span><span class="s3">&quot;object&quot;</span><span class="s2">) {</span>
			<span class="s4">if </span><span class="s2">(</span>
				<span class="s4">typeof </span><span class="s2">value.preprocess !== </span><span class="s3">&quot;function&quot; </span><span class="s2">||</span>
				<span class="s4">typeof </span><span class="s2">value.postprocess !== </span><span class="s3">&quot;function&quot;</span>
			<span class="s2">) {</span>
				<span class="s4">throw new </span><span class="s2">TypeError(</span>
					<span class="s3">&quot;Object must have a preprocess() and a postprocess() method.&quot;</span><span class="s2">,</span>
				<span class="s2">);</span>
			<span class="s2">}</span>
		<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
			<span class="s4">throw new </span><span class="s2">TypeError(</span><span class="s3">&quot;Expected an object or a string.&quot;</span><span class="s2">);</span>
		<span class="s2">}</span>
	<span class="s2">},</span>
<span class="s2">};</span>

<span class="s0">/** </span><span class="s1">@type </span><span class="s0">{ObjectPropertySchema} */</span>
<span class="s4">const </span><span class="s2">rulesSchema = {</span>
	<span class="s2">merge(first = {}, second = {}) {</span>
		<span class="s4">const </span><span class="s2">result = {</span>
			<span class="s2">...first,</span>
			<span class="s2">...second,</span>
		<span class="s2">};</span>

		<span class="s4">for </span><span class="s2">(</span><span class="s4">const </span><span class="s2">ruleId of Object.keys(result)) {</span>
			<span class="s4">try </span><span class="s2">{</span>
				<span class="s0">// avoid hairy edge case</span>
				<span class="s4">if </span><span class="s2">(ruleId === </span><span class="s3">&quot;__proto__&quot;</span><span class="s2">) {</span>
					<span class="s0">/* eslint-disable-next-line no-proto -- Though deprecated, may still be present */</span>
					<span class="s4">delete </span><span class="s2">result.__proto__;</span>
					<span class="s4">continue</span><span class="s2">;</span>
				<span class="s2">}</span>

				<span class="s2">result[ruleId] = normalizeRuleOptions(result[ruleId]);</span>

				<span class="s0">/* 
                 * If either rule config is missing, then the correct 
                 * config is already present and we just need to normalize 
                 * the severity. 
                 */</span>
				<span class="s4">if </span><span class="s2">(!(ruleId </span><span class="s4">in </span><span class="s2">first) || !(ruleId </span><span class="s4">in </span><span class="s2">second)) {</span>
					<span class="s4">continue</span><span class="s2">;</span>
				<span class="s2">}</span>

				<span class="s4">const </span><span class="s2">firstRuleOptions = normalizeRuleOptions(first[ruleId]);</span>
				<span class="s4">const </span><span class="s2">secondRuleOptions = normalizeRuleOptions(second[ruleId]);</span>

				<span class="s0">/* 
                 * If the second rule config only has a severity (length of 1), 
                 * then use that severity and keep the rest of the options from 
                 * the first rule config. 
                 */</span>
				<span class="s4">if </span><span class="s2">(secondRuleOptions.length === </span><span class="s5">1</span><span class="s2">) {</span>
					<span class="s2">result[ruleId] = [</span>
						<span class="s2">secondRuleOptions[</span><span class="s5">0</span><span class="s2">],</span>
						<span class="s2">...firstRuleOptions.slice(</span><span class="s5">1</span><span class="s2">),</span>
					<span class="s2">];</span>
					<span class="s4">continue</span><span class="s2">;</span>
				<span class="s2">}</span>

				<span class="s0">/* 
                 * In any other situation, then the second rule config takes 
                 * precedence. That means the value at `result[ruleId]` is 
                 * already correct and no further work is necessary. 
                 */</span>
			<span class="s2">} </span><span class="s4">catch </span><span class="s2">(ex) {</span>
				<span class="s4">throw new </span><span class="s2">Error(</span><span class="s3">`Key &quot;</span><span class="s2">${ruleId}</span><span class="s3">&quot;: </span><span class="s2">${ex.message}</span><span class="s3">`</span><span class="s2">, {</span>
					<span class="s2">cause: ex,</span>
				<span class="s2">});</span>
			<span class="s2">}</span>
		<span class="s2">}</span>

		<span class="s4">return </span><span class="s2">result;</span>
	<span class="s2">},</span>

	<span class="s2">validate(value) {</span>
		<span class="s2">assertIsObject(value);</span>

		<span class="s0">/* 
         * We are not checking the rule schema here because there is no 
         * guarantee that the rule definition is present at this point. Instead 
         * we wait and check the rule schema during the finalization step 
         * of calculating a config. 
         */</span>
		<span class="s4">for </span><span class="s2">(</span><span class="s4">const </span><span class="s2">ruleId of Object.keys(value)) {</span>
			<span class="s0">// avoid hairy edge case</span>
			<span class="s4">if </span><span class="s2">(ruleId === </span><span class="s3">&quot;__proto__&quot;</span><span class="s2">) {</span>
				<span class="s4">continue</span><span class="s2">;</span>
			<span class="s2">}</span>

			<span class="s4">const </span><span class="s2">ruleOptions = value[ruleId];</span>

			<span class="s2">assertIsRuleOptions(ruleId, ruleOptions);</span>

			<span class="s4">if </span><span class="s2">(Array.isArray(ruleOptions)) {</span>
				<span class="s2">assertIsRuleSeverity(ruleId, ruleOptions[</span><span class="s5">0</span><span class="s2">]);</span>
			<span class="s2">} </span><span class="s4">else </span><span class="s2">{</span>
				<span class="s2">assertIsRuleSeverity(ruleId, ruleOptions);</span>
			<span class="s2">}</span>
		<span class="s2">}</span>
	<span class="s2">},</span>
<span class="s2">};</span>

<span class="s0">/**</span>
 <span class="s0">* Creates a schema that always throws an error. Useful for warning</span>
 <span class="s0">* about eslintrc-style keys.</span>
 <span class="s0">* </span><span class="s1">@param </span><span class="s0">{string} key The eslintrc key to create a schema for.</span>
 <span class="s0">* </span><span class="s1">@returns </span><span class="s0">{ObjectPropertySchema} The schema.</span>
 <span class="s0">*/</span>
<span class="s4">function </span><span class="s2">createEslintrcErrorSchema(key) {</span>
	<span class="s4">return </span><span class="s2">{</span>
		<span class="s2">merge: </span><span class="s3">&quot;replace&quot;</span><span class="s2">,</span>
		<span class="s2">validate() {</span>
			<span class="s4">throw new </span><span class="s2">IncompatibleKeyError(key);</span>
		<span class="s2">},</span>
	<span class="s2">};</span>
<span class="s2">}</span>

<span class="s4">const </span><span class="s2">eslintrcKeys = [</span>
	<span class="s3">&quot;env&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;extends&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;globals&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;ignorePatterns&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;noInlineConfig&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;overrides&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;parser&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;parserOptions&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;reportUnusedDisableDirectives&quot;</span><span class="s2">,</span>
	<span class="s3">&quot;root&quot;</span><span class="s2">,</span>
<span class="s2">];</span>

<span class="s0">//-----------------------------------------------------------------------------</span>
<span class="s0">// Full schema</span>
<span class="s0">//-----------------------------------------------------------------------------</span>

<span class="s4">const </span><span class="s2">flatConfigSchema = {</span>
	<span class="s0">// eslintrc-style keys that should always error</span>
	<span class="s2">...Object.fromEntries(</span>
		<span class="s2">eslintrcKeys.map(key =&gt; [key, createEslintrcErrorSchema(key)]),</span>
	<span class="s2">),</span>

	<span class="s0">// flat config keys</span>
	<span class="s2">settings: deepObjectAssignSchema,</span>
	<span class="s2">linterOptions: {</span>
		<span class="s2">schema: {</span>
			<span class="s2">noInlineConfig: booleanSchema,</span>
			<span class="s2">reportUnusedDisableDirectives: disableDirectiveSeveritySchema,</span>
			<span class="s2">reportUnusedInlineConfigs: unusedInlineConfigsSeveritySchema,</span>
		<span class="s2">},</span>
	<span class="s2">},</span>
	<span class="s2">language: languageSchema,</span>
	<span class="s2">languageOptions: languageOptionsSchema,</span>
	<span class="s2">processor: processorSchema,</span>
	<span class="s2">plugins: pluginsSchema,</span>
	<span class="s2">rules: rulesSchema,</span>
<span class="s2">};</span>

<span class="s0">//-----------------------------------------------------------------------------</span>
<span class="s0">// Exports</span>
<span class="s0">//-----------------------------------------------------------------------------</span>

<span class="s2">module.exports = {</span>
	<span class="s2">flatConfigSchema,</span>
	<span class="s2">hasMethod,</span>
	<span class="s2">assertIsRuleSeverity,</span>
<span class="s2">};</span>
</pre>
</body>
</html>