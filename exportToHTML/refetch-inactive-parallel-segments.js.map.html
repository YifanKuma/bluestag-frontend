<html>
<head>
<title>refetch-inactive-parallel-segments.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
refetch-inactive-parallel-segments.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../../src/client/components/router-reducer/refetch-inactive-parallel-segments.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { FlightRouterState } from '../../../server/app-render/types'</span><span class="s3">\n</span><span class="s1">import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'</span><span class="s3">\n</span><span class="s1">import type { AppRouterState } from './router-reducer-types'</span><span class="s3">\n</span><span class="s1">import { applyFlightData } from './apply-flight-data'</span><span class="s3">\n</span><span class="s1">import { fetchServerResponse } from './fetch-server-response'</span><span class="s3">\n</span><span class="s1">import { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'</span><span class="s3">\n\n</span><span class="s1">interface RefreshInactiveParallelSegments {</span><span class="s3">\n  </span><span class="s1">navigatedAt: number</span><span class="s3">\n  </span><span class="s1">state: AppRouterState</span><span class="s3">\n  </span><span class="s1">updatedTree: FlightRouterState</span><span class="s3">\n  </span><span class="s1">updatedCache: CacheNode</span><span class="s3">\n  </span><span class="s1">includeNextUrl: boolean</span><span class="s3">\n  </span><span class="s1">canonicalUrl: string</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Refreshes inactive segments that are still in the current FlightRouterState.</span><span class="s3">\n </span><span class="s1">* A segment is considered </span><span class="s3">\&quot;</span><span class="s1">inactive</span><span class="s3">\&quot; </span><span class="s1">when the server response indicates it didn't match to a page component.</span><span class="s3">\n </span><span class="s1">* This happens during a soft-navigation, where the server will want to patch in the segment</span><span class="s3">\n </span><span class="s1">* with the </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot; </span><span class="s1">component, but we explicitly ignore the server in this case</span><span class="s3">\n </span><span class="s1">* and keep the existing state for that segment. New data for inactive segments are inherently</span><span class="s3">\n </span><span class="s1">* not part of the server response when we patch the tree, because they were associated with a response</span><span class="s3">\n </span><span class="s1">* from an earlier navigation/request. For each segment, once it becomes </span><span class="s3">\&quot;</span><span class="s1">active</span><span class="s3">\&quot;</span><span class="s1">, we encode the URL that provided</span><span class="s3">\n </span><span class="s1">* the data for it. This function traverses parallel routes looking for these markers so that it can re-fetch</span><span class="s3">\n </span><span class="s1">* and patch the new data into the tree.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export async function refreshInactiveParallelSegments(</span><span class="s3">\n  </span><span class="s1">options: RefreshInactiveParallelSegments</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const fetchedSegments = new Set&lt;string&gt;()</span><span class="s3">\n  </span><span class="s1">await refreshInactiveParallelSegmentsImpl({</span><span class="s3">\n    </span><span class="s1">...options,</span><span class="s3">\n    </span><span class="s1">rootTree: options.updatedTree,</span><span class="s3">\n    </span><span class="s1">fetchedSegments,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">async function refreshInactiveParallelSegmentsImpl({</span><span class="s3">\n  </span><span class="s1">navigatedAt,</span><span class="s3">\n  </span><span class="s1">state,</span><span class="s3">\n  </span><span class="s1">updatedTree,</span><span class="s3">\n  </span><span class="s1">updatedCache,</span><span class="s3">\n  </span><span class="s1">includeNextUrl,</span><span class="s3">\n  </span><span class="s1">fetchedSegments,</span><span class="s3">\n  </span><span class="s1">rootTree = updatedTree,</span><span class="s3">\n  </span><span class="s1">canonicalUrl,</span><span class="s3">\n</span><span class="s1">}: RefreshInactiveParallelSegments &amp; {</span><span class="s3">\n  </span><span class="s1">fetchedSegments: Set&lt;string&gt;</span><span class="s3">\n  </span><span class="s1">rootTree: FlightRouterState</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">const [, parallelRoutes, refetchPath, refetchMarker] = updatedTree</span><span class="s3">\n  </span><span class="s1">const fetchPromises = []</span><span class="s3">\n\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">refetchPath &amp;&amp;</span><span class="s3">\n    </span><span class="s1">refetchPath !== canonicalUrl &amp;&amp;</span><span class="s3">\n    </span><span class="s1">refetchMarker === 'refresh' &amp;&amp;</span><span class="s3">\n    </span><span class="s1">// it's possible for the tree to contain multiple segments that contain data at the same URL</span><span class="s3">\n    </span><span class="s1">// we keep track of them so we can dedupe the requests</span><span class="s3">\n    </span><span class="s1">!fetchedSegments.has(refetchPath)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">fetchedSegments.add(refetchPath) // Mark this URL as fetched</span><span class="s3">\n\n    </span><span class="s1">// Eagerly kick off the fetch for the refetch path &amp; the parallel routes. This should be fine to do as they each operate</span><span class="s3">\n    </span><span class="s1">// independently on their own cache nodes, and `applyFlightData` will copy anything it doesn't care about from the existing cache.</span><span class="s3">\n    </span><span class="s1">const fetchPromise = fetchServerResponse(</span><span class="s3">\n      </span><span class="s1">new URL(refetchPath, location.origin),</span><span class="s3">\n      </span><span class="s1">{</span><span class="s3">\n        </span><span class="s1">// refetch from the root of the updated tree, otherwise it will be scoped to the current segment</span><span class="s3">\n        </span><span class="s1">// and might not contain the data we need to patch in interception route data (such as dynamic params from a previous segment)</span><span class="s3">\n        </span><span class="s1">flightRouterState: [rootTree[0], rootTree[1], rootTree[2], 'refetch'],</span><span class="s3">\n        </span><span class="s1">nextUrl: includeNextUrl ? state.nextUrl : null,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">).then(({ flightData }) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (typeof flightData !== 'string') {</span><span class="s3">\n        </span><span class="s1">for (const flightDataPath of flightData) {</span><span class="s3">\n          </span><span class="s1">// we only pass the new cache as this function is called after clearing the router cache</span><span class="s3">\n          </span><span class="s1">// and filling in the new page data from the server. Meaning the existing cache is actually the cache that's</span><span class="s3">\n          </span><span class="s1">// just been created &amp; has been written to, but hasn't been </span><span class="s3">\&quot;</span><span class="s1">committed</span><span class="s3">\&quot; </span><span class="s1">yet.</span><span class="s3">\n          </span><span class="s1">applyFlightData(</span><span class="s3">\n            </span><span class="s1">navigatedAt,</span><span class="s3">\n            </span><span class="s1">updatedCache,</span><span class="s3">\n            </span><span class="s1">updatedCache,</span><span class="s3">\n            </span><span class="s1">flightDataPath</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// When flightData is a string, it suggests that the server response should have triggered an MPA navigation</span><span class="s3">\n        </span><span class="s1">// I'm not 100% sure of this decision, but it seems unlikely that we'd want to introduce a redirect side effect</span><span class="s3">\n        </span><span class="s1">// when refreshing on-screen data, so handling this has been ommitted.</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">fetchPromises.push(fetchPromise)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const key in parallelRoutes) {</span><span class="s3">\n    </span><span class="s1">const parallelFetchPromise = refreshInactiveParallelSegmentsImpl({</span><span class="s3">\n      </span><span class="s1">navigatedAt,</span><span class="s3">\n      </span><span class="s1">state,</span><span class="s3">\n      </span><span class="s1">updatedTree: parallelRoutes[key],</span><span class="s3">\n      </span><span class="s1">updatedCache,</span><span class="s3">\n      </span><span class="s1">includeNextUrl,</span><span class="s3">\n      </span><span class="s1">fetchedSegments,</span><span class="s3">\n      </span><span class="s1">rootTree,</span><span class="s3">\n      </span><span class="s1">canonicalUrl,</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">fetchPromises.push(parallelFetchPromise)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">await Promise.all(fetchPromises)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Walks the current parallel segments to determine if they are </span><span class="s3">\&quot;</span><span class="s1">active</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n </span><span class="s1">* An active parallel route will have a `__PAGE__` segment in the FlightRouterState.</span><span class="s3">\n </span><span class="s1">* As opposed to a `__DEFAULT__` segment, which means there was no match for that parallel route.</span><span class="s3">\n </span><span class="s1">* We add a special marker here so that we know how to refresh its data when the router is revalidated.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function addRefreshMarkerToActiveParallelSegments(</span><span class="s3">\n  </span><span class="s1">tree: FlightRouterState,</span><span class="s3">\n  </span><span class="s1">path: string</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const [segment, parallelRoutes, , refetchMarker] = tree</span><span class="s3">\n  </span><span class="s1">// a page segment might also contain concatenated search params, so we do a partial match on the key</span><span class="s3">\n  </span><span class="s1">if (segment.includes(PAGE_SEGMENT_KEY) &amp;&amp; refetchMarker !== 'refresh') {</span><span class="s3">\n    </span><span class="s1">tree[2] = path</span><span class="s3">\n    </span><span class="s1">tree[3] = 'refresh'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (const key in parallelRoutes) {</span><span class="s3">\n    </span><span class="s1">addRefreshMarkerToActiveParallelSegments(parallelRoutes[key], path)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;addRefreshMarkerToActiveParallelSegments&quot;</span><span class="s0">,</span><span class="s1">&quot;refreshInactiveParallelSegments&quot;</span><span class="s0">,</span><span class="s1">&quot;options&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchedSegments&quot;</span><span class="s0">,</span><span class="s1">&quot;Set&quot;</span><span class="s0">,</span><span class="s1">&quot;refreshInactiveParallelSegmentsImpl&quot;</span><span class="s0">,</span><span class="s1">&quot;rootTree&quot;</span><span class="s0">,</span><span class="s1">&quot;updatedTree&quot;</span><span class="s0">,</span><span class="s1">&quot;navigatedAt&quot;</span><span class="s0">,</span><span class="s1">&quot;state&quot;</span><span class="s0">,</span><span class="s1">&quot;updatedCache&quot;</span><span class="s0">,</span><span class="s1">&quot;includeNextUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;canonicalUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelRoutes&quot;</span><span class="s0">,</span><span class="s1">&quot;refetchPath&quot;</span><span class="s0">,</span><span class="s1">&quot;refetchMarker&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchPromises&quot;</span><span class="s0">,</span><span class="s1">&quot;has&quot;</span><span class="s0">,</span><span class="s1">&quot;add&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;fetchServerResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;URL&quot;</span><span class="s0">,</span><span class="s1">&quot;location&quot;</span><span class="s0">,</span><span class="s1">&quot;origin&quot;</span><span class="s0">,</span><span class="s1">&quot;flightRouterState&quot;</span><span class="s0">,</span><span class="s1">&quot;nextUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;then&quot;</span><span class="s0">,</span><span class="s1">&quot;flightData&quot;</span><span class="s0">,</span><span class="s1">&quot;flightDataPath&quot;</span><span class="s0">,</span><span class="s1">&quot;applyFlightData&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;parallelFetchPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;all&quot;</span><span class="s0">,</span><span class="s1">&quot;tree&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;segment&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;PAGE_SEGMENT_KEY&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;IAyHgBA,wCAAwC;eAAxCA;;IA9FMC,+BAA+B;eAA/BA;;;iCAxBU;qCACI;yBACH;AAsB1B,eAAeA,gCACpBC,OAAwC;IAExC,MAAMC,kBAAkB,IAAIC;IAC5B,MAAMC,oCAAoC;QACxC,GAAGH,OAAO;QACVI,UAAUJ,QAAQK,WAAW;QAC7BJ;IACF;AACF;AAEA,eAAeE,oCAAoC,KAYlD;IAZkD,IAAA,EACjDG,WAAW,EACXC,KAAK,EACLF,WAAW,EACXG,YAAY,EACZC,cAAc,EACdR,eAAe,EACfG,WAAWC,WAAW,EACtBK,YAAY,EAIb,GAZkD;IAajD,MAAM,GAAGC,gBAAgBC,aAAaC,cAAc,GAAGR;IACvD,MAAMS,gBAAgB,EAAE;IAExB,IACEF,eACAA,gBAAgBF,gBAChBG,kBAAkB,aAClB,4FAA4F;IAC5F,sDAAsD;IACtD,CAACZ,gBAAgBc,GAAG,CAACH,cACrB;QACAX,gBAAgBe,GAAG,CAACJ,aAAa,2BAA2B;;QAE5D,wHAAwH;QACxH,kIAAkI;QAClI,MAAMK,eAAeC,IAAAA,wCAAmB,EACtC,IAAIC,IAAIP,aAAaQ,SAASC,MAAM,GACpC;YACE,gGAAgG;YAChG,8HAA8H;YAC9HC,mBAAmB;gBAAClB,QAAQ,CAAC,EAAE;gBAAEA,QAAQ,CAAC,EAAE;gBAAEA,QAAQ,CAAC,EAAE;gBAAE;aAAU;YACrEmB,SAASd,iBAAiBF,MAAMgB,OAAO,GAAG;QAC5C,GACAC,IAAI,CAAC;gBAAC,EAAEC,UAAU,EAAE;YACpB,IAAI,OAAOA,eAAe,UAAU;gBAClC,KAAK,MAAMC,kBAAkBD,WAAY;oBACvC,wFAAwF;oBACxF,4GAA4G;oBAC5G,4EAA4E;oBAC5EE,IAAAA,gCAAe,EACbrB,aACAE,cACAA,cACAkB;gBAEJ;YACF,OAAO;YACL,4GAA4G;YAC5G,+GAA+G;YAC/G,sEAAsE;YACxE;QACF;QAEAZ,cAAcc,IAAI,CAACX;IACrB;IAEA,IAAK,MAAMY,OAAOlB,eAAgB;QAChC,MAAMmB,uBAAuB3B,oCAAoC;YAC/DG;YACAC;YACAF,aAAaM,cAAc,CAACkB,IAAI;YAChCrB;YACAC;YACAR;YACAG;YACAM;QACF;QAEAI,cAAcc,IAAI,CAACE;IACrB;IAEA,MAAMC,QAAQC,GAAG,CAAClB;AACpB;AAQO,SAAShB,yCACdmC,IAAuB,EACvBC,IAAY;IAEZ,MAAM,CAACC,SAASxB,kBAAkBE,cAAc,GAAGoB;IACnD,oGAAoG;IACpG,IAAIE,QAAQC,QAAQ,CAACC,yBAAgB,KAAKxB,kBAAkB,WAAW;QACrEoB,IAAI,CAAC,EAAE,GAAGC;QACVD,IAAI,CAAC,EAAE,GAAG;IACZ;IAEA,IAAK,MAAMJ,OAAOlB,eAAgB;QAChCb,yCAAyCa,cAAc,CAACkB,IAAI,EAAEK;IAChE;AACF&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>