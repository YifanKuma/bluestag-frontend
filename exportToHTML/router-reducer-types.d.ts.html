<html>
<head>
<title>router-reducer-types.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #0033b3;}
.s1 { color: #080808;}
.s2 { color: #067d17;}
.s3 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
router-reducer-types.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">type { CacheNode } from </span><span class="s2">'../../../shared/lib/app-router-context.shared-runtime'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { FlightRouterState, FlightSegmentPath } from </span><span class="s2">'../../../server/app-render/types'</span><span class="s1">;</span>
<span class="s0">import </span><span class="s1">type { FetchServerResponseResult } from </span><span class="s2">'./fetch-server-response'</span><span class="s1">;</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">ACTION_REFRESH = </span><span class="s2">&quot;refresh&quot;</span><span class="s1">;</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">ACTION_NAVIGATE = </span><span class="s2">&quot;navigate&quot;</span><span class="s1">;</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">ACTION_RESTORE = </span><span class="s2">&quot;restore&quot;</span><span class="s1">;</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">ACTION_SERVER_PATCH = </span><span class="s2">&quot;server-patch&quot;</span><span class="s1">;</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">ACTION_PREFETCH = </span><span class="s2">&quot;prefetch&quot;</span><span class="s1">;</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">ACTION_HMR_REFRESH = </span><span class="s2">&quot;hmr-refresh&quot;</span><span class="s1">;</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">const </span><span class="s1">ACTION_SERVER_ACTION = </span><span class="s2">&quot;server-action&quot;</span><span class="s1">;</span>
<span class="s0">export </span><span class="s1">type RouterChangeByServerResponse = ({ navigatedAt, previousTree, serverResponse, }: {</span>
    <span class="s1">navigatedAt: number;</span>
    <span class="s1">previousTree: FlightRouterState;</span>
    <span class="s1">serverResponse: FetchServerResponseResult;</span>
<span class="s1">}) =&gt; </span><span class="s0">void</span><span class="s1">;</span>
<span class="s0">export interface </span><span class="s1">Mutable {</span>
    <span class="s1">mpaNavigation?: boolean;</span>
    <span class="s1">patchedTree?: FlightRouterState;</span>
    <span class="s1">canonicalUrl?: string;</span>
    <span class="s1">scrollableSegments?: FlightSegmentPath[];</span>
    <span class="s1">pendingPush?: boolean;</span>
    <span class="s1">cache?: CacheNode;</span>
    <span class="s1">prefetchCache?: AppRouterState[</span><span class="s2">'prefetchCache'</span><span class="s1">];</span>
    <span class="s1">hashFragment?: string;</span>
    <span class="s1">shouldScroll?: boolean;</span>
    <span class="s1">preserveCustomHistoryState?: boolean;</span>
    <span class="s1">onlyHashChange?: boolean;</span>
<span class="s1">}</span>
<span class="s0">export interface </span><span class="s1">ServerActionMutable </span><span class="s0">extends </span><span class="s1">Mutable {</span>
    <span class="s1">inFlightServerAction?: Promise&lt;any&gt; | </span><span class="s0">null</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Refresh triggers a refresh of the full page data.</span>
 <span class="s3">* - fetches the Flight data and fills rsc at the root of the cache.</span>
 <span class="s3">* - The router state is updated at the root.</span>
 <span class="s3">*/</span>
<span class="s0">export interface </span><span class="s1">RefreshAction {</span>
    <span class="s1">type: </span><span class="s0">typeof </span><span class="s1">ACTION_REFRESH;</span>
    <span class="s1">origin: Location[</span><span class="s2">'origin'</span><span class="s1">];</span>
<span class="s1">}</span>
<span class="s0">export interface </span><span class="s1">HmrRefreshAction {</span>
    <span class="s1">type: </span><span class="s0">typeof </span><span class="s1">ACTION_HMR_REFRESH;</span>
    <span class="s1">origin: Location[</span><span class="s2">'origin'</span><span class="s1">];</span>
<span class="s1">}</span>
<span class="s0">export </span><span class="s1">type ServerActionDispatcher = (args: Omit&lt;ServerActionAction, </span><span class="s2">'type' </span><span class="s1">| </span><span class="s2">'mutable' </span><span class="s1">| </span><span class="s2">'navigate' </span><span class="s1">| </span><span class="s2">'changeByServerResponse' </span><span class="s1">| </span><span class="s2">'cache'</span><span class="s1">&gt;) =&gt; </span><span class="s0">void</span><span class="s1">;</span>
<span class="s0">export interface </span><span class="s1">ServerActionAction {</span>
    <span class="s1">type: </span><span class="s0">typeof </span><span class="s1">ACTION_SERVER_ACTION;</span>
    <span class="s1">actionId: string;</span>
    <span class="s1">actionArgs: any[];</span>
    <span class="s1">resolve: (value: any) =&gt; </span><span class="s0">void</span><span class="s1">;</span>
    <span class="s1">reject: (reason?: any) =&gt; </span><span class="s0">void</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Navigate triggers a navigation to the provided url. It supports two types: `push` and `replace`.</span>
 <span class="s3">*</span>
 <span class="s3">* `navigateType`:</span>
 <span class="s3">* - `push` - pushes a new history entry in the browser history</span>
 <span class="s3">* - `replace` - replaces the current history entry in the browser history</span>
 <span class="s3">*</span>
 <span class="s3">* Navigate has multiple cache heuristics:</span>
 <span class="s3">* - page was prefetched</span>
 <span class="s3">*  - Apply router state tree from prefetch</span>
 <span class="s3">*  - Apply Flight data from prefetch to the cache</span>
 <span class="s3">*  - If Flight data is a string, it's a redirect and the state is updated to trigger a redirect</span>
 <span class="s3">*  - Check if hard navigation is needed</span>
 <span class="s3">*    - Hard navigation happens when a dynamic parameter below the common layout changed</span>
 <span class="s3">*    - When hard navigation is needed the cache is invalidated below the flightSegmentPath</span>
 <span class="s3">*    - The missing cache nodes of the page will be fetched in layout-router and trigger the SERVER_PATCH action</span>
 <span class="s3">*  - If hard navigation is not needed</span>
 <span class="s3">*    - The cache is reused</span>
 <span class="s3">*    - If any cache nodes are missing they'll be fetched in layout-router and trigger the SERVER_PATCH action</span>
 <span class="s3">* - page was not prefetched</span>
 <span class="s3">*  - The navigate was called from `next/router` (`router.push()` / `router.replace()`) / `next/link` without prefetched data available (e.g. the prefetch didn't come back from the server before clicking the link)</span>
 <span class="s3">*    - Flight data is fetched in the reducer (suspends the reducer)</span>
 <span class="s3">*    - Router state tree is created based on Flight data</span>
 <span class="s3">*    - Cache is filled based on the Flight data</span>
 <span class="s3">*</span>
 <span class="s3">* Above steps explain 3 cases:</span>
 <span class="s3">* - `soft` - Reuses the existing cache and fetches missing nodes in layout-router.</span>
 <span class="s3">* - `hard` - Creates a new cache where cache nodes are removed below the common layout and fetches missing nodes in layout-router.</span>
 <span class="s3">* - `optimistic` (explicit no prefetch) - Creates a new cache and kicks off the data fetch in the reducer. The data fetch is awaited in the layout-router.</span>
 <span class="s3">*/</span>
<span class="s0">export interface </span><span class="s1">NavigateAction {</span>
    <span class="s1">type: </span><span class="s0">typeof </span><span class="s1">ACTION_NAVIGATE;</span>
    <span class="s1">url: URL;</span>
    <span class="s1">isExternalUrl: boolean;</span>
    <span class="s1">locationSearch: Location[</span><span class="s2">'search'</span><span class="s1">];</span>
    <span class="s1">navigateType: </span><span class="s2">'push' </span><span class="s1">| </span><span class="s2">'replace'</span><span class="s1">;</span>
    <span class="s1">shouldScroll: boolean;</span>
    <span class="s1">allowAliasing: boolean;</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Restore applies the provided router state.</span>
 <span class="s3">* - Used for `popstate` (back/forward navigation) where a known router state has to be applied.</span>
 <span class="s3">* - Also used when syncing the router state with `pushState`/`replaceState` calls.</span>
 <span class="s3">* - Router state is applied as-is from the history state, if available.</span>
 <span class="s3">* - If the history state does not contain the router state, the existing router state is used.</span>
 <span class="s3">* - If any cache node is missing it will be fetched in layout-router during rendering and the server-patch case.</span>
 <span class="s3">* - If existing cache nodes match these are used.</span>
 <span class="s3">*/</span>
<span class="s0">export interface </span><span class="s1">RestoreAction {</span>
    <span class="s1">type: </span><span class="s0">typeof </span><span class="s1">ACTION_RESTORE;</span>
    <span class="s1">url: URL;</span>
    <span class="s1">tree: FlightRouterState | undefined;</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Server-patch applies the provided Flight data to the cache and router tree.</span>
 <span class="s3">* - Only triggered in layout-router.</span>
 <span class="s3">* - Creates a new cache and router state with the Flight data applied.</span>
 <span class="s3">*/</span>
<span class="s0">export interface </span><span class="s1">ServerPatchAction {</span>
    <span class="s1">type: </span><span class="s0">typeof </span><span class="s1">ACTION_SERVER_PATCH;</span>
    <span class="s1">navigatedAt: number;</span>
    <span class="s1">serverResponse: FetchServerResponseResult;</span>
    <span class="s1">previousTree: FlightRouterState;</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* PrefetchKind defines the type of prefetching that should be done.</span>
 <span class="s3">* - `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully.</span>
 <span class="s3">* - `full` - prefetch the page data fully.</span>
 <span class="s3">* - `temporary` - a temporary prefetch entry is added to the cache, this is used when prefetch={false} is used in next/link or when you push a route programmatically.</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">enum </span><span class="s1">PrefetchKind {</span>
    <span class="s1">AUTO = </span><span class="s2">&quot;auto&quot;</span><span class="s1">,</span>
    <span class="s1">FULL = </span><span class="s2">&quot;full&quot;</span><span class="s1">,</span>
    <span class="s1">TEMPORARY = </span><span class="s2">&quot;temporary&quot;</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Prefetch adds the provided FlightData to the prefetch cache</span>
 <span class="s3">* - Creates the router state tree based on the patch in FlightData</span>
 <span class="s3">* - Adds the FlightData to the prefetch cache</span>
 <span class="s3">* - In ACTION_NAVIGATE the prefetch cache is checked and the router state tree and FlightData are applied.</span>
 <span class="s3">*/</span>
<span class="s0">export interface </span><span class="s1">PrefetchAction {</span>
    <span class="s1">type: </span><span class="s0">typeof </span><span class="s1">ACTION_PREFETCH;</span>
    <span class="s1">url: URL;</span>
    <span class="s1">kind: PrefetchKind;</span>
<span class="s1">}</span>
<span class="s0">export interface </span><span class="s1">PushRef {</span>
    <span class="s3">/**</span>
     <span class="s3">* If the app-router should push a new history entry in app-router's useEffect()</span>
     <span class="s3">*/</span>
    <span class="s1">pendingPush: boolean;</span>
    <span class="s3">/**</span>
     <span class="s3">* Multi-page navigation through location.href.</span>
     <span class="s3">*/</span>
    <span class="s1">mpaNavigation: boolean;</span>
    <span class="s3">/**</span>
     <span class="s3">* Skip applying the router state to the browser history state.</span>
     <span class="s3">*/</span>
    <span class="s1">preserveCustomHistoryState: boolean;</span>
<span class="s1">}</span>
<span class="s0">export </span><span class="s1">type FocusAndScrollRef = {</span>
    <span class="s3">/**</span>
     <span class="s3">* If focus and scroll should be set in the layout-router's useEffect()</span>
     <span class="s3">*/</span>
    <span class="s1">apply: boolean;</span>
    <span class="s3">/**</span>
     <span class="s3">* The hash fragment that should be scrolled to.</span>
     <span class="s3">*/</span>
    <span class="s1">hashFragment: string | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s3">/**</span>
     <span class="s3">* The paths of the segments that should be focused.</span>
     <span class="s3">*/</span>
    <span class="s1">segmentPaths: FlightSegmentPath[];</span>
    <span class="s3">/**</span>
     <span class="s3">* If only the URLs hash fragment changed</span>
     <span class="s3">*/</span>
    <span class="s1">onlyHashChange: boolean;</span>
<span class="s1">};</span>
<span class="s0">export </span><span class="s1">type PrefetchCacheEntry = {</span>
    <span class="s1">treeAtTimeOfPrefetch: FlightRouterState;</span>
    <span class="s1">data: Promise&lt;FetchServerResponseResult&gt;;</span>
    <span class="s1">kind: PrefetchKind;</span>
    <span class="s1">prefetchTime: number;</span>
    <span class="s1">staleTime: number;</span>
    <span class="s1">lastUsedTime: number | </span><span class="s0">null</span><span class="s1">;</span>
    <span class="s1">key: string;</span>
    <span class="s1">status: PrefetchCacheEntryStatus;</span>
    <span class="s1">url: URL;</span>
<span class="s1">};</span>
<span class="s0">export </span><span class="s1">declare </span><span class="s0">enum </span><span class="s1">PrefetchCacheEntryStatus {</span>
    <span class="s1">fresh = </span><span class="s2">&quot;fresh&quot;</span><span class="s1">,</span>
    <span class="s1">reusable = </span><span class="s2">&quot;reusable&quot;</span><span class="s1">,</span>
    <span class="s1">expired = </span><span class="s2">&quot;expired&quot;</span><span class="s1">,</span>
    <span class="s1">stale = </span><span class="s2">&quot;stale&quot;</span>
<span class="s1">}</span>
<span class="s3">/**</span>
 <span class="s3">* Handles keeping the state of app-router.</span>
 <span class="s3">*/</span>
<span class="s0">export </span><span class="s1">type AppRouterState = {</span>
    <span class="s3">/**</span>
     <span class="s3">* The router state, this is written into the history state in app-router using replaceState/pushState.</span>
     <span class="s3">* - Has to be serializable as it is written into the history state.</span>
     <span class="s3">* - Holds which segments and parallel routes are shown on the screen.</span>
     <span class="s3">*/</span>
    <span class="s1">tree: FlightRouterState;</span>
    <span class="s3">/**</span>
     <span class="s3">* The cache holds React nodes for every segment that is shown on screen as well as previously shown segments.</span>
     <span class="s3">* It also holds in-progress data requests.</span>
     <span class="s3">* Prefetched data is stored separately in `prefetchCache`, that is applied during ACTION_NAVIGATE.</span>
     <span class="s3">*/</span>
    <span class="s1">cache: CacheNode;</span>
    <span class="s3">/**</span>
     <span class="s3">* Cache that holds prefetched Flight responses keyed by url.</span>
     <span class="s3">*/</span>
    <span class="s1">prefetchCache: Map&lt;string, PrefetchCacheEntry&gt;;</span>
    <span class="s3">/**</span>
     <span class="s3">* Decides if the update should create a new history entry and if the navigation has to trigger a browser navigation.</span>
     <span class="s3">*/</span>
    <span class="s1">pushRef: PushRef;</span>
    <span class="s3">/**</span>
     <span class="s3">* Decides if the update should apply scroll and focus management.</span>
     <span class="s3">*/</span>
    <span class="s1">focusAndScrollRef: FocusAndScrollRef;</span>
    <span class="s3">/**</span>
     <span class="s3">* The canonical url that is pushed/replaced.</span>
     <span class="s3">* - This is the url you see in the browser.</span>
     <span class="s3">*/</span>
    <span class="s1">canonicalUrl: string;</span>
    <span class="s3">/**</span>
     <span class="s3">* The underlying &quot;url&quot; representing the UI state, which is used for intercepting routes.</span>
     <span class="s3">*/</span>
    <span class="s1">nextUrl: string | </span><span class="s0">null</span><span class="s1">;</span>
<span class="s1">};</span>
<span class="s0">export </span><span class="s1">type ReadonlyReducerState = Readonly&lt;AppRouterState&gt;;</span>
<span class="s0">export </span><span class="s1">type ReducerState = Promise&lt;AppRouterState&gt; | AppRouterState;</span>
<span class="s0">export </span><span class="s1">type ReducerActions = Readonly&lt;RefreshAction | NavigateAction | RestoreAction | ServerPatchAction | PrefetchAction | HmrRefreshAction | ServerActionAction&gt;;</span>
</pre>
</body>
</html>