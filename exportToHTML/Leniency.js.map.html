<html>
<head>
<title>Leniency.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
Leniency.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;Leniency.js&quot;</span><span class="s0">,</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;_parseDigits&quot;</span><span class="s0">,</span><span class="s1">&quot;_interopRequireDefault&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;_matchPhoneNumberStringAgainstPhoneNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;_metadata2&quot;</span><span class="s0">,</span><span class="s1">&quot;_getCountryByCallingCode&quot;</span><span class="s0">,</span><span class="s1">&quot;_format&quot;</span><span class="s0">,</span><span class="s1">&quot;_util&quot;</span><span class="s0">,</span><span class="s1">&quot;e&quot;</span><span class="s0">,</span><span class="s1">&quot;__esModule&quot;</span><span class="s0">,</span><span class="s1">&quot;_createForOfIteratorHelperLoose&quot;</span><span class="s0">,</span><span class="s1">&quot;r&quot;</span><span class="s0">,</span><span class="s1">&quot;t&quot;</span><span class="s0">,</span><span class="s1">&quot;Symbol&quot;</span><span class="s0">,</span><span class="s1">&quot;iterator&quot;</span><span class="s0">,</span><span class="s1">&quot;call&quot;</span><span class="s0">,</span><span class="s1">&quot;next&quot;</span><span class="s0">,</span><span class="s1">&quot;bind&quot;</span><span class="s0">,</span><span class="s1">&quot;Array&quot;</span><span class="s0">,</span><span class="s1">&quot;isArray&quot;</span><span class="s0">,</span><span class="s1">&quot;_unsupportedIterableToArray&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;o&quot;</span><span class="s0">,</span><span class="s1">&quot;done&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;TypeError&quot;</span><span class="s0">,</span><span class="s1">&quot;a&quot;</span><span class="s0">,</span><span class="s1">&quot;_arrayLikeToArray&quot;</span><span class="s0">,</span><span class="s1">&quot;toString&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;constructor&quot;</span><span class="s0">,</span><span class="s1">&quot;name&quot;</span><span class="s0">,</span><span class="s1">&quot;from&quot;</span><span class="s0">,</span><span class="s1">&quot;test&quot;</span><span class="s0">,</span><span class="s1">&quot;n&quot;</span><span class="s0">,</span><span class="s1">&quot;_default&quot;</span><span class="s0">,</span><span class="s1">&quot;exports&quot;</span><span class="s0">,</span><span class="s1">&quot;POSSIBLE&quot;</span><span class="s0">,</span><span class="s1">&quot;phoneNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;_ref&quot;</span><span class="s0">,</span><span class="s1">&quot;candidate&quot;</span><span class="s0">,</span><span class="s1">&quot;metadata&quot;</span><span class="s0">,</span><span class="s1">&quot;VALID&quot;</span><span class="s0">,</span><span class="s1">&quot;_ref2&quot;</span><span class="s0">,</span><span class="s1">&quot;defaultCountry&quot;</span><span class="s0">,</span><span class="s1">&quot;isValid&quot;</span><span class="s0">,</span><span class="s1">&quot;containsOnlyValidXChars&quot;</span><span class="s0">,</span><span class="s1">&quot;STRICT_GROUPING&quot;</span><span class="s0">,</span><span class="s1">&quot;_ref3&quot;</span><span class="s0">,</span><span class="s1">&quot;regExpCache&quot;</span><span class="s0">,</span><span class="s1">&quot;containsMoreThanOneSlashInNationalNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;isNationalPrefixPresentIfRequired&quot;</span><span class="s0">,</span><span class="s1">&quot;checkNumberGroupingIsValid&quot;</span><span class="s0">,</span><span class="s1">&quot;allNumberGroupsRemainGrouped&quot;</span><span class="s0">,</span><span class="s1">&quot;EXACT_GROUPING&quot;</span><span class="s0">,</span><span class="s1">&quot;_ref4&quot;</span><span class="s0">,</span><span class="s1">&quot;allNumberGroupsAreExactlyPresent&quot;</span><span class="s0">,</span><span class="s1">&quot;index&quot;</span><span class="s0">,</span><span class="s1">&quot;charAtIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;charAt&quot;</span><span class="s0">,</span><span class="s1">&quot;charAtNextIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;matchPhoneNumberStringAgainstPhoneNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;substring&quot;</span><span class="s0">,</span><span class="s1">&quot;ext&quot;</span><span class="s0">,</span><span class="s1">&quot;parseDigits&quot;</span><span class="s0">,</span><span class="s1">&quot;_ref5&quot;</span><span class="s0">,</span><span class="s1">&quot;_metadata&quot;</span><span class="s0">,</span><span class="s1">&quot;__countryCallingCodeSource&quot;</span><span class="s0">,</span><span class="s1">&quot;Metadata&quot;</span><span class="s0">,</span><span class="s1">&quot;selectNumberingPlan&quot;</span><span class="s0">,</span><span class="s1">&quot;countryCallingCode&quot;</span><span class="s0">,</span><span class="s1">&quot;phoneNumberRegion&quot;</span><span class="s0">,</span><span class="s1">&quot;country&quot;</span><span class="s0">,</span><span class="s1">&quot;getCountryByCallingCode&quot;</span><span class="s0">,</span><span class="s1">&quot;nationalNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;format&quot;</span><span class="s0">,</span><span class="s1">&quot;chooseFormatForNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;numberingPlan&quot;</span><span class="s0">,</span><span class="s1">&quot;formats&quot;</span><span class="s0">,</span><span class="s1">&quot;nationalPrefixFormattingRule&quot;</span><span class="s0">,</span><span class="s1">&quot;nationalPrefixIsOptionalWhenFormattingInNationalFormat&quot;</span><span class="s0">,</span><span class="s1">&quot;usesNationalPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;Boolean&quot;</span><span class="s0">,</span><span class="s1">&quot;nationalPrefix&quot;</span><span class="s0">,</span><span class="s1">&quot;firstSlashInBodyIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;indexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;secondSlashInBodyIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;candidateHasCountryCode&quot;</span><span class="s0">,</span><span class="s1">&quot;number&quot;</span><span class="s0">,</span><span class="s1">&quot;checkGroups&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedCandidate&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizeDigits&quot;</span><span class="s0">,</span><span class="s1">&quot;formattedNumberGroups&quot;</span><span class="s0">,</span><span class="s1">&quot;getNationalNumberGroups&quot;</span><span class="s0">,</span><span class="s1">&quot;alternateFormats&quot;</span><span class="s0">,</span><span class="s1">&quot;MetadataManager&quot;</span><span class="s0">,</span><span class="s1">&quot;getAlternateFormatsForCountry&quot;</span><span class="s0">,</span><span class="s1">&quot;getCountryCode&quot;</span><span class="s0">,</span><span class="s1">&quot;nationalSignificantNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;util&quot;</span><span class="s0">,</span><span class="s1">&quot;getNationalSignificantNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;_iterator&quot;</span><span class="s0">,</span><span class="s1">&quot;numberFormats&quot;</span><span class="s0">,</span><span class="s1">&quot;_step&quot;</span><span class="s0">,</span><span class="s1">&quot;alternateFormat&quot;</span><span class="s0">,</span><span class="s1">&quot;leadingDigitsPatterns&quot;</span><span class="s0">,</span><span class="s1">&quot;leadingDigitsRegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;getPatternForRegExp&quot;</span><span class="s0">,</span><span class="s1">&quot;formattingPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;formatNsnUsingPattern&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;rfc3966Format&quot;</span><span class="s0">,</span><span class="s1">&quot;formatNumber&quot;</span><span class="s0">,</span><span class="s1">&quot;endIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;startIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;candidateGroups&quot;</span><span class="s0">,</span><span class="s1">&quot;NON_DIGITS_PATTERN&quot;</span><span class="s0">,</span><span class="s1">&quot;candidateNumberGroupIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;hasExtension&quot;</span><span class="s0">,</span><span class="s1">&quot;contains&quot;</span><span class="s0">,</span><span class="s1">&quot;formattedNumberGroupIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;endsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;fromIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;getCountryCodeSource&quot;</span><span class="s0">,</span><span class="s1">&quot;CountryCodeSource&quot;</span><span class="s0">,</span><span class="s1">&quot;FROM_DEFAULT_COUNTRY&quot;</span><span class="s0">,</span><span class="s1">&quot;countryCode&quot;</span><span class="s0">,</span><span class="s1">&quot;String&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;region&quot;</span><span class="s0">,</span><span class="s1">&quot;getRegionCodeForCountryCode&quot;</span><span class="s0">,</span><span class="s1">&quot;getNddPrefixForRegion&quot;</span><span class="s0">,</span><span class="s1">&quot;Character&quot;</span><span class="s0">,</span><span class="s1">&quot;isDigit&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;getExtension&quot;</span><span class="s0">],</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../source/findNumbers/Leniency.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import parseDigits from '../helpers/parseDigits.js'</span><span class="s3">\r\n</span><span class="s1">import matchPhoneNumberStringAgainstPhoneNumber from './matchPhoneNumberStringAgainstPhoneNumber.js'</span><span class="s3">\r\n</span><span class="s1">import Metadata from '../metadata.js'</span><span class="s3">\r\n</span><span class="s1">import getCountryByCallingCode from '../helpers/getCountryByCallingCode.js'</span><span class="s3">\r\n</span><span class="s1">import { chooseFormatForNumber } from '../format.js'</span><span class="s3">\r\n\r\n</span><span class="s1">import {</span><span class="s3">\r\n\t</span><span class="s1">startsWith,</span><span class="s3">\r\n\t</span><span class="s1">endsWith</span><span class="s3">\r\n</span><span class="s1">} from './util.js'</span><span class="s3">\r\n\r\n</span><span class="s1">/**</span><span class="s3">\r\n </span><span class="s1">* Leniency when finding potential phone numbers in text segments</span><span class="s3">\r\n </span><span class="s1">* The levels here are ordered in increasing strictness.</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\r\n</span><span class="s1">export default</span><span class="s3">\r\n</span><span class="s1">{</span><span class="s3">\r\n\t</span><span class="s1">/**</span><span class="s3">\r\n\t </span><span class="s1">* Phone numbers accepted are </span><span class="s3">\&quot;</span><span class="s1">possible</span><span class="s3">\&quot;</span><span class="s1">, but not necessarily </span><span class="s3">\&quot;</span><span class="s1">valid</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\r\n\t </span><span class="s1">*/</span><span class="s3">\r\n\t</span><span class="s1">POSSIBLE(phoneNumber, { candidate, metadata })</span><span class="s3">\r\n\t</span><span class="s1">{</span><span class="s3">\r\n\t\t</span><span class="s1">return true</span><span class="s3">\r\n\t</span><span class="s1">},</span><span class="s3">\r\n\r\n\t</span><span class="s1">/**</span><span class="s3">\r\n\t </span><span class="s1">* Phone numbers accepted are </span><span class="s3">\&quot;</span><span class="s1">possible</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">valid</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\r\n\t </span><span class="s1">* Numbers written in national format must have their national-prefix</span><span class="s3">\r\n\t </span><span class="s1">* present if it is usually written for a number of this type.</span><span class="s3">\r\n\t </span><span class="s1">*/</span><span class="s3">\r\n\t</span><span class="s1">VALID(phoneNumber, { candidate, defaultCountry, metadata })</span><span class="s3">\r\n\t</span><span class="s1">{</span><span class="s3">\r\n\t\t</span><span class="s1">if (</span><span class="s3">\r\n\t\t\t</span><span class="s1">!phoneNumber.isValid() ||</span><span class="s3">\r\n\t\t\t</span><span class="s1">!containsOnlyValidXChars(phoneNumber, candidate, metadata)</span><span class="s3">\r\n\t\t</span><span class="s1">)</span><span class="s3">\r\n\t\t</span><span class="s1">{</span><span class="s3">\r\n\t\t\t</span><span class="s1">return false</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">// Skipped for simplicity.</span><span class="s3">\r\n\t\t</span><span class="s1">// return isNationalPrefixPresentIfRequired(phoneNumber, { defaultCountry, metadata })</span><span class="s3">\r\n\t\t</span><span class="s1">return true</span><span class="s3">\r\n\t</span><span class="s1">},</span><span class="s3">\r\n\r\n\t</span><span class="s1">/**</span><span class="s3">\r\n\t </span><span class="s1">* Phone numbers accepted are </span><span class="s3">\&quot;</span><span class="s1">valid</span><span class="s3">\&quot; </span><span class="s1">and</span><span class="s3">\r\n\t </span><span class="s1">* are grouped in a possible way for this locale. For example, a US number written as</span><span class="s3">\r\n\t </span><span class="s1">* </span><span class="s3">\&quot;</span><span class="s1">65 02 53 00 00</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">650253 0000</span><span class="s3">\&quot; </span><span class="s1">are not accepted at this leniency level, whereas</span><span class="s3">\r\n\t </span><span class="s1">* </span><span class="s3">\&quot;</span><span class="s1">650 253 0000</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">650 2530000</span><span class="s3">\&quot; </span><span class="s1">or </span><span class="s3">\&quot;</span><span class="s1">6502530000</span><span class="s3">\&quot; </span><span class="s1">are.</span><span class="s3">\r\n\t </span><span class="s1">* Numbers with more than one '/' symbol in the national significant number</span><span class="s3">\r\n\t </span><span class="s1">* are also dropped at this level.</span><span class="s3">\r\n\t </span><span class="s1">*</span><span class="s3">\r\n\t </span><span class="s1">* Warning: This level might result in lower coverage especially for regions outside of</span><span class="s3">\r\n\t </span><span class="s1">* country code </span><span class="s3">\&quot;</span><span class="s1">+1</span><span class="s3">\&quot;</span><span class="s1">. If you are not sure about which level to use,</span><span class="s3">\r\n\t </span><span class="s1">* email the discussion group libphonenumber-discuss@googlegroups.com.</span><span class="s3">\r\n\t </span><span class="s1">*/</span><span class="s3">\r\n\t</span><span class="s1">STRICT_GROUPING(phoneNumber, { candidate, defaultCountry, metadata, regExpCache })</span><span class="s3">\r\n\t</span><span class="s1">{</span><span class="s3">\r\n\t\t</span><span class="s1">if (</span><span class="s3">\r\n\t\t\t</span><span class="s1">!phoneNumber.isValid() ||</span><span class="s3">\r\n\t\t\t</span><span class="s1">!containsOnlyValidXChars(phoneNumber, candidate, metadata) ||</span><span class="s3">\r\n\t\t\t</span><span class="s1">containsMoreThanOneSlashInNationalNumber(phoneNumber, candidate) ||</span><span class="s3">\r\n\t\t\t</span><span class="s1">!isNationalPrefixPresentIfRequired(phoneNumber, { defaultCountry, metadata })</span><span class="s3">\r\n\t\t</span><span class="s1">)</span><span class="s3">\r\n\t\t</span><span class="s1">{</span><span class="s3">\r\n\t\t\t</span><span class="s1">return false</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">return checkNumberGroupingIsValid</span><span class="s3">\r\n\t\t</span><span class="s1">(</span><span class="s3">\r\n\t\t\t</span><span class="s1">phoneNumber,</span><span class="s3">\r\n\t\t\t</span><span class="s1">candidate,</span><span class="s3">\r\n\t\t\t</span><span class="s1">metadata,</span><span class="s3">\r\n\t\t\t</span><span class="s1">allNumberGroupsRemainGrouped,</span><span class="s3">\r\n\t\t\t</span><span class="s1">regExpCache</span><span class="s3">\r\n\t\t</span><span class="s1">)</span><span class="s3">\r\n\t</span><span class="s1">},</span><span class="s3">\r\n\r\n\t</span><span class="s1">/**</span><span class="s3">\r\n\t </span><span class="s1">* Phone numbers accepted are </span><span class="s3">\&quot;</span><span class="s1">valid</span><span class="s3">\&quot; </span><span class="s1">and are grouped in the same way</span><span class="s3">\r\n\t </span><span class="s1">* that we would have formatted it, or as a single block.</span><span class="s3">\r\n\t </span><span class="s1">* For example, a US number written as </span><span class="s3">\&quot;</span><span class="s1">650 2530000</span><span class="s3">\&quot; </span><span class="s1">is not accepted</span><span class="s3">\r\n\t </span><span class="s1">* at this leniency level, whereas </span><span class="s3">\&quot;</span><span class="s1">650 253 0000</span><span class="s3">\&quot; </span><span class="s1">or </span><span class="s3">\&quot;</span><span class="s1">6502530000</span><span class="s3">\&quot; </span><span class="s1">are.</span><span class="s3">\r\n\t </span><span class="s1">* Numbers with more than one '/' symbol are also dropped at this level.</span><span class="s3">\r\n\t </span><span class="s1">*</span><span class="s3">\r\n\t </span><span class="s1">* Warning: This level might result in lower coverage especially for regions outside of</span><span class="s3">\r\n\t </span><span class="s1">* country code </span><span class="s3">\&quot;</span><span class="s1">+1</span><span class="s3">\&quot;</span><span class="s1">. If you are not sure about which level to use, email the discussion group</span><span class="s3">\r\n\t </span><span class="s1">* libphonenumber-discuss@googlegroups.com.</span><span class="s3">\r\n\t </span><span class="s1">*/</span><span class="s3">\r\n\t</span><span class="s1">EXACT_GROUPING(phoneNumber, { candidate, defaultCountry, metadata, regExpCache })</span><span class="s3">\r\n\t</span><span class="s1">{</span><span class="s3">\r\n\t\t</span><span class="s1">if (</span><span class="s3">\r\n\t\t\t</span><span class="s1">!phoneNumber.isValid() ||</span><span class="s3">\r\n\t\t\t</span><span class="s1">!containsOnlyValidXChars(phoneNumber, candidate, metadata) ||</span><span class="s3">\r\n\t\t\t</span><span class="s1">containsMoreThanOneSlashInNationalNumber(phoneNumber, candidate) ||</span><span class="s3">\r\n\t\t\t</span><span class="s1">!isNationalPrefixPresentIfRequired(phoneNumber, { defaultCountry, metadata })</span><span class="s3">\r\n\t\t</span><span class="s1">)</span><span class="s3">\r\n\t\t</span><span class="s1">{</span><span class="s3">\r\n\t\t\t</span><span class="s1">return false</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">return checkNumberGroupingIsValid</span><span class="s3">\r\n\t\t</span><span class="s1">(</span><span class="s3">\r\n\t\t\t</span><span class="s1">phoneNumber,</span><span class="s3">\r\n\t\t\t</span><span class="s1">candidate,</span><span class="s3">\r\n\t\t\t</span><span class="s1">metadata,</span><span class="s3">\r\n\t\t\t</span><span class="s1">allNumberGroupsAreExactlyPresent,</span><span class="s3">\r\n\t\t\t</span><span class="s1">regExpCache</span><span class="s3">\r\n\t\t</span><span class="s1">)</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n</span><span class="s1">}</span><span class="s3">\r\n\r\n</span><span class="s1">function containsOnlyValidXChars(phoneNumber, candidate, metadata)</span><span class="s3">\r\n</span><span class="s1">{</span><span class="s3">\r\n\t</span><span class="s1">// The characters 'x' and 'X' can be (1) a carrier code, in which case they always precede the</span><span class="s3">\r\n\t</span><span class="s1">// national significant number or (2) an extension sign, in which case they always precede the</span><span class="s3">\r\n\t</span><span class="s1">// extension number. We assume a carrier code is more than 1 digit, so the first case has to</span><span class="s3">\r\n\t</span><span class="s1">// have more than 1 consecutive 'x' or 'X', whereas the second case can only have exactly 1 'x'</span><span class="s3">\r\n\t</span><span class="s1">// or 'X'. We ignore the character if it appears as the last character of the string.</span><span class="s3">\r\n\t</span><span class="s1">for (let index = 0; index &lt; candidate.length - 1; index++)</span><span class="s3">\r\n\t</span><span class="s1">{</span><span class="s3">\r\n\t\t</span><span class="s1">const charAtIndex = candidate.charAt(index)</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">if (charAtIndex === 'x' || charAtIndex === 'X')</span><span class="s3">\r\n\t\t</span><span class="s1">{</span><span class="s3">\r\n\t\t\t</span><span class="s1">const charAtNextIndex = candidate.charAt(index + 1)</span><span class="s3">\r\n\r\n\t\t\t</span><span class="s1">if (charAtNextIndex === 'x' || charAtNextIndex === 'X')</span><span class="s3">\r\n\t\t\t</span><span class="s1">{</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// This is the carrier code case, in which the 'X's always precede the national</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// significant number.</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">index++</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">if (matchPhoneNumberStringAgainstPhoneNumber(candidate.substring(index), phoneNumber, metadata) !== 'NSN_MATCH')</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">{</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">return false</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// This is the extension sign case, in which the 'x' or 'X' should always precede the</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// extension number.</span><span class="s3">\r\n\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t</span><span class="s1">else {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">const ext = parseDigits(candidate.substring(index))</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">if (ext) {</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">if (phoneNumber.ext !== ext)  {</span><span class="s3">\r\n\t\t\t\t\t\t</span><span class="s1">return false</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">} else {</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">if (phoneNumber.ext) {</span><span class="s3">\r\n\t\t\t\t\t\t</span><span class="s1">return false</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">return true</span><span class="s3">\r\n</span><span class="s1">}</span><span class="s3">\r\n\r\n</span><span class="s1">function isNationalPrefixPresentIfRequired(phoneNumber, { defaultCountry, metadata: _metadata })</span><span class="s3">\r\n</span><span class="s1">{</span><span class="s3">\r\n\t</span><span class="s1">// First, check how we deduced the country code. If it was written in international format, then</span><span class="s3">\r\n\t</span><span class="s1">// the national prefix is not required.</span><span class="s3">\r\n\t</span><span class="s1">if (phoneNumber.__countryCallingCodeSource !== 'FROM_DEFAULT_COUNTRY')</span><span class="s3">\r\n\t</span><span class="s1">{</span><span class="s3">\r\n\t\t</span><span class="s1">return true</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">const metadata = new Metadata(_metadata)</span><span class="s3">\r\n\t</span><span class="s1">metadata.selectNumberingPlan(phoneNumber.countryCallingCode)</span><span class="s3">\r\n\r\n\t</span><span class="s1">const phoneNumberRegion = phoneNumber.country || getCountryByCallingCode(phoneNumber.countryCallingCode, {</span><span class="s3">\r\n\t\t</span><span class="s1">nationalNumber: phoneNumber.nationalNumber,</span><span class="s3">\r\n\t\t</span><span class="s1">metadata</span><span class="s3">\r\n\t</span><span class="s1">})</span><span class="s3">\r\n\r\n\t</span><span class="s1">// Check if a national prefix should be present when formatting this number.</span><span class="s3">\r\n\t</span><span class="s1">const nationalNumber = phoneNumber.nationalNumber</span><span class="s3">\r\n\t</span><span class="s1">const format = chooseFormatForNumber(metadata.numberingPlan.formats(), nationalNumber)</span><span class="s3">\r\n\r\n\t</span><span class="s1">// To do this, we check that a national prefix formatting rule was present</span><span class="s3">\r\n\t</span><span class="s1">// and that it wasn't just the first-group symbol ($1) with punctuation.</span><span class="s3">\r\n\t</span><span class="s1">if (format.nationalPrefixFormattingRule())</span><span class="s3">\r\n\t</span><span class="s1">{</span><span class="s3">\r\n\t\t</span><span class="s1">if (metadata.numberingPlan.nationalPrefixIsOptionalWhenFormattingInNationalFormat())</span><span class="s3">\r\n\t\t</span><span class="s1">{</span><span class="s3">\r\n\t\t\t</span><span class="s1">// The national-prefix is optional in these cases, so we don't need to check if it was present.</span><span class="s3">\r\n\t\t\t</span><span class="s1">return true</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">if (!format.usesNationalPrefix())</span><span class="s3">\r\n\t\t</span><span class="s1">{</span><span class="s3">\r\n\t\t\t</span><span class="s1">// National Prefix not needed for this number.</span><span class="s3">\r\n\t\t\t</span><span class="s1">return true</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t\t</span><span class="s1">return Boolean(phoneNumber.nationalPrefix)</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">return true</span><span class="s3">\r\n</span><span class="s1">}</span><span class="s3">\r\n\r\n</span><span class="s1">export function containsMoreThanOneSlashInNationalNumber(phoneNumber, candidate)</span><span class="s3">\r\n</span><span class="s1">{</span><span class="s3">\r\n\t</span><span class="s1">const firstSlashInBodyIndex = candidate.indexOf('/')</span><span class="s3">\r\n\t</span><span class="s1">if (firstSlashInBodyIndex &lt; 0)</span><span class="s3">\r\n\t</span><span class="s1">{</span><span class="s3">\r\n\t\t</span><span class="s1">// No slashes, this is okay.</span><span class="s3">\r\n\t\t</span><span class="s1">return false</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">// Now look for a second one.</span><span class="s3">\r\n\t</span><span class="s1">const secondSlashInBodyIndex = candidate.indexOf('/', firstSlashInBodyIndex + 1)</span><span class="s3">\r\n\t</span><span class="s1">if (secondSlashInBodyIndex &lt; 0)</span><span class="s3">\r\n\t</span><span class="s1">{</span><span class="s3">\r\n\t\t</span><span class="s1">// Only one slash, this is okay.</span><span class="s3">\r\n\t\t</span><span class="s1">return false</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">// If the first slash is after the country calling code, this is permitted.</span><span class="s3">\r\n\t</span><span class="s1">const candidateHasCountryCode =</span><span class="s3">\r\n\t\t\t</span><span class="s1">phoneNumber.__countryCallingCodeSource === 'FROM_NUMBER_WITH_PLUS_SIGN' ||</span><span class="s3">\r\n\t\t\t</span><span class="s1">phoneNumber.__countryCallingCodeSource === 'FROM_NUMBER_WITHOUT_PLUS_SIGN'</span><span class="s3">\r\n\r\n\t</span><span class="s1">if (candidateHasCountryCode &amp;&amp; parseDigits(candidate.substring(0, firstSlashInBodyIndex)) === phoneNumber.countryCallingCode)</span><span class="s3">\r\n\t</span><span class="s1">{</span><span class="s3">\r\n\t\t</span><span class="s1">// Any more slashes and this is illegal.</span><span class="s3">\r\n\t\t</span><span class="s1">return candidate.slice(secondSlashInBodyIndex + 1).indexOf('/') &gt;= 0</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">return true</span><span class="s3">\r\n</span><span class="s1">}</span><span class="s3">\r\n\r\n</span><span class="s1">function checkNumberGroupingIsValid(</span><span class="s3">\r\n\t</span><span class="s1">number,</span><span class="s3">\r\n\t</span><span class="s1">candidate,</span><span class="s3">\r\n\t</span><span class="s1">metadata,</span><span class="s3">\r\n\t</span><span class="s1">checkGroups,</span><span class="s3">\r\n\t</span><span class="s1">regExpCache</span><span class="s3">\r\n</span><span class="s1">) {</span><span class="s3">\r\n\t</span><span class="s1">throw new Error('This part of code hasn</span><span class="s3">\\</span><span class="s1">'t been ported')</span><span class="s3">\r\n\r\n\t</span><span class="s1">const normalizedCandidate = normalizeDigits(candidate, true /* keep non-digits */)</span><span class="s3">\r\n\t</span><span class="s1">let formattedNumberGroups = getNationalNumberGroups(metadata, number, null)</span><span class="s3">\r\n\t</span><span class="s1">if (checkGroups(metadata, number, normalizedCandidate, formattedNumberGroups)) {</span><span class="s3">\r\n\t\t</span><span class="s1">return true</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">// If this didn't pass, see if there are any alternate formats that match, and try them instead.</span><span class="s3">\r\n\t</span><span class="s1">const alternateFormats = MetadataManager.getAlternateFormatsForCountry(number.getCountryCode())</span><span class="s3">\r\n\t</span><span class="s1">const nationalSignificantNumber = util.getNationalSignificantNumber(number)</span><span class="s3">\r\n\r\n\t</span><span class="s1">if (alternateFormats) {</span><span class="s3">\r\n\t\t</span><span class="s1">for (const alternateFormat of alternateFormats.numberFormats()) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">if (alternateFormat.leadingDigitsPatterns().length &gt; 0) {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// There is only one leading digits pattern for alternate formats.</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">const leadingDigitsRegExp = regExpCache.getPatternForRegExp('^' + alternateFormat.leadingDigitsPatterns()[0])</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">if (!leadingDigitsRegExp.test(nationalSignificantNumber)) {</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">// Leading digits don't match; try another one.</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">continue</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t\t</span><span class="s1">formattedNumberGroups = getNationalNumberGroups(metadata, number, alternateFormat)</span><span class="s3">\r\n\t\t\t</span><span class="s1">if (checkGroups(metadata, number, normalizedCandidate, formattedNumberGroups)) {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">return true</span><span class="s3">\r\n\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">return false</span><span class="s3">\r\n</span><span class="s1">}</span><span class="s3">\r\n\r\n</span><span class="s1">/**</span><span class="s3">\r\n </span><span class="s1">* Helper method to get the national-number part of a number, formatted without any national</span><span class="s3">\r\n </span><span class="s1">* prefix, and return it as a set of digit blocks that would be formatted together following</span><span class="s3">\r\n </span><span class="s1">* standard formatting rules.</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\r\n</span><span class="s1">function getNationalNumberGroups(</span><span class="s3">\r\n\t</span><span class="s1">metadata,</span><span class="s3">\r\n\t</span><span class="s1">number,</span><span class="s3">\r\n\t</span><span class="s1">formattingPattern</span><span class="s3">\r\n</span><span class="s1">) {</span><span class="s3">\r\n\t</span><span class="s1">throw new Error('This part of code hasn</span><span class="s3">\\</span><span class="s1">'t been ported')</span><span class="s3">\r\n\r\n\t</span><span class="s1">if (formattingPattern) {</span><span class="s3">\r\n\t\t</span><span class="s1">// We format the NSN only, and split that according to the separator.</span><span class="s3">\r\n\t\t</span><span class="s1">const nationalSignificantNumber = util.getNationalSignificantNumber(number)</span><span class="s3">\r\n\t\t</span><span class="s1">return util.formatNsnUsingPattern(nationalSignificantNumber,</span><span class="s3">\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</span><span class="s1">formattingPattern, 'RFC3966', metadata).split('-')</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">// This will be in the format +CC-DG1-DG2-DGX;ext=EXT where DG1..DGX represents groups of digits.</span><span class="s3">\r\n\t</span><span class="s1">const rfc3966Format = formatNumber(number, 'RFC3966', metadata)</span><span class="s3">\r\n\r\n\t</span><span class="s1">// We remove the extension part from the formatted string before splitting it into different</span><span class="s3">\r\n\t</span><span class="s1">// groups.</span><span class="s3">\r\n\t</span><span class="s1">let endIndex = rfc3966Format.indexOf(';')</span><span class="s3">\r\n\t</span><span class="s1">if (endIndex &lt; 0) {</span><span class="s3">\r\n\t\t</span><span class="s1">endIndex = rfc3966Format.length</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">// The country-code will have a '-' following it.</span><span class="s3">\r\n\t</span><span class="s1">const startIndex = rfc3966Format.indexOf('-') + 1</span><span class="s3">\r\n\t</span><span class="s1">return rfc3966Format.slice(startIndex, endIndex).split('-')</span><span class="s3">\r\n</span><span class="s1">}</span><span class="s3">\r\n\r\n</span><span class="s1">function allNumberGroupsAreExactlyPresent</span><span class="s3">\r\n</span><span class="s1">(</span><span class="s3">\r\n\t</span><span class="s1">metadata,</span><span class="s3">\r\n\t</span><span class="s1">number,</span><span class="s3">\r\n\t</span><span class="s1">normalizedCandidate,</span><span class="s3">\r\n\t</span><span class="s1">formattedNumberGroups</span><span class="s3">\r\n</span><span class="s1">)</span><span class="s3">\r\n</span><span class="s1">{</span><span class="s3">\r\n\t</span><span class="s1">throw new Error('This part of code hasn</span><span class="s3">\\</span><span class="s1">'t been ported')</span><span class="s3">\r\n\r\n\t</span><span class="s1">const candidateGroups = normalizedCandidate.split(NON_DIGITS_PATTERN)</span><span class="s3">\r\n\r\n\t</span><span class="s1">// Set this to the last group, skipping it if the number has an extension.</span><span class="s3">\r\n\t</span><span class="s1">let candidateNumberGroupIndex =</span><span class="s3">\r\n\t\t\t</span><span class="s1">number.hasExtension() ? candidateGroups.length - 2 : candidateGroups.length - 1</span><span class="s3">\r\n\r\n\t</span><span class="s1">// First we check if the national significant number is formatted as a block.</span><span class="s3">\r\n\t</span><span class="s1">// We use contains and not equals, since the national significant number may be present with</span><span class="s3">\r\n\t</span><span class="s1">// a prefix such as a national number prefix, or the country code itself.</span><span class="s3">\r\n\t</span><span class="s1">if (candidateGroups.length == 1</span><span class="s3">\r\n\t\t\t</span><span class="s1">|| candidateGroups[candidateNumberGroupIndex].contains(</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">util.getNationalSignificantNumber(number)))</span><span class="s3">\r\n\t</span><span class="s1">{</span><span class="s3">\r\n\t\t</span><span class="s1">return true</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">// Starting from the end, go through in reverse, excluding the first group, and check the</span><span class="s3">\r\n\t</span><span class="s1">// candidate and number groups are the same.</span><span class="s3">\r\n\t</span><span class="s1">let formattedNumberGroupIndex = (formattedNumberGroups.length - 1)</span><span class="s3">\r\n\t</span><span class="s1">while (formattedNumberGroupIndex &gt; 0 &amp;&amp; candidateNumberGroupIndex &gt;= 0)</span><span class="s3">\r\n\t</span><span class="s1">{</span><span class="s3">\r\n\t\t</span><span class="s1">if (candidateGroups[candidateNumberGroupIndex] !== formattedNumberGroups[formattedNumberGroupIndex])</span><span class="s3">\r\n\t\t</span><span class="s1">{</span><span class="s3">\r\n\t\t\t</span><span class="s1">return false</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">formattedNumberGroupIndex--</span><span class="s3">\r\n\t\t</span><span class="s1">candidateNumberGroupIndex--</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">// Now check the first group. There may be a national prefix at the start, so we only check</span><span class="s3">\r\n\t</span><span class="s1">// that the candidate group ends with the formatted number group.</span><span class="s3">\r\n\t</span><span class="s1">return (candidateNumberGroupIndex &gt;= 0</span><span class="s3">\r\n\t\t\t</span><span class="s1">&amp;&amp; endsWith(candidateGroups[candidateNumberGroupIndex], formattedNumberGroups[0]))</span><span class="s3">\r\n</span><span class="s1">}</span><span class="s3">\r\n\r\n\r\n</span><span class="s1">function allNumberGroupsRemainGrouped</span><span class="s3">\r\n</span><span class="s1">(</span><span class="s3">\r\n\t</span><span class="s1">metadata,</span><span class="s3">\r\n\t</span><span class="s1">number,</span><span class="s3">\r\n\t</span><span class="s1">normalizedCandidate,</span><span class="s3">\r\n\t</span><span class="s1">formattedNumberGroups</span><span class="s3">\r\n</span><span class="s1">)</span><span class="s3">\r\n</span><span class="s1">{</span><span class="s3">\r\n\t</span><span class="s1">throw new Error('This part of code hasn</span><span class="s3">\\</span><span class="s1">'t been ported')</span><span class="s3">\r\n\r\n\t</span><span class="s1">let fromIndex = 0</span><span class="s3">\r\n\t</span><span class="s1">if (number.getCountryCodeSource() !== CountryCodeSource.FROM_DEFAULT_COUNTRY)</span><span class="s3">\r\n\t</span><span class="s1">{</span><span class="s3">\r\n\t\t</span><span class="s1">// First skip the country code if the normalized candidate contained it.</span><span class="s3">\r\n\t\t</span><span class="s1">const countryCode = String(number.getCountryCode())</span><span class="s3">\r\n\t\t</span><span class="s1">fromIndex = normalizedCandidate.indexOf(countryCode) + countryCode.length()</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">// Check each group of consecutive digits are not broken into separate groupings in the</span><span class="s3">\r\n\t</span><span class="s1">// {@code normalizedCandidate} string.</span><span class="s3">\r\n\t</span><span class="s1">for (let i = 0; i &lt; formattedNumberGroups.length; i++)</span><span class="s3">\r\n\t</span><span class="s1">{</span><span class="s3">\r\n\t\t</span><span class="s1">// Fails if the substring of {@code normalizedCandidate} starting from {@code fromIndex}</span><span class="s3">\r\n\t\t</span><span class="s1">// doesn't contain the consecutive digits in formattedNumberGroups[i].</span><span class="s3">\r\n\t\t</span><span class="s1">fromIndex = normalizedCandidate.indexOf(formattedNumberGroups[i], fromIndex)</span><span class="s3">\r\n\t\t</span><span class="s1">if (fromIndex &lt; 0) {</span><span class="s3">\r\n\t\t\t</span><span class="s1">return false</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">// Moves {@code fromIndex} forward.</span><span class="s3">\r\n\t\t</span><span class="s1">fromIndex += formattedNumberGroups[i].length()</span><span class="s3">\r\n\t\t</span><span class="s1">if (i == 0 &amp;&amp; fromIndex &lt; normalizedCandidate.length())</span><span class="s3">\r\n\t\t</span><span class="s1">{</span><span class="s3">\r\n\t\t\t</span><span class="s1">// We are at the position right after the NDC. We get the region used for formatting</span><span class="s3">\r\n\t\t\t</span><span class="s1">// information based on the country code in the phone number, rather than the number itself,</span><span class="s3">\r\n\t\t\t</span><span class="s1">// as we do not need to distinguish between different countries with the same country</span><span class="s3">\r\n\t\t\t</span><span class="s1">// calling code and this is faster.</span><span class="s3">\r\n\t\t\t</span><span class="s1">const region = util.getRegionCodeForCountryCode(number.getCountryCode())</span><span class="s3">\r\n\t\t\t</span><span class="s1">if (util.getNddPrefixForRegion(region, true) != null</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">&amp;&amp; Character.isDigit(normalizedCandidate.charAt(fromIndex))) {</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// This means there is no formatting symbol after the NDC. In this case, we only</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// accept the number if there is no formatting symbol at all in the number, except</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">// for extensions. This is only important for countries with national prefixes.</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">const nationalSignificantNumber = util.getNationalSignificantNumber(number)</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">return startsWith</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">(</span><span class="s3">\r\n\t\t\t\t\t</span><span class="s1">normalizedCandidate.slice(fromIndex - formattedNumberGroups[i].length),</span><span class="s3">\r\n\t\t\t\t\t </span><span class="s1">nationalSignificantNumber</span><span class="s3">\r\n\t\t\t\t</span><span class="s1">)</span><span class="s3">\r\n\t\t\t</span><span class="s1">}</span><span class="s3">\r\n\t\t</span><span class="s1">}</span><span class="s3">\r\n\t</span><span class="s1">}</span><span class="s3">\r\n\r\n\t</span><span class="s1">// The check here makes sure that we haven't mistakenly already used the extension to</span><span class="s3">\r\n\t</span><span class="s1">// match the last group of the subscriber number. Note the extension cannot have</span><span class="s3">\r\n\t</span><span class="s1">// formatting in-between digits.</span><span class="s3">\r\n\t</span><span class="s1">return normalizedCandidate.slice(fromIndex).contains(number.getExtension())</span><span class="s3">\r\n</span><span class="s1">}&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[]}</span></pre>
</body>
</html>