<html>
<head>
<title>middleware-turbopack.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
middleware-turbopack.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/server/dev/middleware-turbopack.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import type { IncomingMessage, ServerResponse } from 'http'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">getOriginalCodeFrame,</span><span class="s3">\n  </span><span class="s1">ignoreListAnonymousStackFramesIfSandwiched,</span><span class="s3">\n  </span><span class="s1">type IgnorableStackFrame,</span><span class="s3">\n  </span><span class="s1">type OriginalStackFrameResponse,</span><span class="s3">\n  </span><span class="s1">type OriginalStackFramesRequest,</span><span class="s3">\n  </span><span class="s1">type OriginalStackFramesResponse,</span><span class="s3">\n  </span><span class="s1">type StackFrame,</span><span class="s3">\n</span><span class="s1">} from '../../next-devtools/server/shared'</span><span class="s3">\n</span><span class="s1">import { middlewareResponse } from '../../next-devtools/server/middleware-response'</span><span class="s3">\n</span><span class="s1">import path from 'path'</span><span class="s3">\n</span><span class="s1">import { openFileInEditor } from '../../next-devtools/server/launch-editor'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">SourceMapConsumer,</span><span class="s3">\n  </span><span class="s1">type NullableMappedPosition,</span><span class="s3">\n</span><span class="s1">} from 'next/dist/compiled/source-map08'</span><span class="s3">\n</span><span class="s1">import type { Project, TurbopackStackFrame } from '../../build/swc/types'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">type ModernSourceMapPayload,</span><span class="s3">\n  </span><span class="s1">devirtualizeReactServerURL,</span><span class="s3">\n  </span><span class="s1">findApplicableSourceMapPayload,</span><span class="s3">\n</span><span class="s1">} from '../lib/source-maps'</span><span class="s3">\n</span><span class="s1">import { findSourceMap, type SourceMap } from 'node:module'</span><span class="s3">\n</span><span class="s1">import { fileURLToPath, pathToFileURL } from 'node:url'</span><span class="s3">\n</span><span class="s1">import { inspect } from 'node:util'</span><span class="s3">\n\n</span><span class="s1">function shouldIgnorePath(modulePath: string): boolean {</span><span class="s3">\n  </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">modulePath.includes('node_modules') ||</span><span class="s3">\n    </span><span class="s1">// Only relevant for when Next.js is symlinked e.g. in the Next.js monorepo</span><span class="s3">\n    </span><span class="s1">modulePath.includes('next/dist') ||</span><span class="s3">\n    </span><span class="s1">modulePath.startsWith('node:')</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const currentSourcesByFile: Map&lt;string, Promise&lt;string | null&gt;&gt; = new Map()</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @returns 1-based lines and 1-based columns</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">async function batchedTraceSource(</span><span class="s3">\n  </span><span class="s1">project: Project,</span><span class="s3">\n  </span><span class="s1">frame: TurbopackStackFrame</span><span class="s3">\n</span><span class="s1">): Promise&lt;{ frame: IgnorableStackFrame; source: string | null } | undefined&gt; {</span><span class="s3">\n  </span><span class="s1">const file = frame.file</span><span class="s3">\n    </span><span class="s1">? // TODO(veil): Why are the frames sent encoded?</span><span class="s3">\n      </span><span class="s1">decodeURIComponent(frame.file)</span><span class="s3">\n    </span><span class="s1">: undefined</span><span class="s3">\n\n  </span><span class="s1">if (!file) return</span><span class="s3">\n\n  </span><span class="s1">// For node internals they cannot traced the actual source code with project.traceSource,</span><span class="s3">\n  </span><span class="s1">// we need an early return to indicate it's ignored to avoid the unknown scheme error from `project.traceSource`.</span><span class="s3">\n  </span><span class="s1">if (file.startsWith('node:')) {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">frame: {</span><span class="s3">\n        </span><span class="s1">file,</span><span class="s3">\n        </span><span class="s1">line1: frame.line ?? null,</span><span class="s3">\n        </span><span class="s1">column1: frame.column ?? null,</span><span class="s3">\n        </span><span class="s1">methodName: frame.methodName ?? '&lt;unknown&gt;',</span><span class="s3">\n        </span><span class="s1">ignored: true,</span><span class="s3">\n        </span><span class="s1">arguments: [],</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">source: null,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const currentDirectoryFileUrl = pathToFileURL(process.cwd()).href</span><span class="s3">\n\n  </span><span class="s1">const sourceFrame = await project.traceSource(frame, currentDirectoryFileUrl)</span><span class="s3">\n  </span><span class="s1">if (!sourceFrame) {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">frame: {</span><span class="s3">\n        </span><span class="s1">file,</span><span class="s3">\n        </span><span class="s1">line1: frame.line ?? null,</span><span class="s3">\n        </span><span class="s1">column1: frame.column ?? null,</span><span class="s3">\n        </span><span class="s1">methodName: frame.methodName ?? '&lt;unknown&gt;',</span><span class="s3">\n        </span><span class="s1">ignored: shouldIgnorePath(file),</span><span class="s3">\n        </span><span class="s1">arguments: [],</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">source: null,</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let source = null</span><span class="s3">\n  </span><span class="s1">const originalFile = sourceFrame.originalFile</span><span class="s3">\n\n  </span><span class="s1">// Don't look up source for node_modules or internals. These can often be large bundled files.</span><span class="s3">\n  </span><span class="s1">const ignored =</span><span class="s3">\n    </span><span class="s1">shouldIgnorePath(originalFile ?? sourceFrame.file) ||</span><span class="s3">\n    </span><span class="s1">// isInternal means resource starts with turbopack:///[turbopack]</span><span class="s3">\n    </span><span class="s1">!!sourceFrame.isInternal</span><span class="s3">\n  </span><span class="s1">if (originalFile &amp;&amp; !ignored) {</span><span class="s3">\n    </span><span class="s1">let sourcePromise = currentSourcesByFile.get(originalFile)</span><span class="s3">\n    </span><span class="s1">if (!sourcePromise) {</span><span class="s3">\n      </span><span class="s1">sourcePromise = project.getSourceForAsset(originalFile)</span><span class="s3">\n      </span><span class="s1">currentSourcesByFile.set(originalFile, sourcePromise)</span><span class="s3">\n      </span><span class="s1">setTimeout(() =&gt; {</span><span class="s3">\n        </span><span class="s1">// Cache file reads for 100ms, as frames will often reference the same</span><span class="s3">\n        </span><span class="s1">// files and can be large.</span><span class="s3">\n        </span><span class="s1">currentSourcesByFile.delete(originalFile!)</span><span class="s3">\n      </span><span class="s1">}, 100)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">source = await sourcePromise</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// TODO: get ignoredList from turbopack source map</span><span class="s3">\n  </span><span class="s1">const ignorableFrame: IgnorableStackFrame = {</span><span class="s3">\n    </span><span class="s1">file: sourceFrame.file,</span><span class="s3">\n    </span><span class="s1">line1: sourceFrame.line ?? null,</span><span class="s3">\n    </span><span class="s1">column1: sourceFrame.column ?? null,</span><span class="s3">\n    </span><span class="s1">methodName:</span><span class="s3">\n      </span><span class="s1">// We ignore the sourcemapped name since it won't be the correct name.</span><span class="s3">\n      </span><span class="s1">// The callsite will point to the column of the variable name instead of the</span><span class="s3">\n      </span><span class="s1">// name of the enclosing function.</span><span class="s3">\n      </span><span class="s1">// TODO(NDX-531): Spy on prepareStackTrace to get the enclosing line number for method name mapping.</span><span class="s3">\n      </span><span class="s1">frame.methodName ?? '&lt;unknown&gt;',</span><span class="s3">\n    </span><span class="s1">ignored,</span><span class="s3">\n    </span><span class="s1">arguments: [],</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">frame: ignorableFrame,</span><span class="s3">\n    </span><span class="s1">source,</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function parseFile(fileParam: string | null): string | undefined {</span><span class="s3">\n  </span><span class="s1">if (!fileParam) {</span><span class="s3">\n    </span><span class="s1">return undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return devirtualizeReactServerURL(fileParam)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createStackFrames(</span><span class="s3">\n  </span><span class="s1">body: OriginalStackFramesRequest</span><span class="s3">\n</span><span class="s1">): TurbopackStackFrame[] {</span><span class="s3">\n  </span><span class="s1">const { frames, isServer } = body</span><span class="s3">\n\n  </span><span class="s1">return frames</span><span class="s3">\n    </span><span class="s1">.map((frame): TurbopackStackFrame | undefined =&gt; {</span><span class="s3">\n      </span><span class="s1">const file = parseFile(frame.file)</span><span class="s3">\n\n      </span><span class="s1">if (!file) {</span><span class="s3">\n        </span><span class="s1">return undefined</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">file,</span><span class="s3">\n        </span><span class="s1">methodName: frame.methodName ?? '&lt;unknown&gt;',</span><span class="s3">\n        </span><span class="s1">line: frame.line1 ?? undefined,</span><span class="s3">\n        </span><span class="s1">column: frame.column1 ?? undefined,</span><span class="s3">\n        </span><span class="s1">isServer,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">.filter((f): f is TurbopackStackFrame =&gt; f !== undefined)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createStackFrame(</span><span class="s3">\n  </span><span class="s1">searchParams: URLSearchParams</span><span class="s3">\n</span><span class="s1">): TurbopackStackFrame | undefined {</span><span class="s3">\n  </span><span class="s1">const file = parseFile(searchParams.get('file'))</span><span class="s3">\n\n  </span><span class="s1">if (!file) {</span><span class="s3">\n    </span><span class="s1">return undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">file,</span><span class="s3">\n    </span><span class="s1">methodName: searchParams.get('methodName') ?? '&lt;unknown&gt;',</span><span class="s3">\n    </span><span class="s1">line: parseInt(searchParams.get('line1') ?? '0', 10) || undefined,</span><span class="s3">\n    </span><span class="s1">column: parseInt(searchParams.get('column1') ?? '0', 10) || undefined,</span><span class="s3">\n    </span><span class="s1">isServer: searchParams.get('isServer') === 'true',</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @returns 1-based lines and 1-based columns</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">async function nativeTraceSource(</span><span class="s3">\n  </span><span class="s1">frame: TurbopackStackFrame</span><span class="s3">\n</span><span class="s1">): Promise&lt;{ frame: IgnorableStackFrame; source: string | null } | undefined&gt; {</span><span class="s3">\n  </span><span class="s1">const sourceURL = frame.file</span><span class="s3">\n  </span><span class="s1">let sourceMapPayload: ModernSourceMapPayload | undefined</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">sourceMapPayload = findSourceMap(sourceURL)?.payload</span><span class="s3">\n  </span><span class="s1">} catch (cause) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`${sourceURL}: Invalid source map. Only conformant source maps can be used to find the original code.`,</span><span class="s3">\n      </span><span class="s1">{ cause }</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (sourceMapPayload !== undefined) {</span><span class="s3">\n    </span><span class="s1">let consumer: SourceMapConsumer</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">consumer = await new SourceMapConsumer(sourceMapPayload)</span><span class="s3">\n    </span><span class="s1">} catch (cause) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">`${sourceURL}: Invalid source map. Only conformant source maps can be used to find the original code.`,</span><span class="s3">\n        </span><span class="s1">{ cause }</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let traced: {</span><span class="s3">\n      </span><span class="s1">originalPosition: NullableMappedPosition</span><span class="s3">\n      </span><span class="s1">sourceContent: string | null</span><span class="s3">\n    </span><span class="s1">} | null</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">const originalPosition = consumer.originalPositionFor({</span><span class="s3">\n        </span><span class="s1">line: frame.line ?? 1,</span><span class="s3">\n        </span><span class="s1">// 0-based columns out requires 0-based columns in.</span><span class="s3">\n        </span><span class="s1">column: (frame.column ?? 1) - 1,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n\n      </span><span class="s1">if (originalPosition.source === null) {</span><span class="s3">\n        </span><span class="s1">traced = null</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">const sourceContent: string | null =</span><span class="s3">\n          </span><span class="s1">consumer.sourceContentFor(</span><span class="s3">\n            </span><span class="s1">originalPosition.source,</span><span class="s3">\n            </span><span class="s1">/* returnNullOnMissing */ true</span><span class="s3">\n          </span><span class="s1">) ?? null</span><span class="s3">\n\n        </span><span class="s1">traced = { originalPosition, sourceContent }</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} finally {</span><span class="s3">\n      </span><span class="s1">consumer.destroy()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (traced !== null) {</span><span class="s3">\n      </span><span class="s1">const { originalPosition, sourceContent } = traced</span><span class="s3">\n      </span><span class="s1">const applicableSourceMap = findApplicableSourceMapPayload(</span><span class="s3">\n        </span><span class="s1">(frame.line ?? 1) - 1,</span><span class="s3">\n        </span><span class="s1">(frame.column ?? 1) - 1,</span><span class="s3">\n        </span><span class="s1">sourceMapPayload</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n\n      </span><span class="s1">// TODO(veil): Upstream a method to sourcemap consumer that immediately says if a frame is ignored or not.</span><span class="s3">\n      </span><span class="s1">let ignored = false</span><span class="s3">\n      </span><span class="s1">if (applicableSourceMap === undefined) {</span><span class="s3">\n        </span><span class="s1">console.error(</span><span class="s3">\n          </span><span class="s1">'No applicable source map found in sections for frame',</span><span class="s3">\n          </span><span class="s1">frame</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// TODO: O(n^2). Consider moving `ignoreList` into a Set</span><span class="s3">\n        </span><span class="s1">const sourceIndex = applicableSourceMap.sources.indexOf(</span><span class="s3">\n          </span><span class="s1">originalPosition.source!</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">ignored =</span><span class="s3">\n          </span><span class="s1">applicableSourceMap.ignoreList?.includes(sourceIndex) ??</span><span class="s3">\n          </span><span class="s1">// When sourcemap is not available, fallback to checking `frame.file`.</span><span class="s3">\n          </span><span class="s1">// e.g. In pages router, nextjs server code is not bundled into the page.</span><span class="s3">\n          </span><span class="s1">shouldIgnorePath(frame.file)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const originalStackFrame: IgnorableStackFrame = {</span><span class="s3">\n        </span><span class="s1">methodName:</span><span class="s3">\n          </span><span class="s1">// We ignore the sourcemapped name since it won't be the correct name.</span><span class="s3">\n          </span><span class="s1">// The callsite will point to the column of the variable name instead of the</span><span class="s3">\n          </span><span class="s1">// name of the enclosing function.</span><span class="s3">\n          </span><span class="s1">// TODO(NDX-531): Spy on prepareStackTrace to get the enclosing line number for method name mapping.</span><span class="s3">\n          </span><span class="s1">frame.methodName</span><span class="s3">\n            </span><span class="s1">?.replace('__WEBPACK_DEFAULT_EXPORT__', 'default')</span><span class="s3">\n            </span><span class="s1">?.replace('__webpack_exports__.', '') || '&lt;unknown&gt;',</span><span class="s3">\n        </span><span class="s1">file: originalPosition.source,</span><span class="s3">\n        </span><span class="s1">line1: originalPosition.line,</span><span class="s3">\n        </span><span class="s1">column1:</span><span class="s3">\n          </span><span class="s1">originalPosition.column === null ? null : originalPosition.column + 1,</span><span class="s3">\n        </span><span class="s1">// TODO: c&amp;p from async createOriginalStackFrame but why not frame.arguments?</span><span class="s3">\n        </span><span class="s1">arguments: [],</span><span class="s3">\n        </span><span class="s1">ignored,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">frame: originalStackFrame,</span><span class="s3">\n        </span><span class="s1">source: sourceContent,</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return undefined</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">async function createOriginalStackFrame(</span><span class="s3">\n  </span><span class="s1">project: Project,</span><span class="s3">\n  </span><span class="s1">projectPath: string,</span><span class="s3">\n  </span><span class="s1">frame: TurbopackStackFrame</span><span class="s3">\n</span><span class="s1">): Promise&lt;OriginalStackFrameResponse | null&gt; {</span><span class="s3">\n  </span><span class="s1">const traced =</span><span class="s3">\n    </span><span class="s1">(await nativeTraceSource(frame)) ??</span><span class="s3">\n    </span><span class="s1">// TODO(veil): When would the bundler know more than native?</span><span class="s3">\n    </span><span class="s1">// If it's faster, try the bundler first and fall back to native later.</span><span class="s3">\n    </span><span class="s1">(await batchedTraceSource(project, frame))</span><span class="s3">\n  </span><span class="s1">if (!traced) {</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">let normalizedStackFrameLocation = traced.frame.file</span><span class="s3">\n  </span><span class="s1">if (</span><span class="s3">\n    </span><span class="s1">normalizedStackFrameLocation !== null &amp;&amp;</span><span class="s3">\n    </span><span class="s1">normalizedStackFrameLocation.startsWith('file://')</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">normalizedStackFrameLocation = path.relative(</span><span class="s3">\n      </span><span class="s1">projectPath,</span><span class="s3">\n      </span><span class="s1">fileURLToPath(normalizedStackFrameLocation)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">originalStackFrame: {</span><span class="s3">\n      </span><span class="s1">arguments: traced.frame.arguments,</span><span class="s3">\n      </span><span class="s1">file: normalizedStackFrameLocation,</span><span class="s3">\n      </span><span class="s1">line1: traced.frame.line1,</span><span class="s3">\n      </span><span class="s1">column1: traced.frame.column1,</span><span class="s3">\n      </span><span class="s1">ignored: traced.frame.ignored,</span><span class="s3">\n      </span><span class="s1">methodName: traced.frame.methodName,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">originalCodeFrame: getOriginalCodeFrame(traced.frame, traced.source),</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getOverlayMiddleware({</span><span class="s3">\n  </span><span class="s1">project,</span><span class="s3">\n  </span><span class="s1">projectPath,</span><span class="s3">\n  </span><span class="s1">isSrcDir,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">project: Project</span><span class="s3">\n  </span><span class="s1">projectPath: string</span><span class="s3">\n  </span><span class="s1">isSrcDir: boolean</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">return async function (</span><span class="s3">\n    </span><span class="s1">req: IncomingMessage,</span><span class="s3">\n    </span><span class="s1">res: ServerResponse,</span><span class="s3">\n    </span><span class="s1">next: () =&gt; void</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">const { pathname, searchParams } = new URL(req.url!, 'http://n')</span><span class="s3">\n\n    </span><span class="s1">if (pathname === '/__nextjs_original-stack-frames') {</span><span class="s3">\n      </span><span class="s1">if (req.method !== 'POST') {</span><span class="s3">\n        </span><span class="s1">return middlewareResponse.badRequest(res)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">const body = await new Promise&lt;string&gt;((resolve, reject) =&gt; {</span><span class="s3">\n        </span><span class="s1">let data = ''</span><span class="s3">\n        </span><span class="s1">req.on('data', (chunk) =&gt; {</span><span class="s3">\n          </span><span class="s1">data += chunk</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">req.on('end', () =&gt; resolve(data))</span><span class="s3">\n        </span><span class="s1">req.on('error', reject)</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n\n      </span><span class="s1">const request = JSON.parse(body) as OriginalStackFramesRequest</span><span class="s3">\n      </span><span class="s1">const result = await getOriginalStackFrames({</span><span class="s3">\n        </span><span class="s1">project,</span><span class="s3">\n        </span><span class="s1">projectPath,</span><span class="s3">\n        </span><span class="s1">frames: request.frames,</span><span class="s3">\n        </span><span class="s1">isServer: request.isServer,</span><span class="s3">\n        </span><span class="s1">isEdgeServer: request.isEdgeServer,</span><span class="s3">\n        </span><span class="s1">isAppDirectory: request.isAppDirectory,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n\n      </span><span class="s1">ignoreListAnonymousStackFramesIfSandwiched(result)</span><span class="s3">\n\n      </span><span class="s1">return middlewareResponse.json(res, result)</span><span class="s3">\n    </span><span class="s1">} else if (pathname === '/__nextjs_launch-editor') {</span><span class="s3">\n      </span><span class="s1">const isAppRelativePath = searchParams.get('isAppRelativePath') === '1'</span><span class="s3">\n\n      </span><span class="s1">let openEditorResult</span><span class="s3">\n      </span><span class="s1">if (isAppRelativePath) {</span><span class="s3">\n        </span><span class="s1">const relativeFilePath = searchParams.get('file') || ''</span><span class="s3">\n        </span><span class="s1">const appPath = path.join(</span><span class="s3">\n          </span><span class="s1">'app',</span><span class="s3">\n          </span><span class="s1">isSrcDir ? 'src' : '',</span><span class="s3">\n          </span><span class="s1">relativeFilePath</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">openEditorResult = await openFileInEditor(appPath, 1, 1, projectPath)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">const frame = createStackFrame(searchParams)</span><span class="s3">\n        </span><span class="s1">if (!frame) return middlewareResponse.badRequest(res)</span><span class="s3">\n        </span><span class="s1">openEditorResult = await openFileInEditor(</span><span class="s3">\n          </span><span class="s1">frame.file,</span><span class="s3">\n          </span><span class="s1">frame.line ?? 1,</span><span class="s3">\n          </span><span class="s1">frame.column ?? 1,</span><span class="s3">\n          </span><span class="s1">projectPath</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (openEditorResult.error) {</span><span class="s3">\n        </span><span class="s1">return middlewareResponse.internalServerError(</span><span class="s3">\n          </span><span class="s1">res,</span><span class="s3">\n          </span><span class="s1">openEditorResult.error</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (!openEditorResult.found) {</span><span class="s3">\n        </span><span class="s1">return middlewareResponse.notFound(res)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return middlewareResponse.noContent(res)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return next()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export function getSourceMapMiddleware(project: Project) {</span><span class="s3">\n  </span><span class="s1">return async function (</span><span class="s3">\n    </span><span class="s1">req: IncomingMessage,</span><span class="s3">\n    </span><span class="s1">res: ServerResponse,</span><span class="s3">\n    </span><span class="s1">next: () =&gt; void</span><span class="s3">\n  </span><span class="s1">): Promise&lt;void&gt; {</span><span class="s3">\n    </span><span class="s1">const { pathname, searchParams } = new URL(req.url!, 'http://n')</span><span class="s3">\n\n    </span><span class="s1">if (pathname !== '/__nextjs_source-map') {</span><span class="s3">\n      </span><span class="s1">return next()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let filename = searchParams.get('filename')</span><span class="s3">\n\n    </span><span class="s1">if (!filename) {</span><span class="s3">\n      </span><span class="s1">return middlewareResponse.badRequest(res)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let nativeSourceMap: SourceMap | undefined</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">nativeSourceMap = findSourceMap(filename)</span><span class="s3">\n    </span><span class="s1">} catch (cause) {</span><span class="s3">\n      </span><span class="s1">return middlewareResponse.internalServerError(</span><span class="s3">\n        </span><span class="s1">res,</span><span class="s3">\n        </span><span class="s1">new Error(</span><span class="s3">\n          </span><span class="s1">`${filename}: Invalid source map. Only conformant source maps can be used to find the original code.`,</span><span class="s3">\n          </span><span class="s1">{ cause }</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (nativeSourceMap !== undefined) {</span><span class="s3">\n      </span><span class="s1">const sourceMapPayload = nativeSourceMap.payload</span><span class="s3">\n      </span><span class="s1">return middlewareResponse.json(res, sourceMapPayload)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">// Turbopack chunk filenames might be URL-encoded.</span><span class="s3">\n      </span><span class="s1">filename = decodeURI(filename)</span><span class="s3">\n    </span><span class="s1">} catch {</span><span class="s3">\n      </span><span class="s1">return middlewareResponse.badRequest(res)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (path.isAbsolute(filename)) {</span><span class="s3">\n      </span><span class="s1">filename = pathToFileURL(filename).href</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">const sourceMapString = await project.getSourceMap(filename)</span><span class="s3">\n\n      </span><span class="s1">if (sourceMapString) {</span><span class="s3">\n        </span><span class="s1">return middlewareResponse.jsonString(res, sourceMapString)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} catch (cause) {</span><span class="s3">\n      </span><span class="s1">return middlewareResponse.internalServerError(</span><span class="s3">\n        </span><span class="s1">res,</span><span class="s3">\n        </span><span class="s1">new Error(</span><span class="s3">\n          </span><span class="s1">`Failed to get source map for '${filename}'. This is a bug in Next.js`,</span><span class="s3">\n          </span><span class="s1">{</span><span class="s3">\n            </span><span class="s1">cause,</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">middlewareResponse.noContent(res)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function getOriginalStackFrames({</span><span class="s3">\n  </span><span class="s1">project,</span><span class="s3">\n  </span><span class="s1">projectPath,</span><span class="s3">\n  </span><span class="s1">frames,</span><span class="s3">\n  </span><span class="s1">isServer,</span><span class="s3">\n  </span><span class="s1">isEdgeServer,</span><span class="s3">\n  </span><span class="s1">isAppDirectory,</span><span class="s3">\n</span><span class="s1">}: {</span><span class="s3">\n  </span><span class="s1">project: Project</span><span class="s3">\n  </span><span class="s1">projectPath: string</span><span class="s3">\n  </span><span class="s1">frames: readonly StackFrame[]</span><span class="s3">\n  </span><span class="s1">isServer: boolean</span><span class="s3">\n  </span><span class="s1">isEdgeServer: boolean</span><span class="s3">\n  </span><span class="s1">isAppDirectory: boolean</span><span class="s3">\n</span><span class="s1">}): Promise&lt;OriginalStackFramesResponse&gt; {</span><span class="s3">\n  </span><span class="s1">const stackFrames = createStackFrames({</span><span class="s3">\n    </span><span class="s1">frames,</span><span class="s3">\n    </span><span class="s1">isServer,</span><span class="s3">\n    </span><span class="s1">isEdgeServer,</span><span class="s3">\n    </span><span class="s1">isAppDirectory,</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">return Promise.all(</span><span class="s3">\n    </span><span class="s1">stackFrames.map(async (frame) =&gt; {</span><span class="s3">\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">const stackFrame = await createOriginalStackFrame(</span><span class="s3">\n          </span><span class="s1">project,</span><span class="s3">\n          </span><span class="s1">projectPath,</span><span class="s3">\n          </span><span class="s1">frame</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">if (stackFrame === null) {</span><span class="s3">\n          </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">status: 'rejected',</span><span class="s3">\n            </span><span class="s1">reason: 'Failed to create original stack frame',</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return { status: 'fulfilled', value: stackFrame }</span><span class="s3">\n      </span><span class="s1">} catch (error) {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">status: 'rejected',</span><span class="s3">\n          </span><span class="s1">reason: inspect(error, { colors: false }),</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;getOriginalStackFrames&quot;</span><span class="s0">,</span><span class="s1">&quot;getOverlayMiddleware&quot;</span><span class="s0">,</span><span class="s1">&quot;getSourceMapMiddleware&quot;</span><span class="s0">,</span><span class="s1">&quot;shouldIgnorePath&quot;</span><span class="s0">,</span><span class="s1">&quot;modulePath&quot;</span><span class="s0">,</span><span class="s1">&quot;includes&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;currentSourcesByFile&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;batchedTraceSource&quot;</span><span class="s0">,</span><span class="s1">&quot;project&quot;</span><span class="s0">,</span><span class="s1">&quot;frame&quot;</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">,</span><span class="s1">&quot;decodeURIComponent&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;line1&quot;</span><span class="s0">,</span><span class="s1">&quot;line&quot;</span><span class="s0">,</span><span class="s1">&quot;column1&quot;</span><span class="s0">,</span><span class="s1">&quot;column&quot;</span><span class="s0">,</span><span class="s1">&quot;methodName&quot;</span><span class="s0">,</span><span class="s1">&quot;ignored&quot;</span><span class="s0">,</span><span class="s1">&quot;arguments&quot;</span><span class="s0">,</span><span class="s1">&quot;source&quot;</span><span class="s0">,</span><span class="s1">&quot;currentDirectoryFileUrl&quot;</span><span class="s0">,</span><span class="s1">&quot;pathToFileURL&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;cwd&quot;</span><span class="s0">,</span><span class="s1">&quot;href&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceFrame&quot;</span><span class="s0">,</span><span class="s1">&quot;traceSource&quot;</span><span class="s0">,</span><span class="s1">&quot;originalFile&quot;</span><span class="s0">,</span><span class="s1">&quot;isInternal&quot;</span><span class="s0">,</span><span class="s1">&quot;sourcePromise&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;getSourceForAsset&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;setTimeout&quot;</span><span class="s0">,</span><span class="s1">&quot;delete&quot;</span><span class="s0">,</span><span class="s1">&quot;ignorableFrame&quot;</span><span class="s0">,</span><span class="s1">&quot;parseFile&quot;</span><span class="s0">,</span><span class="s1">&quot;fileParam&quot;</span><span class="s0">,</span><span class="s1">&quot;devirtualizeReactServerURL&quot;</span><span class="s0">,</span><span class="s1">&quot;createStackFrames&quot;</span><span class="s0">,</span><span class="s1">&quot;body&quot;</span><span class="s0">,</span><span class="s1">&quot;frames&quot;</span><span class="s0">,</span><span class="s1">&quot;isServer&quot;</span><span class="s0">,</span><span class="s1">&quot;map&quot;</span><span class="s0">,</span><span class="s1">&quot;filter&quot;</span><span class="s0">,</span><span class="s1">&quot;f&quot;</span><span class="s0">,</span><span class="s1">&quot;createStackFrame&quot;</span><span class="s0">,</span><span class="s1">&quot;searchParams&quot;</span><span class="s0">,</span><span class="s1">&quot;parseInt&quot;</span><span class="s0">,</span><span class="s1">&quot;nativeTraceSource&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceURL&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceMapPayload&quot;</span><span class="s0">,</span><span class="s1">&quot;findSourceMap&quot;</span><span class="s0">,</span><span class="s1">&quot;payload&quot;</span><span class="s0">,</span><span class="s1">&quot;cause&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;consumer&quot;</span><span class="s0">,</span><span class="s1">&quot;SourceMapConsumer&quot;</span><span class="s0">,</span><span class="s1">&quot;traced&quot;</span><span class="s0">,</span><span class="s1">&quot;originalPosition&quot;</span><span class="s0">,</span><span class="s1">&quot;originalPositionFor&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceContent&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceContentFor&quot;</span><span class="s0">,</span><span class="s1">&quot;destroy&quot;</span><span class="s0">,</span><span class="s1">&quot;applicableSourceMap&quot;</span><span class="s0">,</span><span class="s1">&quot;findApplicableSourceMapPayload&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceIndex&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">,</span><span class="s1">&quot;indexOf&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">,</span><span class="s1">&quot;originalStackFrame&quot;</span><span class="s0">,</span><span class="s1">&quot;replace&quot;</span><span class="s0">,</span><span class="s1">&quot;createOriginalStackFrame&quot;</span><span class="s0">,</span><span class="s1">&quot;projectPath&quot;</span><span class="s0">,</span><span class="s1">&quot;normalizedStackFrameLocation&quot;</span><span class="s0">,</span><span class="s1">&quot;path&quot;</span><span class="s0">,</span><span class="s1">&quot;relative&quot;</span><span class="s0">,</span><span class="s1">&quot;fileURLToPath&quot;</span><span class="s0">,</span><span class="s1">&quot;originalCodeFrame&quot;</span><span class="s0">,</span><span class="s1">&quot;getOriginalCodeFrame&quot;</span><span class="s0">,</span><span class="s1">&quot;isSrcDir&quot;</span><span class="s0">,</span><span class="s1">&quot;req&quot;</span><span class="s0">,</span><span class="s1">&quot;res&quot;</span><span class="s0">,</span><span class="s1">&quot;next&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;URL&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;method&quot;</span><span class="s0">,</span><span class="s1">&quot;middlewareResponse&quot;</span><span class="s0">,</span><span class="s1">&quot;badRequest&quot;</span><span class="s0">,</span><span class="s1">&quot;Promise&quot;</span><span class="s0">,</span><span class="s1">&quot;resolve&quot;</span><span class="s0">,</span><span class="s1">&quot;reject&quot;</span><span class="s0">,</span><span class="s1">&quot;data&quot;</span><span class="s0">,</span><span class="s1">&quot;on&quot;</span><span class="s0">,</span><span class="s1">&quot;chunk&quot;</span><span class="s0">,</span><span class="s1">&quot;request&quot;</span><span class="s0">,</span><span class="s1">&quot;JSON&quot;</span><span class="s0">,</span><span class="s1">&quot;parse&quot;</span><span class="s0">,</span><span class="s1">&quot;result&quot;</span><span class="s0">,</span><span class="s1">&quot;isEdgeServer&quot;</span><span class="s0">,</span><span class="s1">&quot;isAppDirectory&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreListAnonymousStackFramesIfSandwiched&quot;</span><span class="s0">,</span><span class="s1">&quot;json&quot;</span><span class="s0">,</span><span class="s1">&quot;isAppRelativePath&quot;</span><span class="s0">,</span><span class="s1">&quot;openEditorResult&quot;</span><span class="s0">,</span><span class="s1">&quot;relativeFilePath&quot;</span><span class="s0">,</span><span class="s1">&quot;appPath&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;openFileInEditor&quot;</span><span class="s0">,</span><span class="s1">&quot;internalServerError&quot;</span><span class="s0">,</span><span class="s1">&quot;found&quot;</span><span class="s0">,</span><span class="s1">&quot;notFound&quot;</span><span class="s0">,</span><span class="s1">&quot;noContent&quot;</span><span class="s0">,</span><span class="s1">&quot;filename&quot;</span><span class="s0">,</span><span class="s1">&quot;nativeSourceMap&quot;</span><span class="s0">,</span><span class="s1">&quot;decodeURI&quot;</span><span class="s0">,</span><span class="s1">&quot;isAbsolute&quot;</span><span class="s0">,</span><span class="s1">&quot;sourceMapString&quot;</span><span class="s0">,</span><span class="s1">&quot;getSourceMap&quot;</span><span class="s0">,</span><span class="s1">&quot;jsonString&quot;</span><span class="s0">,</span><span class="s1">&quot;stackFrames&quot;</span><span class="s0">,</span><span class="s1">&quot;all&quot;</span><span class="s0">,</span><span class="s1">&quot;stackFrame&quot;</span><span class="s0">,</span><span class="s1">&quot;status&quot;</span><span class="s0">,</span><span class="s1">&quot;reason&quot;</span><span class="s0">,</span><span class="s1">&quot;value&quot;</span><span class="s0">,</span><span class="s1">&quot;inspect&quot;</span><span class="s0">,</span><span class="s1">&quot;colors&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>