<html>
<head>
<title>encryption.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
encryption.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/server/app-render/encryption.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/* eslint-disable import/no-extraneous-dependencies */</span><span class="s3">\n</span><span class="s1">import 'server-only'</span><span class="s3">\n\n</span><span class="s1">/* eslint-disable import/no-extraneous-dependencies */</span><span class="s3">\n</span><span class="s1">import { renderToReadableStream } from 'react-server-dom-webpack/server'</span><span class="s3">\n</span><span class="s1">/* eslint-disable import/no-extraneous-dependencies */</span><span class="s3">\n</span><span class="s1">import { createFromReadableStream } from 'react-server-dom-webpack/client'</span><span class="s3">\n\n</span><span class="s1">import { streamToString } from '../stream-utils/node-web-streams-helper'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">arrayBufferToString,</span><span class="s3">\n  </span><span class="s1">decrypt,</span><span class="s3">\n  </span><span class="s1">encrypt,</span><span class="s3">\n  </span><span class="s1">getActionEncryptionKey,</span><span class="s3">\n  </span><span class="s1">getClientReferenceManifestForRsc,</span><span class="s3">\n  </span><span class="s1">getServerModuleMap,</span><span class="s3">\n  </span><span class="s1">stringToUint8Array,</span><span class="s3">\n</span><span class="s1">} from './encryption-utils'</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">getCacheSignal,</span><span class="s3">\n  </span><span class="s1">getPrerenderResumeDataCache,</span><span class="s3">\n  </span><span class="s1">getRenderResumeDataCache,</span><span class="s3">\n  </span><span class="s1">workUnitAsyncStorage,</span><span class="s3">\n</span><span class="s1">} from './work-unit-async-storage.external'</span><span class="s3">\n</span><span class="s1">import { createHangingInputAbortSignal } from './dynamic-rendering'</span><span class="s3">\n</span><span class="s1">import React from 'react'</span><span class="s3">\n\n</span><span class="s1">const isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge'</span><span class="s3">\n\n</span><span class="s1">const textEncoder = new TextEncoder()</span><span class="s3">\n</span><span class="s1">const textDecoder = new TextDecoder()</span><span class="s3">\n\n</span><span class="s1">const filterStackFrame =</span><span class="s3">\n  </span><span class="s1">process.env.NODE_ENV !== 'production'</span><span class="s3">\n    </span><span class="s1">? (require('../lib/source-maps') as typeof import('../lib/source-maps'))</span><span class="s3">\n        </span><span class="s1">.filterStackFrameDEV</span><span class="s3">\n    </span><span class="s1">: undefined</span><span class="s3">\n</span><span class="s1">const findSourceMapURL =</span><span class="s3">\n  </span><span class="s1">process.env.NODE_ENV !== 'production'</span><span class="s3">\n    </span><span class="s1">? (require('../lib/source-maps') as typeof import('../lib/source-maps'))</span><span class="s3">\n        </span><span class="s1">.findSourceMapURLDEV</span><span class="s3">\n    </span><span class="s1">: undefined</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Decrypt the serialized string with the action id as the salt.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">async function decodeActionBoundArg(actionId: string, arg: string) {</span><span class="s3">\n  </span><span class="s1">const key = await getActionEncryptionKey()</span><span class="s3">\n  </span><span class="s1">if (typeof key === 'undefined') {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`Missing encryption key for Server Action. This is a bug in Next.js`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Get the iv (16 bytes) and the payload from the arg.</span><span class="s3">\n  </span><span class="s1">const originalPayload = atob(arg)</span><span class="s3">\n  </span><span class="s1">const ivValue = originalPayload.slice(0, 16)</span><span class="s3">\n  </span><span class="s1">const payload = originalPayload.slice(16)</span><span class="s3">\n\n  </span><span class="s1">const decrypted = textDecoder.decode(</span><span class="s3">\n    </span><span class="s1">await decrypt(key, stringToUint8Array(ivValue), stringToUint8Array(payload))</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">if (!decrypted.startsWith(actionId)) {</span><span class="s3">\n    </span><span class="s1">throw new Error('Invalid Server Action payload: failed to decrypt.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return decrypted.slice(actionId.length)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Encrypt the serialized string with the action id as the salt. Add a prefix to</span><span class="s3">\n </span><span class="s1">* later ensure that the payload is correctly decrypted, similar to a checksum.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">async function encodeActionBoundArg(actionId: string, arg: string) {</span><span class="s3">\n  </span><span class="s1">const key = await getActionEncryptionKey()</span><span class="s3">\n  </span><span class="s1">if (key === undefined) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`Missing encryption key for Server Action. This is a bug in Next.js`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Get 16 random bytes as iv.</span><span class="s3">\n  </span><span class="s1">const randomBytes = new Uint8Array(16)</span><span class="s3">\n  </span><span class="s1">workUnitAsyncStorage.exit(() =&gt; crypto.getRandomValues(randomBytes))</span><span class="s3">\n  </span><span class="s1">const ivValue = arrayBufferToString(randomBytes.buffer)</span><span class="s3">\n\n  </span><span class="s1">const encrypted = await encrypt(</span><span class="s3">\n    </span><span class="s1">key,</span><span class="s3">\n    </span><span class="s1">randomBytes,</span><span class="s3">\n    </span><span class="s1">textEncoder.encode(actionId + arg)</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">return btoa(ivValue + arrayBufferToString(encrypted))</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">enum ReadStatus {</span><span class="s3">\n  </span><span class="s1">Ready,</span><span class="s3">\n  </span><span class="s1">Pending,</span><span class="s3">\n  </span><span class="s1">Complete,</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Encrypts the action's bound args into a string. For the same combination of</span><span class="s3">\n</span><span class="s1">// actionId and args the same cached promise is returned. This ensures reference</span><span class="s3">\n</span><span class="s1">// equality for returned objects from </span><span class="s3">\&quot;</span><span class="s1">use cache</span><span class="s3">\&quot; </span><span class="s1">functions when they're invoked</span><span class="s3">\n</span><span class="s1">// multiple times within one render pass using the same bound args.</span><span class="s3">\n</span><span class="s1">export const encryptActionBoundArgs = React.cache(</span><span class="s3">\n  </span><span class="s1">async function encryptActionBoundArgs(actionId: string, ...args: any[]) {</span><span class="s3">\n    </span><span class="s1">const workUnitStore = workUnitAsyncStorage.getStore()</span><span class="s3">\n    </span><span class="s1">const cacheSignal = workUnitStore</span><span class="s3">\n      </span><span class="s1">? getCacheSignal(workUnitStore)</span><span class="s3">\n      </span><span class="s1">: undefined</span><span class="s3">\n\n    </span><span class="s1">const { clientModules } = getClientReferenceManifestForRsc()</span><span class="s3">\n\n    </span><span class="s1">// Create an error before any asynchronous calls, to capture the original</span><span class="s3">\n    </span><span class="s1">// call stack in case we need it when the serialization errors.</span><span class="s3">\n    </span><span class="s1">const error = new Error()</span><span class="s3">\n    </span><span class="s1">Error.captureStackTrace(error, encryptActionBoundArgs)</span><span class="s3">\n\n    </span><span class="s1">let didCatchError = false</span><span class="s3">\n\n    </span><span class="s1">const hangingInputAbortSignal = workUnitStore</span><span class="s3">\n      </span><span class="s1">? createHangingInputAbortSignal(workUnitStore)</span><span class="s3">\n      </span><span class="s1">: undefined</span><span class="s3">\n\n    </span><span class="s1">let readStatus = ReadStatus.Ready</span><span class="s3">\n    </span><span class="s1">function startReadOnce() {</span><span class="s3">\n      </span><span class="s1">if (readStatus === ReadStatus.Ready) {</span><span class="s3">\n        </span><span class="s1">readStatus = ReadStatus.Pending</span><span class="s3">\n        </span><span class="s1">cacheSignal?.beginRead()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">function endReadIfStarted() {</span><span class="s3">\n      </span><span class="s1">if (readStatus === ReadStatus.Pending) {</span><span class="s3">\n        </span><span class="s1">cacheSignal?.endRead()</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">readStatus = ReadStatus.Complete</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// streamToString might take longer than a microtask to resolve and then other things</span><span class="s3">\n    </span><span class="s1">// waiting on the cache signal might not realize there is another cache to fill so if</span><span class="s3">\n    </span><span class="s1">// we are no longer waiting on the bound args serialization via the hangingInputAbortSignal</span><span class="s3">\n    </span><span class="s1">// we should eagerly start the cache read to prevent other readers of the cache signal from</span><span class="s3">\n    </span><span class="s1">// missing this cache fill. We use a idempotent function to only start reading once because</span><span class="s3">\n    </span><span class="s1">// it's also possible that streamToString finishes before the hangingInputAbortSignal aborts.</span><span class="s3">\n    </span><span class="s1">if (hangingInputAbortSignal &amp;&amp; cacheSignal) {</span><span class="s3">\n      </span><span class="s1">hangingInputAbortSignal.addEventListener('abort', startReadOnce, {</span><span class="s3">\n        </span><span class="s1">once: true,</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Using Flight to serialize the args into a string.</span><span class="s3">\n    </span><span class="s1">const serialized = await streamToString(</span><span class="s3">\n      </span><span class="s1">renderToReadableStream(args, clientModules, {</span><span class="s3">\n        </span><span class="s1">filterStackFrame,</span><span class="s3">\n        </span><span class="s1">signal: hangingInputAbortSignal,</span><span class="s3">\n        </span><span class="s1">onError(err) {</span><span class="s3">\n          </span><span class="s1">if (hangingInputAbortSignal?.aborted) {</span><span class="s3">\n            </span><span class="s1">return</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">// We're only reporting one error at a time, starting with the first.</span><span class="s3">\n          </span><span class="s1">if (didCatchError) {</span><span class="s3">\n            </span><span class="s1">return</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">didCatchError = true</span><span class="s3">\n\n          </span><span class="s1">// Use the original error message together with the previously created</span><span class="s3">\n          </span><span class="s1">// stack, because err.stack is a useless Flight Server call stack.</span><span class="s3">\n          </span><span class="s1">error.message = err instanceof Error ? err.message : String(err)</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">}),</span><span class="s3">\n      </span><span class="s1">// We pass the abort signal to `streamToString` so that no chunks are</span><span class="s3">\n      </span><span class="s1">// included that are emitted after the signal was already aborted. This</span><span class="s3">\n      </span><span class="s1">// ensures that we can encode hanging promises.</span><span class="s3">\n      </span><span class="s1">hangingInputAbortSignal</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n\n    </span><span class="s1">if (didCatchError) {</span><span class="s3">\n      </span><span class="s1">if (process.env.NODE_ENV === 'development') {</span><span class="s3">\n        </span><span class="s1">// Logging the error is needed for server functions that are passed to the</span><span class="s3">\n        </span><span class="s1">// client where the decryption is not done during rendering. Console</span><span class="s3">\n        </span><span class="s1">// replaying allows us to still show the error dev overlay in this case.</span><span class="s3">\n        </span><span class="s1">console.error(error)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">endReadIfStarted()</span><span class="s3">\n      </span><span class="s1">throw error</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!workUnitStore) {</span><span class="s3">\n      </span><span class="s1">// We don't need to call cacheSignal.endRead here because we can't have a cacheSignal</span><span class="s3">\n      </span><span class="s1">// if we do not have a workUnitStore.</span><span class="s3">\n      </span><span class="s1">return encodeActionBoundArg(actionId, serialized)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">startReadOnce()</span><span class="s3">\n\n    </span><span class="s1">const prerenderResumeDataCache = getPrerenderResumeDataCache(workUnitStore)</span><span class="s3">\n    </span><span class="s1">const renderResumeDataCache = getRenderResumeDataCache(workUnitStore)</span><span class="s3">\n    </span><span class="s1">const cacheKey = actionId + serialized</span><span class="s3">\n\n    </span><span class="s1">const cachedEncrypted =</span><span class="s3">\n      </span><span class="s1">prerenderResumeDataCache?.encryptedBoundArgs.get(cacheKey) ??</span><span class="s3">\n      </span><span class="s1">renderResumeDataCache?.encryptedBoundArgs.get(cacheKey)</span><span class="s3">\n\n    </span><span class="s1">if (cachedEncrypted) {</span><span class="s3">\n      </span><span class="s1">return cachedEncrypted</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const encrypted = await encodeActionBoundArg(actionId, serialized)</span><span class="s3">\n\n    </span><span class="s1">endReadIfStarted()</span><span class="s3">\n    </span><span class="s1">prerenderResumeDataCache?.encryptedBoundArgs.set(cacheKey, encrypted)</span><span class="s3">\n\n    </span><span class="s1">return encrypted</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n\n</span><span class="s1">// Decrypts the action's bound args from the encrypted string.</span><span class="s3">\n</span><span class="s1">export async function decryptActionBoundArgs(</span><span class="s3">\n  </span><span class="s1">actionId: string,</span><span class="s3">\n  </span><span class="s1">encryptedPromise: Promise&lt;string&gt;</span><span class="s3">\n</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">const encrypted = await encryptedPromise</span><span class="s3">\n  </span><span class="s1">const workUnitStore = workUnitAsyncStorage.getStore()</span><span class="s3">\n\n  </span><span class="s1">let decrypted: string | undefined</span><span class="s3">\n\n  </span><span class="s1">if (workUnitStore) {</span><span class="s3">\n    </span><span class="s1">const cacheSignal = getCacheSignal(workUnitStore)</span><span class="s3">\n    </span><span class="s1">const prerenderResumeDataCache = getPrerenderResumeDataCache(workUnitStore)</span><span class="s3">\n    </span><span class="s1">const renderResumeDataCache = getRenderResumeDataCache(workUnitStore)</span><span class="s3">\n\n    </span><span class="s1">decrypted =</span><span class="s3">\n      </span><span class="s1">prerenderResumeDataCache?.decryptedBoundArgs.get(encrypted) ??</span><span class="s3">\n      </span><span class="s1">renderResumeDataCache?.decryptedBoundArgs.get(encrypted)</span><span class="s3">\n\n    </span><span class="s1">if (!decrypted) {</span><span class="s3">\n      </span><span class="s1">cacheSignal?.beginRead()</span><span class="s3">\n      </span><span class="s1">decrypted = await decodeActionBoundArg(actionId, encrypted)</span><span class="s3">\n      </span><span class="s1">cacheSignal?.endRead()</span><span class="s3">\n      </span><span class="s1">prerenderResumeDataCache?.decryptedBoundArgs.set(encrypted, decrypted)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">decrypted = await decodeActionBoundArg(actionId, encrypted)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const { edgeRscModuleMapping, rscModuleMapping } =</span><span class="s3">\n    </span><span class="s1">getClientReferenceManifestForRsc()</span><span class="s3">\n\n  </span><span class="s1">// Using Flight to deserialize the args from the string.</span><span class="s3">\n  </span><span class="s1">const deserialized = await createFromReadableStream(</span><span class="s3">\n    </span><span class="s1">new ReadableStream({</span><span class="s3">\n      </span><span class="s1">start(controller) {</span><span class="s3">\n        </span><span class="s1">controller.enqueue(textEncoder.encode(decrypted))</span><span class="s3">\n\n        </span><span class="s1">switch (workUnitStore?.type) {</span><span class="s3">\n          </span><span class="s1">case 'prerender':</span><span class="s3">\n          </span><span class="s1">case 'prerender-runtime':</span><span class="s3">\n            </span><span class="s1">// Explicitly don't close the stream here (until prerendering is</span><span class="s3">\n            </span><span class="s1">// complete) so that hanging promises are not rejected.</span><span class="s3">\n            </span><span class="s1">if (workUnitStore.renderSignal.aborted) {</span><span class="s3">\n              </span><span class="s1">controller.close()</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">workUnitStore.renderSignal.addEventListener(</span><span class="s3">\n                </span><span class="s1">'abort',</span><span class="s3">\n                </span><span class="s1">() =&gt; controller.close(),</span><span class="s3">\n                </span><span class="s1">{ once: true }</span><span class="s3">\n              </span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">break</span><span class="s3">\n          </span><span class="s1">case 'prerender-client':</span><span class="s3">\n          </span><span class="s1">case 'prerender-ppr':</span><span class="s3">\n          </span><span class="s1">case 'prerender-legacy':</span><span class="s3">\n          </span><span class="s1">case 'request':</span><span class="s3">\n          </span><span class="s1">case 'cache':</span><span class="s3">\n          </span><span class="s1">case 'private-cache':</span><span class="s3">\n          </span><span class="s1">case 'unstable-cache':</span><span class="s3">\n          </span><span class="s1">case undefined:</span><span class="s3">\n            </span><span class="s1">return controller.close()</span><span class="s3">\n          </span><span class="s1">default:</span><span class="s3">\n            </span><span class="s1">workUnitStore satisfies never</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">}),</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">findSourceMapURL,</span><span class="s3">\n      </span><span class="s1">serverConsumerManifest: {</span><span class="s3">\n        </span><span class="s1">// moduleLoading must be null because we don't want to trigger preloads of ClientReferences</span><span class="s3">\n        </span><span class="s1">// to be added to the current execution. Instead, we'll wait for any ClientReference</span><span class="s3">\n        </span><span class="s1">// to be emitted which themselves will handle the preloading.</span><span class="s3">\n        </span><span class="s1">moduleLoading: null,</span><span class="s3">\n        </span><span class="s1">moduleMap: isEdgeRuntime ? edgeRscModuleMapping : rscModuleMapping,</span><span class="s3">\n        </span><span class="s1">serverModuleMap: getServerModuleMap(),</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">)</span><span class="s3">\n\n  </span><span class="s1">return deserialized</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;decryptActionBoundArgs&quot;</span><span class="s0">,</span><span class="s1">&quot;encryptActionBoundArgs&quot;</span><span class="s0">,</span><span class="s1">&quot;isEdgeRuntime&quot;</span><span class="s0">,</span><span class="s1">&quot;process&quot;</span><span class="s0">,</span><span class="s1">&quot;env&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_RUNTIME&quot;</span><span class="s0">,</span><span class="s1">&quot;textEncoder&quot;</span><span class="s0">,</span><span class="s1">&quot;TextEncoder&quot;</span><span class="s0">,</span><span class="s1">&quot;textDecoder&quot;</span><span class="s0">,</span><span class="s1">&quot;TextDecoder&quot;</span><span class="s0">,</span><span class="s1">&quot;filterStackFrame&quot;</span><span class="s0">,</span><span class="s1">&quot;NODE_ENV&quot;</span><span class="s0">,</span><span class="s1">&quot;require&quot;</span><span class="s0">,</span><span class="s1">&quot;filterStackFrameDEV&quot;</span><span class="s0">,</span><span class="s1">&quot;undefined&quot;</span><span class="s0">,</span><span class="s1">&quot;findSourceMapURL&quot;</span><span class="s0">,</span><span class="s1">&quot;findSourceMapURLDEV&quot;</span><span class="s0">,</span><span class="s1">&quot;decodeActionBoundArg&quot;</span><span class="s0">,</span><span class="s1">&quot;actionId&quot;</span><span class="s0">,</span><span class="s1">&quot;arg&quot;</span><span class="s0">,</span><span class="s1">&quot;key&quot;</span><span class="s0">,</span><span class="s1">&quot;getActionEncryptionKey&quot;</span><span class="s0">,</span><span class="s1">&quot;Error&quot;</span><span class="s0">,</span><span class="s1">&quot;originalPayload&quot;</span><span class="s0">,</span><span class="s1">&quot;atob&quot;</span><span class="s0">,</span><span class="s1">&quot;ivValue&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;payload&quot;</span><span class="s0">,</span><span class="s1">&quot;decrypted&quot;</span><span class="s0">,</span><span class="s1">&quot;decode&quot;</span><span class="s0">,</span><span class="s1">&quot;decrypt&quot;</span><span class="s0">,</span><span class="s1">&quot;stringToUint8Array&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;encodeActionBoundArg&quot;</span><span class="s0">,</span><span class="s1">&quot;randomBytes&quot;</span><span class="s0">,</span><span class="s1">&quot;Uint8Array&quot;</span><span class="s0">,</span><span class="s1">&quot;workUnitAsyncStorage&quot;</span><span class="s0">,</span><span class="s1">&quot;exit&quot;</span><span class="s0">,</span><span class="s1">&quot;crypto&quot;</span><span class="s0">,</span><span class="s1">&quot;getRandomValues&quot;</span><span class="s0">,</span><span class="s1">&quot;arrayBufferToString&quot;</span><span class="s0">,</span><span class="s1">&quot;buffer&quot;</span><span class="s0">,</span><span class="s1">&quot;encrypted&quot;</span><span class="s0">,</span><span class="s1">&quot;encrypt&quot;</span><span class="s0">,</span><span class="s1">&quot;encode&quot;</span><span class="s0">,</span><span class="s1">&quot;btoa&quot;</span><span class="s0">,</span><span class="s1">&quot;ReadStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;React&quot;</span><span class="s0">,</span><span class="s1">&quot;cache&quot;</span><span class="s0">,</span><span class="s1">&quot;args&quot;</span><span class="s0">,</span><span class="s1">&quot;workUnitStore&quot;</span><span class="s0">,</span><span class="s1">&quot;getStore&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheSignal&quot;</span><span class="s0">,</span><span class="s1">&quot;getCacheSignal&quot;</span><span class="s0">,</span><span class="s1">&quot;clientModules&quot;</span><span class="s0">,</span><span class="s1">&quot;getClientReferenceManifestForRsc&quot;</span><span class="s0">,</span><span class="s1">&quot;error&quot;</span><span class="s0">,</span><span class="s1">&quot;captureStackTrace&quot;</span><span class="s0">,</span><span class="s1">&quot;didCatchError&quot;</span><span class="s0">,</span><span class="s1">&quot;hangingInputAbortSignal&quot;</span><span class="s0">,</span><span class="s1">&quot;createHangingInputAbortSignal&quot;</span><span class="s0">,</span><span class="s1">&quot;readStatus&quot;</span><span class="s0">,</span><span class="s1">&quot;startReadOnce&quot;</span><span class="s0">,</span><span class="s1">&quot;beginRead&quot;</span><span class="s0">,</span><span class="s1">&quot;endReadIfStarted&quot;</span><span class="s0">,</span><span class="s1">&quot;endRead&quot;</span><span class="s0">,</span><span class="s1">&quot;addEventListener&quot;</span><span class="s0">,</span><span class="s1">&quot;once&quot;</span><span class="s0">,</span><span class="s1">&quot;serialized&quot;</span><span class="s0">,</span><span class="s1">&quot;streamToString&quot;</span><span class="s0">,</span><span class="s1">&quot;renderToReadableStream&quot;</span><span class="s0">,</span><span class="s1">&quot;signal&quot;</span><span class="s0">,</span><span class="s1">&quot;onError&quot;</span><span class="s0">,</span><span class="s1">&quot;err&quot;</span><span class="s0">,</span><span class="s1">&quot;aborted&quot;</span><span class="s0">,</span><span class="s1">&quot;message&quot;</span><span class="s0">,</span><span class="s1">&quot;String&quot;</span><span class="s0">,</span><span class="s1">&quot;console&quot;</span><span class="s0">,</span><span class="s1">&quot;prerenderResumeDataCache&quot;</span><span class="s0">,</span><span class="s1">&quot;getPrerenderResumeDataCache&quot;</span><span class="s0">,</span><span class="s1">&quot;renderResumeDataCache&quot;</span><span class="s0">,</span><span class="s1">&quot;getRenderResumeDataCache&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheKey&quot;</span><span class="s0">,</span><span class="s1">&quot;cachedEncrypted&quot;</span><span class="s0">,</span><span class="s1">&quot;encryptedBoundArgs&quot;</span><span class="s0">,</span><span class="s1">&quot;get&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;encryptedPromise&quot;</span><span class="s0">,</span><span class="s1">&quot;decryptedBoundArgs&quot;</span><span class="s0">,</span><span class="s1">&quot;edgeRscModuleMapping&quot;</span><span class="s0">,</span><span class="s1">&quot;rscModuleMapping&quot;</span><span class="s0">,</span><span class="s1">&quot;deserialized&quot;</span><span class="s0">,</span><span class="s1">&quot;createFromReadableStream&quot;</span><span class="s0">,</span><span class="s1">&quot;ReadableStream&quot;</span><span class="s0">,</span><span class="s1">&quot;start&quot;</span><span class="s0">,</span><span class="s1">&quot;controller&quot;</span><span class="s0">,</span><span class="s1">&quot;enqueue&quot;</span><span class="s0">,</span><span class="s1">&quot;type&quot;</span><span class="s0">,</span><span class="s1">&quot;renderSignal&quot;</span><span class="s0">,</span><span class="s1">&quot;close&quot;</span><span class="s0">,</span><span class="s1">&quot;serverConsumerManifest&quot;</span><span class="s0">,</span><span class="s1">&quot;moduleLoading&quot;</span><span class="s0">,</span><span class="s1">&quot;moduleMap&quot;</span><span class="s0">,</span><span class="s1">&quot;serverModuleMap&quot;</span><span class="s0">,</span><span class="s1">&quot;getServerModuleMap&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;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&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>