<html>
<head>
<title>Referencer.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
Referencer.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, { value: </span><span class="s2">true </span><span class="s1">});</span>
<span class="s1">exports.Referencer = </span><span class="s2">void </span><span class="s3">0</span><span class="s1">;</span>
<span class="s2">const </span><span class="s1">types_1 = require(</span><span class="s0">&quot;@typescript-eslint/types&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">assert_1 = require(</span><span class="s0">&quot;../assert&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">definition_1 = require(</span><span class="s0">&quot;../definition&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">lib_1 = require(</span><span class="s0">&quot;../lib&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">ClassVisitor_1 = require(</span><span class="s0">&quot;./ClassVisitor&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">ExportVisitor_1 = require(</span><span class="s0">&quot;./ExportVisitor&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">ImportVisitor_1 = require(</span><span class="s0">&quot;./ImportVisitor&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">PatternVisitor_1 = require(</span><span class="s0">&quot;./PatternVisitor&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">Reference_1 = require(</span><span class="s0">&quot;./Reference&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">TypeVisitor_1 = require(</span><span class="s0">&quot;./TypeVisitor&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">Visitor_1 = require(</span><span class="s0">&quot;./Visitor&quot;</span><span class="s1">);</span>
<span class="s4">// Referencing variables and creating bindings.</span>
<span class="s2">class </span><span class="s1">Referencer </span><span class="s2">extends </span><span class="s1">Visitor_1.Visitor {</span>
    <span class="s1">#hasReferencedJsxFactory = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">#hasReferencedJsxFragmentFactory = </span><span class="s2">false</span><span class="s1">;</span>
    <span class="s1">#jsxFragmentName;</span>
    <span class="s1">#jsxPragma;</span>
    <span class="s1">#lib;</span>
    <span class="s1">scopeManager;</span>
    <span class="s1">constructor(options, scopeManager) {</span>
        <span class="s2">super</span><span class="s1">(options);</span>
        <span class="s2">this</span><span class="s1">.scopeManager = scopeManager;</span>
        <span class="s2">this</span><span class="s1">.#jsxPragma = options.jsxPragma;</span>
        <span class="s2">this</span><span class="s1">.#jsxFragmentName = options.jsxFragmentName;</span>
        <span class="s2">this</span><span class="s1">.#lib = options.lib;</span>
    <span class="s1">}</span>
    <span class="s1">populateGlobalsFromLib(globalScope) {</span>
        <span class="s2">const </span><span class="s1">flattenedLibs = </span><span class="s2">new </span><span class="s1">Set();</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">lib of </span><span class="s2">this</span><span class="s1">.#lib) {</span>
            <span class="s2">const </span><span class="s1">definition = lib_1.lib.get(lib);</span>
            <span class="s2">if </span><span class="s1">(!definition) {</span>
                <span class="s2">throw new </span><span class="s1">Error(</span><span class="s0">`Invalid value for lib provided: </span><span class="s1">${lib}</span><span class="s0">`</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s1">flattenedLibs.add(definition);</span>
        <span class="s1">}</span>
        <span class="s4">// Flatten and deduplicate the set of included libs</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">lib of flattenedLibs) {</span>
            <span class="s4">// By adding the dependencies to the set as we iterate it,</span>
            <span class="s4">// they get iterated only if they are new</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">referencedLib of lib.libs) {</span>
                <span class="s1">flattenedLibs.add(referencedLib);</span>
            <span class="s1">}</span>
            <span class="s4">// This loop is guaranteed to see each included lib exactly once</span>
            <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[name, variable] of lib.variables) {</span>
                <span class="s1">globalScope.defineImplicitVariable(name, variable);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s4">// for const assertions (`{} as const` / `&lt;const&gt;{}`)</span>
        <span class="s1">globalScope.defineImplicitVariable(</span><span class="s0">'const'</span><span class="s1">, {</span>
            <span class="s1">eslintImplicitGlobalSetting: </span><span class="s0">'readonly'</span><span class="s1">,</span>
            <span class="s1">isTypeVariable: </span><span class="s2">true</span><span class="s1">,</span>
            <span class="s1">isValueVariable: </span><span class="s2">false</span><span class="s1">,</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">close(node) {</span>
        <span class="s2">while </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.currentScope(</span><span class="s2">true</span><span class="s1">) &amp;&amp; node === </span><span class="s2">this</span><span class="s1">.currentScope().block) {</span>
            <span class="s2">this</span><span class="s1">.scopeManager.currentScope = </span><span class="s2">this</span><span class="s1">.currentScope().close(</span><span class="s2">this</span><span class="s1">.scopeManager);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">currentScope(dontThrowOnNull) {</span>
        <span class="s2">if </span><span class="s1">(!dontThrowOnNull) {</span>
            <span class="s1">(</span><span class="s3">0</span><span class="s1">, assert_1.assert)(</span><span class="s2">this</span><span class="s1">.scopeManager.currentScope, </span><span class="s0">'aaa'</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.scopeManager.currentScope;</span>
    <span class="s1">}</span>
    <span class="s1">referencingDefaultValue(pattern, assignments, maybeImplicitGlobal, init) {</span>
        <span class="s1">assignments.forEach(assignment =&gt; {</span>
            <span class="s2">this</span><span class="s1">.currentScope().referenceValue(pattern, Reference_1.ReferenceFlag.Write, assignment.right, maybeImplicitGlobal, init);</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s4">/**</span>
     <span class="s4">* Searches for a variable named &quot;name&quot; in the upper scopes and adds a pseudo-reference from itself to itself</span>
     <span class="s4">*/</span>
    <span class="s1">referenceInSomeUpperScope(name) {</span>
        <span class="s2">let </span><span class="s1">scope = </span><span class="s2">this</span><span class="s1">.scopeManager.currentScope;</span>
        <span class="s2">while </span><span class="s1">(scope) {</span>
            <span class="s2">const </span><span class="s1">variable = scope.set.get(name);</span>
            <span class="s2">if </span><span class="s1">(!variable) {</span>
                <span class="s1">scope = scope.upper;</span>
                <span class="s2">continue</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s1">scope.referenceValue(variable.identifiers[</span><span class="s3">0</span><span class="s1">]);</span>
            <span class="s2">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">referenceJsxFragment() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.#jsxFragmentName == </span><span class="s2">null </span><span class="s1">||</span>
            <span class="s2">this</span><span class="s1">.#hasReferencedJsxFragmentFactory) {</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.#hasReferencedJsxFragmentFactory = </span><span class="s2">this</span><span class="s1">.referenceInSomeUpperScope(</span><span class="s2">this</span><span class="s1">.#jsxFragmentName);</span>
    <span class="s1">}</span>
    <span class="s1">referenceJsxPragma() {</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.#jsxPragma == </span><span class="s2">null </span><span class="s1">|| </span><span class="s2">this</span><span class="s1">.#hasReferencedJsxFactory) {</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.#hasReferencedJsxFactory = </span><span class="s2">this</span><span class="s1">.referenceInSomeUpperScope(</span><span class="s2">this</span><span class="s1">.#jsxPragma);</span>
    <span class="s1">}</span>
    <span class="s4">///////////////////</span>
    <span class="s4">// Visit helpers //</span>
    <span class="s4">///////////////////</span>
    <span class="s1">visitClass(node) {</span>
        <span class="s1">ClassVisitor_1.ClassVisitor.visit(</span><span class="s2">this</span><span class="s1">, node);</span>
    <span class="s1">}</span>
    <span class="s1">visitForIn(node) {</span>
        <span class="s2">if </span><span class="s1">(node.left.type === types_1.AST_NODE_TYPES.VariableDeclaration &amp;&amp;</span>
            <span class="s1">node.left.kind !== </span><span class="s0">'var'</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.scopeManager.nestForScope(node);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(node.left.type === types_1.AST_NODE_TYPES.VariableDeclaration) {</span>
            <span class="s2">this</span><span class="s1">.visit(node.left);</span>
            <span class="s2">this</span><span class="s1">.visitPattern(node.left.declarations[</span><span class="s3">0</span><span class="s1">].id, pattern =&gt; {</span>
                <span class="s2">this</span><span class="s1">.currentScope().referenceValue(pattern, Reference_1.ReferenceFlag.Write, node.right, </span><span class="s2">null</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">.visitPattern(node.left, (pattern, info) =&gt; {</span>
                <span class="s2">const </span><span class="s1">maybeImplicitGlobal = !</span><span class="s2">this</span><span class="s1">.currentScope().isStrict</span>
                    <span class="s1">? {</span>
                        <span class="s1">node,</span>
                        <span class="s1">pattern,</span>
                    <span class="s1">}</span>
                    <span class="s1">: </span><span class="s2">null</span><span class="s1">;</span>
                <span class="s2">this</span><span class="s1">.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, </span><span class="s2">false</span><span class="s1">);</span>
                <span class="s2">this</span><span class="s1">.currentScope().referenceValue(pattern, Reference_1.ReferenceFlag.Write, node.right, maybeImplicitGlobal, </span><span class="s2">false</span><span class="s1">);</span>
            <span class="s1">}, { processRightHandNodes: </span><span class="s2">true </span><span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.visit(node.right);</span>
        <span class="s2">this</span><span class="s1">.visit(node.body);</span>
        <span class="s2">this</span><span class="s1">.close(node);</span>
    <span class="s1">}</span>
    <span class="s1">visitFunction(node) {</span>
        <span class="s4">// FunctionDeclaration name is defined in upper scope</span>
        <span class="s4">// NOTE: Not referring variableScope. It is intended.</span>
        <span class="s4">// Since</span>
        <span class="s4">//  in ES5, FunctionDeclaration should be in FunctionBody.</span>
        <span class="s4">//  in ES6, FunctionDeclaration should be block scoped.</span>
        <span class="s2">if </span><span class="s1">(node.type === types_1.AST_NODE_TYPES.FunctionExpression) {</span>
            <span class="s2">if </span><span class="s1">(node.id) {</span>
                <span class="s4">// FunctionExpression with name creates its special scope;</span>
                <span class="s4">// FunctionExpressionNameScope.</span>
                <span class="s2">this</span><span class="s1">.scopeManager.nestFunctionExpressionNameScope(node);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else if </span><span class="s1">(node.id) {</span>
            <span class="s4">// id is defined in upper scope</span>
            <span class="s2">this</span><span class="s1">.currentScope().defineIdentifier(node.id, </span><span class="s2">new </span><span class="s1">definition_1.FunctionNameDefinition(node.id, node));</span>
        <span class="s1">}</span>
        <span class="s4">// Consider this function is in the MethodDefinition.</span>
        <span class="s2">this</span><span class="s1">.scopeManager.nestFunctionScope(node, </span><span class="s2">false</span><span class="s1">);</span>
        <span class="s4">// Process parameter declarations.</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">param of node.params) {</span>
            <span class="s2">this</span><span class="s1">.visitPattern(param, (pattern, info) =&gt; {</span>
                <span class="s2">this</span><span class="s1">.currentScope().defineIdentifier(pattern, </span><span class="s2">new </span><span class="s1">definition_1.ParameterDefinition(pattern, node, info.rest));</span>
                <span class="s2">this</span><span class="s1">.referencingDefaultValue(pattern, info.assignments, </span><span class="s2">null</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
            <span class="s1">}, { processRightHandNodes: </span><span class="s2">true </span><span class="s1">});</span>
            <span class="s2">this</span><span class="s1">.visitFunctionParameterTypeAnnotation(param);</span>
            <span class="s1">param.decorators.forEach(d =&gt; </span><span class="s2">this</span><span class="s1">.visit(d));</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.visitType(node.returnType);</span>
        <span class="s2">this</span><span class="s1">.visitType(node.typeParameters);</span>
        <span class="s4">// In TypeScript there are a number of function-like constructs which have no body,</span>
        <span class="s4">// so check it exists before traversing</span>
        <span class="s2">if </span><span class="s1">(node.body) {</span>
            <span class="s4">// Skip BlockStatement to prevent creating BlockStatement scope.</span>
            <span class="s2">if </span><span class="s1">(node.body.type === types_1.AST_NODE_TYPES.BlockStatement) {</span>
                <span class="s2">this</span><span class="s1">.visitChildren(node.body);</span>
            <span class="s1">}</span>
            <span class="s2">else </span><span class="s1">{</span>
                <span class="s2">this</span><span class="s1">.visit(node.body);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.close(node);</span>
    <span class="s1">}</span>
    <span class="s1">visitFunctionParameterTypeAnnotation(node) {</span>
        <span class="s2">switch </span><span class="s1">(node.type) {</span>
            <span class="s2">case </span><span class="s1">types_1.AST_NODE_TYPES.AssignmentPattern:</span>
                <span class="s2">this</span><span class="s1">.visitType(node.left.typeAnnotation);</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s2">case </span><span class="s1">types_1.AST_NODE_TYPES.TSParameterProperty:</span>
                <span class="s2">this</span><span class="s1">.visitFunctionParameterTypeAnnotation(node.parameter);</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s2">default</span><span class="s1">:</span>
                <span class="s2">this</span><span class="s1">.visitType(node.typeAnnotation);</span>
                <span class="s2">break</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">visitJSXElement(node) {</span>
        <span class="s2">if </span><span class="s1">(node.name.type === types_1.AST_NODE_TYPES.JSXIdentifier) {</span>
            <span class="s2">if </span><span class="s1">(node.name.name[</span><span class="s3">0</span><span class="s1">].toUpperCase() === node.name.name[</span><span class="s3">0</span><span class="s1">] ||</span>
                <span class="s1">node.name.name === </span><span class="s0">'this'</span><span class="s1">) {</span>
                <span class="s4">// lower cased component names are always treated as &quot;intrinsic&quot; names, and are converted to a string,</span>
                <span class="s4">// not a variable by JSX transforms:</span>
                <span class="s4">// &lt;div /&gt; =&gt; React.createElement(&quot;div&quot;, null)</span>
                <span class="s4">// the only case we want to visit a lower-cased component has its name as &quot;this&quot;,</span>
                <span class="s2">this</span><span class="s1">.visit(node.name);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">.visit(node.name);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">visitProperty(node) {</span>
        <span class="s2">if </span><span class="s1">(node.computed) {</span>
            <span class="s2">this</span><span class="s1">.visit(node.key);</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.visit(node.value);</span>
    <span class="s1">}</span>
    <span class="s1">visitType(node) {</span>
        <span class="s2">if </span><span class="s1">(!node) {</span>
            <span class="s2">return</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">TypeVisitor_1.TypeVisitor.visit(</span><span class="s2">this</span><span class="s1">, node);</span>
    <span class="s1">}</span>
    <span class="s1">visitTypeAssertion(node) {</span>
        <span class="s2">this</span><span class="s1">.visit(node.expression);</span>
        <span class="s2">this</span><span class="s1">.visitType(node.typeAnnotation);</span>
    <span class="s1">}</span>
    <span class="s4">/////////////////////</span>
    <span class="s4">// Visit selectors //</span>
    <span class="s4">/////////////////////</span>
    <span class="s1">ArrowFunctionExpression(node) {</span>
        <span class="s2">this</span><span class="s1">.visitFunction(node);</span>
    <span class="s1">}</span>
    <span class="s1">AssignmentExpression(node) {</span>
        <span class="s2">const </span><span class="s1">left = </span><span class="s2">this</span><span class="s1">.visitExpressionTarget(node.left);</span>
        <span class="s2">if </span><span class="s1">(PatternVisitor_1.PatternVisitor.isPattern(left)) {</span>
            <span class="s2">if </span><span class="s1">(node.operator === </span><span class="s0">'='</span><span class="s1">) {</span>
                <span class="s2">this</span><span class="s1">.visitPattern(left, (pattern, info) =&gt; {</span>
                    <span class="s2">const </span><span class="s1">maybeImplicitGlobal = !</span><span class="s2">this</span><span class="s1">.currentScope().isStrict</span>
                        <span class="s1">? {</span>
                            <span class="s1">node,</span>
                            <span class="s1">pattern,</span>
                        <span class="s1">}</span>
                        <span class="s1">: </span><span class="s2">null</span><span class="s1">;</span>
                    <span class="s2">this</span><span class="s1">.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, </span><span class="s2">false</span><span class="s1">);</span>
                    <span class="s2">this</span><span class="s1">.currentScope().referenceValue(pattern, Reference_1.ReferenceFlag.Write, node.right, maybeImplicitGlobal, </span><span class="s2">false</span><span class="s1">);</span>
                <span class="s1">}, { processRightHandNodes: </span><span class="s2">true </span><span class="s1">});</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(left.type === types_1.AST_NODE_TYPES.Identifier) {</span>
                <span class="s2">this</span><span class="s1">.currentScope().referenceValue(left, Reference_1.ReferenceFlag.ReadWrite, node.right);</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">.visit(left);</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.visit(node.right);</span>
    <span class="s1">}</span>
    <span class="s1">BlockStatement(node) {</span>
        <span class="s2">this</span><span class="s1">.scopeManager.nestBlockScope(node);</span>
        <span class="s2">this</span><span class="s1">.visitChildren(node);</span>
        <span class="s2">this</span><span class="s1">.close(node);</span>
    <span class="s1">}</span>
    <span class="s1">BreakStatement() {</span>
        <span class="s4">// don't reference the break statement's label</span>
    <span class="s1">}</span>
    <span class="s1">CallExpression(node) {</span>
        <span class="s2">this</span><span class="s1">.visitChildren(node, [</span><span class="s0">'typeArguments'</span><span class="s1">]);</span>
        <span class="s2">this</span><span class="s1">.visitType(node.typeArguments);</span>
    <span class="s1">}</span>
    <span class="s1">CatchClause(node) {</span>
        <span class="s2">this</span><span class="s1">.scopeManager.nestCatchScope(node);</span>
        <span class="s2">if </span><span class="s1">(node.param) {</span>
            <span class="s2">const </span><span class="s1">param = node.param;</span>
            <span class="s2">this</span><span class="s1">.visitPattern(param, (pattern, info) =&gt; {</span>
                <span class="s2">this</span><span class="s1">.currentScope().defineIdentifier(pattern, </span><span class="s2">new </span><span class="s1">definition_1.CatchClauseDefinition(param, node));</span>
                <span class="s2">this</span><span class="s1">.referencingDefaultValue(pattern, info.assignments, </span><span class="s2">null</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
            <span class="s1">}, { processRightHandNodes: </span><span class="s2">true </span><span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.visit(node.body);</span>
        <span class="s2">this</span><span class="s1">.close(node);</span>
    <span class="s1">}</span>
    <span class="s1">ClassDeclaration(node) {</span>
        <span class="s2">this</span><span class="s1">.visitClass(node);</span>
    <span class="s1">}</span>
    <span class="s1">ClassExpression(node) {</span>
        <span class="s2">this</span><span class="s1">.visitClass(node);</span>
    <span class="s1">}</span>
    <span class="s1">ContinueStatement() {</span>
        <span class="s4">// don't reference the continue statement's label</span>
    <span class="s1">}</span>
    <span class="s1">ExportAllDeclaration() {</span>
        <span class="s4">// this defines no local variables</span>
    <span class="s1">}</span>
    <span class="s1">ExportDefaultDeclaration(node) {</span>
        <span class="s2">if </span><span class="s1">(node.declaration.type === types_1.AST_NODE_TYPES.Identifier) {</span>
            <span class="s1">ExportVisitor_1.ExportVisitor.visit(</span><span class="s2">this</span><span class="s1">, node);</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">.visit(node.declaration);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">ExportNamedDeclaration(node) {</span>
        <span class="s2">if </span><span class="s1">(node.declaration) {</span>
            <span class="s2">this</span><span class="s1">.visit(node.declaration);</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s1">ExportVisitor_1.ExportVisitor.visit(</span><span class="s2">this</span><span class="s1">, node);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">ForInStatement(node) {</span>
        <span class="s2">this</span><span class="s1">.visitForIn(node);</span>
    <span class="s1">}</span>
    <span class="s1">ForOfStatement(node) {</span>
        <span class="s2">this</span><span class="s1">.visitForIn(node);</span>
    <span class="s1">}</span>
    <span class="s1">ForStatement(node) {</span>
        <span class="s4">// Create ForStatement declaration.</span>
        <span class="s4">// NOTE: In ES6, ForStatement dynamically generates per iteration environment. However, this is</span>
        <span class="s4">// a static analyzer, we only generate one scope for ForStatement.</span>
        <span class="s2">if </span><span class="s1">(node.init &amp;&amp;</span>
            <span class="s1">node.init.type === types_1.AST_NODE_TYPES.VariableDeclaration &amp;&amp;</span>
            <span class="s1">node.init.kind !== </span><span class="s0">'var'</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.scopeManager.nestForScope(node);</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.visitChildren(node);</span>
        <span class="s2">this</span><span class="s1">.close(node);</span>
    <span class="s1">}</span>
    <span class="s1">FunctionDeclaration(node) {</span>
        <span class="s2">this</span><span class="s1">.visitFunction(node);</span>
    <span class="s1">}</span>
    <span class="s1">FunctionExpression(node) {</span>
        <span class="s2">this</span><span class="s1">.visitFunction(node);</span>
    <span class="s1">}</span>
    <span class="s1">Identifier(node) {</span>
        <span class="s2">this</span><span class="s1">.currentScope().referenceValue(node);</span>
        <span class="s2">this</span><span class="s1">.visitType(node.typeAnnotation);</span>
    <span class="s1">}</span>
    <span class="s1">ImportAttribute() {</span>
        <span class="s4">// import assertions are module metadata and thus have no variables to reference</span>
    <span class="s1">}</span>
    <span class="s1">ImportDeclaration(node) {</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s1">, assert_1.assert)(</span><span class="s2">this</span><span class="s1">.scopeManager.isModule(), </span><span class="s0">'ImportDeclaration should appear when the mode is ES6 and in the module context.'</span><span class="s1">);</span>
        <span class="s1">ImportVisitor_1.ImportVisitor.visit(</span><span class="s2">this</span><span class="s1">, node);</span>
    <span class="s1">}</span>
    <span class="s1">JSXAttribute(node) {</span>
        <span class="s2">this</span><span class="s1">.visit(node.value);</span>
    <span class="s1">}</span>
    <span class="s1">JSXClosingElement(node) {</span>
        <span class="s2">this</span><span class="s1">.visitJSXElement(node);</span>
    <span class="s1">}</span>
    <span class="s1">JSXFragment(node) {</span>
        <span class="s2">this</span><span class="s1">.referenceJsxPragma();</span>
        <span class="s2">this</span><span class="s1">.referenceJsxFragment();</span>
        <span class="s2">this</span><span class="s1">.visitChildren(node);</span>
    <span class="s1">}</span>
    <span class="s1">JSXIdentifier(node) {</span>
        <span class="s2">this</span><span class="s1">.currentScope().referenceValue(node);</span>
    <span class="s1">}</span>
    <span class="s1">JSXMemberExpression(node) {</span>
        <span class="s2">if </span><span class="s1">(node.object.type !== types_1.AST_NODE_TYPES.JSXIdentifier ||</span>
            <span class="s1">node.object.name !== </span><span class="s0">'this'</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.visit(node.object);</span>
        <span class="s1">}</span>
        <span class="s4">// we don't ever reference the property as it's always going to be a property on the thing</span>
    <span class="s1">}</span>
    <span class="s1">JSXOpeningElement(node) {</span>
        <span class="s2">this</span><span class="s1">.referenceJsxPragma();</span>
        <span class="s2">this</span><span class="s1">.visitJSXElement(node);</span>
        <span class="s2">this</span><span class="s1">.visitType(node.typeArguments);</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">attr of node.attributes) {</span>
            <span class="s2">this</span><span class="s1">.visit(attr);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">LabeledStatement(node) {</span>
        <span class="s2">this</span><span class="s1">.visit(node.body);</span>
    <span class="s1">}</span>
    <span class="s1">MemberExpression(node) {</span>
        <span class="s2">this</span><span class="s1">.visit(node.object);</span>
        <span class="s2">if </span><span class="s1">(node.computed) {</span>
            <span class="s2">this</span><span class="s1">.visit(node.property);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">MetaProperty() {</span>
        <span class="s4">// meta properties all builtin globals</span>
    <span class="s1">}</span>
    <span class="s1">NewExpression(node) {</span>
        <span class="s2">this</span><span class="s1">.visitChildren(node, [</span><span class="s0">'typeArguments'</span><span class="s1">]);</span>
        <span class="s2">this</span><span class="s1">.visitType(node.typeArguments);</span>
    <span class="s1">}</span>
    <span class="s1">PrivateIdentifier() {</span>
        <span class="s4">// private identifiers are members on classes and thus have no variables to reference</span>
    <span class="s1">}</span>
    <span class="s1">Program(node) {</span>
        <span class="s2">const </span><span class="s1">globalScope = </span><span class="s2">this</span><span class="s1">.scopeManager.nestGlobalScope(node);</span>
        <span class="s2">this</span><span class="s1">.populateGlobalsFromLib(globalScope);</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.scopeManager.isGlobalReturn()) {</span>
            <span class="s4">// Force strictness of GlobalScope to false when using node.js scope.</span>
            <span class="s2">this</span><span class="s1">.currentScope().isStrict = </span><span class="s2">false</span><span class="s1">;</span>
            <span class="s2">this</span><span class="s1">.scopeManager.nestFunctionScope(node, </span><span class="s2">false</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.scopeManager.isModule()) {</span>
            <span class="s2">this</span><span class="s1">.scopeManager.nestModuleScope(node);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.scopeManager.isImpliedStrict()) {</span>
            <span class="s2">this</span><span class="s1">.currentScope().isStrict = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.visitChildren(node);</span>
        <span class="s2">this</span><span class="s1">.close(node);</span>
    <span class="s1">}</span>
    <span class="s1">Property(node) {</span>
        <span class="s2">this</span><span class="s1">.visitProperty(node);</span>
    <span class="s1">}</span>
    <span class="s1">SwitchStatement(node) {</span>
        <span class="s2">this</span><span class="s1">.visit(node.discriminant);</span>
        <span class="s2">this</span><span class="s1">.scopeManager.nestSwitchScope(node);</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">switchCase of node.cases) {</span>
            <span class="s2">this</span><span class="s1">.visit(switchCase);</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.close(node);</span>
    <span class="s1">}</span>
    <span class="s1">TaggedTemplateExpression(node) {</span>
        <span class="s2">this</span><span class="s1">.visit(node.tag);</span>
        <span class="s2">this</span><span class="s1">.visit(node.quasi);</span>
        <span class="s2">this</span><span class="s1">.visitType(node.typeArguments);</span>
    <span class="s1">}</span>
    <span class="s1">TSAsExpression(node) {</span>
        <span class="s2">this</span><span class="s1">.visitTypeAssertion(node);</span>
    <span class="s1">}</span>
    <span class="s1">TSDeclareFunction(node) {</span>
        <span class="s2">this</span><span class="s1">.visitFunction(node);</span>
    <span class="s1">}</span>
    <span class="s1">TSEmptyBodyFunctionExpression(node) {</span>
        <span class="s2">this</span><span class="s1">.visitFunction(node);</span>
    <span class="s1">}</span>
    <span class="s1">TSEnumDeclaration(node) {</span>
        <span class="s2">this</span><span class="s1">.currentScope().defineIdentifier(node.id, </span><span class="s2">new </span><span class="s1">definition_1.TSEnumNameDefinition(node.id, node));</span>
        <span class="s4">// enum members can be referenced within the enum body</span>
        <span class="s2">this</span><span class="s1">.scopeManager.nestTSEnumScope(node);</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">member of node.body.members) {</span>
            <span class="s4">// TS resolves literal named members to be actual names</span>
            <span class="s4">// enum Foo {</span>
            <span class="s4">//   'a' = 1,</span>
            <span class="s4">//   b = a, // this references the 'a' member</span>
            <span class="s4">// }</span>
            <span class="s2">if </span><span class="s1">(member.id.type === types_1.AST_NODE_TYPES.Literal &amp;&amp;</span>
                <span class="s2">typeof </span><span class="s1">member.id.value === </span><span class="s0">'string'</span><span class="s1">) {</span>
                <span class="s2">const </span><span class="s1">name = member.id;</span>
                <span class="s2">this</span><span class="s1">.currentScope().defineLiteralIdentifier(name, </span><span class="s2">new </span><span class="s1">definition_1.TSEnumMemberDefinition(name, member));</span>
            <span class="s1">}</span>
            <span class="s2">else if </span><span class="s1">(member.id.type === types_1.AST_NODE_TYPES.Identifier) {</span>
                <span class="s2">this</span><span class="s1">.currentScope().defineIdentifier(member.id, </span><span class="s2">new </span><span class="s1">definition_1.TSEnumMemberDefinition(member.id, member));</span>
            <span class="s1">}</span>
            <span class="s2">this</span><span class="s1">.visit(member.initializer);</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.close(node);</span>
    <span class="s1">}</span>
    <span class="s1">TSExportAssignment(node) {</span>
        <span class="s2">if </span><span class="s1">(node.expression.type === types_1.AST_NODE_TYPES.Identifier) {</span>
            <span class="s4">// this is a special case - you can `export = T` where `T` is a type OR a</span>
            <span class="s4">// value however `T[U]` is illegal when `T` is a type and `T.U` is illegal</span>
            <span class="s4">// when `T.U` is a type</span>
            <span class="s4">// i.e. if the expression is JUST an Identifier - it could be either ref</span>
            <span class="s4">// kind; otherwise the standard rules apply</span>
            <span class="s2">this</span><span class="s1">.currentScope().referenceDualValueType(node.expression);</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">.visit(node.expression);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">TSImportEqualsDeclaration(node) {</span>
        <span class="s2">this</span><span class="s1">.currentScope().defineIdentifier(node.id, </span><span class="s2">new </span><span class="s1">definition_1.ImportBindingDefinition(node.id, node, node));</span>
        <span class="s2">if </span><span class="s1">(node.moduleReference.type === types_1.AST_NODE_TYPES.TSQualifiedName) {</span>
            <span class="s2">let </span><span class="s1">moduleIdentifier = node.moduleReference.left;</span>
            <span class="s2">while </span><span class="s1">(moduleIdentifier.type === types_1.AST_NODE_TYPES.TSQualifiedName) {</span>
                <span class="s1">moduleIdentifier = moduleIdentifier.left;</span>
            <span class="s1">}</span>
            <span class="s2">this</span><span class="s1">.visit(moduleIdentifier);</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">.visit(node.moduleReference);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">TSInstantiationExpression(node) {</span>
        <span class="s2">this</span><span class="s1">.visitChildren(node, [</span><span class="s0">'typeArguments'</span><span class="s1">]);</span>
        <span class="s2">this</span><span class="s1">.visitType(node.typeArguments);</span>
    <span class="s1">}</span>
    <span class="s1">TSInterfaceDeclaration(node) {</span>
        <span class="s2">this</span><span class="s1">.visitType(node);</span>
    <span class="s1">}</span>
    <span class="s1">TSModuleDeclaration(node) {</span>
        <span class="s2">if </span><span class="s1">(node.id.type === types_1.AST_NODE_TYPES.Identifier &amp;&amp; node.kind !== </span><span class="s0">'global'</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.currentScope().defineIdentifier(node.id, </span><span class="s2">new </span><span class="s1">definition_1.TSModuleNameDefinition(node.id, node));</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.scopeManager.nestTSModuleScope(node);</span>
        <span class="s2">this</span><span class="s1">.visit(node.body);</span>
        <span class="s2">this</span><span class="s1">.close(node);</span>
    <span class="s1">}</span>
    <span class="s1">TSSatisfiesExpression(node) {</span>
        <span class="s2">this</span><span class="s1">.visitTypeAssertion(node);</span>
    <span class="s1">}</span>
    <span class="s1">TSTypeAliasDeclaration(node) {</span>
        <span class="s2">this</span><span class="s1">.visitType(node);</span>
    <span class="s1">}</span>
    <span class="s1">TSTypeAssertion(node) {</span>
        <span class="s2">this</span><span class="s1">.visitTypeAssertion(node);</span>
    <span class="s1">}</span>
    <span class="s1">UpdateExpression(node) {</span>
        <span class="s2">const </span><span class="s1">argument = </span><span class="s2">this</span><span class="s1">.visitExpressionTarget(node.argument);</span>
        <span class="s2">if </span><span class="s1">(PatternVisitor_1.PatternVisitor.isPattern(argument)) {</span>
            <span class="s2">this</span><span class="s1">.visitPattern(argument, pattern =&gt; {</span>
                <span class="s2">this</span><span class="s1">.currentScope().referenceValue(pattern, Reference_1.ReferenceFlag.ReadWrite, </span><span class="s2">null</span><span class="s1">);</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">else </span><span class="s1">{</span>
            <span class="s2">this</span><span class="s1">.visitChildren(node);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">VariableDeclaration(node) {</span>
        <span class="s2">const </span><span class="s1">variableTargetScope = node.kind === </span><span class="s0">'var'</span>
            <span class="s1">? </span><span class="s2">this</span><span class="s1">.currentScope().variableScope</span>
            <span class="s1">: </span><span class="s2">this</span><span class="s1">.currentScope();</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">decl of node.declarations) {</span>
            <span class="s2">const </span><span class="s1">init = decl.init;</span>
            <span class="s2">this</span><span class="s1">.visitPattern(decl.id, (pattern, info) =&gt; {</span>
                <span class="s1">variableTargetScope.defineIdentifier(pattern, </span><span class="s2">new </span><span class="s1">definition_1.VariableDefinition(pattern, decl, node));</span>
                <span class="s2">this</span><span class="s1">.referencingDefaultValue(pattern, info.assignments, </span><span class="s2">null</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
                <span class="s2">if </span><span class="s1">(init) {</span>
                    <span class="s2">this</span><span class="s1">.currentScope().referenceValue(pattern, Reference_1.ReferenceFlag.Write, init, </span><span class="s2">null</span><span class="s1">, </span><span class="s2">true</span><span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">}, { processRightHandNodes: </span><span class="s2">true </span><span class="s1">});</span>
            <span class="s2">this</span><span class="s1">.visit(decl.init);</span>
            <span class="s2">this</span><span class="s1">.visitType(decl.id.typeAnnotation);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">WithStatement(node) {</span>
        <span class="s2">this</span><span class="s1">.visit(node.object);</span>
        <span class="s4">// Then nest scope for WithStatement.</span>
        <span class="s2">this</span><span class="s1">.scopeManager.nestWithScope(node);</span>
        <span class="s2">this</span><span class="s1">.visit(node.body);</span>
        <span class="s2">this</span><span class="s1">.close(node);</span>
    <span class="s1">}</span>
    <span class="s1">visitExpressionTarget(left) {</span>
        <span class="s2">switch </span><span class="s1">(left.type) {</span>
            <span class="s2">case </span><span class="s1">types_1.AST_NODE_TYPES.TSAsExpression:</span>
            <span class="s2">case </span><span class="s1">types_1.AST_NODE_TYPES.TSTypeAssertion:</span>
                <span class="s4">// explicitly visit the type annotation</span>
                <span class="s2">this</span><span class="s1">.visitType(left.typeAnnotation);</span>
            <span class="s4">// intentional fallthrough</span>
            <span class="s2">case </span><span class="s1">types_1.AST_NODE_TYPES.TSNonNullExpression:</span>
                <span class="s4">// unwrap the expression</span>
                <span class="s1">left = left.expression;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">left;</span>
    <span class="s1">}</span>
<span class="s1">}</span>
<span class="s1">exports.Referencer = Referencer;</span>
</pre>
</body>
</html>