<html>
<head>
<title>action-utils.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
action-utils.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s3">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">createServerModuleMap: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">selectWorkerForForwarding: </span><span class="s2">null</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">_export(target, all) {</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">name </span><span class="s2">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">createServerModuleMap: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">createServerModuleMap;</span>
    <span class="s1">},</span>
    <span class="s1">selectWorkerForForwarding: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">selectWorkerForForwarding;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_apppaths = require(</span><span class="s0">&quot;../../shared/lib/router/utils/app-paths&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_pathhasprefix = require(</span><span class="s0">&quot;../../shared/lib/router/utils/path-has-prefix&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_removepathprefix = require(</span><span class="s0">&quot;../../shared/lib/router/utils/remove-path-prefix&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_workasyncstorageexternal = require(</span><span class="s0">&quot;./work-async-storage.external&quot;</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">createServerModuleMap({ serverActionsManifest }) {</span>
    <span class="s2">return new </span><span class="s1">Proxy({}, {</span>
        <span class="s1">get: (_, id)=&gt;{</span>
            <span class="s2">var </span><span class="s1">_serverActionsManifest__id, _serverActionsManifest_;</span>
            <span class="s2">const </span><span class="s1">workers = (_serverActionsManifest_ = serverActionsManifest[process.env.NEXT_RUNTIME === </span><span class="s0">'edge' </span><span class="s1">? </span><span class="s0">'edge' </span><span class="s1">: </span><span class="s0">'node'</span><span class="s1">]) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: (_serverActionsManifest__id = _serverActionsManifest_[id]) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _serverActionsManifest__id.workers;</span>
            <span class="s2">if </span><span class="s1">(!workers) {</span>
                <span class="s2">return </span><span class="s1">undefined;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">workStore = _workasyncstorageexternal.workAsyncStorage.getStore();</span>
            <span class="s2">let </span><span class="s1">workerEntry;</span>
            <span class="s2">if </span><span class="s1">(workStore) {</span>
                <span class="s1">workerEntry = workers[normalizeWorkerPageName(workStore.page)];</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s4">// If there's no work store defined, we can assume that a server</span>
                <span class="s4">// module map is needed during module evaluation, e.g. to create a</span>
                <span class="s4">// server action using a higher-order function. Therefore it should be</span>
                <span class="s4">// safe to return any entry from the manifest that matches the action</span>
                <span class="s4">// ID. They all refer to the same module ID, which must also exist in</span>
                <span class="s4">// the current page bundle. TODO: This is currently not guaranteed in</span>
                <span class="s4">// Turbopack, and needs to be fixed.</span>
                <span class="s1">workerEntry = Object.values(workers).at(</span><span class="s3">0</span><span class="s1">);</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(!workerEntry) {</span>
                <span class="s2">return </span><span class="s1">undefined;</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">{ moduleId, async } = workerEntry;</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">id: moduleId,</span>
                <span class="s1">name: id,</span>
                <span class="s1">chunks: [],</span>
                <span class="s1">async</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">selectWorkerForForwarding(actionId, pageName, serverActionsManifest) {</span>
    <span class="s2">var </span><span class="s1">_serverActionsManifest__actionId;</span>
    <span class="s2">const </span><span class="s1">workers = (_serverActionsManifest__actionId = serverActionsManifest[process.env.NEXT_RUNTIME === </span><span class="s0">'edge' </span><span class="s1">? </span><span class="s0">'edge' </span><span class="s1">: </span><span class="s0">'node'</span><span class="s1">][actionId]) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: _serverActionsManifest__actionId.workers;</span>
    <span class="s2">const </span><span class="s1">workerName = normalizeWorkerPageName(pageName);</span>
    <span class="s4">// no workers, nothing to forward to</span>
    <span class="s2">if </span><span class="s1">(!workers) </span><span class="s2">return</span><span class="s1">;</span>
    <span class="s4">// if there is a worker for this page, no need to forward it.</span>
    <span class="s2">if </span><span class="s1">(workers[workerName]) {</span>
        <span class="s2">return</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s4">// otherwise, grab the first worker that has a handler for this action id</span>
    <span class="s2">return </span><span class="s1">denormalizeWorkerPageName(Object.keys(workers)[</span><span class="s3">0</span><span class="s1">]);</span>
<span class="s1">}</span>
<span class="s4">/**</span>
 <span class="s4">* The flight entry loader keys actions by bundlePath.</span>
 <span class="s4">* bundlePath corresponds with the relative path (including 'app') to the page entrypoint.</span>
 <span class="s4">*/ </span><span class="s2">function </span><span class="s1">normalizeWorkerPageName(pageName) {</span>
    <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _pathhasprefix.pathHasPrefix)(pageName, </span><span class="s0">'app'</span><span class="s1">)) {</span>
        <span class="s2">return </span><span class="s1">pageName;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s0">'app' </span><span class="s1">+ pageName;</span>
<span class="s1">}</span>
<span class="s4">/**</span>
 <span class="s4">* Converts a bundlePath (relative path to the entrypoint) to a routable page name</span>
 <span class="s4">*/ </span><span class="s2">function </span><span class="s1">denormalizeWorkerPageName(bundlePath) {</span>
    <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _apppaths.normalizeAppPath)((</span><span class="s3">0</span><span class="s1">, _removepathprefix.removePathPrefix)(bundlePath, </span><span class="s0">'app'</span><span class="s1">));</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=action-utils.js.map</span></pre>
</body>
</html>