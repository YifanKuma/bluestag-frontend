<html>
<head>
<title>batched-file-reader.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
batched-file-reader.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;BatchedFileReader&quot;</span><span class="s1">, {</span>
    <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
    <span class="s1">get: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">BatchedFileReader;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">class </span><span class="s1">BatchedFileReader {</span>
    <span class="s1">constructor(reader){</span>
        <span class="s2">this</span><span class="s1">.reader = reader;</span>
    <span class="s1">}</span>
    <span class="s1">schedule(callback) {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.schedulePromise) {</span>
            <span class="s2">this</span><span class="s1">.schedulePromise = Promise.resolve();</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.schedulePromise.then(()=&gt;{</span>
            <span class="s1">process.nextTick(callback);</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">getOrCreateBatch() {</span>
        <span class="s3">// If there is an existing batch and it's not completed, then reuse it.</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.batch &amp;&amp; !</span><span class="s2">this</span><span class="s1">.batch.completed) {</span>
            <span class="s2">return this</span><span class="s1">.batch;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">batch = {</span>
            <span class="s1">completed: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">directories: [],</span>
            <span class="s1">callbacks: []</span>
        <span class="s1">};</span>
        <span class="s2">this</span><span class="s1">.batch = batch;</span>
        <span class="s2">this</span><span class="s1">.schedule(async ()=&gt;{</span>
            <span class="s1">batch.completed = </span><span class="s2">true</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(batch.directories.length === </span><span class="s4">0</span><span class="s1">) </span><span class="s2">return</span><span class="s1">;</span>
            <span class="s3">// Collect all the results for each of the directories. If any error</span>
            <span class="s3">// occurs, send the results back to the loaders.</span>
            <span class="s2">let </span><span class="s1">values;</span>
            <span class="s2">try </span><span class="s1">{</span>
                <span class="s1">values = </span><span class="s2">await this</span><span class="s1">.load(batch.directories);</span>
            <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
                <span class="s3">// Reject all the callbacks.</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">{ reject } of batch.callbacks){</span>
                    <span class="s1">reject(err);</span>
                <span class="s1">}</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s3">// Loop over all the callbacks and send them their results.</span>
            <span class="s2">for</span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; i &lt; batch.callbacks.length; i++){</span>
                <span class="s2">const </span><span class="s1">value = values[i];</span>
                <span class="s2">if </span><span class="s1">(value </span><span class="s2">instanceof </span><span class="s1">Error) {</span>
                    <span class="s1">batch.callbacks[i].reject(value);</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">batch.callbacks[i].resolve(value);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s2">return </span><span class="s1">batch;</span>
    <span class="s1">}</span>
    <span class="s1">async load(directories) {</span>
        <span class="s3">// Make a unique array of directories. This is what lets us de-duplicate</span>
        <span class="s3">// loads for the same directory.</span>
        <span class="s2">const </span><span class="s1">unique = [</span>
            <span class="s1">...</span><span class="s2">new </span><span class="s1">Set(directories)</span>
        <span class="s1">];</span>
        <span class="s2">const </span><span class="s1">results = </span><span class="s2">await </span><span class="s1">Promise.all(unique.map(async (directory)=&gt;{</span>
            <span class="s2">let </span><span class="s1">files;</span>
            <span class="s2">let </span><span class="s1">error;</span>
            <span class="s2">try </span><span class="s1">{</span>
                <span class="s1">files = </span><span class="s2">await this</span><span class="s1">.reader.read(directory);</span>
            <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
                <span class="s2">if </span><span class="s1">(err </span><span class="s2">instanceof </span><span class="s1">Error) error = err;</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">directory,</span>
                <span class="s1">files,</span>
                <span class="s1">error</span>
            <span class="s1">};</span>
        <span class="s1">}));</span>
        <span class="s2">return </span><span class="s1">directories.map((directory)=&gt;{</span>
            <span class="s2">const </span><span class="s1">found = results.find((result)=&gt;result.directory === directory);</span>
            <span class="s2">if </span><span class="s1">(!found) </span><span class="s2">return </span><span class="s1">[];</span>
            <span class="s2">if </span><span class="s1">(found.files) </span><span class="s2">return </span><span class="s1">found.files;</span>
            <span class="s2">if </span><span class="s1">(found.error) </span><span class="s2">return </span><span class="s1">found.error;</span>
            <span class="s2">return </span><span class="s1">[];</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">async read(dir) {</span>
        <span class="s3">// Get or create a new file reading batch.</span>
        <span class="s2">const </span><span class="s1">batch = </span><span class="s2">this</span><span class="s1">.getOrCreateBatch();</span>
        <span class="s3">// Push this directory into the batch to resolve.</span>
        <span class="s1">batch.directories.push(dir);</span>
        <span class="s3">// Push the promise handles into the batch (under the same index) so it can</span>
        <span class="s3">// be resolved later when it's scheduled.</span>
        <span class="s2">const </span><span class="s1">promise = </span><span class="s2">new </span><span class="s1">Promise((resolve, reject)=&gt;{</span>
            <span class="s1">batch.callbacks.push({</span>
                <span class="s1">resolve,</span>
                <span class="s1">reject</span>
            <span class="s1">});</span>
        <span class="s1">});</span>
        <span class="s2">return </span><span class="s1">promise;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">//# sourceMappingURL=batched-file-reader.js.map</span></pre>
</body>
</html>