<html>
<head>
<title>next-dev-server.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #8c8c8c; font-style: italic;}
.s4 { color: #1750eb;}
.s5 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
next-dev-server.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;default&quot;</span><span class="s1">, {</span>
    <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
    <span class="s1">get: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">DevServer;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_requestmeta = require(</span><span class="s0">&quot;../request-meta&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_react = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">_interop_require_wildcard(require(</span><span class="s0">&quot;react&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_fs = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">_interop_require_default(require(</span><span class="s0">&quot;fs&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_jestworker = require(</span><span class="s0">&quot;next/dist/compiled/jest-worker&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_path = require(</span><span class="s0">&quot;path&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_output = require(</span><span class="s0">&quot;../../build/output&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_constants = require(</span><span class="s0">&quot;../../lib/constants&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_findpagesdir = require(</span><span class="s0">&quot;../../lib/find-pages-dir&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_constants1 = require(</span><span class="s0">&quot;../../shared/lib/constants&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_nextserver = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">_interop_require_wildcard(require(</span><span class="s0">&quot;../next-server&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_normalizepagepath = require(</span><span class="s0">&quot;../../shared/lib/page-path/normalize-page-path&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_pathhasprefix = require(</span><span class="s0">&quot;../../shared/lib/router/utils/path-has-prefix&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_removepathprefix = require(</span><span class="s0">&quot;../../shared/lib/router/utils/remove-path-prefix&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_storage = require(</span><span class="s0">&quot;../../telemetry/storage&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_trace = require(</span><span class="s0">&quot;../../trace&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_findpagefile = require(</span><span class="s0">&quot;../lib/find-page-file&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_utils = require(</span><span class="s0">&quot;../lib/utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_coalescedfunction = require(</span><span class="s0">&quot;../../lib/coalesced-function&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_loaddefaulterrorcomponents = require(</span><span class="s0">&quot;../load-default-error-components&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_utils1 = require(</span><span class="s0">&quot;../../shared/lib/utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_log = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">_interop_require_wildcard(require(</span><span class="s0">&quot;../../build/output/log&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_iserror = </span><span class="s3">/*#__PURE__*/ </span><span class="s1">_interop_require_wildcard(require(</span><span class="s0">&quot;../../lib/is-error&quot;</span><span class="s1">));</span>
<span class="s2">const </span><span class="s1">_utils2 = require(</span><span class="s0">&quot;../../build/utils&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_formatservererror = require(</span><span class="s0">&quot;../../lib/format-server-error&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_devroutematchermanager = require(</span><span class="s0">&quot;../route-matcher-managers/dev-route-matcher-manager&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_devpagesroutematcherprovider = require(</span><span class="s0">&quot;../route-matcher-providers/dev/dev-pages-route-matcher-provider&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_devpagesapiroutematcherprovider = require(</span><span class="s0">&quot;../route-matcher-providers/dev/dev-pages-api-route-matcher-provider&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_devapppageroutematcherprovider = require(</span><span class="s0">&quot;../route-matcher-providers/dev/dev-app-page-route-matcher-provider&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_devapprouteroutematcherprovider = require(</span><span class="s0">&quot;../route-matcher-providers/dev/dev-app-route-route-matcher-provider&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_nodemanifestloader = require(</span><span class="s0">&quot;../route-matcher-providers/helpers/manifest-loaders/node-manifest-loader&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_batchedfilereader = require(</span><span class="s0">&quot;../route-matcher-providers/dev/helpers/file-reader/batched-file-reader&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_defaultfilereader = require(</span><span class="s0">&quot;../route-matcher-providers/dev/helpers/file-reader/default-file-reader&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_lrucache = require(</span><span class="s0">&quot;../lib/lru-cache&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_middlewareroutematcher = require(</span><span class="s0">&quot;../../shared/lib/router/utils/middleware-route-matcher&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_detachedpromise = require(</span><span class="s0">&quot;../../lib/detached-promise&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_ispostpone = require(</span><span class="s0">&quot;../lib/router-utils/is-postpone&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_generateinterceptionroutesrewrites = require(</span><span class="s0">&quot;../../lib/generate-interception-routes-rewrites&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_buildcustomroute = require(</span><span class="s0">&quot;../../lib/build-custom-route&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_errorsource = require(</span><span class="s0">&quot;../../shared/lib/error-source&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_logrequests = require(</span><span class="s0">&quot;./log-requests&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_fallback = require(</span><span class="s0">&quot;../../lib/fallback&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_instrumentationglobalsexternal = require(</span><span class="s0">&quot;../lib/router-utils/instrumentation-globals.external&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_routeregex = require(</span><span class="s0">&quot;../../shared/lib/router/utils/route-regex&quot;</span><span class="s1">);</span>
<span class="s2">function </span><span class="s1">_interop_require_default(obj) {</span>
    <span class="s2">return </span><span class="s1">obj &amp;&amp; obj.__esModule ? obj : {</span>
        <span class="s2">default</span><span class="s1">: obj</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_getRequireWildcardCache(nodeInterop) {</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">WeakMap !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) </span><span class="s2">return null</span><span class="s1">;</span>
    <span class="s2">var </span><span class="s1">cacheBabelInterop = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
    <span class="s2">var </span><span class="s1">cacheNodeInterop = </span><span class="s2">new </span><span class="s1">WeakMap();</span>
    <span class="s2">return </span><span class="s1">(_getRequireWildcardCache = </span><span class="s2">function</span><span class="s1">(nodeInterop) {</span>
        <span class="s2">return </span><span class="s1">nodeInterop ? cacheNodeInterop : cacheBabelInterop;</span>
    <span class="s1">})(nodeInterop);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">_interop_require_wildcard(obj, nodeInterop) {</span>
    <span class="s2">if </span><span class="s1">(!nodeInterop &amp;&amp; obj &amp;&amp; obj.__esModule) {</span>
        <span class="s2">return </span><span class="s1">obj;</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(obj === </span><span class="s2">null </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;object&quot; </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">obj !== </span><span class="s0">&quot;function&quot;</span><span class="s1">) {</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s2">default</span><span class="s1">: obj</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s2">var </span><span class="s1">cache = _getRequireWildcardCache(nodeInterop);</span>
    <span class="s2">if </span><span class="s1">(cache &amp;&amp; cache.has(obj)) {</span>
        <span class="s2">return </span><span class="s1">cache.get(obj);</span>
    <span class="s1">}</span>
    <span class="s2">var </span><span class="s1">newObj = {</span>
        <span class="s1">__proto__: </span><span class="s2">null</span>
    <span class="s1">};</span>
    <span class="s2">var </span><span class="s1">hasPropertyDescriptor = Object.defineProperty &amp;&amp; Object.getOwnPropertyDescriptor;</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">key </span><span class="s2">in </span><span class="s1">obj){</span>
        <span class="s2">if </span><span class="s1">(key !== </span><span class="s0">&quot;default&quot; </span><span class="s1">&amp;&amp; Object.prototype.hasOwnProperty.call(obj, key)) {</span>
            <span class="s2">var </span><span class="s1">desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : </span><span class="s2">null</span><span class="s1">;</span>
            <span class="s2">if </span><span class="s1">(desc &amp;&amp; (desc.get || desc.set)) {</span>
                <span class="s1">Object.defineProperty(newObj, key, desc);</span>
            <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                <span class="s1">newObj[key] = obj[key];</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">newObj.default = obj;</span>
    <span class="s2">if </span><span class="s1">(cache) {</span>
        <span class="s1">cache.set(obj, newObj);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">newObj;</span>
<span class="s1">}</span>
<span class="s3">// Load ReactDevOverlay only when needed</span>
<span class="s2">let </span><span class="s1">PagesDevOverlayBridgeImpl;</span>
<span class="s2">const </span><span class="s1">ReactDevOverlay = (props)=&gt;{</span>
    <span class="s2">if </span><span class="s1">(PagesDevOverlayBridgeImpl === undefined) {</span>
        <span class="s1">PagesDevOverlayBridgeImpl = require(</span><span class="s0">'../../next-devtools/userspace/pages/pages-dev-overlay-setup'</span><span class="s1">).PagesDevOverlayBridge;</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">_react.createElement(PagesDevOverlayBridgeImpl, props);</span>
<span class="s1">};</span>
<span class="s2">class </span><span class="s1">DevServer </span><span class="s2">extends </span><span class="s1">_nextserver.default {</span>
    <span class="s1">getStaticPathsWorker() {</span>
        <span class="s2">const </span><span class="s1">worker = </span><span class="s2">new </span><span class="s1">_jestworker.Worker(require.resolve(</span><span class="s0">'./static-paths-worker'</span><span class="s1">), {</span>
            <span class="s1">maxRetries: </span><span class="s4">1</span><span class="s1">,</span>
            <span class="s3">// For dev server, it's not necessary to spin up too many workers as long as you are not doing a load test.</span>
            <span class="s3">// This helps reusing the memory a lot.</span>
            <span class="s1">numWorkers: </span><span class="s4">1</span><span class="s1">,</span>
            <span class="s1">enableWorkerThreads: </span><span class="s2">this</span><span class="s1">.nextConfig.experimental.workerThreads,</span>
            <span class="s1">forkOptions: {</span>
                <span class="s1">env: {</span>
                    <span class="s1">...process.env,</span>
                    <span class="s3">// discard --inspect/--inspect-brk flags from process.env.NODE_OPTIONS. Otherwise multiple Node.js debuggers</span>
                    <span class="s3">// would be started if user launch Next.js in debugging mode. The number of debuggers is linked to</span>
                    <span class="s3">// the number of workers Next.js tries to launch. The only worker users are interested in debugging</span>
                    <span class="s3">// is the main Next.js one</span>
                    <span class="s1">NODE_OPTIONS: (</span><span class="s4">0</span><span class="s1">, _utils.getFormattedNodeOptionsWithoutInspect)()</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">});</span>
        <span class="s1">worker.getStdout().pipe(process.stdout);</span>
        <span class="s1">worker.getStderr().pipe(process.stderr);</span>
        <span class="s2">return </span><span class="s1">worker;</span>
    <span class="s1">}</span>
    <span class="s1">constructor(options){</span>
        <span class="s2">var </span><span class="s1">_this_nextConfig_experimental_amp, _this_nextConfig_experimental;</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s3">// Increase the number of stack frames on the server</span>
            <span class="s1">Error.stackTraceLimit = </span><span class="s4">50</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">catch  </span><span class="s1">{}</span>
        <span class="s2">super</span><span class="s1">({</span>
            <span class="s1">...options,</span>
            <span class="s1">dev: </span><span class="s2">true</span>
        <span class="s1">}), </span><span class="s3">/**</span>
   <span class="s3">* The promise that resolves when the server is ready. When this is unset</span>
   <span class="s3">* the server is ready.</span>
   <span class="s3">*/ </span><span class="s2">this</span><span class="s1">.ready = </span><span class="s2">new </span><span class="s1">_detachedpromise.DetachedPromise();</span>
        <span class="s2">this</span><span class="s1">.bundlerService = options.bundlerService;</span>
        <span class="s2">this</span><span class="s1">.startServerSpan = options.startServerSpan ?? (</span><span class="s4">0</span><span class="s1">, _trace.trace)(</span><span class="s0">'start-next-dev-server'</span><span class="s1">);</span>
        <span class="s2">this</span><span class="s1">.renderOpts.dev = </span><span class="s2">true</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.renderOpts.ErrorDebug = ReactDevOverlay;</span>
        <span class="s2">this</span><span class="s1">.staticPathsCache = </span><span class="s2">new </span><span class="s1">_lrucache.LRUCache(</span><span class="s3">// 5MB</span>
        <span class="s4">5 </span><span class="s1">* </span><span class="s4">1024 </span><span class="s1">* </span><span class="s4">1024</span><span class="s1">, </span><span class="s2">function </span><span class="s1">length(value) {</span>
            <span class="s2">var </span><span class="s1">_JSON_stringify;</span>
            <span class="s2">return </span><span class="s1">((_JSON_stringify = JSON.stringify(value.staticPaths)) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _JSON_stringify.length) ?? </span><span class="s4">0</span><span class="s1">;</span>
        <span class="s1">});</span>
        <span class="s2">this</span><span class="s1">.renderOpts.ampSkipValidation = ((_this_nextConfig_experimental = </span><span class="s2">this</span><span class="s1">.nextConfig.experimental) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: (_this_nextConfig_experimental_amp = _this_nextConfig_experimental.amp) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _this_nextConfig_experimental_amp.skipValidation) ?? </span><span class="s2">false</span><span class="s1">;</span>
        <span class="s2">this</span><span class="s1">.renderOpts.ampValidator = async (html, pathname)=&gt;{</span>
            <span class="s2">var </span><span class="s1">_this_nextConfig_experimental_amp, _this_nextConfig_experimental;</span>
            <span class="s2">const </span><span class="s1">{ getAmpValidatorInstance, getBundledAmpValidatorFilepath } = require(</span><span class="s0">'../../export/helpers/get-amp-html-validator'</span><span class="s1">);</span>
            <span class="s2">const </span><span class="s1">validatorPath = ((_this_nextConfig_experimental = </span><span class="s2">this</span><span class="s1">.nextConfig.experimental) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: (_this_nextConfig_experimental_amp = _this_nextConfig_experimental.amp) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _this_nextConfig_experimental_amp.validator) || getBundledAmpValidatorFilepath();</span>
            <span class="s2">const </span><span class="s1">validator = </span><span class="s2">await </span><span class="s1">getAmpValidatorInstance(validatorPath);</span>
            <span class="s2">const </span><span class="s1">result = validator.validateString(html);</span>
            <span class="s1">(</span><span class="s4">0</span><span class="s1">, _output.ampValidation)(pathname, result.errors.filter((error)=&gt;{</span>
                <span class="s2">if </span><span class="s1">(error.severity === </span><span class="s0">'ERROR'</span><span class="s1">) {</span>
                    <span class="s3">// Unclear yet if these actually prevent the page from being indexed by the AMP cache.</span>
                    <span class="s3">// These are coming from React so all we can do is ignore them for now.</span>
                    <span class="s3">// &lt;link rel=&quot;expect&quot; blocking=&quot;render&quot; /&gt;</span>
                    <span class="s3">// https://github.com/ampproject/amphtml/issues/40279</span>
                    <span class="s2">if </span><span class="s1">(error.code === </span><span class="s0">'DISALLOWED_ATTR' </span><span class="s1">&amp;&amp; error.params[</span><span class="s4">0</span><span class="s1">] === </span><span class="s0">'blocking' </span><span class="s1">&amp;&amp; error.params[</span><span class="s4">1</span><span class="s1">] === </span><span class="s0">'link'</span><span class="s1">) {</span>
                        <span class="s2">return false</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s3">// &lt;template&gt; without type</span>
                    <span class="s3">// https://github.com/ampproject/amphtml/issues/40280</span>
                    <span class="s2">if </span><span class="s1">(error.code === </span><span class="s0">'MANDATORY_ATTR_MISSING' </span><span class="s1">&amp;&amp; error.params[</span><span class="s4">0</span><span class="s1">] === </span><span class="s0">'type' </span><span class="s1">&amp;&amp; error.params[</span><span class="s4">1</span><span class="s1">] === </span><span class="s0">'template'</span><span class="s1">) {</span>
                        <span class="s2">return false</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s3">// &lt;template&gt; without type</span>
                    <span class="s3">// https://github.com/ampproject/amphtml/issues/40280</span>
                    <span class="s2">if </span><span class="s1">(error.code === </span><span class="s0">'MISSING_REQUIRED_EXTENSION' </span><span class="s1">&amp;&amp; error.params[</span><span class="s4">0</span><span class="s1">] === </span><span class="s0">'template' </span><span class="s1">&amp;&amp; error.params[</span><span class="s4">1</span><span class="s1">] === </span><span class="s0">'amp-mustache'</span><span class="s1">) {</span>
                        <span class="s2">return false</span><span class="s1">;</span>
                    <span class="s1">}</span>
                    <span class="s2">return true</span><span class="s1">;</span>
                <span class="s1">}</span>
                <span class="s2">return false</span><span class="s1">;</span>
            <span class="s1">}).filter((e)=&gt;</span><span class="s2">this</span><span class="s1">._filterAmpDevelopmentScript(html, e)), result.errors.filter((e)=&gt;e.severity !== </span><span class="s0">'ERROR'</span><span class="s1">));</span>
        <span class="s1">};</span>
        <span class="s2">const </span><span class="s1">{ pagesDir, appDir } = (</span><span class="s4">0</span><span class="s1">, _findpagesdir.findPagesDir)(</span><span class="s2">this</span><span class="s1">.dir);</span>
        <span class="s2">this</span><span class="s1">.pagesDir = pagesDir;</span>
        <span class="s2">this</span><span class="s1">.appDir = appDir;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.nextConfig.experimental.serverComponentsHmrCache) {</span>
            <span class="s2">this</span><span class="s1">.serverComponentsHmrCache = </span><span class="s2">new </span><span class="s1">_lrucache.LRUCache(</span><span class="s2">this</span><span class="s1">.nextConfig.cacheMaxMemorySize, </span><span class="s2">function </span><span class="s1">length(value) {</span>
                <span class="s2">return </span><span class="s1">JSON.stringify(value).length;</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">getServerComponentsHmrCache() {</span>
        <span class="s2">return this</span><span class="s1">.serverComponentsHmrCache;</span>
    <span class="s1">}</span>
    <span class="s1">getRouteMatchers() {</span>
        <span class="s2">const </span><span class="s1">{ pagesDir, appDir } = (</span><span class="s4">0</span><span class="s1">, _findpagesdir.findPagesDir)(</span><span class="s2">this</span><span class="s1">.dir);</span>
        <span class="s2">const </span><span class="s1">ensurer = {</span>
            <span class="s1">ensure: async (match, pathname)=&gt;{</span>
                <span class="s2">await this</span><span class="s1">.ensurePage({</span>
                    <span class="s1">definition: match.definition,</span>
                    <span class="s1">page: match.definition.page,</span>
                    <span class="s1">clientOnly: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">url: pathname</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
        <span class="s1">};</span>
        <span class="s2">const </span><span class="s1">matchers = </span><span class="s2">new </span><span class="s1">_devroutematchermanager.DevRouteMatcherManager(</span><span class="s2">super</span><span class="s1">.getRouteMatchers(), ensurer, </span><span class="s2">this</span><span class="s1">.dir);</span>
        <span class="s2">const </span><span class="s1">extensions = </span><span class="s2">this</span><span class="s1">.nextConfig.pageExtensions;</span>
        <span class="s2">const </span><span class="s1">extensionsExpression = </span><span class="s2">new </span><span class="s1">RegExp(</span><span class="s0">`</span><span class="s5">\\</span><span class="s0">.(?:</span><span class="s1">${extensions.join(</span><span class="s0">'|'</span><span class="s1">)}</span><span class="s0">)$`</span><span class="s1">);</span>
        <span class="s3">// If the pages directory is available, then configure those matchers.</span>
        <span class="s2">if </span><span class="s1">(pagesDir) {</span>
            <span class="s2">const </span><span class="s1">fileReader = </span><span class="s2">new </span><span class="s1">_batchedfilereader.BatchedFileReader(</span><span class="s2">new </span><span class="s1">_defaultfilereader.DefaultFileReader({</span>
                <span class="s3">// Only allow files that have the correct extensions.</span>
                <span class="s1">pathnameFilter: (pathname)=&gt;extensionsExpression.test(pathname)</span>
            <span class="s1">}));</span>
            <span class="s1">matchers.push(</span><span class="s2">new </span><span class="s1">_devpagesroutematcherprovider.DevPagesRouteMatcherProvider(pagesDir, extensions, fileReader, </span><span class="s2">this</span><span class="s1">.localeNormalizer));</span>
            <span class="s1">matchers.push(</span><span class="s2">new </span><span class="s1">_devpagesapiroutematcherprovider.DevPagesAPIRouteMatcherProvider(pagesDir, extensions, fileReader, </span><span class="s2">this</span><span class="s1">.localeNormalizer));</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(appDir) {</span>
            <span class="s3">// We create a new file reader for the app directory because we don't want</span>
            <span class="s3">// to include any folders or files starting with an underscore. This will</span>
            <span class="s3">// prevent the reader from wasting time reading files that we know we</span>
            <span class="s3">// don't care about.</span>
            <span class="s2">const </span><span class="s1">fileReader = </span><span class="s2">new </span><span class="s1">_batchedfilereader.BatchedFileReader(</span><span class="s2">new </span><span class="s1">_defaultfilereader.DefaultFileReader({</span>
                <span class="s3">// Ignore any directory prefixed with an underscore.</span>
                <span class="s1">ignorePartFilter: (part)=&gt;part.startsWith(</span><span class="s0">'_'</span><span class="s1">)</span>
            <span class="s1">}));</span>
            <span class="s3">// TODO: Improve passing of &quot;is running with Turbopack&quot;</span>
            <span class="s2">const </span><span class="s1">isTurbopack = !!process.env.TURBOPACK;</span>
            <span class="s1">matchers.push(</span><span class="s2">new </span><span class="s1">_devapppageroutematcherprovider.DevAppPageRouteMatcherProvider(appDir, extensions, fileReader, isTurbopack));</span>
            <span class="s1">matchers.push(</span><span class="s2">new </span><span class="s1">_devapprouteroutematcherprovider.DevAppRouteRouteMatcherProvider(appDir, extensions, fileReader, isTurbopack));</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">matchers;</span>
    <span class="s1">}</span>
    <span class="s1">getBuildId() {</span>
        <span class="s2">return </span><span class="s0">'development'</span><span class="s1">;</span>
    <span class="s1">}</span>
    <span class="s1">async prepareImpl() {</span>
        <span class="s2">var </span><span class="s1">_this_ready;</span>
        <span class="s1">(</span><span class="s4">0</span><span class="s1">, _trace.setGlobal)(</span><span class="s0">'distDir'</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.distDir);</span>
        <span class="s1">(</span><span class="s4">0</span><span class="s1">, _trace.setGlobal)(</span><span class="s0">'phase'</span><span class="s1">, _constants1.PHASE_DEVELOPMENT_SERVER);</span>
        <span class="s2">const </span><span class="s1">telemetry = </span><span class="s2">new </span><span class="s1">_storage.Telemetry({</span>
            <span class="s1">distDir: </span><span class="s2">this</span><span class="s1">.distDir</span>
        <span class="s1">});</span>
        <span class="s2">await super</span><span class="s1">.prepareImpl();</span>
        <span class="s2">await this</span><span class="s1">.matchers.reload();</span>
        <span class="s1">(_this_ready = </span><span class="s2">this</span><span class="s1">.ready) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _this_ready.resolve();</span>
        <span class="s2">this</span><span class="s1">.ready = undefined;</span>
        <span class="s3">// In dev, this needs to be called after prepare because the build entries won't be known in the constructor</span>
        <span class="s2">this</span><span class="s1">.interceptionRoutePatterns = </span><span class="s2">this</span><span class="s1">.getinterceptionRoutePatterns();</span>
        <span class="s3">// This is required by the tracing subsystem.</span>
        <span class="s1">(</span><span class="s4">0</span><span class="s1">, _trace.setGlobal)(</span><span class="s0">'appDir'</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.appDir);</span>
        <span class="s1">(</span><span class="s4">0</span><span class="s1">, _trace.setGlobal)(</span><span class="s0">'pagesDir'</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.pagesDir);</span>
        <span class="s1">(</span><span class="s4">0</span><span class="s1">, _trace.setGlobal)(</span><span class="s0">'telemetry'</span><span class="s1">, telemetry);</span>
        <span class="s1">process.on(</span><span class="s0">'unhandledRejection'</span><span class="s1">, (reason)=&gt;{</span>
            <span class="s2">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _ispostpone.isPostpone)(reason)) {</span>
                <span class="s3">// React postpones that are unhandled might end up logged here but they're</span>
                <span class="s3">// not really errors. They're just part of rendering.</span>
                <span class="s2">return</span><span class="s1">;</span>
            <span class="s1">}</span>
            <span class="s2">this</span><span class="s1">.logErrorWithOriginalStack(reason, </span><span class="s0">'unhandledRejection'</span><span class="s1">);</span>
        <span class="s1">});</span>
        <span class="s1">process.on(</span><span class="s0">'uncaughtException'</span><span class="s1">, (err)=&gt;{</span>
            <span class="s2">this</span><span class="s1">.logErrorWithOriginalStack(err, </span><span class="s0">'uncaughtException'</span><span class="s1">);</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">async hasPage(pathname) {</span>
        <span class="s2">let </span><span class="s1">normalizedPath;</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s1">normalizedPath = (</span><span class="s4">0</span><span class="s1">, _normalizepagepath.normalizePagePath)(pathname);</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
            <span class="s1">console.error(err);</span>
            <span class="s3">// if normalizing the page fails it means it isn't valid</span>
            <span class="s3">// so it doesn't exist so don't throw and return false</span>
            <span class="s3">// to ensure we return 404 instead of 500</span>
            <span class="s2">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">((</span><span class="s4">0</span><span class="s1">, _utils2.isMiddlewareFile)(normalizedPath)) {</span>
            <span class="s2">return </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _findpagefile.findPageFile)(</span><span class="s2">this</span><span class="s1">.dir, normalizedPath, </span><span class="s2">this</span><span class="s1">.nextConfig.pageExtensions, </span><span class="s2">false</span><span class="s1">).then(Boolean);</span>
        <span class="s1">}</span>
        <span class="s2">let </span><span class="s1">appFile = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s2">let </span><span class="s1">pagesFile = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.appDir) {</span>
            <span class="s1">appFile = </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _findpagefile.findPageFile)(</span><span class="s2">this</span><span class="s1">.appDir, normalizedPath + </span><span class="s0">'/page'</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.nextConfig.pageExtensions, </span><span class="s2">true</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.pagesDir) {</span>
            <span class="s1">pagesFile = </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _findpagefile.findPageFile)(</span><span class="s2">this</span><span class="s1">.pagesDir, normalizedPath, </span><span class="s2">this</span><span class="s1">.nextConfig.pageExtensions, </span><span class="s2">false</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(appFile &amp;&amp; pagesFile) {</span>
            <span class="s2">return false</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">Boolean(appFile || pagesFile);</span>
    <span class="s1">}</span>
    <span class="s1">async runMiddleware(params) {</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s2">const </span><span class="s1">result = </span><span class="s2">await super</span><span class="s1">.runMiddleware({</span>
                <span class="s1">...params,</span>
                <span class="s1">onWarning: (warn)=&gt;{</span>
                    <span class="s2">this</span><span class="s1">.logErrorWithOriginalStack(warn, </span><span class="s0">'warning'</span><span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
            <span class="s2">if </span><span class="s1">(</span><span class="s0">'finished' </span><span class="s2">in </span><span class="s1">result) {</span>
                <span class="s2">return </span><span class="s1">result;</span>
            <span class="s1">}</span>
            <span class="s1">result.waitUntil.catch((error)=&gt;{</span>
                <span class="s2">this</span><span class="s1">.logErrorWithOriginalStack(error, </span><span class="s0">'unhandledRejection'</span><span class="s1">);</span>
            <span class="s1">});</span>
            <span class="s2">return </span><span class="s1">result;</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
            <span class="s2">if </span><span class="s1">(error </span><span class="s2">instanceof </span><span class="s1">_utils1.DecodeError) {</span>
                <span class="s2">throw </span><span class="s1">error;</span>
            <span class="s1">}</span>
            <span class="s3">/**</span>
       <span class="s3">* We only log the error when it is not a MiddlewareNotFound error as</span>
       <span class="s3">* in that case we should be already displaying a compilation error</span>
       <span class="s3">* which is what makes the module not found.</span>
       <span class="s3">*/ </span><span class="s2">if </span><span class="s1">(!(error </span><span class="s2">instanceof </span><span class="s1">_utils1.MiddlewareNotFoundError)) {</span>
                <span class="s2">this</span><span class="s1">.logErrorWithOriginalStack(error);</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">err = (</span><span class="s4">0</span><span class="s1">, _iserror.getProperError)(error);</span>
            <span class="s1">(</span><span class="s4">0</span><span class="s1">, _errorsource.decorateServerError)(err, _constants1.COMPILER_NAMES.edgeServer);</span>
            <span class="s2">const </span><span class="s1">{ request, response, parsedUrl } = params;</span>
            <span class="s3">/**</span>
       <span class="s3">* When there is a failure for an internal Next.js request from</span>
       <span class="s3">* middleware we bypass the error without finishing the request</span>
       <span class="s3">* so we can serve the required chunks to render the error.</span>
       <span class="s3">*/ </span><span class="s2">if </span><span class="s1">(request.url.includes(</span><span class="s0">'/_next/static'</span><span class="s1">) || request.url.includes(</span><span class="s0">'/__nextjs_original-stack-frame'</span><span class="s1">) || request.url.includes(</span><span class="s0">'/__nextjs_source-map'</span><span class="s1">) || request.url.includes(</span><span class="s0">'/__nextjs_error_feedback'</span><span class="s1">)) {</span>
                <span class="s2">return </span><span class="s1">{</span>
                    <span class="s1">finished: </span><span class="s2">false</span>
                <span class="s1">};</span>
            <span class="s1">}</span>
            <span class="s1">response.statusCode = </span><span class="s4">500</span><span class="s1">;</span>
            <span class="s2">await this</span><span class="s1">.renderError(err, request, response, parsedUrl.pathname);</span>
            <span class="s2">return </span><span class="s1">{</span>
                <span class="s1">finished: </span><span class="s2">true</span>
            <span class="s1">};</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">async runEdgeFunction(params) {</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s2">return super</span><span class="s1">.runEdgeFunction({</span>
                <span class="s1">...params,</span>
                <span class="s1">onError: (err)=&gt;</span><span class="s2">this</span><span class="s1">.logErrorWithOriginalStack(err, </span><span class="s0">'app-dir'</span><span class="s1">),</span>
                <span class="s1">onWarning: (warn)=&gt;{</span>
                    <span class="s2">this</span><span class="s1">.logErrorWithOriginalStack(warn, </span><span class="s0">'warning'</span><span class="s1">);</span>
                <span class="s1">}</span>
            <span class="s1">});</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
            <span class="s2">if </span><span class="s1">(error </span><span class="s2">instanceof </span><span class="s1">_utils1.DecodeError) {</span>
                <span class="s2">throw </span><span class="s1">error;</span>
            <span class="s1">}</span>
            <span class="s2">this</span><span class="s1">.logErrorWithOriginalStack(error, </span><span class="s0">'warning'</span><span class="s1">);</span>
            <span class="s2">const </span><span class="s1">err = (</span><span class="s4">0</span><span class="s1">, _iserror.getProperError)(error);</span>
            <span class="s2">const </span><span class="s1">{ req, res, page } = params;</span>
            <span class="s1">res.statusCode = </span><span class="s4">500</span><span class="s1">;</span>
            <span class="s2">await this</span><span class="s1">.renderError(err, req, res, page);</span>
            <span class="s2">return null</span><span class="s1">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">getRequestHandler() {</span>
        <span class="s2">const </span><span class="s1">handler = </span><span class="s2">super</span><span class="s1">.getRequestHandler();</span>
        <span class="s2">return </span><span class="s1">(req, res, parsedUrl)=&gt;{</span>
            <span class="s2">const </span><span class="s1">request = </span><span class="s2">this</span><span class="s1">.normalizeReq(req);</span>
            <span class="s2">const </span><span class="s1">response = </span><span class="s2">this</span><span class="s1">.normalizeRes(res);</span>
            <span class="s2">const </span><span class="s1">loggingConfig = </span><span class="s2">this</span><span class="s1">.nextConfig.logging;</span>
            <span class="s2">if </span><span class="s1">(loggingConfig !== </span><span class="s2">false</span><span class="s1">) {</span>
                <span class="s2">const </span><span class="s1">start = Date.now();</span>
                <span class="s2">const </span><span class="s1">isMiddlewareRequest = (</span><span class="s4">0</span><span class="s1">, _requestmeta.getRequestMeta)(req, </span><span class="s0">'middlewareInvoke'</span><span class="s1">);</span>
                <span class="s2">if </span><span class="s1">(!isMiddlewareRequest) {</span>
                    <span class="s1">response.originalResponse.once(</span><span class="s0">'close'</span><span class="s1">, ()=&gt;{</span>
                        <span class="s3">// NOTE: The route match is only attached to the request's meta data</span>
                        <span class="s3">// after the request handler is created, so we need to check it in the</span>
                        <span class="s3">// close handler and not before.</span>
                        <span class="s2">const </span><span class="s1">routeMatch = (</span><span class="s4">0</span><span class="s1">, _requestmeta.getRequestMeta)(req).match;</span>
                        <span class="s2">if </span><span class="s1">(!routeMatch) {</span>
                            <span class="s2">return</span><span class="s1">;</span>
                        <span class="s1">}</span>
                        <span class="s1">(</span><span class="s4">0</span><span class="s1">, _logrequests.logRequests)({</span>
                            <span class="s1">request,</span>
                            <span class="s1">response,</span>
                            <span class="s1">loggingConfig,</span>
                            <span class="s1">requestDurationInMs: Date.now() - start</span>
                        <span class="s1">});</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">return </span><span class="s1">handler(request, response, parsedUrl);</span>
        <span class="s1">};</span>
    <span class="s1">}</span>
    <span class="s1">async handleRequest(req, res, parsedUrl) {</span>
        <span class="s2">const </span><span class="s1">span = (</span><span class="s4">0</span><span class="s1">, _trace.trace)(</span><span class="s0">'handle-request'</span><span class="s1">, undefined, {</span>
            <span class="s1">url: req.url</span>
        <span class="s1">});</span>
        <span class="s2">const </span><span class="s1">result = </span><span class="s2">await </span><span class="s1">span.traceAsyncFn(async ()=&gt;{</span>
            <span class="s2">var </span><span class="s1">_this_ready;</span>
            <span class="s2">await </span><span class="s1">((_this_ready = </span><span class="s2">this</span><span class="s1">.ready) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _this_ready.promise);</span>
            <span class="s1">(</span><span class="s4">0</span><span class="s1">, _requestmeta.addRequestMeta)(req, </span><span class="s0">'PagesErrorDebug'</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.renderOpts.ErrorDebug);</span>
            <span class="s2">return await super</span><span class="s1">.handleRequest(req, res, parsedUrl);</span>
        <span class="s1">});</span>
        <span class="s2">const </span><span class="s1">memoryUsage = process.memoryUsage();</span>
        <span class="s1">span.traceChild(</span><span class="s0">'memory-usage'</span><span class="s1">, {</span>
            <span class="s1">url: req.url,</span>
            <span class="s0">'memory.rss'</span><span class="s1">: String(memoryUsage.rss),</span>
            <span class="s0">'memory.heapUsed'</span><span class="s1">: String(memoryUsage.heapUsed),</span>
            <span class="s0">'memory.heapTotal'</span><span class="s1">: String(memoryUsage.heapTotal)</span>
        <span class="s1">}).stop();</span>
        <span class="s2">return </span><span class="s1">result;</span>
    <span class="s1">}</span>
    <span class="s1">async run(req, res, parsedUrl) {</span>
        <span class="s2">var </span><span class="s1">_this_ready;</span>
        <span class="s2">await </span><span class="s1">((_this_ready = </span><span class="s2">this</span><span class="s1">.ready) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _this_ready.promise);</span>
        <span class="s2">const </span><span class="s1">{ basePath } = </span><span class="s2">this</span><span class="s1">.nextConfig;</span>
        <span class="s2">let </span><span class="s1">originalPathname = </span><span class="s2">null</span><span class="s1">;</span>
        <span class="s3">// TODO: see if we can remove this in the future</span>
        <span class="s2">if </span><span class="s1">(basePath &amp;&amp; (</span><span class="s4">0</span><span class="s1">, _pathhasprefix.pathHasPrefix)(parsedUrl.pathname || </span><span class="s0">'/'</span><span class="s1">, basePath)) {</span>
            <span class="s3">// strip basePath before handling dev bundles</span>
            <span class="s3">// If replace ends up replacing the full url it'll be `undefined`, meaning we have to default it to `/`</span>
            <span class="s1">originalPathname = parsedUrl.pathname;</span>
            <span class="s1">parsedUrl.pathname = (</span><span class="s4">0</span><span class="s1">, _removepathprefix.removePathPrefix)(parsedUrl.pathname || </span><span class="s0">'/'</span><span class="s1">, basePath);</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">{ pathname } = parsedUrl;</span>
        <span class="s2">if </span><span class="s1">(pathname.startsWith(</span><span class="s0">'/_next'</span><span class="s1">)) {</span>
            <span class="s2">if </span><span class="s1">(_fs.default.existsSync((</span><span class="s4">0</span><span class="s1">, _path.join)(</span><span class="s2">this</span><span class="s1">.publicDir, </span><span class="s0">'_next'</span><span class="s1">))) {</span>
                <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(_constants.PUBLIC_DIR_MIDDLEWARE_CONFLICT), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                    <span class="s1">value: </span><span class="s0">&quot;E394&quot;</span><span class="s1">,</span>
                    <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">configurable: </span><span class="s2">true</span>
                <span class="s1">});</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(originalPathname) {</span>
            <span class="s3">// restore the path before continuing so that custom-routes can accurately determine</span>
            <span class="s3">// if they should match against the basePath or not</span>
            <span class="s1">parsedUrl.pathname = originalPathname;</span>
        <span class="s1">}</span>
        <span class="s2">try </span><span class="s1">{</span>
            <span class="s2">return await super</span><span class="s1">.run(req, res, parsedUrl);</span>
        <span class="s1">} </span><span class="s2">catch </span><span class="s1">(error) {</span>
            <span class="s2">const </span><span class="s1">err = (</span><span class="s4">0</span><span class="s1">, _iserror.getProperError)(error);</span>
            <span class="s1">(</span><span class="s4">0</span><span class="s1">, _formatservererror.formatServerError)(err);</span>
            <span class="s2">this</span><span class="s1">.logErrorWithOriginalStack(err);</span>
            <span class="s2">if </span><span class="s1">(!res.sent) {</span>
                <span class="s1">res.statusCode = </span><span class="s4">500</span><span class="s1">;</span>
                <span class="s2">try </span><span class="s1">{</span>
                    <span class="s2">return await this</span><span class="s1">.renderError(err, req, res, pathname, {</span>
                        <span class="s1">__NEXT_PAGE: (</span><span class="s4">0</span><span class="s1">, _iserror.default)(err) &amp;&amp; err.page || pathname || </span><span class="s0">''</span>
                    <span class="s1">});</span>
                <span class="s1">} </span><span class="s2">catch </span><span class="s1">(internalErr) {</span>
                    <span class="s1">console.error(internalErr);</span>
                    <span class="s1">res.body(</span><span class="s0">'Internal Server Error'</span><span class="s1">).send();</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">logErrorWithOriginalStack(err, type) {</span>
        <span class="s2">this</span><span class="s1">.bundlerService.logErrorWithOriginalStack(err, type);</span>
    <span class="s1">}</span>
    <span class="s1">getPagesManifest() {</span>
        <span class="s2">return </span><span class="s1">_nodemanifestloader.NodeManifestLoader.require((</span><span class="s4">0</span><span class="s1">, _path.join)(</span><span class="s2">this</span><span class="s1">.serverDistDir, _constants1.PAGES_MANIFEST)) ?? undefined;</span>
    <span class="s1">}</span>
    <span class="s1">getAppPathsManifest() {</span>
        <span class="s2">if </span><span class="s1">(!</span><span class="s2">this</span><span class="s1">.enabledDirectories.app) </span><span class="s2">return </span><span class="s1">undefined;</span>
        <span class="s2">return </span><span class="s1">_nodemanifestloader.NodeManifestLoader.require((</span><span class="s4">0</span><span class="s1">, _path.join)(</span><span class="s2">this</span><span class="s1">.serverDistDir, _constants1.APP_PATHS_MANIFEST)) ?? undefined;</span>
    <span class="s1">}</span>
    <span class="s1">getinterceptionRoutePatterns() {</span>
        <span class="s2">const </span><span class="s1">rewrites = (</span><span class="s4">0</span><span class="s1">, _generateinterceptionroutesrewrites.generateInterceptionRoutesRewrites)(Object.keys(</span><span class="s2">this</span><span class="s1">.appPathRoutes ?? {}), </span><span class="s2">this</span><span class="s1">.nextConfig.basePath).map((route)=&gt;</span><span class="s2">new </span><span class="s1">RegExp((</span><span class="s4">0</span><span class="s1">, _buildcustomroute.buildCustomRoute)(</span><span class="s0">'rewrite'</span><span class="s1">, route).regex));</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.nextConfig.output === </span><span class="s0">'export' </span><span class="s1">&amp;&amp; rewrites.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s1">_log.error(</span><span class="s0">'Intercepting routes are not supported with static export.</span><span class="s5">\n</span><span class="s0">Read more: https://nextjs.org/docs/app/building-your-application/deploying/static-exports#unsupported-features'</span><span class="s1">);</span>
            <span class="s1">process.exit(</span><span class="s4">1</span><span class="s1">);</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">rewrites ?? [];</span>
    <span class="s1">}</span>
    <span class="s1">async getMiddleware() {</span>
        <span class="s2">var </span><span class="s1">_this_middleware;</span>
        <span class="s3">// We need to populate the match</span>
        <span class="s3">// field as it isn't serializable</span>
        <span class="s2">if </span><span class="s1">(((_this_middleware = </span><span class="s2">this</span><span class="s1">.middleware) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _this_middleware.match) === </span><span class="s2">null</span><span class="s1">) {</span>
            <span class="s2">this</span><span class="s1">.middleware.match = (</span><span class="s4">0</span><span class="s1">, _middlewareroutematcher.getMiddlewareRouteMatcher)(</span><span class="s2">this</span><span class="s1">.middleware.matchers || []);</span>
        <span class="s1">}</span>
        <span class="s2">return this</span><span class="s1">.middleware;</span>
    <span class="s1">}</span>
    <span class="s1">getNextFontManifest() {</span>
        <span class="s2">return </span><span class="s1">undefined;</span>
    <span class="s1">}</span>
    <span class="s1">async hasMiddleware() {</span>
        <span class="s2">return this</span><span class="s1">.hasPage(</span><span class="s2">this</span><span class="s1">.actualMiddlewareFile);</span>
    <span class="s1">}</span>
    <span class="s1">async ensureMiddleware(url) {</span>
        <span class="s2">return this</span><span class="s1">.ensurePage({</span>
            <span class="s1">page: </span><span class="s2">this</span><span class="s1">.actualMiddlewareFile,</span>
            <span class="s1">clientOnly: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">definition: undefined,</span>
            <span class="s1">url</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">async loadInstrumentationModule() {</span>
        <span class="s2">let </span><span class="s1">instrumentationModule;</span>
        <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.actualInstrumentationHookFile &amp;&amp; </span><span class="s2">await this</span><span class="s1">.ensurePage({</span>
            <span class="s1">page: </span><span class="s2">this</span><span class="s1">.actualInstrumentationHookFile,</span>
            <span class="s1">clientOnly: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">definition: undefined</span>
        <span class="s1">}).then(()=&gt;</span><span class="s2">true</span><span class="s1">).catch(()=&gt;</span><span class="s2">false</span><span class="s1">)) {</span>
            <span class="s2">try </span><span class="s1">{</span>
                <span class="s1">instrumentationModule = </span><span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _instrumentationglobalsexternal.getInstrumentationModule)(</span><span class="s2">this</span><span class="s1">.dir, </span><span class="s2">this</span><span class="s1">.nextConfig.distDir);</span>
            <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
                <span class="s1">err.message = </span><span class="s0">`An error occurred while loading instrumentation hook: </span><span class="s1">${err.message}</span><span class="s0">`</span><span class="s1">;</span>
                <span class="s2">throw </span><span class="s1">err;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">instrumentationModule;</span>
    <span class="s1">}</span>
    <span class="s1">async runInstrumentationHookIfAvailable() {</span>
        <span class="s2">await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _instrumentationglobalsexternal.ensureInstrumentationRegistered)(</span><span class="s2">this</span><span class="s1">.dir, </span><span class="s2">this</span><span class="s1">.nextConfig.distDir);</span>
    <span class="s1">}</span>
    <span class="s1">async ensureEdgeFunction({ page, appPaths, url }) {</span>
        <span class="s2">return this</span><span class="s1">.ensurePage({</span>
            <span class="s1">page,</span>
            <span class="s1">appPaths,</span>
            <span class="s1">clientOnly: </span><span class="s2">false</span><span class="s1">,</span>
            <span class="s1">definition: undefined,</span>
            <span class="s1">url</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">generateRoutes(_dev) {</span>
    <span class="s3">// In development we expose all compiled files for react-error-overlay's line show feature</span>
    <span class="s3">// We use unshift so that we're sure the routes is defined before Next's default routes</span>
    <span class="s3">// routes.unshift({</span>
    <span class="s3">//   match: getPathMatch('/_next/development/:path*'),</span>
    <span class="s3">//   type: 'route',</span>
    <span class="s3">//   name: '_next/development catchall',</span>
    <span class="s3">//   fn: async (req, res, params) =&gt; {</span>
    <span class="s3">//     const p = pathJoin(this.distDir, ...(params.path || []))</span>
    <span class="s3">//     await this.serveStatic(req, res, p)</span>
    <span class="s3">//     return {</span>
    <span class="s3">//       finished: true,</span>
    <span class="s3">//     }</span>
    <span class="s3">//   },</span>
    <span class="s3">// })</span>
    <span class="s1">}</span>
    <span class="s1">_filterAmpDevelopmentScript(html, event) {</span>
        <span class="s2">if </span><span class="s1">(event.code !== </span><span class="s0">'DISALLOWED_SCRIPT_TAG'</span><span class="s1">) {</span>
            <span class="s2">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s2">const </span><span class="s1">snippetChunks = html.split(</span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">);</span>
        <span class="s2">let </span><span class="s1">snippet;</span>
        <span class="s2">if </span><span class="s1">(!(snippet = html.split(</span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">)[event.line - </span><span class="s4">1</span><span class="s1">]) || !(snippet = snippet.substring(event.col))) {</span>
            <span class="s2">return true</span><span class="s1">;</span>
        <span class="s1">}</span>
        <span class="s1">snippet = snippet + snippetChunks.slice(event.line).join(</span><span class="s0">'</span><span class="s5">\n</span><span class="s0">'</span><span class="s1">);</span>
        <span class="s1">snippet = snippet.substring(</span><span class="s4">0</span><span class="s1">, snippet.indexOf(</span><span class="s0">'&lt;/script&gt;'</span><span class="s1">));</span>
        <span class="s2">return </span><span class="s1">!snippet.includes(</span><span class="s0">'data-amp-development-mode-only'</span><span class="s1">);</span>
    <span class="s1">}</span>
    <span class="s1">async getStaticPaths({ pathname, urlPathname, requestHeaders, page, isAppPath }) {</span>
        <span class="s3">// we lazy load the staticPaths to prevent the user</span>
        <span class="s3">// from waiting on them for the page to load in dev mode</span>
        <span class="s2">const </span><span class="s1">__getStaticPaths = async ()=&gt;{</span>
            <span class="s2">const </span><span class="s1">{ configFileName, publicRuntimeConfig, serverRuntimeConfig, httpAgentOptions } = </span><span class="s2">this</span><span class="s1">.nextConfig;</span>
            <span class="s2">const </span><span class="s1">{ locales, defaultLocale } = </span><span class="s2">this</span><span class="s1">.nextConfig.i18n || {};</span>
            <span class="s2">const </span><span class="s1">staticPathsWorker = </span><span class="s2">this</span><span class="s1">.getStaticPathsWorker();</span>
            <span class="s2">try </span><span class="s1">{</span>
                <span class="s2">var </span><span class="s1">_this_nextConfig_experimental_sri;</span>
                <span class="s2">const </span><span class="s1">pathsResult = </span><span class="s2">await </span><span class="s1">staticPathsWorker.loadStaticPaths({</span>
                    <span class="s1">dir: </span><span class="s2">this</span><span class="s1">.dir,</span>
                    <span class="s1">distDir: </span><span class="s2">this</span><span class="s1">.distDir,</span>
                    <span class="s1">pathname,</span>
                    <span class="s1">config: {</span>
                        <span class="s1">pprConfig: </span><span class="s2">this</span><span class="s1">.nextConfig.experimental.ppr,</span>
                        <span class="s1">configFileName,</span>
                        <span class="s1">publicRuntimeConfig,</span>
                        <span class="s1">serverRuntimeConfig,</span>
                        <span class="s1">cacheComponents: Boolean(</span><span class="s2">this</span><span class="s1">.nextConfig.experimental.cacheComponents)</span>
                    <span class="s1">},</span>
                    <span class="s1">httpAgentOptions,</span>
                    <span class="s1">locales,</span>
                    <span class="s1">defaultLocale,</span>
                    <span class="s1">page,</span>
                    <span class="s1">isAppPath,</span>
                    <span class="s1">requestHeaders,</span>
                    <span class="s1">cacheHandler: </span><span class="s2">this</span><span class="s1">.nextConfig.cacheHandler,</span>
                    <span class="s1">cacheHandlers: </span><span class="s2">this</span><span class="s1">.nextConfig.experimental.cacheHandlers,</span>
                    <span class="s1">cacheLifeProfiles: </span><span class="s2">this</span><span class="s1">.nextConfig.experimental.cacheLife,</span>
                    <span class="s1">fetchCacheKeyPrefix: </span><span class="s2">this</span><span class="s1">.nextConfig.experimental.fetchCacheKeyPrefix,</span>
                    <span class="s1">isrFlushToDisk: </span><span class="s2">this</span><span class="s1">.nextConfig.experimental.isrFlushToDisk,</span>
                    <span class="s1">maxMemoryCacheSize: </span><span class="s2">this</span><span class="s1">.nextConfig.cacheMaxMemorySize,</span>
                    <span class="s1">nextConfigOutput: </span><span class="s2">this</span><span class="s1">.nextConfig.output,</span>
                    <span class="s1">buildId: </span><span class="s2">this</span><span class="s1">.buildId,</span>
                    <span class="s1">authInterrupts: Boolean(</span><span class="s2">this</span><span class="s1">.nextConfig.experimental.authInterrupts),</span>
                    <span class="s1">sriEnabled: Boolean((_this_nextConfig_experimental_sri = </span><span class="s2">this</span><span class="s1">.nextConfig.experimental.sri) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _this_nextConfig_experimental_sri.algorithm)</span>
                <span class="s1">});</span>
                <span class="s2">return </span><span class="s1">pathsResult;</span>
            <span class="s1">} </span><span class="s2">finally</span><span class="s1">{</span>
                <span class="s3">// we don't re-use workers so destroy the used one</span>
                <span class="s1">staticPathsWorker.end();</span>
            <span class="s1">}</span>
        <span class="s1">};</span>
        <span class="s2">const </span><span class="s1">result = </span><span class="s2">this</span><span class="s1">.staticPathsCache.get(pathname);</span>
        <span class="s2">const </span><span class="s1">nextInvoke = (</span><span class="s4">0</span><span class="s1">, _coalescedfunction.withCoalescedInvoke)(__getStaticPaths)(</span><span class="s0">`staticPaths-</span><span class="s1">${pathname}</span><span class="s0">`</span><span class="s1">, []).then(async (res)=&gt;{</span>
            <span class="s2">var </span><span class="s1">_res_value;</span>
            <span class="s2">const </span><span class="s1">{ prerenderedRoutes, fallbackMode: fallback } = res.value;</span>
            <span class="s2">if </span><span class="s1">(isAppPath) {</span>
                <span class="s2">if </span><span class="s1">(</span><span class="s2">this</span><span class="s1">.nextConfig.output === </span><span class="s0">'export'</span><span class="s1">) {</span>
                    <span class="s2">if </span><span class="s1">(!prerenderedRoutes) {</span>
                        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`Page &quot;</span><span class="s1">${page}</span><span class="s0">&quot; is missing exported function &quot;generateStaticParams()&quot;, which is required with &quot;output: export&quot; config.`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                            <span class="s1">value: </span><span class="s0">&quot;E353&quot;</span><span class="s1">,</span>
                            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                            <span class="s1">configurable: </span><span class="s2">true</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                    <span class="s2">if </span><span class="s1">(!prerenderedRoutes.some((item)=&gt;item.pathname === urlPathname)) {</span>
                        <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">`Page &quot;</span><span class="s1">${page}</span><span class="s0">&quot; is missing param &quot;</span><span class="s1">${pathname}</span><span class="s0">&quot; in &quot;generateStaticParams()&quot;, which is required with &quot;output: export&quot; config.`</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                            <span class="s1">value: </span><span class="s0">&quot;E443&quot;</span><span class="s1">,</span>
                            <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                            <span class="s1">configurable: </span><span class="s2">true</span>
                        <span class="s1">});</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">if </span><span class="s1">(!isAppPath &amp;&amp; </span><span class="s2">this</span><span class="s1">.nextConfig.output === </span><span class="s0">'export'</span><span class="s1">) {</span>
                <span class="s2">if </span><span class="s1">(fallback === _fallback.FallbackMode.BLOCKING_STATIC_RENDER) {</span>
                    <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'getStaticPaths with &quot;fallback: blocking&quot; cannot be used with &quot;output: export&quot;. See more info here: https://nextjs.org/docs/advanced-features/static-html-export'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                        <span class="s1">value: </span><span class="s0">&quot;E11&quot;</span><span class="s1">,</span>
                        <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">configurable: </span><span class="s2">true</span>
                    <span class="s1">});</span>
                <span class="s1">} </span><span class="s2">else if </span><span class="s1">(fallback === _fallback.FallbackMode.PRERENDER) {</span>
                    <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">'getStaticPaths with &quot;fallback: true&quot; cannot be used with &quot;output: export&quot;. See more info here: https://nextjs.org/docs/advanced-features/static-html-export'</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                        <span class="s1">value: </span><span class="s0">&quot;E210&quot;</span><span class="s1">,</span>
                        <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                        <span class="s1">configurable: </span><span class="s2">true</span>
                    <span class="s1">});</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">const </span><span class="s1">value = {</span>
                <span class="s1">staticPaths: prerenderedRoutes == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: prerenderedRoutes.map((route)=&gt;route.pathname),</span>
                <span class="s1">prerenderedRoutes,</span>
                <span class="s1">fallbackMode: fallback</span>
            <span class="s1">};</span>
            <span class="s2">if </span><span class="s1">(((_res_value = res.value) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _res_value.fallbackMode) !== undefined &amp;&amp; </span><span class="s3">// This matches the hasGenerateStaticParams logic</span>
            <span class="s3">// we do during build</span>
            <span class="s1">(!isAppPath || prerenderedRoutes &amp;&amp; prerenderedRoutes.length &gt; </span><span class="s4">0</span><span class="s1">)) {</span>
                <span class="s3">// we write the static paths to partial manifest for</span>
                <span class="s3">// fallback handling inside of entry handler's</span>
                <span class="s2">const </span><span class="s1">rawExistingManifest = </span><span class="s2">await </span><span class="s1">_fs.default.promises.readFile((</span><span class="s4">0</span><span class="s1">, _path.join)(</span><span class="s2">this</span><span class="s1">.distDir, _constants1.PRERENDER_MANIFEST), </span><span class="s0">'utf8'</span><span class="s1">);</span>
                <span class="s2">const </span><span class="s1">existingManifest = JSON.parse(rawExistingManifest);</span>
                <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">staticPath of value.staticPaths || []){</span>
                    <span class="s1">existingManifest.routes[staticPath] = {};</span>
                <span class="s1">}</span>
                <span class="s1">existingManifest.dynamicRoutes[pathname] = {</span>
                    <span class="s1">dataRoute: </span><span class="s2">null</span><span class="s1">,</span>
                    <span class="s1">dataRouteRegex: </span><span class="s2">null</span><span class="s1">,</span>
                    <span class="s1">fallback: (</span><span class="s4">0</span><span class="s1">, _fallback.fallbackModeToFallbackField)(res.value.fallbackMode, page),</span>
                    <span class="s1">fallbackRevalidate: </span><span class="s2">false</span><span class="s1">,</span>
                    <span class="s1">fallbackExpire: undefined,</span>
                    <span class="s1">fallbackHeaders: undefined,</span>
                    <span class="s1">fallbackStatus: undefined,</span>
                    <span class="s1">fallbackRootParams: undefined,</span>
                    <span class="s1">fallbackSourceRoute: pathname,</span>
                    <span class="s1">prefetchDataRoute: undefined,</span>
                    <span class="s1">prefetchDataRouteRegex: undefined,</span>
                    <span class="s1">routeRegex: (</span><span class="s4">0</span><span class="s1">, _routeregex.getRouteRegex)(pathname).re.source,</span>
                    <span class="s1">experimentalPPR: undefined,</span>
                    <span class="s1">renderingMode: undefined,</span>
                    <span class="s1">allowHeader: []</span>
                <span class="s1">};</span>
                <span class="s2">const </span><span class="s1">updatedManifest = JSON.stringify(existingManifest);</span>
                <span class="s2">if </span><span class="s1">(updatedManifest !== rawExistingManifest) {</span>
                    <span class="s2">await </span><span class="s1">_fs.default.promises.writeFile((</span><span class="s4">0</span><span class="s1">, _path.join)(</span><span class="s2">this</span><span class="s1">.distDir, _constants1.PRERENDER_MANIFEST), updatedManifest);</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s2">this</span><span class="s1">.staticPathsCache.set(pathname, value);</span>
            <span class="s2">return </span><span class="s1">value;</span>
        <span class="s1">}).catch((err)=&gt;{</span>
            <span class="s2">this</span><span class="s1">.staticPathsCache.remove(pathname);</span>
            <span class="s2">if </span><span class="s1">(!result) </span><span class="s2">throw </span><span class="s1">err;</span>
            <span class="s1">_log.error(</span><span class="s0">`Failed to generate static paths for </span><span class="s1">${pathname}</span><span class="s0">:`</span><span class="s1">);</span>
            <span class="s1">console.error(err);</span>
        <span class="s1">});</span>
        <span class="s2">if </span><span class="s1">(result) {</span>
            <span class="s2">return </span><span class="s1">result;</span>
        <span class="s1">}</span>
        <span class="s2">return </span><span class="s1">nextInvoke;</span>
    <span class="s1">}</span>
    <span class="s1">async ensurePage(opts) {</span>
        <span class="s2">await this</span><span class="s1">.bundlerService.ensurePage(opts);</span>
    <span class="s1">}</span>
    <span class="s1">async findPageComponents({ locale, page, query, params, isAppPath, appPaths = </span><span class="s2">null</span><span class="s1">, shouldEnsure, url }) {</span>
        <span class="s2">var </span><span class="s1">_this_ready;</span>
        <span class="s2">await </span><span class="s1">((_this_ready = </span><span class="s2">this</span><span class="s1">.ready) == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s4">0 </span><span class="s1">: _this_ready.promise);</span>
        <span class="s2">const </span><span class="s1">compilationErr = </span><span class="s2">await this</span><span class="s1">.getCompilationError(page);</span>
        <span class="s2">if </span><span class="s1">(compilationErr) {</span>
            <span class="s3">// Wrap build errors so that they don't get logged again</span>
            <span class="s2">throw new </span><span class="s1">_nextserver.WrappedBuildError(compilationErr);</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(shouldEnsure || </span><span class="s2">this</span><span class="s1">.serverOptions.customServer) {</span>
            <span class="s2">await this</span><span class="s1">.ensurePage({</span>
                <span class="s1">page,</span>
                <span class="s1">appPaths,</span>
                <span class="s1">clientOnly: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">definition: undefined,</span>
                <span class="s1">url</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">this</span><span class="s1">.nextFontManifest = </span><span class="s2">super</span><span class="s1">.getNextFontManifest();</span>
        <span class="s2">return await super</span><span class="s1">.findPageComponents({</span>
            <span class="s1">page,</span>
            <span class="s1">query,</span>
            <span class="s1">params,</span>
            <span class="s1">locale,</span>
            <span class="s1">isAppPath,</span>
            <span class="s1">shouldEnsure,</span>
            <span class="s1">url</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s1">async getFallbackErrorComponents(url) {</span>
        <span class="s2">await this</span><span class="s1">.bundlerService.getFallbackErrorComponents(url);</span>
        <span class="s2">return await </span><span class="s1">(</span><span class="s4">0</span><span class="s1">, _loaddefaulterrorcomponents.loadDefaultErrorComponents)(</span><span class="s2">this</span><span class="s1">.distDir);</span>
    <span class="s1">}</span>
    <span class="s1">async getCompilationError(page) {</span>
        <span class="s2">return await this</span><span class="s1">.bundlerService.getCompilationError(page);</span>
    <span class="s1">}</span>
    <span class="s1">async instrumentationOnRequestError(...args) {</span>
        <span class="s2">await super</span><span class="s1">.instrumentationOnRequestError(...args);</span>
        <span class="s2">const </span><span class="s1">err = args[</span><span class="s4">0</span><span class="s1">];</span>
        <span class="s2">this</span><span class="s1">.logErrorWithOriginalStack(err, </span><span class="s0">'app-dir'</span><span class="s1">);</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s3">//# sourceMappingURL=next-dev-server.js.map</span></pre>
</body>
</html>