<html>
<head>
<title>prepare-destination.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #067d17;}
.s1 { color: #080808;}
.s2 { color: #0033b3;}
.s3 { color: #1750eb;}
.s4 { color: #8c8c8c; font-style: italic;}
.s5 { color: #264eff;}
.s6 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
prepare-destination.js</font>
</center></td></tr></table>
<pre><span class="s0">&quot;use strict&quot;</span><span class="s1">;</span>
<span class="s1">Object.defineProperty(exports, </span><span class="s0">&quot;__esModule&quot;</span><span class="s1">, {</span>
    <span class="s1">value: </span><span class="s2">true</span>
<span class="s1">});</span>
<span class="s3">0 </span><span class="s1">&amp;&amp; (module.exports = {</span>
    <span class="s1">compileNonPath: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">matchHas: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">parseDestination: </span><span class="s2">null</span><span class="s1">,</span>
    <span class="s1">prepareDestination: </span><span class="s2">null</span>
<span class="s1">});</span>
<span class="s2">function </span><span class="s1">_export(target, all) {</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">var </span><span class="s1">name </span><span class="s2">in </span><span class="s1">all)Object.defineProperty(target, name, {</span>
        <span class="s1">enumerable: </span><span class="s2">true</span><span class="s1">,</span>
        <span class="s1">get: all[name]</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s1">_export(exports, {</span>
    <span class="s1">compileNonPath: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">compileNonPath;</span>
    <span class="s1">},</span>
    <span class="s1">matchHas: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">matchHas;</span>
    <span class="s1">},</span>
    <span class="s1">parseDestination: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">parseDestination;</span>
    <span class="s1">},</span>
    <span class="s1">prepareDestination: </span><span class="s2">function</span><span class="s1">() {</span>
        <span class="s2">return </span><span class="s1">prepareDestination;</span>
    <span class="s1">}</span>
<span class="s1">});</span>
<span class="s2">const </span><span class="s1">_escaperegexp = require(</span><span class="s0">&quot;../../escape-regexp&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_parseurl = require(</span><span class="s0">&quot;./parse-url&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_interceptionroutes = require(</span><span class="s0">&quot;./interception-routes&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_getcookieparser = require(</span><span class="s0">&quot;../../../../server/api-utils/get-cookie-parser&quot;</span><span class="s1">);</span>
<span class="s2">const </span><span class="s1">_routematchutils = require(</span><span class="s0">&quot;./route-match-utils&quot;</span><span class="s1">);</span>
<span class="s4">/**</span>
 <span class="s4">* Ensure only a-zA-Z are used for param names for proper interpolating</span>
 <span class="s4">* with path-to-regexp</span>
 <span class="s4">*/ </span><span class="s2">function </span><span class="s1">getSafeParamName(paramName) {</span>
    <span class="s2">let </span><span class="s1">newParamName = </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s2">for</span><span class="s1">(</span><span class="s2">let </span><span class="s1">i = </span><span class="s3">0</span><span class="s1">; i &lt; paramName.length; i++){</span>
        <span class="s2">const </span><span class="s1">charCode = paramName.charCodeAt(i);</span>
        <span class="s2">if </span><span class="s1">(charCode &gt; </span><span class="s3">64 </span><span class="s1">&amp;&amp; charCode &lt; </span><span class="s3">91 </span><span class="s1">|| </span><span class="s4">// A-Z</span>
        <span class="s1">charCode &gt; </span><span class="s3">96 </span><span class="s1">&amp;&amp; charCode &lt; </span><span class="s3">123 </span><span class="s4">// a-z</span>
        <span class="s1">) {</span>
            <span class="s1">newParamName += paramName[i];</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">newParamName;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">escapeSegment(str, segmentName) {</span>
    <span class="s2">return </span><span class="s1">str.replace(</span><span class="s2">new </span><span class="s1">RegExp(</span><span class="s0">&quot;:&quot; </span><span class="s1">+ (</span><span class="s3">0</span><span class="s1">, _escaperegexp.escapeStringRegexp)(segmentName), </span><span class="s0">'g'</span><span class="s1">), </span><span class="s0">&quot;__ESC_COLON_&quot; </span><span class="s1">+ segmentName);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">unescapeSegments(str) {</span>
    <span class="s2">return </span><span class="s1">str.replace(</span><span class="s5">/__ESC_COLON_/gi</span><span class="s1">, </span><span class="s0">':'</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">matchHas(req, query, has, missing) {</span>
    <span class="s2">if </span><span class="s1">(has === </span><span class="s2">void </span><span class="s3">0</span><span class="s1">) has = [];</span>
    <span class="s2">if </span><span class="s1">(missing === </span><span class="s2">void </span><span class="s3">0</span><span class="s1">) missing = [];</span>
    <span class="s2">const </span><span class="s1">params = {};</span>
    <span class="s2">const </span><span class="s1">hasMatch = (hasItem)=&gt;{</span>
        <span class="s2">let </span><span class="s1">value;</span>
        <span class="s2">let </span><span class="s1">key = hasItem.key;</span>
        <span class="s2">switch</span><span class="s1">(hasItem.type){</span>
            <span class="s2">case </span><span class="s0">'header'</span><span class="s1">:</span>
                <span class="s1">{</span>
                    <span class="s1">key = key.toLowerCase();</span>
                    <span class="s1">value = req.headers[key];</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s2">case </span><span class="s0">'cookie'</span><span class="s1">:</span>
                <span class="s1">{</span>
                    <span class="s2">if </span><span class="s1">(</span><span class="s0">'cookies' </span><span class="s2">in </span><span class="s1">req) {</span>
                        <span class="s1">value = req.cookies[hasItem.key];</span>
                    <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                        <span class="s2">const </span><span class="s1">cookies = (</span><span class="s3">0</span><span class="s1">, _getcookieparser.getCookieParser)(req.headers)();</span>
                        <span class="s1">value = cookies[hasItem.key];</span>
                    <span class="s1">}</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s2">case </span><span class="s0">'query'</span><span class="s1">:</span>
                <span class="s1">{</span>
                    <span class="s1">value = query[key];</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s2">case </span><span class="s0">'host'</span><span class="s1">:</span>
                <span class="s1">{</span>
                    <span class="s2">const </span><span class="s1">{ host } = (req == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: req.headers) || {};</span>
                    <span class="s4">// remove port from host if present</span>
                    <span class="s2">const </span><span class="s1">hostname = host == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">void </span><span class="s3">0 </span><span class="s1">: host.split(</span><span class="s0">':'</span><span class="s1">, </span><span class="s3">1</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">].toLowerCase();</span>
                    <span class="s1">value = hostname;</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s1">}</span>
            <span class="s2">default</span><span class="s1">:</span>
                <span class="s1">{</span>
                    <span class="s2">break</span><span class="s1">;</span>
                <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">if </span><span class="s1">(!hasItem.value &amp;&amp; value) {</span>
            <span class="s1">params[getSafeParamName(key)] = value;</span>
            <span class="s2">return true</span><span class="s1">;</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(value) {</span>
            <span class="s2">const </span><span class="s1">matcher = </span><span class="s2">new </span><span class="s1">RegExp(</span><span class="s0">&quot;^&quot; </span><span class="s1">+ hasItem.value + </span><span class="s0">&quot;$&quot;</span><span class="s1">);</span>
            <span class="s2">const </span><span class="s1">matches = Array.isArray(value) ? value.slice(-</span><span class="s3">1</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">].match(matcher) : value.match(matcher);</span>
            <span class="s2">if </span><span class="s1">(matches) {</span>
                <span class="s2">if </span><span class="s1">(Array.isArray(matches)) {</span>
                    <span class="s2">if </span><span class="s1">(matches.groups) {</span>
                        <span class="s1">Object.keys(matches.groups).forEach((groupKey)=&gt;{</span>
                            <span class="s1">params[groupKey] = matches.groups[groupKey];</span>
                        <span class="s1">});</span>
                    <span class="s1">} </span><span class="s2">else if </span><span class="s1">(hasItem.type === </span><span class="s0">'host' </span><span class="s1">&amp;&amp; matches[</span><span class="s3">0</span><span class="s1">]) {</span>
                        <span class="s1">params.host = matches[</span><span class="s3">0</span><span class="s1">];</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s2">return true</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s2">return false</span><span class="s1">;</span>
    <span class="s1">};</span>
    <span class="s2">const </span><span class="s1">allMatch = has.every((item)=&gt;hasMatch(item)) &amp;&amp; !missing.some((item)=&gt;hasMatch(item));</span>
    <span class="s2">if </span><span class="s1">(allMatch) {</span>
        <span class="s2">return </span><span class="s1">params;</span>
    <span class="s1">}</span>
    <span class="s2">return false</span><span class="s1">;</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">compileNonPath(value, params) {</span>
    <span class="s2">if </span><span class="s1">(!value.includes(</span><span class="s0">':'</span><span class="s1">)) {</span>
        <span class="s2">return </span><span class="s1">value;</span>
    <span class="s1">}</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key of Object.keys(params)){</span>
        <span class="s2">if </span><span class="s1">(value.includes(</span><span class="s0">&quot;:&quot; </span><span class="s1">+ key)) {</span>
            <span class="s1">value = value.replace(</span><span class="s2">new </span><span class="s1">RegExp(</span><span class="s0">&quot;:&quot; </span><span class="s1">+ key + </span><span class="s0">&quot;</span><span class="s6">\\</span><span class="s0">*&quot;</span><span class="s1">, </span><span class="s0">'g'</span><span class="s1">), </span><span class="s0">&quot;:&quot; </span><span class="s1">+ key + </span><span class="s0">&quot;--ESCAPED_PARAM_ASTERISKS&quot;</span><span class="s1">).replace(</span><span class="s2">new </span><span class="s1">RegExp(</span><span class="s0">&quot;:&quot; </span><span class="s1">+ key + </span><span class="s0">&quot;</span><span class="s6">\\</span><span class="s0">?&quot;</span><span class="s1">, </span><span class="s0">'g'</span><span class="s1">), </span><span class="s0">&quot;:&quot; </span><span class="s1">+ key + </span><span class="s0">&quot;--ESCAPED_PARAM_QUESTION&quot;</span><span class="s1">).replace(</span><span class="s2">new </span><span class="s1">RegExp(</span><span class="s0">&quot;:&quot; </span><span class="s1">+ key + </span><span class="s0">&quot;</span><span class="s6">\\</span><span class="s0">+&quot;</span><span class="s1">, </span><span class="s0">'g'</span><span class="s1">), </span><span class="s0">&quot;:&quot; </span><span class="s1">+ key + </span><span class="s0">&quot;--ESCAPED_PARAM_PLUS&quot;</span><span class="s1">).replace(</span><span class="s2">new </span><span class="s1">RegExp(</span><span class="s0">&quot;:&quot; </span><span class="s1">+ key + </span><span class="s0">&quot;(?!</span><span class="s6">\\</span><span class="s0">w)&quot;</span><span class="s1">, </span><span class="s0">'g'</span><span class="s1">), </span><span class="s0">&quot;--ESCAPED_PARAM_COLON&quot; </span><span class="s1">+ key);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">value = value.replace(</span><span class="s5">/(:|\*|\?|\+|\(|\)|\{|\})/g</span><span class="s1">, </span><span class="s0">'</span><span class="s6">\\</span><span class="s0">$1'</span><span class="s1">).replace(</span><span class="s5">/--ESCAPED_PARAM_PLUS/g</span><span class="s1">, </span><span class="s0">'+'</span><span class="s1">).replace(</span><span class="s5">/--ESCAPED_PARAM_COLON/g</span><span class="s1">, </span><span class="s0">':'</span><span class="s1">).replace(</span><span class="s5">/--ESCAPED_PARAM_QUESTION/g</span><span class="s1">, </span><span class="s0">'?'</span><span class="s1">).replace(</span><span class="s5">/--ESCAPED_PARAM_ASTERISKS/g</span><span class="s1">, </span><span class="s0">'*'</span><span class="s1">);</span>
    <span class="s4">// the value needs to start with a forward-slash to be compiled</span>
    <span class="s4">// correctly</span>
    <span class="s2">return </span><span class="s1">(</span><span class="s3">0</span><span class="s1">, _routematchutils.safeCompile)(</span><span class="s0">&quot;/&quot; </span><span class="s1">+ value, {</span>
        <span class="s1">validate: </span><span class="s2">false</span>
    <span class="s1">})(params).slice(</span><span class="s3">1</span><span class="s1">);</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">parseDestination(args) {</span>
    <span class="s2">let </span><span class="s1">escaped = args.destination;</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">param of Object.keys({</span>
        <span class="s1">...args.params,</span>
        <span class="s1">...args.query</span>
    <span class="s1">})){</span>
        <span class="s2">if </span><span class="s1">(!param) </span><span class="s2">continue</span><span class="s1">;</span>
        <span class="s1">escaped = escapeSegment(escaped, param);</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">parsed = (</span><span class="s3">0</span><span class="s1">, _parseurl.parseUrl)(escaped);</span>
    <span class="s2">let </span><span class="s1">pathname = parsed.pathname;</span>
    <span class="s2">if </span><span class="s1">(pathname) {</span>
        <span class="s1">pathname = unescapeSegments(pathname);</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">href = parsed.href;</span>
    <span class="s2">if </span><span class="s1">(href) {</span>
        <span class="s1">href = unescapeSegments(href);</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">hostname = parsed.hostname;</span>
    <span class="s2">if </span><span class="s1">(hostname) {</span>
        <span class="s1">hostname = unescapeSegments(hostname);</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">hash = parsed.hash;</span>
    <span class="s2">if </span><span class="s1">(hash) {</span>
        <span class="s1">hash = unescapeSegments(hash);</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">search = parsed.search;</span>
    <span class="s2">if </span><span class="s1">(search) {</span>
        <span class="s1">search = unescapeSegments(search);</span>
    <span class="s1">}</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">...parsed,</span>
        <span class="s1">pathname,</span>
        <span class="s1">hostname,</span>
        <span class="s1">href,</span>
        <span class="s1">hash,</span>
        <span class="s1">search</span>
    <span class="s1">};</span>
<span class="s1">}</span>
<span class="s2">function </span><span class="s1">prepareDestination(args) {</span>
    <span class="s2">const </span><span class="s1">parsedDestination = parseDestination(args);</span>
    <span class="s2">const </span><span class="s1">{ hostname: destHostname, query: destQuery, search: destSearch } = parsedDestination;</span>
    <span class="s4">// The following code assumes that the pathname here includes the hash if it's</span>
    <span class="s4">// present.</span>
    <span class="s2">let </span><span class="s1">destPath = parsedDestination.pathname;</span>
    <span class="s2">if </span><span class="s1">(parsedDestination.hash) {</span>
        <span class="s1">destPath = </span><span class="s0">&quot;&quot; </span><span class="s1">+ destPath + parsedDestination.hash;</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">destParams = [];</span>
    <span class="s2">const </span><span class="s1">destPathParamKeys = [];</span>
    <span class="s1">(</span><span class="s3">0</span><span class="s1">, _routematchutils.safePathToRegexp)(destPath, destPathParamKeys);</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key of destPathParamKeys){</span>
        <span class="s1">destParams.push(key.name);</span>
    <span class="s1">}</span>
    <span class="s2">if </span><span class="s1">(destHostname) {</span>
        <span class="s2">const </span><span class="s1">destHostnameParamKeys = [];</span>
        <span class="s1">(</span><span class="s3">0</span><span class="s1">, _routematchutils.safePathToRegexp)(destHostname, destHostnameParamKeys);</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key of destHostnameParamKeys){</span>
            <span class="s1">destParams.push(key.name);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">const </span><span class="s1">destPathCompiler = (</span><span class="s3">0</span><span class="s1">, _routematchutils.safeCompile)(destPath, </span><span class="s4">// we don't validate while compiling the destination since we should</span>
    <span class="s4">// have already validated before we got to this point and validating</span>
    <span class="s4">// breaks compiling destinations with named pattern params from the source</span>
    <span class="s4">// e.g. /something:hello(.*) -&gt; /another/:hello is broken with validation</span>
    <span class="s4">// since compile validation is meant for reversing and not for inserting</span>
    <span class="s4">// params from a separate path-regex into another</span>
    <span class="s1">{</span>
        <span class="s1">validate: </span><span class="s2">false</span>
    <span class="s1">});</span>
    <span class="s2">let </span><span class="s1">destHostnameCompiler;</span>
    <span class="s2">if </span><span class="s1">(destHostname) {</span>
        <span class="s1">destHostnameCompiler = (</span><span class="s3">0</span><span class="s1">, _routematchutils.safeCompile)(destHostname, {</span>
            <span class="s1">validate: </span><span class="s2">false</span>
        <span class="s1">});</span>
    <span class="s1">}</span>
    <span class="s4">// update any params in query values</span>
    <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">[key, strOrArray] of Object.entries(destQuery)){</span>
        <span class="s4">// the value needs to start with a forward-slash to be compiled</span>
        <span class="s4">// correctly</span>
        <span class="s2">if </span><span class="s1">(Array.isArray(strOrArray)) {</span>
            <span class="s1">destQuery[key] = strOrArray.map((value)=&gt;compileNonPath(unescapeSegments(value), args.params));</span>
        <span class="s1">} </span><span class="s2">else if </span><span class="s1">(</span><span class="s2">typeof </span><span class="s1">strOrArray === </span><span class="s0">'string'</span><span class="s1">) {</span>
            <span class="s1">destQuery[key] = compileNonPath(unescapeSegments(strOrArray), args.params);</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s4">// add path params to query if it's not a redirect and not</span>
    <span class="s4">// already defined in destination query or path</span>
    <span class="s2">let </span><span class="s1">paramKeys = Object.keys(args.params).filter((name)=&gt;name !== </span><span class="s0">'nextInternalLocale'</span><span class="s1">);</span>
    <span class="s2">if </span><span class="s1">(args.appendParamsToQuery &amp;&amp; !paramKeys.some((key)=&gt;destParams.includes(key))) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">key of paramKeys){</span>
            <span class="s2">if </span><span class="s1">(!(key </span><span class="s2">in </span><span class="s1">destQuery)) {</span>
                <span class="s1">destQuery[key] = args.params[key];</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">let </span><span class="s1">newUrl;</span>
    <span class="s4">// The compiler also that the interception route marker is an unnamed param, hence '0',</span>
    <span class="s4">// so we need to add it to the params object.</span>
    <span class="s2">if </span><span class="s1">((</span><span class="s3">0</span><span class="s1">, _interceptionroutes.isInterceptionRouteAppPath)(destPath)) {</span>
        <span class="s2">for </span><span class="s1">(</span><span class="s2">const </span><span class="s1">segment of destPath.split(</span><span class="s0">'/'</span><span class="s1">)){</span>
            <span class="s2">const </span><span class="s1">marker = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.find((m)=&gt;segment.startsWith(m));</span>
            <span class="s2">if </span><span class="s1">(marker) {</span>
                <span class="s2">if </span><span class="s1">(marker === </span><span class="s0">'(..)(..)'</span><span class="s1">) {</span>
                    <span class="s1">args.params[</span><span class="s0">'0'</span><span class="s1">] = </span><span class="s0">'(..)'</span><span class="s1">;</span>
                    <span class="s1">args.params[</span><span class="s0">'1'</span><span class="s1">] = </span><span class="s0">'(..)'</span><span class="s1">;</span>
                <span class="s1">} </span><span class="s2">else </span><span class="s1">{</span>
                    <span class="s1">args.params[</span><span class="s0">'0'</span><span class="s1">] = marker;</span>
                <span class="s1">}</span>
                <span class="s2">break</span><span class="s1">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s2">try </span><span class="s1">{</span>
        <span class="s1">newUrl = destPathCompiler(args.params);</span>
        <span class="s2">const </span><span class="s1">[pathname, hash] = newUrl.split(</span><span class="s0">'#'</span><span class="s1">, </span><span class="s3">2</span><span class="s1">);</span>
        <span class="s2">if </span><span class="s1">(destHostnameCompiler) {</span>
            <span class="s1">parsedDestination.hostname = destHostnameCompiler(args.params);</span>
        <span class="s1">}</span>
        <span class="s1">parsedDestination.pathname = pathname;</span>
        <span class="s1">parsedDestination.hash = </span><span class="s0">&quot;&quot; </span><span class="s1">+ (hash ? </span><span class="s0">'#' </span><span class="s1">: </span><span class="s0">''</span><span class="s1">) + (hash || </span><span class="s0">''</span><span class="s1">);</span>
        <span class="s1">parsedDestination.search = destSearch ? compileNonPath(destSearch, args.params) : </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s1">} </span><span class="s2">catch </span><span class="s1">(err) {</span>
        <span class="s2">if </span><span class="s1">(err.message.match(</span><span class="s5">/Expected .*? to not repeat, but got an array/</span><span class="s1">)) {</span>
            <span class="s2">throw </span><span class="s1">Object.defineProperty(</span><span class="s2">new </span><span class="s1">Error(</span><span class="s0">&quot;To use a multi-match in the destination you must add `*` at the end of the param name to signify it should repeat. https://nextjs.org/docs/messages/invalid-multi-match&quot;</span><span class="s1">), </span><span class="s0">&quot;__NEXT_ERROR_CODE&quot;</span><span class="s1">, {</span>
                <span class="s1">value: </span><span class="s0">&quot;E329&quot;</span><span class="s1">,</span>
                <span class="s1">enumerable: </span><span class="s2">false</span><span class="s1">,</span>
                <span class="s1">configurable: </span><span class="s2">true</span>
            <span class="s1">});</span>
        <span class="s1">}</span>
        <span class="s2">throw </span><span class="s1">err;</span>
    <span class="s1">}</span>
    <span class="s4">// Query merge order lowest priority to highest</span>
    <span class="s4">// 1. initial URL query values</span>
    <span class="s4">// 2. path segment values</span>
    <span class="s4">// 3. destination specified query values</span>
    <span class="s1">parsedDestination.query = {</span>
        <span class="s1">...args.query,</span>
        <span class="s1">...parsedDestination.query</span>
    <span class="s1">};</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s1">newUrl,</span>
        <span class="s1">destQuery,</span>
        <span class="s1">parsedDestination</span>
    <span class="s1">};</span>
<span class="s1">}</span>

<span class="s4">//# sourceMappingURL=prepare-destination.js.map</span></pre>
</body>
</html>