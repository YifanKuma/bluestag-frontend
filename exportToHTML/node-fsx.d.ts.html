<html>
<head>
<title>node-fsx.d.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8c8c8c; font-style: italic;}
.s1 { color: #080808;}
.s2 { color: #8c8c8c; font-style: italic;}
.s3 { color: #0033b3;}
.s4 { color: #067d17;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
node-fsx.d.ts</font>
</center></td></tr></table>
<pre><span class="s0">/// &lt;reference types=&quot;node&quot; resolution-mode=&quot;require&quot;/&gt;</span>
<span class="s0">/**</span>
 <span class="s0">* A class representing the Node.js implementation of Hfs.</span>
 <span class="s0">* </span><span class="s2">@implements </span><span class="s0">{HfsImpl}</span>
 <span class="s0">*/</span>
<span class="s3">export class </span><span class="s1">NodeHfsImpl </span><span class="s3">implements </span><span class="s1">HfsImpl {</span>
    <span class="s0">/**</span>
     <span class="s0">* Creates a new instance.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{object} [options] The options for the instance.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{Fsp} [options.fsp] The file system module to use.</span>
     <span class="s0">*/</span>
    <span class="s1">constructor({ fsp }?: {</span>
        <span class="s1">fsp?: Fsp;</span>
    <span class="s1">});</span>
    <span class="s0">/**</span>
     <span class="s0">* Reads a file and returns the contents as a string. Assumes UTF-8 encoding.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{string} filePath The path to the file to read.</span>
     <span class="s0">* </span><span class="s2">@returns </span><span class="s0">{Promise&lt;string|undefined&gt;} A promise that resolves with the contents of</span>
     <span class="s0">*     the file or undefined if the file doesn't exist.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{TypeError} If the file path is not a string.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{RangeError} If the file path is empty.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{RangeError} If the file path is not absolute.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{RangeError} If the file path is not a file.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{RangeError} If the file path is not readable.</span>
     <span class="s0">*/</span>
    <span class="s1">text(filePath: string): Promise&lt;string | undefined&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Reads a file and returns the contents as a JSON object. Assumes UTF-8 encoding.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{string} filePath The path to the file to read.</span>
     <span class="s0">* </span><span class="s2">@returns </span><span class="s0">{Promise&lt;object|undefined&gt;} A promise that resolves with the contents of</span>
     <span class="s0">*    the file or undefined if the file doesn't exist.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{SyntaxError} If the file contents are not valid JSON.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{Error} If the file cannot be read.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{TypeError} If the file path is not a string.</span>
     <span class="s0">*/</span>
    <span class="s1">json(filePath: string): Promise&lt;object | undefined&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Reads a file and returns the contents as an ArrayBuffer.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{string} filePath The path to the file to read.</span>
     <span class="s0">* </span><span class="s2">@returns </span><span class="s0">{Promise&lt;ArrayBuffer|undefined&gt;} A promise that resolves with the contents</span>
     <span class="s0">*    of the file or undefined if the file doesn't exist.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{Error} If the file cannot be read.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{TypeError} If the file path is not a string.</span>
     <span class="s0">* </span><span class="s2">@deprecated </span><span class="s0">Use bytes() instead.</span>
     <span class="s0">*/</span>
    <span class="s1">arrayBuffer(filePath: string): Promise&lt;ArrayBuffer | undefined&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Reads a file and returns the contents as an Uint8Array.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{string} filePath The path to the file to read.</span>
     <span class="s0">* </span><span class="s2">@returns </span><span class="s0">{Promise&lt;Uint8Array|undefined&gt;} A promise that resolves with the contents</span>
     <span class="s0">*    of the file or undefined if the file doesn't exist.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{Error} If the file cannot be read.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{TypeError} If the file path is not a string.</span>
     <span class="s0">*/</span>
    <span class="s1">bytes(filePath: string): Promise&lt;Uint8Array | undefined&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Writes a value to a file. If the value is a string, UTF-8 encoding is used.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{string} filePath The path to the file to write.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{string|ArrayBuffer|ArrayBufferView} contents The contents to write to the</span>
     <span class="s0">*   file.</span>
     <span class="s0">* </span><span class="s2">@returns </span><span class="s0">{Promise&lt;void&gt;} A promise that resolves when the file is</span>
     <span class="s0">*  written.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{TypeError} If the file path is not a string.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{Error} If the file cannot be written.</span>
     <span class="s0">*/</span>
    <span class="s1">write(filePath: string, contents: string | ArrayBuffer | ArrayBufferView): Promise&lt;</span><span class="s3">void</span><span class="s1">&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Checks if a file exists.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{string} filePath The path to the file to check.</span>
     <span class="s0">* </span><span class="s2">@returns </span><span class="s0">{Promise&lt;boolean&gt;} A promise that resolves with true if the</span>
     <span class="s0">*    file exists or false if it does not.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{Error} If the operation fails with a code other than ENOENT.</span>
     <span class="s0">*/</span>
    <span class="s1">isFile(filePath: string): Promise&lt;boolean&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Checks if a directory exists.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{string} dirPath The path to the directory to check.</span>
     <span class="s0">* </span><span class="s2">@returns </span><span class="s0">{Promise&lt;boolean&gt;} A promise that resolves with true if the</span>
     <span class="s0">*    directory exists or false if it does not.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{Error} If the operation fails with a code other than ENOENT.</span>
     <span class="s0">*/</span>
    <span class="s1">isDirectory(dirPath: string): Promise&lt;boolean&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Creates a directory recursively.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{string} dirPath The path to the directory to create.</span>
     <span class="s0">* </span><span class="s2">@returns </span><span class="s0">{Promise&lt;void&gt;} A promise that resolves when the directory is</span>
     <span class="s0">*   created.</span>
     <span class="s0">*/</span>
    <span class="s1">createDirectory(dirPath: string): Promise&lt;</span><span class="s3">void</span><span class="s1">&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Deletes a file or empty directory.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{string} fileOrDirPath The path to the file or directory to</span>
     <span class="s0">*   delete.</span>
     <span class="s0">* </span><span class="s2">@returns </span><span class="s0">{Promise&lt;void&gt;} A promise that resolves when the file or</span>
     <span class="s0">*   directory is deleted.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{TypeError} If the file or directory path is not a string.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{Error} If the file or directory cannot be deleted.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{Error} If the file or directory is not found.</span>
     <span class="s0">*/</span>
    <span class="s3">delete</span><span class="s1">(fileOrDirPath: string): Promise&lt;</span><span class="s3">void</span><span class="s1">&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Deletes a file or directory recursively.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{string} fileOrDirPath The path to the file or directory to</span>
     <span class="s0">*   delete.</span>
     <span class="s0">* </span><span class="s2">@returns </span><span class="s0">{Promise&lt;void&gt;} A promise that resolves when the file or</span>
     <span class="s0">*   directory is deleted.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{TypeError} If the file or directory path is not a string.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{Error} If the file or directory cannot be deleted.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{Error} If the file or directory is not found.</span>
     <span class="s0">*/</span>
    <span class="s1">deleteAll(fileOrDirPath: string): Promise&lt;</span><span class="s3">void</span><span class="s1">&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Returns a list of directory entries for the given path.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{string} dirPath The path to the directory to read.</span>
     <span class="s0">* </span><span class="s2">@returns </span><span class="s0">{AsyncIterable&lt;HfsDirectoryEntry&gt;} A promise that resolves with the</span>
     <span class="s0">*   directory entries.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{TypeError} If the directory path is not a string.</span>
     <span class="s0">* </span><span class="s2">@throws </span><span class="s0">{Error} If the directory cannot be read.</span>
     <span class="s0">*/</span>
    <span class="s1">list(dirPath: string): AsyncIterable&lt;HfsDirectoryEntry&gt;;</span>
    <span class="s0">/**</span>
     <span class="s0">* Returns the size of a file.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{string} filePath The path to the file to read.</span>
     <span class="s0">* </span><span class="s2">@returns </span><span class="s0">{Promise&lt;number|undefined&gt;} A promise that resolves with the size of the</span>
     <span class="s0">*  file in bytes or undefined if the file doesn't exist.</span>
     <span class="s0">*/</span>
    <span class="s1">size(filePath: string): Promise&lt;number | undefined&gt;;</span>
    <span class="s1">#private;</span>
<span class="s1">}</span>
<span class="s0">/**</span>
 <span class="s0">* A class representing a file system utility library.</span>
 <span class="s0">* </span><span class="s2">@implements </span><span class="s0">{HfsImpl}</span>
 <span class="s0">*/</span>
<span class="s3">export class </span><span class="s1">NodeHfs </span><span class="s3">extends </span><span class="s1">Hfs </span><span class="s3">implements </span><span class="s1">HfsImpl {</span>
    <span class="s0">/**</span>
     <span class="s0">* Creates a new instance.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{object} [options] The options for the instance.</span>
     <span class="s0">* </span><span class="s2">@param </span><span class="s0">{Fsp} [options.fsp] The file system module to use.</span>
     <span class="s0">*/</span>
    <span class="s1">constructor({ fsp }?: {</span>
        <span class="s1">fsp?: Fsp;</span>
    <span class="s1">});</span>
<span class="s1">}</span>
<span class="s3">export const </span><span class="s1">hfs: NodeHfs;</span>
<span class="s3">export </span><span class="s1">type HfsImpl = </span><span class="s3">import</span><span class="s1">(</span><span class="s4">&quot;@humanfs/types&quot;</span><span class="s1">).HfsImpl;</span>
<span class="s3">export </span><span class="s1">type HfsDirectoryEntry = </span><span class="s3">import</span><span class="s1">(</span><span class="s4">&quot;@humanfs/types&quot;</span><span class="s1">).HfsDirectoryEntry;</span>
<span class="s3">export </span><span class="s1">type Fsp = </span><span class="s3">typeof </span><span class="s1">nativeFsp;</span>
<span class="s3">export </span><span class="s1">type Dirent = </span><span class="s3">import</span><span class="s1">(</span><span class="s4">&quot;fs&quot;</span><span class="s1">).Dirent;</span>
<span class="s3">import </span><span class="s1">{ Hfs } from </span><span class="s4">&quot;@humanfs/core&quot;</span><span class="s1">;</span>
<span class="s3">import </span><span class="s1">nativeFsp from </span><span class="s4">&quot;node:fs/promises&quot;</span><span class="s1">;</span>
</pre>
</body>
</html>