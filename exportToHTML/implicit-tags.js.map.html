<html>
<head>
<title>implicit-tags.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #080808;}
.s1 { color: #067d17;}
.s2 { color: #1750eb;}
.s3 { color: #0037a6;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
implicit-tags.js.map</font>
</center></td></tr></table>
<pre><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;../../../src/server/lib/implicit-tags.ts&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { NEXT_CACHE_IMPLICIT_TAG_ID } from '../../lib/constants'</span><span class="s3">\n</span><span class="s1">import type { FallbackRouteParams } from '../request/fallback-params'</span><span class="s3">\n</span><span class="s1">import { getCacheHandlerEntries } from '../use-cache/handlers'</span><span class="s3">\n</span><span class="s1">import { createLazyResult, type LazyResult } from './lazy-result'</span><span class="s3">\n\n</span><span class="s1">export interface ImplicitTags {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* For legacy usage, the implicit tags are passed to the incremental cache</span><span class="s3">\n   </span><span class="s1">* handler in `get` calls.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readonly tags: string[]</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Modern cache handlers don't receive implicit tags. Instead, the implicit</span><span class="s3">\n   </span><span class="s1">* tags' expirations are stored in the work unit store, and used to compare</span><span class="s3">\n   </span><span class="s1">* with a cache entry's timestamp.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* Note: This map contains lazy results so that we can evaluate them when the</span><span class="s3">\n   </span><span class="s1">* first cache entry is read. It allows us to skip fetching the expiration</span><span class="s3">\n   </span><span class="s1">* values if no caches are read at all.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readonly expirationsByCacheKind: Map&lt;string, LazyResult&lt;number&gt;&gt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const getDerivedTags = (pathname: string): string[] =&gt; {</span><span class="s3">\n  </span><span class="s1">const derivedTags: string[] = [`/layout`]</span><span class="s3">\n\n  </span><span class="s1">// we automatically add the current path segments as tags</span><span class="s3">\n  </span><span class="s1">// for revalidatePath handling</span><span class="s3">\n  </span><span class="s1">if (pathname.startsWith('/')) {</span><span class="s3">\n    </span><span class="s1">const pathnameParts = pathname.split('/')</span><span class="s3">\n\n    </span><span class="s1">for (let i = 1; i &lt; pathnameParts.length + 1; i++) {</span><span class="s3">\n      </span><span class="s1">let curPathname = pathnameParts.slice(0, i).join('/')</span><span class="s3">\n\n      </span><span class="s1">if (curPathname) {</span><span class="s3">\n        </span><span class="s1">// all derived tags other than the page are layout tags</span><span class="s3">\n        </span><span class="s1">if (!curPathname.endsWith('/page') &amp;&amp; !curPathname.endsWith('/route')) {</span><span class="s3">\n          </span><span class="s1">curPathname = `${curPathname}${</span><span class="s3">\n            </span><span class="s1">!curPathname.endsWith('/') ? '/' : ''</span><span class="s3">\n          </span><span class="s1">}layout`</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">derivedTags.push(curPathname)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return derivedTags</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a map with lazy results that fetch the expiration value for the given</span><span class="s3">\n </span><span class="s1">* tags and respective cache kind when they're awaited for the first time.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function createTagsExpirationsByCacheKind(</span><span class="s3">\n  </span><span class="s1">tags: string[]</span><span class="s3">\n</span><span class="s1">): Map&lt;string, LazyResult&lt;number&gt;&gt; {</span><span class="s3">\n  </span><span class="s1">const expirationsByCacheKind = new Map&lt;string, LazyResult&lt;number&gt;&gt;()</span><span class="s3">\n  </span><span class="s1">const cacheHandlers = getCacheHandlerEntries()</span><span class="s3">\n\n  </span><span class="s1">if (cacheHandlers) {</span><span class="s3">\n    </span><span class="s1">for (const [kind, cacheHandler] of cacheHandlers) {</span><span class="s3">\n      </span><span class="s1">if ('getExpiration' in cacheHandler) {</span><span class="s3">\n        </span><span class="s1">expirationsByCacheKind.set(</span><span class="s3">\n          </span><span class="s1">kind,</span><span class="s3">\n          </span><span class="s1">createLazyResult(async () =&gt; cacheHandler.getExpiration(...tags))</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return expirationsByCacheKind</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export async function getImplicitTags(</span><span class="s3">\n  </span><span class="s1">page: string,</span><span class="s3">\n  </span><span class="s1">url: {</span><span class="s3">\n    </span><span class="s1">pathname: string</span><span class="s3">\n    </span><span class="s1">search?: string</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">fallbackRouteParams: null | FallbackRouteParams</span><span class="s3">\n</span><span class="s1">): Promise&lt;ImplicitTags&gt; {</span><span class="s3">\n  </span><span class="s1">const tags: string[] = []</span><span class="s3">\n  </span><span class="s1">const hasFallbackRouteParams =</span><span class="s3">\n    </span><span class="s1">fallbackRouteParams &amp;&amp; fallbackRouteParams.size &gt; 0</span><span class="s3">\n\n  </span><span class="s1">// Add the derived tags from the page.</span><span class="s3">\n  </span><span class="s1">const derivedTags = getDerivedTags(page)</span><span class="s3">\n  </span><span class="s1">for (let tag of derivedTags) {</span><span class="s3">\n    </span><span class="s1">tag = `${NEXT_CACHE_IMPLICIT_TAG_ID}${tag}`</span><span class="s3">\n    </span><span class="s1">tags.push(tag)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Add the tags from the pathname. If the route has unknown params, we don't</span><span class="s3">\n  </span><span class="s1">// want to add the pathname as a tag, as it will be invalid.</span><span class="s3">\n  </span><span class="s1">if (url.pathname &amp;&amp; !hasFallbackRouteParams) {</span><span class="s3">\n    </span><span class="s1">const tag = `${NEXT_CACHE_IMPLICIT_TAG_ID}${url.pathname}`</span><span class="s3">\n    </span><span class="s1">tags.push(tag)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">tags,</span><span class="s3">\n    </span><span class="s1">expirationsByCacheKind: createTagsExpirationsByCacheKind(tags),</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[</span><span class="s1">&quot;getImplicitTags&quot;</span><span class="s0">,</span><span class="s1">&quot;getDerivedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;pathname&quot;</span><span class="s0">,</span><span class="s1">&quot;derivedTags&quot;</span><span class="s0">,</span><span class="s1">&quot;startsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;pathnameParts&quot;</span><span class="s0">,</span><span class="s1">&quot;split&quot;</span><span class="s0">,</span><span class="s1">&quot;i&quot;</span><span class="s0">,</span><span class="s1">&quot;length&quot;</span><span class="s0">,</span><span class="s1">&quot;curPathname&quot;</span><span class="s0">,</span><span class="s1">&quot;slice&quot;</span><span class="s0">,</span><span class="s1">&quot;join&quot;</span><span class="s0">,</span><span class="s1">&quot;endsWith&quot;</span><span class="s0">,</span><span class="s1">&quot;push&quot;</span><span class="s0">,</span><span class="s1">&quot;createTagsExpirationsByCacheKind&quot;</span><span class="s0">,</span><span class="s1">&quot;tags&quot;</span><span class="s0">,</span><span class="s1">&quot;expirationsByCacheKind&quot;</span><span class="s0">,</span><span class="s1">&quot;Map&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheHandlers&quot;</span><span class="s0">,</span><span class="s1">&quot;getCacheHandlerEntries&quot;</span><span class="s0">,</span><span class="s1">&quot;kind&quot;</span><span class="s0">,</span><span class="s1">&quot;cacheHandler&quot;</span><span class="s0">,</span><span class="s1">&quot;set&quot;</span><span class="s0">,</span><span class="s1">&quot;createLazyResult&quot;</span><span class="s0">,</span><span class="s1">&quot;getExpiration&quot;</span><span class="s0">,</span><span class="s1">&quot;page&quot;</span><span class="s0">,</span><span class="s1">&quot;url&quot;</span><span class="s0">,</span><span class="s1">&quot;fallbackRouteParams&quot;</span><span class="s0">,</span><span class="s1">&quot;hasFallbackRouteParams&quot;</span><span class="s0">,</span><span class="s1">&quot;size&quot;</span><span class="s0">,</span><span class="s1">&quot;tag&quot;</span><span class="s0">,</span><span class="s1">&quot;NEXT_CACHE_IMPLICIT_TAG_ID&quot;</span><span class="s0">],</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;+BAyEsBA;;;eAAAA;;;2BAzEqB;0BAEJ;4BACW;AAqBlD,MAAMC,iBAAiB,CAACC;IACtB,MAAMC,cAAwB;QAAC,CAAC,OAAO,CAAC;KAAC;IAEzC,yDAAyD;IACzD,8BAA8B;IAC9B,IAAID,SAASE,UAAU,CAAC,MAAM;QAC5B,MAAMC,gBAAgBH,SAASI,KAAK,CAAC;QAErC,IAAK,IAAIC,IAAI,GAAGA,IAAIF,cAAcG,MAAM,GAAG,GAAGD,IAAK;YACjD,IAAIE,cAAcJ,cAAcK,KAAK,CAAC,GAAGH,GAAGI,IAAI,CAAC;YAEjD,IAAIF,aAAa;gBACf,uDAAuD;gBACvD,IAAI,CAACA,YAAYG,QAAQ,CAAC,YAAY,CAACH,YAAYG,QAAQ,CAAC,WAAW;oBACrEH,cAAc,GAAGA,cACf,CAACA,YAAYG,QAAQ,CAAC,OAAO,MAAM,GACpC,MAAM,CAAC;gBACV;gBACAT,YAAYU,IAAI,CAACJ;YACnB;QACF;IACF;IACA,OAAON;AACT;AAEA;;;CAGC,GACD,SAASW,iCACPC,IAAc;IAEd,MAAMC,yBAAyB,IAAIC;IACnC,MAAMC,gBAAgBC,IAAAA,gCAAsB;IAE5C,IAAID,eAAe;QACjB,KAAK,MAAM,CAACE,MAAMC,aAAa,IAAIH,cAAe;YAChD,IAAI,mBAAmBG,cAAc;gBACnCL,uBAAuBM,GAAG,CACxBF,MACAG,IAAAA,4BAAgB,EAAC,UAAYF,aAAaG,aAAa,IAAIT;YAE/D;QACF;IACF;IAEA,OAAOC;AACT;AAEO,eAAehB,gBACpByB,IAAY,EACZC,GAGC,EACDC,mBAA+C;IAE/C,MAAMZ,OAAiB,EAAE;IACzB,MAAMa,yBACJD,uBAAuBA,oBAAoBE,IAAI,GAAG;IAEpD,sCAAsC;IACtC,MAAM1B,cAAcF,eAAewB;IACnC,KAAK,IAAIK,OAAO3B,YAAa;QAC3B2B,MAAM,GAAGC,qCAA0B,GAAGD,KAAK;QAC3Cf,KAAKF,IAAI,CAACiB;IACZ;IAEA,4EAA4E;IAC5E,4DAA4D;IAC5D,IAAIJ,IAAIxB,QAAQ,IAAI,CAAC0B,wBAAwB;QAC3C,MAAME,MAAM,GAAGC,qCAA0B,GAAGL,IAAIxB,QAAQ,EAAE;QAC1Da,KAAKF,IAAI,CAACiB;IACZ;IAEA,OAAO;QACLf;QACAC,wBAAwBF,iCAAiCC;IAC3D;AACF&quot;</span><span class="s0">,</span><span class="s1">&quot;ignoreList&quot;</span><span class="s0">:[</span><span class="s2">0</span><span class="s0">]}</span></pre>
</body>
</html>